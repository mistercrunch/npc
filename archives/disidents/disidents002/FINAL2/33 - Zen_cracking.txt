 
                        - D I S I D E N T S - H A C K  J O U R N A L -

                                          Numero 2
                                           XXXIII



                 TITLE:Ideologías, Zen Cracking 
                 AUTHOR: SparK
                 DISIDENTS ARGENTINA 2001


-------------------------------------------------------------------------------------------------
---------------------------[ INDICE Ideologías, Zen Cracking ]-----------------------------------
-------------------------------------------------------------------------------------------------              				
----[0x01 Introducción                                                                          -
----[0x02 Ideologías y Zen Cracking                                                             -
----[0x03 ¿Que es el Zen Cracking?                                                              -
----[0x04 Entrando en el territorio crack                                                       -
----[0x05 Un ejemplo                                                                            - 
-------------------------------------------------------------------------------------------------




-------------------------------------------------------------------------------------------------
-------------------------------[0x01-* Introducción]---------------------------------------------
-------------------------------------------------------------------------------------------------
Antes que nada, quiero agradecer al grupo el cual pertenezco, por dejar exponer mis conocimientos
, que con esfuerzo he elaborado en estos años, la práctica, la paciencia, el esfuerzo llevan a 
aprender, la voluntad de autosuperacion, y las metas definidas te permiten hacer lo que quieras
, el tiempo solo es una ilusión.


-------------------------------------------------------------------------------------------------
---------------------------[0x02-* Ideologías y Zen Cracking]------------------------------------
-------------------------------------------------------------------------------------------------

Mi pensamiento más profundo es SER, de ahí lo demás surge, YO SOY con el conocimiento, "pienso 
luego existo", decía alguien por ahí....

Quizás tu lector, te preguntes que tendrá que ver estas intros con el cracking?, ¿que tiene que 
ver con reventar programas?, es algo que va más allá de eso, más allá de una acción, es un efecto
de una causa más profunda, la causa es el aprendizaje, "revertir" situaciones para llegar 
al principio y luego volver por el principio al final.
Por ejemplo, yo cuando era chico tomaba los laberintos y empezaba desde la meta hacia el 
principio, para mi era más fácil llegar al principio, porque?, si es el mismo laberinto?, si, es 
el mismo, pero la perspectiva es otra, primero la manera de enfrentarlo es por atrás, el 
laberinto esta preparado para enfrentarlo de adelante, desde el principio fue pensado para que 
el que empiece, le cueste llegar al final; pero no fue pensado para el camino "inverso".
Justamente esto se trata este pequeño y humilde articulo, a veces las cosas desde otro punto de 
vista, no son tan difíciles como parecen.

Existe por ahí en algún lugar de la red, sitios, que llevan al cibernauta a mundos insospechados,
por ejemplo una persona que llevó a generar una revolución en muchas mentes (incluso la mía), 
cuando el cracking todavía era un tabú solo practicado por gurús de la informática, "elite", fue 
ORC, le llamaban ORC THE RED CRACKER, una personalidad muy particular, una persona que no 
revelaba nada de su identidad, pero sin embargo te hacía sentir el verdadero aroma de las cosas, 
mirando el laberinto desde el final.
Quizás nadie sepa quien fué, o quien es, de repente el desapareció, pero dejó un tesoro 
increiblemente grande, un conjunto de tutoriales que dejó boquiabierto a la scene del crack, una 
revolución no solo en información técnica sino, filosófica, un punto de ver las cosas 
excepcionalmente extraño y a la vez perfecto.

Luego lo acompañaron muchas personas inspiradas en él, una de las más importantes quizás FRAVIA,
una persona muy inteligente, que respetó la filosofía de ORC y la implantó en el diseño de su web,
un diseño fino, casi medieval.



-------------------------------------------------------------------------------------------------
--------------------------[0x03-* ¿Que es el Zen Cracking?]--------------------------------------
-------------------------------------------------------------------------------------------------


El Zen Cracking fue una manera que tuvo ORC de llamarle a la busqueda de ruptura de las rutinas 
de proteccion de un software, el decia: "Just feel the code" (solo siente el codigo), es una 
manera de decir, usa tus sentidos para localizar el punto de ruptura, ademas de tu cabeza ;) , 
con esa frase fue mas allá de toda lógica, usa tu capacidad, tu cerebro, pero también usa tu 
intuición para encontrar ese punto sagrado, es una filosofía de vida mas que nada, es una forma 
de actuar frente a un problema, usa tu cerebro y tu intuición, todo esta mezclado, todo esta en 
todo...

Así un día yo encontré sus estudios sobre cracking, y entendí una verdad más importante que el 
0 o el 1, encontre toda una filosofía mas profunda en esto del cracking, donde luego FRAVIA, 
presento sus estudios sobre REALITY CRACKING, en la que ORC antes ya había hecho mención; yo 
inclusive he probado lo de sentir el código y sorpresivamente ha funcionado; porque generalmante 
cuando se programa en algún lenguaje estructurado, o RAD (rapid application development), por 
ejemplo DELPHI o VISUAL BASIC, el compilador genera el código de máquina de manera muy parecida 
en cada programa. 

Por ejemplo, cuando se agregan radiobuttons, que son esos botones redonditos donde al hacer click
quedan marcados con un puntito, hay una serie de subrutinas en ASM (ensamblador) que el 
compilador genera por defecto para todos los programas, o sea el compilador compila la logica del
programa, mientras que la lógica de los componentes esta pre-programada, por lo tanto, se 
presenta un PATRÓN de instrucciones, que cuando has leído muchos tutoriales y código, te das 
cuenta a que pertenecen.

Por Ejemplo:

una aplicación tiene un conjunto de botones, ejemplo calculadora entonces, al compilar esa 
aplicacion, en ASM queda algo asi:

sumar:	mov eax, 00676468	<----mueve un dato a eax, que puede ser el identificador del button
	cmp eax, 0		<----lo compara para ver si es el presionado
	jne restar		<----si no es asi verá si se clikeo el botón de restar




restar:  mov eax, 00584766
	 cmp eax,0
	 jne multiplicar        <----y asi hasta encontrar el botón

entonces este patrón de instrucciones es entendible cuando se tiene cierta practica, luego de 
esta logica de los componentes se encuentra la lógica del programa mismo, como por ejemplo, para
aquellos que sepan pascal:

if (numeroqueentroelusuario = numeroreciencalculado) then
	registered:=true;
if (registered=true) then
	createwindow('Registered');
else
	createwindow('Unregistered');

Fácilmente se sabe que el usuario entra un número y un nombre de usuario, y el programa calcula 
dependiendo del nombre de usuario el número de registro (variable numeroreciencalculado), luego 
lo chequea con el que ingreso el usuario (variable numeroqueentroelusuario), y de ahi el usuario
es registrado o no, luego cambia todo el aspecto del programa, ya sea activar botones, sacar 
mensajes insistentes, o hacer infinitos los limites de tiempo para el uso del programa, 
dependiendo de la protección del programa.

Entonces, diferenciamos la lógica del programa, (la lógica que utilizó el programador), de la de
la lógica de los componentes, ahí vemos donde pueden estar los puntos de ruptura, primero viendo 
los PATRONES de código, luego el chequeo de los datos ingresados y los calculados por el
programa, son muy fáciles de encontrar.

Ojo, no todo es tan fácil, puede que no solo sea un chequeo, a veces se encuentran "espejos", 
que vuelven a chequear lo mismo en distintos lugares del programa, esas son protecciones 
anti-crackers ;*)
Luego también el código puede ser guardado en un archivo temporal y borrarse de la memoria, para 
luego chequearlo a través del disco, por eso hay que estar atento y conocer las funciones de 
escritura, con sus llamados a interrupción correspondientes, luego las API de Windows que son 
llamadas para aplicar las distintas técnicas.



-------------------------------------------------------------------------------------------------
--------------------------[0x04-* Entrando en territorio crack]----------------------------------
-------------------------------------------------------------------------------------------------




Bueno, creo que no todo es teoría sino también es un poco (bastante) de práctica, podemos poseer
hoy en día todos los conocimientos que queramos obtener, gracias a Internet, pero lo importante 
es absorverlos y que pasen a formar parte de vos mismo, la ingeniería inversa debe ser centro de
tu vida..... pero no de tu existencia.
Hay muchas formas de satisfacer el hambre de un programa, por ejemplo, la más fácil y rápida es 
la de parchear el código, mas cerca todavía parchear los saltos decisivos, las tomas de 
decisiones que llevarán al programa a "transformarse en..." me refiero a poder cambiar el rumbo 
de las cosas siempre para bien.
Otra forma es una pesca del serial válido, para eso se usan los debuggers (ver lección uno) como
el soft-ice (wwww.numega.com, de antemano, no respondo sobre warez). La pesca del serial válido,
es cuando se ingresa un código no válido, ej: 12345 y luego se sigue el cálculo del serial válido
que generalmente lo genera el programa runtime a partir de un nombre o email o algún dato que el 
usuario pueda ingresar ej:

nombre de usuario: SparK
numero de registro: 12345

bueno, seguramente el número de registro válido no será 12345 sería un milagro ;*)
El chiste es seguir el código válido con el debugger paso a paso, viendo como se pasa de un 
registro a oro sumandose, dividiéndose, o multiplicándose hasta luego hacer la comparacion:


cmp regval,noval ó   cmp noval,regval
jne xxxxxx       ó   je xxxxxxxxxxxx
jz xxxxxx        ó   jnz xxxxxxxxxxx

y llamar al cartel o lo que sea, aviso que los chequeos pueden ser muy diversos,estos son ejemplos
más comunes, por eso, lo principal es entender el ensamblador, tratar de ver más allá del patrón 
de letras y números, para ver el significado de las cosas.

Antes cuando no era tan abierto el mundo de la informática, existían los verdaderos CODERS, los gurús, 
leían el código ASCII y comprendían las instrucciónes automaticamente, codificaban en ensamblador 
porque eran libres, eran expertos en criptografía, ellos hicieron posibles esto de hoy, muchos son bien 
conocidos, otros ni los conocen pero están, como el aire que no ven pero respiran.

Entonces en un momento cuando el chequeo se haga antes de saltar la ventana, el serial válido se 
comparará con el no válido, introducido por nosotros, lo que se puede hacer, es mirar los dos registros
y ver en cual está el nuestro, entonces, sabremos que en el otro está el válido para nuestro registro, 
con ESE dato que ingresamos (en este caso spark); nos salimos del debugger, y ingresamos el código 
copiado y voilá!!, registrado!.

Otro método es una KeyGen (key generator, generador de la llave o código), es estudiar el algoritmo de 
creación del número de serie válido, para crear un programa aparte que genere los números de serie 
válidos a partir de los datos que le demos.

Por ejemplo: si el programa pide nombre de usuario y numero de registro, el keygen pedira el nombre de 
usuario y generara el numero de registro automaticamente.

¿Como funciona esto?

Al haber estudiado con anterioridad el algoritmo y haber programado una keygen, es lo mismo que extraer
el código encargado de hacer eso del programa principal y generar un nuevo programa, que solo hará el 
trabajo de generar el código válido, sólo que ahora será bueno y lo mostrará.

Luego existen infinidades de protecciones y rupturas de ellas, com por ejemplo las famosas llaves en 
el registro de windows, que el programa introduce, o las llaves introducidas en un archivo ini, o las 
mochilas (los dispositivos que se conectan en puerto paralelo o serie y aportan datos al programa 
principal ejecutandose y este los verifica, sabiendo si el programa es original o pirateado), las 
mochilas suelen estudiarse, y se genera un loader (cargador), que en runtime hace de mochila y brinda 
a la aplicación los datos requeridos por la misma haciéndole creer que es la original.

Más adelante veremos un tutorial con ejemplos, dedicados a cada protección, trataré de usar crackmes, 
llamados programas de entrenamiento que son de libre modificación y distribución, pero nunca programas 
comerciales, ya que sería ilegal modificar código propietario, y no quiero entrar en esas acciones que 
no hacen otra cosa que promover el delito y no formar a programadores más concientes de la seguridad 
de un programa.





-------------------------------------------------------------------------------------------------
------------------------------[0x05-* Un ejemplo]------------------------------------------------
-------------------------------------------------------------------------------------------------



Bueno, a modo de ejemplo empezaré a crackear (o intentar al menos ;) un crackme del team 
area54cracks, cuya web es:
 
http://saigon.vietmedia.com/area54cracksv2/index2.htm 
             o en  
http://galeon.com/disidentsweb/CrkMeViz-4.zip

en la sección crackmes, se encuentran varios crackmes, yo elegí uno llamado: CrkMeV4, ocupa 16KB, 
y pensé  que sería útil para los que recién empiezan... no se asusten XD

bueno, lo bajamos y lo ejecutamos , vemos que nos dice, que tiene una limitacion a 8 ejecuciones, 
y abajo posee un contador en negrita, la primera vez es un 0, luego si salimos del programa, y 
volvemos a ejecutarlo, podemos observar que el contador se incrementa a 1, y asi sucesivamente 
hasta llegar a 8, cuando nos dice que la aplicación expiró.

Si vemos un poco el menu, podemos observar que está el típico menu Archivo y luego si hacemos 
click en él encontramos opciones que son Acerca de..., Salir y Registrar.

Acerca de....  : si hacemos click vemos que nos informa sobre el programa y nos dice a nombre de 
quien esta registrado y con que nro de registro, normalmente dice <Unregistered>, pero nosotros 
cambiaremos ese estado ;-D

Salir : hagan click y se comerán un incremento en el contador XDD , para el que no entendió el 
chiste malo que acabo de hacer, Salir nos saca del programa...

Registrar : si hacemos click en él nos lleva a otra ventanita donde debemos poner un nombre de 
usuario y un nro de serie, y si es correcto nos registra, sino seguiremos limitados :P

pongamos como user name, SparK , pongan ahora 123456, en el campo serial number; como vemos el 
botón registrar sigue desactivado, esto es curioso, bueno, en vez de SparK, pongamos SparKrisp, 
si van tecleando despacio, cuando ponen la letra nro 6 correspondiente a la "r", el botón se 
registrar activa, con lo que nos lleva a pensar, de que la subrutina que genera el número de 
serie válido necesita 6 letras en el campo User Name, curioso.... pero no importa ;) .
De todas formas, no atacaremos ahí....


-----------------------------------------------------------------------------------------------------
                             Manos a la obra
-----------------------------------------------------------------------------------------------------

Primero, necesitaremos un desensamblador, si han leído el otro artículo de esta ezine, sabrán o 
tendrán una idea de lo que ya es, bueno para aquellos que no lo leyeron, es un programa que toma 
el código ASCII de un archivo y lo decodifica, transformándolo a instrucciones en Ensamblador, 
un poco mas entendible para el ser humano.

Utilizaremos por ahora uno sencillo el W32Dasm, que lo pueden conseguir en la página de karpoff 
(welcome.to/karpoff), en la seccion herramientas, bajen todo lo de W32dasm que encuentren ahí, 
todo es útil.

Ahora instalemos el W32Dasm, luego ejecutemoslo, y debemos ir al menu File, luego a Open, u open 
file, no me acuerdo bien la opcion, pero es la opcion para abrir el archivo a desensamblar.

Elegimos el crackme para que lo desensamble y esperamos (NOTA antes de desensamblarlo, deben haber 
salido del programa a crackear, sinó les saltara en el W32Dasm que el crackme está siendo usado 
por otro programa) , luego de un rato aparecerá una maraña de cosas tremendas, eso se llama 
Ensamblador :)

Ya que tenemos todo el meollo, veamos por donde empezamos, primero miremos un poco el encabezado
que nos muestra del programa, si observamos bien, encontraremos algo asi:


			+++++++++++++++++++ IMPORTED FUNCTIONS ++++++++++++++++++
			Number of Imported Modules =    1 (decimal)

			   Import Module 001: MSVBVM50.DLL
			+++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Bien, vemos que hay un módulo que el archivo importa para poder funcionar, este contiene 
procesos y funciones, es una librería, si observamos el nombre del archivo vemos que contiene 
estas siglas:   M      S    V     B    V    M    5   0

M : Micro
S : Soft
V : Visual
B : Basic
V : no se :P tampoco interesa.
M : Module
5 : version 5
0 : punto 0


en total vemos que el programa necesita una librería de Microsoft Visual Basic 5.0, por lo tanto 
vemos que está hecho en Visual Basic, entonces debemos tener ciertas precauciones....

Primero, si hacemos click en uno de los botones del W32Dasm llamado String Ref. (strings de 
referencias),veremos "VB5!", o algo así, muy pocas cosas, en realidad ahí tienen que aparecer,
la mayoría de las cadenas de caracteres que contiene el programa, por ejemplo "User Name", 
"Limitado a 8 ejecuciones"  , etc. Si ejecutan el crackme verán las strings que les 
acabo de nombrar; entonces para eso les dije que se bajaran todos los W32Dasm de la página 
de Karpoff, porque hay uno que es para desensamblar programas hechos con  Visual Basic.

Ahora si, ejecutamos el otro W32Dasm, y desensamblamos el mismo programa; ahora hacemos click de 
nuevo en String References, y Voilá! vemos los strings de la aplicación.

Les explicaré en detalle que hice y porque lo hice así, primero busque el que dice:
                        
                      "CrkMeViZ Registrado!!"

Debe haber en algún lado, algo que haga que aparezca este bendito mensaje en la pantalla, y encontraremos 
ese punto.

Si hacemos doble click en ese string nos llevará al lugar en donde se encuentra, es mas o menos este:



* Possible StringData Ref from Code Obj ->"  CrkMeViZ Registrado!! "  <-------------- ACAAAA!!! 
                                  
:004064A8 6814364000     push 00403614	<---- Este push guarda la cadena
					CrkMeViZ Registrado!! en la pila del sistema
:004064AD 56             push esi
:004064AE 8B16           mov edx, dword ptr [esi]
:004064B0 FF5254         call [edx+54]

Yo les comenté, anteriormente en este artículo, que antes del mensaje siempre hay algo que define que 
mensaje irá, entonces busquemos un salto, antes en este artículo vimos saltos como JE, JNE, JMP, etc, 
después explicaré cada salto y como funciona.

si miramos unos renglones mas arriba en el W32Dasm encontraremos esto:


:00406477 FF1578914000            Call dword ptr [00409178]
:0040647D 6685C0                  test ax, ax
:00406480 0F847F010000            je 00406605
:00406486 8B7D08                  mov edi, dword ptr [ebp+08]
:00406489 8B857CFDFFFF            mov eax, dword ptr [ebp+FFFFFD7C]
:0040648F 57                      push edi
:00406490 FF9004030000            call dword ptr [eax+00000304]

* Reference To: MSVBVM50.__vbaObjSet, Ord:0000h
                                  |
:00406496 8B1D64914000            mov ebx, dword ptr [00409164]
:0040649C 8D8D24FEFFFF            lea ecx, dword ptr [ebp+FFFFFE24]
:004064A2 50                      push eax
:004064A3 51                      push ecx
:004064A4 FFD3                    call ebx
:004064A6 8BF0                    mov esi, eax

si observamos bien, veremos un salto.....

para el que no lo vió aún es este:


			:00406480 0F847F010000            je 00406605      

je = jump equal, salta si es igual

entonces, una conclusión, lo contrario de je es jne = jump if not equal (saltar si no es igual), 
pensemos un poco, el programa nos dice que estamos registrados si NO salta, porque si salta, 
comprobemoslo haciendo doble click en la linea en donde esta el salto, el programa saltara y 
pasara por alto el mensaje, con lo que se ejecutara la subrutina como usuario no registrado; 
lo único que tenemos que hacer es revertir las cosas para que NO salte, entonces revertamos 
las cosas, el salto que debería ir es jne, ahora llegó el momento de el cambio, el código en 
hexadecimal compilado para esta intrucción es:

	0F847F010000    el desplazamiento, o sea en el lugar en donde se encuentra la instrucción 
                        es 00406480, y necesitaremos el offset, entonces haremos algo, hagan click 
                        en la linea en donde esta el salto y miren en la barra inferior del programa, 
                        la que está abajo de todo, si se fijan bien dira offset: 5880 , este número 
                        es muy importante, ya que nos dirá la ubicación exacta del salto.

Ahora que ya tenemos el salto debemos saber el código en hexadecimal del salto que revierte al
salto original.

0F847F010000   este es el salto original. yo les podría dar un trabajo de investigación pero seré 
               bueno ;)

0F  7F010000   es solamente la instruccion je 00406605 compilada, sin el je, o sea que el je es 
               igual al 84, y el jne es igual al 85 asi que lo único que debemos cambiar es el 84 
               por el 85 y quedaría asi la instruccion:


			:00406480 0F857F010000            jne 00406605      

¿fácil no?

Ahora, debemos encontrar un editor hexadecimal, yo les recomiendo el Hiew, aunque hay otras 
utilidades muy buenas también, no estoy seguro si el Hiew (hacker view) lo tiene karpoff, pero 
busquen que está por todos lados.

Una vez ejecutado el Hiew, buscan el crackme y luego le dan enter para que les muestre el 
código ASCII, ahora aprietan F4 dos veces seguidas rapido y les mostrará el código hexadecimal 
del archivo, luego aprietan F5 y ponen el offset , que en este caso sería 5880, y llegarán al 
salto 0F847F010000, ahora, apretar F3 (NOTA antes de apretar F3, no debe estar el W32Dasm abierto
mostrando el crackme en pantalla, porque sinó les mostrará que el archivo no se puede editar, 
simplemente porque está siendo usado por otra aplicación), cambiar el 84 por el 85, apretar F9 
(update) y listo. FELICITACIONES!!!

Ahora salgan de ahí apretando Escape, y ejecuten el crackme, si hicieron todo bien les dirá,
 que están registrados. ;-D


Un pequeño detalle, ya que la hacemos, hagamosla bien o sino nada; si se fijan en la opcion 
acerca de... 
del menu archivo, aparecera <Unregistered>, bueno, hay una forma de que aparezca tu nombre ahí y 
un número de serie cualquiera.

Primero debemos conseguir el Regmon (register monitor), y bajense por las dudas, lo necesitaran, 
el Filemon (file monitor), los dos están en la página de Karpoff, y en castellano.

Ahora, ejecutemos el Regmon primero, luego, ejecutemos el crackme, y veremos que en regmon 
suceden un monton de cosas.....

La explicación de esto es la siguiente:

Una forma de que el programa cuente de manera fácil y eficiente, las veces que lleva ejecutándose
el programa, asi reinicies la máquina, es llevando un control de la cantidad de veces en algún 
lado, y ese lugar es el registro  de Windows, asi que si miran bien ahora el regmon les mostrará
algo así:



0 Explorer  QueryValue	HKCU\AppEvents\Schemes\Apps\.Default\CCSelect\.current\(Default)	NOTFOUND	
1 Explorer  OpenKey	HKCR\TypeLib	SUCCESS	hKey: 0xC29C0AB0	
2 Explorer  OpenKey	HKCR\TypeLib\{50A7E9B0-70EF-11D1-B75A-00A0C90564FE}		SUCCESS	hKey: 0xC29BFA10	
3 Explorer  OpenKey	HKCR\TypeLib\{50A7E9B0-70EF-11D1-B75A-00A0C90564FE}\1.0		SUCCESS	hKey: 0xC29BEB60	
4 Explorer  OpenKey	HKCR\TypeLib\{50A7E9B0-70EF-11D1-B75A-00A0C90564FE}\1.0\0	SUCCESS	hKey: 0xC29BEB20	
5 Explorer  OpenKey	HKCR\TypeLib\{50A7E9B0-70EF-11D1-B75A-00A0C90564FE}\1.0\0\win32	SUCCESS	hKey: 0xC29BEAE0	
6 Explorer  CloseKey	HKCR\TypeLib\{50A7E9B0-70EF-11D1-B75A-00A0C90564FE}\1.0\0\win32	SUCCESS		
7 Explorer  CloseKey	HKCR\TypeLib\{50A7E9B0-70EF-11D1-B75A-00A0C90564FE}\1.0\0	SUCCESS		
8 Explorer  OpenKey	HKCR\TypeLib\{50A7E9B0-70EF-11D1-B75A-00A0C90564FE}\1.0\0	SUCCESS	hKey: 0xC29BEB20	
9 Explorer  QueryValue	
.
.
.
.
y así hasta que vemos algo como esto:

548 Crkmeviz	QueryValueEx	HKCU\Software\VB and VBA Program Settings\ODBC\Register\Serial number	NOTFOUND
.
.
551 Crkmeviz	QueryValueEx	HKCU\Software\VB and VBA Program Settings\ODBC\Register\User Name	NOTFOUND	.
.
.
564 Crkmeviz	SetValueEx	HKCU\Software\VB and VBA Program Settings\ODBC\Register\Counter	SUCCESS	"5"		

Antes  que nada miren la última línea, dice claramente " counter success "5" " cuando yo estaba 
ejecutando el programa, lo había ejecutado 4 veces, y en la quinta, guardó un 5 en el registro de
Windows, ¿que hace con esto?, simple, cuando el programa se ejecuta la próxima vez, se fija 
primero en orden de aparición, busca si hay un "Serial number" y un "User Name" y luego como no 
encuentra ninguno de esos dos, dice "entonces este programa está sin registrar todavía, entonces
busco el contador y lo actualizo" y efectivamente busca el número en el registro y lo actualiza, 
en mi caso es 5 el nuevo valor.

Por lo tanto, el programa mismo nos pide que pongamos el nombre de usuario y el número de serie, 
asi que hagámosle caso ;) veamos, tenemos la llave: 

			HKCU\Software\VB and VBA Program Settings\ODBC\Register\Serial number

y la llave:

			HKCU\Software\VB and VBA Program Settings\ODBC\Register\User Name

Ahora vayamos a Inicio, Ejecutar, y tipeamos regedit, luego, buscamos HKCU, que suele ser la 
segunda rama empezando de arriba hacia abajo, luego click en software, y buscamos VB and .... , 
luego click ODBC, luego Register y por último.... no están ni Serial number ni User Name!!!! que
horrooor!! :) mejor, vamos a la otra ventana y hacemos click en el botón derecho y luego click en
Nuevo, valor de la cadena y ponemos tal cual como dice el crackme: Serial number, listo ahora 
hacemos doble click en  el ítem que acabamos crear y ponemos cualquier número, listo, ahora 
hacemos lo mismo y ponemos como nombre: User Name, se crea otro ítem y ponemos ahora un Nombre 
de usuario, pongan algo más de 6 letras acuerdense porque el programa por algún motivo chequea 
por 6 letras, también podríamos crackear la cantidad de letras, pero..... nah! dejemosslo así :).

Listo ahora, salgamos del regedit y ejecutemos el crackme, y luego hacer click en el menu archivo, 
acerca de.... y veremos lo que pusimos en el regedit ¿lindo no? 


Un truco:
---------
Si aún no crackeamos la aplicación, y tenemos por ejemplo 5 usos, podemos volverlos a 0 usos,
solamente poniendo en el valor 	

	HKCU\Software\VB and VBA Program Settings\ODBC\Register\Counter   el valor 0, es solo un tip ;)


Conclusión:
-----------

Ahora han visto en una pequeñísima proporción de lo que es cracking, lo que es la ingeniería 
inversa, y lo útil que es para depurar soft, que muchas veces los compiladores RAD cargan en 
nuestra pobre aplicación, funciones y chequeos innecesarios.
Este crackme se podría haber atacado de mil maneras, si alguno de ustedes se les ocurre, 
inténtenlo, y luego me dicen.



Saludos,
	SparK

				

---------------------------------------------------
-       CONTACTA CONMIGO O CON EL TEAM            -
---------------------------------------------------
- NICK:     Spark                                 -
- CARGO:    Director de Disidents Argentina       -    
- MAIL:     spark@kernel.net             	  -	
- TEAM:     disidents@yahoo.es                    -
---------------------------------------------------

                                                          Disidents Argentina  2001 2° edicion.
-------------------------------------------------------------------------------------------------

                     @@-------               @@---------------  
		    @@----                  @@---------       @@@@@@@@@  
		   @@--     @@@@@--        @@-- @@@@@       @     @@  @@@@@@@@@@@@@@@@@@@@@@@@@@@@-------
              @@@@@@    @@ @@      @@ @@@@@@-  @@      @@@ @    @@  @@-----------------------------
             @@        @@ @@@@@   @@ @@---    @@@@@@   @@ @@   @@  @@@@@--------------
            @@        @@     @@  @@ @@ -     @@       @@ @@   @@      @@----------
             @@@@@@@ @@  @@@@@@ @@   @@@@@@@ @@@@@@@ @@  @@ @@	     @@--------
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@------
