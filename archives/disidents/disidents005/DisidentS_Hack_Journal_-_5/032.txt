SPO_-_Securizacion_Por_Oscuridad_by_FREEBRAIN_-_Disidents_Journal_5                     

                            
                     -+-| DisidentS Hack Journal #5 |-+-









   ______________________________________________________________________
  |                                                                      |
  | -+- Titulo_____: SPO - Securizacion Por Oscuridad                    |
  | -+- Autor______: FreeBrain                                           |
  | -+- E-Mail_____: freebrain@unionnewbies.net                          |
  | -+- Team_______: DisidentS España - http://disidents-team.cjb.net    |
  |______________________________________________________________________|





               "la potencia sin control..no sirve de nada"
>>------------------------------------------------------------------------<<



----------------------------------------------------------------------------
----------------------------------------------------------------------------

.==========================================================================.
|===========~ INDICE ~======================================================
|===========================================================================
|=~ 1 Introduccion                                                         |
|=~ 2 Conceptos "clave"                                                    |
|=~ 3 Simulacion de una intrusion "comun"                                  |
|=~ 4 Explicacion de la SPO                                                |
|=~ 5 Aplicacion de SPO (sendmail/linux)                                   |
|=~ 6 Contra-SPO                                                           |
|=~ 7 Despedida                                                            |
|=~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~=.
======================================================~ INDICE ~============
============================================================================


-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 1 Introduccion. ~=============================================
|===========================================================================

Bueno, pues aqui estamos otra vez, como siempre dandole salsa al tema de la 
seguridad :-)

En este pequeño texto explicare un poco una tecnica de securizacion (de la 
cual no voy a hablar extensamente ahora) que he visto aplicada hoy por hoy 
en muy pocos sitios, y que puede llegar a ser enormemente efectiva, sobre todo 
para combatir a los tan odiados socialmente "script kiddies". Ciertamente es 
una tecnica un tanto "ruda" (por asi decirlo) pero que puede dar unos 
resultados bastante satisfactorios (a mi modo de ver, claro). 

Entre otras cosas, me he permitido el lujo de darle un nombre, la he llamado 
"SPO" (Securizacion Por Obscuridad) por razones las cuales veremos mas 
adelante :-) 

La verdad, no se si esta tecnica se reconoce como tal, si tiene otro nombre, 
o que ... he investigado relativamente poco sobre ella (no hace falta 
informarse demasiado para comprenderla y llevarla a cabo, si tenemos los 
conocimientos necesarios, claro). En el caso de que fuese asi, ruego 
perdoneis mi ignorancia respecto al tema :-P

En principio los "requerimientos" (conocimientos, mas bien) que necesitaremos 
para llevar a cabo la SPO son relativamente pocos, aunque la verdad, con un 
poco de sentido comun y habiendo leido este articulo (eso espero, que sirva 
para algo) no hara falta informarse mucho. 

En principio es recomendable tener unos conocimientos minimos en redes (sobre 
todo en cuanto a servidores) para estar centraditos en el tema, y unos 
conocimientos minimos en lenguajes de programacion con estructura de "script" 
(vease Pascal, C, Perl, etc), los justos para editar un codigo sin armar una 
catastrofe :-)

Bueno, antes de entrar en materia, decir que esta "tecnica" la he visto 
aplicada en sitios bastante "gordos" (no voy a decir ahora cuales, pero 
creedme que son sitios gordos) por lo cual debo suponer que hay realmente
poca documentacion sobre ella, y que es una tecnica un tanto "profesional".

Pues bueno, con eso empezamos a entrar en calor :-)


-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 2 Conceptos basicos. ~========================================
|===========================================================================

Bien, ahora vamos con los conceptos basicos necesarios para aprovechar a
fondo el tema y bla bla bla.

Supongo que algunos ya los tendreis requete-sabidos, pero bueno, repasar
no engorda :-P

1- Conocimientos en jerarquia cliente-servidor (redes)
Principalmente hemos de centrarnos en lo que es un servidor. Dicho asi un
poco "ampliamente" un servidor es un ordenador que pone a disposicion de
unos "hipoteticos clientes" una serie de servicios. 

Vamos a profundizar en los servicios, que es lo que basicamente nos interesa.
Un servicio (tambien conocido en la jerga UNIX como "daemon") es un programa
ejecutado en un proceso background del sistema que generalmente suele ser un
servidor de red, o sea, un programa que provee un cierto y especifico servicio.

De ese modo, podemos hablar de un daemon (servicio) de web (http), tambien
llamado HTTPD (HTTP Daemon), de un servicio de correo saliente (smtpd), etc.

Estos servicios basicamente (refiriendome de cara a la red) ponen un socket
en "escucha", es decir, dejan un puerto en escucha que puede recibir 
conexiones "entrantes" de otros ordenadores (los clientes). Mediante ese
socket "en escucha" el servidor recibe peticiones de clientes, por ejemplo,
en el caso de que sea un servidor HTTP (Web), la peticion de que nos
muestre una web (el comando HTTP GET, si mal no recuerdo). Bien, por
aqui iran los tiros ;-)

2- OpenSource (programacion)
Lo primero expliquemos un poco que es esto del OpenSource. En principio el 
OpenSource es una "filosofia" basada en la aportacion del codigo fuente de
los programas al publico, y en la permision al publico de que este modifique
el codigo fuente a su antojo, sin ningun tipo de restriccion al respeto 
(ojo, no caigamos en el tipico error de que "codigo libre = programa gratis",
porque no es asi).

Nosotros (para llevar a cabo la SPO) nos aprovecharemos de esta ventaja de
disponer del codigo fuente, para realizar la SPO :-) 

Un apunte: opensource != linux, si bien es cierto que el Sistema Operativo
GNU/Linux es de codigo abierto, no quiere decir que todo el codigo abierto
sea Linux (y programas para Linux), si no que existen aplicaciones de codigo
abierto para multitud de plataformas (si, entre ellas Windows :-) 

Cierto es que en este articulo (tanto la aplicacion de la SPO, como todo lo
demas) se ejemplifica en Linux, pero ello no quiere decir que no se pueda
llevar a cabo de la misma manera por ejemplo en Windows. Otra cosa es que
fuese mas o menos complicado, pero yo ahi ya no me meto.

3- Programacion en C
Bien, no os asusteis los que no sepais C, no es necesario ser un guru del
C para aprovechar este articulo, ni mucho menos, yo no lo soy y he podido
(o al menos lo he intentado) explicarlo :-P

Debemos tener claros sobre todo el concepto de string, usea, una cadena de
texto usada por una determinada funcion/comando, nada mas, lo cual lo 
veremos mucho mas claro sobre la practica. Y tambien el concepto de variable,
aunque no es tan importante.

Hombre, la verdad es que creo que pueden ser utiles unas pequeñas nociones
de C, pero vamos, en principio seria suficiente con saber interpretar el
codigo y listo ;-)

4- Estructura general de un programa en C (sources)
Normalmente (en la mayoria de programas "grandes") nos encontramos
principalmente una serie de archivos, en el caso de Linux lo frecuente es
encontrarnos:
- Archivo "configure" (ejecutable)
- Archivo "Makefile" (no ejecutable)
- Una serie de archivos *.c (no ejecutables)
- Archivos *.h (no ejecutables)
Y a mayores, la documentacion, README's, To-Do's, etcetera. Ojo! No todos 
los programas han de contener un "configure" y un "Makefile" necesariamente,
pueden prescindir de "configure", y usar un bash script (*.sh generalmente)
que cumpla la funcion del "configure" y del "Makefile".

De todos modos lo que principalmente nos interesa son los archivos *.c, en
estos archivos esta contenido el CODIGO FUENTE del programa, es decir, el
codigo del programa en el lenguaje en el que originalmente fue escrito,
todo a nuestra disposicion para que jugueteemos con el ;-)

Normalmente, suele haber varios archivos *.c, y varios *.h, los *.h son 
"librerias" para los *.c, generalmente en los *.h no solemos encontrar lo
que nos interesa, pero no esta de mas tenerlos en cuenta :-)

En cada uno de esos archivos *.c se encuentra "una parte" del codigo del
programa. Por lo normal los nombres de estos archivos *.c suelen ser 
bastante explicativos, y automaticamente nos dan una referencia de que
parte del codigo del programa esta contenida en ellos, otras veces, hemos
de abrir el archivo (con un editor de texto, cualquiera, nano, vi, notepad)
y en los comentaros (texto entre /* */) nos dice que es lo que hace esa
"parte" del codigo.

Nota para despistados: sources = fuentes (codigo fuente)!

Bueno, pues ahora si ya con todo esto, creo que tenemos de sobra para 
ponernos en marcha, asique ... alla vamos!


-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 3 Simulacion de una intrusion "comun". ~======================
|===========================================================================

Ahora plantearemos el problema.

Todo empieza cuando un hipotetico atacante intenta asaltar nuestro host. 
Cierto es que puede hacerlo de muchas maneras, y que puede detectar un fallo
en nuestro sistema de muchas maneras, pero aqui nos centraremos en una (que
es la que basicamente "defiende" la SPO).

Bien, un atacante puede estar deseoso de encontrar una maquina con un 
determinado fallo y asaltarla, y venir con escaneres de vulnerabilidades
(una especie de exploits, solo que en vez de lanzar el exploit contra una
determinada ip especificada por el atacante, lo hacen contra todo un rango
de ip's especificado por el susodicho atacante. En este caso, la SPO (como
ya veremos mas tarde) nos serviria de bien poco, pero esta el otro caso, el
caso mas "comun", efectivamente como ya habras adivinado, el tipico intruso
que selecciona el host y le pasa un escaner.

Pongamonos en la piel de un intruso, imaginemos que queremos "hackear" este
host: freebrain-sec.disidents.org

Bien, lo primero que hariamos seria sacar nuestro escaner (en este caso nmap)
y escanear el host para ver que servicios hay corriendo en el:


[freebrain@dhcppc0 freebrain]$ nmap freebrain-sec.disidents.org

Starting nmap V. 3.00 ( www.insecure.org/nmap/ )
Interesting ports on freebrain-sec.disidents.org (6.6.6.6):
(The 1601 ports scanned but not shown below are in state: closed)
Port       State       Service
25/tcp     open        smtp

Nmap run completed -- 1 IP address (1 host up) scanned in 1 second


Bien, el escaneo nos muestra que el host que queremos atacar solo esta 
corriendo un servicio (daemon), en este caso, un servidor de correo saliente.
Pero claro ... necesitamos saber mas ... necesitamos saber que servidor
es ese ... para ello tiramos de netcat (en este caso, se puede usar telnet,
o cualquier otro programa del estilo, o simplemente un escaner que nos 
muestre el "debug" de las conexiones en pantalla ;-):


[freebrain@dhcppc0 freebrain]$ netcat freebrain-sec.disidents.org 25
220 freebrain-sec.disidents.org ESMTP Sendmail 8.11.6/8.11.6; Sun, 11 Jan 2004 01:56:57 -0500
quit
221 2.0.0 freebrain-sec.disidents.org closing connection

(como veis abrimos con el netcat una conexion al host por el puerto 25,
que es el puerto del smtp :-P)

Bien, ahora ya tenemos una poderosa y valiosa informacion en nuestras
manos, a parte de saber que el host corre un servidor SMTP, sabemos que 
servidor es en concreto, un Sendmail, y tambien su version. En este caso,
una version con unas cuantas vulnerabilidades importantes ya descubiertas,
si el bueno del administrador del host no ha parcheado ... podriamos explotar
esas vulnerabilidades (no tendriamos mas que buscar el exploit, lo cual
tardariamos unos 10-15 minutos en encontrar). O si no, si tenemos algun 
0day casualmente para esa version se Sendmail, pues entonces ya no habria
parche que valga, nos lo cargariamos fijo.

Bien ... ahora reflexionemos en lo que hemos hecho ... en donde esta la 
clave? Pues ni mas ni menos que en la informacion que hemos recibido, piensa,
sin esa informacion ... como hubieramos sabido que exploit/vulnerabilidad
utilizar? Pues simplemente, no lo hubiesemos sabido ;-)

Efectivamente los propios daemons del host nos regalan toda esa valiosa
informacion, apenas tenemos que molestarnos un poco en conseguirla.

El otro metodo para "asaltar" hubiera sido que nuestro host estuviera en el
medio de un rango escaneado por un potencial atacante, suponiendo que el
atacante poseyera un escaner de vulnerabilidades en Sendmail, concretamente
de las vulnerabilidades que afectan a la version 8.11.6, pero claro, ese
hubiera sido un caso bastante diferente al que he expuesto aqui :-P

Volviendo a nuestro caso concreto, si el host no nos hubiese regalado esa
informacion acerca de el, que alternativa nos hubiera quedado? llamar al
administrador y preguntarle por el software que usa en su servidor? coger
decenas (o cientos) de exploits para distintos servidores de correo SMTP y
distintas versiones a ver si uno funcionaba? Como veis, son opciones un
tanto "estupidas" y rudas, y en la mayoria de los casos, muy poco factibles.

Por tanto, casi podemos afirmar que la clave de esa "intrusion" (la que he
"expuesto") ha sido la informacion revelada por el host, es decir, que toda
la intrusion dependia de que informacion revelase el host, y de si la revelaba
o no ... pues entonces, ataquemos directamente a la raiz del problema!


-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 4 Explicacion de la SPO. ~====================================
|===========================================================================

Ya sabemos cual es la raiz del problema: la informacion que recibe un 
atacante acerca de nuestra maquina, en concreto, de nuestros servicios.

Como solucionamos este problemazo? Pues facilisimo, impidiendo que el 
hipotetico atacante reciba tal informacion ... y como? Pues simplemente:
NO dandosela.

Ahora se entiende el nombre que le di a esta tecnica de securizacion, no?
Securizacion Por Oscuridad, es decir, que el atacante "no vea nada" (no
reciba informacion), de modo que no pueda buscar algun exploit para
atacarnos, puesto que no tendria ni la mas minima idea de que exploit
utilizar. Bien, pues con esto, veamos los pasos importantes a seguir a
la hora de aplicar esta tecnica:

1- Auditado de los daemons a securizar
Lo primero es abrir un netcat mismo al daemon que queremos securizar, y nos
anotamos la "string" (cadena de texto) en la cual nos revela la informacion.

2- Busqueda de la string en el codigo fuente
Ahora el siguiente paso es tratar de localizar esa string en el codigo fuente.
Un dato a tener en cuenta es que generalmente el nombre del daemon (en el
caso expuesto anteriormente, "sendmail" y la version , en el caso de antes,
"8.11.6" se suelen almacenar por separado en distintas variables, por tanto
es mejor que vayamos a una palabra o palabras seguras, en el caso expuesto
anteriormente, "ESMTP". Tambien hay que tener presente que esta solo se 
encontrara en algun archivo *.c, con lo cual restringimos enormemente la 
busqueda.

Para buscar un determinado texto en un conjunto de archivos podemos usar
herramientas tales (en Linux) como KFind o grep ;-)

3- Modificacion de la misma
Ahora que ya tenemos la string localizada, la cambiamos por el texto que
queramos, por ejemplo "ESMTP Secured by FreeBrain (DisidentS)".

4- Compilamos el programa
Ahora vamos a compilarlo, si lo hemos hecho bien, no deberia dar ningun error
el compilador (por lo general el gcc). En el caso de que hubieramos metido
la pata en algun detalle, el mismo compilador nos indicaria donde diablos
se encuentra el error, por tanto, solo seria proceder a repararlo ;-)
Como compilamos el programa? Pues generalmente haciendo "./configure",
"gmake" y "gmake install", pero esto depende del programa que sea, claro.

5- Arrancamos el programa y comprobamos
Ahora arrancamos el programa (generalmente "./programa") y hacemos lo de
antes, netcat <nuestro_host> <puerto>, y vemos si hemos cambiado lo correcto
y como ha quedado, en nuestro caso, deberia respondernos algo asi como
"ESMTP Secured by FreeBrain (DisidentS)", que es lo que elegimos ponerle :-P

Ahora ya por mucho que "escaneasen" nuestro daemon, ya no podrian saber
que daemon es ni que version :-)

Bien, a esta string que da la informacion sobre el daemon se le suele llamar
"greet", o "greet message" (algo asi como "mensaje de bienvenida"), y 
se situa generalmente en una funcion que llaman "Connect()", o "Connection()",
o similar, que es una funcion que se "activa" cuando un remoto cliente
establece conexion con el daemon (en este caso, es el atacante mediante el
netcat).

Esto (el tema de encontrar y modificar la string) nos puede llevar mas o
menos tiempo, en funcion del programa. De todos modos, no deberia llevar mas
de 30 minutos en ningun caso :-P

Bueno, principalmente ahora podemos destacar unos objetivos que cubre la
SPO:

1- "Securizacion" de daemons
Unicamente aplicable a daemons (no se si en algun caso se podria aplicar
al Sistema Operativo, pero me imagino que si, seria cuestion de investigar
un poco ;-)

2- Disuasion de atacantes "selectivos"
Evidentemente esta tecnica tiene un notorio poder de "disuasion" frente
a atacantes selectivos, es decir, que "seleccionen" sus host "victima", y
que evidentemente apliquen el metodo de "intrusion" que explicamos antes,
o al menos, uno de caracteristicas similares :-P

A que me refiero con disuasion? A que en cuanto el atacante observe que
la maquina no le ofrece apenas informacion, se le ocurrira que seguramente
sea muy dificil de asaltar y muy segura, de modo que si no le van los retos,
seguramente desista en sus intentos y abandone la tentativa.

Fuera de esto, hay que destacar que la SPO NO esta orientada a "corregir"
vulnerabilidades, si nuestros daemons estan afectados por alguna vuln, van
a seguir estandolo aunque apliquemos SPO o no, la diferencia es que sera
"mas dificil" asaltarlos si hemos aplicado SPO, de modo que efectivamente
reducimos el riesgo de ataques/intrusiones, y por tanto podemos afirmar
que es una tecnica de securizacion :-)

Tambien la SPO nos despeja un poco con todo el tema de las actualizaciones,
aplicando SPO no tenemos que estar tan pendientes de tener todo bien
actualizadito y al dia, aunque evidentemente, siempre sigue siendo muy
recomendable actualizar (recuerda el caso de los escaneres de vulns...).

Por ultimo, puede constituir una gran defensa contra 0day's, puesto que
cuando se trata de exploit's 0day no suelen haber escaneres de vulns para
los fallos 0day, por tanto, casi que tenemos todas las de ganar frente
a intrusiones mediante vulnerabilidades 0day.

NOTA: Un exploit/vulnerabilidad 0day es un exploit o una vulnerabilidad que
todavia no se ha hecho publica, es decir, que nadie la ha publicado, ya sea
en listas de correo como BugTraq, en webs de seguridad como SecurityFocus
o PacketStormSecurity, o se haya hecho publica directamente a la empresa
fabricante del software afectado o a alguna organizacion tipo CERT.


-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 5 Aplicacion de SPO (sendmail/linux). ~=======================
|===========================================================================

Ha llegado el momento de poner en practica lo que hemos aprendido sobre
SPO :-)

Vamos a securizar un sendmail, en nuestro caso, sendmail 8.11.6 para Linux.
Para ello, seguiremos los pasos propuestos anteriormente, de modo que 
empezamos con la primera parte, "auditado del daemon a securizar".

1- Auditado del daemon a securizar
Nos bajamos el sendmail 8.11.6 para Linux de aqui:
ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.11.6.tar.gz
Ahora, con el sendmail en nuestro poder, procedemos a descomprimirlo:


[freebrain@freebrain-sec freebrain]$ tar xvfz sendmail.8.11.6.tar.gz


Ahora una vez descomprimido, compilamos el sendmail, para ello usamos los
comandos (sin comillas): "./configure", "gmake" y "gmake install".

Ahora con el sendmail compilado, lo arrancamos (hay que arrancarlo de manera
adecuada, como servicio y tal) y conectamos al host por el puerto 25. El
mensaje que obtendriamos seria el mismo que el greet de antes:


[freebrain@freebrain-sec freebrain]$ netcat freebrain-sec.disidents.org 25
220 freebrain-sec.disidents.org ESMTP Sendmail 8.11.6/8.11.6; Sun, 11 Jan 2004 01:56:57 -0500
quit
221 2.0.0 freebrain-sec.disidents.org closing connection


Vale, bien, ya sabemos cual es la string. Ahora como decia antes, las palabras 
"Sendmail" y "8.11.6" seguramente se encuentren cada una definidas como 
variables en alguna parte del codigo, por tanto las suprimiriamos de una
posible busqueda, al igual que la fecha (lo cual es evidente) y demas.
Principalmente nos quemados con "ESMTP", que es la unica palabra de la string
que no tiene pinta de estar variabilizada (aunque yo aqui me he sacado el
cuento un poco de la manga, no siempre tiene porque ser asi ;-)

Bueno, pues nos vamos a la siguiente parte de la SPO.

2- Busqueda de la string en el codigo fuente
Bien, ya tenemos nuestra palabreja ("ESMTP") para buscar, recordamos que 
deberia de estar contenida en un archivo *.c, asique nos disponemos a buscar 
en la carpeta del sendmail :-)

Para buscar evidentemente usamos grep o kfind (por ejemplo), o lo que mas os 
guste :-P

NOTA: En este caso nos movemos al subdirectorio "sendmail" que se encuentra
dentro del directorio "principal" del sendmail (sendmail.8.11.6), puesto
que es el directorio donde estan los archivos principales de codigo fuente.

Una vez hallamos lanzado el grep o el KFind encontramos varios archivos 
"sospechosos" de contener tal string, nos vamos al srvrsmtp.c y lo abrimos
con un editor de texto. Cual editor sirve, podeis usar vi, emacs, nano,
notepad, etc etc, todo vale con tal de que tenga una opcion para buscar texto.

Ahora con el archivo abierto con el editor de texto, buscamos nuestra cadena,
en este caso, alguna que contenga "ESMTP".

NOTA: Es importante recordar que "ESMTP" se encontrara directamente en el
comando que se envie con el demas texto (... ESMTP Sendmail 8.11.6 ...) y
no en otro sitio del codigo como una variable :-P (recordamos que "Sendmail"
y "8.11.6" seguramente esten variabilizados y por ello no se encuentren 
junto a "ESMTP" en la string como tal ;-)

3- Modificacion de la string

Despues de la busqueda, nos encontramos esto:


	/* output the first line, inserting "ESMTP" as second word */
	expand(SmtpGreeting, inp, sizeof inp, e);
	p = strchr(inp, '\n');
	if (p != NULL)
		*p++ = '\0';
	id = strchr(inp, ' ');
	if (id == NULL)
		id = &inp[strlen(inp)];
	if (p == NULL)
		snprintf(cmdbuf, sizeof cmdbuf,
			 "%s %%.*s ESMTP%%s", greetcode);
	else
		snprintf(cmdbuf, sizeof cmdbuf,
			 "%s-%%.*s ESMTP%%s", greetcode);
	message(cmdbuf, (int) (id - inp), inp, id);

	/* output remaining lines */
	while ((id = p) != NULL && (p = strchr(id, '\n')) != NULL)
	{
		*p++ = '\0';
		if (isascii(*id) && isspace(*id))
			id++;
		(void) snprintf(cmdbuf, sizeof cmdbuf, "%s-%%s", greetcode);
		message(cmdbuf, id);
	}
	if (id != NULL)
	{
		if (isascii(*id) && isspace(*id))
			id++;
		(void) snprintf(cmdbuf, sizeof cmdbuf, "%s %%s", greetcode);
		message(cmdbuf, id);
	}

	protocol = NULL;
	sendinghost = macvalue('s', e);
	gothello = FALSE;
	gotmail = FALSE;
	for (;;)
	{
		/* arrange for backout */
		(void) setjmp(TopFrame);
		QuickAbort = FALSE;
		HoldErrs = FALSE;
		SuprErrs = FALSE;
		LogUsrErrs = FALSE;
		OnlyOneError = TRUE;
		e->e_flags &= ~(EF_VRFYONLY|EF_GLOBALERRS);

		/* setup for the read */
		e->e_to = NULL;
		Errors = 0;
		FileName = NULL;
		(void) fflush(stdout);

		/* read the input line */
		SmtpPhase = "server cmd read";
		sm_setproctitle(TRUE, e, "server %s cmd read", CurSmtpClient);
# if SASL


Bien, pues ahora nos fijamos en:


		snprintf(cmdbuf, sizeof cmdbuf,
			 "%s %%.*s ESMTP%%s", greetcode);


Bien, como podemos suponer, "snprintf" es una funcion para la impresion de
texto en pantalla. Luego, "cmdbuf", "sizeof", etc, son parametros de la
funcion, al igual que "greetcode", en este caso, arrays (variables) y demas
para la string :-)

Lo que se imprime en pantalla es lo que va entre "", las %s y demas hacen
referencia a los parametros de snprintf dichos antes ;-)

Bien, pues ahora procedemos a borrar tales parametros (puesto que YA NO
son necesarios para nosotros ;-) y los cambiamos por lo nuestro, de modo
que quedaria asi:


snprintf("<nuestro mensaje de bienvenida>");


Ahora, por ejemplo, ponemos como "mensaje de bienvenida" lo siguiente:

ESMTP Secured by DisidentS Hack Team

De modo que queda esto:


snprintf("ESMTP Secured by DisidentS Hack Team");


Ahora guardamos los cambios efectuados y estamos listos para pasar al siguiente
paso de la SPO :-)

4- Compilado del programa

Bien, ya tenemos el cambio hecho, pues recompilemos el programa para que el
cambio se aplique. Para ello, igual que antes, "./configure", "gmake" y "gmake
install".

Ahora que ya tenemos el programa compilado (y si no ha dado errores) nos vamos
al ultimo paso de la SPO para terminar.

Si da algun error, hemos de revisar los cambios aplicados, a ver si hemos 
metido la pata en algun sitio. Normalmente el compilador ya nos dice donde
se encuentra el fallo pertinente y que tipo de fallo es, asique no tendremos
ningun problema (creo yo :-).

NOTA: Hemos de distinguir entre "warning" y "error", cuando nos da "error"
significa que el programa NO VA a compilar por culpa de un error grave, sin
embargo si nos da "warning", simplemente sera un aviso o advertencia de que
hemos hecho una "chapucilla", de modo que aunque no se corrijan los warning,
tampoco es preocupante (ojo, no estoy diciendo que no haya que corregirlos
ni mucho menos ;-)

5- Arrancamos el programa y comprobamos

Ahora, arrancamos el SMTP (como daemon, ojo) y comprobamos si la string que
devuelve cuando se abre una conexion a el es la que especificamos. Si lo
hemos hecho todo bien, quedaria asi:


[freebrain@freebrain-sec freebrain]$ netcat freebrain-sec.disidents.org 25
220 ESMTP Secured by DisidentS Hack Team
quit
221 2.0.0 freebrain-sec.disidents.org closing connection


Bien, si ha sido asi, podemos sentirnos satisfechos porque el daemon de ESMTP
ha sido securizado con exito ;-)


-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 6 Contra-SPO. ~===============================================
|===========================================================================

Hasta aqui hemos estado hablando de securizacion y de como securizar un host
(mediante la SPO), pero no hemos hablado de como romper la seguridad en un
host (usea, de como saltarnos esta tecnica) donde se haya aplicado SPO.

Bien, en principio ya sabemos que la tecnica del simple escaneo no nos vale.
Pero, a no ser que se haya aplicado SPO a todos los mensajes (strings) que
identifiquen al daemon (nosotros solo la hemos aplicado a los de "bienvenida")
podremos buscar estas strings en el daemon, a fin de saber que daemon es y
poder concretar un marco de versiones mas o menos estrecho (ojo, esto 
requiere bastante trabajo, trabajo que la mayoria de "kiddies" no estarian
dispuestos a realizar ;-).

Por ejemplo, imaginemos que el host freebrain-sec.disidents.org tiene un
servidor HTTP corriendo, y que ha sido securizado mediante SPO en la string
de bienvenida, vale, lo escaneamos y no obtenemos nada, pero como muchos
HTTPd's muestran mensajes "identificatorios" en las paginas 404 por ejemplo,
pues cojemos un navegador y vamos a un directorio que no exista, ejemplo:

http://freebrain-sec.disidents.org/lalala

Si es un apache, por ejemplo, y no ha sido securizado mediante SPO totalmente,
deberia salir en esa "pagina":


Not Found

The requested URL /lalala was not found on this server.
Apache/2.0.48 Server at freebrain-sec.disidents.org Port 80


Bien, ya hemos obtenido la version y tipo de servidor sin tener que indagar
mas, en este caso hemos tenido suerte :-)

Otras veces es mas dificil, y tendremos que remitirnos a buscar y buscar hasta
poder llegar a una buena conclusion, pero, como ya os imaginareis, eso ya
corre por vuestra cuenta, asique ... a investigar!


-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 7 Despedida. ~================================================
|===========================================================================

Pues esto ha tocado a su fin. Como siempre, espero que hayas disfrutado con
este texto, que hayas aprendido, y que en definitiva, no hayas perdido el
tiempo.

Anticipadamente pido disculpas por los errores cometidos (que seguro que han
sido un monton). Tambien quiero agradecer y dedicar este trabajo a toda la
gente que me apoya, me conoce, etc, y que me aguantan a diario:

b-04, SparK, Tresde, JeNdArK, {V|s|oN}, w3ndig0, oKuPa, ipy, ^DeLtA^, VaMp|r3,
[[AKira]], RandomLoG, Nusky, MaSTeRiX, Pangea-X, |_Tr0mP4s, y a todos los 
que me dejo en el tintero (ya sabeis quienes sois ;-), a toda la gente de
DisidentS y a toda la administracion de IRC-Phoenix.Org. Un saludo a todos y
feliz año nuevo.

Y sobre todo, gracias a ti tambien por haber invertido tu tiempo leyendo
esto ;-)

PD: Ah si, y disculpas por el retraso en la entrega del articulo XDDDD (que
se deberia haber sacado la ezine un dia antes de que yo entregase este
articulo, si que es soy un caso, siempre todo en el ultimo momento XD).

-E0f-

"Smoke on the water!"


-----------------------------------------------------------------------------
Mail del grupo disidents@yahoo.com
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
                                     0
                                   X0 0X
                                     S
