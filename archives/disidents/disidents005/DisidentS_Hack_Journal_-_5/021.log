[021]_Charla_sobre_Finite_Automaton_by_SparK_DisidentS_Hack_Journal_-_5



                        -+-| DisidentS Hack Journal #5 |-+-







  ____________________________________________________________________
 |                                                                    |
 |  -+- Titulo_____: Finite Automaton - Dandole personalidad al code  |
 |  -+- Autor______: S-P-A-R-K (Editor)                               |
 |  -+- E-Mail_____: dsd_cracking@portadaauga.org                     |
 |  -+- Team_______: DisidentS Argentina 2004 -  LOS FUERA DE LA LEY  |
 |  -+- KB_________:                                                  |
 |  -+- Tema_______: Charla irc sobre Finite Automaton                |
 |____________________________________________________________________|



Un dia cualquiera en #disidents!!


<S-P-A-R-K> quieren que de una charla
<S-P-A-R-K> ?
<S-P-A-R-K> alguien me esta leyendo?
<S-P-A-R-K> digan si los que me llen
<S-P-A-R-K> leen ahora
<leon01> si
<^[LoW]^> si
<Q-tron> S-P-A-R-K sobre k?
<S-P-A-R-K> minimo mas de 10
<^[LoW]^> S-P-A-R-K ahora ?
<S-P-A-R-K> sip
<^[LoW]^> sobre ...?
<S-P-A-R-K> sobre finite automaton
<S-P-A-R-K> darle personalidad al code
<Q-tron> k es eso?
<S-P-A-R-K> a trozos de code
<S-P-A-R-K> usado en los virus polimorficos, pero tb puede ser usado en la seguridad soft
<S-P-A-R-K> ok
<S-P-A-R-K> alguien de los que tienen + me leen?
<S-P-A-R-K> bueno, gracias a los que entraron
<S-P-A-R-K> por tener confianza en las tonterias que dire
<S-P-A-R-K> ;)
<S-P-A-R-K> Ok, cuando quieran empezamos
<S-P-A-R-K> ok
<S-P-A-R-K> gente
*** ^[LoW]^ sets mode: +m
<^[LoW]^> si S-P-A-R-K empieza
<S-P-A-R-K> ok
<S-P-A-R-K> aclaro una cosa
<S-P-A-R-K> este tema, fue explicado por un creador de virus de la 29a, llamado zombie
<S-P-A-R-K> pero esta aplicado sobre el tema virus
<S-P-A-R-K> yo lo explicare hacia el tema de seguridad en software
<S-P-A-R-K> o sea, anti-cracking :)
<S-P-A-R-K> empecemos por el principio
<S-P-A-R-K> z0mbie habia explicado
<S-P-A-R-K> esto para crear virus polimorficos
<S-P-A-R-K> como saben los virus polimorficos, pueden tomar distintas decisiones
<S-P-A-R-K> dependiendo de factores que se den en la computadora
<S-P-A-R-K> o sea
<S-P-A-R-K> no poseen solamente un trigger
<S-P-A-R-K> sino que poseen varios, y condicionados, de manera que sea complicado predecir 
  su proxima accion
<S-P-A-R-K> unvirus , es un programa de computadora
<S-P-A-R-K> un programa de computadora es un conjunto de instrucciones logicas
<S-P-A-R-K> que realizan una determinada accion logica en el ordenador
<S-P-A-R-K> (teoria)
<S-P-A-R-K> :)
<S-P-A-R-K> un virus, es justamente un programa
<S-P-A-R-K> con una logica
<S-P-A-R-K> un programa, de contabilidad
<S-P-A-R-K> tb es un programa
<S-P-A-R-K> con su logica
<S-P-A-R-K> por lo tanto ambos programas
<S-P-A-R-K> son programas. con todas las letras
<S-P-A-R-K> a pesar de tener funcionamientos distintos
<S-P-A-R-K> un programa, de contabilidad, es como un ciervo
<S-P-A-R-K> un animalito indefenso
<S-P-A-R-K> un virus, es como un leon
<S-P-A-R-K> en cuanto a seguridad, y dificultad en programacion
<S-P-A-R-K> son los mejores
<S-P-A-R-K> los mas optimizados,y los mas pensados
<S-P-A-R-K> un programa de contabilidad por ejemplo
<S-P-A-R-K> realiza su accion
<S-P-A-R-K> pero no esta "protegido"
<S-P-A-R-K> claro esta, podemos protegerlo con wises 
<S-P-A-R-K> upx, y demas
<S-P-A-R-K> pero tratemos de dificultar la raiz
<S-P-A-R-K> si creamos codigo complicado desde el principio
<S-P-A-R-K> realizando saltos condicionales, incondicionales
<S-P-A-R-K> utilizando etiquetas, procesos con nombres que despisten
<S-P-A-R-K> el codigo generado sera mas dificil de interpretar para un reverser
<S-P-A-R-K> si a eso le agregamos un tipo de encriptacion o proteccion
<S-P-A-R-K> sera mucho mas dificultoso de entender
<S-P-A-R-K> ahora, vamos a la parte de complicar el codigo
<S-P-A-R-K> como se puede complicar el codigo
<S-P-A-R-K> z0mbie, define a este tema, finite automaton
<S-P-A-R-K> simplemente es tener trozos de codigo con multiples acciones
<S-P-A-R-K> en base a una matriz
<S-P-A-R-K> con un algoritmo adecuado, dependiendo de ciertas variables
<S-P-A-R-K> obtenidas del sistema
<S-P-A-R-K> el algoritmo, dara valores resultantes
<S-P-A-R-K> y estos seran utilizados para localizar, otro valor en la matriz
<S-P-A-R-K> finalmente ese valor localizado
<S-P-A-R-K> dara como resultado la accion a tomar
<S-P-A-R-K> ahora como implementar esto?
<S-P-A-R-K> como preguntar por los valores?, como generar un algoritmo?
<S-P-A-R-K> con que valores rellenar la ma triz?
<S-P-A-R-K> ok, esas preguntas las trataremos de responder ahora
<S-P-A-R-K> la primer pregunta es lo + facil
<S-P-A-R-K> tenemos varias formas de hacerlo
<S-P-A-R-K> ustedes piensen en alto nivel
<S-P-A-R-K> y luego piensen como iran compiladas esas instrucciones en bajo nivel
<S-P-A-R-K> si utilizamos un lenguaje desestructurado
<S-P-A-R-K> como basic que permite etiquetas
<S-P-A-R-K> como asm
<S-P-A-R-K> podemos ir de un lado a otro
<S-P-A-R-K> sin seguir una logica directa
<S-P-A-R-K> como lo hariamos por ejemplo en pascal
<S-P-A-R-K> esto permite poder generar a bajo nivel
<S-P-A-R-K> saltos incondicionales
<S-P-A-R-K> y complicar la situacion
<S-P-A-R-K> para un reverser
<S-P-A-R-K> en alto nivel
<S-P-A-R-K> podemos utilizar if's
<S-P-A-R-K> que pregunten por cada valor
<S-P-A-R-K> tb, podemos utilizar CASE
<S-P-A-R-K> tb podemos hacerlo de una manera mas ineficiente con el fin
<S-P-A-R-K> de despistar
<S-P-A-R-K> como un for con un i desde el primer valor posible de accion a tomar
<S-P-A-R-K> hasta el ultimo
<S-P-A-R-K> con if's dentro, preguntando que valor lleva i en ese momento
<S-P-A-R-K> esto complicara la lectura a nivel interno
<S-P-A-R-K> estoy hablando a nivel ensamblador
<S-P-A-R-K> ahora como pueden, ver hay mil maneras de hacer lo mismo
<S-P-A-R-K> quizas tb, se puedan utilizar booleanas
<S-P-A-R-K> o swittches
<S-P-A-R-K> variables numericas
<S-P-A-R-K> puestas a 0 o a 1
<S-P-A-R-K> punto aparte, queda a la libre imaginacion del programador
<S-P-A-R-K> pero por otro lado, lo mejor esutilizar Cases
<S-P-A-R-K> y luego hacer saltos con etiquetas
<S-P-A-R-K> ahora, como generamos el algoritmo que dara como resultado los dos indices para 
  ubicar el valor final que esta contenido en la matriz?
<S-P-A-R-K> podemos utilizar un algoritmo
<S-P-A-R-K> que lea una posicion de memoria en un momento
<S-P-A-R-K> esa posicion de memoria, deber ser analizada con anterioridad
<S-P-A-R-K> para tener la certeza, de que en distintas maquinas, o dependiendo la cantidad 
  de procesos
<S-P-A-R-K> corriendo,
<S-P-A-R-K> el codigo de maquina q1ue haya en esa posicion, sera diferente
<S-P-A-R-K> cada vez
<S-P-A-R-K> solo asi, podemos obtener un valor casi aleatorio
<S-P-A-R-K> ok
<S-P-A-R-K> leemos el valor de la memoria
<S-P-A-R-K> y ahora, con ese valor ingresado , lo mandamos como parametro para utilizarlo 
  en el algoritmo
<S-P-A-R-K> para que se figuren
<S-P-A-R-K> obtengo valor de memoria ----> llamo algoritmo(valor) -----> obtengo indices
<S-P-A-R-K> con los indices, puedo ya ubicar
<S-P-A-R-K> el valor de accion 
<S-P-A-R-K> una vez, ubicado en la matriz el valor de la accion a tomar
<S-P-A-R-K> podemos, proceder, a hacer el chequeo de cual es el valor tomado
<S-P-A-R-K> a traves de los metodos anteriormente mencionados
<S-P-A-R-K> ok
<S-P-A-R-K> el valor obtenido de la memoria
<S-P-A-R-K> puede ser obtenido de mil maneras
<S-P-A-R-K> eso es imaginacion del programador
<S-P-A-R-K> debemos tratar de ser lo + paranoicos posible
<S-P-A-R-K> como por ejemploobtener, la cantidad de memoria libre en ese momento
<S-P-A-R-K> y sacar un calculo con ese nro, de tal manera que de un valor final
<S-P-A-R-K> pero cuando digo obtener la cantidad de memoria libre
<S-P-A-R-K> es con un una funcion que lo haga con precision
<S-P-A-R-K> porque no serviria de nada decir
<S-P-A-R-K> hay 10 mb libres
<S-P-A-R-K> no
<S-P-A-R-K> lo util es que el valor sera 10385438
<S-P-A-R-K> por ejemplo
<S-P-A-R-K> lo mas aleatorio posible
<S-P-A-R-K> lo mas caotico posible
<S-P-A-R-K> como llenamos la matriz?
<S-P-A-R-K> la matriz, puede tener valores predefinidos
<S-P-A-R-K> que sera lo mas facil y conveniente
<S-P-A-R-K> o podemos llenar la matriz en tiempo de ejecucion
<S-P-A-R-K> y luego los chequeos de los cases, se complicaran demasiado como para poder 
  chequear los valores
<S-P-A-R-K> o sea, que optemos por tener valores predeterminados
<S-P-A-R-K> de esta manera
<S-P-A-R-K> podemos obtener algo asi
<S-P-A-R-K> 1  6  9
<S-P-A-R-K> 7  3  2
<S-P-A-R-K> 8  9  4
<S-P-A-R-K> ..
<S-P-A-R-K> tenemos una matriz cuadrada
<S-P-A-R-K> de 3 x 3
<S-P-A-R-K> esos valores desencadenan cada uno 
<S-P-A-R-K> una accion dada
<S-P-A-R-K> obtenervalor;
<S-P-A-R-K> algoritmo(valor,i,j);
<S-P-A-R-K> en i, j, devuelve los indices, ojo estos no deben pasarse del tamaño de la 
  matriz
<S-P-A-R-K> para eso un chequeo antes de devolverlos, por eso, es que el tamaño de la 
  matriz debera ir predefinido tb
<S-P-A-R-K> (puede no ir predefinido pero caemos en una grave complicacion de nuevo)
<S-P-A-R-K> una vez obtenidos estos indices es muy simple
<S-P-A-R-K> accion(matriz,i,j);
<S-P-A-R-K> pasamos la matriz como parametro, con los indices
<S-P-A-R-K> e internamente el proceso
<S-P-A-R-K> hara algo parecido a esto
<S-P-A-R-K> valor:=matriz[i,j];
<S-P-A-R-K> y luego los case's o if's o booleanas
<S-P-A-R-K> if (valor = X) then
<S-P-A-R-K> case valor = X do
<S-P-A-R-K> Ó
<S-P-A-R-K> podemos usar
<S-P-A-R-K> if's primero y luego setear booleanas
<S-P-A-R-K> para simplemente complicar la lectura a bajo nivel para el reverser
<S-P-A-R-K> o sea
<S-P-A-R-K> if (valor = 9) then
<S-P-A-R-K> valor9:=true;
<S-P-A-R-K> else
<S-P-A-R-K> ...
<S-P-A-R-K> luego de todos los chequeos
<S-P-A-R-K> cases, para ver que booleana es activada
<S-P-A-R-K> entonces desarrollar una accion
<S-P-A-R-K> tomen, esto de esta forma
<S-P-A-R-K> dependiendo la accion que tomemos
<S-P-A-R-K> encriptaremos nuestro programa con distintos algoritmos
<S-P-A-R-K> blowfish, des, idea
<S-P-A-R-K> seria totalmente impredecible
<S-P-A-R-K> a no se que se puedan obtener los indices de la matriz
<S-P-A-R-K> y definir sus acciones
<S-P-A-R-K> pero pensemos algo
<S-P-A-R-K> este problema es exponencial
<S-P-A-R-K> si la matriz crece
<S-P-A-R-K> la cantidad de saltos condicionales seria muy alta
<S-P-A-R-K> y hariamos perder la paciencia a muchos
<S-P-A-R-K> esta situacion, puede complicarse como ije antees de mil maneras
<S-P-A-R-K> diferentes
<S-P-A-R-K> ok
<S-P-A-R-K> el problema de una matriz de valores, es combinatoria
<S-P-A-R-K> podemos obtener variaciones, combinaciones y o permutaciones de valores
<S-P-A-R-K> complicando mucho mas la cosa
<S-P-A-R-K> sumenle que este proceso
<S-P-A-R-K> se haga en cada proceso del prograama
<S-P-A-R-K> podemos realizar por ejemplo un crackme
<S-P-A-R-K> que cambie de proteccion, o de rutina de generacion de serial
<S-P-A-R-K> dependiendo de valores distantes de la realidad del usuario
<S-P-A-R-K> me refiero a valores internos, de la pc
<S-P-A-R-K> como definir que valor tomo?
<S-P-A-R-K> un jeygen, para este tipo de crackme
<S-P-A-R-K> llevaria por supuesto muchisimo mas tiempo
<S-P-A-R-K> analizarlo
<S-P-A-R-K> en conclusion el porcentaje de seguridad
<S-P-A-R-K> es incrementado
<S-P-A-R-K> bueno, he terminado,
<S-P-A-R-K> fue pequeña la charla
<S-P-A-R-K> en otro momento seguiremos con estas cosas
<S-P-A-R-K> alguna preguntaaa??? 
<S-P-A-R-K> si luego se les ocurre alguna pregunten a low, si no estoy, ok?
<S-P-A-R-K> ------ FIN ----------
<^[LoW]^> un aplauso PLAS PLAS PLAS PLAS
<S-P-A-R-K> ajajaj
<S-P-A-R-K> se durmieron todoss??
<Q-tron> PLAS PLAS PLAS PLAS PLAS
*** ^[LoW]^ sets mode: +vvvv AOL|off awaynach0 carioka D4rk4ng3l
*** ^[LoW]^ sets mode: +vvvv LLoKKaWaY LuZZeR meku NuXaria
*** ^[LoW]^ sets mode: +vvvv pax remains SynAck Zarcan
*** ^[LoW]^ sets mode: +vvvv [kev] [ShrAway] _Hangman_ {Risk}
*** ^[LoW]^ sets mode: -m
<D4rk4ng3l> :p
<Meleth> pla plas plas
<SynAck> xDDD
<^[LoW]^> Bueno
<remains> eeeeee
<^[LoW]^> antes de q os durmais mas jejejej
<remains> 4[s-p-a-r-k4] 1capullo queremos un hijo tuyo
<remains> xD
<remains> has implementado algo s-p-a-r-k ?
<SynAck> ha estado bien, S-P-A-R-K :))
<^[LoW]^> Os aviso q dentro de 2-3 semanas se celebrara la Dstmaniac
<S-P-A-R-K> jaajaj
<^[LoW]^> Es una jornada de charlas q se dara integramente en #Disidents
<S-P-A-R-K> algo estoy por implementar en eso remains
<S-P-A-R-K> se han dormio en serio
*** [kev] has quit IRC (User Quit: 11,5 MeSiAs-ScRiPt v5 15,5(El día del Juicio Final)11,5 bY: Lois & 
JAP-5,5 11,5 Bájatelo de www.lois.infierno.org )
<leon01> xDDDDDDD
<^[LoW]^> jejej
*** carioka has quit IRC (Read error: No route to host)
<SynAck> por cierto
<SynAck> el log se subira a algun sitio?
End of #disidents buffer    Thu May 02 12:49:17 2002

