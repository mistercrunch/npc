[006]_Métodos_de_Compresión_sin_Pérdida_de_la_Información_by_SparK_-_Disidents_Journal_5


                     -+-| DisidentS Hack Journal #5 |-+-
 
 
 
 
 
 
 
 
 
   ______________________________________________________________________
  |                                                                      |
  | -+- Titulo_____: Métodos de Compresión sin Pérdida de la Información |
  | -+- Autor______: SparK                                               |
  | -+- E-Mail_____: dsd_cracking@portadaauga.org                        |
  | -+- Team_______: DisidentS Argentina - http://disidents-team.cjb.net |
  |______________________________________________________________________|
 
 
 
 
 
"la potencia sin control..no sirve de nada"
>>------------------------------------------------------------------------<<
 
 
 
----------------------------------------------------------------------------
----------------------------------------------------------------------------
 
.==========================================================================.
|===========~ INDICE ~======================================================
|===========================================================================
|=~ 1- Introducción                                                        |
|=~ 2- ¿Porqué Compresión?                                                 |
|=~ 3- Teoría sobre algunos métodos                                        |
|=~ 4- Metodo Central: Compresión sin Pérdida                              |
|=~ 5- Ejemplo paso a paso                                                 |
|=~ 6- Aplicaciones                                                        |
|=~ 7- Conclusión                                                          |
|=~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~=.
======================================================~ INDICE ~============
============================================================================
 
.==========================================================================.
|===========~ 1- Introducción. ~|===========================================
|===========================================================================
 
Buenas mis queridos seguidores y amigos, pues aquí estamos de nuevo con una
nueva aventura.

Si señor, se trata de una aventura comprimida, ¿cómo? , ni más ni menos que de
compresión de la información.
Nos adentraremos en algunos métodos y algoritmos conocidos, pero más aún nos
adentraremos en un método muy útil, llamado método de compresión sin pérdida.

Entre otras cosas veremos un ejemplo práctico diseñado, programado y testeado
por mí, es un programa que comprime utilizando el método que explicaré a con-
tinuación.

Les aviso desde ahora amigos/as que mi ejemplo seguramente tiene bugs, no está
lo suficiente depurado y fallará en la mayoría de los casos, así que para 
aquellos críticos, criticones que critican y saben hacer eso solamente, va 
esta aclaración. :D

Bien, sin más que decir en este apartado, pasemos al siguiente!! :)

-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 2- ¿Porqué Compresión?. ~|====================================
|===========================================================================
 
Muchos se preguntarán, con la misma pregunta que este apartado, bueno, les 
respondo: "La compresión es casi la base de la informática!!"

Si señores así es, todo esta comprimido en la mayor parte del tiempo. 
A medida que escuchamos música, un tipo de formato con algunas técnicas en el
manejo de estructuras de información son procesadas por nuestro procesador.

Muchos de nosotros vemos, que todo está muy separado, pero no es así, todo
es byte, absolutamente todo es una mezcla de bytes, una maraña eterna de 
bytes aparentemente sin sentido.

¿Qué es lo que le da forma a nuestros bytes?

Los formatos, estos son formas de guardar la información, es decir, se han
diseñado estructuras de la información para almacenar de una manera un tipo
de datos específicos, y a esa estructura se le da un nombre, este nombre, 
identifica el formato.

Estas estructuras de información nos revelan la manera en que los datos están
almacenados, para que sirve cada uno, como se usa cada dato, donde y cómo se
aplica.

Por supuesto, como muchos pensaran, estas estructuras de datos son procesadas,
"entendidas" por algunas aplicaciones especialmente diseñadas para ello.
Exactamente es eso, una acplicación que abre un documento Word, ¿ qué hace ?,
simplemente trata de interpretar una cantidad de  bytes almacenados en una 
cantidad dada de sectores dentro de un disco rígido, ésta cantidad de sectores
a leer está dada por tablas de información que no son ni más ni menos que 
otras estructuras con la que el sistema operativo hace uso de ellas, para saber
cuales sectores del disco rígido pertenecen a ese fichero el cual queremos 
acceder desde word.

Como verán estamos frente siempre al mismo problema, el problema de hacer 
interpretar a nuestra PC que es lo que queremos, y como queremos que lo 
interprete.

Bien, éste es el gran porqué de los drivers, del sistema operativo y demás 
programas que forman parte de un sistema. 
Existe para decirle a nuestra pc, algo así: 

"Oye!, esta estructura es un fichero de sonido, debes pasarla por el driver de sonido!!"

Una estructura de datos que define a un formato específico sería así:

typedef struct tagBITMAPINFOHEADER {    /* bmih */
    DWORD   biSize;
    LONG    biWidth;
    LONG    biHeight;
    WORD    biPlanes;
    WORD    biBitCount;
    DWORD   biCompression;
    DWORD   biSizeImage;
    LONG    biXPelsPerMeter;
    LONG    biYPelsPerMeter;
    DWORD   biClrUsed;
    DWORD   biClrImportant;
} BITMAPINFOHEADER;

Este es el header de un fichero BMP, una parte aclaro, como podemos ver
es una estructura que se guarda de un fichero, y el programa que quiera
procesarlo, deberá interpretar esta estructura.

Bueno, la compresión justamente es una manera de interpretar la información
y transformarla en otra información con una sola diferencia, que el resultado
SIEMPRE sea menor o IGUAL al original.

La manera de interpretar datos comprimidos, es interpretando una estructura
previamente creada, durante el proceso de creación.

Una vez interpretadas las estructuras se puede proceder a la descompresión.

-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 3- Teoría sobre algunos métodos. ~|===========================
|===========================================================================
 
Bien amigos, existen dos grandes categorías, los métodos con pérdida y sin
pérdida.

Con pérdida son aquellos los cuales como algunos esperarán leer, pierden 
información, ¿algunos ejemplos? MP3 por ejemplo, MPG, WMA, etc.

¿Qué no sabían que perdían información esos formatos?

Bien, ¿cómo pueden imaginarse que un mp3 puede alojar la calidad de un CD en 
tan poco espacio?
Por eso amigos cuando queremos extraer a MP3 un cd de música debemos elegir
la calidad, justamente lo que estamos eligiendo ahí es que tan buena va a
ser la compresión del mP3, y cuanta información queremos que se pierda.

A menos calidad, más pérdida de información y mayor compresión.

Los sonidos más relevantes son destacados solamente, evitando por ej, el sonido
de un rasguido de una guitarra.

¿ Y que creen de los demás formatos mencionados ?, pues, es lo mismo mis amigos
cuando en el photoshop u otra aplicación elegimos guardar en JPG, y nos pregunta
con que calidad, esto es lo mismo que en el MP3, se hace para saber que información
debe evitar guardar, y cual no.

Les cuento un secreto jeejejje (ya deja de serlo), en la esteganografía, se
aprovechan los problemas de compresión para alojar bits ocultos, contenidos
de frases encriptadas.

Con problemas de Compresión me refiero a que hay partes de un fichero que 
a pesar los mejores métodos de compresión, no se comprimen a pesar de parecer
estar "de más", estas partes son reutilizables para programas de ocultamiento
de información para ocultar datos dentro de esos gráficos.

Por supuesto formatos como BMP, o GIF no son tan comprimidos, y puede haber más
zonas para ocultar nuestros preciados bits, ya hablaremos del caso ;) .

Bueno amigos, ahora le toca el turno a la compresión sin pérdida, justamente es
eso, simplemente trata de comprimir sin perder información, luego cuando la re-
cupera debe ser identica a la información comprimida sino no servirá.

Justamente el fin para el cual es usada ésta tecnología es para procesos en los 
cuales la información es útil en su totalidad, no hay desechos, toda debe pro-
cesarse, entonces se utilizan estos algoritmos, que no "tiran" nada a la basura.

ZIP, RAR, ACE, LZH, CAB, son algunos ejemplos de este tipo de compresión.

Imaginen si un fichero EXE que queremos comprimir, hacemos que pierda información
para que se comprima más, como si fuera un MP3, entonces, perderíamos trozos de
la cabecera del fichero quizás, trozos de datos, código del programa, un tremendo
caos. :)

Actualmente este tipo de compresión se está tratando de implementar, para 
suplantar en algunos ambientes al MP3. ¿Qué se quiere ganar con esto?

Quieren un formato que comprima tanto como MP3 pero que no pierda tanto como MP3.

Entonces, están diseñando métodos de compresión nuevos utilizando el método
de compresión sin pérdida.
El tamaño resultante no será el de un fichero WAV pero tampoco será del tamaño
de un MP3, con lo que podríamos "sacrificar" un poco de espacio a cambio de la
mejor calidad.

También está naciendo un nuevo sistema de compresión, una tercera categoría, 
aunque aún menor, yo la nombro igualmente es denominada:

			SISTEMAS DE COMPRESIÓN EMERGENTES 

Este tipo de compresión permitirá a través de un sólo fichero obtener, 
distintas versiones del mismo, es decir, podemos extraer de una imagen,
varias, simplemente eligiendo de qué calidad la queremos, esto es posible
ya que la imagen original esta contenida dentro del fichero.

-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 4- Metodo Central: Compresión sin Pérdida. ~|=================
|===========================================================================

Bien éste método pura y objetivamente está centrado en la entropía.

¿Qué es la entropía?

Copiaré una definición física de ésta:

"Todo aparato, sistema y objeto que forma parte de la realidad que nos rodea,
sufre un desgaste, contiene errores, o lo que es más común, deja de funcionar,
eso, es entropía."

En este libro que tengo muy interesante sobre bioinformática hay una definición
que nos lleva a los tiempos más remotos sobre la frase "el conocimiento es poder",
terminan concluyendo con esta igualdad: 
	
			Información = Antientropía

¿Qué hacemos entonces aquí? ¿Regeneramos la realidad?, quizás amigos.....

Como verán el método de la compresión sin pérdida no produce pérdida de 
información con lo que su radio de compresión está destinado a la ocurrencia
de patrones, es decir, a la frecuencia con que se repiten partes del fichero
para que puedan ser "resumidas".

De ahí que éste método está limitado por la entropía, de la información, o sea,
depende de la caocidad de ésta.

Si por ejemplo, queremos comprimir un fichero que contiene:

		abcdefghijklm

No se comprimiría en lo absoluto, ¿porqué?, pues porque no hay ningún trozo
de información repetida.

En cambio, si tenemos un fichero como el siguiente:

		aaaaaabbbbbbcbcbcbaaadddddd

Podríamos decir que si se comprimirá, ¿porqué?, pues porque hay repetición 
de algunos patrones determinados, es decir, algunas letras se repiten, y 
secuencias de las mismas también se repiten.

Entonces se cumple lo que explique más arriba, el radio de compresión, depende
de la entropía de la información que se desea comprimir.

¿qué hacer en este caso?

Este tipo de métodos de compresión, utilizan un diccionario para reemplazar
los patrones que se repiten.

¿Qué es un diccionario?

Bueno, justamente es una estructura de datos, creada por el mismo algoritmo
de compresión, la cual servirá para decirle al algoritmo de descompresión, cuantas
veces se repite determinado patrón, y donde volverlo a su estado inicial.

Puede especificar, muchas más cosas, pero para nuestro ejemplo lo reduciremos
a 1 símbolo utilizado para reemplazar un patrón determinado, y a que patrón
pertenece ese símbolo.

Por ejemplo podría especificar el radio usado para ese patrón, máscaras de 
compresión usadas, si es una entrada comprimida, etc.
Como muchos pensarán se puede volver a comprimir utilizando el mismo diccionario
una y otra vez, para tratar de producir un fichero más pequeño, es una interesante
técnica.

En el diccionario cada símbolo es único, o sea, no se puede repetir para otro
patrón, si se repite, entonces no sabrá el algoritmo a que código pertenece
un patrón u otro.

En nuestro ejemplo que analizaremos más abajo he tratado de simular una compresión
del tipo Lempel-Ziv.
Existen otros tipos de compresión sin pérdida como por ejemplo codificación de 
Huffman y codificación aritmética.

El método de compresión de huffman está basado en árboles, donde cada nodo hacia
la izquierda es un 0 y a la derecha un 1, se clasifican los patrones en distintos
nodos del árbol de tal manera que para recuperarlo tenemos un símbolo que es
equivalente al recorrido que se debe hacer en el árbol para encontrarlo, por ej:

				0010 es igual a CAR

El método que analizaremos es el Lempel-Ziv, éste método simplemente, recorre
la información a comprimir, en búsqueda de patrones repetidos, utilizando algunas
complejas fórmulas estadísticas del método de Shannon.

Dependiendo del resultado de estas estadísticas, que justamente reflejan la 
entropía de la información a comprimir, los algoritmos tomarán esos resultados
y actuarán en base a ellos.

Cada nuevo patrón que se repite, es una nueva entrada al diccionario, es se
le es asignado un código de identificación, este código, será utilizado,
a posteriori, cuando se proceda a la compresión, simplemente, se reemplazan
los patrones por cada símbolo equivalente según lo registrado en el diccionario.

Para descomprimir, simplemente se busca en el diccionario por el símbolo encontrado
en el texto comprimido y se reemplaza por su patrón equivalente.
 
-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 5- Ejemplo paso a paso. ~|====================================
|===========================================================================
 
Paso a explicarles algo, la idea de este ejemplo es que ustedes vean, que pueden
con no mucho esfuerzo crear un algoritmo propio que haga lo que ustedes desean.
Utilizando algoritmos comerciales o freeware, puede ser a veces contraproducente.

¿Porqué?, pues porque son de estudio masivo entonces es más factible de que 
haya bruteforcers y programas que analicen la información comprimida en el 
fichero.

Este ejemplo, como dije antes tiene bugs, es ineficiente, y no funciona siempre,
simplemente es una posible aplicación y una manera que se me ocurrió a mi
personalmente, cuando analicé el método de Lempel-Ziv.

El método original data del año 1978, y va generando el diccionario, tomando
en principio la unidad, 1 byte, luego cuando reconoce todos los diferentes
bytes de a 1, sigue con el patrón de longitud 2, y así agota todas las instancias
con esa longitud, sigue hasta el 3, y asi, hasta terminar con la string a comprimir.

Empezaremos por el principio amigos,he diseñado el ejemplo con dos MEMO's, uno
tiene la string a comprimir, el otro, dará el resultado luego de la compresión.

La string, que he tomado para probar es: abbaabbaababbaaaabaabba

Analicemos que patrones se repiten, cuantas veces, y que podríamos hacer mentalmente
al menos para comprimirlo, luego trataré de explicar lo hecho por mí, tratando
de codificar mis pensamientos.... 

Según el método genérico tenemos dos unidades a y b, no hay otra letra.

Luego tenemos variaciones con estas dos letras, e inclusive algunas secuencias de letras
repetidas.

Tomando dos letras ahora, miremos que tenemos, empezando desde la izquierda, tenemos
ab, contemos la cantidad de veces que se repite este patron.

a = 13 veces
b = 10  ''
ab = 6  ''

Si tomamos ahora las proximas dos letras, pero, aquí hay un problema con el que a 
la hora de implementar me enteré.
Si tenemos ab, y pasamos a la siguiente patrón, algunos tomarán el que sigue, ba; 
pero nos estamos salteando una combinación bb, es la combinación de la segunda letra
de la primer combinacion, con la primer letra de la segunda combinación. 

Entonces, deberemos ir "pisando" la última letra de la combinación anterior para 
poder tomar todas las combinaciones posibles, y luego evaluar cuantas veces se
repite cada una.

Por ej, bb se repite 4 veces también, si no hubiésemos hecho como les dije
no daría lo mismo, y quizás nos perderíamos un buen radio de compresión.

Les mostraré el resultado que dió el string anterior comprimido utilizando el
ejemplo que les explicaré a continuación: 

		Original:   		abbaabbaababbaaaabaabba

		Comprimido:		3313aa1a3


A continuación, mostraré el trozo de código que hace la clasificación de cada patrón,
para que puedan observar como podría hacerse:

procedure TForm1.Button1Click(Sender: TObject);
var
arreglito,mejores:arreglo;
i,j:integer;
begin
       for j:=1 to 255 do
       begin
            mejores[j].patron:='';
            mejores[j].cod:=0;
            mejores[j].cant:=0;
       end;

   for i:=2 to length(memo1.lines.text) div 2 do
   begin
       for j:=1 to 255 do
       begin
            arreglito[j].patron:='';
            arreglito[j].cod:=0;
            arreglito[j].cant:=0;
       end;

      recorrer(arreglito,memo1,i);
      mejorratio(arreglito,mejores,memo1,memo2);
   end;
 comprimir(mejores,memo1,memo2);
end;

Bien, este proceso es el que se ejecuta cuando hacemos click en el botón 
Comprimir, lo primero que hace, es vaciar un array llamado mejores, este 
array almacenará los patrones que dan mayor radio para comprimir un string
dado.

El array es de registros, con lo que por cada celda tenemos tres campos a 
llenar, el patrón, el código del mismo, y la cantidad de veces que se repite
en la string a comprimir.

No identificamos las letras distintas que hay, ¿porqué?, pues porque si 
las identificamos, tenemos que comprimirlas sino malgastaremos espacio
en el diccionario, y ¿que radio de compresión habrá? 1:1, una letra, 1 símbolo.

Ahora entonces empezamos con el primer for a recorrer la string a comprimir
desde 2, hasta la longitud de la string dividido dos. ¿porqué? , esto se hace
porque no encontraremos en una string de 20 letras 1 patrón de 11 letras que 
se repita al menos dos veces, porque esta string debería tener al menos 22 letras.

Entonces, analizaremos los patrones que al menos se repitan dos veces, para que
la compresión tenga efecto, sino podríamos reemplazar cualquier patrón por un
símbolo pero igualmente en el diccionario iría definido, así que no hay compresión
alguna.

Luego de vaciar el arreglito, que es otro array, copia, de mejores, ejecuta
dos procesos que he creado, uno llamado recorrer, donde lo que hace, es
buscar un determinado patrón, en la string, utilizando a i, i es un índice
que en ese momento vale 2, la primera vez, y definirá la longitud del patrón
que deberemos escanear en la string a comprimir.

Arreglito cotendrá todas las posibles combinaciones dadas en el string, con 
la longitud de patrón dada en ese momento por el índice i.

Recorrer contiene:

procedure recorrer(var arr:arreglo;var memo:tmemo;long:integer);
var
i,j,h,l:integer;
tmp:string;
begin
    for j:=1 to length(memo.lines.text) do
    begin
        h:=j;
        tmp:='';
        for i:=1 to long do
        begin
              tmp:=tmp+memo.lines.text[h];
              inc(h);
        end;
        for l:=1 to 255 do
        begin
             if (arr[l].patron = tmp) or(arr[l].patron  = '') then
                break;
        end;

        if (arr[l].patron <> tmp) then
        begin
            arr[l].patron:=tmp;
            arr[l].cod:=j;
            buscar(arr,memo,l);
        end;
    end;
end;

El primer for va desde 1 hasta la long del string, luego, el segundo for lo 
que hace es generar el patrón en ese momento dado la longitud, en nuestro
primer caso es 2, entonces hara desde 1 a 2, guardando en tmp, el patrón
que extrae de la string guardada en el memo1, el memo1 es pasado como
parámetro a la variable del proceso memo.

Utilizo h para saber hasta que letra se extrajo, si utilizamos i, siempre
por cada iteración, sacaremos la primer letra, y no la que le sigue, en el 
string.

Ahora, l es utilizado para recorrer el arreglo y medir su dimensión lógica
esto se hace para ubicar un lugar vacío en el arreglo, y que no sea un
patrón existente, sino guardaríamos en el arreglo patrones ya registrados.

Una vez encontrada la dimensión lógica, podemos guardar, el nuevo patrón,
con un nuevo código, este código es asignado por j, j es el índice del primer
for, que se va incrementando en 1, entonces por cada patrón tendremos un 
código único, como habíamos previsto. :)

Aparece una nueva llamada a otro proceso, llamado buscar veamos que hace:

procedure buscar(var arr:arreglo;var memo:tmemo;j:integer);
var
  i,k,h:integer;
  tmp:string;
begin
    for i:=1 to length(memo.lines.text) do
    begin
          h:=i;
          for k:=h to h+length(arr[j].patron)-1 do
          begin
               tmp:=tmp+ memo.lines.text[k];
               if (arr[j].patron = tmp) then
                    arr[j].cant:=arr[j].cant +1 ;
          end;
          tmp:='';
    end;
end;

Éste es el algoritmo que hace la búsqueda "pisando" las letras.

Lo más importante aquí es el segundo for, como verán hace una iteracción
media complicada de calcular a simple vista, esto es debido a que tenemos
que ir corriendonos por el string, entonces he usado una variable h temporal
que toma el valor de i por cada iteracción, donde k se iguala a h entonces
puede seguir a partir del valor 3, en la siguiente iteracción.

En tmp guarda el patrón buscado, y lo compara, si es igual, entonces cuenta 1.

Luego si volvemos a la rutina principal, encontraremos la llamada mejorratio.
Este proceso se encarga de elegir, que patrones darán mejor ratio para luego
comprimir con esos, es una primera selección, ya luego habrá otra para
aplicar la compresión.

Veamos como funciona:

procedure mejorratio(var arr,arr2:arreglo;var memo,memob:tmemo);
var
  calc,max,i,j:integer;
begin
     i:=1;
     max:=0;
     j:=1;
     while (arr[i].patron <> '') do
     begin
          calc:=(length(arr[i].patron)*arr[i].cant)-arr[i].cant;
          if (calc > max) and (arr[i].cant > 1) then
          begin
              max:=calc;
            while (arr2[j].patron <> '') do
                j:=j+1;
              arr2[j].patron:=arr[i].patron;
              arr2[j].cod:=cont;
              arr2[j].cant:=arr[i].cant;
              inc(cont);
          end;
          i:=i+1;
     end;
end;

Bien como podemos ver, este proceso utiliza dos arreglos, la llamada a este
proceso es así:   mejorratio(arreglito,mejores,memo1,memo2);
Con lo que tenemos el primer arreglo con los patrones definidos, escaneados, 
el segundo arreglo contendrá los mejores patrones, que daran mejor radio de
compresión.

La cuenta que realicé para dar con el patrón que de mejor radio, es el siguiente:

En primera instancia usamos arr que es arreglito, para recorrerlo e ir calculando,
arr2 es el arreglo mejores.

El cálculo se basa en un principio que me pareció interesante, la longitud del patrón
por la cantidad de veces que se repite dará la cantidad de bytes que ocupa ese patrón
menos la cantidad de veces que se repite.

Acabo de encontrar un error, el resultado siempre será igual a la longitud del patrón
la cual la chequearemos contra un máximo, para ver que patrón es el que más conviene
usar primero, para sacar más radio al comprimir.

Luego evaluamos que la cantidad sea mayor a 1, para elegir los que se repiten dos
o más veces. Después recorremos con el while el arreglo mejores para encontrar su
dimensión lógica, porque lo ubicaremos dentro de este arreglo ya que es un patrón
candidato a comprimir.

Este proceso sirve para hacer una segunda elección de los mejores patrones, así
a la hora de comprimir que es cuando se hace la llamada:

		 comprimir(mejores,memo1,memo2);

nos aseguramos de obtener el mejor radio posible.

El proceso que analizaremos y con ésto termina mi humilde algoritmo:

procedure comprimir(var mejores:arreglo;var memo,memob:tmemo);
var
  j,i:integer;
  primer:boolean;
begin
    primer:=true;
    i:=1;
    while (mejores[i].patron <>'') do inc(i);
    dec(i);
    //para ver cual patron conviene mas
    j:=0;
    conveniencia(mejores,i,j,memo);

    while (mejores[i].patron <>  '') and (i >= 1) do
    begin
        if (primer) then
        begin
            memob.lines.text:=memo.Lines.text;
            memob.Lines.Text:=stripped(mejores,j,memob.lines.text);
            inc(i);
            primer:=false
        end
        else
            memob.Lines.Text:=stripped(mejores,i,memob.lines.text);
        dec(i);
    end;
end;

Bueno, comprimir funciona muy sencillo y creo que fue la parte mas fácil y 
divertida del algoritmo, simplemente hace el reemplazo de los patrones por
los símbolos.

Si nos fijamos bien, tenemos otro proceso que hice, para elegir aún mejor los 
patrones y saber cuales va a usar antes de comprimir, como les conte antes.
Se llama conveniencia, y lo llamamos pasamos el arreglo mejores, pasamos
a el índice i, que contiene la dimensión lógica, a j, que es 0 porque es un valor
devuelto por el proceso donde devuelve el índice que apunta al patrón que más
conviente para comprimir.

Explicaré antes el proceso conveniencia:

procedure conveniencia(arr:arreglo;i:integer;var j:integer;memo:tmemo);
var
k:integer;
maxl,r,max:real;
begin
 max:=0;
 maxl:=0;
if (max < 9999) then
 for i:=i downto 1 do
 begin
      k:= (length(memo.lines.text)) - (length(arr[i].patron) * arr[i].cant);
  if (k > 0) then
  begin
      r:=length(memo.lines.text) / k;
   if (r > max) then
   begin
    j:=i;
    max:=r;
   end;
  end
  else
      if (k = 0) and (maxl < length(arr[i].patron)) then
      begin
        max:=9999;
        j:=i;
        maxl:=length(arr[i].patron);
      end;
 end;

end;

Este proceso, funciona por maximos, el cual hago un cálculo también para saber
cual patrón es el más utilizable.
Calculo K utilizando la long del memo que le paso como parámetro menos la longitud
del patrón multiplicado por la cantidad de veces que se repite el patrón.

Esto nos da un índice que nos dice lo siguiente, tenemos una longitud de un string
que es igual a 20 bytes restada la longitud del patrón apuntado por el índice en ese
momento, que puede ser 4 caracteres por ejemplo, multiplicado por la cantidad de 
veces que se repite ese patrón.

Por ej, se repite 4 veces, tendríamos que ese patrón puede comprimir 16 bytes en 4
bytes, ya que cada patrón ocupa 4 bytes.
Ahora 20 - 16 es 4 , con lo que preguntamos si k es mayor a 4, y  si lo es, donde luego
calculamos una variable a la que llamé r, esta hace una division real, entre la 
longitud del string que es 20 en nuestro ejemplo y el 4 que está contenido en k.

El resultado es 5, utilicé un real, porque a veces las diferencias son menores entre
patrones y repeticiones, eso es chequeado si es mayor a la variable max, significa
que se repite mas veces, entonces obtendremos mejor radio de compresión.

Si el resultado es mejor, entonces se testea si es igual a 0, porque puede ser que 
de justo entonces, estaríamos frente al mejor patrón, el cual se repite exactamente
una cantidad de veces, por ejemplo en una string: abababab donde abab se repite 2 
veces.

Y preguntamos también si la longitud del patrón indicado es mayor que la variable maxl
esto, sirve para saber si es la longitud máxima de un patrón el cual tiene el mejor
radio.

Una vez sucedido esto, max toma el máximo valor posible, le asignamos el índice donde
se encuentra el patrón, y terminamos.

Por último en cuanto a la rutina comprimir nos quedamos en esta parte:

    while (mejores[i].patron <>  '') and (i >= 1) do
    begin
        if (primer) then
        begin
            memob.lines.text:=memo.Lines.text;
            memob.Lines.Text:=stripped(mejores,j,memob.lines.text);
            inc(i);
            primer:=false
        end
        else
            memob.Lines.Text:=stripped(mejores,i,memob.lines.text);
        dec(i);
    end;

Donde iteramos hasta terminar con la dimension lógica del arreglo. La primera
vez, utilizamos una variable booleana, la cual llamamos a una funcion de delphi
para sacar el texto utilizando j, el cual apunta al mejor patrón, con mejor
radio.

Luego por último en la segunda o X vueltas utilizamos i, el cual elije por 
orden según el arreglo mejores.

Bueno, yo habia mostrado el texto original, y el texto comprimido, explicaré
el porqué del resultado:

		Original:   		abbaabbaababbaaaabaabba

		Comprimido:		3313aa1a3

Como podemos ver, hay cuatro 3, y dos 1. Encontramos el patrón abba que se
repite cuatro veces, supongamos que nuestro algoritmo le dio al patrón abba
el símbolo 3.

		a b b a| a b b a| a b| a b b a| a| a| a b| a |a b b a
		   3   |    3   |  1 |    3   | a| a|  1 | a |   3

El diccionario sería el siguiente:

				patrón   código   ocurrencias

				 abba	    3          4
				  ab        1	       2

			 
-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 6- Aplicaciones. ~|===========================================
|===========================================================================
 
La aplicación de mi ejemplo propone solamente compresión con letras, o sea no 
puede haber números en el string, porque sino al utilizar números como símbolos
en el diccionario, confundirá los números originales con los del diccionario, no
pudiendo reconocer uno de otros.

Sin embargo, podemos utilizar un caracter especial para números, o una serie
de caracteres especiales para los dígitos (0..9), de ésta manera sabremos cuales
son.

Lo interesante, es que hemos comprimido bastante, y el diccionario no se ha
agrandado demasiado, podríamos no agregar el campo de ocurrencias al diccionario
final, de esta manera nos ahorraríamos 2 bytes.

El diccionario ocupará 8 bytes, más 9 bytes del texto comprimido, son 17 bytes.
El texto original ocupa 23 bytes, en total, 6 bytes comprimidos. :D

Como podemos ver, un fichero txt con este texto dentro, comprimido con rar nos
daría algunos miles de bytes, 0 de compresión.... 

Pero bueno, el rar tiene mucha mas tecnología, CRC y demás, que nosotros no, 
eso lo dejaremos para otras versiones, o porqué no experimenten ahora ustedes,
ya tienen el conocimiento en sus manos, ya tienen el poder. :)

-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 7- Conclusión. ~|=============================================
|===========================================================================
 
Bueno amigos/as, espero que les haya entretenido lo suficiente este artículo humilde
que les presento, simplemente a contribuir a la causa, una causa justa, conocimiento
para todos, capacidad de elección, posibilidad de crear nuevas cosas, nuevas
líneas de aplicaciones, nuevas ideas.

Lo más importante de ésto, es que ya tienen la base de un método interesante, ahora
pueden utilizarlo en una emergencia, para sus propias aplicaciones, o para crear
un nuevo método mejor que los actuales, por favor si logran algo, mánden un mail a
mi casilla de correo, me sentiría muy orgulloso de haber sido de alguna manera
un cosechador de ideas de las que ahora han florecido. :)

Adjunto el código en Delphi, no es nada del otro mundo, y el código es el
mismo que he explicado, espero que les sirva. 

Saludos, y gracias por su tiempo.
	
			"Mi delito es mi inteligencia".

	"There is a crack, a crack for everything, that's how the light gets in..."


								SparK

-----------------------------------------------------------------------------
                   DisidentS Hacker Team 2003 (c).
 
----------------------------------------------------------------------------
                 Mail del Team: disidents@yahoo.es
----------------------------------------------------------------------------
 
                               0
                             X0 0X
                               S
