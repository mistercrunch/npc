


                     -+-| DisidentS Hack Journal #3 |-+-









   ______________________________________________________________________
  |                                                                      |
  | -+- Titulo_____: Manteniendo el control sobre las conexiones en      |
  |                  nuestra  maquina. [019.txt]                         |
  | -+- Autor______: W3ndig0                                             |
  | -+- E-Mail_____: <disidents@yahoo.es>                                |
  | -+- Team_______: DisidentS España - http://www.disidents.int-ltd.com |
  | -+- KB_________: 96.0                                                |
  |______________________________________________________________________|





               "la potencia sin control..no sirve de nada"
>>------------------------------------------------------------------------<<



----------------------------------------------------------------------------
----------------------------------------------------------------------------

.==========================================================================.
|===========~ INDICE ~======================================================
|===========================================================================
|=~ 0.0.0 Introduccion.                                                    |
|=~ 1.0.0 Un poquito mas de control en linux .                             |
|=~ 1.0.0 Portsentry de psionic (The abacus proyect)                       |
|=~ 1.1.0 Necesidad de PORTSENTRY ¿Porque port sentry?                     |
|=~ 1.2.0 ¿Exactamente que hace?                                           |
|=~ 1.3.0 Configurando PORTSENTRY                                          |
|=~ 1.3.1 Syslog                                                           |
|=~ 1.3.2 Configurando los puertos                                         |
|=~ 1.3.3 Configurando las opciones avanzadas                              |
|=~ 1.3.4 Poniendolo guapo para la fiesta X)                               |
|=~ 1.4.0 IcmpInfo el detector de rastreos y bombas ICMP                   |
|=~ 1.4.1 Que es IcmpInfo?                                                 |
|=~ 1.4.2 Bajando e instalando a IcmpInfo.                                 |
|=~ 2.0.0 Controlando que se abre, se envia y se recive y por donde en win.|
|=~ 2.1.0 Planteamientos preeliminares.                                    |
|=~ 2.2.0 Una vision intuitiva.                                            |
|=~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~=.
======================================================~ INDICE ~============
============================================================================











.==========================================================================.
|===========~ 0.0.0 Introduccion. ~=========================================
|===========================================================================

 Quizas manteniendo un poco con la correlacion  de articulos en el ezine esta
Vez  vamos  a  meternos  un  poco  en como controlar lo que se mueve  por los
puertos de nuestra maquina, tanto si tenemos un Win(98,me..), un Win2000 o un
Linux.

 Como  supondreis  de  antemano  de todos los sistemas operativos que vamos a
analizar  en  este articulo es Win (98 ,Me..) quien posiblemente nos de menos
alternativas de juego directamente, ya que nos vamos a centrar en las posibi-
lidades que de antemano el S0 nos ofrece.

 Bien..y os preguntareis..¿que vamos a analizar?...Analizaremos la  posibili-
Dad  de  filtrar  paquetes  o  de  ver  que puertos estan abiertos en nuestro
sistema y  concretamente bajo Win 98,me..implementaremos un sencillo programa
En  VB  que  nos  permitira  mantener  un cierto control sobre las conexiones
existentes  en nuestra maquina. . ademas  de hacer un pequeña herramienta que
substituira al NETSTAT y que  ademas ..sera visual y continuada.

 Si..si..si mucho WIn..pero yo me he instalado el Linux y quisiera saber como
con trolarlo tambien desde linux, esque soy muy paranoico sabes?. . . Tambien
entraremos  a analizar  una sencilla pero muy  util herramienta que Linux nos
ofrece..PORTSENTRY...

  Pues bueno . . . nos queda un  largo tramo por recorrer asique cuanto antes
cojamos la mochila y empezemos a caminar mejor..asique ahi vamos!


.==========================================================================.
|===========~ 1.0.0 Un poquito mas de control en linux. ~===================
|===========================================================================

=============================================================================
-----------------------------------------------------------------------------
        1.0 Portsentry de psionic(the abacus proyect).
-----------------------------------------------------------------------------
=============================================================================
  De  todos los detectores de scanners que me mirado a la hora de preguntarme
cual tocaria en este articulo y de daros buena informacion y  la mas completa
posible, he optado por portsentry, el motivo es claro, es una comparacion  de
facilidad de instalacion y prestaciones, portsentry sale victorioso frente  a
otros detectores de  scaneos ya que nos va a permitir un monton de  opciones.
Aun  asi,  portsentry  no  nos  monitoriza el  trafico  saliente, lo  cual en
terminos de paranoia, considero es fundamental




.==========================================================================.
|=========~ 1.1.0 Necesidad de PORTSENTRY ¿Porque portsentry?. ~============
|===========================================================================


 Veamos..El problema de los escaneos viene por  los  metodos ocultos que  son
invisibles a un metodo Binding comun, lo cual hace que estemos siempre con la
mosca detras de la oreja ya que si, con un binding sabemos que nos estan esca
neando pero no estamos nunca  seguros de  que no  lo estan haciendo ya que no
detecta los escaneos ocultos del tipo FIN, half-open, Oddball  packet, Syn  y
X-mas..

  Normalmente  cuando queriamos vigilar los puertos  de  nuestro  sistema . .
teniamos que hacer un binding a los puertos que nos era interesante  vigilar.
Es vital  para  la seguridad de nuestro  sistema saber que sucede en nuestros
puertos asi como una correcta politica de permisos y actualización de nuestro
software, si  fueramos  medicos el prevenir escaneos a nuestro sistema podria
denominarse  medicina  preventiva ya  que  normalmente tras un estudio de que
estamos corriendo en nuestro sistema, podria iniciarse una ataque al mismo en
toda regla, mejor estemos prevenidos no?..

  Portsentry es sencillo, facil de configurar y sobre todo UTIL!. y ademas. .
facil de encontrar. . casi todas las distribuciones vienen ya con el, y no me
extraña  por  ser  una estupendisima manera de hacer nuestro sistema linux un
poquitin mas seguro.




.==========================================================================.
|=========~ 1.2.0 ¿Exactamente que hace? ~==================================
|===========================================================================

  Portsentry tiene diversas opciones para proteger nuestro sistema  local  de
intentos de acceso no autorizados, esto lo va hacer directamente denegando el
acceso a aquellas IP que lo intenten, y guardando estas en un archivo ubicado
en /etc/host.deny, podemos ver un ejemplo de este archivo...

        >>>> cat /etc/hosts.deny
	#
	# hosts.deny	 This file describes the names of the hosts which are
	#		*not* allowed to use the local INET  services,  as  decided
	#		by the '/usr/sbin/tcpd' server.
	#
	# The  portmap  line  is  redundant, but it is left to remind you  that
	# the new secure portmap uses hosts.deny and hosts.allow. In particular
	# you should know that NFS uses portmap!
	#
	ALL: *.89.0.5
	ALL: *.89.0.5
	ALL: *.89.0.5
	ALL: *.89.0.5
	ALL: *.89.0.5
	ALL: *.141.56.254 // Como veis el archivo es redundante es decir..
                       nos guarda los intentos de una ip sin importar si ya
                       estaba.
	ALL: *.141.57.161
	ALL: *.141.56.254
	ALL: *.141.57.89
	ALL: *.89.0.5
	ALL: *.168.0.4
	ALL: *.141.56.254 // *
	ALL: *.168.0.31
	ALL: *.141.63.198
	ALL: *.89.19.13
	ALL: *.89.0.5
	ALL: *.141.56.254  // *
	ALL: *.168.0.4
	ALL: *.168.0.4
	ALL: *.141.56.254
	ALL: *.168.0.4
	ALL: *.141.56.254 // *
	ALL: *.89.0.5

 ----------------------------------------------------------------------------
         (jeje muy solicitado estoy ...hehehehe), muchas de estas ip  son  de
mi dominio son maquinas que se han tratado de conectar a mie incluso la ip de
mi proveedor . . ha sido denegada ( ya vale con que le page no ? :) otras son
escaneos
en toda  regla,  les he puesto un * porque hay que respetar al que empieza  y
ademas ..el primero en hacer escaneos soy yo.. :)

       Ahora  profundizemos  un poco en como funciona y que hace para denegar
los accesos y a que puertos deniega los accesos...

       Para denegar un acceso lo que hace es enviar el paquete  entrante  (el
del escaneador por ejemplo) a un host que no existe. . por ejemplo 666.  666.
666. 666,  esto  lo  realiza  via  tcp  wrappers,  claro  que  ademas podemos
reconfigurar  la  configuracion  del  host  local  para que los paquetes sean
filtrados e incluso añadidos  al log del sistema...como sabeis  linux  guarda
logs de casi todo, estupendo verdad :)

       Para vigilar nuestro sistema portsentry dispone de varias  maneras  de
hacerlo,  puede usar una lista de puertos..hacer un binding invertido  en  el
cual  todos  los  puertos  establecidos  salvo  los  usados  por  demonios  y
lógicamente  los  que tu no quieras,  no es un metodo que yo recomendaria (el
blinding invertido) ya que podeis tener en poco tiempo un centenar de alarmas
y os pondria nerviosos :)salvo que seais tan para
noicos como yo.




.==========================================================================.
|=========~ 1.3.0 Configurando Portsentry. ~================================
|===========================================================================


        Bueno..a que te va gustando este sencillo programa? ahora vamos a ver
como cofigurarlo..es muy facil! :)

        1.- Onde ta la configuracion si ya lo tengo instalado?

          gueeeeno..normalmente en /etc/portsentry

        2.- Oño..pos no w3n..no lo tengo instalado. .como lo  instalo ? donde
            lo consigo...

         Normalmente todas las distribuciones ya vienen con el. .claro que el
que  venga  no  kiere  decir  k  lo  tengas  instalado..logicamente.que no lo
tienes?..nada pos a bajarlo de www.psionic.com/abacus/portsentry ...lo puedes
bajar tanto en codigo como en paquete "precocinado", si lo bajas como paquete
precocinado..nada al tipico metodo de configure, make y install..que lo bajas
en formato codigo..hay que enrredar un poco mas..

         Editamos el archivo Portsentry_config.h (antes extraelo . . ) ya que
vamos a cambiar una serie de cuestiones..
lo  primero  debemos de indicar donde va a estar el archivo de configuracion,
 /etc/portsentry, donde /etc/ es el directorio y portsentry  el  archivin . .
podeis ponerlo onde querais por ejemplo /onde me de la gana/portsentry...pero
ser paranoicos..si alguien entrase o tubiese acceso..donde miraria primero?..
en /etc/ ya que alli hay un monton de cosas interesantes...asique ser "finos"
y no lo dejeis al alcance de la mano, ya me entendeis..esconderlo un poco.

          Para configurar esto se lo asignamos a CONFIG_FILE

          Tambien  tendremos  k configurar  donde esta el archivo hosts.deny ,
que   pertenece   a   TCP   wrappers  .   .  normalmente   lo  tendremos   en
/etc /hosts.deny..usease..en el directorio
/etc/.

          Configurar el nivel de log..en SYSLOG_FACILITY asi como su nivel en
SYSLOG_LEVEL para el envio de mensajes en caso de que alguien nos " toque los
puertos "  XD  . . .  como vale mas una imagen que 100 palabras..pegaremos el
archivo de configuracion aqui para ir haciendolo "in situ"...

/************************************************************************/
/*                                                                      */
/* Psionic PortSentry							*/
/*                                                                      */
/* Created: 10-12-1997                                                  */
/* Modified: 06-26-2001                                                 */
/*                                                                      */
/* Send all changes/modifications/bugfixes to help@psionic.com      	*/
/*                                                                      */
/*                                                                      */
/* This software is Copyright(c) 1997-2001 Psionic Software, Inc.       */
/*                                                                      */
/* Disclaimer:                                                          */
/*                                                                      */
/* All software distributed by Psionic Software is distributed 		*/
/* AS IS and carries NO WARRANTY or GUARANTEE OF ANY KIND. End users of */
/* the software acknowledge that they will not hold Psionic Software	*/
/* liable for failure or non-function of the software product. YOU ARE  */
/* USING THIS PRODUCT AT YOUR OWN RISK.					*/
/*                                                                      */
/* Licensing restrictions apply. Commercial re-sell is prohibited under */
/* certain conditions. See the license that came with this package or 	*/
/* visit http://www.psionic.com for more information. 			*/
/*                                                                      */
/*$Id:portsentry_config.h,v 1.4 2001/06/26 15:14:57 crowland Exp crowland $ */
/************************************************************************/



/* These are probably ok. Be sure you change the Makefile if you */
/* change the path */
#define CONFIG_FILE "/etc/portsentry" --->> aqui o donde querais..ej: /usr/bin/tetris ..
/* The location of Wietse Venema's TCP Wrapper hosts.deny file */
#define WRAPPER_HOSTS_DENY "/etc/hosts.deny"-->> onde ta el archivo hosts.deny..pos
                                                   onde lo tengas..

/* The default syslog is as daemon.notice. You can also use */
/* any of the facilities from syslog.h to send messages to (LOCAL0, etc) */
#define SYSLOG_FACILITY LOG_DAEMON --------->> Tipo de log..como un demonio...
#define SYSLOG_LEVEL LOG_NOTICE ---------------->> envia las noticias por log.


/* the maximum number of hosts to keep in a "previous connect" state engine*/
#define MAXSTATE 50

-----------------------------------------------------------------------------
  Sencillo verdad...si lo dejais igual k  este os funcionara sin problemas...
ahora vamos a configurar el portsentry.conf e n el  se congiguran los puertos
asi si vemos algo que no nos gusta..lo cambiamos..
-----------------------------------------------------------------------------

      Abrimos el archivo portsentry.conf

# PortSentry Configuration
#
# $Id: portsentry.conf,v 1.23 2001/06/26 15:20:56 crowland Exp crowland $
#
# IMPORTANT NOTE: You CAN NOT put spaces between your port arguments.
#
# The default ports will catch a large number of common probes
#
# All entries must be in quotes.


#######################
# Port Configurations #
#######################
#
#
# Some example port configs for classic and basic Stealth modes#
# I like to always keep some ports at the "low" end of the spectrum.
# This will detect a sequential port sweep really quickly and usually
# these ports are not in use (i.e. tcpmux port 1)
#
# ** X-Windows Users **: If you are running X on your box you need to be sure
# you are not binding PortSentry to port 6000 (or port 2000  for  OpenWindows users).
# Doing so will prevent the X-client from starting properly.
#
# These port bindings are *ignored* for Advanced Stealth Scan Detection Mode.
#

# Un-comment these if you are really anal:
#TCP_PORTS="1,7,9,11,15,70,79,80,109,110,111,119,138,139,143,512,513,514,515,
540,635,1080,1524,2000,2001,4000,4001,5742,600
		0,6001,6667,12345,12346,20034,27665,30303,32771,32772,32773,32774,31337,
40421,40425,49724,54320"
#UDP_PORTS="1,7,9,66,67,68,69,111,137,138,161,162,474,513,517,518,635,640,641,666,700,2049,31335,27444,34555,32770,32771,32
		   772,32773,32774,31337,54321"
#
# Use these if you just want to be aware:
TCP_PORTS="1,11,15,79,111,119,143,540,635,1080,1524,2000,5742,6667,12345,12346,20034,27665,31337,32771,32772,32773,32774,40
		   421,49724,54320"
UDP_PORTS="1,7,9,69,161,162,513,635,640,641,700,37444,34555,31335,32770,32771,32772,32773,32774,31337,54321"
#
# Use these for just bare-bones
#TCP_PORTS="1,11,15,110,111,143,540,635,1080,1524,2000,12345,12346,20034,32771,32772,32773,32774,49724,54320"
#UDP_PORTS="1,7,9,69,161,162,513,640,700,32770,32771,32772,32773,32774,31337,54321"

###########################################
# Advanced Stealth Scan Detection Options #
###########################################
#
# This is the number of ports you want PortSentry to monitor in Advanced mode.
# Any port *below* this number will be monitored. Right now it watches
# everything below 1024.
#
# On many Linux systems you cannot bind above port 61000. This is because
# these ports are used as part of IP masquerading. I don't recommend you
# bind over this number of ports. Realistically: I DON'T RECOMMEND YOU MONITOR
# OVER 1024 PORTS AS YOUR FALSE ALARM RATE WILL ALMOST CERTAINLY RISE. You've been
# warned! Don't write me if you have have a problem because I'll only tell
# you to RTFM and don't run above the first 1024 ports.
#
#
ADVANCED_PORTS_TCP="1024"
ADVANCED_PORTS_UDP="1024"
#
# This field tells PortSentry what ports (besides listening daemons) to
# ignore. This is helpful for services like ident that services such
# as FTP, SMTP, and wrappers look for but you may not run (and probably
# *shouldn't* IMHO).
#
# By specifying ports here PortSentry will simply not respond to
# incoming requests, in effect PortSentry treats them as if they are
# actual bound daemons. The default ports are ones reported as
# problematic false alarms and should probably be left alone for
# all but the most isolated systems/networks.
#
# Default TCP ident and NetBIOS service
ADVANCED_EXCLUDE_TCP="113,139"
# Default UDP route (RIP), NetBIOS, bootp broadcasts.
ADVANCED_EXCLUDE_UDP="520,138,137,67"


######################
# Configuration Files#
######################
#
# Hosts to ignore
IGNORE_FILE="/usr/local/psionic/portsentry/portsentry.ignore"
# Hosts that have been denied (running history)
HISTORY_FILE="/usr/local/psionic/portsentry/portsentry.history"
# Hosts that have been denied this session only (temporary until next restart)
BLOCKED_FILE="/usr/local/psionic/portsentry/portsentry.blocked

##############################
# Misc. Configuration Options#
##############################
#
# DNS Name resolution - Setting this to "1" will turn on DNS lookups
# for attacking hosts. Setting it to "0" (or any other value) will shut
# it off.
RESOLVE_HOST = "1"

###################
# Response Options#
###################
# Options to dispose of attacker. Each is an action that will
# be run if an attack is detected. If you don't want a particular
# option then comment it out and it will be skipped.
#
# The variable $TARGET$ will be substituted with the target attacking
# host when an attack is detected. The variable $PORT$ will be substituted
# with the port that was scanned.
#
##################
# Ignore Options #
##################
# These options allow you to enable automatic response # options for UDP/TCP. This is useful if you just want
# warnings for connections, but don't want to react for
# a particular protocol (i.e. you want to block TCP, but
# not UDP). To prevent a possible Denial of service attack
# against UDP and stealth scan detection for TCP, you may
# want to disable blocking, but leave the warning enabled.
# I personally would wait for this to become a problem before
# doing though as most attackers really aren't doing this.
# The third option allows you to run just the external command
# in case of a scan to have a pager script or such execute
# but not drop the route. This may be useful for some admins
# who want to block TCP, but only want pager/e-mail warnings
# on UDP, etc.
#
#
# 0 = Do not block UDP/TCP scans.
# 1 = Block UDP/TCP scans.
# 2 = Run external command only (KILL_RUN_CMD)

BLOCK_UDP="1"
BLOCK_TCP="1"

###################
# Dropping Routes:#
###################
# This command is used to drop the route or add the host into
# a local filter table.
#
# The gateway (333.444.555.666) should ideally be a dead host on
# the *local* subnet. On some hosts you can also point this at
# localhost (127.0.0.1) and get the same effect. NOTE THAT
# 333.444.555.66 WILL *NOT* WORK. YOU NEED TO CHANGE IT!!
#
# ALL KILL ROUTE OPTIONS ARE COMMENTED OUT INITIALLY. Make sure you
# uncomment the correct line for your OS. If you OS is not listed
# here and you have a route drop command that works then please
# mail it to me so I can include it. ONLY ONE KILL_ROUTE OPTION
# CAN BE USED AT A TIME SO DON'T UNCOMMENT MULTIPLE LINES.
#
# NOTE: The route commands are the least optimal way of blocking
# and do not provide complete protection against UDP attacks and
# will still generate alarms for both UDP and stealth scans. I
# always recommend you use a packet filter because they are made
# for this purpose.

# Generic
#KILL_ROUTE="/sbin/route add $TARGET$ 333.444.555.666"

# Generic Linux
#KILL_ROUTE="/sbin/route add -host $TARGET$ gw 333.444.555.666"

# Newer versions of Linux support the reject flag now. This
# is cleaner than the above option.
#KILL_ROUTE="/sbin/route add -host $TARGET$ reject"

# Generic BSD (BSDI, OpenBSD, NetBSD, FreeBSD)
#KILL_ROUTE="/sbin/route add $TARGET$ 333.444.555.666"

# Generic Sun
#KILL_ROUTE="/usr/sbin/route add $TARGET$ 333.444.555.666 1"

# NEXTSTEP
#KILL_ROUTE="/usr/etc/route add $TARGET$ 127.0.0.1 1"

# FreeBSD
#KILL_ROUTE="route add -net $TARGET$ -netmask 255.255.255.255 127.0.0.1 -blackhole"

# Digital UNIX 4.0D (OSF/1 / Compaq Tru64 UNIX)
#KILL_ROUTE="/sbin/route add -host -blackhole $TARGET$ 127.0.0.1"

# Generic HP-UX
#KILL_ROUTE="/usr/sbin/route add net $TARGET$ netmask 255.255.255.0 127.0.0.1"

##
# Using a packet filter is the PREFERRED. The below lines
# work well on many OS's. Remember, you can only uncomment *one*
# KILL_ROUTE option.
##

# ipfwadm support for Linux
#KILL_ROUTE="/sbin/ipfwadm -I -i deny -S $TARGET$ -o"
#
# ipfwadm support for Linux (no logging of denied packets)
#KILL_ROUTE="/sbin/ipfwadm -I -i deny -S $TARGET$"
#
# ipchain support for Linux
#KILL_ROUTE="/sbin/ipchains -I input -s $TARGET$ -j DENY -l"
#
# ipchain support for Linux (no logging of denied packets)
#KILL_ROUTE="/sbin/ipchains -I input -s $TARGET$ -j DENY"
#
# iptables support for Linux
#KILL_ROUTE="/usr/local/bin/iptables -I INPUT -s $TARGET$ -j DROP"
#
# For those of you running FreeBSD (and compatible) you can
# use their built in firewalling as well.
#
#KILL_ROUTE="/sbin/ipfw add 1 deny all from $TARGET$:255.255.255.255 to any"
#
#
# For those running ipfilt (OpenBSD, etc.)
# NOTE THAT YOU NEED TO CHANGE external_interface TO A VALID INTERFACE!!
#
#KILL_ROUTE="/bin/echo 'block in log on external_interface from $TARGET$/32 to any' | /sbin/ipf -f -"


###############
# TCP Wrappers#
###############
# This text will be dropped into the hosts.deny file for wrappers
# to use. There are two formats for TCP wrappers:
#
# Format One: Old Style - The default when extended host processing
# options are not enabled.
#
KILL_HOSTS_DENY="ALL: $TARGET$"

# Format Two: New Style - The format used when extended option
# processing is enabled. You can drop in extended processing
# options, but be sure you escape all '%' symbols with a backslash
# to prevent problems writing out (i.e. \%c \%h )
#
#KILL_HOSTS_DENY="ALL: $TARGET$ : DENY"

###################
# External Command#
###################
# This is a command that is run when a host connects, it can be whatever
# you want it to be (pager, etc.). This command is executed before the
# route is dropped or after depending on the KILL_RUN_CMD_FIRST option below
#
#
# I NEVER RECOMMEND YOU PUT IN RETALIATORY ACTIONS AGAINST THE HOST SCANNING
# YOU!
#
# TCP/IP is an *unauthenticated protocol* and people can make scans appear out
# of thin air. The only time it is reasonably safe (and I *never* think it is
# reasonable) to run reverse probe scripts is when using the "classic" -tcp mode.
# This mode requires a full connect and is very hard to spoof.
#
# The KILL_RUN_CMD_FIRST value should be set to "1" to force the command
# to run *before* the blocking occurs and should be set to "0" to make the
# command run *after* the blocking has occurred.
#
#KILL_RUN_CMD_FIRST = "0"
#
#
#KILL_RUN_CMD="/some/path/here/script $TARGET$ $PORT$"


#####################
# Scan trigger value#
#####################
# Enter in the number of port connects you will allow before an
# alarm is given. The default is 0 which will react immediately.
# A value of 1 or 2 will reduce false alarms. Anything higher is
# probably not necessary. This value must always be specified, but
# generally can be left at 0.
#
# NOTE: If you are using the advanced detection option you need to
# be careful that you don't make a hair trigger situation. Because
# Advanced mode will react for *any* host connecting to a non-used
# below your specified range, you have the opportunity to really
# break things. (i.e someone innocently tries to connect to you via
# SSL [TCP port 443] and you immediately block them). Some of you
# may even want this though. Just be careful
#
SCAN_TRIGGER="0"

######################
# Port Banner Section#
######################
#
# Enter text in here you want displayed to a person tripping the PortSentry.
# I *don't* recommend taunting the person as this will aggravate them.
# Leave this commented out to disable the feature
#
# Stealth scan detection modes don't use this feature
#
#PORT_BANNER="** UNAUTHORIZED ACCESS PROHIBITED *** YOUR CONNECTION ATTEMPT HAS BEEN LOGGED. GO AWAY."

# EOF




.==========================================================================.
|=========~ 1.3.1 Syslog ~==================================================
|===========================================================================

    Bueno pos vamos a ello, lo primero que se nos antoja es quizas configurar
como vamos a recivir los mensajes o alertas..(os lo pego de nuevo para que no
os perdais)

     /* The default syslog is as daemon.notice. You can also use
     /* any of the facilities from syslog.h to send messages to (LOCAL0, etc)
 */
    #define SYSLOG_FACILITY LOG_DAEMON --------------->> Tipo de log..como un
                                                         demonio...
    #define SYSLOG_LEVEL LOG_NOTICE ---------------->> envia las noticias por
                                                       log.

    Como leereis nos indica que admite  cualquiera  de  las  posibilidades  o
facilidades que se encuentran incluidas en syslog.h, si no andamos muy ffinos
con el temo no nos lo sabemos de memoria, lo ideal seria poder echar un ojo a
esa libreria y ver que opciones nos da.

     Y claro, si  no  sois  unos usuarios con horas de vuelo en linux pues os
perdereis un poco, nada pues os digo onde encontrarla y porque esta alli.

     Normalmente como linux ha sido desarrollado como sistema operativo  para
programadores  tendremos  una  serie  de  librerias  para  el  desarrollo  de
programas en C que son usadas por los  programadores,  syslog  no  va  a  ser
menos, los .h son librerias de C para aquellos que no sepais ni  una  palabra
de programacion en C, glibc - devel es un paquete  con un monton de librerias
comunes  que  se  disponen  para el uso de programadores y que como veis, son
usadas con asiduidad.

     Normalmente /include, lo de include tiene su logica :) en C a la hora de
Incluir  una  libreria  lo  hacemos asi #include <libreria.h> , las librerias
incluyen  una  serie  de funciones y constantes, en este caso la libreria que
nos ocupa tiene  en su interior las constantes para syslog y  que  portsentry
usa  a la  hora de definir como va a logear los incidentes en los puertos que
hayamos definido.

     La  libreria  en  concreto  tras  instalar  si no lo teneis instalado el
pakete glibc - devel (por ejemplo, puede estar  presente  en otros paquetes),
se encuentra en usr/include/sys y  como  vereis  se  encuentra  perfectamente
comentada  y  de  muy sencilla  lectura  echarle  un  vistazo  si quereis con
cualquier editor de texto fronted o bien  un pikoo un vi, lo que tengais para
editar ...me limitare a pegar las partes donde se definen las constantes para
ir explicando poco a poco como va el tema y que opciones tenemos,

      Comezaremos por como va a funcionar portsentry...veamos la  declaracion
de constantes en syslog.h

      en el archivo de configuracion de portsentry....
-----------------------------------------------------------------------------
   #define SYSLOG_FACILITY LOG_DAEMON ----->> Tipo de log..como un demonio...
   -----------------------------------\/
 Declaracion de constantes en syslog.h
   --------------------------------------
   #define	LOG_KERN	(0<<3)	      /* kernel messages */-->mensages del
                                           kernel
   #define	LOG_USER	(1<<3)	  /* random user-level messages */mensajes
                                                de usuario o nivel aleatorios
   #define	LOG_MAIL	(2<<3)	/* mail system */...como sistema de correo
   #define	LOG_DAEMON	(3<<3)	  /* system daemons */...como un demonio..
                                              siempre presente ---<esta es la
                                              mejor opcion
   #define	LOG_AUTH	(4<<3)	  /* security/authorization messages */...
                                         como mensajes de autorizacion
   #define	LOG_SYSLOG	(5<<3)/* messages generated internally by syslogd */..
                                            .mensajes que son generados por el
                                            propio syslog
   #define	LOG_LPR		(6<<3)	 /* line printer subsystem */ ...como
                                           un subsistema de impresoras
   #define	LOG_NEWS	(7<<3)	   /* network news subsystem */...como news
   #define	LOG_UUCP	(8<<3)    /* UUCP subsystem */... como subsistema UUCP
                                         (    transferencias de archivos entre
                                         sistemas)*ver man uucp
   #define	LOG_CRON	(9<<3)  /* clock daemon */...como el demonio del relog
   #define	LOG_AUTHPRIV(10<<3)/* security/authorization messages (private) */
                                 ..como mensajes de autorizacion pero privados

   #define	LOG_FTP		(11<<3)/* ftp daemon */ ..como un demonio FTP

          Yo creo que es suficientemente explicito . . . como mucho os las he
traducido creo que no tiene mas problema...

¿por qué  usamos  LOG_DAEMON? . facil . . si queremos que nuestro sistema sea
continuamente monitorizado,  lo  ideal   es  que  portsentry  este    siempre
activo  . . .
¿y si me interesase otra opcion?... nada pues escribirias lo  sigiente en  el
archivo de configuracion de portsentry:

 #define SYSLOG_FACILITY Define que nos interese..
por ejemplo #define SYSLOG_FACILITY LOG_AUTH (ponerlo en mayusculas)

         Ahora veamos, que nivel de log nos interesa?...
-----------------------------------------------------------------------------
En el archivo de configuracion de portsentry...
#define SYSLOG_LEVEL LOG_NOTICE
-------------------------------------\/
Declaracion de constantes en syslog.h
--------------------------------------
/*
* priorities/facilities are encoded into a single 32-bit quantity, where the
* bottom 3 bits are the priority (0-7) and the top 28 bits are the facility
* (0-big number).  Both the priorities and the facilities map roughly
* one-to-one to strings in the syslogd(8) source code.  This mapping is
* included in this file.
*
* priorities (these are ordered)
*/
#define	LOG_EMERG	0	/* system is unusable */....emergencia!!
#define	LOG_ALERT	1	/* action must be taken immediately */
                             ....Alerta y nos avisa inmediatamenterl
#define	LOG_CRIT	2	/* critical conditions */...Critico
#define	LOG_ERR	3	/* error conditions */...hups..sa producido un
                                error y nos informa de ello
#define	LOG_WARNING	4	/* warning conditions */...Cuidadin cuidadin...
#define	LOG_NOTICE	5	/* normal but significant condition */..una
                                 prioridad normal pero importante
#define	LOG_INFO	6	/* informational */ ..a nivel informativo
#define	LOG_DEBUG	7	/* debug-level messages */...mensajes de debug..

        Pos bueno..lo primero que nos dice es que estan ordenadas de mas prio
ridad  a  menos  prioridad. .Todos estos tipos van destinados a como va a ser
logeado en  el log del systema, a efectos de portsentry que prioridad tendran
sus mensajes en este log  . .yo he decidido subir un nivel al que por defecto
nos  ofrece  el  programa  en su configuracion original, en vez de LOG_NOTICE
vamos a ponerlo en

LOG_WARNING,  entre  muchas  otras razones es mas explicito a la hora de leer
los logs del sistema.

al igual que en el caso anterior esto lo cambiamos asi...

 #define SYSLOG_LEVEL LOG_WARNING aunque si sois muy muy muy parnaoides
 podeis poner LOG_ALERT pero bueno, lo importante es que nos avise.


 Ahora ya hemos configurado como queremos que portsentry se comporte,
ahora podemos configurar mas cosas hasta dejarlo como queremos y a
nuestro gusto y acorde con nuestro sistema...

        Vamos con los puertos...




.==========================================================================.
|=========~ 1.3.2 Configurando los puertos. ~===============================
|===========================================================================

         Portsentry  en  su  configuración  original  nos  provee  3 posibles
configuraciones  para  la  configuracion de este apartado, para activar las o
desactivarlas, no tendremos mas que  descomentar la linea ..veamos como va,..

        #######################
	# Port Configurations #
	#######################
	#
	#
	# Some example port configs for classic and basic Stealth modes
	#
	# I like to always keep some ports at the "low" end of the spectrum.
	# This will detect a sequential port sweep really quickly and usually
	# these ports are not in use (i.e. tcpmux port 1)
	#
	# ** X-Windows Users **: If you are running X on your box, you need to be sure
	# you are not binding PortSentry to port 6000 (or port 2000 for OpenWindows users).
	# Doing so will prevent the X-client from starting properly.
	#
	# These port bindings are *ignored* for Advanced Stealth Scan Detection Mode.
	#

	# Un-comment these if you are really anal:
	#TCP_PORTS="1,7,9,11,15,70,79,80,109,110,111,119,138,139,143,512,513,514,515,540,635,1080,1524,2000,2001,4000,4001,5742,600
		   0,6001,6667,12345,12346,20034,27665,30303,32771,32772,32773,32774,31337,40421,40425,49724,54320"
	#UDP_PORTS="1,7,9,66,67,68,69,111,137,138,161,162,474,513,517,518,635,640,641,666,700,2049,31335,27444,34555,32770,32771,32
		   772,32773,32774,31337,54321"
	#
	# Use these if you just want to be aware:
	TCP_PORTS="1,11,15,79,111,119,143,540,635,1080,1524,2000,5742,6667,12345,12346,20034,27665,31337,32771,32772,32773,32774,40
		   421,49724,54320"
	UDP_PORTS="1,7,9,69,161,162,513,635,640,641,700,37444,34555,31335,32770,32771,32772,32773,32774,31337,54321"
	#
	# Use these for just bare-bones
	#TCP_PORTS="1,11,15,110,111,143,540,635,1080,1524,2000,12345,12346,20034,32771,32772,32773,32774,49724,54320"
	#UDP_PORTS="1,7,9,69,161,162,513,640,700,32770,32771,32772,32773,32774,31337,54321"

        Como configuracion por defecto nos da esta:
        # Use these if you just want to be aware:
	TCP_PORTS="1,11,15,79,111,119,143,540,635,1080,1524,2000,5742,6667,12345,12346,20034,27665,31337,32771,32772,32773,32774,40
		   421,49724,54320"
	UDP_PORTS="1,7,9,69,161,162,513,635,640,641,700,37444,34555,31335,32770,32771,32772,32773,32774,31337,54321"
 ----------------------------------------------------------------------------
 ----------------------------------------------------------------------------

  esta configuracion solo nos hara estar prevenidos, aun  asi  podemos añadir
mas puertos a las secuencias mediante ",Puerto" o podemos definir exactamente
los que nosotros queramos..

         Por ejemplo UDP_PORTS="1,69,162,..."

 Esto ya depende de vosotros y como lo querais, eso si, no definais el puerto
6000 o el 2000 si usais X o openwindows,hace referencia a  ello  pero  quiero
hacer  incapie  en ello no sea que no lo leais y os  limiteis a escribir como
locos sin leer.

  Pero  imaginemos  que  no estamos deacuerdo con esta opcion y queremos usar
cualquiera de las otras dos que nos ofrece, hariamos lo siguiente:

  Comentamos la opcion que no queremos uilizar, con # delante,
  # Use these if you just want to be aware:
  ->#TCP_PORTS="1,11,15,79,111,119,143,540,635,1080,1524,2000,5742,6667,12345,12346,20034,27665,31337,32771,32772,32773,32774,40
  ->#421,49724,54320"
  ->#UDP_PORTS="1,7,9,69,161,162,513,635,640,641,700,37444,34555,31335,32770,32771,32772,32773,32774,31337,54321"

   Descomentamos la opcion que queramos, la primera por ejemplo

   # Un-comment these if you are really anal:
   -> TCP_PORTS="1,7,9,11,15,70,79,80,109,110,111,119,138,139,143,512,513,514,515,540,635,1080,1524,2000,2001,4000,4001,5742,600
		   0,6001,6667,12345,12346,20034,27665,30303,32771,32772,32773,32774,31337,40421,40425,49724,54320"
	->UDP_PORTS="1,7,9,66,67,68,69,111,137,138,161,162,474,513,517,518,635,640,641,666,700,2049,31335,27444,34555,32770,32771,32
		   772,32773,32774,31337,54321"

      y listo, si quereis quitar o añadir puertos veis el apartado anterior.



.==========================================================================.
|=========~ 1.3.3 Configurando las opciones avanzadas ~=====================
|===========================================================================


        El sistema tradicional de deteccion esta muy bien, decimos que puertos
queremos  proteger  pero  portsetry  dispone  de  mas  ventajaslos  metodos de
deteccion avanzados.

        Al  seleccionar los metodos  de deteccion  avanzados se ignoraran las
Configuraciones  de puertos que  hemos echo antes y nos va a ser mas sencillo
configurar ya que simplemente diremos un valor de puerto y por debajo de el..
todos quedaran vigilados. Como en el caso anterior  tambien  se nos ofrece la
posibilidad  de  si deseamos   excluir algun puerto manualmente del  rango lo 
podamos excluir, veamos como lo hacemos en la practica:

       ###########################################
       # Advanced Stealth Scan Detection Options #
       ###########################################
	#
	# This is the number of ports you want PortSentry to monitor in Advanced mode.
	# Any port *below* this number will be monitored. Right now it watches
	# everything below 1024. 
	# 
	# On many Linux systems you cannot bind above port 61000. This is because
	# these ports are used as part of IP masquerading. I don't recommend you
	# bind over this number of ports. Realistically: I DON'T RECOMMEND YOU MONITOR 
	# OVER 1024 PORTS AS YOUR FALSE ALARM RATE WILL ALMOST CERTAINLY RISE. You've been
	# warned! Don't write me if you have have a problem because I'll only tell
	# you to RTFM and don't run above the first 1024 ports.
	#
	#
	ADVANCED_PORTS_TCP="1024"
	ADVANCED_PORTS_UDP="1024"
	#
	# This field tells PortSentry what ports (besides listening daemons) to
	# ignore. This is helpful for services like ident that services such 
	# as FTP, SMTP, and wrappers look for but you may not run (and probably
	# *shouldn't* IMHO).
	#
	# By specifying ports here PortSentry will simply not respond to
	# incoming requests, in effect PortSentry treats them as if they are
	# actual bound daemons. The default ports are ones reported as 
	# problematic false alarms and should probably be left alone for
	# all but the most isolated systems/networks.
	#
	# Default TCP ident and NetBIOS service
	ADVANCED_EXCLUDE_TCP="113,139"
	# Default UDP route (RIP), NetBIOS, bootp broadcasts.
	ADVANCED_EXCLUDE_UDP="520,138,137,67"
-----------------------------------------------------------------------------
      La manera de configurar esto pues ya es cosa al gusto del administrador X),
 como  veis esta excluido el 139 y el ident,  yo personalmente no he excluido esto de mi portsentry, motivo?..quien me  toque esos puertos  si no  es de mi dominio . . puede ser un tipo buscandolelas cosquillas a mi maquina, prefiero las falsas alarmas.  si no lo quisierais asi, nada aplicais lo que explicamos antes solo que en este caso como veis  no  se  encuentra  comentado . . se os recomienda eso si no monitorizar puertos  por enzima de 1024, ya que tendreis muchas falsas alarmas..dependiendo de lo escrupulosos que seais y si usais ip masquerading no podreis blindar los puertos por enzima  de 61000 . .eso os lo explica en guiri hay arriba ..

       Si  teneis  algun  servidor  de  FTP corriendo u otro tipo de demonio, telnets  (pordios cambiarlo a SHH) deberiais de excluirlos ya que en el  caso
De  que  alguno  de  los  que  realmente  tienen  acceso al sistema se quiera conectar . . . le blokeareis y ademas sin decirle ni media palabra :), si  no teneis nada corriendo..pos nada.




.==========================================================================.
|=========~ 1.3.4 Poniendolo guapo para la fiesta X) ~======================
|===========================================================================


       A continuacion tenemos mas cosas guapas para configurar ...veamoslas !

       ######################
       # Configuration Files#
       ######################
	#
	# Hosts to ignore
	IGNORE_FILE="/usr/local/psionic/portsentry/portsentry.ignore"
	# Hosts that have been denied (running history)
	HISTORY_FILE="/usr/local/psionic/portsentry/portsentry.history"
	# Hosts that have been denied this session only (temporary until next restart)
	BLOCKED_FILE="/usr/local/psionic/portsentry/portsentry.blocked"


        Aqui tenemos 3 archivos muy guapos:


IGNORE_FILE nos  va  a  recoger   al  archivo el cual contiene los  host  que 
automaticamente ignorados . . aqui deberiais de incluir a el host y direccion
de vuestra maquina y si teneis una red local los host y direcciones de  estas 
maquinas.

         Que significa lo de ignorados? pues que no se les blokeara, ante una
conexion de ellos..portsentry directamente pasara de ellos...una cosita..real
mente  creeis  que  es  bueno  ignorar  a  los  host  de  vuestra  red local? 
dependiendo  de  la  extensión  de esta  claro, si mi red tiene 2 pcs pues no
vamos a rompernos la cabeza..pero..y si alguien ganase control sobre un pc de nuestra  red? no oleríamos  k  a nivel  de puerto algo raro sucede..y tampoco podriamos  blockear  spoofs  de ip con ips de nuestro  dominio...PARANOIA! yo personalmente no ig noraria a ninguna  maquina nada mas que a la mia. que  es 
de la que mas o menos me puedo sentir seguro.
              

HISTORY_FILE  nos  va  a  recoger  la  historia  de lo que sucede o ha venido
sucediendo desde que metimos portsentry, hay poco mas que comentar pero . .es 
un log..aseguraros de que NADIE en la maquina tenga acceso a ese archivo y no 
me seais cutres y lo oculteis..cambiarlos de sitio y ponerles  nombres  mas o menos Inocentes por ejemplo   /root/supercalifragilistico.espialidoso XD ¿que porque tanto secretito?,  que pasa si alguien ha entrado? o si tu maquina  es fisiscamentte accedida por otra persona? normalmente antes de una intrusion..
lo mas normal es que lo primeros  pasos  sean una  serie  de  scaneos, ningun metodo  es  infalible y lo unico  k te puede orientar de que  esta pasando es muchas  veces  ver  que  ha  estado  pasando cuando estabamos tomando el cafe tranquilamente.  Personalmente . . .yo haria  esto  con  todos  los  archivos importantes y de log, despues de una intrusion,tanto si han echo root como si no, los log valenoro ya que es una huella que hay que borrar...no lo pongamos facil.

BLOCKED_FILE es como history, es un archivo donde se almacenan los eventos de
la sesion  hasta que  la maquina  sea apagada,  es decir  es  un History pero reciente, lo mismo que os  comentaba  ...esconderlo..y ojo..Xd acordaros de k esto es la configuracion,esconderla tambien, de nada nos vale tenerla visible por ahi danzando ..si se puede leer . .  habremos echo aguas al menos en este apartado.


##############################
# Misc. Configuration Options#
##############################
#
# DNS Name resolution - Setting this to "1" will turn on DNS lookups
# for attacking hosts. Setting it to "0" (or any other value) will shut
# it off.
RESOLVE_HOST = "1"

  Esto nada . . . si queremos que le meta un dns lookup a la makina . . si le 
pones 0 lo desactivas y con 1 lo activas..tu pispo y tu pispidad :)P


##################
# Ignore Options #
##################
# These options allow you to enable automatic response
# options for UDP/TCP. This is useful if you just want
# warnings for connections, but don't want to react for
# a particular protocol (i.e. you want to block TCP, but
# not UDP). To prevent a possible Denial of service attack
# against UDP and stealth scan detection for TCP, you may 
# want to disable blocking, but leave the warning enabled. 
# I personally would wait for this to become a problem before
# doing though as most attackers really aren't doing this.
# The third option allows you to run just the external command
# in case of a scan to have a pager script or such execute
# but not drop the route. This may be useful for some admins
# who want to block TCP, but only want pager/e-mail warnings
# on UDP, etc.
#
# 
# 0 = Do not block UDP/TCP scans.
# 1 = Block UDP/TCP scans.
# 2 = Run external command only (KILL_RUN_CMD)
	 BLOCK_UDP="1"
BLOCK_TCP="1"
 ----------------------------------------------------------------------------            

-----------------------------------------------------------------------------
Bueeeno bueno bueno..aqui hay algo mas de miga en el asunto..veamos,portsentry 
puede hacer 3 cosas..
           No bloquear el scaneo en tcp/udp
           Bloquearlo..
           Bloquearlo y ejecutar un comando/script.

 aqui se nos da la opcion de decirle que queremos..logicamente bloquearlo no?
o bien podriamos querer solo que se nos informe                ....

 La opcion de ejecutar un comando vamos a verla conjuntamente 
con la configurasion del comando/script que es mas logico no?
-----------------------------------------------------------------------------
     imaginemos que en block_udp hemos puesto un 2;

###################
# External Command#
###################
# This is a command that is run when a host connects, it can be whatever
# you want it to be (pager, etc.). This command is executed before the
# route is dropped or after depending on the KILL_RUN_CMD_FIRST option below
#
#
# I NEVER RECOMMEND YOU PUT IN RETALIATORY ACTIONS AGAINST THE HOST SCANNING 
# YOU!
#
# TCP/IP is an *unauthenticated protocol* and people can make scans appear out
# of thin air. The only time it is reasonably safe (and I *never* think it is 
# reasonable) to run reverse probe scripts is when using the "classic" -tcp mode. 
# This mode requires a full connect and is very hard to spoof.
#
# The KILL_RUN_CMD_FIRST value should be set to "1" to force the command 
# to run *before* the blocking occurs and should be set to "0" to make the 
# command run *after* the blocking has occurred. 
#
#KILL_RUN_CMD_FIRST = "0"
#
#
#KILL_RUN_CMD="/some/path/here/script $TARGET$ $PORT$"

KILL_RUM_CMD_FIRST = "0" o "1" nos dira si queremos la ejecucion ANTES DE BLOQUEAR
 o DESPUES DE HABERLO ECHO. por ejemplon podriamos hacer correr un script que nos 
informase..o simplemente un echo XD (que cutre zomo po dio)

KILL_RUN_CMD="echo Atencion el señor jaiker X te llama por el puerto $PORT$ desde
 $TARGET$" lo cual deberia mostrar una salida por consola diciendonos algo como esto:
            El señor jaiker X te llama por el puerto 313 desde 194.34.56.12

  si sois un poco curiosinos pos os haceis un script chulo k haga lo que querais..

       
#####################
# Scan trigger value#
#####################
# Enter in the number of port connects you will allow before an
# alarm is given. The default is 0 which will react immediately.
# A value of 1 or 2 will reduce false alarms. Anything higher is 
# probably not necessary. This value must always be specified, but
# generally can be left at 0. 
#
# NOTE: If you are using the advanced detection option you need to
# be careful that you don't make a hair trigger situation. Because
# Advanced mode will react for *any* host connecting to a non-used
# below your specified range, you have the opportunity to really 
# break things. (i.e someone innocently tries to connect to you via 
# SSL [TCP port 443] and you immediately block them). Some of you
# may even want this though. Just be careful.
#
SCAN_TRIGGER="0"

-----------------------------------------------------------------------------
 Esto responde a la frase..tengo muucha paciencia pero ta donde me dejo tokar
 los webbez?..usease..cuantas conexiones permitimos antes de k portsentry se 
ponga a blockear y a darnos alarmas ? bueno..si no queremos que a la primera 
de cambio un amigo sea bloqueado pues podemos decir..haber DDiego pal Shh..
spark en el ftp...humm a la 3 conexion me das el toque.
-----------------------------------------------------------------------------
               SCAN_TRIGGER="3"

              Tan simple como eso :)

           ######################
           # Port Banner Section#
           ######################
	   #
	   # Enter text in here you want displayed to a person tripping the PortSentry.
	   # I *don't* recommend taunting the person as this will aggravate them.
	   # Leave this commented out to disable the feature
	   #
	   # Stealth scan detection modes don't use this feature
	   #
	   #PORT_BANNER="** UNAUTHORIZED ACCESS PROHIBITED *** YOUR CONNECTION ATTEMPT HAS BEEN LOGGED. GO AWAY."
-----------------------------------------------------------------------------
   Veamos  esto  solo es operativo para modos de  deteccion normales, no  los
avanzados,  los  avanzados  son silenciosos . . esto lo que hace es enviar un
mensaje al tio que se quiere conectar...si lo  queremos usar lo descomentamos
y escribimos lo que queramos.

 PORT_BANNER="ATENCION PERRO SUELTO!!, el administrador de esta maquina es un 
Perro  y  lo  logea  todo. tu  intento  ha sido logeado  y sera enviado a las
autoridades, vete a enrredar en los puertos en serie de tu novia chavalin.  "

    Si  en  algun  momento  os  encontrais  con  algo como esto en uno de los 
escaneos  a un host...

               "Hola soy un programa en basic. y tu un puntero a Char, si los
                puertos me tocas una ostia te vas a ganar :)"

               habreis dado con mi maquina. XDDDD

               No metais mensajes ofensivos..ser tolerantes con la gente y no 
              los provoqueis un mensaje ofensivo podria hacer que el atacante 
              se obscecara con vosotros y a saber como puede reaccionar..
              recordar que correr un DOS es una pijada y si no teneis un guar
              dian de red..un smurf es muy jodido de detener y localizar su 
              origen..y IPCHAINS no lo para. es solo un firewall.
              Recordar que hay mucho traumatizado en la red XDD.

   Bueno  las  demas  opciones (me  he dejado una no creais que no  lo se,las 
explorais  vosotros . . es  simplemente el tipo de host local que teneis para
denegar  los paquetes a uno inexistente . .descomentais y tal..que ia toy tal 
fistro anal de tanto
portsentry puñetas.
-----------------------------------------------------------------------------


   Bueno..esto era la configuracion..hace unas cuantas lineas arriba habiamos
dicho  que  esto era por si sus bajabais  el codigo (ver mas arriba pa ver de 
donde), vale...ahora lo amos a instala.

              Make (te pedira que le digas el sistema, por eso nos hemos 
              saltado lo de Dropping Routes ...
              
              empiezan a salir paranoias por la pantalla..blalblalbalbalba

              Make install ...ala instalao.. 

              ahora lo activamos..
          
                  portsentry -udp | -tcp | -stcp |-sudp| -atcp | -audp
                          
                    -udp -> modo basico de deteccion udp
                    -tcp -> "                      " tcp
                    -stcp->no es super tcp XD, es stealth tcp osea deteccion de 
                           escaneos ocultos tcp
                    -sudp->lo pispo pero pa udp.
                    -atcp->metodos avanzaos en tcp.
                    -audp->avanzaos en udp.

              deberemos de ejecutar una vez el programa por opcion..for sample
        
                  [root @Disidents w3ndig0 as root]# portsentry -audp
                  [root @Disidents w3ndig0 as root]#
                  [root @Disidents w3ndig0 as root]# portsentry -atcp
                  [root @Disidents w3ndig0 as root]#
                  [root @Disidents w3ndig0 as root]# me mola tu gramola
                   bash: me: command not found 
                  [root @Disidents w3ndig0 as root]#


Que resulta que ya lo teniais instalao?..pos nada de nada..aplicais las
opciones de configuracion aqui descritas..en los archivos descritos..y con
las recomendaciones si quereis descritas.


.==========================================================================.
|=========~ 1.4.0 IcmpInfo El detector de rastreos y bombas ICMP ~==========
|===========================================================================


Bien lo primero donde podeis conseguirle,
ftp://hplyot.obspm.fr/net/icmpinfo-1.11.tar.gz, ademas os dire que si sois 
un pelin vagos..este os va a gustar :) ya que no tiene ningun  tipo de confi-
guracion.

     Otros sitios alternativos de descarga:

         http://sunsite.ics.forth.gr/sunsite/systools/netmon/icmpinfo/    
         http://packages.debian.org/stable/net/icmpinfo.html

-----------------------------------------------------------------------------   
   1.4.1 Que es IcmpInfo?
-----------------------------------------------------------------------------
     
     Con portsentry podiamos monitorizar el  trafico entrante TCP y UDP,  ver 
scaneos ocultos etc, pero siempre cabia  la  posibilidad de ataques por ping, 
tanto entrantes o salientes, es decir, que nuestra maquina sea el  punto  de 
inicio de un ataque a otra paquina por ejemplo, que alguno de nuestros  usuar
ios, se dedique a correr smurfs etc..o que seamos parte  de  un amplificador,
es  decir  que  un  smurf  use  la broadcast de nuestra red para atacar  otra 
maquina. La idea es que todo el trafico ICMP tambien pueda ser controlado  en 
la medida  que  nos  sea  posible. Con  IcmpInfo  lo vamos  a conseguir y con
matricula de honor.

-----------------------------------------------------------------------------  
   1.4.2 Bajando e instalado IcmpInfo
-----------------------------------------------------------------------------

     Antes de nada, aseguraros de que teneis los  includes de red necesarios, 
como lo sabeis?..una buena manera es ver si existe  el  siguiente  directorio 
/usr/include/netinet/

     Acontinuacion..verificado que tenemos lo necesario..lo bajamos. . y  una  
vez bajado..lo descomprimimos, para los mas novatos os pongo como se hace:

    [root @Disidents w3ndig0 as root]# gunzip icmpinfo-1.11.tar.gz
    [root @Disidents w3ndig0 as root]# tar -xvf icmpinfo-1.11.tar.gz 
    icmpinfo-1.11/
    icmpinfo-1.11/print.c
    icmpinfo-1.11/icmpinfo.c
    icmpinfo-1.11/README
    icmpinfo-1.11/defs.h
    icmpinfo-1.11/DOC
    icmpinfo-1.11/icmpinfo.man
    icmpinfo-1.11/NocTools.Infos
    icmpinfo-1.11/recvping.c
    icmpinfo-1.11/Makefile
    icmpinfo-1.11/CHANGES
    icmpinfo-1.11/err.c
    icmpinfo-1.11/linux_ip_icmp.h
    icmpinfo-1.11/TODO
    icmpinfo-1.11/LICENSE
    icmpinfo-1.11/CHECKSUMS.asc

    se os creara un directorio: /icmpinfo-1.11/ dentro del que esteis y en el 
    descomprimira el archivo.
  
    [root @Disidents w3ndig0 as root]# cd /icmpinfo-1.11/
    [root @Disidents w3ndig0 as root]# ls -al
    drwxr-xr-x    2 root     bin          4096 ene 24 10:39 ./
    drwx------   43 root     root         4096 ene 24 10:37 ../
    -rw-r--r--    1 root     sys          1769 ago 28  1995 CHANGES
    -r--r--r--    1 root     sys           930 ago 28  1995 CHECKSUMS.asc
    -rw-r--r--    1 root     sys          1613 may 26  1994 defs.h
    -rw-r--r--    2 root     sys          4363 ago 28  1995 DOC
    -rw-r--r--    1 root     sys           311 abr 22  1994 err.c
    -rw-r--r--    1 root     sys          4190 ago 28  1995 icmpinfo.c
    -rw-r--r--    1 root     sys          1657 ago 28  1995 icmpinfo.man
    -rw-r--r--    1 root     sys          4690 ago 28  1995 LICENSE
    -rw-r--r--    1 root     sys          3791 may 11  1994 linux_ip_icmp.h
    -rw-r--r--    1 root     sys           837 ago 17  1995 Makefile
    -rw-r--r--    1 root     sys          1416 ago 17  1995 NocTools.Infos
    -rw-r--r--    1 root     sys          6561 ago 28  1995 print.c
    -rw-r--r--    2 root     sys          4363 ago 28  1995 README
    -rw-r--r--    1 root     sys           552 ene  7  1994 recvping.c
    -rw-r--r--    1 root     sys            45 ago 17  1995 TODO
                      
    A continuacion...creamos el paquete con make..muy sencillo 
(desde donde estais osea en el directorio /icmpinfo-1.11/

       [root @Disidents w3ndig0 as root]# make
       bla bla bla bla bla

       Si todo ha ido bien..ya lo tendreis listo para ser usado.

       El programa trae un muy descriptivo README . . leerlo..aparte de esto,
Yo no me limitare a describiros las opciones y demas, si quereis tener futuro
en esto iros aconstumbrando a leer en ingles mucha documentacion, la  mayoria
de las veces, por desgracia, la mejor documentacion esta en ingles.



.==========================================================================.
|=~ 2.0 Controlando que se abre, se envia y se recive y por donde en win. ~=
|===========================================================================

============================================================================

.==========================================================================.
|======~ 2.1.0 Planteamientos preeliminares. ~==============================
|===========================================================================

      Bueeeno  bueno bueno .  .si bien en el articulo de linux he optado  por
explicaros un  programa  echo,  en  windows, que supongo todos lo tendreis en
mayor o menor medida visitado  y conocido, odiado o amado eso  dependiendo de
vuestro criterio, yo opto por no explicaros como hacer  funcionar un  monitor
de puertos,voy a optar a tratar de enseñaros como hacerlo vosotros mismos.

    Como  siempre,  uno se plantea a la hora de desarrollar una aplicacion si 
maneja varios lenguajes..k lenguaje usar...en visual c++ o  visual c?..delphi 
o Vjava?...y en VBasic? XDd 

      Supongo  que  al  oir  lo de Vb todos habreis sonrreido y tal..ahora es 
Cuando  se  os  queda la risa  congelada y  os digo que haremos un monitor de 
puertos en visual Basic... :) 

     Porque  Vbasic? . .  y porque no? a fin de cuentas usemos el  lenguaje k 
usemos .. para llamar a un par de apis..nos vale tanto uno como otro asique a 
efectos nos la suda. eh! y hay que decir que mas adelante vereis una serie de 
cuestiones  que  os  indicaran  que el diseño de las apis que vamos a usar es 
para C++ o C, pero como somos muy chulos..lo haremos en VB y con EXITO!.



.==========================================================================.
|======~ 2.2.0 Una vision intuitiva. ~======================================
|===========================================================================


    Bien, como de lo que se trata es de que penseis y despertaros el gusanin,
Vamos   a  pensar  juntos  una  serie  de  cuestiones  y  a plantear posibles
solucionesa nuestro problema..ver los puertos y su actividad.

    a) Podriamos hacer una shell ejecutando un netstat..a quien piense esto..
que inmediatamente deje de leer  el  Seine  y  se  dedique  al  pastoreo.  No
queremos  usar  un comando  . . queremos  HACERLO  nosotros  o  al  menos  en
parte..cuanto menos..mejorar lo existente.

   b) Una posible opcion seria pedir al usuario los puertos que se desean ser
vigilados,  apartir  de  ahi, y si no hay nada corriendo alertar de cualquier
conexion a ellos, problema..no detectariamos nada mas que en esos  puertos  y
estariamos seriamente limitados.Si alguno quereis ver un ejemplo de como hace
esto  podeis  pedirme  el  codigo  ejemplo  del  DESILUSIONATOR  programa que
exactamente hace eso ..escuchar por puertos y alertar de coexiones..claro que
aparte de  eso  una  de las opciones es enviar por ese puerto una descarga de
texto  bloqueando  o  bubbleando  a  cualquier  mal  escaner implementado. De
cualquier  modo,  es  una  solucion  demasiado simple y que nos deja muy poco
juego. (para pedirme el codigo me podeis encontrar en el canal #disidents del
irc hispano, NO LO ENVIO A CORREOS).

   c) Y  si  pudiéramos  ver claramente  TODO lo que pasa en nuestro sistema?
desde envios de ping que nos llegan a paquetes  mal  fragmentados. etc  etc .
.etc.. Whao..eso seria poco menos que genial verdad?. . . y alguno dira..bah!
eso ya lo hacen muchos programas..y yo le contestare..tienes  menos futuro en
esto  que  un  chorizo  en  la  boca  de  un  gitano. Razon? si no sabes como
funciona..no lo uses, ese es mi lema y a el me remito.



    Veamos,  ahora llega lo gordo, sabemos lo que queremos, (la opcion C para
 los despistados XD ) peero..no sabemos como hacerlo..ala pos a leer :)

 Es fundamental que tengais algunas nociones de Vbasic, lo demas he comentado
 arduamente el codigo y creo que os sera facil leerlo..o eso   espero vamos..

  El sigiente modulo es un .bas que debereis de agregar a vuestro proyecto,
luego despues de pegaroslo os comento una serie de cuestiones..
primero..echarle un ojo ;)

-----------------------------------------------------------------------------


  Attribute VB_Name = "Conexiones"
'(nombre del modulo interno que tendreis que darle si quereis en el explorador
' de proyecto, si quereis copiar y pegar..no quiteis esto simp'lemente guardar
' la copia como un .bas y ala agregarlo.)
'################################################################################
'#          DISIDENTS CODEX 2001-02                                             #
'# Modulo encargado de proporcionar conexiones y estados de                     #
'# los puertos udp y tcp y transferencias                                       #
'#                                                                              #
'# Desarrollado por w3ndig0 para Disidents C0dex                                #
'# no hay derechos ..solo incluye una referencia                                #
'# al origen del mismo si usas este codigo para algo...                         #
'#                                                                              #
'# Compartir los conocimientos es la base de una cultura floreciente. w3ndig0   #
'# la potencia sin control no sirve de nada. pirelly                            #
'# La curiosidad y el empeño es el atributo del hombre. w3ndig0                 #
'# Si bebes no programes. anonimo ;)                                            #
'################################################################################
' option explicit pa no meter la gamba con las variables...
Option Explicit

'bueno bueno bueno...amos a declarar las funciones del api

'api para capturar las conexiones TCP del pc..ya bien sean activas o esten en otro estado
 Private Declare Function GetTCPtable Lib "IPhlpApi" Alias "GetTcpTable" (pTcpTable As MIB_TCPTABLE, bufferSize As Long, shorted As Boolean) As Long
'api para capturar las conexiones UDP esten en el estado en que esten
Private Declare Function GetUDPtable Lib "IPhlpApi" Alias "GetUdpTable" (PUDPTable As MIB_UDPTABLE, bufferSize As Long, shorted As Boolean) As Long


'empezamos por definir las extructuras..
'#############################################################################
'Extructura para la Tabla de TCP (conexiones TCP y sus diferentes estados
'algo compleja..pero tampoco en exceso..
'#############################################################################
'El orden de declaracion de extructuras es importante ya k segun las vamos
'declarando las vamos a ir usando ... la principal..osea la k pasaremos a la
'funcion es la ultima..




'Esta extructura nos almacena lo que es la conexion en si para cada entrada TCP
Private Type MIB_TCPROW
  dwState As Long                ' state of the connection
  dwLocalAddr(0 To 3) As Byte    ' address on local computer (0.1.2.3 ejemplo: 213.32.125.123 ;) )
  dwLocalPort As String * 4      ' port number on local computer
  dwRemoteAddr(0 To 3) As Byte   ' address on remote computer (0.1.2.3 ejemplo: 213.32.125.123 ;) )
  dwRemotePort As String * 4     ' port number on remote computer
End Type


'Extructura principal
Public Type MIB_TCPTABLE
  dwNumEntries As Long        ' number of entries in the table
  aeTable(100) As MIB_TCPROW  ' array of TCP connections
End Type
'#############################################################################
' bueno si te has enterado..esquemita al canto...                            #
'#############################################################################
'                                                                            #
'                                                                            #
'               ->Dwnumentries   (numero de conexiones)                      #
'  MIB_TCPTABLE                                                              #
'               ->Aetable(100) ----->Mib_tcpRow donde aetable es             #
'                                            un array estatico               #
'                                            de tipo Mib_tcpRow              #
'#############################################################################
'#############################################################################
'Extructura para la Tabla de UDP (conexiones UDP y sus diferentes estados
'logicamente es algo diferente a la TCP...
'#############################################################################
'extructura que nos va a recoger los datos...leer lo anterior para las otras
'declaraciones..creo k esta suficientemente claro no? ;) (es mas de lo mismo)


Private Type MIB_UDPROW
  dwLocalAddr(0 To 3) As Byte ' IP address on local computer(0.1.2.3 ejemplo: 213.32.125.123 ;) )
  dwLocalPort As String * 4   ' port number on local computer
End Type

Type MIB_UDPTABLE
dwNumEntries As Long          ' number of entries in the table
aeTable(100) As MIB_UDPROW    ' table of MIB_UDPROW structs
End Type

Public Function GetTCPtableF() As MIB_TCPTABLE
'captura de la tabla de conexiones TCP
Dim tabla  As MIB_TCPTABLE
Dim sizeoftable As Long
Dim retorno  As Long
sizeoftable = 20 * 100 + 4 'un buen buffer guapo y sobrado
retorno = GetTCPtable(tabla, sizeoftable, True)
GetTCPtableF = tabla
End Function
Public Function getUDPtablef() As MIB_UDPTABLE
'captura de la tabla de conexiones UDP
Dim tabla As MIB_UDPTABLE
Dim sizeoftable As Long
Dim retorno As Long
sizeoftable = 20 * 100 + 4 'un buen buffer guapo y sobrado
retorno = GetUDPtable(tabla, sizeoftable, True)
getUDPtablef = tabla
End Function




bien esto que es?¿...aver,,lo primero porque los comentarios en guiri?...lo
vereis mas adelante la razon es simple, a fin de no liaros la pelota poniendo
nombres a las variables "extraños" me he limitado a copiar
exactamente las que en la descripcion de microsoft hacen..motivo?
porque seguramente os pasareis por alli a echar un ojo.

y W3n? como churrula esto? bien, veaamos..las conexiones tcp y udp son retor
nados por el api al realizar las llamadas en un formato definido, en este caso
un tipo de dato definido por el usuario, este tipo contiene varios elementos,
 normalmente uno que nos dice el numero de elementos del otro, en este caso ..
el numero de conexiones TCP o UDP, echar un ojo al codigo...



Bien..y como la usamos? ..lo primero que tendreis que tener en cuenta es el tipo
de datos que nos retorna la funcion..veamos

Public Function GetTCPtableF() As MIB_TCPTABLE <--- Este es el tipo que retorna.
'captura de la tabla de conexiones TCP
Dim tabla  As MIB_TCPTABLE
Dim sizeoftable As Long
Dim retorno  As Long
sizeoftable = 20 * 100 + 4 'un buen buffer guapo y sobrado
retorno = GetTCPtable(tabla, sizeoftable, True)
GetTCPtableF = tabla
End Function



-----------------------------------------------------------------------------
Ahora la pregunta del millon de dolares..si retorna un MIB_TCPTABLE..como de
beremos recoger esto en la llamada a la funcion??..de que color era el caballo
blanco de santigao? Blanco!! pues en un tipo MIB_TCPTABLE y asi con la otra
funcion.
De ahi la importancia de declarar MIB_TCPTABLE como publica, asi os ahorrais
definir otro tipo dentro de un formulario por ejemplo.

Creo que he comentado las librerias claramente, si no entendeis algo echar
mano de un libro de visual basic competente, k los hay (Visual basic 6 de Fco.
Javier Ceballos, agarraros porke el librito pesa medio kilo, editorial RA-MA,
desde aqui mando un saludo al autor con el cual yo aprendi a programar en su
libro TURBO BASIC de la misma editorial, un estupendo libro para autodidactas
como el menda lerenda).

Dicho esto..ale k corra el codigo y fijaros en los comentarios creo k son
claros y vastante explicitos, si no entendeis algo, ya sabeis onde localizarme.
-----------------------------------------------------------------------------



'          DISIDENTS CODEX 2001-02
' Modulo encargado de proporcionar estadisticas de
' los puertos udp y tcp y transferencias
'
' Desarrollado por w3ndig0 para Disidents C0dex
' no hay derechos ..solo incluye una referencia
' al origen del mismo si usas este codigo para algo...
'
' Compartir los conocimientos es la base de una cultura floreciente. w3ndig0
' la potencia sin control no sirve de nada. pirelly
' La curiosidad y el empeño es el atributo del hombre. w3ndig0
' Si bebes no programes. anonimo ;)

' option explicit pa no meter la gamba con las variables...
' Option Explicit

' declaraciones del api ...ver pagina de microsoft http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tcpip/tcpip_8kfb.asp
Private Declare Function GetIcmpStatistics Lib "IPhlpApi" (StdICMP As MIB_ICMP) As Long
Private Declare Function GetIpStatistics Lib "IPhlpApi" (pStats As MIB_IPSTATS) As Long
Private Declare Function GetTcpStatistics Lib "IPhlpApi" (pTCPstats As MIB_TCPSTATS) As Long
Private Declare Function GetUdpStatistics Lib "IPhlpApi" (pUDPstats As MIB_UDPSTATS) As Long
' declaraciones de extructuras ...ñaaarererrooo raro roo...jeje

' Extructura para estadisticas IP..siempre que llego a caaasa te pillo en la coziinaa...
'########################################################################################
Public Type MIB_IPSTATS
    dwForwarding As Byte       ' IP forwarding activado o no activado
    dwDefaultTTL As Long       ' default time-to-live
    dwInReceives As Long       ' datagrams received
    dwInHdrErrors As Long      ' received header errors
    dwInAddrErrors As Long     ' received address errors
    dwForwDatagrams  As Long   ' datagrams forwarded
    dwInUnknownProtos As Long  ' datagrams with unknown protocol
    dwInDiscards As Long       ' received datagrams discarded
    dwInDelivers   As Long     ' received datagrams delivered
    dwOutRequests  As Long     ' peticiones de conexion
    dwRoutingDiscards  As Long '
    dwOutDiscards  As Long     ' sent datagrams discarded
    dwOutNoRoutes   As Long    ' datagrams for which no route exists
    dwReasmTimeout  As Long    ' datagrams for which all
                               ' frags Not did
    dwReasmReqds  As Long      ' datagrams requiring re-assembly
    dwReasmOks  As Long        ' successful re-assemblies
    dwReasmFails  As Long      ' failed re-assemblies
    dwFragOks   As Long        ' successful fragmentations
    dwFragFails  As Long       ' failed fragmentations
    dwFragCreates As Long      ' datagrams fragmented
    dwNumIf    As Long         ' number of interfaces on computer
    dwNumAddr  As Long         ' number of IP address on computer
    dwNumRoutes  As Long       ' number of routes in routing table
End Type
'######################################################################################
' extructuras para estadisticas ICMP es algo mas complicado..pero no mucho mas..no nos asustemos..
' como vereis el motivo de la complicacion es que en una extructura nos va a retornar los ICMP
' Salientes y los ICMP entrantes, dividido en entrantes y salientes, haciendo mucho mas sencillo
' el trabajo con la informacion recivida. asique 3 extructuras..una con todo..otra con una division
' entre ICMP entrantes/salientes y una generica con las stadisticas.

' tipo generico para ICMP entrantes y salientes
Public Type MIBICMPSTATS
  dwMsgs  As Long             'number of messages
  dwErrors  As Long           ' number of errors
  dwDestUnreachs  As Long     'destination unreachable messages
  dwTimeExcds  As Long        'time-to-live exceeded messages
  dwParmProbs   As Long       'parameter problem messages
  dwSrcQuenchs  As Long       'source quench messages
  dwRedirects  As Long        'redirection messages
  dwEchos   As Long           'echo requests
  dwEchoReps    As Long       'echo replies
  dwTimestamps    As Long     'time-stamp requests   dwTimestampReps    As Long  'time-stamp replies
  dwAddrMasks    As Long      'address mask requests
  dwAddrMaskReps    As Long   'address mask replies
End Type

' un tipo de datos que almacena entradas y salidas apuntando a MIBICMPSTATS
Public Type MIBICMPINFO
     icmpInStats As MIBICMPSTATS   ' stadisticas para mensajes ICMP entrantes
     icmpOutStats As MIBICMPSTATS ' Stadisticas para mensajes ICMP Salientes
End Type

' El tipo de datos qye apunta a los otros dos en cadena y que es el que pasamos al api
Public Type MIB_ICMP
   stats As MIBICMPINFO   ' contiene las estadisticas icmp
End Type

'######################################################################################
'Si no te has aclarado mucho..nada un esquemita pa que lo veas mas claro ;)           #
'######################################################################################
'#                                                                                    #
'#                                                                                    #
'#                                  --->icmpinstats  ----->MIBICMPSTATS               #
'#  Mib_icmp -->stats--->Mibicmpinfo                                                  #
'#                                  --->icmpoutstats ----->MIBICMPSTATS               #
'#                                                                                    #
'#                                                                                    #
'######################################################################################
'######################################################################################
' aaale amos a las extructuras para etadisticas tcp...mas de lo mismo..
'######################################################################################
Public Type MIB_TCPSTATS
  dwRtoAlgorithm As Long   '    time-out algorithm
  dwRtoMin As Long  '           minimum time-out
  dwRtoMax  As Long '           maximum time-out
  dwMaxConn  As Long '          maximum connections
  dwActiveOpens  As Long '      active opens
  dwPassiveOpens  As Long '     passive opens
  dwAttemptFails  As Long '     failed attempts
  dwEstabResets   As Long '      established connections reset
  dwCurrEstab  As Long '        established connections
  dwInSegs  As Long '           segments received
  dwOutSegs   As Long '          segment sent
  dwRetransSegs   As Long '      segments retransmitted
  dwInErrs   As Long '           incoming errors
  dwOutRsts  As Long '          outgoing resets
  dwNumConns   As Long '         cumulative connections
End Type
'######################################################################################
' Ahora las extructuras UDP ...pos na..lo de siempre..
'######################################################################################
Public Type MIB_UDPSTATS
  dwInDatagrams As Long  '    received datagrams
  dwNoPorts As Long  '        datagrams for which no port exists
  dwInErrors As Long  '       errors on received datagrams
  dwOutDatagrams As Long  '   sent datagrams
  dwNumAddrs  As Long '       number of entries in UDP listener table
End Type
'######################################################################################



 Public Function getIPestadist() As MIB_IPSTATS
Dim longitud As Long
Dim estadistica As MIB_IPSTATS
longitud = GetIpStatistics(estadistica)
'retornamos la tabla de estadisticas
getIPestadist = estadistica
End Function
Public Function getICMPstadist() As MIB_ICMP
Dim estadistica As MIB_ICMP
Dim retorno As Long
retorno = GetIcmpStatistics(estadistica)
'retornamos la tabla de estadisticas
getICMPstadist = estadistica
End Function
Public Function GetTCPstadist() As MIB_TCPSTATS
Dim retorno As Long
Dim estadistica As MIB_TCPSTATS
retorno = GetTcpStatistics(estadistica)
'retornamos la tabla de estadisticas
GetTCPstadist = estadistica
End Function
Public Function GetUDPstadist() As MIB_UDPSTATS
Dim retorno As Long
Dim estadistica As MIB_UDPSTATS
'retornamos la tabla de estadisticas
retorno = GetUdpStatistics(estadistica)
End Function

-----------------------------------------------------------------------------
ahora un modulo encargado de controlar las conexiones, para el cierre de una
conexion, se requiere una serie de cuestiones k un puerto listening no cumple,
 en capitulos siguientes si se da el caso haremos frente a este tema,
...ale a leer mas codigo ;)
-----------------------------------------------------------------------------

Attribute VB_Name = "Celador"
'################################################################################
'#          DISIDENTS CODEX 2001-02                                             #
'# Modulo encargado de proporcionar un medio para cerrar y                      #
'# cambiar los estados de los puertos, cerrandolos a lo vasto                   #
'# si el usuario asi lo reguiere.                                               #
'# Desarrollado por w3ndig0 para Disidents C0dex                                #
'# no hay derechos ..solo incluye una referencia                                #
'# al origen del mismo si usas este codigo para algo...                         #
'#                                                                              #
'# Compartir los conocimientos es la base de una cultura floreciente. w3ndig0   #
'# la potencia sin control no sirve de nada. pirelly                            #
'# La curiosidad y el empeño es el atributo del hombre. w3ndig0                 #
'# Si bebes no programes. anonimo ;)                                            #
'################################################################################
' option explicit pa no meter la gamba con las variables...
Option Explicit
'la funcion del api que nos interesa para cerrar puertos, ojo, TCP ..
Private Declare Function SetTcpEntry Lib "iphlpapi" (Ptcpcelda As MIB_TCPROW) As Long

'definiciones de los posibles estados
' aunque solo vamos a usar el 12, pensando en la utilidad didadtica, he puesto todos
' -------------------------------------------------------------------------------
' TCP_STATE_CLOSED = 1
' TCP_STATE_LISTEN = 2
' TCP_STATE_SYN_SENT = 3
' TCP_STATE_SYN_RCVD = 4
' TCP_STATE_ESTAB = 5
' TCP_STATE_FIN_WAIT1 = 6
' TCP_STATE_FIN_WAIT2 = 7
' TCP_STATE_CLOSE_wait = 8
' TCP_STATE_CLOSING = 9
' TCP_STATE_LAST_ACK = 10
' TCP_STATE_TIME_WAIT = 11
' TCP_STATE_DELETE_TCB = 12


'configuracion de solid###############
Public Type T_config                '#
     trojan As Boolean              '#
     Autoclosed As Boolean          '#
     zoombie As Boolean             '#
End Type                            '#
                                    '#
Private SOLID_CONFIG As T_config    '#
'--------------------------------------
Type ignored
     port_number As Long
     type As Integer ' 0 tcp, 1 udp
End Type

Type T_Ignore_ports
       Num_Entryes As Long
       portignored() As ignored
End Type

Public ignored_ports As T_Ignore_ports
'-----------------------------------------------------------------------------------
'-----------------------------------------------------------------------------------
'aqui vamos a declarar la extructura que va a contener los puertos comunes usados
'por los troyanos mas conocidos, incluidos en una lista con el siguiente formato
'puerto:tipoconexion(TCP-UDP):troyanos , asi sera de mas facil lectura y no nos
'vamos a complicar mucho.

'la lista esta ordenada segun el puerto.
Private Type T_lstroyanos
        puerto As String 'puerto que usan
        Tipoconexion As String * 3 'UDP o TCP
        Troyanos As String 'nombres de los troyanos que usan ese puerto
End Type
Private Type T_LTROYANOS
        Num_Entryes As Integer  'nos va a recoger el numero de entradas en la lista
        lista() As T_lstroyanos ' un array dinamico que almacenara las entradas con
                                ' un tipo de datos T_lstroyanos
End Type
Public Lista_troyanos As T_LTROYANOS

'-----------------------------------------------------------------------------------
'si os perdeis..esquemita:
'-----------------------------------------------------------------------------------
'
'
'                              |--- Num_entryes ->contador de entradas
'                              |
'                              |
'lista_troyanos>> T_LTROYANOS--|
'                              |------------------Lista() ;array de T_lstroyanos
'                                                 |
'                                                 |--->Puerto as string
'                                                 |--->TipoConexion as strin*3 (tcp/udp)
'                                                 |--->Troyanos; nombres de los troyanos
'
'-----------------------------------------------------------------------------------

Public Function CloseTCP(indice As Long) As Integer
' esta funcion cierra una conexion TCP este en el estado en que
'este, directamente poniendola a closed y sin importarnos en
'absoluto el otro lado de la conexion, muy util para troyanos.
'o puertos sospechosos..
Dim fake As MIB_TCPROW
Dim fake2 As MIB_TCPTABLE
fake2 = GetTCPtableF 'llamamos al api para recoger las conexiones
fake = fake2.aeTable(indice)

fake.dwState = 12


SetTcpEntry fake ' llamamos a la funcion de errores del sistema (errores.bas)

 End Function
 Private Function lngToPort(ByVal lngIn As Long) As String
    'Converts a long port number into a C style port number
    Dim lngTemp As Long

    lngTemp = Int(lngIn / 256)
    lngIn = lngIn - (256 * lngTemp)
    lngToPort = Chr(lngTemp) & Chr(lngIn) & Chr(0) & Chr(0)
End Function


 Public Sub Cargalistatroyanos()
 Dim buffer(2) As String 'que no os despiste! esto tiene 3 elementos, 0, 1, 2
 Dim tempbuffer As String
 Dim grupo As Integer
 Dim cadena As String
 Dim contador_entradas As Integer
 Dim contador As Integer
 Dim retorno As String
 grupo = 0
 'esta funcion carga la lista de troyanos y la almacena en memoria
 retorno = Dir(App.Path & "\trojan list.txt", vbArchive) 'miramo avei si el archivo existe
                                                     'si existe retorno=nombre_archivo
                                                     'si no, retorno=""
If retorno <> "" Then

        Open App.Path & "\trojan list.txt" For Input As #1 'abrimos la lista

         Lista_troyanos.Num_Entryes = 0 'ponemos el numero de entradas a 0

          While Not EOF(1)
            Input #1, cadena ' leemos del archivo lista
            cadena = cadena + vbCr

                  While Len(cadena) > 0
                      contador = contador + 1
                       tempbuffer = Left(cadena, contador)

                             If Right(tempbuffer, 1) = ":" Then

                                       cadena = Right(cadena, Len(cadena) - Len(tempbuffer))

                                       tempbuffer = Left(tempbuffer, Len(tempbuffer) - 1)
                                       buffer(grupo) = tempbuffer

                                       grupo = grupo + 1
                                       contador = 1
                            End If
                            If Right(tempbuffer, 1) = vbCr Then

                                       cadena = Right(cadena, Len(cadena) - Len(tempbuffer))

                                       tempbuffer = Left(tempbuffer, Len(tempbuffer) - 1)
                                       buffer(2) = tempbuffer


                                       contador = 1

                            End If
                        If grupo > 2 Then
                                      MsgBox "Error in trojan list in line " & Str(contador_entradas)
                                        Exit Sub
                         End If

                 Wend
          contador = 0
          grupo = 0
          contador_entradas = contador_entradas + 1 'incrementamos el contador de entradas
          Lista_troyanos.Num_Entryes = contador_entradas
          ReDim Preserve Lista_troyanos.lista(contador_entradas)
          Lista_troyanos.lista(contador_entradas).puerto = buffer(0)
          Lista_troyanos.lista(contador_entradas).Tipoconexion = buffer(1)
          Lista_troyanos.lista(contador_entradas).Troyanos = buffer(2)

          Wend

        Close #1 ' cerramos la lista

     Else
         'ops! alguien se ha borrado la lista de troyanos..pegamos un alarido
         MsgBox "I can't found the trojan list on Solid work directory, Solid can run without it but trojan protection can't be activated"
         SOLID_CONFIG.trojan = False
End If

 End Sub

Public Sub Check_authorized(puerto As String, portindice As Long, estado As Long, tipo As Integer)
Dim a As Integer
Dim retorno As Integer
Dim ctdor As Integer

'esta funcion comprueva k los puertos en cualquier estado no sean los de ningun
'troyano en la lista o denegados expresamente por el usuario.O ignorados...

'para acelerar el proceso previamente miramos si el puerto ha sido expresamente
'ignorado por el usuario
On Error GoTo 10 'si el array no esta inicializado va a dar error, asike para evitar una funcion de inicializado hacemos esta chapuza
For a = 0 To ignored_ports.Num_Entryes
    If a > ignored_ports.Num_Entryes Then Exit For 'los for aleatoriamente dan un bucle mas o menos ..asi lo evitamos
    If Val(puerto) = Val(ignored_ports.portignored(a).port_number) And ignored_ports.portignored(a).type = tipo Then
    Exit Sub
    End If

Next

10

For a = 0 To Lista_troyanos.Num_Entryes

       If Val(Lista_troyanos.lista(a).puerto) = Val(puerto) Then  'si el puerto esta en la lista de troyanos y es TCP


       If Lista_troyanos.lista(a).Tipoconexion = "TCP" Then
         If estado = 5 Then 'si esta conectado!

            retorno = MsgBox("WARNING!!! the folowing port " & puerto & " is commonly used by the following trojans " & Lista_troyanos.lista(a).Troyanos & _
            " !!, push YES to try to close it or NO to ignore the alarm, is strongly recomended that you scan your Host with a antivirus to detect if is an a trojan who is using this port " & _
            " we recommend to you close all aplications and if this alert continues go to www.moosoft.com and dowload THE CLEANER and scan your host", vbYesNo, "Warning S0lid had detected a suspicious CONEXION on your system!!! ")



                     If retorno = 6 Then

                             MsgBox "ok trying to close it!"
                            'hay que ver cual es el indice del puerto en la tabla tcp-row para ordenar su cierre
                            'portIndice = SearchPort(puerto)
                             CloseTCP (portindice)
                     Else
                             MsgBox "ok, port is ignored in this session"
                             'nos aseguramos de que el puerto no existe ya en la lista a fin de ahorrar memoria
                             For ctdor = 0 To ignored_ports.Num_Entryes
                              If ctdor > ignored_ports.Num_Entryes Then Exit For 'los for aleatoriamente dan un bucle mas o menos ..asi lo evitamos
                                If Val(puerto) = Val(ignored_ports.portignored(ctdor).port_number) And ignored_ports.portignored(ctdor).type = tipo Then
                                Exit Sub
                            End If

                            Next
                             ReDim Preserve ignored_ports.portignored(ignored_ports.Num_Entryes) 'redimensionamos array
                             ignored_ports.portignored(ignored_ports.Num_Entryes).port_number = Val(puerto) 'añadimos puerto a la lista
                             ignored_ports.portignored(ignored_ports.Num_Entryes).type = 0 'tipo tcp
                              ignored_ports.Num_Entryes = ignored_ports.Num_Entryes + 1 'avanzamos el indice
                    End If


         Else
            retorno = MsgBox("WARNING!!! the folowing port " & puerto & " is commonly used by the following trojans " & Lista_troyanos.lista(a).Troyanos & _
            " !!,  is strongly recomended that you scan your Host with a antivirus to detect if is an a trojan who is using this port " & _
            " we recommend to you close all aplications and if this alert continues go to www.moosoft.com and dowload THE CLEANER and scan your host, Do you want ignore this port?", vbYesNo, "Warning S0lid Had detected a suspicious LISTEN PORT on your system!!! ")

            If retorno = 6 Then


                             MsgBox "ok, port is ignored in this session"
                             ignored_ports.Num_Entryes = ignored_ports.Num_Entryes + 1 'avanzamos el indice
                             ReDim Preserve ignored_ports.portignored(ignored_ports.Num_Entryes) 'redimensionamos array
                             ignored_ports.portignored(ignored_ports.Num_Entryes).port_number = Val(puerto) 'añadimos puerto a la lista
                             ignored_ports.portignored(ignored_ports.Num_Entryes).type = 0 'tipo tcp

                    End If



        End If



       End If

       If Lista_troyanos.lista(a).Tipoconexion = "UDP" Then
       retorno = MsgBox("WARNING!!! the folowing port " & puerto & " is commonly used by the following trojans " & Lista_troyanos.lista(a).Troyanos & _
            " !!, is strongly recomended that you scan your Host with a antivirus to detect if is an a trojan who is using this port " & _
            " we recommend to you close all aplications and if this alert continues go to www.moosoft.com and dowload THE CLEANER and scan your host", vbOKOnly, "Warning S0lid HAd detected a suspicious UDP open port on your system!!! ")

       End If
       End If

Next

End Sub
Private Function SearchPort(puerto As String) As Integer
Dim TCP_tablax As MIB_TCPTABLE 'tabla de conexiones TCP
Dim contador As Integer
Dim suggestport As String
For contador = 0 To TCP_tablax.dwNumEntries - 1

    suggestport = portC(TCP_tablax.aeTable(contador).dwLocalPort)
    If Val(suggestport) = Val(puerto) Then
                            SearchPort = contador
                            Exit Function
    End If
Next

End Function

Public Function portC(Strport) As Long
On Error GoTo 10
'pasa los puertos a un formato en C
portC = Str(Asc(Mid(Strport, 1, 1)) * 256 + Asc(Mid(Strport, 2, 1)))
Exit Function
10


End Function



-----------------------------------------------------------------------------
Como destacar, siempre hay k destacar algo, es importante k veais la  funcion
PortC, la teneis justo enzima, es fundamental, ya que pasa los puertos en fo-
rmato string a formato de C, recordad que si trabajais con el api de win, te-
ndreis que familiarizaros con este tipo de movidas.

Bueno el codigo k hos he puesto aqui, pertenece a SOLID, k podreis bajaros en
breve, tanto su codigo fuente como logicamente el programa enterito  para  su
uso y disfrute.

la peich www.geocities.com/solidportmonitor/
   la de descarga: http://snow.prohosting.com/cod3x/
   ya tenemos ftp pal codigo, un saludo desde aqui a los chicos de hazent!
   y un abrazo fuertisimo a Bockvan, arriba ese peazo grupo!!!

Si no podeis bajarlo a fecha de hoy o lo que sea, estaros atentos... en  unos
dias lo tendreis enterito en las manos.
Os recomiendo k una vez que este listo para su descarga le echeis un ojo sobre
todo por el tratamiento a la informacion retornada por las llamadas  al  api,
ya que si me lio a pegar mas codigo igual tamos aqui ta la ezine 4.
-----------------------------------------------------------------------------




                          ------------
                          |          |
                          |   E0f!   |
                           -/---------
                           /
                          """"
                        """  """              %%%
                       """      ""         %%%% )
                        ""()    ""   %%%%%%   )
                         \ |    "" %"""""  ) )
                          \|   ""%%       )#
                              ""%%  ) )  )#
                             ""#% ) )"""""""
                            ""#%% """"""""#
                            """""""""""""#
                       ....   """""""""".......
                            ...............
                     ......                ........
                            ..............
-----------------------------------------------------------------------------
contacto: disidents@yahoo.com
contacto: north@demasiado.com
-----------------------------------------------------------------------------
Mail del grupo disidents@yahoo.com
-----------------------------------------------------------------------------
Este articulo  va  dedicado  a todos los que habeis echo de mi idea, un grupo
DDiego, Rah3, S-p-a-r-k, leon01, taseh, Vanmore, towanda, rootzero, xankaisen
Ashira-,charchi,etc etc etc osea  a  todos  y a los que no apareceis..no  por
ello sois menos importantes, mas que nada es que  ddiego  me va a cortar  las
orejas por poner fecha al ezine y luego ser io kien va retrasado XD.

Desde aki un Saludo a PAul de Oviedo (jeje a k no te esperabas esto eh? XD no
todos los dias se encuentra  a alguien leyendo arroba en el bus y resulta ser
el direct. de Disidents XD, un abrazo desde aki tio)


A mi sufrida novia k tiene k tar de mi y mi pc ta los ovarios..
A la peña de empresariales y al tio este k da informatica..como se llama..ehmm
a si Campomanes..lee mas majete lee..
Al canal #visualBasic del hispano, por su ardua labor de promover el uso de vb
y sufrir el acoso de miles de chavaletes acosando a dudas que al menos se tra-
tan de resolver con todo el cariño del mundo. A vosotros, a los  que  empezais
a programar..os dedico todo mi trabajo, que os sea fructifero y ya sabeis  toy
aqui pa lo k kerais.

-----------------------------------------------------------------------------
                                0
                              X0 0X
                                S

