
                     -+-| DisidentS Hack Journal #4 |-+-





  _____________________________________________________________________
 |                                                                     |
 | -- Titulo_____: Guía de programación con ncurses (Parte I)          |
 | -- Autor______: <+CoOL~ShADoW+>                                     |
 | -- Team_______: Disidents España - http://www.disidents.org         |
 | -- Tema_______: Programacion Linux                                  |
 |_____________________________________________________________________|




.==========================================================================.
|===========~ INDICE ~======================================================
|===========================================================================
|=~ 1.0 Introducción                                                       | 
|=~ 2.0 Funciones principales                                              | 
|=~ 3.0 Salida de texto                                                    |
|=~ 4.0 Ingreso de datos                                                   |
|=~ 5.0 Más funciones para divertirte                                      |
|=~ 6.0 Usando menús                                                       |
|=~ 7.0 Ejemplos                                                           |
|=~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~=.
======================================================~ INDICE ~============
============================================================================



.==========================================================================.
|=======~ 1.0 INTRODUCCION     ~============================================
|===========================================================================


¿Qué son las Ncurses?


Digamos que para UNIX existen unas bibliotecas llamadas curses, pues las Nc-
urses (New curses) son un clon de estas pero libre.
Las Ncurses nos permiten la creación de aplicaciones  gráficas  dentro de la 
consola, claro que no se tendrá la misma calidad que X.
Nos permiten la creación de multiples ventanas, formularios, menús, utiliza-
ción de colores (si la terminal los soporta), etc.


Compilación


Obiamente usaremos el gcc. Para compilar un programa que utilice ncurses de-
beríamos usar: gcc -lcurses archivo.c -o programa

Y en el código fuente colocaremos:

#include <curses.h>

Muchas distribuciones usan  un enlace  símbolico a curses.h  desde ncurses.h
pero es conveniente usar curses.h en nuestro código.				


curscr y stdscr


Estas  dos son estructuras, stdscr  contiene lo que se ve en la pantalla, es 
decir como si todo fuese una imagen, mientras que curscr contiene la idea de 
como es la pantalla en forma corriente. Estas dos estructuras son necesarias 
por ejemplo para poder refrescar la pantalla.

.==========================================================================.
|=======~ 2.0 FUNCIONES PRINCIPALES  ~======================================
|===========================================================================



Ahora veremos las funciones que más o siempre usaremos.

  WINDOW *initscr(void);

Inicia stdscr y curscr, y averigua las capacidades del terminal.
Si en alguna de estas tareas se produce algún fallo se de importante  infor-
mación, y se retorna NULL, si tiene exito el valor apunta a stdscr.
Tenemos que recordar que antes de usar cualquier función de  ncurses hay que 
llamar a initscr (solo una vez al principio).

 SCREEN  *newterm(const  char  *type,  FILE  *outfd,   FILE *infd);

Si  vamos a usar E/S desde más de un terminal debemos usar esta función. Por 
cada terminal se tendrá que llamara.
En caso de que  como  primer  argumento  usemos NULL se usará $TERM, y en el 
resto de los argumentos como Linux tiene la gran ventaja de tratar todo como
archivos usaremos stdout y stdin.

 SCREEN *set_term(SCREEN *new);

Antes de usar E/S del terminal hay que convertirla en la terminal actual, si 
falla retorna NULL, en caso contratrio retorna la terminal previa.

 int refresh(void);

Con esta función se obtiene la salida actual a la  terminal, hace una compa-
ración entre  strscr y curscr y  copia las  direrencias a  este  último.  Es 
decir refresca  la pantalla, en este  caso se toma por defecto a strscr pero 
se puede apuntar  a cualquier  ventana  con la función wrefresh, no me voy a
meter en el tema  así que si quieres más  informacion ya  sabes, man refresh
que son menos de 100 lineas ;)

 int endwin(void);

Esta  función sale del  modo visual de  las curses,  es decir quedamos en la 
terminal en modo texto, la  ventaja de esta función es  que no libera la me-
moria que está  siendo usada, lo que  nos  permitiría volver con refresh. Si 
falla rerotna ERR si no retorna OK

 void delscreen(SCREEN* sp);

Para  liberar la  memoria de la  estructura SCREEN, debemos  usarla luego de 
endwin cuando estemos con newterm.

Como vamos, tamos con todo que ya tan rápido pasamos las principales funcio-
nes, pero aún queda camino.


.==========================================================================.
|=======~ 3.0 SALIDA DE TEXTO  ~============================================
|===========================================================================


Bueno antes pódimos crear una ventana, terminarla, restarurarla, y saber sus 
medidas, pero no creo que eso solo sirva de mucho si no sabemos mandar cade-
nas de texto a estas.

 La verdad es que la cosa está fácil y seguirá así, ya verás.

 int addch(chtype ch);

Muestra en la pantalla el caracter ch, no hay que precouparse  por  calcular 
la posición del  puntero ya que la  función los desplaza automaticamente. Si 
ch es un  caracter de  control que  no sea un retorno, una tabulación, o una 
nueva linea se debe usar la notación ^X (X es el caracter).

 int waddch(WINDOW *win, chtype ch);

Pues lo mismo que el anterior pero puedes espesificar la ventana.

 int mvaddch(int y, int x, chtype ch);

Más de lo mismo pero esta vez podemos desplazar el cursor a donde queramos.

 int mvwaddch(WINDOW *win, int y, int x, chtype ch);

No es muy  difícil de deducir que esta rutina combina las caracteristicas de 
las 2 que se nombraron anterirormente (ventana y mover el cursor).

 int echochar(chtype ch);

Es una llamada a addch seguida de una a refresh esto permite obtener una me-
jor performance cuando se trabaja sin caracteres de control.

 int wechochar(WINDOW *win, chtype ch);

waddch seguida de wrefresh no me hagan escrbir pa na :P
Todas estas rutinas que nombré retornan ERR si hay algún error o OK si  todo
 sale bien.

 int insch(chtype ch);

Inserta el caracter ch antes del cursor, todo lo que esté depués  de este se
corre un espacio a la derecha (como nos facilitan la vida no?).

 int winsch(WINDOW *win, chtype ch);
 int mvinsch(int y, int x, chtype ch);
 int mvwinsch(WINDOW *win, int y, int x, chtype ch);

A estas  alturas ya debemos adivinar para que sirven por su nomenclatura así 
que no los describiré.
 Si fallan retornan ERR si no OK.

 int printw(char *fmt [, arg] ...);

Es como printf pero la usamos cuando estemos con ncurses así que no hay nada
que explicar.

 int wprintw(WINDOW *win, char *fmt [, arg] ...);
 int mvprintw(int y, int x, char *fmt [, arg] ...);
 int mvwprintw(WINDOW *win, int y, int x, char *fmt [, arg] ...);

Tampoco hay que ser un genio para saber su funcionamiento. También  retornan
ERR o OK.

 int addchstr(const chtype *chstr);

Copia chstr a la estructura de la imagen de la ventana y  luegov la posición 
actual del cursor.

 int addchnstr(const chtype *chstr, int n);

Lo mismo que la  anterior  pero se elige  la cantidad  de  bytes a copiar si 
n = -1 se copia toda la cadena.
Entonces ya podemos deducir las demas:

 int waddchstr(WINDOW *win, const chtype *chstr);
 int waddchnstr(WINDOW *win, const chtype *chstr, int n);
 int mvaddchstr(int y, int x, const chtype *chstr);
 int mvaddchnstr(int y, int x, const chtype *chstr, int n);
 int mvwaddchstr(WINDOW *win, int y, int x, const chtype *chstr);
 int mvwaddchnstr(WINDOW *win, int y, int x, const chtype *chstr, int n);

A excepción de waddchnstr, todas  son macros, son más rápidas pero no proce-
san caracteres como  los  de retorno  de  carro, nueva linea o retorno y  no 
avanzan el cursor; si una cadena es muy larga  para entrar en una linea esta
es truncada. Yo prefiero printw pero hay que mostrar las alternativas.
Como ya es común retornan ERR o OK.


.==========================================================================.
|=======~ 4.0 INGRESO DE DATOS   ~==========================================
|===========================================================================


Ahora toca una de la parte más importante, la que sin ella  nuestro programa
no tendría  casi ninguna  interacción  con el  ususario, sin  más palabrerío 
vamos a ver algunas funciones ;)

 int getch(void);

Retorna el caracter tecleado o ERR  si falla, manda el eco o  no dependiendo 
de si está habilitada en la terminal.
Para manejar esto necesitamos estas dos funciones:

  int echo(void);
  int noecho(void);

Se deben llamar antes del  getch, echo (eco) permite  que el  texto se envíe
a la ventana, y noecho para el caso contrario.
Esto  es útil por ejemplo si queremos hacer un  programa que use contraseñas 
y no  queremos que se  vean, pero hay otro  problema; el modo de  entrada de 
caracteres que se esté  usando. Cuando comienzan  las ncurses el modo en que 
se procesa la entrada de caracteres es haciendo que el kernel los envíe a un
buffer hasta que llegue  uno de  nueva linea (un enter) y  ahí los envía to-
dos, esto en mi  opinión son dos desventajas, la primera es que  es bastante 
incómodo, y la  segunda  es que  si  trabajamos  con  un  programa  que  use 
passwords no es muy lindo que se  valla todo para  un buffer (sin encriptar) 
ya que dumpeando esa zona se podría obtener per nah no hablo más.

Para solucionar esto usaremos:

 int cbreak(void);
 int nocbreak(void);

Con  cbreak solucionamos el  problema ya que nos pone en un modo que los ca-
racteres  no son llevados a ningún buffer (ni son procesados lo que nos da a 
nosotros el control ya que nos llega como lo mandamos para que  nuestro pro-
pio programa procese lo que quiera), es  decir cada caracter que se tipea es 
enviado  sin  la  necesidad de  ingresar un  caracter de  nueva linea. Y con 
nocbreak pues lo dejamos en el modo feo de antes :P.

Espero  no  haber explicado  esto mal, les  recomiendo  leer los manuales de 
getch (donde encontrarán algunas otras funciones) y de cbreak, donde también 
se explica los modos de delay, no delay y medio-delay que yo no expliqué.



.==========================================================================.
|=======~ 5.0 MAS FUNCIONES PARA DIVERTIRTE   ~=============================
|===========================================================================


 void getmaxyx(WINDOW *win, int y, int x);

Esta  macro guarda en dos variables de tipo entero el altura y la ancho (fi-
las y columnas) de la ventana espesificada en el primer argumento.
Es útil para  cuando se quiere redimensionar una ventana y  luego volverla a 
la normalidad.

 int bkgd(const chtype ch);

Establece la propiedades del  fondo de  una ventana. Por ejemplo para que la 
salida fuese en negrita sería bkgd(A_BOLD), para ver los posibles  atributos 
de video lee el man curs_attr (si eres curioso busca en curses.h) y para más 
información man bkgd (recomiendo una leida).

De todos modos copio los atributos definidos en curses.h:

/* attributes */

#define NCURSES_BITS(mask,shift) ((mask) << ((shift) + 8))

#define A_NORMAL	0L
#define A_ATTRIBUTES	NCURSES_BITS(~(1UL - 1UL),0)
#define A_CHARTEXT	(NCURSES_BITS(1UL,0) - 1UL)
#define A_COLOR		NCURSES_BITS(((1UL) << 8) - 1UL,0)
#define A_STANDOUT	NCURSES_BITS(1UL,8)
#define A_UNDERLINE	NCURSES_BITS(1UL,9)
#define A_REVERSE	NCURSES_BITS(1UL,10)
#define A_BLINK		NCURSES_BITS(1UL,11)
#define A_DIM		NCURSES_BITS(1UL,12)
#define A_BOLD		NCURSES_BITS(1UL,13)
#define A_ALTCHARSET	NCURSES_BITS(1UL,14)
#define A_INVIS		NCURSES_BITS(1UL,15)


 chtype getbkgd(WINDOW *win);

Obtiene el estado del fondo de una ventana. Para más información leer el ma-
nual que dije anteriormente.

int border(chtype ls, chtype rs, chtype ts, chtype bs, chtype tl, chtype tr, 
           chtype bl, chtype br);
 
Dibuja un borde a la ventana.
Los argumentos son:
ls	costado izquierdo
rs	costado derecho
ts	lado superiror
bs	lado inferior
tl	superior-izquierda
tr	superior-derecha
bl	inferior-izquierda
br	inferior-derecha

Pero hay una macro que simplifica la tarea:

 int box(WINDOW *win, chtype verch, chtype horch);

Mucho más fácil, por ejemplo con box(stdscr,ACS_VLINE,ASC_HLINE) hemos hecho
lo   mismo  que  con   border(ACS_VLINE,  ACS_VLINE,  ACS_HLINE,  ACS_HLINE, 
ACS_ULCORNER, ACS_URCORNER, ACS_LLCORNER, ACS_LRCORNER);
Si se usa 0 son esos por defecto. Si  nos damos cuenta  la función verdadera 
es wborder solo que border es lo mismo pero a stdscr.
NOTA: puedes averte dado cuenta que en éstas ultimas  funciones los argumen-
tos son chtype, pero en los ejemplos he  usado constantes  de las ncurses lo 
que pasa es que esas constantes son caracteres que las ncurses los usan para
 lineas, estilos, etc.

/* VT100 symbols begin here */
#define ACS_ULCORNER	(acs_map['l'])	/* upper left corner */
#define ACS_LLCORNER	(acs_map['m'])	/* lower left corner */
#define ACS_URCORNER	(acs_map['k'])	/* upper right corner */
#define ACS_LRCORNER	(acs_map['j'])	/* lower right corner */
#define ACS_LTEE		(acs_map['t'])	/* tee pointing right */
#define ACS_RTEE		(acs_map['u'])	/* tee pointing left */
#define ACS_BTEE		(acs_map['v'])	/* tee pointing up */
#define ACS_TTEE		(acs_map['w'])	/* tee pointing down */
#define ACS_HLINE	(acs_map['q'])	/* horizontal line */
#define ACS_VLINE	(acs_map['x'])	/* vertical line */
#define ACS_PLUS		(acs_map['n'])	/* large plus or crossover */
#define ACS_S1		(acs_map['o'])	/* scan line 1 */
#define ACS_S9		(acs_map['s'])	/* scan line 9 */
#define ACS_DIAMOND	(acs_map['`'])	/* diamond */
#define ACS_CKBOARD	(acs_map['a'])	/* checker board (stipple) */
#define ACS_DEGREE	(acs_map['f'])	/* degree symbol */
#define ACS_PLMINUS	(acs_map['g'])	/* plus/minus */
#define ACS_BULLET	(acs_map['~'])	/* bullet */
/* Teletype 5410v1 symbols begin here */
#define ACS_LARROW	(acs_map[','])	/* arrow pointing left */
#define ACS_RARROW	(acs_map['+'])	/* arrow pointing right */
#define ACS_DARROW	(acs_map['.'])	/* arrow pointing down */
#define ACS_UARROW	(acs_map['-'])	/* arrow pointing up */
#define ACS_BOARD	(acs_map['h'])	/* board of squares */
#define ACS_LANTERN	(acs_map['i'])	/* lantern symbol */
#define ACS_BLOCK	(acs_map['0'])	/* solid square block */
/*
 * These aren't documented, but a lot of System Vs have them anyway
 * (you can spot pprryyzz{{||}} in a lot of AT&T terminfo strings).
 * The ACS_names may not match AT&T's, our source didn't know them.
 */
#define ACS_S3		(acs_map['p'])	/* scan line 3 */
#define ACS_S7		(acs_map['r'])	/* scan line 7 */
#define ACS_LEQUAL	(acs_map['y'])	/* less/equal */
#define ACS_GEQUAL	(acs_map['z'])	/* greater/equal */
#define ACS_PI		(acs_map['{'])	/* Pi */
#define ACS_NEQUAL	(acs_map['|'])	/* not equal */
#define ACS_STERLING	(acs_map['}'])	/* UK pound sign */

Creo que ahora si se entiende ;)
Pueden usar  las constates, o acs_map['letra'], yo uso las constantes porque
son más fáciles de recordar.

 int hline(chtype ch, int n);
 int whline(WINDOW *win, chtype ch, int n);
 mvhline(int y, int x, chtype ch, int n);
 mvwhline(WINDOW *, int y, int x, chtype ch, int n)

Dibuja  en foma horizontal el caracter ch (usar ACS_HLINE)  y su longitud es
n. También están sus variantes para ventanas y posición.

 int vline(chtype ch, int n);
 int wvline(WINDOW *win, chtype ch, int n);
 int mvvline(int y, int x, chtype ch, int n);
 int mvwvline(WINDOW *, int y, int x, chtype ch, int n);

Lo mismo pero vertical.
Con hline se dibuja de izquierda a derecha  y con vline de arriba hacia aba-
jo, no  cambian la  posición del cursor. Como vimos  estas funciones  no son
impresindibles  ya  que  pódriamos crear  algunas que hicieran  lo mismo con
unas pocas lineas de código. 

 int clear(void)

Borra la pantalla, como estas funciones no tiene mucha ciencia solo digo que
 si quieren ver todo el conjunto está bien documentado en curs_clear.

 int putwin(WINDOW *win, FILE *filep);

Guarda toda la información asociada a win en el archivo al que apunta filep.

 WINDOW *getwin(FILE *filep);

Lee la información  de un  archivo  (creado con putwin) y crea  la ventana y 
retorna  el puntero  a  la ventana. Recomiendo ver  también  las  rutinas de 
dumpeado en scr_dump. 



.==========================================================================.
|=======~ 6.0 USANDO MENUS   ~==============================================
|===========================================================================


Primero que nada para poder  usar los menús  se necesita incluir el  archivo 
menu.h. Así que en nuestro código quedaría:

#include <curses.h>
#include <menu.h>
Y con el gcc usaríamos: /gcc -lmenu -lcurses archivo.c -o programa.

Los pasos para crear y mostrar un menú serían:

1	initscr
2	new_item
3	new_menu
4	set_menu_format (opcional)
5	post_menu
6	refresh

Y para terminarlo:

1	unpost_menu
2	free_menu
3	free_item
4	delwin

 MENU *new_menu(ITEM **items);

Crea un nuevo menú. Si falla retorna NULL.

 int free_menu(MENU *menu);

Desconecta el menú y libera la memoria asignada. Puede retornar los  siguen-
tes valores: Si no hay ningún error E_OK en  caso contrario, E_SYSTEM_ERROR,
E_BAD_ARGUMENT, o E_POSTED.

 int post_menu(MENU *menu);

Muestra el menú.

 int unpost_menu(MENU *menu);

Lo borra.
Estas dos funciones retornan E_OK  si todo  sale bien y en  caso  contrario: 
E_SYSTEM_ERROR,   E_BAD_ARGUMENT,    E_POSTED,    E_BAD_STATE,    E_NO_ROOM, 
E_NOT_POSTED,  E_NOT_CONNECTED. Para  ver  el  significado de estos mensajes 
/man post_menu.

  ITEM *new_item(const char *name, const char *description);

Crea un nuevo ítem del menú, si hay algún error retorna NULL.

 int free_item(ITEM *item);

Libera la memoria asignada a ese ítem. Retorna E_OK si todo  sale bien y  en 
caso contrario da: E_SYSTEM_ERROR, E_BAD_ARGUMENT o E_CONNECTED.
 
 int menu_driver(MENU *menu, int c)

Se debe  usar luego del que menú sea mostrado, permite desplazarse entre los
ítems. En c le decimos que hacer, agunos de los argumentos son: 

 REQ_LEFT_ITEM		Se mueve a la izquierda
 REQ_RIGHT_ITEM		Se mueve a la derecha
 REQ_UP_ITEM		Hacia arriba
 REQ_DOWN_ITEM		Hacia abajo
 REQ_FIRST_ITEM		Va al primer ítem
 REQ_LAST_ITEM		Va al último ítem

También existe uno para las entradas del ratón  llamado  KEY_MOUSE, pero  no 
explicaré su comportamiento. Si todo sale bien retorna E_OK de lo contrario: 
E_SYSTEM_ERROR,E_BAD_ARGUMENT, E_BAD_STATE, E_NOT_POSTED, E_UNKNOWN_COMMAND, 
E_NO_MATCH, E_REQUEST_DENIED. Para  obtener más infomación lee  el manual de 
menu_driver.

 int set_menu_format(MENU *menu, int rows, int cols);

Establece el tamaño del menú, por filas y columnas. Por defecto son 16 filas
y una columna. Los valores que retorna son: E_OK si no hay errores  y si los 
hay retorna E_SYSTEM_ERROR, E_BAD_ARGUMENT, o E_POSTED.

.==========================================================================.
|=======~ 7.0 EJEMPLOS   ~==================================================
|===========================================================================


Ejemplo de ingreso y salida de datos:

/* Este programa tecles  la tecla que se a va escribiendo "que rápido"  este 
método se usa en muchas películas para  hacer creer que la persona realmente 
escribe a gran velocidad pero en realidad  ta tecleando cualquier cosa :P */

#include <curses.h>
#include <stdlib.h>

int main() {
int contador = 1 ;

if ((initscr()) == NULL) {			/*	           */
    perror("initscr") ;				/* Inicio ncurses   */
    exit(EXIT_FAILURE) ;			/*	           */
}

noecho() ;				/* Para que no salga en pantalla lo que se escribe */

keypad(stdscr, TRUE) ;			/* Habilito entrada de ratón y tecaldo */

while(getch() != 'q') {			/* Mientras no se precione "q" no se saldrá del programa */
    switch(contador) {
      case 1:
          addch('q') ; contador++ ; break;	/* Se va mostrando de char en char y se incrementa el valor de contador */
      case 2:
          addch('u') ; contador++ ; break;
      case 3:
          addch('e') ; contador++ ; break;
      case 4:
          addch(' ') ; contador++ ; break;
      case 5:
          addch('r') ; contador++ ; break;
      case 6:
          addch('á') ; contador++ ; break;
      case 7:
          addch('p') ; contador++ ; break;
      case 8:
          addch('i') ; contador++ ; break;
      case 9:
          addch('d') ; contador++ ; break;
      case 10:
          addch('o') ; contador++ ; break;
      default:
          clear() ; contador = 1 ;		/* cuando se termina el mensaje borro la pantalla y reinicio el contador */
    }
    refresh() ;				/* refresco la pantalla */
}

endwin() ;				/* termino la pantalla */
exit(0) ;				/* y termino el programa */
}


Ejemplo de menús:

/* Para este  ejemplo me basé  en el  del libro "Programación  en linux  con 
ejemplos" , ya que  estuve  probando  otros métodos  pero con ninguno mejoré 
este, espero que no sea tratado como un plagio */

#include <stdlib.h>
#include <curses.h>
#include <menu.h>

int main()
{
static const char *opciones[] = { "uno", "dos", "tres" , "Salir" , NULL } ;	/* Array de cadenas con los items */
const char **popciones ;
int cascii , *itemsel ;
ITEM *items[sizeof(opciones)];
ITEM **pitems = items ;
MENU *un_menu ;

if ((initscr()) == NULL) {						/*	           */
   perror("initscr") ;							/* Inicio ncurses   */
   exit(EXIT_FAILURE) ;						        /*	           */
}

noecho();                                                               /* Para que no salgan las letras que presionamos */

keypad(stdscr, TRUE) ;	/* Habilito las entradas de teclado y ratón */

for ( popciones = opciones; *popciones; popciones++ ) *pitems++ = new_item(*popciones, "");	/* Recorro el array para                                                                                                 agregar los items */
     *pitems = NULL ;
     un_menu = new_menu(items) ;		/* Creo el menú */
     set_menu_format(un_menu, 1 , 4) ;	/* Columnas y filas del menú */
     post_menu(un_menu) ;		/* Lo muestro */
     while ((cascii = getch()) != 'q' ) {			/* Este loop termina cuando el usario presione q terminando                                                                 el programa */
        if (cascii == KEY_DOWN || cascii == KEY_RIGHT ) { menu_driver(un_menu, REQ_RIGHT_ITEM) ; }    /* Cambia la                                                                                                                 selección de un item */                                                              
        else if (cascii == KEY_UP || cascii == KEY_LEFT ) { menu_driver(un_menu, REQ_LEFT_ITEM) ; }	/* de acuerdo a las                                                                                                         teclas   */
        else {	/* Si se presiona cualquier tecla que no sea q o las flechas de deplazamiento */
           itemsel = current_item(un_menu) ;
           if (*itemsel == "uno") { printw("opción 1\n") ; }
           if (*itemsel == "dos") { printw("opción 2\n") ; }	 /*  Comprueba que   */
           if (*itemsel == "tres") { printw("opción 3\n") ; }	 /* item se selecionó  */
           if (*itemsel == "Salir") { goto salir ; }
       }
    }

    salir:
       unpost_menu(un_menu) ;	/* Quito el menú */
       free_menu(un_menu) ;	/* Libero la memoria del menú */
       for ( pitems = items; *pitems; pitems++ ) free_item(*pitems) ; /* Libero la memoria de cada item */
       keypad(stdscr, FALSE) ;	/* Desabilito las entradas de teclado y ratón */
       endwin() ; 		/* Termino la ventana */
       exit(0) ;
}



Con esto termina la primera parte del curso, en la segunda entrega veremos como 
usar el ratón, usar colores, formularios, y crear sub-ventanas.

Hasta la próxima ;)
