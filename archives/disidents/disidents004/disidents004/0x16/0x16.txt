
                       -+-| DisidentS Hack Journal #4 |-+-



	
	
 ___________________________________________________________________________
 |                                                                           |
 | -- Titulo_____: Criptografia con Visual basic                            |
 | -- Autor______: XpyXt                                                     |
 | -- E-Mail_____: xpyxt@desdeinter.net                                      |
 | -- Team_______: Disidents España - http://www.disidents.org	             |                                            |
 | -- Tema_______: Programacion en  Visual Basic                             |
 |___________________________________________________________________________|




.==========================================================================.
|===========~ INDICE ~======================================================
|===========================================================================
|=~ 1.0 Introduccion                                                       | 
|=~ 2.0 Algo de teoria                                                     | 
|=~ 3.0 Creacion del algoritmo                                             |
|=~ 4.0 La Key                                                             |
|=~ 5.0 Despedida                                                          |
|=~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~=.
======================================================~ INDICE ~============
============================================================================



.==========================================================================.
|=======~ 1.0 INTRODUCCION     ~============================================
|===========================================================================


No voy a  explicar como crear un potente motor de cifrado si no voy a expli-
car como programar en Visual Basic (version 6.0) un pequeño motor de cifrado, 
capaz de encriptar texto, ficheros y todo lo que queramos. Hoy en dia la cri-
ptografia no es un simple entretenimiento de encriptar texto, si no algo muy
serio, ya que asegura el seguridad de ciertos datos. Si se trabaja con datos
importantes y serios es recomendable encriptarlos.

¿Por que no se cifra el correo?    
 
Las respuestas más comunes a esta pregunta son: 
1) el público no está concienciado de la (in)seguridad de Internet.
2) el público no está dispuesto a ceder en comodidad para ganar en seguridad.

Ambas respuestas eran válidas en el pasado, pero ya no es así. 

La prensa, con su campaña de histeria colectiva, presenta  Internet  como  un
lugar inseguro, plagado de crackers, en el que la intimidad no  existe  y  la
seguridad es una broma. El segundo problema es de índole técnica, pero con la
maduración de estas tecnologías, penPGP puede integrarse  (y  de  hecho  está
integrado) en muchos clientes de correo -como Microsoft Outlook, Eudora y si-
milares- mediante el uso de módulos extra (plug-ins).

Fuente Kriptopolis (http://www.kriptopolis.com)

El  tema  deja  de ser una broma y se combierte en algo real, la seguridad de-
pende de nosotros.

Pues bien, voy a explicar como iniciarnos y programar un algoritmo de cifrado 
con visual basic (version 6.0), el motor  va a estar basado principalmente en 
cuatro operaciones matematicas, sumas, restas, multiplicaciones y divisiones, 
tambien va a tener una key.

Es un princio  para  que  despues nostros desarrollemos un motor mas fuerte y 
complejo.




.==========================================================================.
|=======~ 2.0 ALGO DE TEORIA      ~=========================================
|===========================================================================


Principalmente vamos a intentar poner una cierta dificultad para ser entend-
ido a lo que deseamos encriptar, un dato muy a  tener  en cuenta es  que  el
texto en cual sea distinto en numero de bytes iniciales a los finales.
El motor se basa principalmente en unas ciertas operaciones matematicas,gra-
cias a ellas vamos a poder encriptar nuestro texto y ficheros.



.==========================================================================.
|=======~ 3.0 CREACION DEL ALGORITMO     ~==================================
|===========================================================================

 
El algoritmo de cifrado que voy a explicar es algo simple y poco profesionar
bajo mi puto de vista, pero es  una  idea  de  como programar  algoritmos de
cifrado, ademas de ser entretenido podemos aprender mucho.	

El motor  va  a tener varios motores pequeños, la union de todos los motores 
creara uno grande y algo compejo.

Manos a la creacion

Este  primer  ejemplo es sumamente malo y penoso, consiste en donde pongamos
un 2 pondra 3 y donde a pondra b, pondra el caracter siguiente.

Dim TextoINI As String
Dim LongTextoINI As Long
Dim CarectarSIN As String
Dim CarectarKRY As String
Dim I As Long

TextoINI = Text1.Text
LongTextoINI = Len(Text1.Text) ' leemos la longitud del texto a encriptar
For I = 1 To LongTextoINI
    CarectarSIN = Mid(TextoINI, I, 1) ' leemos caracter a carecter
    CarectarKRY = CarectarKRY & Chr(Asc(CarectarSIN) + 1)   'saca en numero
     ascii del caracter le suma
                           'una unidad y lo combierte en letra
                           'Asc("A") transforma A a codigo ascii
                           'Chr(65) transforma el numero a letra
    		Text2.Text = CarectarKRY
	Next
 
Es simple, sumamente simple, pero ya encripta algo, explicacion paso a paso.

LongTextoINI = Len(Text1.Text) ' calcula la logitud del texto en bytes

CarectarSIN = Mid(TextoINI, I, 1) ' coge un caracter del texto, va consecutiva-
mente 

CarectarKRY = CarectarKRY & Chr(Asc(CarectarSIN) + 1) ' el caracter, es pasa-
do a codigo ascii, se le suma 1 y se pasa a ascii

Para desencriptar en vez de sumar 1 le restamos 1

Este pequeño encriptador es base de este otro algo mas complejo



Dim PRI_I As Long
Dim PRI_Carectar As String
Dim PRI_Parte As String
Dim PRI_DesEncriptado As String
Dim PRI_Longitud As String
Dim PRI_Texto As String

PRI_Texto = Text1.Text
PRI_Longitud = Len(PRI_Texto)
	
PRI_Parte = 0
For PRI_I = 1 To PRI_Longitud
    If PRI_Parte = 0 Then
       PRI_Carectar = Mid(PRI_Texto, PRI_I, 1)
       PRI_DesEncriptado = PRI_DesEncriptado & Chr(Asc(PRI_Carectar) - 1)
        		
         PRI_Parte = 1
         ElseIf PRI_Parte = 1 Then
         PRI_Carectar = Mid(PRI_Texto, PRI_I, 1)
         PRI_DesEncriptado = PRI_DesEncriptado & Chr(Asc(PRI_Carectar) + 1)
        		

         PRI_Parte = 2
         ElseIf PRI_Parte = 2 Then
         PRI_Carectar = Mid(PRI_Texto, PRI_I, 1)
         PRI_DesEncriptado = PRI_DesEncriptado & Chr(Asc(PRI_Carectar) - 3)
        		
         PRI_Parte = 3
         ElseIf PRI_Parte = 3 Then
         PRI_Carectar = Mid(PRI_Texto, PRI_I, 1)
         PRI_DesEncriptado = PRI_DesEncriptado & Chr(Asc(PRI_Carectar) + 2)
        		
         PRI_Parte = 4
         ElseIf PRI_Parte = 4 Then
         PRI_Carectar = Mid(PRI_Texto, PRI_I, 1)
         PRI_DesEncriptado = PRI_DesEncriptado & Chr(Asc(PRI_Carectar) - 5)
        		
         PRI_Parte = 0
         End If

	Next

	text2.text  = PRI_DesEncriptado ' resultado
|===========================================================================

Es algo mas complejo, viendo el codigo fuente parece sencillo, prueba a  en-
criptar un trozo de texto. Para desencriptarlo invierte las operaciones  ma-
tematicas y listo.

El motor siguiente no encripta nada, pasa todo el texto o fichero  a  codigo
ascii, es una buena base para aplicar divisiones al resultado.
|===========================================================================
Dim P2_I As Long
Dim P2_Caracter As String

Dim P2_Longitud As Long
En_Encriptado= text1.text
P2_Longitud = Len(En_Encriptado) ' calcula la longitud del texto
	
For P2_I = 1 To P2_Longitud  ' Empieza a sacar el codigo ascii y los va agru-
pando.
       P2_Caracter = Mid(En_Encriptado, P2_I, 1)
       P2_Total = P2_Total & Asc(P2_Caracter) & " "
    	
	Next
|===========================================================================
Lo que hace es leer carater a caracter y sacar el codigo ascii,  despues los
agrupa  dejando un espacio entre el cogido de cada uno.
|===========================================================================

P2_Total = P2_Total & Asc(P2_Caracter) & " " ' saca el codigo ascii de un carac-
ter  y lo agrupa dejando un " " (espacio) entre cada uno.

Para poder volver a pasar todos los codigos ascii a ascii, lo hacemos mediate
una  matriz.

Dim DP2_contenido() As String
Dim DP2_Total As String
Dim N As Long
DP2_contenido = Split(text1.text, " ") ' matriz 
N = 0
DP2_Total = ""
Do
   On Error GoTo DP2_fin
    If DP2_contenido(N) = "" Then
        GoTo DP2_fin
    End If
       DP2_Total = DP2_Total & Chr(DP2_contenido(N)) 

       N = N + 1
    
Loop Until (N = N + 1)
	
DP2_fin:
text2.text = DP2_Total
|===========================================================================
Este codigo lee lo ke hay entre los espacio lo pasa a ascii, ya que  lo  que 
hay entre los espacio es codigo ascii y lo agrupa.


Al motor de antes de pasar ascii a codigo ascii le  vamos  a  someter a unas 
operaciones matematicas para aplicar algo de cifrado. En este motor se puede
aplicar bien operacion de divisiones.
|===========================================================================

Dim En_Encriptado as string	
Dim P4_I As Long
Dim P4_Caracter As String

Dim P4_Longitud As Long
En_Encriptado = text1.text 
P4_Longitud = Len(En_Encriptado)

P4_Total = ""
For P4_I = 1 To P4_Longitud
    P4_Caracter = Mid(En_Encriptado, P4_I, 1)
    P4_Total = P4_Total & (Asc(P4_Caracter) / 2) & " "
    	Next
text2.text = P4_Total

P4_Total = P4_Total & (Asc(P4_Caracter) / 2) & " " ' pasamos el byte a codigo
 ascii y lo dividimos entre 2.

|===========================================================================
El  resultado en cuanto a volumen sera muy distinto si aplicamos a parte que 
nos darian  decimales. Hagamos unas pruebas:

Con  la frase Hola mundo vamos a realizar una serie de pruebas a con distin-
tos numeros de division.
|===========================================================================

>>>>Division por 2
Frase : Hola mundo
Resultado : 36 55,5 54 48,5 16 54,5 58,5 55 50 55,5 

>>>>Division por 3
Frase : Hola mundo
Resultado :24 37 36 32,3333333333333 10,6666666666667 36,3333333333333 39
36,6666666666667 33,3333333333333 37

>>>>Division por 4
Frase : Hola mundo
Resultado : 18 27,75 27 24,25 8 27,25 29,25 27,5 25 27,75 

>>>>Division por 5
Frase : Hola mundo
Resultado: 14,4 22,2 21,6 19,4 6,4 21,8 23,4 22 20 22,2 


|===========================================================================
Todo otra vez se puede pasar  a ascii,  por lo que no hay ningun problema en 
dividir por el numero que se quiera.
|===========================================================================

Para pasar a codigo ascii

Dim DP2_contenido() As String
    Dim DP2_Total As String
    Dim N As Long
    DP2_contenido = Split(Text2.Text, " ") ' matriz
    N = 0
    DP2_Total = ""
    Do
        On Error GoTo DP2_fin
            If DP2_contenido(N) = "" Then
                GoTo DP2_fin
            End If
           DP2_Total = DP2_Total & Chr(DP2_contenido(N) * 2) 'faztor matematico

            	N = N + 1
    
    	Loop Until (N = N + 1)
    
	DP2_fin:
    	Text3.Text = DP2_Total 

|===========================================================================
Este tipo de motor tambien podemos aplicar varias operaciones a la  vez,  lo
que hara mas dificil de desencriptar.

En el codigo para encriptar sustitulle 
P4_Total = P4_Total & (Asc(P4_Caracter) / 2) & " " 
                      por 
P4_Total = P4_Total & (((Asc(P4_Caracter)) / 5) + 2) & " "

Ahora para desencriptar va un poco al reves primero restamos  el 2 y despues
multiplicamos por 5
|===========================================================================
DP2_Total = DP2_Total & (Chr((DP2_contenido(N) - 2) * 5))
|===========================================================================
Este metodo lo primero que hace cuando encripta es calcular el codigo  ascii 
depues lo divide por 5 y le suma 2, pues bien, para desencriptar tenemos que
coger el numero resultante restarle el numero sumado, multiplicarle el nume-
ro divido y pasarlo a codigo ascii.

Como ya tenemos varios motores hechos y sabemos como  funcionan  es  hora de
montar  un gran motor con todos ellos, si vas a encriptar ficheros lo pimero 
seria sacar el codigo ascii y depues empezar  a  encriptar,  para  texto  da
igual.La forma de ponerlo tambien es algo crucial y sobre todo a la hora  de
desencriptar, hay que tener mucho cuidado como ponemos el motor para  desen-
criptar, tiene que estar colocado al reves que el que encriptar y poner  las
operaciones inversas bien colocadas. Al final del texto hay un  codigo  com-
pletamente funcionar para encriptar texto y ficheros basados en estos  moto-
res.



.==========================================================================.
|=======~ 4.0 LA KEY     ~==================================================
|===========================================================================


Tal como esta el motor de cifrado es sencillo encriptar y desencriptar, para
evitar que sea de piñon fijo vamos a crear un sistema de key,  este  sistema
trata que segun la palabra nuestro motor encriptara de una manera u otra,esa
palabra es la key.

Como hemos ido aprendiendo el motor realiza unas operaciones matematicas para
encriptar  el  texto,  pues bien, esos numeros los sustituimos por otros para
encriptar de otra menera, pero ya no se podra desencriptar si no conocemos la
key.

Lo que hay ke hacer  es  pasar  las letras ke introducimos a numeros para que 
sustitullan a los puesto en codigo fuente.  Para ello tenemos que pasar todas
las letras puesta en la key a numeros, pero claro, si para nuestro motor  una
vez montado necesitamos 8 numeros y pasar todas las letras a numeros ( codigo
ascii ) son mas de 8 numero, la solucion es sumarlos sobre si mismos, el  nu-
mero 5 es ascii es 53 entoces sumanos 5 + 3 = 8, si el codigo ascii  una  vez
sumando es superior a 10 lo sumanos otra vez sombre si mismo 1 + 0 = 1. 

Parece muy bonito y sencillo, veamos como hacerlo por codigo.

Dim I as long
for I = 1 to len(text1.text)
	Caracter = mid(text1.text,I,1)
	final = final & asc(caracter)
	next
	Ese codigo pasa la key a codigo ascii, pero es sumamente grande.

|===========================================================================
El problema es que pasa cada caracter a 2 o 3 bytes y tenemos  que hacer que
lo pase a un 1 byte. 
|===========================================================================


El siguiente codigo nos pasa cada byte en ascii a un solo byte numerico.

	Dim I as long
	Dim Caracter as string
	For I = 1 To Len(Text1.Text)
    	Caracter = Mid(Text1.Text, I, 1)
    	Code_Ascii = Asc(Caracter)
    	For Q = 1 To Len(Code_Ascii)
        	Numero_Ascii = Mid(Code_Ascii, Q, 1)
        	Numero_Ascii_R = Numero_Ascii_R + Numero_Ascii
    	Next

    	If Len(Numero_Ascii_R) >= 2 Then
        	Dim R As Long
        	Dim PS_Caracter As String
        	Dim PS_Suma As Long
        	For R = 1 To Len(Numero_Ascii_R)
            		PS_Caracter = Mid(Numero_Ascii_R, R, 1)
            		PS_Suma = PS_Suma + Val(PS_Caracter)
        	Next
        	Numero_Ascii_R = PS_Suma
        
        	PS_Suma = 0
    	End If
    
    	Key_Bruta = Key_Bruta & Numero_Ascii_R

    	Numero_Ascii_R = 0
	Next
|===========================================================================

La salida Key_Bruta: 

El unico problema de este codigo ke si ponemos una key de X bytes  nos  dara 
un numero de X bytes, pero necesitamos un mumero de 8  bytes.  Ahora  lo  ke 
tenemos que hacer seperar en dos grupos el resultado obtenido,  en  caso  de
ser superior a 8 bytes, para ello el primer grupo de 8 bytes y el segundo de 
lo que quede, y los sumanos. El seguiente codigo fuente lo hace.
|===========================================================================

	Dim Bytes_8_16_A As Long
        Dim Str_8_16_A As String
        Dim StrEnd_8_16_A As String
        For Bytes_8_16_A = 1 To 8 'grupo 1
            Str_8_16_A = Mid(Key_Bruta, Bytes_8_16_A, 1)
            StrEnd_8_16_A = StrEnd_8_16_A & Str_8_16_A
        Next
        
        Dim Bytes_8_16_B As Long
        Dim Str_8_16_B As String
        Dim StrEnd_8_16_B As String
        For Bytes_8_16_B = 8 To BytesKey ' grupo 2
            Str_8_16_B = Mid(Key_Bruta, Bytes_8_16_B, 1)
            StrEnd_8_16_B = StrEnd_8_16_B & Str_8_16_B
        Next
        Dim End_Plus_8_16 As Long
        Dim End_Str_8_16_A As String
        Dim End_Str_8_16_B As String
        Dim End_Out_8_16 As String
        
        Dim End_Inter_8_16 As String
        For End_Plus_8_16 = 1 To 8
            End_Str_8_16_A = Mid(StrEnd_8_16_A, End_Plus_8_16, 1)
            End_Str_8_16_B = Mid(StrEnd_8_16_B, End_Plus_8_16, 1)
            End_Inter_8_16 = Val(End_Str_8_16_A) + Val(End_Str_8_16_B)
            'End_Out_8_16 = End_Out_8_16 & End_Inter_8_16
            
            If Len(End_Inter_8_16) >= 2 Then
                Dim R_8_16 As Long
                Dim PS_Caracter_8_16 As String
                Dim PS_Suma_8_16 As Long
                For R_8_16 = 1 To Len(End_Inter_8_16)
                    PS_Caracter_8_16 = Mid(End_Inter_8_16, R_8_16, 1)
                    PS_Suma_8_16 = PS_Suma_8_16 + Val(PS_Caracter_8_16)
                Next
                 End_Out_8_16 = End_Out_8_16 & PS_Suma_8_16 ' resultado
                
                PS_Suma_8_16 = 0
            Else
            End_Out_8_16 = End_Out_8_16 & End_Inter_8_16
            
            End If
        Next
La salida es  End_Out_8_16 

Este codigo fuente pasa cualquier key comprendida entre 8 y 16 bytes a un 
numero de 8 bytes. Ahora tenemos que hacer ke cada byte del resultado susti-
tuirlo por un numero de motor, para ello usamos este sistema muy sencillo.

Public Key_Byte_1 As Long
Public Key_Byte_2 As Long
Public Key_Byte_3 As Long
Public Key_Byte_4 As Long
Public Key_Byte_5 As Long
Public Key_Byte_6 As Long
Public Key_Byte_7 As Long
Public Key_Byte_8 As Long
Dim Key_out_en   as string	

Key_out_en  = PS_Suma_8_16 
Key_Byte_1 = Mid(Key_out_en, 1, 1)
Key_Byte_2 = Mid(Key_out_en, 2, 1)
Key_Byte_3 = Mid(Key_out_en, 3, 1)
Key_Byte_4 = Mid(Key_out_en, 4, 1)
Key_Byte_5 = Mid(Key_out_en, 5, 1)
Key_Byte_6 = Mid(Key_out_en, 6, 1)
Key_Byte_7 = Mid(Key_out_en, 7, 1)
Key_Byte_8 = Mid(Key_out_en, 8, 1)

Ahora colocas el Key_Byte_X en vez del numero y listo :)

Respecto a la key no hay mas ke decir.



.==========================================================================.
|=======~ 5.0 DESPEDIDA     ~===============================================
|===========================================================================


El objetivo de este texto es enseñar como crear motores de cifrado con visu-
al basic, son motores muy simples pero utiles. Espero que os haya gustado el 
texto.
	  
Para cualquier duda o consulta no lo dudes, ponte en contacto con migo, XpyXt
mail xpyxt@disidents.no-ip.org

Supongo ke junto la ezine estaran dos programas  open  source  basados  en el 
motor explicado en este texto.

Un saludo


		

