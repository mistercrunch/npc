

              ####                 ####
             #    #               #    #          ##########
                 #     ####           #                #  ###
                #      #  #          #  #####   #      #  #  #
            ### #  #   #    #    ### #       #  ####   #   # #
           #    #  ##   #   ##  #    # ######   #   #  # #  #
           #   ##  #  #  #  #   #   ##       #  #   #  # #   #
            ###  # #  ####  #    ###  #  ####   #   #  #  ###
          ========================================================
                              <DisidentS>                  #
                                                       ##
                                                       #

-.¿como programar troyanos en vbasic 1 ? by nORTh


advertencias:

	la información recogida en este articulo, es meramente informativa, el autor,
usea iop, manifiesta su intención expresa de k cualquier uso de la misma,
mediante la aplicación de codigo, instrucciones, o cualquier otro tipo de uso,
sea con fines educativos y en ningun caso con el fin de causar daño a terceros
o crear aplicaciones que puedan causarlo.


        Si lees este articulo, cualquier cosa k hagas con el contenido del
mismo sera bajo tu propia responsabilidad, por otra parte estaras aceptando k
estas leyendo un articulo de hacking, el hacking es ilegal y por lo cual
supuestamente estas incurriendo en actividades delictivas dependiendo de la
legislacion vigente en tu pais. Asi mismo, el uso de troyanos es considerado
ilegal en muchos paises, aun asi, son un medio efectivo y bonito de aprender
de k va esto de internet y como se comunican los ordenadores.

bueno, paso de mas rollos y eso, k si sigues leyendo es bajo tu responsabilidad.




1.- Algo de teoria:

 como todo buen articulo que se preste, desconociendo el nivel del lector, voy
a suponer este medio, bajo, empezaremos explicando un poco k es un troyano, e
iremos desglosando poco a poco cada elemento, si ya controlas algo, o sabes
algo, igual te saltas esta parte, ya se k es un rollo, pero no te recomiendo k
lo hagas, luego te me pierdes, asike cierra el notexcapes y bienvenido al
mundo de la programasion orientada a internet o redes locales.

bien, al grano como las gallinas:

Todos, o casi todos sabemos k es un troyano, e incluso de k tipos los hay, de
todos modos vamos a repasarlo un poco...

     basikamente hay de dos tipos:

         backdoors , k son lo ke se kedan escuchando en un puerto esperando
                  conexiones y permiten el acceso a ese ordenador.

         cliente-servidor: hay un programa servidor que es el k "infecta" y un
                           cliente k se conecta a ese servidor, tipo subseven,
                           netbus, back orifice etc..

los primeros, normalmente escuchan en un puerto como puede ser el de telnet
(el 23 pa profanos), y admiten conexiones de otros programas legales como
telnet, es decir, interpretan los comandos de estos programas.

1.2 ¿que hace realmente un troyano?

    bien, para k un troyano "troyanize" XD, debera de entender primero k es lo
k keremos k haga en el otro ordenador, yo no puedo abrir por ejemplo un telnet
a una makina y decirle ">niñoo...apagate" simplemente no me va a entender,
como siempre es problema de comunicasion..XD, como entre las mujeres y los
hombres, amos, ya me entendeis...

    Logicamente, se va intuyendo la necesidad de k nuestro troyanejo nos
entienda, si fuese un troyano de telnet, necesitariamos k nuestro bichito
entendiese los comandos k nuestro cliente de telnet le mandara, es decir si
ponemos "pass pepe" debera interpretar k pass es un comando y k pepe en este
caso es el pasword.

    Asi mismo debera de decirnos k el comando ha sido ejecutado con normalidad
y todo eso.

	claro k ke pasa si nuestro amigo ya tiene instalado un servidor de telnet?,
 a la hora de programar un troyano intentaremos usar un puerto por encima de los
 well know ports los 1024 primeros por que esos son puertos reservados y si nuestro
 anfitrion (el que hemos troyanizado) tiene otro servicio corriendo en ese mismo
 puerto habra como minimo conflictos y es seguro que seamos descubiertos en seguida
 a parte de que dos servicios no pueden escuchar en el mismo puerto escuchar es lo
 que hace un socket esperando al evento conect 	Bien, entonces komo nos aseguramos?
  principalmente usaremos un puerto poco conocido y que no este reservado para otro
  servico , las backdoors van bien para linux, en guin, personalmente, prefiero el
  segundo tipo de troyanos, los de cliente-servidor.

	bien, al igual k sucedia con una backdoor,nuestro "bicho" tendra k entender k
keremos k haga, normalmente me remitire a esto como "motor de comandos", ya 
vereis k suena a mucho pero no es tanto.


1.3 troyanos servidor-cliente
 
       bueno, se ve claramente mi preferencia :), nos vamos a detener aki, ya 
k este tipo de troyanos se hacen con la gorra :), por mucho k las compañias 
antivirus se empeñen en protegernos, hacer un troyano es cosa de niños y con 
un solo dedo para teclear.

1.4 teoria server-cliente

      vamos a ello, primero como va la cosa, tenemos un programa k se llama 
cliente
y otro k se llama servidor, porke?

      El servidor nos va dar acceso al ordenador, es decir, es el huesped de 
la makina en la k keremos entrar.

      El cliente, se va a conectar a el servidor, es la herramienta k usaremos 
para conectar con el servidor.

bien, como lo hacemos?

     nuestro cliente debera mandar comandos al servidor, estos comandos los 
vamos a definir e implementar nosotros mismos, es decir, haremos k nuestros 
comandos sean interpretados por el servidor, esto lo haremos con un motor de 
comandos.

un motor de comandos podria ser tan sencillo como: (aki empezamos con Vbasic)

        select case comando
         
           case "dir"
                     intrucciones
           case "del" 
                     instrucciones
           case "lo k kieras" instrucciones"
        
         end select

como ves, no es nada del otro mundo
claro k, ejem..como pillamos el comando y todo eso?
XD
ahora lo vamos a ver...primero hablemos de sockets y de k libreria usar...


2.- Programado en Vbasic 

bueno, todos sabemos k hay una cosa k se llama winsockets y tal...pero
jode...k pasa k todo el mundo usa la misma version?...todos usan winsockets?
la respuesta es NO, por ejemplo el win me, usa versiones diferentes, esto 
implica k o bien usamos winsockets arriesgandonos a k nuestro server no la 
encuentre en el infectado, o bien..somos mas listos...y conseguimos otra 
libreria de sockets...no sera mejor lo segundo??, aparte de este hay otros 
motivos..el guinsockets es engorroso..XD

primero definamos k leches es un socket, porke como no se como taras de nivel, 
creo k es justo k si te has tragado este coñazo,..jode..lo minimo es k te lo 
esplique un poco.

bien, un socket o los sockets son conexiones, es decir, perimten controlar los 
puertos, abrirlos, cerrarlos, blokearlos,dejarlos a la escucha etc...

vamos a decir k es cada cosa...

         cuando abres un socket bien puedes hacerlo para conectarte o para 
esperar
que alguien se conecte a el.

         blokear un socket implika k el proceso en Vbasic se va a kedar parado 
hasta k no se complete alguna operacion, por ejemplo, recivir datos.

         los sockets pueden ser binarios o no binarios, esto implika un pekeño 
dilema y k deberas resolver en funcion de lo k kieras hacer..por ejemplo

                si el socket es binario..la informacion k llege a el, sera 
interpretada tal y como llega.
                si el socket no es binario la informacion sera convertida a 
cadenas de texto. 

         bien, cuando un socket se deja a la escucha, osea listening, 
significa k ese socket esta esperando a una conexion, es lo k se denomina 
puerto abierto, si si, eso tipico k alguien te abre un privado diciendote todo 
escandalizado k tienes un puerto abierto...XDD es normal tener puertos 
abiertos, bueno, dependiendo de cuales, ya k podria ser un troyanin esperando 
una conexion...claro k si tienes el ftp o el telnet abierto..y no usas ningun 
server de ftp o telnet, tambien puedes empezar a moskearte.



2.1 k libreria uso para mi programa?

bien, yo te recomiendo katalyst socketwrench, porke? pos muy sencillo, ademas 
de incluir una estupendisima documentacion (necesitas el acrobat reader pa 
leerla) es realmente sencillo de usar y muy intuitivo. Para empezar a aprender 
creo k es de lo mejorcito k me he encontrado po este mundo.

¿que onde la pillas? pos akin...www.catalyst.com la libreria es la socket 
wrench, es gratuita y sencillamente genial.

apartir de ahora cuando programemos nos vamos a referir a ella.

(por cierto lo de catalyst es gratuito, pero tiene copywrite y tal, usala con 
conocimiento de ello, ya k es gratuita y se merecen ese respeto por parte de 
los k amamos las cosas gratis en inet y nos gusta la libertad de informacion, 
hay k apollar este tipo de "regalos" porke cuando profundicemos en el tema, 
veras k realmente es lo k los tios de catalyst nos hacen, un regalo de una 
pedazo libreria de la leche.).

(jode como se me va la pinza XDD)


2.2 Empezemos a trabajar:

 el problema de programar aplicaciones cliente servidor es k para probarlo 
necesitaras hacerlo desde tu mismo ordenador, lo cual implica k tendras k ir 
compilando uno de los dos, sakarlo a exe, y ejecutar el otro en vbasic para 
ver los errores k te da. Aparte de esa incomodidad lo demas es sencillo.


                empezaremos con el servidor:

    primero vamos a incluir el socketwrench en nuestro proyecto, bueno supongo 
k hasta ahi llegais todos, creo. Si no pos a consultar la ayuda, porke lo k no 
voy haser e un manual de vbasic XD, pista, vais a onde tan las herramientas, 
boton derecho, componentes y lo buzkais onde lo hayais metido.

bien, seleccionamos el iconejo k nos sale en nuestro panel de herramientas y 
lo metemos en el formulario de inicio.

a continuacion, al ser el servidor, lo interesante es k nada mas ejecutar, el 
socket se abra a la escucha, es decir, empiece a escuchar haber si hay alguien 
que quiera conectar con el:

para ello, lo definiremos en el evento load del formulario, haremos la 
declaracion asi:

incluye ademas una label (dejala con label1) 
Private Sub form1_load()

On Error GoTo error


socket1.AddressFamily = 2 (familia internet)
socket1.Protocol =  6     (protocolo tcp)
socket1.SocketType = 1    (tipo sock stream)
socket1.LocalPort = "9829" (puerto k vamos abrir)

socket1.Binary = True      (que significa esto?..lo ves ya te dije k leyeras   
                             todo, es para k acepte los datos de modo integro) 
           
socket1.BufferSize = 1024  (el buffer del socket)
socket1.Blocking = False

socket1.Interval = 60000 (tiempo de espera antes de decir si hay o no hay 
conexion                          en milisegundos, esto son 60 secs)
Label1.Caption = "abriendo conexion..... "
socket1.Action = 2
If socket1.Listening  Then Label1.Caption = "Preparado para recivir clientes"

Exit Sub

error:
respuesta = MsgBox("No puedo abrir conexion error " & Err, vbOKOnly, "Error 
interno")
If socket1.Listening = True Then Label1.Caption = "Preparado pero con errores"
If socket1.Listening = False Then Label1.Caption = "NO PREPARADO....MOTIVO 
ERROR" & Err (nos va a decir k numero de error es)

Exit Sub

End Sub 

   bien, k hemos echo, bueno, de momento abrir un socket a la escucha, es 
decir, hemos abierto el puerto 9829 en estado listening, usease, esperando 
conexiones, k porke el 9829? por ke ese puerto en concreto?..hay algun motivo 
oculto?..alguna razon?..si la hay, mi viciado y retorcido cerebro XD, usea 
porke me da la gana k sea ese, podria ser el 10100 o el k te venga en gana, 
siempre k tengas en cuenta k la conexion es tcp, y k no uses puertos k usen 
otros programas.

   bien ahora nuestro programilla en el mejor de los casos esta esperando a k 
alguien conecte con el...hasta aki, todo bien, es un programa normal.

komo sabemos k alguien conecta?

bien deberemos definir el evento k acepta la conexion , se llama 
socket1_accept (por webbes, lo uniko es si has cambiado el nombre del socket1, 
nombre_accept)

cuando un socket se conecta psa valores a nuestra funcion o evento accept,
el valor es socketid, la identificasion del socket, vamos a ver como va esto:

Private Sub socket1_accept(SocketId As Integer)
socket1.Accept = SocketId (aceptamos la conexion de este socket)
label1.caption="se nos ha conectado alguien"
end sub

bien, si alguien se nos conecta..simplemente lo aceptamos.una vez k la 
conexion se ha aceptado, tecnikamente estamos conectados a ese cliente k tan 
gratamente nos ha ofrecido relasiones de tipo tcp,(k gochinada XDD :)P ) pero 
claro, el rollo esta en mandarnos cosas y tal, k se puedan enviar datos y 
recivir datos... bien eso es sencilliiiiiiiimo...

definimos el siguiente suceso..si llegan datos...tal y tal

Private Sub socket1_read(Datalength As Integer, IsUrgent As Integer)
            
        socket1.RecvLen = Datalength
        cadena = socket1.RecvData

end sub

bien, k tenemos akin?...tenemos k hay dos variables k son pasadas al 
procedimiento, de donde?..del socket k konecta con nosotros,,cuando veamos el 
cliente lo entenderas mejor ya veras, de momento te vasta saber k Datalength 
va a recoger la longitud de la cadena k el socket nos esta mandando, para 
efectos..es un len, por ejemplo..seria el resultado de len("hola soy un 
juaiker y me he conestao cuntigo")

lo de isUrgent XD, lo vamos a dejar para mas adelante..pero mucho mas 
adelante, ya k es profunnnndo el tema..a la vez de jugoso..ya lo veremos.

bien..ahora tenemos dos cosas...socket1.recvlen=datalength y 
cadena=socket1.recvdata, bien...k kujons es eso?

para k el programilla lea los datos k nos manda el k se ha conectado, es 
preciso decirle kuanto mide la cadena k nos han mandado, eso nos lo dice 
datalength, (ves como es lo mismo k un len no?, insisto k ya veras como lo 
pillas mejo con el cliente).

despues tenemos cadena= socket1.recvdata, aki lo k hacemos es asignar a la 
cadena, los datos k llegan a nuestro server. sencillo no?


bien..pos ia tenemos un programa muy cutrelongo k acepta conexiones y lee lo k 
nos mandan...po ejemplo ahora podemos hacer k veamos k es lo k nos 
mandan...como? joder macho...facil

metes un text box..pispapente...y dices text1.text=cadena, o bien podemos 
prescindir de la variable cadena, y poner text1.text=socket1.recvdata. la 
funsion kedaria asina..


Private Sub socket1_read(Datalength As Integer, IsUrgent As Integer)

socket1(Index).RecvLen = Datalength
     text1.text = socket1(Index).RecvData
end sub

bien..ahora hay cosillas k se nos kedan en el tintero...

primero...nuestro programa acepta una..y solo una conexion..malo no?, 
bien..ademas aun no hemos implementado ese magnifico motor de 
comandos....usease k de momento nu ase na de na.XD}

vamos a avanzar un poco en lo segundo, ya k la solucion a lo primero es 
sencillisima, pero os voy a dejar pensar hasta la siguiente entrega, asi os 
estrujais el coco y aprendeis mas, creerme.

el motor de comandos..jeje nucleo prinsipal de todo troyano k se precie...ha 
de ser sobre todo sencillo, liviano..ligero..XD bien, porke ha de ser tan 
sencillo y libiano?..po en primer lugar, hasta ahora..todas las instrucciones 
y variables k hemos metido son mas k nada fundamentales...eso significa k no 
hemos tirado de mas de los recursos del sistema..debemos de tener en cuenta k 
nuestro programa se va a "colar" dentro de los procesos de otra makina, si la 
ralentiza..o ocupa demasiado..el tio lo mas posible es ke se de cuenta de k 
algo no va bien..o por lo menos k hay algo raro ejecutandose, ya vemos como 
pasar desapercibios en un ctrl +alt +del del win, pero eso pa mas 
adelante..(como mi jode hacer esto, pero eske sino jue..os escribo un libro XD 
en un pispas XDD).

 bien..nuestro motor de comandos deberemos de implementarlo justo dentro del 
evento accept, porke?..bien..podriamos hacerlo fuera..pasarle lo k hemos 
recivido..etc..pero como antes decia..cuanto menos ocupe en memoria nuestro 
programilla mejor..asike economia economia...


gueno..po os pliko de k va..va haber una serie de comandos k seras tu kien los 
defina..eso suena a mucho..pero ya veras komo en realidaz es una gilipollez 
XD, cuando el server reciva ese comando..pos hara una cosa u otra..antes os 
adetalatava la posibilidad de hacerlo con un select case, gueno..podeis 
hacerlo a base de ifs etc.. pero aki os lo espliko con select case, k porke? 
pos porke me parece mas ordenado dentro de lo k kabe..



Private Sub socket1_read(Datalength As Integer, IsUrgent As Integer)
Dim longitud As Long
Dim resto As Long
Dim antiguo_nick As String
Dim cadena As String


Rem motor de comandos
        socket1.RecvLen = Datalength
            
            cadena = socket1.RecvData
            comando = Left(cadena, 6) (cojemos po ejemplo 6 caracteres pa 
nuestros                                        comandos, 123456 argumentos)
            

Select Case comando
            
            Case "[ñisk]" _>lo de [ñisk] e una pirualada de ejemplo
            
       socket1.Blocking = True ---------------->muy muy muy muy importante!!!  
 
               label1.caption="comando recivido " & comando, "n"
                                   ...................
                                    ....................
                                     .................... 
       socket1.Blocking = False      --------->muy!!! muy importante!!!
            Call nicks_actualizar
            
            Case "[....]"
             
                    ...........      
                       .............
                        .............
                      
               End Select
          
            Next a
            Call nicks_actualizar
        
            Case Else
                label1.caption="si si, mi abuela va en moto tambien"
End Select

sencillo no?..un case normalito..o no? bien, pero hay dos cosas k debo 
resaltarte..
es muy posible k kuando ejecutes la parte del codigo en el caso de k el 
comando sea
[ñisk], necesites volver a leer algo del socket...pero otias..sabiendo k las 
cosas no son secuensiales..podria ser k leyeses otro comando..o cualkier otra 
cosa..como te aseguras tu de leer lo k tienes ke leer del codigo

esto lo solusionamos sencillamente con blokear el puerto, tal y como esplicaba 
al prinsipio del todo..ahimm..mira k te dije k no te lo saltaaaras..XD

gueno...
pos por ahora esto...practika...y trata de aventurar como podremos hacer 
conexiones multiples...

nos vemos en la segunda parte


