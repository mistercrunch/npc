[%]=-=[%]=-=[%]=-=[%]=-=[%]=-=[%]=-=[%]=-=[%]=-=[%]=-=[%]=-=[%]=-=[%]=-=[%]=-=
                                     
                    s$s -  Numero 1 / Febrero 2000 /  - s$s
                           _______   _____   _______    
            .{{-~&,       |   ____| |_   _| |  ___  |        ,&~-{{.
           {{}{{{{\`.     |  |        | |   | |___| |      .`/}}}}P{{
          {{{}  ™™/\ \    |  |____   _| |_  |  ___  |     / /\™™  {}}}
          {`}{\__=  ) }   |_______| |_____| |_|   |_|    { (  =__/}{`}
          {{{_/ l_,' /             Magazine               \ ',_l \_}}}
          {/  ~   ~ f                                      f ~   ~  \}
          / ^  o ) o)        (La E-zine Argentina)         (o ( o  ^ \
         / / \`-'`-'                  Por                   `-'`-'/ \ \
        { (   }    {                                        }    {   ) }
         `.`. j    {   Mr. Nuk3m ( mr_nukem@mixmail.com )   }    j .`.`
           `,`-, . l                                        l . ,-`,`
            f^' \ /}     y nadie mas por que es el numero   {\ / '^f
            t    Y }      1 y nadie la conoce, y aparte     { Y    j
             Y    \l    la estoy editando yo solo. Muah..   l/    Y
              \    \                                        /    /
               `.   \                                      /   .`
                !`,  \                                    /  ,`!
                l /   }                                  {   \ l
                l/   /                                    \l  \
                /  ,'                                      ',  \
               /  /!                                        !\  \
              / ,' l                                        l ', \
             (. \l. `_.                                  ._` .l/ .)
               \ \_`~~'                                  '~~`_/ /
                `''                                          ''`
[%]=-=[%]=-=[%]=-=[%]=-=[%]=-=[%]=-=[%]=-=[%]=-=[%]=-=[%]=-=[%]=-=[%]=-=[%]=-=

                         [)>- CIA Magazine / Team -<(]

                 Mr. Nuk3m ( mr_nukem@mixmail.com ) - EDITOR  

                                  -=%=-

             Sitio Web: 31173.freeservers.com (En Construccion)
                         E-mail: mr_nuk3m@usa.net

                                  -=%=-                           

                        Colaboraron en este numero:

                          Hasta ahora, N A D I E.. 

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

 Saludos desde este e-zine a:

 -= La lista Under 2000 (de Neomenia)
 -= La lista Aprendiendo      
 -= Zine Store (www.zine-store.com.ar), felicidades por el nuevo dominio. :)
 -= A la e-zine DZone (http://dzone.com.ar) de Donatien. :)
 -= Y a todos aquellos que me conocen..
       
 Distribuidores oficiales del e-zine:

 http://31173.freeservers.com (OFICIAL) (EN CONSTRUCCION)

 Nota Nuk3m: Se buscan distribuidores.. escribir a mr_nuk3m@usa.net. 

 Si queres colaborar con el e-zine, mandame tu articulo en formato TXT
 comprimido en lo posible, a mr_nuk3m@usa.net.

 Algunos de los textos que aqui se ponen, han sido copiados de webs u otros
 sitios pero siempre se respeta el contenido original de los autores y se pone
 la fuente de donde han salido. Si algun texto es tuyo y no queres que figure
 en este e-zine, decimelo y lo sacare de la edicion.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

         Titulo                                  Autor           Tema
         ~~~~~~                                  ~~~~~           ~~~~
 00. Indice .................................... Mr. Nuk3m ..... Que sera ?
 01. Editorial ................................. CIA-Team ...... CIA
 02. Noticias .................................. Mr. Nuk3m ..... Actualidad
 03. Descubriendo Linux Red Hat 5.0 (parte 1) .. Mr. Nuk3m ..... Linux
 04. Pepe IBM .................................. Alan MAy ...... BBS
 05. Chistes, Humor, etc. ...................... Mr. Nuk3m ..... Humor
 06. Mail del lector ........................... CIA-Team ...... Lectores
 07. Llave PGP ................................. CIA-Team ...... CIA
 08. Despedida ................................. CIA-Team ...... CIA

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 
ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
º Todos los contenidos de esta revista son solamente educativos, ninguno     º
º pretende incitar al crimen o a la ilegalidad. Cualquier uso erroneo de     º
º esta informacion no es responsabilidad mia. Asimismo, no me hago responsa- º
º ble de las informaciones u opiniones de nuestros colaboradores e informa-  º
º dores.                                                                     º
º                                                                            º
º Nota: Los acentos han sido suprimidos a proposito debido a que los         º
º caracteres pueden verse mal dependiendo del editor que utilices. Se reco-  º
º mienda usar el Edit de MS-DOS ya que el texto ha sido optimizado para ese  º
º editor.  Mr. Nuk3m                                                         º
ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

                -= CIA =- 1999-2000,  Derechos Reservados

      -=#( COMENZAMOS CON EL NUMERO 1 DE CIA, QUE LO DISFRUTES. )#=-


=-=(01)=-=-=-=-=-=-=-=-=-=-=-=#( EDITORIAL )#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
  
Ssii..!! Numero 1, un poco desprolijo, pero con muchas ganas de escribir
y llevar adelante esta e-zine. Hay muchas cosas por contarles, antes que nada
quisiera decirles que esta ezine ha llegado para quedarse y que en lo
posible saldria una vez por mes. Se Necesitan Colaboradores, y gente que
este dispuesta a formar parte del CIA Team. Les cuento que el CIA Team va a
ser menos de 10 personas, asi que aquellos que se sientan capaces de llevar
una seccion de la revista como una seccion de Hack, Crack, Phreack o lo
que sepa hacer que me escriba asi queda confirmado como editor de la revista.

Por otro lado, tambien se necesita de gente que quiera alojar esta e-zine
en su Web Site. Asi que si quieren hacerlo, lo pueden hacer. Pero sin
modificar ni un solo caracter de la revista. :)
Tambien, podras encontrar la revista todos los meses en el web site OFICIAL
http://31173.freeservers.com y otras revistas que te agraden.

Por ahora el Web Site (31173.freeservers.com) esta En CONSTRUCCION, pero
muy pronto estara abierto para que puedas buscar todas las e-zines y cosas
que quieras.

Ok, eso es todo por ahora, disfruten este numero... y escriban al mail.

Mr. Nuk3m

=-=(02)=-=-=-=-=-=-=-=-=-=-=-=-=#( NOTICIAS )#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

 Bueno gente aca pueden encontrar algunas cosas interesante que les interese
 y que quizas les sirva de algo..

................................. Virus Nuevo ................................

 Si recibis un Mail titulado: "Up-grade internet2" !!NO LO ABRAS!! ya
 que contiene un ejecutable con un icono muy gracioso. El ejecutable se 
 llama Perrin.Exe. Este virus borra toda informaci¢n del disco duro y, de 
 alguna manera, se refugia en la memoria del PC, por lo que, cada vez que 
 cargues informaci¢n en el disco duro, este lo borra de nuevo, dej ndolo 
 inservible. 

 Esta informaci¢n fue publicada en la p gina Web de la CNN. Se ha dicho
 que este virus es muy peligroso y que a£n no existe antivirus para ‚l. 

 Otro nuevo virus ha sido descubierto: Llegar  en un E-Mail titulado:
 "California. IBM". YA lo han anunciado que es muy poderoso, m s que Melisa. 
 No hay remedio, se comer  toda la informaci¢n en el disco duro y destruir 
 el Netscape Navigator y el Microsoft Internet Explorer.

 Nota Nuk3m: Esto lo recibi en mi e-mail y me parecio algo digno de publicar
             en esta seccion, aunque vaya uno a saber si es cierto.

............................FTP's y sitios WareZ..............................

--== FTP SERVER 1 ==--     --== FTP SERVER 2 ==--
IP : 24.232.24.5           IP : 24.232.28.58 
User : warez               User : warez
Pass : rulez               Pass : rulez
Port : 22                  Port : 22
Enter!                     Enter!

 Nota Nuk3m: Si intenta entrar en estos FTP's, sean pacientes porque con
             mucha suerte podes llegar a entrar. Porque casi siempre
             esta lleno de usuarios buscand cosas para bajar.

 Otra buena alternetiva es ir a www.latinwarez.com (o com.ar era ??) y
 vas encontrar algo que te guste seguro...

.........................Internet Gratis......................................

 Si leiste bien, INTERNET GRATIS. La compa¤ia i-CERO llego a la Argentina
 para brindar acceso gratuito a Internet. Esta nueva compa¤ia contrata
 los servicio de un ISP que brinde un servicio "REALMENTE" Bueno con un
 maximo de 10 usuarios por modem de 56 K V.90, acceso por 0610 y una mesa
 de ayuda 0-800 las 24 Horas.

 Donde esta el truco ??
 i-CERO promete NO COBRAR ABSOLUTAMENTE NADA, EN NINGUN MOMENTO. Tampoco se
 enviaria Spam ni se obligaria a utilizar un navegador especifico. La unica
 trampita es la aparicion de dos pantallas al iniciar el software de
 conexion (que hay que bajar de www.icero.com), con links a ofertas,
 productos y sitios de comercio electronico. Si no deseamos visitar estos
 sitios presionamos dos veces el boton continuar y se lanzara nuestro
 navegador por defecto con la pagina de i-CERO como inicial. El programa de
 conexion ya se puede bajar desde el sitio, y suscribirse gratuitamente al
 servicio. El alta de cuentas va a ser progresivo; no esperen conectarse
 apenas se suscriban. Se calcula que dentro de 7 meses tendran unos 60.000
 personas registradas.

 i-CERO no apunta a competir con los ISP tradicionales, sino que tiende a
 capturar el mercado de aquellos que se conectan usando la cuenta de otro
 (una realidad muy cierta en nuestro pais). Es por eso que para poder "tener"
 Internet debemos suscribirnos (registrarnos) en el web site de i-CERO y
 despues bajarnos el soft y esperar que nos llege a nuestro e-mail la
 confirmacion de nuestra cuenta de i-CERO.

 Nota Nuk3m: Asi que ya saben, si estan usando alguna cuenta que no es de
             ustedes, dejense de joder y suscribanse a este servicio que
             creo que va a andar muy bien en la Argentina. A parte, se
             ahorran de que los descubran si usan alguna cuenta ajena.

........................Windows 2000..........................................

(articulo sacado de la revista DZone, numero 33)

Prueba del Windows 2000
Escrito por Clark

En el ultimo mes me he dispuesto a probar la version beta 3 del ya muy
mencionado Windows 2000.  La version final de este sistema aun no es
comercial, y no lo sera; hasta febrero segun se.

En realidad el paquete no es nada mas que Windows NT 5.0 con un toque de
Win 98. Hasta hoy han salido tres versiones principales de Windows 2000:
el Server, el Advanced Server y el Professional (que es en el que me
enfocare; ya que los otros no he tenido oportunidad de probarlos).

Despues de usarlo un tiempo, las novedades salen a relucir, su primera
caracteristica, es que ya no usa ni el mentado MS-DOS ni el COMMAND.COM
usado en win95 y 98.

La instalacion es totalmente automatizada y si asi se desea se puede
conservar el Windows que se tiene instalado mediante una particion creada
automaticamente. En mi caso decidi formatear mi disco rigido ya que estoy
convencido de que entre mas limpio este el disco mejor funcionara el sistema.

Bien, si se desea Windows 2000 puede hacer un simple upgrade desde cualquier
version de Windows previa, solo tiene que darsele la orden y automaticamente
hara el resto y no necesitara de tu atencion nuevamente hasta el momento en
que halla culminado la instalacion. Una ventaja que en lo personal me
sorprendio mucho es que no pide controladores para nada en absoluto, reconoce
desde tu monitor hasta tu tarjeta de sonido y desde tu scanner hasta tu
impresora, todo automaticamente, y despues busca el controlador en el disco y
lo instala sin necesidad de insertar esos molestos discos llenos de
controladores.

Parece increible pero Windows 2000 consume menos recursos del sistema en
comparacion con Windows 98, lo que hace el uso de este mas eficiente y menos
tardado (esto fue probado en un celeron a 333mhz con 64mb de ram y 4gb en
disco duro).

¨Se acuerdan de las contrase¤as de Win 98? Esas que con darle "Cancel" te las
puedes saltar...  Pues bien, en W2000 es imposible saltarse estas contrase¤as,
lo que hace el sistema mas seguro.  Nadie podra acceder si no cuenta con una
contrase¤a (claro que es opcional, bastara con configurarlo para que no pida
contrase¤as al inicio).  Cada usuario esta diferenciado y tiene sus propias
carpetas "mis documentos" y "mis fotos", lo que significa que solo el podra
acceder a sus archivos.  Asimismo solo tendra acceso a las aplicaciones que
tenga configuradas en su contrase¤a.  Aquellas para las cuales no cuente con
el permiso necesario simplemente desapareceran (desde la carpeta hasta el
acceso directo de la misma).

Win2000 viene con Internet Explorer 5 y Outlook 5, ambos con mejoras. Trae
animaciones en el menu de inicio, y tambien se anima la pantalla cuando
oprimimos ctrl+alt+supr (esto a modo de alarma por si lo pulsamos por error).

El "Task Manager" (ya saben la ventanita donde aparecen las aplicaciones
abiertas) es similar al que implementaba Windows NT. El mismo presenta tres
secciones: 

- Aplicaciones abiertas
- Procesos  abiertos
- Uso del sistema

Aplicaciones abiertas es la clasica ventanita de Win 98. En procesos abiertos
aparecen todos aquellos procesos ocultos que en Win 98 solo se pueden ver con
el MataProcesos de donatien. Con este visor de procesos se puede acabar
facilmente con cualquier virus o troyano ya que la mayoria son simples
procesos ocultos.

En lo que respecta a las opciones de accesibilidad, trae una novedad llamada
"NARRATOR" que mientras este activa va leyendo en voz alta todo lo que
aparece en tu pantalla. Viene integrado con el Phone Dialer, con el cual se
pueden hacer llamadas de telefono desde internet.

Pues bien, creo que esas son las novedades mas relevantes de esta nueva version
de Windows, espero que este articulo haya servido de algo.

Marco Antonio (Clark) - 16 a¤os
marcoantcerv@starmedia.com
Mexico.

Bueno ahora agrego unas lineas mas al articulo...

Como se comento mas arriba, se ha fijado el 17 de Febrero como el dia D para
la aparicion de Windows 2000 (en nuestro pais, la presentacion oficial sera
el 9 de marzo).

Recordemos que Windows 2000, es en realidad, NT 5; y que esta pensado para
ser usado por empresas y profesionales independientes. El sucesor de
Windows 98 sera Windows Millenium, pensado exclusivamente para el hogar y
sin fecha anunciada de salida aun.

Segun Microsoft, en maquinas con 64 Mb de Ram o mas, Windows 2000 es
sensiblemente mas rapido que Windows 98. En cuanto a la interfase, tiene un
menu de inicio autoconfigurable (similar a lo que ocurre con Office 2000),
los tipicos efectos de menues animados, nuevos iconos y un "booteo en modo
grafico", entre otras novedades.

Las distintas versiones de Windows 2000 son:

Producto                     Orientacion
--------                     -----------
Windows 2000 Professional    Sistema operativo de negocios para PCs de 
                             escritorio y notebooks. Soporta hasta 2
                             procesadores.

Windows 2000 Server          Sistema operativo de red multiproposito. Soporta
                             hasta 4 procesadores y 4 Gb de Ram.

Windows 2000 Advance Server  Sistema operativo de red para aplicaciones de
                             mision critica. Soporta hasta 8 Gb de Ram.

Windows 2000 Datacenter      Sistema operativo de red para sistemas de altas
Server                       demandas. Soporta hasta 32 procesadores y 64 Gb
                             de Ram.

El Windows 2000 (version actualizacion) en nuestro pais, saldra alrededor de
unos U$S 200.
...................................Fin de Noticias............................

Bueno, nada mas por ahora..   

=-=(03)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


                         Descubriendo Linux Red Hat 5.0
                         ------------ ----- --- --- ---
                                 By Mr. Nuk3m 
                                 -- --- -----
                                    V1.3
                                    ----

 Hola a todos los que estan leyendo esto, yo soy Mr. Nuk3m y voy a tratar
 de escribir un manual del sistema operativo Linux Red Hat 5.0. Disculpen
 las faltas de ortografia pero no voy a poner acentos, salvo las e¤es
 para que todos puedan leer este texto sean usuarios de Windows o Linux :)
 Me reservo los derechos de autor de este manual por lo que si quieren hacer
 modificaciones, avisen primero. Este texto es de libre distribucion, siempre
 y cuando aparezcan estas lineas y mi nombre, Mr. Nuk3m. 

 A continuacion un indice para que puedas buscar lo que te interesa saber
 de Linux Red Hat 5.0:
                
  Contenido  
                
   Introduccion (lo esta leyendo)
                                      
   1. Caracteristicas Del Sistema Operativo (S.O.) Linux
      1.1  Principales Caracteristicas
           1.1.1  Linux y los sistemas de Microsoft
           1.1.2  Linux y los sistemas de archivos
           1.1.3  Linux y las redes
           1.1.4  Linux y la interconeccion con otros sistemas
      1.2  Caracteristicas de Hardware requerido y soportado
           1.2.1  Hardware requerido por Linux en maquinas con arquitecturas
                  Intel 80x86
           1.2.2  Hardware soportado por Linux
   2. Estructura General Del Sistema De Archivos
      2.1  Sistema De Archivos
           2.1.1  Nombres de archivos
           2.1.2  Atributos de los archivos
           2.1.3  Directorios
           2.1.4  Estructura del sistema de archivos
           2.1.5  Rutas dentro del sistema de archivos
           2.1.6  Los "links" y los archivos
      2.2  Estructura General De Un Sistema De Archivos Linux
   3. Usuarios, Permisos y Grupos
      3.1  Permisos de acceso
      3.2  Directorio "home" y permisos predefinidos
   4. Dispositivos De Entrada-Salida
      4.1  Conceptos Fundamentales
           4.1.1  Puertos de entrada-salida
           4.1.2  Iterrupciones e IRQ's
           4.1.3  Accesos Directos a Memoria (DMA)
      4.2  Tratamiento de los dispositivos en Linux
           4.2.1  Archivos de los dispositivos mas comunes
   5. Programas y Procesos
      5.1  Ejecucion en primer plano y en "background"
      5.2  Demonios
   6. La Interaccion Con El Sistema. Shell y Comandos
      6.1  La Shell
           6.1.1  Funcionamiento de la shell
      6.2  Comandos
           6.2.1  Comandos simples
           6.2.2  Separador de comandos
      6.3  La Entrada Estandar y La Salida Estandar
           6.3.1  Redireccionando la salida
           6.3.2  Redireccionando la conexion de errores estandar
           6.3.3  Redireccionando la entrada
      6.4  Ca¤erias
      6.5  Generacion De Nombres De Archivos
   7. Comandos Y Utilidades
      7.1  Movimiento En El Sistema De Archivos
      7.2  Listado De Archivos
           7.2.1  Moviendo y copiando archivos
      7.3  Manipulando Archivos
           7.3.1  Moviendo y copiando archivos
           7.3.2  Realizando links
           7.3.3  Eliminando archivos
      7.4  Manipulando Directorios
           7.4.1  Creando directorios
           7.4.2  Eliminando directorios
      7.5  Busqueda De Archivos
           7.5.1  Ejemplos del uso de find
      7.6  Cambiando Permisos, Grupos y Due¤os
           7.6.1  Averiguando los derechos de acceso de un archivo
           7.6.2  Cambiando los permisos
           7.6.3  Cambiando el due¤o y el grupo de los archivos
        
  Empecemos con una pregunta clasica, ¨ Por que Linux y no otros S.O. ?

 Existen una serie de problemas que son comunes a los sistemas operativos
 comerciales y aquellos que, basicamente tienen las siguientes caracteristicas:

  * Cuestan mucho dinero (mas de U$S 50).
  * El codigo fuente del S.O. no esta disponible.
  * Existen limites extrictos en cuanto a la copia del sistema se refiere.

 Consecuentemente, Windows, MacOS, DEC, Ultrix, Solaris, OS/2 son sistemas
 operativos comerciales. Linux y FreeBSD son gratituos; estan disponibles
 generalmente por el costo del medio (CD-ROOM, DISQUETTES, ETC) en que se
 distribuye, el codigo fuente esta disponible y existen pocas limitaciones
 en cuanto a su distribucion. Dado que los sistemas operativos comerciales
 son la fuente de ingreso de las companias que desarollan estos sistemas,
 se dan algunas situaciones que no son ventajosas para el usuario final de
 la computadora. Algunos de estos problemas se deben a la necesidad de
 proteger y mantener en secreto el codigo fuente, como ser:

  * SE ACTUALIZA LENTAMENTE: Los S.O. comerciales como Windows, etc.
    realizan actualizaciones importantes cada 2 o 3 a¤os (Windows 3.11,
    Windows 95, Windows 98 y proximamente Windows 2000), mientras que
    existen lanzamientos de las mayores distribuciones de Linux (Red Hat,
    Debian, SlackWare) cada 6 u 8 meses y se publica en Internet una version
    nueva del Kernel por semana, aproximadamente.

  * ALTO COSTO: Una copia y un numero limitado de licencias de cualquier
    sistema operativo comercial (especialmente para servidores) cuesta mas
    o menos U$S 400 dolares y casi nunca incluyen herramientas de desarrollo,
    como servidores de mail, de web, compiladores C, C++, etc.

  * SOPORTE TECNICO: Los compradores de S.O. comerciales dependen
    exclusivamente del servicio tecnico que brinda la compania en cuestion,
    incluso realizando costosas llamadas telefonicas. En la vereda de enfrente
    y de una forma descentralizada, existen una gran cantidad de puntos de
    consulta para Linux, ya sean organizaciones dedicadas o particulares
    experimentados.

 Se agregan, ademas, un par de problemas que se aplican casi exclusivamente
 al sistema Windows de Microsoft, veamos esto:

  * OBSOLENCIA DEL HARDWARE: No se mantiene compatible con los sistemas
    anteriores. Se dice que es tecnicamente posible "correr" Windows 95
    sobre una PC 386 a 25 Mhz, pero podemos comprobar que hacerlo sobre un
    harware anterior a una PC 486 DX2 a 66 Mhz con 16 Mb de Ram es un
    ejercicio masoquista :) Y es aca donde el costo aparece nuevamente como
    un factor importante a considerar.

  * PROPENSO A FALLOS: No es raro observar que Windows se "CAE" sin razon
    aparente, y la experiencia personal de quien alguan vez uso un Windows
    lo ha demostrado con creses. Aunque su hermano mayor, Windows NT, es
    bastante mas estable, todavia se caecon una frecuencia mayor a la que
    cualquier usuario espera. Hay casos documentados donde servidores Linux
    han estado operando por mas de 1 a¤o sin caida alguna :)

 Caracteristicas de Linux

 Ventajas

  * ADECUADO PARA LA COMUNICACION EN RED: Dado que Linux fue desarrollado por
    un grupo de programadores de Internet, se le dio una prioridad mayor a
    las propiedades  de networking. Estas propiedades funcionan muy bien aun
    con configuraciones de hardware minimas. Se lo utiliza tanto de cliente
    como de servidor de otros S.O. populares; incluso puede ser utilizado por
    los proveedores de Internet. Soporta todos los protocolos mas utilizados
    (TCP/IP, FTP, Samba, Apple Talk, etc).

  * MULTIUSUARIO - MULTITAREA: Sigue la filosofia Unix, lo cual es ventajoso
    incluso si lo utiliza una sola persona, dado que las tareas se ejecutan
    con una proteccion mayor; ademas un mismo usuaro puede estar ejecutando
    varias tareas concurrentemente. Linux tiene la capacidad de manejar todo
    ese "trafico" de informacion.

 Falencias

  * INTERFACE DE USUARIO INCONSISTENTE: GNU/Linux refelja el trafico de varios
    programadores, cada uno con metas de dise¤o diferentes, interfaces
    diferentes, etc. Incluso no existe una restriccion de consistencia entre
    utilidades de una misma distribucion. Esto puede llevar a confusiones y
    frustraciones. Actualmente, se estan llevando a cabo proyectos para
    promover interfases graficas consistentes a traves del sistema XWindows
    (KDE, GNOME, Teak, etc).

  * PAQUETES REPETIDOS: Dentro de una distribucion se pueden encontrar una
    gran cantidad de paquetes "repetidos"; cumplen uan misma funcion, pero
    fueron dise¤adas por distintas personas, con objetivos de dise¤o. Por
    ejemplo: se pueden encontrar varios agentes de transmision de mail como
    el sendmail, smail, qmail, exim, etc.

  * FALTA DE APLICACIONES COMERCIALES: No se han desarrollado grandes suites
    de aplicaciones, aunque en Internet podemos encontrar el Star Office para
    Linux ;)

 Conclusion

 El numero de usuario de Linux esta creciendo rapidamente. Las ventajas
 tecnicas de Linux por sobre otros S.O. comerciales son muy grandes,
 importantes y evidentes. A pesar de ello, Linux todavia tiene caracteristicas
 que lo hacen un poco dificil de usar y otras que pueden hacer que Linux no
 sea el sistema adecuado al momento de elegir.

 La mayoria de las personas que hoy son usuarios de Linux, eran usuarios de
 los distintos sistemas de Microsoft (Windows, MS-DOS, etc) que se dieron
 cuenta de la potencialidad del sistema Linux y de su gran futuro. Hoy hay
 una gran tendencia a abandonar los sistemas de Microsoft y sumarse a la
 filosofia del sistema operativo Linux. Pero, cuidado, obviamente Linux no
 es el sistema ideal en todas las situaciones. No existe tal cosa como la
 MEJOR COMPUTADORA o el mejor SISTEMA OPERATIVO; todo va a depender de la
 tarea que realizemos. Por eso, no creo que Linux sea la mejor solucion para
 todos, por mas que sea tecnicamente superior a muchos S.O. comerciales.

 Un usuario se beneficiara enormemente con Linux si lo que necesita es
 software para programar :), utilizar Internet :), para procesar texto
 con "TeX", y software tecnico en genereal, pero si se necesita fuertemente
 el software comercial o si el usuario no se siente comodo aprendiendo y
 tipeando comandos, entonces debe buscar en otro lado...

 Bueno, bueno, hasta aca llego la introduccion ahora empezamos...



 CAPITULO 1

 CARACTERISTICA DEL SISTEMA OPERATIVO LINUX

 En este capitulo vamos a describir las caracteristicas del S.O. Linux. Es
 importante conocer estas caracteristicas ya que explican porque Linux es
 un sistema tan potente, versatil y nos daran una amplia vision de algunas
 de las caracteristicas internas importantes del sistema. Tambien se
 describira el hardware sobre el cual se puede ejecutar Linux y los
 distintos dispositivos de entrada/salida que son soportados por el sistema.

 Todo lo tratado en este capitulo es aplicable al sistema Linux sobre
 plataformas de la familia Intel 80386 y superiores. El nucle analizado es
 la version 2.2.5.

 1.1 PRINCIPALES CARACTERISTICAS

 Linux es un sistema operativo completo multiusuario con multitarea real.
 Esto significa que sobre una misma maquina con el S.O. Linux pueden estar
 trabajando varias personas simultaneamente y a su vez cada persona puede
 estar ejecutando varios procesos.

 Linux es un S.O. de 32 bits desarrollado para la plataforma Intel 80386.
 Fue realizado aprovechando las caracteristicas de modo protegido de este
 procesador. Asi fue posible implementar la multitarea real y otras
 caracteristicas como memoria virtual y ejecutables con carga de paginas
 por demanda. Linux es tan robusto y completo que es capaz de ser utilizado
 en maquinas en las universidades hasta en largas corporaciones en las
 cuales trabajan cientos de personas al mismo tiempo.

 El codigo del nucleo de Linux fue realizado pensado en ser compatible con
 los estandares de POXIS2 de Unix y otros. Esto quiere decir que es
 totalmente compatible con la mayoria de los sistemas Unix comerciales y
 gratituos que existen en la actualidad. De esta forma la mayoria del
 software desarrollado para otras versiones de Unix funciona perfectamente
 sobre Linux.

 El nucle es capaz de emular por su cuenta las instrucciones del coprocesador
 matematico 80387, con lo que cualquier maquina 80386 sin coprocesador podra
 ejecutar, sobre Linux, aplicaciones que requieran de estas instrucciones.
 En maquina 80486, no es necesario que el nucle emule estas instrucciones ya
 que el coprocesador se encuentra instalado en hardware como parte del
 procesador.

 Otra caracteristica muy importante del sistema es la memoria virtual, que
 permite que se puedan ejecutar programas que utilizan mas memoria de la
 disponible y que es fundamentalmente necesaria para soportar la multitarea.
 Ademas se soportan ejecutables con paginacion por demanda, esto significa
 que solo las paginas necesarias son cargadas en memoria en cada momento,
 utilizando asi mas efectivamente la memoria del sistema. Relacionado con
 esto se encuentra el concepto de area de intercambio o "SWAP" la cual se
 utiliza para almacenar temporariamente informacion que no se puede matener
 en memoria porque esta no alcanza. Esta area de intercambio es imprescindible
 en maquinas que tiene muy poca memoria.

 Fuertemente ligado a Linux, y a los sistemas Unix, esta el concepto de
 librerias dinamicas. Estas se utilizan para almacenar codigo compartido por
 varios programas en una unica libreria. Asi los programas son mas chicos y
 utilizan estas funciones.

 1.1.1 LINUX Y LOS SISTEMAS DE MICROSOFT

 Cabe destacar que Linux NO ES COMPATIBLE con el sistema MS-DOS ni con los
 sistemas Windows 95/98/NT. Los sistemas MS-DOS, Windows 95/98 son sistemas
 hibridos de 16/32 bits y los programas que se ejecutan sobre estos sistemas
 NO PUEDEN SER EJECUTADOS en Linux ya que fueron desrrollados para ser
 ejecutados especificamente en esos sistemas. En cuanto al sistema Windows NT
 es un sistema de 32 bits con un nucleo completamente nuevo y tambien es
 totalmente incompatible con Linux. Sin embargo, todos estos sistemas pueden
 convivir tranquilamente en una PC, o sea que sobre cualquier computadora, con
 suficiente espacio en el disco duro, es posible tener instalado Linux y ademas
 Ms-DOS, Windows 95/98 o NT.

 Sobre Linux, existen emuladores de MS-DOS los que permiten que ciertas
 aplicaciones de MS-DOS puedan ejecutarse sobre Linux. Uno de los emuladores
 mas conocido es el llamado "DOSEMU" y permite ejecutar aplicaciones como
 Turbo Pascal, Turbo Assembler, Harvard Graphics, etc. A su vez existe un
 proyecto llamado "WINE" (Win Emulator) para permitir ejecutar aplicaciones
 Windows sobre el sistema grafico de vantanas X Windows.

 1.1.2 LINUX Y LOS SISTEMAS DE ARCHIVOS

 Linux posee un sistema de archivos propio, no compatible con los de Microsoft,
 llamado "ext2fs" ( Extended File System 2 =). Esto quiere decir que si en una
 PC tenemos instalados los sistemas Linux y MS-DOS/Win95/98/NT desde los
 sistemas de Microsoft no podremos acceder, ni para lectura ni para escritura,
 a los sistemas de archivos de Linux.

 En cambio Linux es capaz de leer y escribir en sistemas de archivos de MS-DOS
 (FAT), de Win95 (VFAT), inclusive con nonbres largos :)) , de Win98 (FAT32),
 tambien con nombres largos =) , y de NT (NTFS). Aunque el soporte de escritura
 sobre NTFS esta, hasta el momento, desarrollado en forma experimental y se
 recomienda no utilizarlo ya que podria da¤ar la escritura de archivos de una
 particion NTFS.

 Ademas de los sistemas de archivos descriptos anteriormente, Linux es capaz
 de leer y escribir sobre particiones basadas en sistemas de archivos de MINIX,
 FFS (Fast File System), de Apple Macintosh, de los sistemas Unix SCO, System
 V, Coherent y Xenix, y UFS de BSD (Unix de Berkeley).

 Linux es capaz de leer archivos de particiones OS/2 HPFS del S.O. OS/2 de
 IBM y del ADFS (Acorn Disk file System) del S.O. de Acorn. Soporta ademas
 lectura desde los CD-ROM's sobre el sistema de archivos estandar que es el
 ISO9660.

 Ademas de esto podemos aplicar sobre el sistema de archivos ext2fs porciones
 del disco limitadas a cada usuario. Esto es conocido como "QUOTAS" y sirve
 para limitar la cantidad de espacio de espacio de almacenamiento en disco
 que cada usuario es capaz de usar.

 1.1.3 LINUX Y LAS REDES

 Cuando hablamos de redes, Linux es la opcion. No solo porque el trabajo en
 red esta altamente integrado con el sistema operativo, sino que ademas una
 infinidad de aplicaciones de libre distribucion se encuentran disponibles y
 que, mas importante aun, es totalmente robusto bajo una gran carga, lo que
 es un resultado de a¤os de desarrollo, testeo y correccion basados en el
 proyecto Open Server.

 Linux tiene realizada como parte de su nucleo una implementacion completa de
 los protocolos de la famila TCP/IP muy eficiente y con soporte para muchos
 conceptos avanzados de trabajo en redes.

 Linux puede funcionar como servidor de WWW en Internet de forma excelente. Es
 mas el servidor APACHE mediante el cual se puede instalar un servidor WWW
 sobre Linux, es el servidor de WWW mas utilizado en Internet y en Itranets
 actualmente. Ademas Linux es capaz de funcionar como cliente de WWW, ya sea
 en una maquina conectada permanentemente a Internet o mediante modem (PPP).

 Esto no es lo unico que se puede realizar con un sistema Linux. Linux es
 capaz de actuar de servidor PROXY, ser utilizado como FIREWALL, como ROUTER
 avanzado o como BRIDGE (puente). Tiene soporte para alias de IP, protocolos
 IPX/SPX, protocolos IPv6, AppleTalk, X.25, ISDN, PPP, SLIP, PLIP, etc.

 A nivel aplicaciones, Linux esta acompa¤ado de innumerables aplicaciones
 como lo son:

  * Sendmail: Puede actuar de servidor de mail, ya sea para enviar, recibir y
              realizar un sin numero de tareas relativas al correo electronico.
              Sendmail es el servidor de mail mas utilizado en Internet.

  * Ftp: Linux puede actuar como servidor o cliente de ftp (File Trasnfer
         Protocol). Un servidor de FTP es capaz de permitir que los clientes
         se conecten y recuperen archivos disponibles en el servidor.

  * Noticias (NEWS): Existen varias implementaciones del protocolo NNTP, el
                     cual sirve para permitir que una red de computadoras
                     sobre Internet intercambien articulos que cubre todo
                     tipo de topicos o tematicas.

  * DNS (Domain Name System): Un servidor DNS tiene el trabajo de traducir
                              los nombres utilizados en Internet como por
                              ejempl www.linux.org en direcciones de IP. El
                              trabajo de DNS sobre Unix/Linux lo realiza un
                              programa llamado "NAMED".

  * Telnet: Telnet es un programa que permite a una persona usar una
            computadora remota como si estuviera trabajando directamente
            sobre la misma.

 1.1.4 LINUX Y LA INTERCONECCION CON OTROS SISTEMAS

 Linux puede interactuar completamente con varios sistemas conocidos
 compartiendo archivos e impresoras en una red. Esto hace posible integrar
 una maquina Linux con cualquiera de los sistemas mas utilizados actualmente
 y permitir su total conectividad.

 Los sistemas con los que Linux puede ser usado para compartir recursos son
 los siguientes:

  * Apple: Linux soporta la familia de protocolos AppleTalk. Linux permite a
           clientes Macintosh ver recursos de un servidor Linux, asi como
           otros clientes Macintosh en una red y compartir archivos e
           impresoras desde el servidor Linux.

  * Entorno Windows: El grupo de aplicaciones SAMBA, que es provisto con el
                     S.O. Linux, permite interactuar a un sistema Linux como
                     servidor o cliente de maquinas con Windows 95/98, Windows
                     NT, DOS o Windows For Workgroups.

  * Novell Netware: A traves del protocolo IPX, Linux puede ser configurado
                    para actuar como un servidor o un cliente NCP, y
                    permitiendo asi servicios de archivos e impresoras en
                    redes Novell.

  * Entornos Unix: La manera mas conocida y eficiente de compartir archivos
                   en entornos Unix es mediante NFS (Network File Sharing).
                   Este protocolo fue originalmente desarrollado por Sun
                   Microsystems. Es una de compartir archivos entre maquinas
                   de forma que parezca que son archivos locales. Asi se
                   puede tener una maquina totalmente funcional sin necesidad
                   de tener un disco rigido instalado.

 1.2 CARACTERISTICAS DE HARDWARE REQUERIDO Y SOPORTADO

 1.2.1 HARDWARE REQUERIDO POR LINUX EN MAQUINAS CON ARQUITECTURA INTEL 80x86

 Linux requiere como configuracion minimima de hardware una maquina con
 procesador 80386 con 2 Mb de memoria RAM y 40 Mb de espacio libre en disco
 rigido y puede correr tranquilamente sobre esta configuracion. Para utilizar
 el modo grafico (vale la pena, Sistema X Windows ;) necesita al menos 8 Mb
 de RAM y 100 Mb de espacio en disco.

 Linux puede trabajar con los buses ISA, VLB (Vesa Local Bus), EISA y PCI.
 Ademas puede trabajar en sistemas con arquitectura PS/2 MCA (Micro Channel
 Architecture).

 Linux puede correr, ademas, en la familia de PC's portables, desde las 80386
 en adelante, inclusive con su sistema grafico.

 1.2.2 HARDWARE SOPORTADO POR LINUX

 PROCESADORES, UNIDADES DE PUNTO FLOTANTE Y MEMORIAS

 Es totalmente compatible con los microprocesadores 386 SX / DX / SL / DXL /
 SLC, 486 DX / SL / SX2 / DX2 / DX4 de Intel/AMD/Cyrix, Pentium, Pentium MMX,
 Pentium Pro, Pentium II y III de Intel, K5, K6, K6-2 3D de AMD, y todos los
 procesadores de la familia Cyrix.

 Linux posee emulacion de unidad de punto flotante para servir de soporte a
 los procesadores que no tiene coprocesador matematico como lo son los 386 o
 los 486/SX.

 Ademas una caracteristtica muy pontente de Linux es que se provee soporte
 para sistemas con multiples CPU's (SMP).

 Con respecto a las memorias, todas las memerias DRAM, FPM, EDO o SDRAM pueden
 ser utilizadas con Linux.

 CONTROLADORES DE UNIDADES DE DISCO RIGIDO, DISQUETTES, CD-ROM Y UNIDADES DE
 CINTA

 Linux puede trabajar con las controladoras estandar de disco IDE, MFM y RLL.
 Tambien hay soporte para interfaces IDE extendidas (EIDE), con hasta dos
 interfaces IDE y 4 discos y/o unidades de CD-ROM. Linux detectara las
 siguientes interfaces EIDE:

  * CMD-640

  * DTC 2278D

  * FGI/Holtek HT-6560B

  * RZ1000

  * Triton I y II con Bus-Master DMA

 Estas interfaces son las mas utilizadas en las computadoras personales y en
 general Linux no tendra ningun problema en detectarlas.

 Linux funcionara tambien con la interface mas moderna IDE/ATAPI, ya se para
 discos, unidades de CD-ROM, unidades de discos flexible o unidades de cinta.

 Es posible, ademas, utilizar las modernas unidades Zip de Iomega, ya sea por
 el puerto paralelo o SCSI.

 UNIDADES DE CD-ROM (NO IDE) (NO SCSI)

 Es factible (ja de donde salio esa palabra :) utilizar sobre Linux las
 siguientes unidades de CD-ROM: Aztech, Creative Labs (una cagada), Goldstar,
 IBM, Panasonic, Mitsumi, Sanyo, Sony, Teac.

 ULTRA-DMA

 Linux puede trabajar con las interfaces de disco con Ultra-DMA mas conocidas
 del mercado. (Bus-Master, VIA, etc.).

 SCSI

 Linux soporta una gran cantidad de interfaces controladoras SCSI. Entre las
 mas importantes encontramos: Adaptec, BusLogic, DTC, Future Domain, NCR,
 Seagate, UltraStor, Quantum, Iomega y Western Digital.

 ADAPTADORES DE RED

 De forma similar, Linux soporta una amplia variedad de trajetas de red
 Ethernet com lo son: 3Com, AMD, AT&T, Cabletron, DEC, Fujitsu, HP, Intel
 EtherExpress, Novell NE2000/1000, SMC, Western Digital, Zenith.

 Ademas soporta varias tarjetas de red ISDN, ARCNet, Token Ring, FDDI,
 Amateur Radio, PCMCIA, Frame Relay, como otras intefaces (que no utilizan
 tarjetas) SLIP, PPP o PLIP.

 TARJETAS DE SONIDO

 Las tarjetas de sonido mas importantes soportadas por Linux son las
 siguientes: Adlib, Crystal, Ensoniq Soundscape, Gravis Ultrasound, Logitech,
 Media TriX, Media Vision, Microsoft Sound System, OPTi, Sound Blaster (100 %
 compatibles), Turtle Beach y puertos MIDI MPU-401.

 MOUSES

 Los siguientes mouses pueden ser utilizados con Linux:

  * Mouse serie de Microsoft

  * Mouse serial de Mouse Systems

  * Mouse de Logitech serie o de bus

  * Mouse de bus de Microsoft

  * Mouse ATI XL

  * Mouse PS/2

 MODEMS

 Todos los modems internos o externos (conectados a un puerto serie) deben
 funcionar con Linux. Algunos frabricantes han creado lineas de modems que
 solo funcionan con Windows 95, por lo que hay que tener mucho cuidado al
 comprar, porque en Linux no sera posible hacerlos funcionar.

 Todos los modems que funcionan bajo interfaz PCMCIA deben funcionar en Linux.
 En lo que respecta a los Modem/Fax, necesitan software apropiado para
 funcionar, pero hay que asegurarse de que el Modem/Fax cumpla con el estandar
 de Fax Clase 2.0 porque es generalmente verdad que el software de Fax
 disponible para Unix no funciona com Modems/Fax de Clase 1.0

 IMPRESORAS

 Todas las impresoras conectadas a un puerto paralelo funcionan en Linux, pero
 al igual que los modems, algunos fabricantes han lanzado impresoras designadas
 para trabajar solamente con el sistema Windows 95.

 Muchos programas de Linux generan como salida de impresion documentos en
 formato Postscript. En general este formato es entendido solo por impresoras
 Laser y algunas otras impresoras avanzadas. Para solucionar este problema en
 Linux podemos utilizar el programa Gostscript, que es un interprete del
 formato Postscript para utilizar con las impresoras que no tiene el soporte
 para este formato. Ghostscript posee, entre otros, drivers para las
 siguientes impresoras:

  * Impresoras Apple

  * Cannon Bubble-Jet, LBP, LIPS III

  * Impresoras DEC

  * Epson 9 y 24 pines, y serie LQ.

  * Epson Stylus con color.

  * Una amplia variedad de las impresoras Hewlett Packard Deskjet, Paintjet y
    Laserjet
  * IBM, Oki, Okidata, Ricoh, Tektronix y Xerox

 SCANNERS

 Para trabajar con scanners en Linux se debe agregar el paquete SANE (Scanner
 Access Now Easy), que es posible conseguirlo gratituamente en Internet, y
 provee soporte para los siguientes scanners:

  * Adara ImageStar

  * Epson GT6000

  * Fujitsu SCSI-2 Scanners

  * Genius ColorPage, GS-B105G, GeniScan, GS-4000 y ScanMate

  * Varios HP ScanJet

  * Varios Logitech ScanMan

  * Nikon CoolScan

 OTROS DISPOSITIVOS

 Linux puede trabajar con Touch-Screens, Joysticks, Terminales en los puetos
 serie, una gran variedad de trajetas de captura de video, varios sistemas
 de manejo de energia UPS, etc.

 DISPOSITIVOS PLUG & PLAY

 PnP fue inventado por Intel y Microsoft, en parte por eso y en parte por las
 diferencias que existian con los desarrolladores de Linux por la forma en que
 se habia implementado, Linux no daba soporte a los dispositivos PnP. Pero nos
 guste, o no, la mayoria del harware, hoy, es PnP y Linux no tiene otra opcion
 que trabajar efectivamente con el PnP.

 Los Kernels actuales de Linux poseen soporte integrado para PnP. Esto favorece
 a la aceptacion de Linux porque muchas personas se rehusaban a Linux porque
 los dispositivos PnP no funcionaban. Hoy estamos en condiciones de usar
 cualquier dispositivo PnP con Linux, siempre que sea 100% compatible con algun
 dispositivo soportado por Linux.



 CAPITULO 2

 ESTRUCUTURA GENERAL DEL SISTEMA DE ARCHIVOS

 2.1 SISTEMA DE ARCHIVOS

 La parte del sistema operativo que fija como los archivos son estructurados,
 nombrados, accesidos, usados, protegidos e implementados se conoce como
 "Sistema de Archivos".

 Desde el punto de vista del usuario, el aspecto mas importante de un sistema
 de archivos es la estructura que refleja el sistema de archivos, que
 constituye un archivo, como los archivos se nombran y se protegen, que
 operaciones estan permitidas sobre los archivos, etc.

 2.1.1 NOMBRES DE ARCHIVOS

 Las reglas exactas para nombrar archivos, varian de sistema en sistema. En
 el caso de Unix es posible tener nombres de archivos de hasta 255 caracteres.
 Por lo tanto los siguientes nombres son totalmente validos:

  Tony, reporte, README.TXT, ls, cp, Resultados de la primera Fecha - Basket

 Una caracteristica importante a tener en cuenta es que en Unix/Linux cae en
 la categoria de sistemas que distinguen entre letras minusculas y letras
 mayusculas, es decir que es "case-sensitive". Por lo tanto se consideraran
 como archivos distintos los siguientes nombre:

  tony, Tony, TONY, tONY

 Muchos sistemas operativos dividen el nombre de un archivo en dos partes que
 se separan por un punto. La parte que se encuentra despues del punto se
 llama "extension". En MS-DOS, por ejemplo, los nombres de los archivos deben
 formarse con un nombre de 1 a 8 caracteres, con una extension opcional de 1
 a 3 caracteres. En Linux la extension es opcional y puede tener la cantidad
 de caracteres que el usuario quiera. Asimismo es posible definir archivos
 con dos o mas extensiones. Ejemplos:

  README.linux, linux-2.2.5.tar.gz

 En Linux no existe ninguna restriccion en las extensiones de los archivos
 que implique la asociacion del mismo con ciertas operaciones. En MS-DOS, por
 ejemplo, solo es posible ejecutar archivos con las extensiones .BAT, .EXE,
 .COM. En Linux para poder ejecutar un archivo se imponen otro tipo de
 restricciones que seran tratadas mas adelante.

 Sin embargo, algunos programas o utilidades exigiran ciertas extensiones en
 los archivos sobre los cuales se quiera trabajar. Por ejemplo el compilador
 de C de distribucion libre que viene con las distribuciones Linux, llamado
 gcc (GNU C Compiler), insistira en que los archivos fuente tengan extension
 .c al final del nombre del archivo. Hay que tener en cuenta que esto no es
 una restriccion impuesta por el S.O. sino que es el programa el que exige
 este tratamiento.

 2.1.2 ATRIBUTOS DE LOS ARCHIVOS

 Los principales atributos de los archivos en Linux tienen que ver con sus
 permisos de acceso, su propietario, grupo al que pertenece (todos estos
 conceptos se trataran mas adelante), su tama¤o en bloques, y su ultima
 fecha de modificacion.

 En el sistema MS-DOS, los archivos ocultos se identificaban con un atributo
 llamado HIDDEN. En Linux, en cambio, no existe ningun atributo especial para
 determinar cuando un archivo es oculto. La distincion se realiza sobre el
 nombre de archivo. Los nombres de los archivos que comienzan con un punto
 son considerados archivos ocultos. Ejemplos:

  .Xclients, .bash_history, .emacs

 2.1.3 DIRECTORIOS

 Con respecto a los directorios y sus nombres y sus atributos, todo lo dicho
 antes para los archivos se aplica de igual manera para los directorios, ya
 que en Linux son a su vez archivos normales.

 La estructura de directorios de la mayoria de los sistemas es una estructura
 de arbol. Esto quiere decir que se tiene un directorio raiz, el cual a su
 vez puede tener varios subdirectorios y asi sucesivamente.

 Linux Fue desarrollado con el objetivo de ser multiusuario y de su alta
 integracion en redes, por lo que uno de los objetivos fundamentales fuel el
 hacer posible el trabajo en grupos y compartir informacion. Con el modelo de
 directorios en forma de arbol es imposible permitir que se comparta
 informacion entre varios usuarios, por eso Linux fue mas alla y baso su
 sistema de archivos en la estructura de grafo aciclico (FIGURA 2.1) que es
 una generalizacion natural del del esquema de directorios jerarquico.

 2.1.4. ESTRUCTURA DEL SISTEMA DE ARCHIVOS

 En sistemas como MS-DOS las distintas unidades de disco, CD-ROM, disco
 flexible, etc., se manipulan con una estructura de directorios propia. Esto
 quiere decir que cada unidad tiene un directorio raiz y una estructura de
 subdirectorios determinada. Para diferenciar las distintas unidades se les
 asigna una letra a cada una de ellas. Asi tenemos la unidad A, la unidad C,
 etc.

 En Linux, esta estructura definitivamente no es adecuada porque trae muchos
 problemas de mantenimiento. Mas aun, es totalmente inaplicable en los
 sistemas de archivos de red como lo son NFS, SMB, etc. El hecho de fijar a
 cada una de las unidades una letra que debe mantenerse para siempre -o todos
 los programas perderan las refernecias de nombres- es una limitacion muy
 grande en sistem tan flexible como Linux :)

 2.1 SISTEMAS DE ARCHIVOS

                        ________________________
                        | Tony | Juan | README |
                        /-----------\-----------\
                      /              \           \-----\
        ____________/_________       _\_____________    \
        | mail | TODO | prog |       | prog | mail |     @
       /---------/------|----        -/---------\---
      /         /       |           /            \
     /        /      ___|__________/____________   \
    /       /       /   |         /             \    \
   /      /        |   _|________/___________    |     @
  @      @         |   | mod1 | mod2 | exec |    |
                   \_  ---|------|------|----   _/
                     \    |      |      |     _/ <-----_
                      \_  |      |      |   _/          |
                        \-|------|------|--/            Estos directorios
                          |      |      |               estan compartidos por
                          |      |      |               los usuarios Tony y
                          @      @      @               Juan.


 FIGURA 2.1: ESTRUCTURA DE SISTEMA DE ARCHIVOS ACICLICA. EJEMPLO DE UN
             DIRECTORIO COMPARTIDO.

 Para solucionar esto, Linux utiliza el concepto de particion raiz y sistemas
 de archivos montados sobre la particion raiz. Esto significa que todas las
 unidades utilizaran una estructura de directorios comun. Asi no existiran
 varias unidades y una estructura de directorios por unidad, sino que existira
 una unica estructura de directorios y sobre ella se acomodaran las distintas
 unidades, inclusive las que se comparten en redes.

 La particion raiz es llamada "/" y es el directorio principal de la
 estructura. Las unidades, antes de poder ser usadas, deben ser montadas en el
 sistema de archivos. Para ello debe existir un "punto de montaje" donde alojar
 la informacion de la unidad. Un punto de montaje no es mas que un directorio
 cualquiera dentro del sistema de archivos, que debe encontrarse vacio.

                        _______________________
                   /    | mnt | Tony | README |
                        øø/øøøøøø|øøøøøøøøø\øø
                        /         \          \______
                   ___/__         __\____________   \
                   |    |         | prog | mail |    @
                   øøøøøø         øøøøøøøøøøøø\øø
                                                \
                                                  \
                              ____________________  @
                             | mod1 | mod2 | exec |
                              øø|øøøøøø|øøøøøø|øøø
                                |      |      |
                                |      |      |
                                @      @      @

 FIGURA 2.2: EJEMPLO DE MONTAJE DE UNA UNIDAD. ESTADO DEL SISTEMA DE ARCHIVOS
             PREVIO AL MONTAJE.

                        _______________________
                   /    | mnt | Tony | README |
                        øø/øøøøøø|øøøøøøøøø\øø
                        /         \          \______
        ______________/__         __\____________   \
        | part1 | part2 |         | prog | mail |    @
        øøø/øøøøøøøø/øøøø         øøøøøøøøøøøø\øø
         /        /                             \
       /        /                                 \
      @        @              ____________________  @
                             | mod1 | mod2 | exec |
                              øø|øøøøøø|øøøøøø|øøø
                                |      |      |
                                |      |      |
                                @      @      @

 FIGURA 2.3: EJEMPLO DE MONTAJE DE UNA UNIDAD. ESTADO DEL SISTEMA UNA VEZ
             REALIZADO EL MONTAJE.

 Veamos un ejemplo de montaje de una unidad en Linux. El estado del sistema
 de archivos antes de montar la unidad es el que muestra la figura 2.2.
 Supongamos que queremos montar un disquettes que posee dos archivos llamados
 "part1" y "part2" en el punto de montaje dado por el directorio "/mnt". El
 directorio esta vacio, por lo que no hay ningun problema. El estado del
 sistema de archivos despues de realizar el montaje se muestra en la figura
 2.3.

 Una vez que se monta la unidad dentro del sistema de archivos se puede
 utilizar como si fuese cualquier directorio dentro de la estructura. La unica
 diferencia es la forma en la que se accede a los datos, ya que un directorio
 dentro del sistema de archivos puede corresponder a una particion del disco
 rigido, un disquette, un CD-ROM o una unidad de red que se encuentra en otra
 maquina. Afortunadamente, el sistema se ocupara de tratar con el dispositivo
 que corresponda, de la forma adecuada, para obtener y guardar la informacion.
 El tratamiento que Linux aplica a cada directorio del sistema de archivos se
 realiza de forma totalmente transparente para el usuario :)

 Esta forma de tratar las unidades trae, por supuesto, muchas ventajas. La
 belleza de los sistemas de archivos montados, por sobre las unidades
 basadas en letras, recae en la transparencia. Uno puede agregar unidades al
 sistema sin romper las referencias de las aplicaciones existentes.

 En el modelo de las unidades con letras, cada vez que se agregan unidades al
 sistema, cambian las letras de las unidades. Asi la mayoria del software y
 algunos S.O. se confunden cuando esto pasa. Tipicamente se termina teniendo
 que reinstalar los programas cada vez que se mueve algun disco de lugar.
 Este juego se vuelve ridiculo cuando se utilizan unidades de red.

 En Linux los sistemas de archivos de red, estan designados desde un principio
 con el objetivo de la transparencia. Asi se pueden mover archivos y
 aplicaciones de una maquina a otra en la red y ser compartidos ya que sus
 puntos de montaje no tienen porque cambiar.

 Lo que puede resultar incomodo es el hecho de tener que montar las unidades
 antes de usarlas. Esto es verdad, pero solo con las unidades extraibles
 (unidades de discos flexibles, o CD-ROM's), ya que las unidades fijas (discos
 rigidos, unidades de red, etc.) se configuran para que se monten
 automaticamente.

 2.1.5 RUTAS DENTRO DEL SISTEMA DE ARCHIVOS

 Las rutas (PATH) se utilizan para referirse a determinados directorios o
 archivos dentro del sistema de archivos. Ya hablamos del directorio raiz
 del sistema, el cual es llamado "/". Dentro de este se pueden crear otros
 directorios y archivos. Por ejemplo, si creamos un archivo llamado "Come As
 You Are.mp3" en el directorio raiz, entonces para referirnos a el tenderemos
 que especificar la siguiente ruta: /Come As you Are.mp3. Si creamos un
 directorio llamado "home" nos referiremos a el como /home o /home/. Esto es
 posible porque es un directorio.

 Generalizando, podemos encontrar encontrar un direcotorio llamado "linux" que
 se encuentra dentro del directorio "src" que a su vez se encuentra dentro del
 directorio "usr" que es un subdirectorio del directorio raiz. La ruta
 adecuada sera: /usr/src/linux.

 Las rutas no siempre se estructuran de esa manera. Todos los ejemplos dados
 en el parrafo anterior corresponden a "rutas absolutas". Esto quiere decir
 que son rutas completas, ya que marcan el camino desde el directorio raiz
 hasta el archivo o directorio deseado. Tambien es posible utilizar "rutas
 relativas". Las rutas relativas se construyen dependiendo del punto en el
 sistema de archivos donde nos encontramos ya que en cada momento nos
 encontramos en un cierto punto del sistema de archivos (el directorio
 actual o el de trabajo) y podemos cambiar de directorio, desplazandonos en
 la jerarquia. Toda ruta que comience con una barra ("/") es considerada una
 ruta absoluta, toda otra ruta es considerada ruta relativa.
 
                        _______________________
                   /    | mnt | Tony | README |
                        øø/øøøøøø|øøøøøøøøø\øø
                        /         \          \______
                      /           __\____________   \
                     @            | prog | mail |    @
                                  øøøøøøøøøøøø\øø
                                                \
                                                  \
                              ____________________  \
                             | mod1 | mod2 | exec |  _\_______________
                              øø|øøøøøø|øøøøøø|øøø   | mess | attach |
                                |      |      |      øøø|øøøøøøø|øøøøø
                                |      |      |         |       |
                                @      @      @         @       @
                                                         

 FIGURA 2.4: EJEMPLO DE RUTAS RELATIVAS. ARBOL DE DIRECTORIOS

 Como ejemplo de rutas relativas consideremos la estructura del sistema de
 archivos que muestra la figura 2.4, pueden darse las siguientes situaciones:

  * Si nos encontramos en el directorio /, entonces la ruta Tony/mail/attach
    se refiere al archivo attach que se encuentra dentro del directorio mail
    que es un subdirectorio del directorio Tony. Facil :)

  * Si nos en el directorio /Tony/mail entonces las rutas ./attach y attach
    ambas se refieren al mismo archivo de los ejemplos anteriores. Tambien
    Facil :))

  * Si nos encontramos en el directorio Tony/prog, entonces la ruta
     ../mail/attach se refiere al mismo archivo que el ejemplo anterior. Un
     poco mas dificil :|

  * Si el directorio en el que nos encotramos es Tony/prog entonces la ruta
    ../../README se refiere al archivo README que se encuentra en el
    directorio raiza. Muy dificil ;(

 HARD LINKS

 Los "hard links" (links "duros") son links directos al inodo ( no INODORO)
 del archivo y nos permiten tener mas de un archivo apuntando al mismo inodo.
 Desde un punto de vista practico dos archivos con el mismo inodo son el mismo
 archivo. Los cambios realizados sobre un archivo seran reflejados en el otro y
 viceversa. Lo unico que hay que tener en cuenta es que para borrar un archivo
 del sistema de archivos hay que borrar todos los hard links que el mismo
 posea. Por ejemplo, si el archivo doc1.tex es un hard link al archivo
 ejemplo1.tex, al borrar el ultimo no estamos borrando el primero. Para borrar
 definitivamente el archivo hay que borrar tambien el archivo doc1.tex. La
 unica restriccion que poseen los hard links es que solo pueden definirse
 dentro de un sistema de archivos, porque los inodos son unicos internamente a
 un sistema de archivos.

 Los directorios "." y ".." son hard links y estan presentes en todos los
 directorios del sistema de archivos. El primero es un hard link al mismo
 directorio y el segundo apunta al directorio padre. En particular la entrada
 ".." en el directorio "/" apunta a si mismo; es decir que el padre del
 directorio raiz es el mismo.

 LINKS SIMBOLICOS

 Los links simbolicos son otro tipo de links que tambien permiten darles varios
 nombres a un archivo pero no asocian a los archivos por numeros de inodo. Por
 esto los links simbolicos no tiene la restriccion de tener que permanecer al
 mismo sistema de archivos y pueden referenciar archivos entre sistemas de
 archivos. Esto quiere decir que un link simbolico tiene su propio numero de
 inodo pero apunta a otro archivo.

 Funcionalmente, los hard links y los links simbolicos son similares, aunque
 tiene algunas diferencias. Por ejemplo, se pueden crear links simbolicos a
 archivos que no existen, esto no es posible con los hard links.

 2.2 ESTRUCTURA GENERAL DE UN SISTEMA DE ARCHIVOS LINUX

 En un sistema de archivos Linux encontraremos los siguientes directorios
 importantes que forman parte del sistema y tiene funciones particulares:

  /bin  Archivos binarios o ejecutables. Aqui encontraremos los comandos mas
        utilizados. Los comandos que se encuentren en este directorio pueden
        ser ejecutados por todos los usuarios del sistema.

  /dev  Archivos que representan los dispositivos del sistema.

  /etc  Archivos de configuracion y pesonalizacion del sistema. Solo pueden
        ser modificados por el superusuario (ROOT).

  /sbin  Ordenes ejecutables solo por el superusuario.

  /home  Directorio donde se crean los directorios home de los usuarios del
         sistema.

  /lib  Librerias escenciales del sistema. 

  /proc  Es una estructura virtual de archivos utilizada por el kernel para
         mostrar la informacion del sistema y su configuracion. A traves del
         mismo es posible ver la informacion de las interrupciones, puertos
         de entrada/salida, uso del CPU, memoria, particiones, modulos, asi
         como la informacion de cada proceso en particular y de los distintos
         dispositivos instalados en el sistema.

  /tmp  Directorio que se utiliza como almacenamiento de archivos temporales.

  /var  Informacion de la historia del sistema. Se guardan los mensajes que
        los precesos realizan al ejecutarse, informacion de debug, archivos a
        imprimir, mensajes de correo a ser distribuidos, etc.

  /boot  Archivos e informacion necesaria para el arranque del sistema.

  /usr  Programas, herramientas y utilidades instaladas en el sistema como
        extension del S.O.

  /usr/bin  Binarios y ejecutables de los programas agregados al sistema.

  /usr/src  Codigo fuente de los programas.

  /usr/src/linux  Codigo fuente del kernel del sistema.

  /usr/man  Manuales de los comandos del sistema y de los programas agregados.

  /usr/X11  Archivos del sistema de ventanas X Windows.

  /usr/X11/bin  Archivos ejecutables del sistema de ventanas.

  /usr/local  Softaware agregado localmente al S.O. En este directorio se suele
              instalar todo el software que agregamos luego de realizar la
              instalacion.



 CAPITULO 3

 USUARIOS, PERMISOS Y GRUPOS

 El sistema operativo Linux es un sistema multiusuario. Esto quiere decir
 que un numero cualquiera de personas pueden trabajar en el sistema, ya sea
 de forma simultanea o no. Para comenzar a trabajar en el sistema Linux es
 necesario iniciar una sesion, esto quiere decir que el sistema nos preguntara
 el nombre de usuario con el cual queremos iniciar la sesion. Este proceso se
 conoce como LOG IN.

 Para que el sistema se asegure que la persona que intenta inciar una sesion
 corresponde al usuario indicado se asocio una contrase¤a (PASSWORD) con
 cada nombre de usuario. La contrase¤a solamente la debe conocer el usuario
 propietario de la cuenta.

 Como parte del proceso de inicio de sesion se debe ingresar la contrase¤a
 apropiada, la cual sera encriptada por el sistema inmediatamente y chequeada
 contra la base de datos de contrase¤as y gurdada en el sistema. Este proceso
 se conoce como autenticacion del usuario. Si la contrase¤a es cheaqueada
 satisfactoriamente entonces el usuario comienza su sesion en el sistema. De
 otra forma se rechaza la solicitud de comienzo de sesion.

 Para que este esquema de autenticacion funcione, es necesario que exista una
 forma de crear cuentas de usuario y de asociarles sus respectivas
 contrase¤as, y ademas no se debe permitir a cualquier usuario que pueda
 realizar estas tareas. Para solucionar estos y otros problemas de seguridad,
 Linux posee una cuenta predefinida llamada "root". Esta es la cuenta del
 superusuario, y es el unico usuario que esta autorizado a crear cuentas,
 asignarles contrase¤as y eliminarlas si es necesario. Estos no son los unicos
 permisos que posee esta cuenta; en realidad en una sesion iniciada como el
 superusuario, root, es posible realizar todas las operaciones necesarias para
 la administracion del sistema.

 El esquema de autenticacion de usuarios es necesario pero no suficiente. El
 hecho de que Linux  utilice la estructura de un unico sistema de archivos y
 de que sea un sistema multiusuario hacen que sea indispensable un sistema de
 permisos aplicable sobre los usuarios para con los archivos. Imaginemos un
 entorno en el cual no existieran permisos sobre los archivos y existieran
 multiples usuarios. Facilmente un usuario podria leer, modificar e incluso
 borrar archivos de otro usuario, o podrian darse otras situaciones
 indeseables para con la seguridad del sistema. Para evitar esto Linux
 establece un mecanismo de proteccion de archivos que funciona mediante
 permisos y grupos.

 Anteriormente, cuando hablamos de los atributos de un archivo, mencionamos
 que un archivo tiene asociado un usuario y un grupo. Estos atributos
 establecen quien es el usuario due¤o del archivo y a que grupo de usuarios
 pertenece. Los grupos son conjuntos de usuarios que tambien son definidos
 por el superusuario como parte de la administracion del sistema y sirven para
 agrupar a varios usuarios con caracteristicas de acceso al sistema similares.
 El concepto de grupos de usuario facilita enormemente la tarea de administrar
 los permisos en sistemas con gran cantidad de usuarios.

 3.1 PERMISOS DE ACCESO

 Ademas de los atributos de usuario y grupo, un archivo tiene asociados
 "permisos de acceso" que determinan las operaciones que son permitidas sobre
 el mismo por parte de cada usuario. Los permisos de un archivo se dividen en
 tres partes:

  * DUE¥O: El usuario que creo el archivo es el due¤o del mismo. El due¤o es
           determinado por el atributo del archivo que especifica quien es el
           due¤o.

  * GRUPO: El conjunto de usuarios que comparten el archivo y necesitan
           permisos de acceso similares. El grupo sobre el cual recaen estos
           permisos es el grupo al cual pertenecen el archivo como lo
           determina el atributo de grupo.

  * OTROS (Universo): El universo se constituye de todos los demas usuarios
                      que no son ni due¤os del archivo ni pertenecen al
                      grupo del archivo.

  Dentro de cada categoria, los permisos se dividen en tres grupos: leer,
  ecribir y ejecutar.

  PERMISO DE LECTURA: Deja a un usuario ver el contenido de un archivo o, en
                      el caso de los directorios poder listar su contenido.

  PERMISO DE ESCRITURA: Permite escribir en los archivos o modificar su
                        contenido. En el caso de los directorios permite
                        crear nuevos archivos o borrar archivos del
                        directorio.

  PERMISO DE EJECUCION: Deja que el usuario pueda ejecutar el archivo, ya sea
                        como un programa o como un script de comandos. El
                        permiso de ejecucion sobre un directorio nos permite
                        cambiar el directorio de trabajo.

 Este mecanismo de permisos nos garantiza seguridad y simultaneamente nos
 permite compartir archivos con grupos de usuarios. Pero para que este
 esquema funcione adecuadamente, la pertenencia a los grupos debe ser
 controlada rigidamente por el adminsitrador del sistema.

 Los permisos asociados con un archivo dependen tambien de los permisos que
 tenga asignado el directorio donde se encuentra el archivo. Por ejeplo, si
 un usuario tiene permisos de lectura y escritura sobre un archivo pero no
 tiene permiso de lectura ni de ejecucion sobre el directorio en el cual se
 encuentra el archivo, entonces no podra leer ni escribir el archivo.
 Generalizando, para poder acceder a un archivo es necesario tener permiso de
 ejecucion en todos los directorios que forman parte de la ruta del archivo,
 ademas del permiso adecuado sobre el archivo.

 3.2 DIRECTORIO "HOME" Y PERMISOS PREDEFINIDOS

 Cuando el administrador del sistema crea una cuenta, crea ademas un
 directorio, el cual sera propiedad del usuario que solicito la cuenta. Este
 directorio es llamado "directorio home" y constituye el lugar en el sistema
 de archivos donde el usuario puede guardar sus archivos. El usuario tiene un
 control total sobre los permisos de su directorio home. El acceso del usuario
 a otros directorios estara regido por los permisos correspondientes. Cuando
 un usuario inicia una sesion en el sistema, su directorio de trabajo es su
 directorio home.

 Al crear un nuevo archivo o directorio, el sistema asigna una combinacion de
 permisos predeterminada. Los permisos predefinidos para los archivo son: de
 lectura y escritura para el due¤o y de lectura y ejecucion para el universo.
 Para los directorios son: de lectura, escritura y ejecucion para el due¤o y
 de lectura y ejecucion para el grupo y para el universo (otros usuarios).

 En cualquier momento, el usuario que es due¤o del archivo o directorio puede
 cambiar sus permisos para gestar la combinacion que desee.



 CAPITULO 4

 DISPOSITIVOS DE ENTRADA/SALIDA

 4.1 CONCEPTOS FUNDAMENTALES

 Los dispositivos de entrada/salida utilizados en las computadoras pueden ser
 divididos, esencialmente, en dos categorias: dispositivos de bloques y
 dispositivos de caracter.

 Un dispositivo de bloque se caracteriza por guardar la informacion en bloques
 de tama¤o fijo, cada uno con su direccion. Los tama¤os de bloques mas comunes
 se encuentran en el rango de 512 bytes a 32768 bytes (32 Kb). La propiedad
 esencial de los dispositivos de bloque es que es posible leer o escribir cada
 bloque independientemente de todos los demas. Los "discos" son los
 dispositivos de bloque mas comunes.

 El otro tipo de dispositivos de entrada/salida es el dispositivo de caracter.
 Un dispositivo de caracter envia o acepta secuencias de carateres sin
 relacion a una estructura de bloque. No tiene direccionamiento y por lo tanto
 no tiene ninguna estructura mecanica interna para realizar posicionamientos.
 Los siguientes dispositivos pueden ser vistos como dispositivos de carater:
 impresoras, ratones, interfaces de red, etc.

 Este esquema de clasificacion no es perfecto. Algunos dispositivos son
 dificiles de clasificar en estas categorias. Sin embargo, para fines practicos
 esta clasificacion nos sera suficiente.

 A continuacion se describen conceptos esenciales para el tratamiento y
 configuracion de los dispositivos de entrada/salida. Estos conceptos son
 importantes a la hora de instalar cualquier dispositivo sobre Linux y
 determinan el exito o el fracaso de la instalacion y el correcto
 funcionamiento del dispositivo.

 4.1.1 PUERTOS DE ENTRADA/SALIDA

 Asi como el sistema accede a memoria, tanto para lectura como escritura, debe
 poder acceder a los dispositivos de entrada/salida. En las maquinas basadas en
 las arquitecturas Intel 80x86 existe un espacio de direccionado para la
 memoria y otro separado para los dispositivos. Este esquema es conocido como
 espaciado separado de direcciones de entrada/salida o espacio de entrada/
 salida.

 Los puertos de entrada/salida son direcciones mediante las cuales el
 procesador se comunica con los dispositivos, ya sea leyendo datos o
 escribiendolos. Un dispositivo puede tener asignadas una o mas direcciones
 dentro del espacio, de acuerdo a cuantas necesite.

 4.1.2 INTERRUPCIONES E IRQ'S

 La velocidad con la que los dispositivos trabajan es, en general, ordenes
 de magnitud mas lenta que la velocidad de proceso de la unidad central de
 procesamiento (CPU). Cuando el CPU necesita comunicarse con un dispositivo,
 inicia la operacion y, en vez de esperar a que el dispositivo termine, sique
 realizando tareas, aprovechando el tiempo. Asi el dispositivo debe poder
 comunicarle al CPU que la operacion de entrada/salida finalizo o que necesita
 algun tipo de informacion para continuar. Aqui es donde entran en juego las
 interrupciones.

 Una interrupcion es una se¤al electronica que se emite desde un dispositivo
 hacia el CPU para comunicarle informacion que permite controlarlo. Para
 emitor las interrupciones existen lineas de pedido de interrupcion (Interrupt
 ReQuest Lines) donde cada dispositivo situa los pedidos de interrupcion.

 Las arquitecturas Intel 80x86 proveen 15 lineas de interrupcion para los
 dispositivos de entrada/salida. Cada dispositivo debe utilizar una y solo
 una de estas lineas, porque sino existen altos riesgos de conflictos en la
 atencion de las interrupciones.

  NOTA: Una caracteristica especial de la arquitectura de las IBM PC's es que
        algunos dispositivos trabajan con puertos de entrada salida e
        interrupciones prefijadas. Por ejemplo: el primer puerto serie,
        conocido como COM1, trabaja en el puerto 0x3f8. Otro ejeplo es la
        unidad de discos flexibles que trabaja sobre la linea de pedido de
        interrupcion numero 6.

 4.1.3 ACCESOS DIRECTOS A MEMORIA (DMA)

 Hay veces que los controladores de los dispositivos necesitan leer o escribir
 grandes cantidades de datos desde o hacia la memoria del sistema. En estos
 casos se utilzan los accesos directos a memoria (Direct Memory Access). Estos
 sirven para permitir que los dispositivos accedan directamente a memoria,
 pero esto se realiza bajo estricto control del CPU.

 4.2 TRATAMIENTO DE LOS DISPOSITIVOS EN LINUX

 En los S.O. de la famila UNIX todos los dispositivos de entrada/salida son
 tratados como archivos que forman parte del sistema de archivos. En general
 estos archivos se encuentran en el directorio /dev, pero esto puede depender
 del sistema.

 Estos archivos, llamados "archivos de dispositivos", son creados por el
 nucleo y son indespensables para el funcionamiento del sistema. Uno de los
 principales objetivos es manejar los dispositivos como archivos es que se
 abstrae y simplifica el tratamiento de los mismos para el usuario. Los
 archivos especiales de dispositivos se manejan con las mismas operaciones
 que se realizan sobre los archivos comunes, pero al tratarse de un archivo de
 dispositivo el sistema se encarga de realizar las tareas necesarias para
 comunicarse con el dispositivo. Esto se realiza por medio de un "manejador de
 dispositivo" que forma parte del nucleo y conoce los detalles de como tratar
 con el dispositivo en cuestion.

 Otra de las ventajas de este esquema de tratamiento de dispositivos es que 
 se pueden fijar permisos sobre los dispositivos utilizando el esquema de
 usuarios, grupos y permisos ya analizado. De esta forma, podremos hacer que
 un grupo de usuarios pueda usar una impresora, que otro grupo pueda usar una
 red, o inclusive denegar el acceso a un disco a un usuario determinado, etc.

 Los archivos de dispositivos tienen un atributo especial que determina si
 son archivos de dispositivos de bloque o de caracter. Esto es necesario
 para que el sistema sepa como tratar a cada uno.

 Como es posible que existan varios dispositivos de entrada/salida de las
 mismas caracteristicas (podemos tener varios discos, varias placa de red,
 etc.) se crean grupos de usuarios para cada clase de dispositivo y hace
 que los archivos pertenezcan a esos grupos. Por ejemplo: todos los
 dispositivos de disco del sistema son archivos que pertenecen al grupo
 "disk, etc."

 4.2.1 ARCHIVOS DE LOS DISPOSITIVOS MAS COMUNES

  * DISCOS MFM, RLL O IDE  (EIDE): La interfaz IDE en Linux soporta hasta 6
    interfases con soporte para dos discos cada una. Se denominan primaria,
    secundaria, terciaria, etc. y a los discos se los denomina maestro y
    esclavo. Tenemos un maestro y un sclavo por cada interfaz. Sus nombres
    son:

       |øøøøøøøøøøøøøøøøøøøøøøø|øøøøøøøøøøøøøøøøøøøøøøøø|
       | Interfaz              | Archivo de dispositivo |
       |-----------------------|------------------------|
       | Primaria - Maestro    |      /dev/hda          |
       | Primaria - Esclavo    |      /dev/hdb          |
       | Secundaria - Maestro  |      /dev/hdc          |
       | Secundaria - Esclavo  |      /dev/hdd          |
       | ...                   |      ...               |
       |_______________________|________________________|

        NOTA: Si uno de los lugares en las interfases es ocupado por un
              CD-ROM, se le asigna un archivo correspondiente a la interfaz,
              pero ademas se crea un link simbolico llamado /dev/cdrom que
              apunta a la interfaz que corresponda al CD-ROM.

  * DISCOS SCSI: Linux tiene soporte para 128 discos SCSI y sus archivos son:

         |øøøøøøøøøøøøøøøøø|øøøøøøøøøøøøøøøøøøøøøøøø|
         | Numero de disco | Archivo de dispositivo |
         |-----------------|------------------------|
         | Disco SCSI 1    |     /dev/sda           |
         | Disco SCSI 2    |     /dev/sdb           |
         | ...             |     ...                |
         | Disco SCSI 26   |     /dev/sdz           |
         |-----------------|------------------------|
         | Disco SCSI 27   |     /dev/sdaa          |
         |-----------------|------------------------|
         | Disco SCSI 28   |     /dev/sdab          |
         |-----------------|------------------------|
         | ...             |     ...                |
         | Disco SCSI 128  |     /dev/sddx          |
         |_________________|________________________|

  * PARTICIONES: Cada disco puede estar particionado. Para referirnos a las
    particiones solo agregamos el numero de la particion correspondiente, al
    nombre del archivo que representa el disco. Los nombres se forman de la
    siguiente forma: /dev/hd?n y /dev/sd?n reemplazando por "?" la letra del
    disco adecuado y por "n" el numero de particion correspondiente.

        NOTA: En particiones del estilo MS-DOS (tipicamente usadas por Linux
        en sistemas i386) los numeros del 1 al 4 representan particiones
        primarias y del 5 en adelante particiones logicas.

  * UNIDADES DE DISQUETTES: Se soportan dos controladoras de unidades de
    disquettes con hasta 4 unidades por controladora.

            |øøøøøøøøøøøøøøøøøøøøøøøøøøøø|øøøøøøøøøøøøøøøøøøøøøøøø|
            | Controladora - Disquettera | Archivo de dispositivo |
            |----------------------------|------------------------|
            | Controladora 1 - Unidad 1  |         /dev/fd0       |
            |       "        -   "    2  |         /dev/fd1       |
            |       "        -   "    3  |         /dev/fd2       |
            |       "        -   "    4  |         /dev/fd3       |
            |       "      2     "    1  |         /dev/fd4       |
            |       "      "     "    2  |         /dev/fd5       |
            |       "      "     "    3  |         /dev/fd6       |
            |       "      "     "    4  |         /dev/fd7       |
            |____________________________|________________________|

  * CONSOLAS VIRTUALES: Son 64 consolas y se nombran /dev/ttyn donde "n" es
    el numero de la consola virtual correspondiente.

  * PUERTOS SERIE, MODEMS Y MOUSES: Se tiene soporte para 64 puertos serie y
    se nombran como /dev/ttySn donde, de nuevo, "n" es el numero del puerto.

        NOTA: En sistemas basados en MS-DOS los puertos  serie se nombran
        COM1, COM2, etc. La correspondencia de esos pueros con los de Linux
        es la siguiente:
             _______________________________
             |   MS-DOS    |   Linux        |
             |-------------|----------------|
             |  COM1       |   /dev/ttyS0   |
             |  COM2       |   /dev/ttyS1   |
             |  COM3       |   /dev/ttyS2   |
             |  COM4       |   /dev/ttyS3   |
             |_____________|________________|
                            
    Los dispositivos de puertos serie pueden ser utilizados, entre otros
    dispositivos, por puertos serie fisicos o por modems. Si el modem es
    externo, entonces se conecta a uno de los puertos serie y se crea un
    link simbolico /dev/modem que apunte al puerto serie fisico
    correspondiente. Si el modem es interno entonces utilizara uno de los
    puertos que se encuentren disponibles (que no esten utilizados por
    puertos serie fisicos) y el link simbolico debera apuntar al puerto
    "logico" que se utilice.

    Si se utiliza un mouse serial entonces se crea un link simbolico /dev/mouse
    que apunta al puerto serie en cual esta conectado el mouse. Si no se
    utiliza un mouse serial entonces se pueden utilizar los siguientes
    dispositivos, dependiendo del tipo del mouse:

            |øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø|øøøøøøøøøøøøøøøøøøøøøøøø|
            | Mouse                         | Archivo de dispositivo |
            |-------------------------------|------------------------|
            | Mouse PS/2                    |   /dev/psaux           |
            | Mouse Logitech de bus         |   /dev/logibm          |
            | Microsoft InPort mouse de bus |   /dev/inportbm        |
            | Ati XL mouse de bus           |   /dev/atibm           |
            | Mouse Atari                   |   /dev/atarimouse      |
            | Mouse Sun                     |   /dev/sunmouse        |
            | Mouse Amiga                   |   /dev/amigamouse      |
            |_______________________________|________________________|

  * PUERTOS PARALELOS: Pueden ser 3 y sus nombres son los siguientes:

          |øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø|øøøøøøøøøøøøøøøøøøøøøøøø|
          | Puerto paralelo                | Archivo de dispositivo |
          |--------------------------------|------------------------|
          | Primer puerto paralelo (0x3BC) |       /dev/lp0         |
          |    "     "       "     (0x378) |       /dev/lp1         |
          |    "     "       "     (0x278) |       /dev/lp2         |
          |________________________________|________________________|

  * TECLADO: El teclado se maneja con el dispositivo /dev/kbd

  * PLACAS DE SONIDO: Los dispositivos relacionados con las placas de sonido
    son los siguientes:

    |øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø|øøøøøøøøøøøøøøøøøøøøøøøø|
    | Dispositivo                                   | Archivo de dispositivo |
    |-----------------------------------------------|------------------------|
    | Control de mezcladora                         |     /dev/mixer         |
    | Secuenciador de audio                         |     /dev/sequencer     |
    | Puertos midi                                  |     /dev/midinn4       |
    | Audio digital                                 |     /dev/dsp5          |
    | Audio digital compatible con formato SUN      |     /dev/audio         |
    | Informacion del estado de la placa de sonidos |     /dev/sndstat       |
    |_______________________________________________|________________________|

  * JOYSTICK: Los dispositivos de joystick se nombran /dev/jsn, para los
    joysticks analogicos y /dev/djsn para los joysticks digitales; "n" es el
    numero de joystick.

  * INTERFASES DE RED: Las interfases de red mas utilizadas son las Punto a
    Punto (PPP) o las interfases Ethernet. Los dispositivos para las mismas
    son: /dev/pppn para las interfases PPP y /dev/ethn para las interfases
    Ethernet; "n" es el numero de interfase.

  * CD-ROM'S ESPECIALES:

        |øøøøøøøøøøøøøøøøøøøøøøøø|øøøøøøøøøøøøøøøøøøøøøøøøø|
        | CD-ROM                 | Archivo de dispositivo  |
        |------------------------|-------------------------|
        | Sony CDU-31A/CDU-33A   |   /dev/sonycd           |
        | Sony CDU-535           |   /dev/cdu535           |
        | Goldstar               |   /dev/gscd             |
        | Optics                 |   /dev/optcd            |
        | Sanyo                  |   /dev/sjcd             |
        | Hitachi                |   /dev/hitcd            |
        | Mitsumi                |   /dev/mitcd            |
        | Panasonic/SoundBlaster |   /dev/sbpcdn6          |
        | Aztech                 |   /dev/aztcd            |
        |________________________|_________________________|
        



 CAPITULO 5

 PROGRAMAS Y PROCESOS

 El concepto central mas importante en cualquier sistema multitarea es el de
 proceso. Informalmente, un proceso es una abstraccion de un programa en
 ejecucion. Un programa es una secuencia de instrucciones que la computadora
 ejecuta con el objetivo de obtener un cierto resultado; es lo que crea el
 programador. Cuando un programa no esta siendo ejecutado se encuentra en un
 archivo del disco. Para poder ejecutar el programa, una copia de las
 instrucciones debe ser cargada en memoria. Cuando un programa se esta
 ejecutando, se lo llama proceso. Es muy importante conocer las
 caracteristicas de los procesos para comprender el funcionamiento de Linux y
 aprovechar la potencia de su modelo multiprogramado.

 Todas las computadoras modernas pueden hacer varias cosas al mismo tiempo
 para aprovechar los recursos mas eficientemente. Por ejemplo: se puede estar
 ejecutando un programa mientras se leen datos de un disco o se imprime un
 documento. En un sistema multiprogramado, ademas, se pueden estar ejecutando
 varios procesos al mismo tiempo (posiblemente de distintos usuarios). Esto
 es posible gracias al concepto de multiprogramacion. En un sistema
 multiprogramado, cada proceso obtiene una tajada del tiempo del procesador.
 Estrictamente hablando, en cada instante de tiempo el procesador ejecuta un
 solo proceso, pero en un periodo determinado, digamos 1 segundo, puede
 trabajar sobre muchos procesos dando a los usuarios la impresion de la
 existencia de paralelismo. En realidad, como resultado de lo que realiza
 internamente obtenemos un "pseudo-paralelismo" que hace que los procesos
 se puedan ejecutar concurrentemente compartiendo el tiempo del procesador.
 Asi el S.O. hace que la operacion de la computadora resulte mas productiva.

 Linux es un sistema multitarea-multiusuario, lo que quiere decir que cada
 usuario puede estar ejecutando varios procesos al mismo tiempo. El S.O.,
 atendera las necesidades de todos los usuarios de una manera justa,
 ejecutando concurrentemente todos los procesos.

 Cada vez que un usuario ejecuta un programa se inicia un proceso en el
 sistema. Cada proceso tiene un PID (Process ID) unico, que es el numero que
 sirve para identificarlo. Alguno se preguntara por que no es el nombre del
 programa el que identifica al proceso ?. Bueno, esto trae muchas desventajas,
 ya que por ejemplo, pueden haber varios procesos ejecutandose como parte del
 mismo programa, y seria imposible identificarlos. Sin embargo, cada proceso
 guarda como atributo el comando que se ingreso para iniciarlo.

 5.1 EJECUCION EN PRIMER PLANO Y EN "BACKGROUND"

 Un proceso puede ejecutarse en primer plano o en "background". Solo puede
 existir un proceso ejecutandose en primer plano y es el proceso con el cual
 podemos interactuar. La entrada del proceso se toma del teclado y la salida
 se muestra por pantalla. Los procesos que se ejecutan en "background" no
 reciben entradas del teclado ni de ninguna terminal, y en general se ejecutan
 "silenciosamente" sin necesidad de interaccion.

 Todos los S.O. proveen algun tipo de mecanismo para ejecutar procesos en
 primer plano, pero, sin embargo no todos proveen la posibilidad de ejecutar
 procesos en "background". La importancia de los procesos en "background" se
 puede analizar considerando sus varias utilidades. Por ejemplo: existen
 procesos que tardan mucho tiempo para completarse y no requieren la 
 interaccion del usuario. Compilar programas o comprimir un archivo muy grande
 son ejemplos de este tipo de tareas. Estas conviene realizarlas en
 "background", ya que mientras varios procesos se estan ejecutando en
 "background" estamos libres para ejecutar cualquier otro tipo de tarea.

 Los procesos pueden estar en varios estados, los cuales pueden ser:

  * Ejecutando: El proceso ejecuta ya sea en primer plano o en "background"

  * Suspendido: Un proceso suspendido es un proceso que esta temporariamente
    detenido. Luego de suspender un proceso es posible reanudarlo ya sea en
    primer plano o en "background". De esta manera el proceso continua en el
    punto en el cual habia sido suspendido.

  * Interrumpido: A diferencia de un proceso suspendido, un proceso es
    interrumpido por algun evento y no puede ser reanudado. Por lo que es
    inmediatamente terminado.

 5.2 DEMONIOS

 Los demonios son procesos que se ejecutan en "background". Se los puede
 pensar como procesos que se mantiene "dormidos" a la espera de eventos que
 los despierten para llevar a cabo una tarea determinada. Cuando un evento
 despierta un demonio, este se ocupa de ejecutar lo pertinente y cuando
 completa el tratamiento del evento vuelve a dormirse y asi sucesivamente.
 Los tipos de eventos que cada demonio espera y las tareas que realiza en
 respuesta a los mismos dependen de la naturaleza del demonio en cuestion.
 Las tareas mas comunes para las que se utilizan demonios son: demonios que
 controlan dispositivos (impresoras(lpd), adaptadores de red (pppd), etc.),
 control de los protocolos de red (tcp/ip (tcpd), etc.), agentes de
 transferencia de correo electronico (sendmail), etc.



 CAPITULO 6

 LA INTERACCION CON EL SISTEMA. SHELL Y COMANDOS

 6.1 LA SHELL

 Todo S.O. debe proveer un mecanismo para que el/los usuarios puedan
 comunicarle lo que quieren realizar y para poder interactuar con el. Linux
 posee una interfase de comunicacion llamada "shell" y es el medio mediante
 el cual el usuario puede comunicarle comandos al sistema y recibir la
 salida de los procesos con los que interactua.

 Basicamente, la shell es un proceso mas que obviamente se ejecuta en primer
 plano, ya que sino seria imposible interactuar con el mismo. Su
 funcionamiento se limita a recibir comandos del usuario, interpretarlos y
 ejecutar las tareas necesarias en respuesta a los mismos. El nombre tecnico
 de la shell puede ser "interprete de comandos". Su funcion se puede comparar
 a la del programa "comand.com" en MS-DOS que esencialmente realiza las mismas
 tareas.

 En los sistemas UNIX cada usuario puede elegir que shell quiere utilizar para
 comunicarse con el sistema. Linux tiene varias shells las cuales pueden ser
 elegidas por el usuario. Inclusive es posible que el usuario programe y
 utilice su propia shell si asi lo desea. Las shells que Linux provee son:

  * sh: Shell de Bourne. Es la shell mas utilizada en los sistemas UNIX.

  * csh: Shell de C. Es la shell preferida por los programadores. Es
         compatible con la shell de Bourne.

  * ash: Shell de Ash. Es una version especial reducida. Se utiliza cuando
         existe muy poca memoria disponible.

  * ksh - pdksh: Shell de Korn. Extension de la shell de Bourne.

  * bash: Bourne Again Shell. Es la shell de la FSF (Free Software Fundation).
          Amplia las capacidades de la shell de Bourne y es utilizada por
          Linux como shell predeterminada.

  * zsh: Z Shell. Compatible con la shell de Bourne.

 6.1.1 FUNCIONAMIENTO DE LA SHELL

 La shell es iniciada inmediatamente cuando un periodo de inicio de sesion es
 autenticado exitosamente. El sistema recuerda cual es la shell que utiliza
 cada usuario y carga la correspondiente al usuario que inicio la sesion.
 Desde este momento, la shell muestra un identificador llamado "prompt" que
 significa que esta esperando que el usuario ingrese una orden.

 Una vez que se visualiza el prompt, el usuario puede ingresar cualquier
 orden, ya sea para que se ejecute en primer plano o en "background". Si el
 pedido de ejecucion dado por el comando ingresado especifica que el proceso
 se debe ejecutar en "background", el proceso se inicia y se comienza a
 ejecutar en "background", por lo que el shell inmediatamente vuelve a mostrar
 el prompt y al estado de espera de mas ordenes. Asi es posible seguir
 ejecutando ordenes. Si el proceso se debia ejecutar en primer plano, la
 shell no retorna el prompt hasta que el proceso ejecutado se termine. Por
 lo tanto debemos esperar a que termine el proceso para poder iniciar otro.

 6.2 COMANDOS

    NOTA: Desde esta seccion en adelante todo lo referente a la shell y sus
    comandos estara basado en la shell bash (Bourne Again Shell) que es la
    shell predefinida en Linux :)

 El uso interactivo tipico de la shell se basa en ingresar comandos simples,
 comandos con calificadores, comandos con facilidades de generacion de
 nombres de archivos, redireccion de entrada-salida, y comandos combinados
 mediante el uso de "ca¤erias". Estas tecnicas son poderosas y extremadamente
 utiles, pero son solo una parte de las capacidades de la shell.

 La shell es, ademas de interprete interactivo de comandos, un interprete de
 un lenguaje de programacion de comandos llamado "El lenguaje de programacion
 de la shell". Este lenguaje nos permite realizar nos permite realizar
 "scripts" que sera posible ejecutar como un programa binario mas, con la
 diferencia que lo interpreta la shell linea por linea y ejecuta los comandos
 correspondientes. Mas adelante nos ocuparemos de analizar este lenguaje de
 programacion en profundidad, ya que es una de las caracteristicas mas
 poderosas de la shell y nos sirve para automatizar muchas de las tareas que
 tenemos que realizar en el sistema y nos ayuda a ahorrar la cantidad de
 comandos que tenemos que tipear.

 6.2.1 COMANDOS SIMPLES

 Un comando simple es una secuencia de (una o mas) palabras separadas por
 espacios o tabuladores. La primer palabra de la secuencia es el nombre del
 comando. Las palabras subsiguientes son los argumentos del comando. Los
 comandos mas simples son de una sola palabra.

 Los comandos mas comunes pueden ser: ls para listar el contenido de un
 directorio, ps para ver los procesos que se encuentran creados en el
 sistema, reboot para reiniciar el sistema, etc.

 ARGUMENTOS

 Los comandos, en su forma mas simple, se ejecutan simplemente poniendo el
 nombre del archivo correspondiente. Sin embrago, existen comandos que
 necesitan argumentos para trabajar. Un ejemplo de esto puede ser el
 comando cp que sirve para copiar archivos. Este comando necesita dos
 argumentos obligatorios, el/los archivo fuente y el detino de la copia.
 Por ejemplo:

  ==> cp /home/juan/cuotas.tex /home/tony/

 Los argumentos se utilizan para pasar informacion adicional a los programas
 que ejecutamos. En algunos casos son opcionales, en otros obligatorios y
 puede ser que la cantidad de argumentos de algunos comandos pueda ser
 variable. La gran mayoria de las veces los argumentos seran nombres de
 archivos o de directorios, pero esto es dependiente de cada programa.

 El nombre del comando y sus argumentos deben ser separados por uno o mas
 espacios, sino la shell nos informara del error con un mensaje. Ejemplo:

  ==> ls/bin

  bash: ls/bin:  No such file or directory

 Otros argumentos  son los "modificadores" que son formas de pasar opciones
 a los programas y seran tratados a continuacion.

 MODIFICADORES

 Los comandos, usualmente, sirven para realizar una funcion pero pueden
 aceptar varias opciones que especifiquen como se debe realizar esta tarea.
 Las opciones que cada comando acepta y la sintaxis con la que se especifica
 la opcion dependen exclusivamente del comando en cuestion. Aunque en general
 se puede hablar  de "modificadores" que son la forma general de ingresar las
 opciones a los comandos. Consideremos el siguiente comando:

  ==> ls -a

 Este comando listara el contenido del directorio actual, pero mostrara
 ademas los que comienzan con ".", ya que estos son ocultos y al ejecutar ls
 no son mostrados. Este comportamiento es especificado por la opcion de
 mostrar los archivos ocultos que es seleccionada con el modificador -a (all).

    NOTA: Un modificador muy util es -h que sirve para especificarle a un
    comando que nos muestre su sintaxis y las opciones que soporta. Esto
    sirve como referencia del funcionamiento del comando. Este modificador
    se puede usar con la mayoria de los comandos de Linux. Algunos comandos
    soportan --help o -help para la misma funcion.

 6.2.2 SEPARADOR DE COMANDOS

 Para ingresar varios comandos en una sola linea es necesario separarlos por
 ";". Por ejemplo:

  ==> date;df -h

 La salida de este comando sera la siguiente:

  Thu Apr 15 17:29:15 ART 1999
  Filesystem           Size  Used  Avail  Capacity Mounted on
  /dev/hda3            1.6G  613M   963M     39%   /
  /dev/hdc1            2.0G  1.9G   138M     93%   /akenaton
  /dev/hda2            298M  238M    60M     80%   /games
  /dev/hda1            2.0G  1.5G   546M     73%   /nt

 La primera linea de la salida es generada por el comando date y muestra la
 hora y el dia actual en el sistema. La tabla que es mostrada a continuacion
 es generada por el comando df y muestra las capacidades, tama¤os utilizados
 y disponibles, y puntos de montaje de los distintos sistemas de arhcivos que
 se encuentran montados. Notemos que las unidades se muestran en distintos
 formatos de acuerdo al valor que tenga cada campo. Esto es causado por la
 opcion -h que indica al comando que muestre los valores con unidades
 significativas y no en numero de bloques.

 6.3 LA ENTRADA ESTANDAR Y LA SALIDA ESTANDAR

 Los programas basados en el modelo de entrada/salida por teletipo son
 aquellos en los que su salida consiste en lineas de texto ASCII. Estos
 programas ofrecen solo una primitiva interfase con el usuario basada en linea
 de comandos. Pero justamente por esto, y por la funcionalidad que provee la
 shell, es posible interconectar varios programas que realizan tareas simples
 para realizar tareas mas complejas. Todos los comandos de Linux y la mayoria
 de sus utilidades se encuentran basados en este modelo. Por esto es
 importante entender el funcionamiento e interaccion de los programas, la shell
 y la entrada/salida para sacar provecho a estas facilidades.

 Cuando un programa, del modelo de teletipo, produce una salida sobre una
 terminal el programa, en general, esta realizando operaciones de salida a lo
 que se denomina salida estandar (stdout). Asimismo, cuando tipeamos algo en
 el teclado de la terminal, un programa lee los caracteres de lo que se llama
 entrada estandar (stdin). Para comunicar errores y mensajes de diagnostico,
 existe una conexion de salida separada llamada stderr.

 La shell, por ejemplo, es un programa que lee caracteres de stdin e
 interpreta los mismos como comandos, argumentos, etc. El comando ls envia
 su salida (el contenido del directorio de trabajo) a stdout y luego se
 visualiza en nuestra pantalla. Este funcionamiento es el predefinido, ya que
 la entrada estandar y la salida estandar se encuentran, normalmente,
 asociadas a la terminal de la computadora, stdin el teclado y stdout a la
 pantalla.

 La shell, sin embargo, nos permite reasignar o redireccionar las conexiones
 de entrada, salida o la de diagnostico de errores. Esta es una de las
 caracteristicas mas poderosas de Linux :)

 6.3.1 REDIRECCIONANDO LA SALIDA

 Supongamos que ejecutamos el comando ps (process status), el cual nos reporta
 del estado de los procesos, que nosotros iniciamos, que se estan ejecutando
 en el sistema. La figura 6.1a nos muestra la salida generada por una
 ejecucion del comando ps. Asi visualizamos la salida en nuestra pantalla.

 Si nos interesa guardar la salida del comando ps, por ejemplo para analizarla
 posteriormente, podemos hacer uso de la redireccion de la salida que nos
 brinda la shell. Le indicamos a la shell que queremos redireccionar la
 salida con el simbolo ">". Entonces, en nuestro ejemplo, debermos ejecutar
 el comando como indica la figura 6.1b. En la misma, observamos que el
 comando termina de ejecutarse sin realizar ninguna salida en la pantalla,
 pues la salida del comando se envio al archivo "procesos" y fue guardada en
 el mismo. Luego mostramos el contenido del archivo procesos, con el comando
 cat, y visualizamos la salida que el comando ps realizo al ejecutarse.

      NOTA: No es necesario que el archivo sobre el cual escribimos al
      redireccionar la salida exista antes de ejecutar el comando ya que la
      shell crea el archivo, si es necesario.

 REDIRECCION NO-DESTRUCTIVA DE LA SALIDA

 Al redireccionar la salida de un comando a un archivo se sobreescriben
 completamente los contenidos del mismo. Hay ocasiones en las que no queremos
 perder la informacion almacenada en un archivo, sino agregarle datos al final
 del mismo. En el ejemplo de la figura 6.1b, los contenidos del archivo
 procesos, si existia antes de ejecutarse el comando, son sobreescritos.
 Para poder concatenar informacion en un archivo usamos ">>" en vez de ">".

 6.3.2 REDIRECCIONANDO LA CONEXION DE ERRORES ESTANDAR

 La conexion de errores estandar es la segunda conexion de salida que el S.O.
 Linux abre para cada programa. Normalmente es conectada a la terminal, o sea
 a nuestra pantalla, y es por eso que cada vez que un programa muestra un
 mensaje de error, este es visualizado en ella. Si ejecutamos un comando y
 redireccionamos la salida del mismo a un archivo, no estamos cambiando para
 nada la conexion de errores estandar de ese comando, por lo que cualquier
 mensaje de error que el comando reporte sera visualizado en pantalla.
 Esto ocurre porque la conexion de errores estandar no se encuentra
 redireccionada. Hay programas que producen una cantidad voluminosa de salida.
 En estos casos uno puede querer redireccionar la conexion de errores estandar
 a un archivo, para luego examinar los mensajes que el programa genero. Para
 redireccionar la conexion de errores estandar se utiliza "2>". El numero 2
 indica el numero de conexion de salida que es justamente la conexion de
 errores estandar.

 6.3.3 REDIRECCIONANDO LA ENTRADA

 Tambien es posible redireccionar la entrada. Ya vimos que uno de los
 programas que lee la informacion de la entrada es la shell, los demas
 programas que vimos (ls, ps, cat, etc.) producen su salida sin leer de la
 entrada estandar. La shell lee los comandos a ejecutar de la entrada estandar.
 Como la entrada estandar puede ser redireccionada a un archivo, es posible
 que la shell obtenga los comandos a ejecutar desde un archivo. Un ejemplo de
 esta situacion se muestra en la figura 6.2. En la misma vemos que los
 contenidos del archivo "comandos" son los nombres de dos comandos de Linux:
 date y ps. Luego utilizando el simbolo "<" redireccionamos la entrada del
 programa bash (Bourne Again Shell) al archivo comandos y los resultados se
 muestran en pantalla.

 REDIRECCIONANDO LA SALIDA Y LA ENTRADA SIMULTANEAMENTE

 Es posible redireccionar, simultaneamente, la entrada estandar y la salida
 estandar. Cuando esto sucede, el unico rol que cumple la terminal es ingresar
 el comando que vamos a ejecutar, pero luego el programa trabaja sin tener
 asociada la entrada ni la salida a la terminal. Salvo que no se redireccione
 la conexion de errores estandar porque los mensajes de error serian
 visualizados en pantalla. La forma de redireccionar la salida y la entrada
 simultaneamente se muestra con un ejemplo en la figura 6.3.

 6.4 CA¥ERIAS: LA INTERCONEXION ENTRE PROGRAMAS

 Las ca¤erias (pipes) conectan la salida estandar de un programa con la entrada
 estandar de otro programa. Una ca¤eria es diferente a la redireccion de la
 entrada/salida. Al redireccionar la entrada conectamos la entrada de un
 programa a un archivo y al redireccionar la salida conectamos la salida del
 programa a un archivo. Una ca¤eria coencta la salida de un programa
 directamente con la entrada de otro programa. Ver figura 6.4.

 Para construir una ca¤eria debemos separar los comandos que queremos
 conectar con el simbolo "|".

 En el ejemplo de la figura 6.5, conectamos dos comandos: ls y wc. El primero
 nos lista el contenido de un directorio, en este caso del directorio /bin. El
 segundo comando, wc (word count) sirve para contar palabras, lineas y
 caracteres, pero al pasarle la opcion -w le estamos diciendo que solo cuente
 palabras. El funcionamiento de este pipe es muy simple: El comando ls lee el
 contenido del directorio /bin y genera una lista de palabras con los nombres
 de los archivos y directorios encontrados. Esta lista, en vez de ser enviada
 a la terminal, es redireccionada a la entrada estandar del comando wc que
 comienza a contar las palabras y muestra el resultado en la salida estandar
 del mismo que es la terminal.

 6.5 GENERACION DE NOMBRES DE ARCHIVOS

 El S.O. Linux nos permite especificar conjuntos de nombres de archivos
 automaticamente utilizando "generacion de nombres de archivos y caracteres
 comodines". Cuando ingresamos argumentos a un comando, la shell examina los
 mismos con el objeto de detectar el uso de la generacion de nombres de
 archivos. El usuario controla la generacion de nombres de archivos
 especificando un modelo para los nombres de archivo. La shell compara el
 modelo provisto con todos los archivos del directorio de trabajo. Si alguno
 de los nombres de archivo responde al modelo, entonces una lista ordenada
 alfabeticamente con todos los nombres de archivos que responden al modelo es
 enviada al programa. Si ninguno de los nombres de archivo del directorio
 actual cumple con el modelo, entonces el modelo (en forma textual) es enviado
 al programa como argumento. Un modelo consiste de caracteres ordinarios y de
 "metacaracteres" llamados caracteres comodines. Los caracteres ordinarios son
 interpretados textualmente; los metacaracteres tiene un significado propio.
 Los metacaracteres utilizados para la generacion de nombres de archivo y sus
 significados se muestran en la tabla 6.1. 

  |øøøøøøøøøøøøøø|øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø|
  | Metacaracter |          Significado                                     |
  |--------------|----------------------------------------------------------|
  |      *       | Equivale a cualquier cadena de caracteres                |
  |      ?       | Equivale a cualquier caracter                            |
  |      [       | Comienza una clase de caracteres                         |
  |      ]       | Termina una clase de caracteres                          |
  |      -       | Indica un rango de caracteres en una clase de caracteres |
  |______________|__________________________________________________________| 
      
  Tabla 6.1: Metacaracteres utilizados para generacion de nombres de archivo.

 El asterisco y el signo de pregunta son muy faciles de usar. Por ejemplo *.c
 equivale a todos los archivos que tienen como sufijo .c como pueden ser:
 prog.c, ab.c, Main.c; los siguientes nombres no satisfacen el modelo unit2.cc,
 main.c.cc; el modelo ???.tex equivale a todos los nombres de archivo que
 tengan tres caracteres cualesquiera y luego el sufijo .tex, por ejemplo:
 ref.tex, cp1.tex, bea.tex, c++.tex, cumplen con el modelo pero ab.tex,
 tony.tex, intro.tex chapter1.tex.z no lo satisfacen.

 Los corchetes y el signo menos se utilizan para formar modelos para grupos
 de caracteres. Los caracteres en el grupo (o clase) son especificados dentro
 de los corchetes. El modelo abc[aeiou] representa todo nombre de archivo que
 comienze con abc y culmine con una unica vocal. El signo menos se utiliza
 para especificar rangos de caracteres. El modelo chapter[0-9] representa a
 todos los nombres de archivo que comienzan con chapter y finalizan con un
 digito. Notemos que el rango incluye a sus limites.

 Es necesario realizar una aclaracion con respecto a los archivos ocultos.
 Recordemos que todo archivo tal que su nombre comience con un punto es
 considerado un archivo oculto. La generacion de nombres de archivos no
 considerara que un modelo representa a un archivo oculto si no se especifica
 explicitamente el punto al comienzo del modelo. Por ejemplo: El modelo
 xinit* no representara al archivo cuyo nombre es .xinitrc. Para solucionar
 esto es necesario especificar el modelo de la siguiente forma .xinit*.

  # ps
    PID TTY STAT  TIME COMMAND
    338   1 S    0:00 /bin/login -- root
    356   1 S    0:00 -bash
    368   1 S    0:00 sh /usr/X11R6/bin/startx
    372   1 S    0:01 wmaker
    373   1 S    0:06 kfm
    377   1 S    0:00 wmmon
    381   1 S    0:00 mount.app
    394   1 S    0:37 emacs
    412  p0 S    0:01 kdvi apunte.dvi
    415   1 S    0:01 /usr/local/bin/x11amp
    479   1 S    0:00 kvt
    515  p0 R    0:00 ps

            a. Ejecucion del comando ps

  # ps > procesos

  # cat procesos
    PID TTY STAT  TIME COMMAND
    338   1 S    0:00 /bin/login -- root
    356   1 S    0:00 -bash
    368   1 S    0:00 sh /usr/X11R6/bin/startx
    372   1 S    0:01 wmaker
    373   1 S    0:06 kfm
    377   1 S    0:00 wmmon
    381   1 S    0:00 mount.app
    394   1 S    0:37 emacs
    412  p0 S    0:01 kdvi apunte.dvi
    415   1 S    0:01 /usr/local/bin/x11amp
    479   1 S    0:00 kvt
    515  p0 R    0:00 ps

            b. Ejecucion del comando ps redireccionando la salida al archivo
               "procesos"

            Figura 6.1: Redireccionando la salida del comando ps.

  # cat comandos
  date
  ps
  # bash < comandos
  Thu Apr 15 19:47:03 ART 1999
    PID TTY STAT  TIME COMMAND
    338   1 S    0:00 /bin/login -- root
    356   1 S    0:00 -bash
    368   1 S    0:00 sh /usr/X11R6/bin/startx
    372   1 S    0:01 wmaker
    373   1 S    0:06 kfm
    377   1 S    0:00 wmmon
    381   1 S    0:00 mount.app
    394   1 S    0:37 emacs
    412  p0 S    0:01 kdvi apunte.dvi
    415   1 S    0:01 /usr/local/bin/x11amp
    479   1 S    0:00 kvt
    515  p0 R    0:00 ps
   
            Figura 6.2: Redireccionando la entrada para que la shell ejecute
                        comandos desde un archivo.

  # cat comandos
  date
  pwd
  # bash < comandos > salida
  # cat salida
  Thu Apr 15 20:06:30 ART 1999
  /home/tony/docs/linux

            Figura 6.3: Redireccionando la entrada y la salida.



      |øøøø|__    <------------------------------------------------------\
  |---|____|  |_____                                                      |
  |    |      |     |            stderr                                   |
  |    |______|     | -----------------------------------> |øøøøøøøø|     |
  |         |       |                                      |        |     |
  |---------|       |                                 _--> |________|     |
     |  PROG1       |                                |        |   |       |
     |______________| --\                            |     /øøøøøøøøø\  --/
                         | stdout                    |    øøøøøøøøøøøøø
                         |                           |
                         |                           |
                         |                           |
                          \                          |
                          |                          |
      |øøøø|__            |                          |
  |---|____|  |_____      |                          |
  |    |      |     | <--/  stdin                    |
  |    |______|     |                                |                 
  |         |       |                                |                  
  |---------|       |                stdout & stderr |               
     |  PROG2       |                                |                
     |______________|  -----------------------------/                
                                                                       
            Figura 6.4: Ca¤eria de dos programas.


  # ls /bin | wc -w
       75

            Figura 6.5: Ejemplo de una ca¤eria. Contar la acntidad de
                        archivos en un directorio.
 


 CAPITULO 7

 COMANDOS Y UTILIDADES

 7.1 MOVIMIENTO EN EL SISTEMA DE ARCHIVOS

 EL directorio actual, o el direcorio de trabajo, es probablemente la pieza
 de informacion mas importante del entorno de trabajo. En cualquier momento,
 podemos saber cual es el directorio actual ejecurando el comando pwd (print
 working directory). La utilizacion de este comando se muestra en la figura
 7.1.

  # pwd
  /home/tony/txts/manual-linux

            Figura 7.1: Averiguando el directorio de trabajo.

 Una vez que completamos el proceso de inicio de sesion (log in), nos
 encontramos en el directorio home que el administrador del sistema nos ha
 designado. Con el comando cd (change directory) podemos cambiar el directorio
 de trabajo. Para ello tenemos que invocarlo con un argumento: el directorio
 que queremos que sea el directorio de trabajo. Se muestran ejemplos de este
 comando en la figura 7.2.

 El argumento con el que proveemos al comando cd puede ser tanto una ruta
 absoluta como una ruta relativa. En la figura 7.2a vemos un ejemplo de una
 ruta relativa y en las figuras 7.2b y c vemos ejemplos de argumentos de
 rutas relativas. Como caso especial, si ejecutamos el comando cd sin
 parametros, el nuevo directorio de trabajo sera nuestro direcotrio home.

 7.2 LISTADO DE ARCHIVOS

 7.2.1 LISTANDO ARCHIVOS

 Como fue comentado anteriormente, el comado ls (list) se utiliza para listar
 el contenido de los directorios. Este comando utiliza muchas opciones, muchas
 de las cuales no vamos a tratar aqui. Nos vamos a ocupar de su uso mas comun
 y de sus opciones mas utiles. El comando ls acepta multiples argumentos. Cada
 argumento que le pasamos puede ser el nombre de un archivo, de un directorio
 o una opcion (modificador). Si no le pasamos ningun argumento, entonces nos
 mostrara el contenido del directorio de trabajo. Por defecto, este comando
 nos muestra el contenido de los directorios en forma de columnas con los
 nombres de archivos encontrados como se muestra en la figura 7.3.

  # pwd
  /home/tony
  # cd /
  # pwd
  /

    a. Cambiando de directorio de trabajo de nuestro directorio home al
       directorio raiz.

  # pwd
  /
  # cd bin
  # pwd
  /bin

    b. Cambiando el directorio de trabajo a un subdirectorio.

  # pwd
  /home/tony/txts
  # cd ..
  # pwd
  /home/tony

    c. Cambiando el directorio de trabajo al directorio padre.

             Figura 7.2: Cambiando el directorio de trabajo.

  # ls
  init.d     rc.local     rc0.d      rc2.d     rc4.d     rc6.d
  rc         rc.sysinfo   rc1.d      rc3.d     rc5.d

             Figura 7.3: Listado del contenido de un directorio.

 Como vemos, el listado se presenta en orden alfabetico. De esta forma, la
 unica informacion que tenemos de cada archivo o directorio listado es su
 nombre. Cuando queremos conocer informacion adicional de cada archivo debemos
 usar los modificadores adecuados.

 LISTADO EN FORMATO LARGO

 El modificador -l indica al comando ls que visualize los nombres de los
 archivos y directorios junto con otros atributos, mas especificamente sus
 permisos, su due¤o, el grupo al que pertenece, la cantidad de links que
 posee, su tama¤o (en bloques), y su fecha de modificacion. Un ejemplo de un
 listado largo de archivos se muestra en la figura 7.4.

  # ls -l
  drwx------    2 root     root         1024 Mar 22 20:55 Xfree86/
  -rw-r--r--    1 root     root        25787 Apr  9 04:48 djetool-0.1.6.tar.gz
  -rw-r--r--    1 root     root       143078 Apr  9 04:50 hpdj-2.5.tar.gz
  -rw-r--r--    1 root     root       252411 Apr  9 04:11 kalendar-0.5b.tar.gz
  -rw-r--r--    1 root     root       677963 Apr  9 04:27 kget-0.6.1.tgz
  -rw-r--r--    1 root     root       766699 Apr  9 04:13 korganizer-1.1.tar.gz
  -rw-r--r--    1 root     root       288856 Apr  9 04:20 kpackage-1.2.tgz
  -rw-r--r--    1 root     root        92157 Apr  9 04:18 kuser-0.6.0.tar.gz
  -rw-r--r--    1 root     root      2643205 Apr  9 04:37 qt-1.42.tar.gz
  -rw-r--r--    1 root     root       140918 Apr  9 04:51 xtexcad-2.1.tar.z

      Figura 7.4: Listado en formato largo del contenido de un directorio  
    
 Sobre el ejemplo anterior se pueden notar varios puntos interesantes:

  * Cada archivo o directorio es mostrado en una linea separada acompa¤ado
    de toda su informacion adicional.

  * La primer columna de la lista, la cual es una serie de simbolos, especifica
    que permisos posee el archivo, pero ademas nos muestra, mediante el primer
    caracter, el tipo del archivo. Los diferentes codigos que se utilizan se
    muestran en la tabla 7.1.

  * La primera entrada en la lista se diferencia de todas las demas porque el
    codigo de tipo de archivo es "d", lo que significa que es un directorio,
    mientras que todas las demas entradas muestran "-" lo que nos informa
    que son archivos ordinarios.

  * La columna siguiente especifica la cantidad de hard links que posee el
    archivo. En el caso del directorio Xfree86 vemos que posee 2 mientras
    que los demas archivos todos tiene un solo link. El directorio posee 2
    links porque uno es creado por el directorio en si mismo y el otro es la
    entrada que se nombra "." que todo directorio contiene y que apunta a si
    mismo. Cada directorio tiene ademas otra entrada denominada ".." que
    apunta a su padre. Esto quiere decir que si un directorio "dir" tiene 4
    subdirectorios, entonces cada uno de estos poseera una entrada ".." que
    apuntara a "dir". Por lo tanto, el direcotrio "dir" tendra asociados 6
    links: uno que represente al directorio, uno por la entrada "." dentro
    de el, y uno por cada subdirectorio que posea. Esta situacion se muestra
    en la figura 7.5.

  * Las siguientes columnas especifican el usuario que es due¤o del archivo o
    directorio, y el grupo al que pertenece.

  * La columna que sigue nos muestra el tama¤o del archivo, pero este tama¤o
    es especificado en bloques. Esto es porque el S.O. utiliza bloques como la
    unidad de transferencia entre memoria y los dispositivos de bloques
    utilizados (discos rigidos, CD-ROM's, disketteras, etc). Tanto los archivos
    como los directorios pueden tener un numero cualquiera de bloques. En gral.,
    en Linux, se utilizan bloques de 1KB o sea (1024 bytes), pero esto no
    siempre es verdad ya que pueden utilizarse tambien bloques de 512 bytes.

  * La siguiente columna nos muestra el momento en el que se modifico por
    ultima vez el archivo o el directorio.

    NOTA: Disculpen semjante dibujo, pero es que si lo hacia mas chico, mo se
    iba a entender demasiado ;)

                         _____ ______ ________
                        |     |      |        |
               /        | mnt | Tony | README |
                        |_____|______|________|
                                  \
                                  1 \
                                      \
              ________________________\|/___________________
             |         |         |        |        |        |
         /-->|    .    |  dir1   |  dir2  |  dir3  |  dir4  | <---------------------------\       
        |    |_________|_________|________|________|________|                               \
      2 |       |         |  /|\        |    |   |   /|\  \                                   \
         \_____/          |   |         |    |    \    \    \                                   \
                          |   |         |     \     \    \    \__________________                 \
                         /    |         |       \     \    \ ______               \                 \  6
                       /      |          \        \     \           \ 5             \____             \
                     /         \           \        \     \_____      \_______            \             \
                   /         3 |             \      4 \         \              \           |             |
       __________\|/______     |    _______ _\|/____   |      __\|/__ _______   |       __\|/________    |
      |         |         |   /    |       |        |  |     |       |       |  |      |      |      |   |
  /-->|    .    |   ..    |--/  /->|   .   |   ..   |--/ /-->|   .   |  ..   |--/  /-->|  .   |  ..  |--/
 |    |_________|_________|    |   |_______|________|   |    |_______|_______|    |    |______|______|
 |       |                     |       |                |       |                 |      |
  \_____/                       \_____/                  \_____/                   \_____/

               Figura 7.5: Links definidos sobre un directorio.

             ______________________________________________     
            | Codigo  | Significado                        |
            |øøøøøøøøø|øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø|     
            |    -    | Archivo ordinario                  |
            |    d    | Directorio                         |
            |    c    | Archivo de dispositivo de caracter |
            |    b    | Archivo de dispositivo de bloque   |
            |    l    | Link simbolico                     |
            |    p    | Archivo de ca¤eria                 |
             øøøøøøøøø øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø     

               Tabla 7.1: Codigos de tipos de archivos y sus significados.

 LISTADO DE ARCHIVOS OCULTOS

 Se pueden notar, en los ejemplos anteriores, que tanto el listado predefinido
 como el listado largo producidos por el comando ls no nos muestran los
 archivos ocultos, es decir aquellos que su nombre comienza con un punto ".".
 Para listar los archivos ocultos es necesario especificar la opcion -a. Un
 ejemplo de listado de archivos ocultos se muestra en la figura 7.6.

 LISTADO DE DIRECTORIOS

 Hemos dicho que le podemos pasar varios argumentos al comando ls. Estos
 argumentos pueden ser archivos o directorios. Supongamos que queremos
 averiguar los permisos que tiene un archivo determinado. Para ello
 ejecutamos:

  ==>  ls -l <archivo>

 Como muestra la figura 7.7a. La ejecucion del comando tendra como resultado
 una unica linea correspondiente al archivo solicitado y su informacion
 correspondiente. Supongamos que, ahora, queremos averiguar los permisos
 que tiene seteados un cierto directorio. Intuitivamente se puede pensar que
 ejecutando ls -l <directorio> vamos a obtener la misma informacion que
 obtuvimos con el archivo. Veamos la figura 7.7b cual es el resultado.
 Imagino que adivinaron cual es el problema. En caso de que no, piensen lo
 siguiente: el comado ls cuando recibe un argumento decide si el mismo es
 un archivo o un directorio. En caso de ser un archivo lista la informacion
 solicitada del mismo y en caso de ser un directorio lista la informacion
 para cada archivo que se encuentre dentro del direcotorio especificado.
 Para que el comando nos liste solo la informacion del directorio y no de su
 contenido es necesario especificar la opcion -d (directory). El comando
 quedara de la siguiente forma:

  ==>  ls -dl <directorio>

   Ver figura 7.7c.

 7.3 MANIPULANDO ARCHIVOS

 Los comandos mv (move), cp (copy), ln (link) y rm (remove), junto con ls son
 los comandos mas importantes a la hora de manipular los archivos de Linux.
 Move y copy se utilizan para mover archivos de un lado a otro en el sistema
 de archivos. La unica diferencia entre ellos es que move borra el archivo
 original y copy no. El comando link se utiliza para establecer pseudonimos
 a los archivos (links). Para borrar los archivos utilizamos el comando
 remove.

 7.3.1 MOVIENDO Y COPIANDO ARCHIVOS

 El comando mv mueve un archivo de un sitio a otro. Si ambos sitios se
 encuentran en el mismo sistema de archivos, entonces el movimiento es
 esencialmente una operacion de renombre. Si por el contrario, los sitios se
 encuentran en distintos sistemas de archivos entonces se realiza una copia y
 luego se borra la original. La sintaxis del comando mv es:

  ==>  mv [opciones] fuente..  destino

 Donde las opciones son opcionales, valga la redundancia, y fuente...
 significa que podemos especificar varios argumentos de fuente, pero solo uno
 de destino.

 Vemos varios ejemplos en la figura 7.8. En el primer ejemplo (figura 7.8a)
 utilizamos mv para cambiar el nombre de un archivo. En el ejemplo siguiente
 (figura 7.8b) movemos un archivo de un directorio a otro y en el ultimo
 ejemplo (figura 7.8c) movemos varios archivos.

  # ls -l penguinc06.gif
  -rw-r--r--   1 root    root       8994 Apr  9 04:42 penguinc06.gif

                      a. Listando la informacion de un archivo.

  # ls -l Xfree86/
  total 6756
  -rw-r--r--   1 root    root          21268 Mar 22 20:27 README
  -rw-r--r--   1 root    root         818655 Mar 22 21:04 XVG16.tgz
  -rw-r--r--   1 root    root        2587331 Mar 22 20:53 Xbin.tgz
  -rw-r--r--   1 root    root           3340 Mar 22 20:39 Xcfg.tgz
  -rw-r--r--   1 root    root         311690 Mar 22 20:34 Xdoc.tgz
  -rw-r--r--   1 root    root        1284484 Mar 22 20:50 Xfonts.tgz
  .
  .
  .

       b. Intento fallido de listado de informacion de un directorio.

  # ls -dl Xfree86/
  drwx------   2 root    root           1024 Mar 22 20:55 Xfree86/

        c. Intento exitoso.

        Figura 7.7: Listando direcotorios e informacion sobre direcotorios.

 Para copiar archivos utilizamos el comando cp que se comporta de forma
 similar a mv, pero con la salvedad de que no borra la fuente del archivo
 original. Al igual que mv acpeta multiples argumentos siempre y cuando el
 ultimo de ellos sea un directorio. En el ejemplo de la figura 7.9a realizamos
 una copia de un archivo en el directorio donde este se encuentra; en el
 ejemplo de la figura 7.9b copiamos el mismo archivo pero en otro directorio
 y en el utimo ejemplo (figura 7.9c) copiamos varios archivos en un directorio.

 COPIANDO DIRECTORIOS

 Si necesita copiar un directorio en vez de archivos, debemos especificar la
 opcion -R o -r (recursive) ya que sino el comando omitira cada argumento
 fuente que sea un directorio y no sera copiado. En caso de proveer esta
 opcion, todo argumento que corresponda a un directorio sera copiado
 (incluyendo todos sus subdirectorios y los subdirectorios de estos y etc)
 en el directorio destino especificado. Veamos un ejemplo en le figura 7.10.
 Supongamos que queremos copiar el directorio mail -que es subdirecotorio de
 Tony- completo con sus archivos en el directorio /backup que se encuentra
 vacio. Para ello ejecutamos:

  ==>  cp -r mail/ /backup/

  # ls
  kernel-2.1.125  kernel-2.2.1   kernel-2.2.5
  # mv kernel-2.2.5 kernel
  # ls
  kernel      kernel-2.1.125   kernel-2.2.1

     a. Utilizando mv para renombrar archivos

  # ls
  kernel      kernel-2.1.125  kernel-2.2.1
  # mv kernel ../config/
  # ls ../config/
  kernel
  # ls
  kernel-2.1.125  kernel-2.2.1

     b. Moviendo un archivo de un directorio a otro.

  # ls
  kernel-2.1.125  kernel-2.2.1   kernel-2.2.5
  # mv kernel* ../config/
  # ls ../config/
  kernel-2.1.125  kernel-2.2.1   kernel-2.2.5
  # ls

     c. Moviendo varios archivos de un directorio a otro.

         Figura 7.8: Moviendo archivos.

 En la figura 7.10 se muestra el arbol resultante una vez realizada la copia.
 El directorio que se copio se muestra resaltado con una elipse

 7.3.2 REALIZANDO LINKS

 Como vimos en la seccion 2.1.6 los "links" sirven para establecer
 pseudonimos entre los archivos, es decir para que un mismo archivo fisico
 sea referenciado por varios nombres logicos. En la terminologia de Linux
 estos pseudonimos son llamados "links". Como tambien ya vimos, existen dos
 tipos de links: hard links y links simbolicos. Primero veremos los hard links
 y despues nos ocuparemos de los simbolicos.

 El comando ln es el utilizado en Linux para establecer los links.

 CREANDO Y MANIPULANDO HARD LINKS

 Los hard links se crean con el comando ln. Supongamos que queremos crear un
 link llamado index.htm a un archivo que se llama presentacion.htm.
 El comando para realizar esto se muestra en la figura 7.11.

 Una vez creado el hard link, tanto el viejo nombre del archivo (presentacio.htm)
 como el nuevo (index.htm) se refieren al mismo archivo, es decir a los
 mismos datos en la misma locacion fisica del disco. Una vez creados los
 links, podemos ver los numeros de i-nodo asociados a cada nombre de archivo
 ejecutando el comando siguiente:

   ==> ls -i

  # pwd
  /usr/local/articles/NT lies/
  # ls
  Lies.htm  lie10.jpg  lie3.jpg  lie5.jpg  lie7.jpg  lie9.jpg
  lie1.jpg  lie2.jpg   lie4.jpg  lie6.jpg  lie8.jpg 
  # cp Lies.htm index.htm
  # ls
  Lies.htm  lie1.jpg  lie2.jpg  lie4.jpg  lie6.jpg  lie8.jpg
  index.htm lie10.jpg lie3.jpg  lie5.jpg  lie7.jpg  lie9.jpg 

       a. Copiando un archivo sobre un mismo directorio.

  # ls
  Lies.htm  lie1.jpg  lie2.jpg  lie4.jpg  lie6.jpg  lie8.jpg
  index.htm lie10.jpg lie3.jpg  lie5.jpg  lie7.jpg  lie9.jpg 
  # cp Lies.htm /root/articles/
  # ls /root/articles/
  Lies.htm

        b. Copiando un archivo hacia otro directorio.

  # ls
  Lies.htm  lie1.jpg  lie2.jpg  lie4.jpg  lie6.jpg  lie8.jpg
  index.htm lie10.jpg lie3.jpg  lie5.jpg  lie7.jpg  lie9.jpg 
  # cp lie* /root/articles/
  # ls /root/articles/
  Lies.htm  lie10.jpg  lie3.jpg  lie5.jpg  lie7.jpg  lie9.jpg
  lie1.jpg  lie2.jpg   lie4.jpg  lie6.jpg  lie8.jpg 

         c. Copiando varios archivos.

           Figura 7.9: Copiando archivos.

 En la figura 7.11 vemos que tanto el archivo el archivo presentacion.htm
 como el archivo index.htm poseen el mismo numero de i-nodo, lo que quiere
 decir que ambos nombres se refieren al mismo "archivo fisico". Esto se
 ilustra en la figura 7.12a. A partir de esto, es valido acceder al archivo
 con cualquiera de los dos nombres que este posee. Es importante notar que si
 modificamos el archivo presentacion.htm, por lo dicho anteriormente, tambien
 modificamos el archivo index.htm.

 En la figura 7.11, antes de crear el hard link, listamos los detalles del
 archivo presentacion.htm y vemos que el numero de links del mismo es 1.
 Cuando listamos por segunada vez, luego de haber creado el hard link, vemos
 que el numero de links de ambos archivos es 2. Ademas de esto notemos que
 todos los atributos restantes son iguales, incluyendo los permisos.
 
          _______________________
     /    | mnt | Tony | backup |
          øø/øøøøøø|øøøøøøøøøøøøø\              __________________
          /         \              \           /                  \
        /           __\____________  \        | ________            \______
       @            | prog | mail |    \------+-| mail |                   \
                    øøøøøøøøøøøø\øø           | øøøøøøøø\                    \
                                  \           |           \                    \
                                    \          \_______     \                   |
                ____________________  \                 \     \                 |
               | mod1 | mod2 | exec |  _\_______________ | _____\___________    |
                øø|øøøøøø|øøøøøø|øøø   | mess | attach | | | mess | attach |    |
                  |      |      |      øøø|øøøøøøø|øøøøø | øøø|øøøøøøø|øøøøø    |
                  |      |      |         |       |      |    |       |         |
                  @      @      @         @       @       \   @       @         |
                                                            \                   |
                                                              \________________/

   # ls mail/
   attach mess
   # cp -r mail /backup/
   # ls /backup/
   mail
   # ls /backup/mail/
   attach mess

                Figura 7.10: Copiando directorios recursivamente.

 OBSERVACIONES ACERCA DE LOS HARD LINKS

 Los hard links, como ya vimos, relacionan nombres de archivos con numeros de
 i-nodo. Un sistema de archivos posee un cierto numero de i-nodos con los
 cuales identifica los archivos que posee. Lo que quiere decir que los i-nodos
 son relativos a un sistema de archivos particular y que podemos tener dos
 archivos distintos que se encuentran en distintos sistemas de archivos, pero
 con el mismo numero de i-nodo. Por esto, no se pueden establecer hard links
 entre archivos que se encuentren en distintos sistemas de archivos archivos.
 Esto es una limitacion importante a la hora de utilizar hard links.

 CREANDO Y MANIPULANDO LINKS SIMBOLICOS

 Para crear links simbolicos tambien utilizamos el comando ln pero modificamos
 su comportamiento con la opcion -s, la cual especifica que el link a crear
 sera un link simbolico. En la figura 7.13 vemos como se crearia un link
 simbolico index.htm al archivo presentacion.htm.

 Al listar los contenidos del directorio, una vez creado el link simbolico,
 vemos que la entrada del archivo index.htm nos informa que el archivo es un
 link simbolico (atributo 1 en la columna de tipo de archivo).

 Ademas vemos que el numero de links del archivo presentacion.htm es 1, esto
 es porque este numero cuenta la cantidad de hard links establecidos y no se
 contabilizan los links simbolicos. Esto quiere decir que al borrar el archivo
 presentacion.htm se borraran directamente los contenidos, y el link simbolico
 quedara destruido, es decir apuntara a algo que ya no existe.

   # ls -l
   total 60
   -r--------   1 root    root         59997 Apr 28 22:47 presentacion.htm
   # ln presentacion.htm index.htm
   # ls -l
   ls -l --color=none
   total 120
   -r--------   2 root    root         59997 Apr 28 22:47 index.htm 
   -r--------   2 root    root         59997 Apr 28 22:47 presentacion.htm
   # ls -i
    262288 index.htm         262288 presentacion.htm

                    Figura 7.11: Estableciendo hard links.

 Otra cosa para notar en el listado, es que la columna respectiva al nombre
 de los archivos, vemos que el archivo index.htm apunta al archivo
 presentacion.htm.

 Es importante tener en cuenta que estos archivos son dos archivos separados.
 Es decir que cada uno tiene sus atributos propios. Por ejemplo, en la figura
 7.13 vemos que los archivos tiene distintos tama¤os, distintas fechas de
 modificacion, etc.

 Al realizar la consulta de los numeros de i-nodo de los archivos, vemos
 tambien que ambos archivos tiene distinto numero de i-nodo, lo que quiere
 decir que ambos tienen un lugar fisico distinto en el medio donde se
 almacenan.

 Anteriormente, vimos que no es posible crear hard links entre archivos que
 se encuentran en distintos sistemas de archivos. Con los links simbolicos,
 esto no es problema, ya que la asociacion se realiza por nombre y no por
 numero de i-nodo. Ver figura 7.12b.

 Al crear los links simbolicos, debemos tener cuidado con la forma en que los
 creamos, ya que podemos hacerlo mediante una ruta relativa o una ruta
 absoluta. Un problema que podemos tener si creamos un link con una ruta
 relativa, es que si movemos el link a otro lugar del sistema de archivos,
 perderemos la asociacion entre los archivos. Con los links absolutos, esto
 no es problema.

   Observacion: Si borramos el archivo que es link simbolico, este sera
                eliminado pero no se borrara el archivo al cual apunta.
                Para borrar el archivo apuntado debemos borrar este
                directamente.

                            __________
                           |          |
                           |          |           _______
                           |          |          |       |
   index.htm -----------.  |          |   .----->|       |
                        |  |          |   |      |_______| 
   presentacion.htm --. |  |          |   |
                      | ø->|----------|___|       Archivo
                      ø--->|__________|
                           |          |
                           |__________|

                         Tabla de i-nodos

     a. Un hard link entre los archivos presentacion.htm e index.htm.

                            __________
                           |          |
                           |          |           _______
    index.htm              |          |          |       |
       |                   |          |   .----->|       |
      \|/                  |          |   |      |_______| 
   presentacion.htm --.    |          |   |
                      |    |----------|___|       Archivo
                      ø--->|__________|
                           |          |
                           |__________|

                         Tabla de i-nodos

     b. Un link simbolico del archivo index.htm al archivo presentacion.htm.

       Figura 7.12: Estructura logica de los links entre archivos.

 7.3.3 ELIMINANDO ARCHIVOS

 Para eliminar archivos ordinarios, utilizamos el comando rm (remove). Vemos
 un ejemplo en la figura 7.14. Debemos tener en cuenta que para poder eliminar
 archivos debemos tener permiso de escritura en el directorio donde se
 encuentren los archivos.

 Si tenemos permiso de escritura sobre el archivo a borrar, entonces el
 mismo sera borrado directamente. En cambio, si no tenemos permiso de
 escritura sobre el archivo, entonces el comando nos preguntara si queremos
 ignorar la proteccion y borrarlo igualmente. Si contestamos "y" (yes), el
 archivo sera borrado, solo si somos due¤o del mismo, sino obtendremos un
 mensaje que nos indicara que no tenemos permiso para borrar el archivo.
 Esto es ilustrado en la figura 7.14: el archivo vi.htm tiene permiso de
 escritura, por lo que es borrado inmediatamente. En cambio el archivo
 persentacion.htm no tiene seteado el permiso de escritura, por lo que el
 comando nos preguntara si queremos ignorar la proteccion. Contestamos que si
 y el archivo es eliminado.

 Se debe tener mucho cuidado cuando eliminamos archivo en Linux, ya que los
 archivos eliminados realmente SE PIERDEN Y NO HAY FORMA DE RECUPERARLOS. No
 existe ningun mecanismo de recuperacion de archivos en Linux. Siempre que
 estemos en duda de borrar un archivo, pensemos en preservarlo ya que no
 tendremos forma de recuperarlo.

 OPCIONES DEL COMANDO RM

 Las opciones mas importantes del comando rm son las siguientes:

  * -f: Forzar la eliminacion de los archivos sin permiso de escritura sin
        pedir la confirmacion.

  * -i: Operacion interactiva. Realizar una confirmacion antes de eliminar
        cada archivo. Las respuestas que comienzan con y o Y son consideradas
        afirmativas.

  * -r: Operacion recursiva. Elimina archivos y subdirectorios, borrando todo
        un subarbol de directorios.

  # ls
  presentacion.htm
  # ls -s presentacio.htm index.htm
  # ls -l
  total 60
  lrwxrwxrwx  1 root    root            16 Apr 29 19:11 index.htm -> presentacion.htm
  -r--------  1 root    root         59997 Apr 28 22:47 presentacion.htm
  # ls -i
   262269 index.htm       262269 presentacion.htm

                  Figura 7.13: Estableciendo links simbolicos.

  # ls -l
  total 14
  -rw-r--r--  1 gg      users        7559 May  2 01:15 commands.htm
  -r--------  1 gg      users        2880 May  2 01:15 presentacion.htm
  -rw-r--r--  1 gg      users        2880 May  2 01:15 vi.htm
  # rm vi.htm
  # rm presentacion.htm
  rm: remove 'presentacion.htm', overriding mode 0400? y
  # ls
  commands.htm

                  Figura 7.14: Eliminando archivos.

 7.4 MANIPULANDO DIRECTORIOS

 7.4.1 CREANDO DIRECTORIOS

 Para organizar nuestros archivos utilizamos directorios y subdirectorios. La
 creacion de directorios tambien se realiza mediante comandos. El comando para
 crear directorios es mkdir (make directory). El mismo acepta una lista de
 argumentos (cada argumento puede ser una rura absoluta o una rura relativa) y
 crea un directorio por cada argumento que se encuentre en la lista. Los
 directorios, una vez creados, se encuentran vacios.

 Veamos un ejemplo en la figura 7.15. primero creamos un directorio llamado
 qt, verificamos que haya sido creado y vemos que esta vacio. Luego creamos
 tres directorios juntos (c, java. c++).

    # la
    # mkdir qt
    # ls
    qt
    # ls qt
    # mkdir c java c++
    # ls
    c     c++    java    qt

      Figura 7.15: Creando directorios.

 7.4.2 ELIMINANDO DIRECTORIOS

 Tenemos dos formas de eliminar directorios:

  1. Utilizando el comando rm con la opcion -r (recursive). Esto borrara un
     directorio junto a todo su contenido (archivos y subdirectorios)
     eliminando asi todo un subarbol.

  2. Utilizando el comando rmdir (remove directory). Este comando nos permite
     eliminar directorios pero con la exigencia de que los mismos esten vacios.
     Si queremos borrar un directorio que tiene archivos dentro, debemos,
     primero, eliminar los mismo com rm y luego eliminar el directorio con
     rmdir.

 Ilustramos ambas formas en la figura 7.16. En la figura 7.16a, borramos el
 directorio com rm -r y en la figura 7.16b lo hacemos con rmdir. Notemos, en
 el primer caso, que el comando nos pide confirmacion para cada archivo o
 directorio que se encuentre en el directorio a borrar. Esto se puede evitar
 utilizando rm -rf, ya que la opcion -f (force), hace que no se realicen las
 confirmaciones y borra directamente.

 En el segundo caso, primero debemos vaciar el directorio (en este caso lo
 hacemos con rm -f) y luego debemos eliminar el directorio con rmdir.

 7.5 BUSQUEDA DE ARCHIVOS

 En ocasiones podemos estar interesados en averiguar donde se encuentran
 determinados archivos. Cuando queremos buscar uno o mas archivos dentro de
 un directorio en particular, podemos utilizar el comando ls para listar los
 archivos y verificar en la lista si el/los mismos se encuentran alli. Pero
 cuando queremos buscar archivos en todo un subarbol de directorios, trabajar
 con ls puede resultar muy incomodo.

 El comandp find (buscar), localiza archivos, de acuerdo a un criterio de
 busqueda, en todo un subarbol de directorios y nos reporta los resultados.

 Los criterios de busqueda del comando find se pueden ser combinar para
 realizar busquedas realmente complejas. Aqui vamos a estudiar los criterios
 mas utilizados a nivel usuario que a su vez son los mas sencillos.

 La sintaxis del commando find es la siguiente:

  ==> find <path...> <criterio>

   * <path...> es una lista de directorios donde se comenzara a buscar. find
     buscara en los subarboles que comienzan en cada directorio especificado
     en la lista de directorios.

   * <criterio> es una serie de acciones, tests y opciones que especifican
     un cierto criterio de busqueda y posiblemente ciertas acciones a
     realizar sobre los archivos encontrados. Esto se vera mas adelante.

    # ls
    c    c++    java    qt
    # ls java
    hello-world.class  hello-world.java
    # rm -r java
    rm:descend directory 'java'? y
    rm: remove 'java/hello-world.java'? y
    rm: remove 'java/hello-world.class'? y
    rm: remove directory 'java' y
    # ls
    c    c++    qt

               a. Eliminando un directorio con rm -r.

    # ls
    c    c++    java    qt
    # ls java
    hello-world.class  hello-world.java
    # rmdir java
    rmdir: java: Directory not empty
    # rm -f java/*
    # rmdir java
    # ls
    c    c++    qt

               b. Eliminando un directorio con rmdir.

                 Figura 7.16: Eliminando directorios

 No vamos a analizar detalladamente la sintaxis de la expresion que denota los
 criterios de busqueda, sino que vamos a ilustrar el uso del comando find con
 varios criterios de busqueda tipicos.

 7.5.1 EJEMPLOS DEL USO DE FIND

 BUSCANDO ARCHIVOS POR NOMBRE

 Supongamos que queremos buscar todos los archivos que comiencen con X en el
 subarbol que encabeza el directorio /etc. El comando utilizado para realizar
 la busqueda y el resultado de la misma se muestran en la figura 7.17.

 En este ejemplo, para realizar la busqueda, le pasamos como ruta de comienzo
 el directorio /etc y la expresion que especifica que el criterio es -name X*.
 La opcion -name especifica al comando find que queremos realizar la busqueda
 por nombre de archivo y el argumento X* expresa que queremos buscar los
 archivos cuyo nombres comiencen con X.

 En general, la busqueda de archivos por nombre se realiza con el siguiente
 comando:

  ==>  find <path> -name <expresion>

 Donde la expresion especifica el formato de los nombres a buscar. Para formar
 la expresion podemos utilizar todas las capacidades de generacion de nombres
 de archivo que nos prove la shell (ver seccion 6.5).

  # find /etc -name X*
  /etc/X11
  /etc/X11/xinit/Xclients
  /etc/X11/xdm/Xaccess
  /etc/X11/xdm/Xresources
  /etc/X11/xdm/Xservers
  /etc/X11/xdm/Xsession
  /etc/X11/xdm/Xsetup_0
  /etc/X11/X
  /etc/X11/XF86Config

                   Figura 7.17: Buscando archivos por nombre.

 BUSCANDO ARCHIVOS POR TAMA¥O

 Otro uso comun del comando find es la busqueda de archivos por tama¤o. Para
 buscar archivos por tama¤o, en vez de utilizar la opcion -name utilizamos la
 opcion -size. A continuacion de esta opcion debemos especificar el tama¤o de
 los archivos a buscar y ademas si queremos buscar archivos mas grandes o mas
 chicos que el tama¤o especificado. Veamos un ejemplo en la figura 7.18.

  # find /mp3 -size +700k
  /mp3/Nirvana/Lithium.mp3
  /mp3/Black Sabbath/paranoid/War Pigs.mp3
  /mp3/Led Zeppelin/Stairway to Heaven.mp3

           Figura 7.18: Buscando archivos por tama¤o.

 En este ejemplo, queremos encontrar todos los archivos que tengan un tama¤o
 mayor a 7000 Kbytes, a partir del directorio /mp3. Debemos realizar dos
 observaciones:

  * El signo "+" que prefijamos al argumento que especifica el tama¤o obliga
    al comando find a realizar un test. En este caso testeara que el tama¤o
    del archivo sea mayor a 7000 Kbytes. En caso de querer buscar archivos
    de un tama¤o menor al argumento debemos prefijar el simbolo "-". Si no
    usamos ningun simbolo, find buscara archivos cuyo tama¤o sea exactamente
    igual al argumento especificado.

  * La letra "k" que agregamos luego del argumento informa a find que la
    unidad a utilizar sera Kbytes. Tambien podemos utilizar:

    - "c": Bytes

    - "w": Palabras (words) de 2 bytes cada una

    - "b": Bloques de 512 bytes cada uno (esta opcion es utilizada por
           defecto si no especificamos ninguna).

 BUSCANDO ARCHIVOS POR FECHA DE MODIFICACION

 Otra manera de utilizar el comando find para buscar archivos es utilizando
 criterios de busqueda basados en fechas de modificacion de los archivos. En
 este caso la opcion a utilizar es -mtime (modified time). Vemos un ejemplo
 en la figura 7.19.

  # find /gome/tony/html -name *.htm -mtime -6
  /home/tony/html/commands.htm
  /home/tony/html/vi.htm

        Figura 7.19: Buscando archivos por fecha de modificacion.

 El argumento de la opcion -mtime es un numero que especifica la cantidad de
 dias. Si prefijamos un "-", entonces find buscara archivos que hayan sido
 modificados dentro de la cantidad de dias especificada. Si prefijamos un "+"
 al argumento, entonces se buscaran archivos que no hayan sido modificados
 en ese periodo. Esto es particularmente util cuando queremos generar listas
 de archivos viejos.

 En este ejemplo, ilustramos como es posible combinar opciones para formar
 criterios de busqueda mas avanzados. En este caso solo seran devueltos como
 resultado los nombres de los archivos que terminen con ".htm" y hayan sido
 modificados en los ultimos 6 dias.

 EFECTUANDO ACCIONES SOBRE LOS ARCHIVOS ENCONTRADOS

 El comando find nos permite realizar ciertas acciones sobre los archivos
 que se van encontrando como resultado de la busqueda. Esta es una
 caracteristica muy util de este sistema.

 Cuando un programa de Linux falla, el S.O. escribe, en el directorio de
 trabajo que el programa tenia en el momento de la falla, un archivo
 (usualmente muy grande) llamado core que se utiliza para realizar un analisis
 de las causas por las que el programa fallo. En un sistema que se utiliza
 para el desarrollo de programas estos archivos son muy utiles, pero en la
 mayoria de los sistemas estos archivos no tienen utilidad y pueden ser
 purgados periodicamente. En la figura 7.20 mostramos un comando find que
 buscara en todo el sistema de archivos a los archivos que se llamen "core" y
 los eliminara.
   
   # find / -name core -exec rm {} \;
   rm: /proc/sys/net/core: is a directory
   find: /proc/410/fd: Permission denied
   find: /proc/411/fd: Permission denied
   find: /proc/433/fd: Permission denied
   rm: /usr/src/linux-2.2.5/net/core: is a directory

           Figura 7.20: Eliminando los archivos encontrados por find.

 Vamos a analizar en detalle el comando utilizado:

  * La opcion -exec nos permite especificar un comando a realizar sobre cada
    archivo que find encuentra. El argumento de esta opcion es un comando. En
    este caso utilizamos el comando rm para que elimine los archivos
    encontrados.

  * Las llaves "{}" que agregamos a continuacion del comando rm seran
    reemplazadas por find con el nombre de cada archivo encontrado. Asi el
    comando rm tendra especificado como argumento el nombre de archivo
    correcto y podra eliminarlo.

  * La sintaxis del comando find nos obliga a colocar, luego del argumento a
    la opcion -exec, un punto y coma ";". Pero como la shell le otorga a este
    simbolo un significado especial (es el separador de comandos) debemos
    utilizar la barra "\" como caracter de escape para que la shell no
    interprete que queremos utilizarlo como separador de comandos. Veremos
    mas sobre esto en los capitulos siguientes.

 OTROS USOS DEL COMANDO FIND

 Es posible utilizar el comando find para realizar busquedas basadas en muchos
 otros criterios, por ejemplo:

  * Buscar archivos vacios (-empty)
  * Buscar archivos pertenecientes a grupos de usuarios (-group)
  * Buscar archivos por nombre, pero que la evaluacion se realice sin
    diferenciar letras minusculas y mayusculas (-iname)
  * Buscar archivos por numero de links (-links)
  * Buscar archivos por tipos (directorios, links simbolicos, etc) (-type)
  * Buscar archivos por usuario (-user)

 7.6 CAMBIANDO PERMISOS, GRUPOS Y DUE¥OS

 La habilidad de poder especificar los permisos, grupos y due¤os de los
 archivos para cada archivo en particular es uno de los puntos mas fuertes
 del S.O. Linux y de todos los demas UNIX.

 Los comandos chmos (change mode), chown (change owner) y chgrp (change group)
 se utilizan para cambiar  los derechos de acceso de los archivos y
 directorios.

 Se debe tener en cuenta que para poder cambiar los derechos de acceso de un
 archivo debemos ser due¤o del mismo. Existe una excepcion a esta regla que
 es el "superusuario" :).

 EL SUPERUSUARIO PUEDE CAMBIAR LOS DERECHOS DE ACCESO DE CUALQUIER ARCHIVO O
 DIRECTORIO.

 Como vimos anteriormente, las tres operaciones que pueden ser realizadas
 sobre un archivo son: lectura, escritura y ejecucion. Por cada archivo
 existen tres niveles de privilegio:

  * user: es el due¤o del archivo

  * group: es el grupo a el cual pertenece el archivo

  * others: es el universos (otros usuarios) de usuarios restantes

 Por cada nivel de privilegio, es posible setear los permisos para las tres
 operaciones de cada archivo o directorio. Mas especificamente por cada nivel
 de privilegio, cada operacion puede estar permitida o denegada.

 7.6.1 AVERIGUANDO LOS DERECHOS DE ACCESO DE UN ARCHIVO

 Para averiguar que permisos tiene un archivo, que usuario es due¤o y a que
 grupo pertenece, podemos utilizar el comando ls -l que nos muestra un listado
 largo de los archivos. Por ejemplo:

  # ls -l
  total 15
  -rw-r--r--   1 tony   users       7559 May 12 04:31 commands.htm
  -rw-r--r--   1 tony   users       3817 May 12 04:31 krabber-2.html
  -rw-r--r--   1 tony   users       2880 May 12 04:31 vi.htm

 Cada entrada del listado, en su comienzo, tiene una serie de simbolos que
 especifican los permisos del archivo. La tercer columna de la entrada
 muestra el usuario due¤o del archivo y la columna siguiente especifica el
 grupo al cual pertenece el archivo. En este caso el due¤o de los archivos
 es el usuario tony y los mismos pertenecen al grupo users. La identificacion
 de los permisos es un poco mas complicada.

 La informacion de los permisos de cada archivo se encuentra en el primer
 campo de la entrada del listado. Este campo es una serie de simbolos. El
 primer simbolo especifica el tipo de archivo (ver tabla 7.1). Los demas
 simbolos especifican los permisos seteados sobre el archivo. El formato es
 el siguiente (ver figura 7.21):

  * Los tres primeros simbolos especifican los permisos de lectura, escritura
    y ejecucion para el usuario due¤o del archivo.

  * Los siguientes tres simbolos especifican los permisos del archivo para los
    usuarios que pertenecen al grupo al cual el archivo pertenece.

  * Los ultimos tres simbolos muestran los permisos del universo restante.

           _________ Permisos del due¤o
          |
          |      ___ Permisos del grupo
         _|_   _|_
         | |   | |
        -rwxrwxrwx
            | ||||_____ Permiso de ejecucion
            ø|ø||______ Permiso de escritura
             | |_______ Permiso de lectura
             |
             |_______Permisos del grupo

             Figura 7.21: Permisos de un archivo

 Los tres simbolos de cada uno de los tres niveles de privilegio se interpreta
 de la siguiente manera:

  1. "r" el archivo tiene permiso de lectura en este nivel de privilegio.

  2. "w" el archivo tiene permiso de escritura en este nivel de privilegio.

  3. "x" el archivo tiene permiso de ejecucion en este nivel de privilegio.

 En cualquiera de los casos, un simbolo "-" significa que no se tiene el
 permiso determinado. En el ejemplo anterior, los tres archivos tienen
 permiso de lectura para todos los niveles de privilegio, pero solo el due¤o
 tiene permiso de escritura y ninguno de los niveles tiene permiso de
 ejecucion, lo que quiere decir que nadie podra ejecuar ninguno de los
 archivos. Esto tiene sentido ya que no son ejecutables, son archivos "html"
 de hipertexto.
 
 Es usual que los miembros del grupo tengan los mismos o menos privilegios
 que el due¤o del archivo y que los demas usuarios tengan los mismos o menos
 privilegios que los de los miembros del grupo, pero Linux no nos impone
 ninguna restriccion sobre el seteo de los permisos. Facilmente podemos
 hacer que un archivo no pueda ser leido por su due¤o pero que los demas
 usuarios puedan hacerlo. (Aunque no tendria sentido desde un punto de vista
 practico).

 7.6.2 CAMBIANDO LOS PERMISOS

 Existen dos formas de cambiar los permisos con el comando chmod. Una de ellas
 es utilizando el modo simbolico y la trataremos a continuacion. La otra forma
 es utilizando el modo numerico octal y usualmente es !!ODIADA!! por los
 usuarios novatos. Esta forma sera tratada en segundo termino.

 MODOS DE ACCESO SIMBOLICOS

 Una palabra de control de modos de acceso simbolica consiste en tres partes:
 quienes, operador y permisos. "Quienes" especifica sobre que niveles de
 privilegio setearemos los permisos. El "operador" es la operacion a plicar:
 agregar, quitar o setear los permisos. Veamos un ejemplo en la figura 7.22.

  # ls -l
  -rw-r--r--   1 tony    users     1090 May 29 17:04 file
  # chmod go-r file
  # ls -l
  -rw-------   1 tony    users     1090 May 29 17:04 file
  # chmod g=u file
  # ls -l
  -rw-rw----   1 tony    users     1090 May 29 17:04 file

        Figura 7.22: Cambiando permisos utilizando el modo simbolico.

 En este ejemplo vemos que el archivo de nombre file tiene permiso de lectura
 para todos los usuarios, pero su due¤o es el unico que tiene permiso de
 escritura. Luego ejecutamos.

  ==> chmod go-r file

 En este comando el campo "quienes" esta formado por g (group) y o (others),
 el operador es "-" por lo tanto se quitaran los permisos especificados, que
 en este caso es unicamente el permiso de lectura "r" (read). Luego de estos
 tres campos se debe especificar  el/los archivos sobr los que queremos
 modificar los permisos. Luego de cambiar los permisos, verificamos que el
 archivo ya no tiene permiso de lectura ni para los usuarios del grupo, ni
 para los demas. Luego ejecutamos:
  
  ==> chmod g=u file

 Aqui el campo "quienes" contiene solo el grupo. El operador es este caso es
 "=" por lo que los permisos del grupo seran seteados iguales a los del
 usuario.

 Los valores que pueden tomar cada campo de la palabra de control simbolico
 se muestran en la tabla 7.2.

    Quienes         Operador                Permisos
  -------------------------------------------------------------------------
  u Usuarios     -  Eliminar el permiso  r Lectura (read)
  g Grupo        +  Agregar el permiso   w Escritura (write)
  o Otros        =  Setear el permiso    x Ejecucion (execute)
  a Todos (all)                          u Permisos actuales del usuario
                                         g Permisos actuales del grupo
                                         o Permisos actuales del resto

                   Tabla 7.2. Formando la palabra de control chmod.

 MODOS DE ACCESO EN NOTACION OCTAL

 Muchas personas prefieren especificar los modos de acceso de los archivos
 utilizando el modo simbolico. Pero el comando chmod tambien nos permite
 utilizar una especificacion numerica. Aunque uno prefiera utilizar la
 notacion simbolica es bueno entender la notacion numerica octal de modos de
 acceso de los archivos en esta notacion. Mas aun si vamos a dedicarnos a la
 administracion de un sistema, nos encontraremos con la notacion octal muy
 frecuentemente. Como usuario, podemos encontrar situaciones en las que los
 comandos mv, cp, ln, rm necesiten confirmacion de las acciones a realizar y
 nos especifiquen el modo de acceso del archivo en notacion octal.

 Los numeros del sistema octal, se encuentran en base 8. Lo que significa que
 los digitos octales son 0, 1, 2, 3, 4, 5, 6 y 7. Cada digito octal es
 representado por tres digitos binarios (0 o 1), por esto la notacion octal
 es practica para represntar cosas que se agrupan en trios, ya que solo un
 digito octal puede representar todas las posibilidades.

 Un solo digito puede servirnos para representar un conjunto de permisos
 de lectura/escritura/ejecucion como vemos en la tabla 7.3.

 Como un digito octal puede guardar un conjunto de permisos, necesitamos tres
 digitos para representar los modos de acceso de un archivo, un digito para
 los permisos del usuario, otro para los permisos del grupo y otro para los
 permisos de los demas usuarios.

 Una diferencia grande con la utilizacion de la notacion simbolica es que
 con el modo octal debemos especificar completamente el modo de acceso del
 archivo y no podemos agregar o quitar permisos. Veamos varios ejemplos
 en la fihura 7.23.

   Digito Octal   Permiso de lectura   Permiso de escritura   Permiso de ejecucion
        0                  no                  no                    no
        1                  no                  no                    si
        2                  no                  si                    no
        3                  no                  si                    si
        4                  si                  no                    no
        5                  si                  no                    si
        6                  si                  si                    no
        7                  si                  si                    si

            Tabla 7.3: Especificacion de modos de acceso con notacion octal.

   # chmod 666 file
   # ls -l file
   -rw-rw-rw-    1 tony    users       1090 May 29 17:04 file
   # chmod 000 file
   # ls -l file
   ----------    1 tony    users       1090 May 29 17:04 file
   # chmod 755 file
   # ls -l file
   -rwxr-xr-x    1 tony    users       1090 May 29 17:04 file
   # chmod 700 file
   # ls -l file
   -rwx------    1 tony    users       1090 May 29 17:04 file

              Figura 7.23: Seteando permisos utilizando la notacion octal.

 7.6.3 CAMBIANDO EL DUE¥O Y EL GRUPO DE LOS ARCHIVOS

 Los comandos chown (change owner) y chgrp (change group) cambian el due¤o y
 el grupo asociados con un archivo. Estos comandos son usualmente utilizados
 cuando un usuario hereda archivos de otro usuario o cuando obtiene copias de
 archivos de otros usuarios. El siguiente comando cambiara el due¤o de todos
 los archivos del directorio actual al usuario juan:

  ==> chown juan *

 El nombre del nuevo due¤o debe ser un nombre de usuario valido o un numero
 de identificacion de usuario (UID) valido. Los nombres de usuarios y los
 respectivos UID's se encuentran en el archivo /etc/passwd. En algunas
 versiones de UNIX/Linux el comando chown solo esta permitido al superusuario.
 El siguiente comando asociara el grupo users con el archivo example.tex.gz:

  ==> chgrp users example.tex.gz

 Los grupos que se pueden utilizar con el comando chgrp pueden ser nombres de
 grupos o numeros de identificacion de grupos (GID) que se encuentran en el
 archivo /etc/group.


  Bueno hasta aca hemos llegado por hoy, espero que les haya gustado y les
  cuento lo que veremos en la segunda entrega:

   Veremos un poco las utilidades mas comunes que usamos en Linux y algunos
   otros comandos que andan por ahi (cap.8), como instalamos software
   adicional a nuestro sistema Linux (cap.9), como montar unidades (cap.10),
   tambien hablaremos un poco del kernel y los modulos (cap.11) y tambien
   profundizaremos un poco mas en los aspectos avanzados de la shell (cap.12).

   Bueno nos vemos en la segunda entrega de este manual de Linux.

                Create By Mr. Nuk3m (mr_nuk3m@usa.net)


=-=(04)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                    
                     @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ @@
                     @@                               @@
                     @@          'Pepe IBM'!!         @@
                     @@           by Alan May         @@
                     @@                               @@
                     @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ @@



 Bue, los dejo con esta pequenia historieta dedicada a todos los sysop's lo-
 cales, que en la major¡a de los casos, me odian.
 Gracias.

 Nota Nuk3m: Perdon por la interrupcion, pero queria decir que este texto
             es un poco viejo y que mas que nada es como un homenaje a los 
             SysOp's de BBS que de por cierto no hay que olvidarlos.

 Espero que disfruten de ella tanto como yo cuando la le¡ desp£es de escribir-
 la, un poco m s sobrio, por supuesto.
                                                        
                                                             Alan May.
                                                                        <PgDn>
                                
                                
                                
                                
                                

                                
                                [Voz en off:]

                         "Las historias de Pepe IBM"
                                 
                    "Hoy les ofrecemos: 'El juicio final'"      
                
               "Basado en hechos y personajes de la vida real."
                  





                                                                        <PgDn>
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

*******************************   1ra. Parte   *******************************

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Se¤ord Sysop:

        Zoy un nuevo uzuadio. Tengo nueve aniodz y rezi‚n me regaladon mi
primer modemd. Me  gusdar¡a sacar muuucchh¡simods archvitodz. Por favor d‚me
mucho mucho accezzo. Grazias.

                                        Pepito Ibm.
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Estimado Pepe.

        Te he dado m¡nimo acceso a la conferencia de chiquillos. Te sugerimos
que aprendas a escribir bien, y te ubiques realmente en el lugar que te 
corresponde en esta comunidad, antes de pretender majores niveles de
acceso.

                                        Sysop.                                        
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Se¤ord Sysop:

        No he podido hacer ning£n Download [noten que ya aprendi¢ algunos 
t‚rminos]. He tratado con uzando Xmodem, pero no andaba, despu‚sz trat‚ con
Zmodem y menoz. Pordfavor ayi£denme a Downgload sus archivoz.

                                        Pepito Ibm.
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Estimado Pepito:

        Sos un salame, pero me agrad s. Creemos que ten‚s un futuro potencial.
Te voy a decir que vamos a hacer. Te voy a ense¤ar a hacer download, pero,
para eso primero ten‚s que aprender a hacer Upload que es el proceso inverso.
[imag¡nense el cagaso del pendejito cuando ley¢ esto]. La pr¢xima vez que en-
tr‚s al BBS, llam me con la opci¢n CHAT y te explico como hacer Upload.

                                        Sysop.
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Se¤ord Sysop:

        Bueno.

                                        Pepito Ibm.
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


                [Transcripci¢n del primer chat con el sysop]


Seleccione: [M, A, E, C, G]: C

El operador del sistema ha sido Paginado!(*)

Eserando.......

El sysop esta aqui!


hola pepito, como est s?

NO CARRIER  (lleno de temor, pepito corta)


                                              (*)=[Copygright BBS Club, 1994] 
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ               
                
                [Transcripci¢n del segundo chat con el sysop]


Seleccione: [M, A, E, C, G]:

El operador del sistema ha sido Paginado!

Esperando...

El sysop esta aqui!


hola pepito!

[ larga pausa ]

hoola

Quer‚s que te ense¤e como hacer Upload, no?

[ larga pausa ]

si

Bueno, fij te como lo hago yo primero, no toqu‚s nada.


Exiting chat...


Seleccione: [M, A, E, C, G]: A


Seleccione: [U, D, C, S, G]: C

Cambiar a cu l Area?: 1

Cambiando al  rea 1...


Seleccione: [U, D, C, S, G]: U

Seleccione un protocolo:

<X> Xmodem
<Y> Ymodem
<Z> Zmodem 



El sysop est  aqui!


Bueno pepito, ahora ten‚s que decirle a tu programa que quer‚s hacer Upload,
apretando la tecla <PAGE UP> cuando quer s empezar la transferencia, OK?

bueno


Exiting chat...


Seleccione [X, Y, Z]: X

Ingrese nombre de archivo a subir: PELOTITA.ZIP

Upload en proceso...........

1 archivo(s) tranferido!


El sysop est  aqui!


viste que f cil que era pepito!

si

Bue, para hacer download ten‚s que hacer el proceso inverso. OK?


gracias,,.p or todo 

De nada, ah!, ya que estamos, que levantaste?

No se.....   me lo di¢ un amiguito.., creo que es algo llamado un virus.

NO CARRIER

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ               
                          
************************  2da.Parte (un a¤o despu‚s)  ************************

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ               

Estimado Sysop:

        Ya sub¡ los archivos por los que pregunt¢. Mi radio de upload es mejor 
que el de download. No me permitir¡a, por favor, pertenecer a otras  reas?

                                        Pepe.
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ               

Estimado Pepe:

        Est  bien, creo que te lo merec‚s. Te voy a dejar entrar en otras 
 reas.

        Ah! ya que estamos, quer¡a decirte que por favor no sig s leventando
esos archivos "cracked by" porque puedo tener problemas.

                                        Sysop.
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ               

Estimado Sysop:

        Porqu‚ no puedo entrar al  rea pornogr fica, que tengo que hacer?
        Por cualquier cosa, mi n£mero de documento es: 30.917.356

                                        Atentamente, Pepe.
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ               

Estimado Pepe:

        Te hac‚s la sincola para llamar ac , no?. No pod‚s llamar a otro
lugar, aunque sea por un tiempito????????

                                        sysop
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 

Estimado Sysop:

        Quiere decir que hay otros BBeses aparte de este?. Porqu‚ no me lo 
hab¡a dicho antes?!

                                        Pepe.
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 

Estimad¡simo Pepito querido.

        Pens‚ que vos lo sab¡as, es m s, este es uno de los peores.
        Prob  con:  The Hell Pit  +1 (617) 408-3357. (jeje)

                                        El SysOp.
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 


[El usuario no llama por unas cuantas semanas, est  muy ocupado descubriendo] 
[el gran mundo de los BBeses. Cuando decide llamar de nuevo hace un batch up-]
           [load de todo el soft que consigui¢ en su traves¡a.]


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 

Estimado Sysop:

        Aprend¡ a hacer phreaking la semana pasada!. Es a lot o' phun y no te
cobran cuando hac‚s download de philes. [evidentemente ha estado llamando a
algunos BBS's de hackers de E.E.U.U., suelen cambiar las 'F' por 'PH' como
modismo]. Entre todas las cosas te dejo un archivito que se llama BlueBeep,
que te va a ayudar a hacer phreaking!!.

                                        Pepe.
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 

Estimado Pepe:

        Hacer phreaking es meterse en l¡os. Acaso cre‚s que no se sabe de 
donde hac‚s todas esas llamadas? Si se sabe. Te sugiero la termin‚s con eso 
antes de que te met s a vos y a tus viejos en problemas.

                                        Sysop.
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 

Estimado Sysop:

        No se porque te parece mal lo que hago, yo no le veo nada de ilegal
a tomar de lo que nos corresponde a todos, las empresas privadas manejan 
los monopolios del pa¡s y nadie se queja, alguien tiene que hacer algo.

                                        Pepe.
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 

Estimado Pepe:

        Habl s tanta mierda, que apest s.

                                        Sysop
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 

Estimado Sysop:

        A uno de mis colegas del Legion of Doom [vieron!, les dije!] le pas¢ 
algo que se llama "getting busted", Que significa eso?

                                        Pepe.
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 

Estimado Pepe:

        Eso significa que lo metiron en cana!. Seguramente por phreaking,
Adem s seguramente que les dijo a los federales que vos tambi‚n est s involu-
crado, con tal de que le den una sentencia m s corta. Est s perdido, hijo. 
Es m s, te bajar‚ del sistema para evitarme problemas.

                                        Sysop.
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
     
      [Cuando el chico entra de nuevo al BBS, ve el siguiente mensaje:]


Muajajajajaja!

Maldito bastardo....
Tu acceso a sido disminu¡do a: NADA. Ahora no sos nada, y no pod‚s hacer nada
tampoco. No queremos volver a verte la jeta por el resto de nuestras vidas.

NO CARRIER

oso!...

NO CARRIER <click!>

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 

*******************************  3ra. Parte  *********************************

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 

     
     [Aproximadamente un mes despu‚s, el chico llama de nuevo bajo un] 
 [nombre asumido. Con asumido quiero decir que el sysop no puede hacer otra]
                 [cosa que asumir que es el pendejo este.]


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 

Estimado Sysop: 

        Soy un nuevo usuario y me gustar¡a tener much¡simos accesos as¡ puedo
hacer mucho upload y download. Thanx.

                                        Pepe Macintoch.
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 

Estimado Pepe Ibm.

        No has aprendido un carajo en los dos a¤os pasados, sos un salame.
        Si ten‚s un perro, espero que se muera.

                                        Sysop.
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 

Estimado Sysop:

        Que quieres decir con eso?, Soy un nuevo usuario. No he llamado a 
ning£n otro BBS antes.

                                        Pepe Macintoch
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 

Estimado Pepe Macintoch/Ibm/ o comoconchaseatunombre:

        Sos un pendejo muy infel¡z, y me est s haciendo la vida imposible,
tom telas de ac , antes que me viole a tu hermana con todas mis fuerzas.

                                        Com‚mela.
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 

Estimado Sysop:

        Mi hermana solo tiene 5 a¤os de edad...

[El sysop entra a chat]

El sysop est  aqui!


[El sysop levanta el tubo y grita:]

La Ê©ÄÕ é con  ûüýúüû cha ûüýþÿûúûüýþÿûú de tu ûú herm ûüýþÿûú
ûüýþÿûú ana!!! ûüýþÿ!!ûúûüýþÿûú !!!!!!!!!!!!!ûüýþÿûú!ûüýþÿûú!!
Ê©ûüýþÊ©ûüýþÊ©ûüýþÊ©ûüýþ
NO CARRIER

[Demasiado ruido en la linea, se corta la comunicaci¢n]

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 

*******************************  4ta. Parte  **********************************

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 

[El pendejo deja de llamar por un largo tiempo, a fin de que el sysop 
calmase un poco su histeria. En este intermedio, la federal cae a su casa
ha hacerle preguntas. No duda en contarles todo, incluso el botonaso nombra 
el BBS que ha estado llamando durante estos 2 a¤os, al cual adem s le debe 
sus primeros pasos en el tema. Imb‚cil.] 

[Despu‚s de caer bajo la presi¢n de la federal, llama al sysop para advertir-
le de lo sucedido. Falla, como siempre, NO CARRIER.]

[Despu‚s de reiterados intentos de logonearse bajo su verdadero nombre, ingre-
sa bajo la identidad de Pepe Honguito, (original, ah?) y deja un mail al 
Sysop:]


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 

Estimado Sysop:

        Solamente vengo a advertirle que alguien lo ha delatado ante la fede-
ral, y lo m s seguro es que vengan a hacerle preguntas acerca de posibles
actividades ilegales que se llevan a cabo ac . Yo que Ud. me esconder¡a.

                                        Pepe ib..,,,^^ 

la puta!!.... como se edita una l¡nea!!??.... la puta, la puta, puta.
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 

Estimado Pepe:

        Pendejo de mierda!!!!!. Que concha le dijiste a la federal!!!
Yo no estoy corriendo un BBS ilegal, en este mismo momento tengo ganas de 
dispararte, violarme a tu hermana y matar a tu perro a la vez!!%$^^%^##@$%
Mejor me tranquilizo...... Tocan la puerta!!!?. Espero que no sea la federal..

        Com‚mela, pendejo mal-parido y la perra que te pari¢.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 

******************************   5ta. Parte   ********************************

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 

[El sysop y el pendejo hacen aparici¢n en la corte. La sala est  llena de 
hackers y phreakers a punto de cumplir sentencia. En este momento desear¡a 
tener un rev¢lver...]


FISCAL :  Sr. Sysop, Ud. tiene un usuario en su sistema de BBS llamado 
          Pepe Ibm, es esto correcto?

SYSOP  :  No, sol¡a tenerlo como usuario, afortunadamente saqu‚ al infel¡z
          a tiempo.

DEFENSA:  Objeci¢n Su Se¤or¡a, es un pendejo, no un infel¡z.

JUEZ   :  Al lugar. Se¤or sysop, agradecer¡a se limitara a contestar lo que 
          se le pregunta.

PENDEJO:  No soy ninguna de esas dos cosas!

JUEZ,
FISCAL,
DEFENSA,
SYSOP,
al un¡sono: SI SOS!!!!



PENDEJO:  El vend¡a tarjetas de cr‚dito robadas!

JUEZ   :  Es cierto eso, Sr. Sysop?

SYSOP  :  Absolutamente no!!! Ese pendejo es un mentiroso!!!

FISCAL :  Su Se¤or¡a, Desear¡a entrar en receso para concretar un caso contra
          el Sr. Sysop.

SYSOP  :  QUE!!?  Le van a creer al culiado este!!?

DEFENSA: OBJECION! Esto no corresponde Su Se¤or¡a!

JUEZ   :  fuck you, esta corte entra en receso...



                        
                                   tHe EnD
            
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
                                  
                                   
                                   Ep¡logo
                                   ~~~~~~~

[Los padres del pendejo le llenaron los bolsillos de guita al Juez para evitar
la incriminaci¢n de su hijo. El sysop sufri¢ una condena de 2 a¤os por fraude
de cr‚dito.] 

   [Dos a¤os despu‚s, el sysop sali¢ de la c rcel, pero por poco tiempo.]
[Fue sentenciado a la silla el‚ctrica por los cargos de asesinato, abuso de 
animales, y violaci¢n de una ni¤a de 7 a¤os...]

[De todas formas pod¡a verse una agradable sonrisa en su rostro mientras 
estaba sentado en la silla esperando su fin...]

                                                          
                                                                Alan May.


Moraleja:
~~~~~~~~
Sysop's, no subestimen a ning£n usuario, por m s ingenuo que este aparente 
ser.



                         Cast en orden de importancia:

                 Yo como [todo lo que est  entre corchetes]
                            Pepe IBM como ‚l mismo
                     Sysop como: El Sysop, Sysop y sysop  


                                                                    Alan May



A todos aquellos que crean que estoy muy al pedo, quiero decirles que tienen
toda la raz¢n. Gracias por tomarse la molestia en leer esta estupid‚z, pasa 
que no ten¡a sue¤o, y, bue...

Tengo derecho a pedirles que este archivo no sea modificado?.... 

Si!! 

Gracias.


=-=(05)=-=-=-=-=#( Chistes, Humor, etc. )#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


                             !! LA CARAJADA !!   
                  ** Por que la vida sin humor es Nada **
                        http://get.to/la.carajada


ESTATUAS
~~~~~~~~

Son dos estatuas, un chico y una chica, desnudas una frente a la otra, en
medio de una plaza. En esto que se les aparece Dios y les dice:

- Hola  chicos, como llevan 200 a¤os uno frente al otro sin pesta¤ear y
  han sido buenas estatuas, les voy a conceder un deseo.

Las estatuas contestan al unisono:

- Nuestro deseo es ser humanos.

Y Dios contesta:

- Ese  deseo  es  muy  dificil, pero bueno, se lo concedere. Seran humanos
  durante 10 minutos, procuren aprovecharlos.

En esto que las dos estatuas se vuelven humanas.

Rapidamente bajan de los pedestales en los que estaban y se van detras de
unos matorrales.

Al momento empiezan a oirse ruidos:

- Ahh, asi asi, uyyyy segui segui, no pares ... Como me gusta, como lo
  disfruto !!!!

A los cinco minutos se acerca Dios y les dice:

- Dense prisa que solo les quedan 5 minutos.

Y detras de los matorrales se escucha a la estatua
femenina decir:

- Oiste?, date prisa ahora me toca a mi, tu sujetas
  a la paloma y yo me cago en ella.
 


VIEJITO
-------

Llega un viejito bien viejito  al cielo y se encuentra con Jesucristo 
y le pregunta?

 - A ver buen hombre quien eres tu?

Yo no me acuerdo bien. Yo solo recuerdo que hace muchos muchos a¤os
trabajaba en carpinteria y tenia un hijito muy pero muy lindo que se 
volvio famoso.

Jesus exclama:  !! Papa !

Y el viejito exclama : !! Pinocho!



Carta de una Chica Paname¤a que fue a estudiar a USA.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Queridos Papa y Mama:

Como esta todo por casa?
Ya han pasado tres meses desde que me vine para la universidad.
He estado un poco enredada para escribir y quiero decirles
que estoy muy apenada por mi falta de consideracion de no escribirles.
A continuacion los voy a actualizar, pero antes de continuar leyendo,
por favor tomen asiento.  No sigan leyendo hasta que esten sentados.

Listos?

Bien, en lo que a mi concierne, ya estoy bastante mejor.
La fractura de la cabeza y la contusion que me hice al saltar de la ventana
de mi dormitorio cuando este se incendio a la semana de mi llegada, ya casi
se ha terminado de sanar.  Solo estuve dos semanas en el hospital y se
puede decir que ya estoy viendo todos los colores de nuevo.

Por suerte, un dependiente de la estacion de gasolina de al frente de
mi dormitorio vio el fuego y vio cuando salte, de modo que llamo a los
bomberos y a la ambulancia.  Tambien el fue el unico que me visito al
hospital y, como no tenia donde vivir por el fuego de mi cuarto, fue lo
suficientemente amable para invitarme a compartir su apartamento con el.

En verdad es un cuarto en un sotano, pero esta bien arreglado.  Al
principio me molestaba un poco el carburador que tiene en la ducha, pero
ya me acostumbre.

El es buena gente y nos hemos enamorado profundamente y pensamos
casarnos.  Aun no hemos fijado la fecha, pero definitivo que sera
antes que se me empiece a notar la barriga.

Si, estoy embarazada de el!  Que alegria!  Siempre me acuerdo de lo
ansiosos que estaban de ser abuelos, por lo que se que nos recibiran con
el bebe y le daran el mismo amor, devocion y cari¤o que me dieron cuando
era ni¤a.

Nos hemos retrasado con lo de la boda porque Leroy tiene una infeccion y
sabemos que nos van a poner peros con lo de los examenes premaritales.

Como yo tambien me contagie, decidimos esperar a que nos hagan efecto
las inyecciones de penicilina.

Yo los conozco a ustedes y se que lo van a recibir con los brazos abiertos
como un miembro mas de la familia.  El es amable y aunque no tan bien
educado, es muy ambicioso. A pesar que su raza y religion son diferentes,
se que el amor de ustedes por mi no permitira que estos pequenos detalles se
pongan de por medio. Estoy segura que lo querran como yo. El viene de una
buena familia tambien, hasta donde se, su papa intercambia mercancia en la
calle o algo asi.

Bueno viejos, ahora quiero decirles que no hubo ningun fuego,
no tengo contusion ni fractura, no estuve en el hospital
y mucho menos estoy embarazada.
No estoy comprometida, ni enamorada, ni tengo sifilis.

Sin embargo, saque una "D" en Historia y una "F" en Biologia, y queria
que evaluaran esta situacion bajo la perspectiva apropiada.

      Los quiere,
      Fredeslinda.



CHAVEZ VISITA UN COLEGIO 
~~~~~~~~~~~~~~~~~~~~~~~~

Hugo Chavez fue a visitar una clase de 4to. grado de una escuela 
primaria. Su llegada se produjo durante una discusion acerca de las 
palabras y sus significados. La maestra pregunto al Presidente si le 
gustaria participar en la discusion sobre el significado de la palabra 
"tragedia". Entonces, el ilustrado lider pidio a la clase un ejemplo 
de "tragedia". 
  
Un peque¤o ni¤o se paro y dijo: "Si un amigo mio, esta jugando en la 
calle y lo atropella un auto, eso es una tragedia". 
  
"No", dijo Chavez. "Eso seria un accidente". 
  
Una peque¤a levanto su mano y dijo: "Si un bus de transporte escolar 
se desbarranca en un precipicio, muriendo todos sus ocupantes, eso 
seria una tragedia". 
  
"Me temo que no" sostuvo el Presidente. "A eso podriamos llamarlo una 
gran perdida". 
  
El silencio crecio en el aula. Ningun otro alumno se animo a dar una 
respuesta. Chavez los insto a continuar, diciendo: "Es que no hay 
nadie que pueda darme un ejemplo de lo que es una tragedia? 
  
Finalmente, en el fondo de la clase, un peque¤o muchacho levanto su 
mano y con voz muy tenue, se animo a decir: "Si el avion presidencial 
esta transportando al Sr. Presidente y a todo el Gabinete y un misil 
lo destruye, haciendolo a¤icos, eso seria una tragedia". 
  
"Fantastico", dijo Chavez. "Eso esta muy bien. Y podrias decirme por 
que eso seria una tragedia? " 
  
"Si" dijo el chico. "Porque, en primer lugar, no seria un accidente y 
en segundo lugar, tampoco seria una gran perdida". 
 


El Rey Arturo y la moraleja
~~~~~~~~~~~~~~~~~~~~~~~~~~~

El joven rey Arturo fue sorprendido y apresado por el monarca del
reino vecino mientras cazaba furtivamente en sus bosques. El rey pudo
haberlo matado en el acto, pues tal era el castigo para quienes violaban las
leyes de la propiedad, pero se conmovio ante la juventud y la simpatia de 
Arturo y le ofrecio la libertad, siempre y cuando en el plazo de un a¤o 
hallara la respuesta a una pregunta dificil.

La pregunta era: ¨Que quiere realmente la mujer?.

Semejante pregunta dejaria perplejo hasta al hombre mas sabio
y al joven Arturo le parecio imposible contestarla.

Con todo, aquello era mejor que morir ahorcado, de modo que regreso a
su reino y empezo a interrogar a la gente. A la princesa, a la reina, a las 
prostitutas, a los monjes, a los sabios y al bufon de la corte...en suma, a 
todos pero nadie le pudo dar una respuesta convincente.Eso si, todos le 
aconsejaron que consultara a la vieja bruja, pues solo ella sabria la 
respuesta.

El precio seria alto, ya que la vieja bruja era famosa en todo el reino por
el precio exorbitante que cobraba por sus servicios.

Llego el ultimo dia del a¤o convenido y Arturo no tuvo mas remedio que
consultar a la hechicera. Ella accedio a darle una respuesta
satisfactoria a condicion de que primero aceptara el precio: !Ella queria 
casarse con Gawain, el caballero mas noble de la Mesa Redonda y el mas 
intimo amigo de Arturo!. El joven Arturo le miro horrorizado: era jorobada y
feisima, tenia un solo diente, despedia un hedor que daba nauseas, hacia 
ruidos obscenos... Nunca se habia topado con una criatura tan repugnante.

Se acobardo ante la perspectiva de pedirle a su amigo de toda la vida
que  asumiera por el esa carga terrible. No obstante, al enterarse del
pacto  propuesto, Gawain afirmo que no era un sacrificio excesivo a
cambio de la vida de su compa¤ero y la preservacion de la Mesa Redonda.

Se anuncio la boda y la vieja bruja, con su sabiduria infernal, dijo:
Lo que realmente quiere la mujer es !ser la soberana de su propia vida!.

Todos supieron al instante que la hechicera habia dicho una gran
verdad y que el joven rey Arturo estaria a salvo. Asi fue: al oir la
respuesta, el monarca vecino le devolvio la libertad.

Pero menuda boda fue aquella,... asistio la corte en pleno y nadie se
sintio  mas desgarrado entre el alivio y la angustia, que el propio
Arturo. Gawain  se mostro cortes, gentil y respetuoso, La vieja bruja hizo 
gala de sus peores modales, engullo la comida directamente del plato sin 
usar los cubiertos, emitio ruidos y olores espantosos.
Llego la noche de bodas:  cuando Gawain, ya preparado para ir al lecho
nupcial aguardaba a que su esposa se reuniera con el,... ella aparecio
con el aspecto de la doncella mas hermosa que un hombre desearia ver!... 
Gawain quedo estupefacto y le pregunto que habia sucedido.
La joven respondio que como habia sido cortes con ella, la mitad del
tiempo se presentaria con su aspecto horrible y la otra mitad con su aspecto

atractivo.

¨Cual preferia para el dia y cual para la noche?

!Que pregunta cruel!... Gawain se apresuro a hacer calculos...¨queria
tener durante el dia a una joven adorable para exhibirla ante sus amigos y
por las noches en la privacidad de su alcoba a una bruja espantosa? O 
¨preferia tener de dia a una bruja y a una joven hermosa en los momentos 
intimos de su vida conyugal?...

¨Ustedes que hubieran preferido... que hubieran elegido?

La eleccion que hizo Gawain esta mas abajo, pero antes de leerla tomen
su decision...



El noble Gawain replico que la dejaria elegir por si misma. Al oir
esto, ella le anuncio que seria una hermosa dama de dia y de noche,
porque el la habia respetado y le habia permitido ser duena de su vida.



¨Cual es la moraleja?
------------------------------------------
------------------------------------------

LA MORALEJA ES QUE NO IMPORTA SI LA MUJER ES BONITA O FEA, EN EL FONDO
SIEMPRE ES UNA BRUJA.



16 MILAGROS EN AMERICA LATINA.
-- ---------   ------- -------

Un Argentino Humilde
Un Dominicano Blanco
Un chileno negro
Un costarricense macho
Un Boliviano Alegre
Un Peruano Simpatico
Un Salvadoreno pacifico
Un Panameno Inteligente
Un Puertoriqueno Inofensivo
Un hondureno Intelectual
Un colombiano Honesto.
Un Mexicano Sincero
Un Nicaraguense Disciplinado
Un Venezolano Abstemio
Un Brasileno Laborioso
UN Cubano Mudo



JAIMITO EN EL SALON DE CLASES
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Estando Jaimito dentro del salon de clases de su escuela primaria
sorpresivamente entra el inspector del Ministerio de Educacion Publica.
Comenta a la maestra que supresencia se debe a una visita para observar
el desarrollo de la clase, sentandose en una silla vacia (justo atras 
de Jaimito) e indicandole que continue con su clase.
La maestra continua y el inspector discretamente le se~ala  con  el dedo
hacia el ni~o  Jaimito, como para que le haga participar de la dinamica
de la clase.

La maestra, un poco nerviosa por la conducta natural de Jaimito , prepara
la pregunta de tal suerte que no pueda salir con una de sus vulgaridades:

 -  A ver Jaimito: ¿Recuerdas la clase de ayer en la que platicamos
    sobre la historia del Himno Nacional?
 -  Claro que me acuerdo maestra.
 -  ¿Recuerdas las afirmaciones del autor del himno? ... eso lo
    comentamos ayer Jaimito.
 -  Si maestra ... ya me acuerdo ... lo tengo en la punta de la lengua...
 Mientras la maestra esperaba la respuesta, nerviosamente jugaba con  un
 lapiz en su mano, que termina cayendose al suelo.
 Al inclinarse a recoger el lapiz dio lugar a mostrar sus lindos atributos
 fisicos.
 En eso, Jaimito continuo:
 -  Ya me acorde: "¡Que buen culo que tenes, perra!"
 La maestra molesta por la respuesta, le pide a Jaimito que salga del salon.
 Jaimito muy serio recoge sus cuadernos y libros e indignado voltea hacia el
 inspector y le dice:
 -  ¡¡¡Concha de tu madre, si no sabes para que mierda soplas!!!

 Colaboracion de Diego Campos
 Desde Buenos Aires - Argentina


 Comprendiendo a los Ingenieros - Toma Uno,
 *****************************************
 Dos estudiantes de ingenieria estaban caminando por el campus cuando
 uno de ellos dijo: "De  donde sacaste esa magnifica bicicleta ?" El
 segundo contesto: "Bueno,  Yo estaba caminando por ahi ayer, pensando 
 en mis trabajos, cuando una hermosa mujer aparecio sobre esta bicicleta.
 Tiro la bicicleta al suelo, se saco toda su ropa y dijo:
 "Toma lo que  quieras". El segundo ingeniero cabeceo afirmativamente:
 "Buena  eleccion! La ropa probablemente no te hubiera entrado !".

 Comprendiendo a los Ingenieros - Toma Dos
 *****************************************
 Un arquitecto, un artista y un ingeniero estaban discutiendo acerca de
 si era  mejor pasar el rato con la mujer o con la amante. El arquitecto
 dijo que disfrutaba pasar el tiempo con su mujer, construyendo una base
 solida para una relacion duradera. El artista dijo que disfrutaba pasar
 el tiempo con su amante, porque con ella encontraba pasion y misterio. 
 El  ingeniero dijo: -"A mi me gustan las dos" -"Las Dos?!" "Si. Si tienes
 una mujer y una amante, cada una de ellas asumira que estas pasando el 
 rato con la otra, y puedes ir a tratar de completar el curso que estas
 haciendo y dejar el trabajo terminado!"  h ttp://get.to/la.carajada

 Comprendiendo a los Ingenieros - Toma Tres
 ******************************************
 Cual es la diferencia entre los ingenieros y los arquitectos ?
 Los ingenieros construyen armas, los arquitectos construyen blancos.

 Comprendiendo a los Ingenieros - Toma Cuatro
 ********************************************
 Para el optimista, el vaso esta medio lleno.
 Para el pesimista, el vaso esta medio vacio.
 Para el ingeniero, el vaso es el doble de grande de lo que deberia  ser.

 Comprendiendo a los Ingenieros - Toma Cinco
 *******************************************
 "Un Ingeniero y su Sapo"
 Un ingeniero estaba cruzando una ruta un dia, cuando un sapo lo llamo
 y le dijo:"Si me besas,  me volvere una hermosa princesa". El ingeniero se
 inclino y tomo el  sapo y se lo metio en el  bolsillo. El sapo volvio a
 hablar, y dijo: "Si me besas para que me  vuelva una hermosa princesa, me
 quedare contigo durante una semana". El ingeniero saco el sapo del
 bolsillo, le sonrio y lo  volvio a meter en el bolsillo. Entonces el sapo
 grito: "Si me besas y  me vuelvo  una hermosa princesa, me quedare contigo
 y hare CUALQUIER cosa que  quieras" Otra  vez el ingeniero saco el sapo,le
 sonrio y lo devolvio al bolsillo.
 Finalmente  el sapo pregunto: "Que pasa? Te dije que soy una hermosa
 princesa, que me quedare contigo por una semana y hare lo que quieras. Por
 que no me  besas?" El ingeniero dijo: "Mira, soy un ingeniero. No tengo
 tiempo para novias, pero un sapo que hable, eso si que es interesante !!"

 Colaboracion de Diana Patricia Piedrahita.
 Desde Cali - colombia

 CARACTER DE LOS HOMBRES SEGUN SU FORMA DE MEAR
 
 
 El sapientisimo doctor de meologia Profesor Urinoski graduado en la 
 excelentisima universidad de h ttp://get.to/la.carajada, tras profundas y
 largas investigaciones sobre la relacion: "Dime como meas y te dire quien
 eres", ha definido el caracter de los hombres segun su forma de mear asi:
 
 1.CIENTIFICO: Mira al suelo mientras mea y al mismo tiempo examina las
 burbujas.
 
 2.DeBIL: Busca desesperadamente entre la camisa y el pantalon y luego
 renuncia.
 
 3.DESPREOCUPADO: Mea en el lavamanos si todas las pocetas estan ocupadas.
 
 4.DISTRAIDO: Se desabrocha el chaleco, se saca la corbata y se mea en los
 pantalones.
 
 5.FANFARRON: Se desabrocha cinco botones para sacarselo cuando con dos
 tiene suficiente.
 
 6.INFANTIL: Dirige el chorro hacia arriba y hacia abajo intentando cazar
 moscas o tratando de llegar mas alto.
 
 7.INSIDIOSO: Deja escapar un silencioso pedo, luego olfatea y mira
 acusadamente al vecino.
 
 8.NERVIOSO: No encuentra el cierre, desgarra el cinturon y se arranca los
 botones.
 
 9.PRACTICO: Mea sin agarrarselo y al mismo tiempo se arregla la corbata.
 
 10.PULCRO: Se la saca con un ligero pellizco y dirige el chorro tratando
 de limpiar la  poceta.
 
 11.SOCIABLE: Se junta con los amigos para una meada social y colectiva,
 tanto si hubiese tenido ganas como si no.
 
 12.SO~OLIENTO: Se mea dentro de los pantalones y en los zapatos, luego se
 va con el cierre abierto y no se da cuenta hasta que alguien se lo
 advierte.
 
 13.TIMIDO: No puede mear cuando alguien le mira, hace como si ya hubiera
 meado, se cierra el cierre y se  escabulle sigilosamente.
 
 14.TeCNICO: Puede mear desde cualquier distancia al orinal, calculando
 ademas que el chorro entre por uno de los orificios.
 
 15.LIDER POSITIVO: Induce a las demas personas a mear en el momento justo
 dedesespero colectivo
 
 16.LIDER NEGATIVO: Induce a las demas personas a mear en el momento que le
 da la gana, a pesar de que que las demas no quieran o no tengan ganas.
 
 17.POLIFACeTICO: Logra mear, cagar, sacarse un moco y tirarse un pedo al
 mismo tiempo.
 
 18.TERCO: Mea cuando se le da la gana por encima de la voluntad de su
 ri~on y su vejiga.
 
 19.VANIDOSO: Mira al espejo mientras mea, y en los casos mas dramaticos
 instala un espejo enfrente del orinal.
 
 20.ESQUIZOFRENICO: No tiene ningun inconveniente en mear en la caneca de
 la cocina, el lavamanos, la ducha, los closets, la nevera, las materas, un
 par de zapatos, detras de un cuadro,la chimenea o una cartera de mujer
 abandonada en el suelo.
 
 21.LATINOAMERICANO TRADICIONAL: Se baja del carro en la mitad de un trancon,
 no pone luces de parqueo, obstruyendo preferiblemente el tercer carril y
 busca una pared cercana. Sin importarle las personas que esten a su
 alrededor, lo saca al aire, donde con su chorro deja un letrero alusivo a
 su equipo de futbol. Como no se puede lavar las manos despues
 de la operacion, vuelve al carro no sin antes ser insultado por las
 personas afectadas por el trancon que genero. Llega a su casa, abraza a su
 esposa a hijos y raspa la olla del arroz dejando un sabor inconfundible en
 la comida de toda su familia. Si la comida es pollo por ejemplo, despues
 de acabar, se chupa los dedos y finalmente se acuesta a dormir luego de
 una jornada extensa. Al dia siguiente no se ba~a por que va tarde para la
 oficina, y lo primero que hace es saludar a su jefe con la misma mano. Mas
 tarde se saca un moco y lo pega por detras de computador (junto a los seis
 chicles de la semana pasada) para terminar de completar su faena.
 
 Nota Nuk3m: Espero que ninguno de los que lean esto, se haya ofendido con
             algun chiste. Es es solamente, UN CHISTE y no pretendo ofender
             a nadie ni discriminar a nadie.


=-=(06)=-=-=-=-=#( Mail del lector )#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


 Bueno por ahora Nada, pero espero que para el segundo numero haya algunos...


=-=(07)=-=-=-=-=#( Llave PGP )#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: PGPfreeware 6.5.1 Int. for non-commercial use <http://www.pgpinternational.com>
Comment: # Mr. Nuk3m # mr_nukem@mixmail.com # 31173.freeservers.com #

mQGiBDiQ2XYRBADbqan9+SxWv1uISw9SEE+gX6sWvLVz66i4OBA7SVtGcaNXmTNH
Sn7etA4ko44zZuYnpwRvrquseslhNTcR4RMa11udg6ws5Wz40ci6EGJW0Y07/TQt
x4IP+5oMm45z5YCBJLOoFflHZY9V3iJk9aJy5uWHsDs8v1uJKVFHVTlBrQCg/34W
pj4BOYi6W58JoU7Z/mW3o4sEAJpMpqL04dZE53vdXsqx4jOfDOz9MNbJOxE/HRm+
r0TKydSIkRWLJxWEzEqogcLUWk6yQIPXIUHClQFfvwssKoeLB2RgHgXrErDGthyw
ym80qke/TcxC0Wz4lBJhmAQh+gCZja5jntkdj7sYtb0Bb2nkbHmf21314j+IUjva
6k5RA/wM8ywo5pZUYvHypnQDqBo4eG+2W6YEd1nZGSZ9MMPQbucKSM6Ai27gKfEF
k8d35Vf4ndWYorucuefS7f9JssyKYBaK9mhpBKOu5vy1lqQXmAk1E0hFLPmcI0jZ
O0yNfmRX5C47qIp6QhL5tcAOe2RmHKvi6DNwQgzdx4/NFonMB7QgTXIuIE51azNt
IDxtcl9udWtlbUBtaXhtYWlsLmNvbT6JAE4EEBECAA4FAjiQ2XYECwMCAQIZAQAK
CRAKv3Qb7n1etvsxAKDe7kspxWdVl/9grzF3LG6K1pltGgCfQRYJTQxS+t4dmWQv
fkYTf9+CUMa5Ag0EOJDZeRAIAPZCV7cIfwgXcqK61qlC8wXo+VMROU+28W65Szgg
2gGnVqMU6Y9AVfPQB8bLQ6mUrfdMZIZJ+AyDvWXpF9Sh01D49Vlf3HZSTz09jdvO
meFXklnN/biudE/F/Ha8g8VHMGHOfMlm/xX5u/2RXscBqtNbno2gpXI61Brwv0YA
WCvl9Ij9WE5J280gtJ3kkQc2azNsOA1FHQ98iLMcfFstjvbzySPAQ/ClWxiNjrtV
jLhdONM0/XwXV0OjHRhs3jMhLLUq/zzhsSlAGBGNfISnCnLWhsQDGcgHKXrKlQzZ
lp+r0ApQmwJG0wg9ZqRdQZ+cfL2JSyIZJrqrol7DVekyCzsAAgIH/3izPREGY0IB
5dLdgNi2QukTjy6VEbYuCbQG+RIN0g2kWCpQHCfKRi6lZpyHzusO3M1zPf0MRvHH
RPZSJhGhpO4+AKmf3vcigEHtJ/sdLR5sicqjgSSB9mQAaUDCxaAwCOLscLNP/eiu
RoWQgfb6L7a1MCn7qOSxd6e86YmIX8ebICKeyJiDwd1gNWrMIqACxMOwrbeBZuSD
NYLIAHqQ5tS12+WQbgt2mC86UW6vtJbRz7rAz0osQ4cnk6ppw8FH2JZ0Koss6X1+
rKyG4Gpd87dD6tIO3KbbyWIHDSjohUD66SFl1nnyiYm0v7lbsRonVMmvnDddGR6o
cnJqxAgkNeiJAEYEGBECAAYFAjiQ2XkACgkQCr90G+59XrakbQCdFhBKaFPsHZrF
Yv/3RI9M+eYrX44AmwaMLdC9l6KEBgn2xLC5aAIuXW3P
=NdHy
-----END PGP PUBLIC KEY BLOCK-----


=-=(08)=-=-=-=-=#( Despedida )#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Bueno no queda mucho por decir, y el proximo numero saldra cuando este listo
y espero que sea realmente en Marzo y si es que no me lleva mucho tiempo.

Anticipamos lo que vamos a ver en el numero 2 de CIA: 

 La segunda parte del manual de Linux, algunos textos perdidos por ahi,
 comentamos algunos programas, quizas tengamos alguna colaboracion,
 tendremos algunos textos viejos, que quizas a mas de uno se le caiga
 una lagrimita ;.) ja ja y alguna que otra cosa...

Espero verlos en la proxima...

Saludos...

Mr. Nuk3m
mr_nuk3m@usa.net
CIA Magazine
Febrero del 2000

[%]=-=[%]=-=[%]=-=[%]=-=[%]=-=[%]=-=[%]=-=[%]=-=[%]=-=[%]=-=[%]=-=[%]=-=[%]=-=
