<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>Structured Exception Handling</title>
<style type="text/css">
</head>

<body bgcolor="#909090" text="#000000" link="#0000FF"
vlink="#E02866">

<p>A:link{text-decoration:underline}
A:visited{text-decoration:underline}
A:active{text-decoration:underline;color: red}
A:hover{text-decoration:underline;color: #8080FF}</style> </p>

<table border="1" width="700" height="22">
    <tr>
        <td width="530"><p align="center">SEH aka Structured
        Exception Handling<br>
        <font size="3">(Sveliamo l'arcano?)</font></p>
        </td>
    </tr>
    <tr>
        <td width="530" bgcolor="#FFFFEA"><p align="center">by
        &quot;Quequero&quot; </p>
        <dl>
            <dt>Home page: <a
                href="http://www.uic-spippolatori.com">http://www.uic-spippolatori.com</a>
            </dt>
            <dt>E-mail: UIC@mail.usa.com</dt>
            <dt>Server: irc.azzurra.it canale: #crack-it</dt>
        </dl>
        </td>
    </tr>
    <tr>
        <td width="530" bgcolor="#C6E7C6"><p align="center">Pubblicato
        grazie alla collaborazione della UIC <a
        href="http://www.uic-spippolatori.com">(www.uic-spippolatori.com)</a></p>
        </td>
    </tr>
    <tr>
        <td width="530"><p align="center"><i>Hihihi è troppo
        stramitico scrivere commenti sul proprio tute, cmq non
        pretendo di far luce su tutto ciò che concerne le SEH in
        quanto mi sarei dovuto addentrare troppo in argomenti che
        avrebbero portato via troppo tempo, cmq il mio scopo era
        incuriosirvi e spero di esserci riuscito.</i></p>
        </td>
    </tr>
    
    <tr>
        <td width="530" bgcolor="#C6E7C6"><p align="center"><font
        color="#0000FF"> ( )<b>NewBies </b>( )<b>Intermedio</b>
        (X)<b>Avanzato</b> ( )<b>Master</b></font> </p>
        </td>
    </tr>
</table>

<p>Structured Exception Handling...Cosa significa...Ma piuttosto,
a cosa servono?</p>

<hr>

<dl>
    <div align="center"><center>
    <dt>SEH aka Structured Exception Handling<br>
        <font size="3">(Sveliamo l'arcano?)</font></dt>
    </center></div><div align="center"><center>
    <dt><font color="#0B7FC1">Written by Quequero</font><br>
        <br>
    </dt>
    </center></div>
</dl>

<table border="1" width="700" height="22">
    <tr>
        <td bgcolor="#C6E7C6"><p align="center"><font
        color="#0000FF" size="4">Introduzione</font><font
        size="4"> </font></p>
        </td>
    </tr>
</table>

<dl>
    <dt>L'argomento delle SEH è stato poco (o per nulla)
        trattato in italia, gli unici riferimenti li ho trovati
        su un tutorial di Kill3xx ma cmq vengono solo accennate.
        Io mi prodigherò ad approfondire questo
        interessantissimo argomento.</dt>
</dl>

<table border="1" width="700" height="22">
    <tr>
        <td bgcolor="#C6E7C6"><p align="center"><font
        color="#0000FF" size="4">Tools usati</font></p>
        </td>
    </tr>
</table>

<dl>
    <dt><a href="http://uic.server101.com/Tools.html">TASM</a>
        (Se vi interessa di fare qualche prova)</dt>
</dl>

<table border="1" width="700" height="22">
    <tr>
        <td bgcolor="#C6E7C6"><p align="center"><font
        color="#0000FF" size="4">Essay</font> </p>
        </td>
    </tr>
</table>

<dl>
    <dt>Erano mesi che aspettavo l'ispirazione per iniziare
        questo tutorial su uno degli aspetti più interessanti
        che la programmazione in Win32 ci offre...La gestione
        delle eccezioni.</dt>
    <dt>Con in bocca il mio caro bastoncino alla liquirizia
        accingerò a far luce su questo interessantissimo aspetto
        della programmazione...Ma prima di tutto voglio
        ringraziare J. Gordon per il so completissimo tutorial
        sulle SEH, ed infatti questo tutorial è ispirato al suo.
        Tanto per inziare vediamo cos'è un'eccezione:</dt>
    <dt>Avete presente quello strano box che raramente vedete su
        windows recante la caption &quot;General Protection
        Fault&quot; che ha quella strana icona che riporta una X
        bianca su sfondo rosso? No vero? Ci avrei giurato.</dt>
    <dt>Allora avete presente quello schermo blu che ogni tanto
        (molto raramente) vi si presenta a schermo e che reca
        alcune parole come &quot;Errore&quot;,
        &quot;Irreversibile&quot;, &quot;Imminente
        distruzione&quot;? Neanche questo? Eddai, l'hanno fatto
        vedere pure alla presentazione di WinTonno 98.....Lo
        vedete che avete capito? :)<br>
        Esattamente, quando un programma genera un'errore
        (un'eccezione appunto) crasha e windows si prende
        &quot;la fatica&quot; di farlo chiudere e di sistemare le
        cose. Come tutti sapete quando un programma crasha si
        hanno due possibili soluzioni: La chiusura stessa del
        programma oppure il blocco totale del sistema giusto? È
        proprio WinSalame che decide cosa deve succedere,
        ovviamente la scelta non è affatto arbitraria ma anzi è
        accuratamente ponderata, peccato che il sistema conosca
        solo due soluzioni, mentre io ve ne farò scoprire
        svariate altre :).</dt>
    <dt>In realtà le eccezioni sono usate parecchio dal sistema,
        un esempio è questo: supponiamo che un thread abbia
        bisogno di più stack, l'idea principale sarebbe quella
        di monitorare lo spazio che sta usando e dargli più
        stack quando non c'è più memoria disponibile, ma ciò
        porterebbe via molte risorse oltre che spazio nel
        programma finale, allora si installa un Exception Handler
        (ovvero un Gestore di Eccezioni) che con pochissime
        risorse e poco spazio controlla una sola cosa: appena il
        thread ha raggiunto il limite massimo di stack il sistema
        segnala un'errore che verrà controllato dal NOSTRO
        handler e non da quello di win, il nostro handler
        provvederà quindi ad allargare lo stack, il tutto
        succede in modo enormemente veloce e senza spreco inutile
        di risorse, ma entriamo nel dettaglio.</dt>
    <dt>Windows si preoccupa di monitorare con un Exception
        Handler ogni thread avviato, la posizione di questo
        Exception Handler si trova in fs:[0<font color="#000000"
        size="3">], ogni errore nel codice fa si che il controllo
        passi a questo Handler che controllerà in sequenza
        queste cose (grazie a J. Gordon per l'elenco):</font></dt>
    <dd>&nbsp;</dd>
    <dd><font color="#000000" size="3">1) WinSuino controlla se
        ci sono altri Handler disposti a controllare l'eccezione
        e se il programma è debuggato allora notifica al
        debugger che è accaduta un'eccezione (ecco spiegata la
        funzione &quot;faults on&quot; di SoftIce :)</font></dd>
    <dd>&nbsp;</dd>
    <dd><font color="#000000" size="3">2) Se non ci sono debugger
        presenti e se il programma non è neanche sotto debugging
        allora il sistema si preoccupa di vedere se noi abbiamo
        installato un Handler sul thread (per-Thread Handler) e
        va quindi a spulciare nel TIB (Thread Information Block)
        che si trova all'indirizzo fs:</font>[0<font
        color="#000000" size="3">]</font></dd>
    <dd>&nbsp;</dd>
    <dd><font color="#000000" size="3">3) Se esiste un per-Thread
        Handler disposto a dialogare con l'eccezione allora gli
        passa il totale controllo, ma questo Handler potrebbe a
        sua volta passare il controllo ad altri Handler della
        catena</font></dd>
    <dd>&nbsp;</dd>
    <dd><font color="#000000" size="3">4) Se nessun Handler
        dialoga con l'eccezione ma il programma è sotto debug
        allora il sistema prova nuovamente a notificare l'evento
        al debugger</font></dd>
    <dd>&nbsp;</dd>
    <dd><font color="#000000" size="3">5) Se non accade nulla di
        positivo allora il controllo passa al Final Handler (che
        dobbiamo settare noi)</font></dd>
    <dt>&nbsp;</dt>
    <dd><font color="#000000" size="3">6) Se il nostro Final
        Handler non è in grado di fare nulla allora il controllo
        passa al System Final Handler, verrà mostrato il solito
        box di GPF oppure verrà attivato un debugger, se il
        programma non può passare il controllo al debugger
        allora un sano ExitProcess farà la sua comparsa :)</font></dd>
    <dt>&nbsp;</dt>
    <dd><font color="#000000" size="3">7) Prima di terminare
        definitivamente il programma, il sistema si preoccupa di
        ripulire lo stack nella zona dove è accaduta
        l'eccezione.</font></dd>
    <dt>&nbsp;</dt>
    <dt><font color="#000000" size="3">Ed ora dovreste potervi
        accorgere delle potenzialità delle SEH, se avete capito
        potete interagire completamente ed abbastanza
        &quot;invisibilmente&quot; su qualunque tipo di codice,
        potete anche gestire voi stessi gli errori del programma
        e quindi il vostro codice sarà molto ma molto più
        robusto e poi durante la fase di debugging le SEH sono
        davvero utilissime.</font></dt>
    <dt><font color="#000000" size="3">Chi ha una discreta
        dimistichezza col C/C++ conoscerà sicuramente le varie
        istruzioni _throw, _try, _except e se fate una ricerca
        sul web a riguardo delle SEH troverete principalmente
        listati C/C++ con queste istruzioni, ma difficilmente
        scoprirete cosa c'è dietro. Effettivamente utilizzare
        l'assembly conviene perchè è più veloce, ma
        nell'installazione di un Handler l'assembly è
        ENORMEMENTE più veloce ed ESTREMAMENTE più compatto del
        C.</font></dt>
    <dt><font color="#000000" size="3">Prima di iniziare con
        qualche esempio di codice dobbiamo fare una distinzione,
        di Handler infatti ne esistono due tipi, il primo si
        chiama Final Handler e si installa nel Thread principale
        del programma ed il secondo si chiama per-Thread Handler
        che come dice la parola stessa si installa all'inizio di
        ogni thread, facciamo un exempio di Final Handler:</font></dt>
    <dd>&nbsp;</dd>
    <dt><font color="#000000" size="2" face="Courier New">Start: </font></dt>
    <dt><font color="#000000" size="2" face="Courier New">push
        offset Final_Handler</font></dt>
    <dt><font size="2" face="Courier New">call
        SetUnhandledExceptionFilter</font></dt>
    <dd>&nbsp;</dd>
    <dt><font size="2" face="Courier New">....snip....</font></dt>
    <dt><font size="2" face="Courier New">....normale codice del
        programma....</font></dt>
    <dt><font size="2" face="Courier New">....snip....</font></dt>
    <dd>&nbsp;</dd>
    <dt><font size="2" face="Courier New">call ExitProcess</font></dt>
    <dt><font size="2" face="Courier New">;----------------------
        </font></dt>
    <dt><font size="2" face="Courier New">Final_Handler:</font></dt>
    <dt><font size="2" face="Courier New">....snip....</font></dt>
    <dt><font size="2" face="Courier New">....codice di
        chiusura....</font></dt>
    <dt><font size="2" face="Courier New">....qualche altra
        cosa....</font></dt>
    <dt><font size="2" face="Courier New">....un box di
        saluti....</font></dt>
    <dt><font size="2" face="Courier New">....snip....</font></dt>
    <dt><font size="2" face="Courier New">mov eax,
        X&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; eax = 0 ---&gt;
        Mostra il box di chiusura</font></dt>
    <dd><font size="2" face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ; eax = 1 ---&gt; Nascondi il box di chiusura</font></dd>
    <dt><font size="2" face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ; eax = -1 ---&gt; Ricarica il contesto e continua</font></dt>
    <dt><font size="2" face="Courier New">ret</font></dt>
    <dd>&nbsp;</dd>
    <dt>Cosa succede? All'inizio del programma viene installato
        un Final Handler che resterà sul Thread principale del
        programma, mi sembra palese ricordare che prima lo
        installate meglio è, se durante il programma dovesse
        incorrere un errore che noi non ci aspettiamo allora il
        sistema seguirà gli step di sopra, se supponiamo di aver
        settato SoftIce a &quot;faults off&quot; allora il
        processo di gestione dell'Exception si fermerà al 5°
        Step e poi il programma verrà chiuso.</dt>
    <dt>Come vedete il Final Handler è l'ultima spiaggia nel
        quale il sistema cerca riparo, ma fa sempre uso di API e
        cmq il livello di libertà che noi abbiamo resta cmq
        molto basso, proviamo quindi a vedere come si installa un
        per-Thread Handler, ricordiamo che la prima DWORD puntata
        da &quot;fs&quot; è la struttura di errore, mentre la
        seconda DWORD è l'indirizzo dell'ExceptionHandler:</dt>
    <dt>&nbsp;</dt>
    <dt><font color="#000000" size="2" face="Courier New">Start: </font></dt>
    <dt><font size="2" face="Courier New">push offset
        ExceptionHandler&nbsp; ; Salviamo la posizione del NOSTRO
        Handler<br>
        push fs:[0]
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ; Salviamo nello stack la posizione della struttura di
        errore<br>
        mov&nbsp; fs:[0], esp<br>
        ...<br>
        ...<br>
        ...<br>
        pop fs:[0]
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ; Rimettiamo tutto a posto...<br>
        add esp, 4
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ; ...e sistemiamo lo stack<br>
        ret<br>
        ;----------------------<br>
        ExceptionHandler:<br>
        ...<br>
        ...<br>
        ...<br>
        mov eax, X
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ; eax = 1 ---&gt; Passa al prossimo Handler della catena<br>
        ret
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ; eax = 0 ---&gt; Ricarica il contesto e continua
        l'esecuzione</font></dt>
    <dd>&nbsp;</dd>
    <dt>Ora sappiamo come si installano questi due tipi di
        Handler, ma prima di vedere come si usano facciamo luce
        su una cosa, ovvero la Struttura di Errore, questa è una
        parte importantissima perchè solo grazie alla struttura
        di errore noi possiamo sapere dove è accaduta
        l'eccezione e soprattutto possiamo conoscere il tipo di
        eccezione.</dt>
    <dt>Sappiamo che la prima DWORD puntata da fs:[0<font
        color="#000000" size="3">] è la struttura di errore che
        ha sua volta punta a questa struttura:</font></dt>
    <dd>&nbsp;</dd>
    <dd><table border="1" width="50%">
            <tr>
                <td width="56%">EXCEPTION_RECORD +0</td>
                <td width="55%">ExceptionCode</td>
            </tr>
            <tr>
                <td width="56%">EXCEPTION_RECORD +4</td>
                <td width="55%">ExceptionFlag</td>
            </tr>
            <tr>
                <td width="56%">EXCEPTION_RECORD +8</td>
                <td width="55%">NestedExceptionRecord</td>
            </tr>
            <tr>
                <td width="56%">EXCEPTION_RECORD +C</td>
                <td width="55%">ExceptionAddress</td>
            </tr>
            <tr>
                <td width="56%">EXCEPTION_RECORD +10</td>
                <td width="55%">NumberParameters</td>
            </tr>
            <tr>
                <td width="56%">EXCEPTION_RECORD +14</td>
                <td width="55%">AdditionalData</td>
            </tr>
        </table>
    </dd>
    <dt><font color="#000000" size="3">ottenere questi dati è
        semplicissimo, all'interno del codice del nostro
        Exception Handler basta fare:</font></dt>
    <dd>&nbsp;</dd>
    <dt><font size="2" face="Courier New">mov edx, dword
        ptr[ebp+8]</font></dt>
    <dd>&nbsp;</dd>
    <dt><font color="#000000" size="3">quindi basta sapere che:</font></dt>
    <dt>&nbsp;</dt>
    <dd><table border="1" width="28%">
            <tr>
                <td width="17%">Edx+0 </td>
                <td width="83%">ExceptionCode</td>
            </tr>
            <tr>
                <td width="17%">Edx+4</td>
                <td width="83%">ExceptionFlag</td>
            </tr>
            <tr>
                <td width="17%">Edx+8</td>
                <td width="83%">NestedExceptionRecord</td>
            </tr>
            <tr>
                <td width="17%">Edx+C</td>
                <td width="83%">ExceptionAddress</td>
            </tr>
            <tr>
                <td width="17%">Edx+10</td>
                <td width="83%">NumberParameters</td>
            </tr>
            <tr>
                <td width="17%">Edx+14</td>
                <td width="83%">AdditionalData</td>
            </tr>
        </table>
    </dd>
    <dt><font color="#000000" size="3">così un semplicissimo:</font></dt>
    <dd>&nbsp;</dd>
    <dt><font color="#000000" size="2" face="Courier New">cmp
        dword ptr[edx</font><font size="2" face="Courier New">],
        ExceptionCode</font></dt>
    <dt>&nbsp;</dt>
    <dt>basta a farci sapere che tipo di eccezione è, ed un
        altrettanto semplice:</dt>
    <dd>&nbsp;</dd>
    <dt><font color="#000000" size="2" face="Courier New">mov
        eax, dword ptr[edx</font><font size="2"
        face="Courier New">+0Ch]</font></dt>
    <dd>&nbsp;</dd>
    <dt>serve a farci conoscere dove è avvenuta l'eccezione,
        bello non credete?</dt>
    <dt>Ora che conosciamo anche la struttura di errore vi mostro
        quali sono i più comuni codici di errore e quindi faremo
        qualche esperimento:</dt>
    <dd>&nbsp;</dd>
    <dt><font size="2" face="Courier New">C0000094h&nbsp;&nbsp;&nbsp;
        ; Divisione per 0<br>
        C0000025h&nbsp;&nbsp;&nbsp; ; Non continuabile, non si
        deve dialogare con l'Exception e si deve chiudere il prg<br>
        C0000026h&nbsp;&nbsp;&nbsp; ; Interrupt Exception<br>
        80000003h&nbsp;&nbsp;&nbsp; ; BreakPoint occorso (INT3)<br>
        C0000095h&nbsp;&nbsp;&nbsp; ; Integer Overlow<br>
        80000004h&nbsp;&nbsp;&nbsp; ; Single Step<br>
        C0000005h&nbsp;&nbsp;&nbsp; ; Read or Write Memory
        Violation<br>
        C000001Dh&nbsp;&nbsp;&nbsp; ; Invalid Opcode</font></dt>
    <dt><font size="2" face="Courier New">C00000FDh&nbsp;&nbsp;&nbsp;
        ; Lo stack ha raggiunto la massima dimensione disponibile</font></dt>
    <dt><font size="2" face="Courier New">80000001h&nbsp;&nbsp;&nbsp;
        ; Violazione di pagina settata con VirtualAlloc</font></dt>
    <dd>&nbsp;</dd>
    <dt>solo due codici necessitano di una spiegazione, il primo
        è C00000095h, ovvero Integer Overflow, questa eccezione
        accade quanto durante un operazione un registro si trova
        a dover contenere una cifra troppo grande, il secondo
        codice è 80000004h, ovvero Single Step, l'eccezione di
        Single Step accade quanto viene settato il TrapFlag, se
        il processore vede che questo flag è settato allora
        genera questa eccezione per ogni riga di codice che
        esegue. Bene, sperimentiamo ora l'uso di un Exception
        Handler per-Thread:</dt>
    <dd>&nbsp;</dd>
    <dt><font size="2" face="Courier New">.data</font></dt>
    <dt><font size="2" face="Courier New">Div0&nbsp;&nbsp;&nbsp;
        db &quot;Division by 0 occurred&quot;,0</font></dt>
    <dt><font size="2" face="Courier New">Brk&nbsp;&nbsp;&nbsp;&nbsp;
        db &quot;Int3 occurred&quot;,0</font></dt>
    <dd>&nbsp;</dd>
    <dt><font size="2" face="Courier New">.code</font></dt>
    <dt><font color="#000000" size="2" face="Courier New">Start: </font></dt>
    <dt><font size="2" face="Courier New">push offset
        ExceptionHandler&nbsp; ; Salviamo la posizione del NOSTRO
        Handler<br>
        push fs:[0]
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ; Salviamo nello stack la posizione della struttura di
        errore<br>
        mov&nbsp; fs:[0], esp</font></dt>
    <dt><font size="2" face="Courier New"><br>
        xor eax, eax</font></dt>
    <dt><font size="2" face="Courier New">div eax
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ; Olè, divisione per 0</font></dt>
    <dt><font size="2" face="Courier New">int 3
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ; Ed anche un INT3 :))</font></dt>
    <dt><font size="2" face="Courier New"><br>
        pop fs:[0]
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ; Rimettiamo tutto a posto...<br>
        add esp, 4
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ; ...e sistemiamo lo stack<br>
        call ExitProcess, NULL<br>
        ;----------------------<br>
        ExceptionHandler&nbsp; PROC c, EF, ContextRecord, DC<br>
        push ebx
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ; Il manuale Intel ci impone di salvare<br>
        push edi
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ; ebx, edi ed esi prima di effettuare<br>
        push esi
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ; questa operazione<br>
        mov edx, dword ptr[ebp+8]<br>
        pop esi<br>
        pop edi<br>
        pop ebx</font></dt>
    <dt><font size="2" face="Courier New">cmp dword ptr[ebx],
        0C0000094h ; Divisione per 0</font></dt>
    <dt><font size="2" face="Courier New">jne continue</font></dt>
    <dt><font size="2" face="Courier New">call </font><font
        size="2">DivisionBy0</font></dt>
    <dt><font size="2" face="Courier New">continue:</font></dt>
    <dt><font size="2" face="Courier New">cmp dword ptr[ebx],
        80000003h&nbsp; ; BreakPoint occorso (INT3)</font></dt>
    <dt><font size="2" face="Courier New">jne exit</font></dt>
    <dt><font size="2" face="Courier New">call BreakOccurred</font></dt>
    <dd>&nbsp;</dd>
    <dt><font size="2" face="Courier New">exit:</font></dt>
    <dt><font size="2" face="Courier New">mov eax, 0<br>
        ret</font></dt>
    <dt><font size="2" face="Courier New">ExHandler&nbsp;&nbsp;&nbsp;
        ENDP</font></dt>
    <dt><font size="2" face="Courier New">;----------------------<br>
        Divisionby0&nbsp;&nbsp;&nbsp; PROC</font></dt>
    <dt><font size="2" face="Courier New">push MB_OK</font></dt>
    <dt><font size="2" face="Courier New">push NULL</font></dt>
    <dt><font size="2" face="Courier New">push offset Div0</font></dt>
    <dt><font size="2" face="Courier New">push NULL</font></dt>
    <dt><font size="2" face="Courier New">call MessageBoxA</font></dt>
    <dt><font size="2" face="Courier New">Divisionby0&nbsp;&nbsp;&nbsp;
        ENDP</font></dt>
    <dt><font size="2" face="Courier New">ret</font></dt>
    <dt><font size="2" face="Courier New">;----------------------<br>
        BreakOccurred</font>&nbsp;&nbsp;&nbsp; <font size="2">PROC</font></dt>
    <dt><font size="2" face="Courier New">push MB_OK</font></dt>
    <dt><font size="2" face="Courier New">push NULL</font></dt>
    <dt><font size="2" face="Courier New">push offset Brk</font></dt>
    <dt><font size="2" face="Courier New">push NULL</font></dt>
    <dt><font size="2" face="Courier New">call MessageBoxA</font></dt>
    <dt><font size="2" face="Courier New">BreakOccurred</font><font
        size="2">&nbsp;&nbsp;&nbsp; ENDP</font></dt>
    <dt><font size="2" face="Courier New">ret</font></dt>
    <dt><font size="2" face="Courier New">;----------------------<br>
        </font></dt>
    <dt><font size="3">E come per magia quando andrete a steppare
        nel codice non solo non crasherà nulla (ricordatevi di
        disabilitare i breakpoint) ma anzi, vedrete anche
        apparire da chissà dove una messagebox, ora provate ad
        immaginare questo stesso procedimento in un eseguibile di
        100-150kb e provate a vedere il Disasm.....Già, nessuna
        reference e quindi una confusione totale, specie per i
        più NewBies che non capiranno MAI dove andar a mettere
        le mani :)</font></dt>
    <dt><font size="3">Ora che abbiamo sperimentato (e capito)
        cosa sono gli Handler passiamo ad approfondire la
        funzione della struttura di errore, per ora conosciamo
        solo due parametri: </font>ExceptionCode, e
        ExceptionAddress....Sono i più intuitivi, ma gli altri?</dt>
    <dt><em>Exception flag</em>:&nbsp;&nbsp;&nbsp;&nbsp; 0
        ----&gt; Eccezione continuabile, possiamo ripararla</dt>
    <dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        1 ----&gt; Eccezione non continuabile, non possiamo
        ripararla</dd>
    <dt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        2 ----&gt; Lo stack è dipanato, non possiamo (e NON
        dobbiamo) neanche provare a ripararla</dt>
    <dd>&nbsp;</dd>
    <dt><em>Nested exception record</em>: punta ad un altro
        EXCEPTION_RECORD, nel caso che il nostro Handler
        generasse da solo un'eccezione :))</dt>
    <dd>&nbsp;</dd>
    <dt><em>NumberParameters</em>: Numero di DWORD da seguire in
        Additional Information</dt>
    <dd>&nbsp;</dd>
    <dt><em>Additional information</em>: Sono informazioni
        inviate dall'applicazione quando si chiama
        RaiseException, se invece il codice di errore è
        C0000005h allora i valori contenuti dalla prima DWORD
        saranno:</dt>
    <dt>0 ----&gt; Violazione di lettura</dt>
    <dt>1 ----&gt; Violazione di scrittura</dt>
    <dt>Al momento della chiamata al per-Thread Handler ESP+C
        punta al Context che contiene tutte le specifiche dei
        registri al momento dell'eccezione (il context si ottiene
        anche chiamando GetThreadContext) ed è:</dt>
    <dt><font size="2" face="Courier New">+0 context flags<br>
        DEBUG REGISTERS<br>
        +4 debug register #0<br>
        +8 debug register #1<br>
        +C debug register #2<br>
        +10 debug register #3<br>
        +14 debug register #6<br>
        +18 debug register #7<br>
        FLOATING POINT / MMX registers<br>
        +1C ControlWord<br>
        +20 StatusWord<br>
        +24 TagWord<br>
        +28 ErrorOffset<br>
        +2C ErrorSelector<br>
        +30 DataOffset<br>
        +34 DataSelector<br>
        +38 FP registers x 8 (10 bytes each)<br>
        +88 Cr0NpxState<br>
        SEGMENT REGISTERS<br>
        +8C gs register<br>
        +90 fs register<br>
        +94 es register<br>
        +98 ds register<br>
        ORDINARY REGISTERS<br>
        +9C edi register<br>
        +A0 esi register<br>
        +A4 ebx register<br>
        +A8 edx register<br>
        +AC ecx register<br>
        +B0 eax register<br>
        CONTROL REGISTERS<br>
        +B4 ebp register<br>
        +B8 eip register<br>
        +BC cs register<br>
        +C0 eflags register<br>
        +C4 esp register<br>
        +C8 ss register</font></dt>
    <dd>&nbsp;</dd>
    <dt>Ed è anche l'unico luogo dal quale potete cambiare il
        valore di EIP (per maggiori info aprite il mitico
        Winnt.h), questa in pratica è la &quot;sala dei
        bottoni&quot; del vostro processore, da qua dentro fate
        proprio tutto :) anche quello che non potreste fare
        altrimenti :). </dt>
    <dt>Esp+8 punta invece ad una NOSTRA struttura di errore,
        mentre Esp+4 punta all'EXCEPTION_RECORD.</dt>
    <dt>Finito qui? Niente affatto, se succede un qualche tipo di
        errore cosa facciamo? Beh, prima di chiudere il programma
        dobbiamo constatare se l'eccezione è riparabile, se si
        allora possiamo fare qualcosa di davvero carino, appena
        viene invocato l'Handler ESP+8 punta alla nostra
        struttura di errore che è così formata:</dt>
    <dd>&nbsp;</dd>
    <dd><table border="1" width="50%">
            <tr>
                <td width="20%">STRUTTURA+0</td>
                <td width="80%">Pointer to next ERR structure</td>
            </tr>
            <tr>
                <td width="20%">STRUTTURA+4</td>
                <td width="80%">Pointer to own exception handler</td>
            </tr>
            <tr>
                <td width="20%">STRUTTURA+8</td>
                <td width="80%">Code address of
                &quot;safe-place&quot; for handler</td>
            </tr>
            <tr>
                <td width="20%">STRUTTURA+C</td>
                <td width="80%">Information for handler</td>
            </tr>
            <tr>
                <td width="20%">STRUTTURA+10</td>
                <td width="80%">Area for flags</td>
            </tr>
            <tr>
                <td width="20%">STRUTTURA+14</td>
                <td width="80%">Value of EBP at safe-place</td>
            </tr>
        </table>
    </dd>
    <dt>vi garantisco che non è poco, infatti i valori contenuti
        da STRUTTURA+8 e STRUTTURA+14h sono importantissimi, ci
        consentono infatti di far continuare l'esecuzione del
        programma in un &quot;luogo-sicuro&quot; (se l'eccezione
        non è recuperabile allora si chiama RtlUnwind e pazienza
        :) quindi la prima cosa da fare è vedere se l'eccezione
        è continuabile, se si allora si estrae dalla nostra
        struttura di errore l'indirizzo del luogo-sicuro
        (STRUTTURA+8) e quello del nostro nuovo EBP
        (STRUTTURA+14h), quindi si estrae il CONTEXT e da li
        dentro si manipola <font size="2" face="Courier New">CONTEXT+B4
        (registro ebp)</font>ponendolo uguale al valore suggerito
        da STRUTTURA+8 e poi si manipola <font size="2"
        face="Courier New">CONTEXT+B8 (registro eip)</font>ponendolo
        uguale a STRUTTURA+14h, in questo modo l'EIP verrà
        cambiato ed il codice continuerà allegramente dove è in
        grado di prolificare :), vi riporto del codice di J.
        Gordon:</dt>
    <dd>&nbsp;</dd>
    <dt><font size="2" face="Courier New">MYFUNCTION:&nbsp; ;
        procedura di entry point<br>
        PUSH EBP&nbsp;&nbsp;&nbsp;&nbsp; ; salva ebp, usato per
        indirizzare lo Stack Frame</font></dt>
    <dt><font size="2" face="Courier New">MOV EBP,ESP&nbsp; ; usa
        EBP come stack frame pointer &nbsp; <br>
        SUB ESP,40h&nbsp; ; 16 DWORD di spazio per i dati locali
        e la struttura di Errore</font></dt>
    <dt><font size="2" face="Courier New">; Installa l'handler <br>
        PUSH EBP&nbsp;&nbsp;&nbsp;&nbsp; ; STRUTTURA+14h salva
        EBP che si trova al luogo-sicuro</font></dt>
    <dt><font size="2" face="Courier New">PUSH
        0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; STRUTTURA+10h
        area per i flags<br>
        PUSH 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;
        STRUTTURA+0Ch informazioni informazioni per l'handler<br>
        PUSH OFFSET SAFE_PLACE&nbsp; ; STRUTTURA+8h nuovo eip al
        luogo-sicuro<br>
        PUSH OFFSET HANDLER&nbsp;&nbsp;&nbsp;&nbsp; ;
        STRUTTURA+4h indirizzo dell'handler<br>
        PUSH
        FS:[0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ; STRUTTURA+0h tieni la STRUTTURA all'inizio della catena<br>
        MOV
        FS:[0],ESP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ; Punta alla STRUTTURA appena creata sullo stack<br>
        ...
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ; Il codice protetto dall'Handler va qui<br>
        ...<br>
        ...<br>
        JMP &gt;L10
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ; Se non ci sono state eccezioni salta<br>
        SAFE_PLACE: <br>
        L10:<br>
        POP FS:[0] <br>
        MOV ESP,EBP<br>
        POP EBP<br>
        RET<br>
        ;*****************<br>
        HANDLER:</font></dt>
    <dt><font size="2" face="Courier New">...<br>
        ...<br>
        ...<br>
        ...<br>
        RET<br>
        </font></dt>
    <dt>come vedete il codice non è troppo difficile, ma bisogna
        applicarsi un attimo per poterlo capire a dovere, nelle
        applicazioni con più di un thread sarete costretti a
        dover usare solamente il Final Handler e non potrete
        settare dei comodi per-Thread Handler. La potenza delle
        SEH non finisce qui, infatti potete agire sui DrX o sui
        CrX senza per questo dover andare a Ring0, se invece
        volete andare a ring0 non dovete far altro che settare
        nel context l'eip e 0x28 e vi ritroverete come per magia
        nel paradiso di WinCinghiale, ovver un luogo dove sarete
        perennemente a ring0 :) a così potrete anche utilizzare
        a piacere i DrX che sono comodissimi per monitorare
        locazioni di memoria od altro, ma di questo ne parlerò
        nel prossimo tutorial, un salutone a tutti e rileggete
        tutto con moltissima attenzione altrimenti non ci
        capirete nulla.</dt>
</dl>

<p align="right">Quequero</p>

<table border="1" width="700" height="22">
    <tr>
        <td bgcolor="#C6E7C6"><dl>
            <div align="center"><center>
            <dt><font color="#0000FF" size="4">Note finali</font><font
                size="4"> </font></dt>
            </center></div>
        </dl>
        </td>
    </tr>
</table>

<dl>
    <dt>Il primo ringraziamento va sicuramente a Kill3xx che mi
        ha tremendamente incuriosito con queste SEH e che poi si
        è anche preso la fatica di darmi alcune spiegazione,
        senza di lui questo tute non sarebbe mai esistito, il
        secondo ringraziamento va a J. Gordon per il suo tute
        sulle SEH, peccato che il codice è tremendamente
        incasinato :), ringrazio anche Olga che resta sempre una
        grandissima amica e soprattutto è l'unica reverser con
        la quale posso parlare seriamente di tutte le cose avendo
        sempre la certezza che si disturberà di starmi a sentire
        e di rispondermi....E lei si merita un grazie troppo
        grande, grazie Alguzza :).</dt>
    <dt>Saluto poi tutti gli amici di #Crack-it (si, anche quelli
        che scrivono dove non devono :), i fratellini Spp,
        N0body88 che si prodiga ogni giorni di farmi sapere le
        sue buone nuove :)), un salutone particolare anche a
        \Spirit\ che è stato con me ed i miei amici sorbendosi
        tutte le nostre domande, accompagnandoci in giro per la
        città e facendoci provare dei cocktail davvero SUPERIORI
        :), grazie anche a Xunil per gli aiuti via tel che mi da,
        a Brigante per avermi spedito quelle cose, a phobos che
        è troppo simpatico anche quando diffonde le mie foto
        :))) e ad andreageddon col qualche ancora devo fare a
        botte....Dai andre muoviti, un saluto anche a baron-sam
        che credo sia defunto :P e spinone che oggi mi ha
        chiamato dalla tunisia....È inutile che menti tanto si
        sentiva il fiatone del tunisino che lavorava &quot;alle
        tue spalle&quot; :), ciao gente.</dt>
</dl>

<table border="1" width="700" height="22">
    <tr>
        <td bgcolor="#C6E7C6"><p align="center"><font
        color="#0000FF" size="4">Disclaimer</font> </p>
        </td>
    </tr>
</table>

<dl>
    <dt><i>Vorrei ricordare che il software va comprato e&nbsp;
        non rubato, dovete registrare il vostro prodotto dopo il
        periodo di valutazione. Non mi ritengo responsabile per
        eventuali danni causati al vostro computer determinati
        dall'uso improprio di questo tutorial. Questo documento
        è stato scritto per invogliare il consumatore a
        registrare legalmente i propri programmi, e non a fargli
        fare uso dei tantissimi file crack presenti in rete,
        infatti tale documento aiuta a comprendere lo sforzo
        immane che ogni singolo programmatore ha dovuto portare
        avanti per fornire ai rispettivi consumatori i migliori
        prodotti possibili. </i></dt>
    <dt><i>Noi reversiamo al solo scopo informativo e di
        miglioramento del linguaggio Assembly.</i></dt>
    <dt><i>Capitoooooooo????? Bhè credo di si ;))))&nbsp; </i> </dt>
</dl>

<hr>
</body>
</html>
