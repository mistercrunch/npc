<HTML>
<HEAD>
</HEAD>
<BODY  bgcolor=#FFFFFF HEIGHT=100 WIDTH=89 TEXT=#000000 LINK=#0000FF VLINK=#FF0000>

<img src="http://www.b4b0.org/images/barwhit.gif" alt="">
<A NAME="section-1"><H1>CLASS 5</H1></A>
<img src="http://www.b4b0.org/images/barwhit.gif" alt="">

<H3>Assembly Language.</H3>

Assembly language is the one language into which all other languages are
translated or interpreted.  Compilers translate high level languages
into assembly language.  We'll discuss compilers a little more later in
the course, but it's really a complex topic in its own right.
 <P>

Because Assembly Language must be a good language for compiling or
interpreting many different languages, it is intentionally very simple.
It provides all of the necessary capabilities required for high level
languages, but does so using simple instructions that can be combined in
many different ways to support different languages.  This is called
FLEXIBILITY. 
 <P>
<hr>
<center>
<H3>Example of a specific Assembly Language: SPARC Assembly</H3>
</center>

<H3> Sparc Architecture : A Brief Overview</H3>
<p>
<H4>Registers</H4>

The SPARC Architecture specifies that a SPARC CPU has 32 registers, in
four sets:
<UL>
<LI>  global,
<LI>  in,
<LI>  local, and
<LI>  out.
</UL>

Registers are denoted by the presence of a percent sign in their name:
<UL>
<LI>  Globals:  %g0 through %g7
<LI>  Ins: %i0 through %i7.
<LI>  Locals: %l0 through %l7.
<LI>  Outs: %o0 through %o7.
</UL>

When you put data in a register, it overwrites whatever was there
(register writes are <I>destructive</I>; the old data is destroyed).
Once you put data into a register, it stays there until you put
something else there instead.  

<P>
<ul>
<LI><b>global:</b> used for global register data, can be used in entire prog.
          <br>
          Referred to as %g0 to %g7 (or %r0 to %r7)
          <br>
          %g0 - discards writes and returns a zero
          <br>
          others are ordinary registers

<P>
<LI><b>out:</b>    used for temporaries, for passing arguments to functions,
          <br>
         and for obtaining returned values from functions
          <br>
         Referred to as %o0 to %o7 (or %r8 to %r15)
          <br>
         %o6 also referred to as %sp (Stack Pointer)
          <br>
         %o7 reserved for called subroutine return address

<P>
<LI><b>local:</b>  used for local function variables, all program variables are
          <br>
         generally stored in these registers.
          <br>
         Referred to as %l0 to %l7 (or %r16 to %r23)

<P>
<LI><b>in:</b>     contain calling function arguments.
          <br>
         referred to as %i0 to %i7 (or %r24 to %r31)
          <br>
         %i6 also referred to as %fp (Frame pointer)
          <br>
         %i7 stores the subroutine return address
</ul>

<P>
See table on page 44 of textbook for details.


<P>
<BR>
<H3>The Sparc Assembler (as) </H3>
A <b>two-pass assembler</b>, and is line based (like all assemblers)
<br>
<b>Comments</b> as in C ( /* and  */)  ( not as in C++)
<br>
Comments also line based, start with ! 

<P>
<b>Psuedo-operations (psuedo-ops)</b>  - These instructions do not 
generate any machine instructions, but only provide some information 
to the assembler. They usually start with a period (.) e.g. 
<br>
<B>.global</B> (for label to be accessible outside the function),
<br>
<B>.word</B> (for initializing a merory location), etc. 

<P>
<B>How does assembly work??</B><BR>
All "C" programs have a .c extension (<b>source code</b>)
<br>
The compilation results in the .o file (<b>object file</b>)
<br>
The .o files are linked and we get the executable file,  a.out

<P>
The compilation is a two step process:
<PRE>
Step1:   C program converted into .s file (assembly language)
Step2:   .s file converted to .o file (using the assembler)
</PRE>

<P>
To convert a C program into the corresponding assembly
language, we use the instruction<BR>
<B>gcc -S program.c</B>

<P>
To execute the .s file, <BR>
<B>gcc -g file.s -o &lt;filename&gt;</b>

<p> 
So, the entire process of creating an executable can be summed up as :

<pre>
Source Code (filename.c)    
    ||
    ||  (compiler, such as gcc -S filename.c
    \/
Assembly Language  (filename.s)
    ||
    ||  (assembler, such as gcc -c filename.s)
    \/
Object Code (filename.o)
    ||
    ||  (Linker/Loader, ld filename.o
    \/
Binary file (executable, such as a.out)
</pre>


<P>
<h2> Format of Instructions </h2>
Any instruction is made up of two parts:
<P>
<b>Opcode</b> (the name of the instruction)<BR>
<b>Operands</b> (the values or data manipulated by the instruction)
<P>
The opcode is necessary in every instruction, but the operand
may or maynot be present.

<P>
Most of the instructions in SPARC have three operands: three registers,
or two registers and a literal constant.

<pre>
opcode  operand 1 (optional), operand 2 (optional), operand 3 (optional) 
 add       %r1             ,     %r2	        ,   %r3
 sub       %r1             ,     %r2	        ,   %r3
 mov       %r1             ,     %r2	
</pre>

<P>
The contents of the first register are combined with those of the
second register or literal constant, and the result is stored in the
third register.

<P>
Some instructions are:<BR>
clr r1 (clear register r1, r1 has to be a valid register name)
<P>
mov r1(or c), r2 (move the contents of r1 or the literal constant c to r2)
<P>
add r1, r2(or c), r3 (add r1 and r2(or c), store result in r3) 
<P>
sub r1, r2(or c), r3 (subtract r2(or c) from r1, store result in r3) 
<P>

The format of an instruction is:
<PRE>
        op      reg, reg_or_imm, reg
</PRE>

<PRE>
        clr reg                     !   sets a register to all zeros
        mov reg_or_imm reg          !   copy data from one reg to another
        add reg1 reg2_or_imm reg3   !   reg1 + reg2_or_imm = reg3
        sub reg1 reg2_or_imm reg3   !   reg1 - reg2_or_imm = reg3
</PRE>
<b> Note: </b> Anything after the "!" on a line is ignored by the assembler,
and is treated as a comment. 

<P>
An immediate value is data encoded right in the instruction. Like this:
<PRE>
     add %o1, 13, %o2                
</PRE>


<P>
When the program is run, some memory has to be allocated for 
it. This is done using the command<BR>
<B>save %sp, -64, %sp</B>

<p>
<H4> MACROS IN ASSEMBLY LANGUAGE </H4> 

They are used to giving <B>symbols</B> 
for <b>numeric constants</b>. Symbols are defined using the `<b>define</b>' 
macro. e.g.<BR>
define(x, l0)
<br>
define(y, l1)

<P>
Some other simple instructions:<BR>
<b>labels</b> -- why are they used, how are they defined?
<PRE>
e.g.   _main:     save %sp, -64, %sp
</PRE>
Here, <B>_main</B> is the label for the main function. All programs 
need to have the main function, as control starts from this function. 


<h2> Our First Program </h2>

Take a look at the following piece of code. All this code does is to 
calculate the value of a polynomial. The code is in C (though it is 
the same for C++ in this case.) Let us suppose that the code is 
stored in a file <b>first.c</b>. The code is given below: 

<pre><hr>
<b> /* first.c */ </b>

void main() 
{
  int x , y ; 

  y = (x - 1) * (x - 7) / (x - 13) ; 
  
  exit(0) ; 
}
<hr></pre>


We can compile this code by using the gcc compiler (GNU C compiler).
To get the assembly  code corresponding to this code, we use the 
-S option. i.e. 

<p>
<b> gcc -S first.c </b> 

<p>
We now get a file called <b>first.s</b> in the current directory, which
is the assembly file. This is what it looks like: 

<pre><hr>
<b> /* first.s */ </b>

gcc2_compiled.:
___gnu_compiled_c:
.text
        .align 	4
        .global _main
        .proc   020
_main:
        !#PROLOGUE# 0
        save 	%sp, -112, %sp
        !#PROLOGUE# 1
        call 	___main,0
        nop
        ld 	[%fp-12], %o1
        add 	%o1,-1, %o0
        ld 	[%fp-12], %o2
        add 	%o2,-7, %o1
        call 	.umul, 0
        nop
        ld 	[%fp-12], %o2
        add 	%o2, -13, %o1
        call 	.div, 0
        nop
        st 	%o0, [%fp-16]
        mov 	0, %o0
        call 	_exit, 0
        nop
L1:
        ret
        restore
<hr></pre>

This code does look a lot complicated, so we will take up a 
simplified version of it, and go through it step by step. 
Actually, this simplified version of the code does the same 
thing, i.e. calculate the value of the expression, but is 
well commented, and easier to understand. 

<p>
For convenience, we first create a file called <b>first.m</b> 
which is not the assembly code, but very close to it. It is the
code written using some macros, and needs to be processed by a 
macro-processor before it can be converted into assembly language 
code.

<p>
p.s. If you are wondering that Macro's are, remember <b>#define</b> in 
     C/C++ ??  

<p>
Look at the following file: 

<pre><hr>
<B> /* first.m */ </B> 

/* This programs computes the expression:
    y = (x - 1) * (x - 7) / (x -13) for x = 9
The polynomial coefficients are:
*/
	define(a2, 1)
	define(a1, 7)
	define(a0, 11)

/* Variables x and y are stored in %l0 and %l1 */

	define(x_r, l0)
	define(y_r, l1)

	.global _main
_main:	save    %sp, -64, %sp
	mov	9, %x_r		!initialize x
	sub	%x_r, a2, %o0	!(x - a2) into %o0
	sub	%x_r, a1, %o1	!(x - a1) into %o1
	call	.mul
	nop			!result in %o0
	sub	%x_r, a0, %o1	!(x - a0) into %o1, the divisor
	call	.div
	nop			!result in %o0
	mov	%o0, %y_r	!store it in y

	mov	1, %g1		!trap dispatch
	ta	0		!trap to system
<hr></pre>

This is not actually assembly language, as there is no instruction
called <b>define</b> in assembly language. But the <b>define</b> 
statements are used by the to just give a symbolic name to the 
constants, i.e. a2 stands for 1, a1 stands for 7, etc. in the 
code given. 

<p>
To convert this code into assmbly language, we need to pass it 
through a M4 macro-processor. To do that, we use the following 
command: 

<p>
<b> m4 &lt; first.m > first.s  </b>

<p>
This creates the new assembly language file from the .m file. 
The assembly language file is given below: 

<pre><hr>
<B> /* first.s */ </B>

/* This programs computes the expression:
    y = (x - 1) * (x - 7) / (x -13) for x = 9
The polynomial coefficients are:
*/

/* Variables x and y are stored in %l0 and %l1 */

        .global _main
_main:  save    %sp, -64, %sp
        mov     9, %l0          !initialize x
        sub     %l0, 1, %o0     !(x - 1) into %o0
        sub     %l0, 7, %o1     !(x - 7) into %o1
        call    .mul
        nop                     !result in %o0
        sub     %l0, 11, %o1    !(x - 11) into %o1, the divisor
        call    .div
        nop                     !result in %o0
        mov     %o0, %l1        !store it in y

        mov     1, %g1          !trap dispatch
        ta      0               !trap to system
<hr></pre>

If you notice, all the define statements are gone, and the 
variables a0, a1, a2 are all replaced by their corresponding 
values in this code. The only disadvantage is that this file 
is a lot more difficult to read and debug as compared to the 
previous file, especially in the case when a lot of variables 
have the same values, i.e. if a0, a1, a2 had the same value,
say 1, you would not know which variable is being referred to. 

<p>
Also, x_r and y_r are replaced by l0 and l1 in the entire file. 

We will look at the program in more detail in the next class. For
now, lets just compile it to get the executable. To do that, type 
the following command: 

<p>
<b>gcc first.s -o first </b>

<p>
This just produces the executable called first. To execute the file,
just type the filename (<b>first</b>) on the command prompt. 

<pre><hr>
colossus><b>first</b>
colossus>
<hr></pre>

What happened? Well, your program ran successfully, but there was no 
output, the reason being that there are no input/output statements in
your code. So it just executed the segment of code, calculated the 
value of y, and then ended. So how do we know if we did the right thing
or not? Well, to find out, we use something called a debugger. We'll 
talk about it in more detail in one of the later classes. For now, this
much is enough!! Bye :-)

<P>
<img src="http://www.b4b0.org/images/barwhit.gif" alt="">
<H3>
For class 6 notes, <A HREF="class6.html">click here</A>
</H3>

<img src="http://www.b4b0.org/images/barwhit.gif" alt="">
<H3>
For more information, contact me at <A HREF="mailto:tvohra@mtu.edu">tvohra@mtu.edu</A>
</H3>

</BODY>
</HTML>
