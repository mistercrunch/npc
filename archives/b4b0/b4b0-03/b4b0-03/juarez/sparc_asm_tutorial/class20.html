<HTML>
<HEAD>
</HEAD>
<BODY bgcolor=#FFFFFF HEIGHT=100 WIDTH=89 TEXT=#000000 LINK=#0000FF VLINK=#FF0000>

<img src="http://www.b4b0.org/images/barwhit.gif" alt="">
<A NAME="section-1"><H1>CLASS 20</H1></A>
<img src="http://www.b4b0.org/images/barwhit.gif" alt="">

<center>
<H2>Leaf Suboutines</H2>
</center>

<P>
A leaf subroutine is one that does not call any other subroutine. A
simpler calling method might be used for the <b>leaf</b> subroutines.

<P>
A leaf subroutine uses only the <b>first six out registers</b>, and the <b>global
registers %g0 and %g1</b>.

<P>
A leaf routine <b>does not execute a save or a restore</b> instruction. e.g. of 
such subroutines: <b>.mul, .div</b>, etc.

<P>
Here, the <b>return address is (%o7 + 8)</b>, (and <b>not %i7 + 8</b>)

<P>
There is a synthetic instruction for that:

<Pre>
<b>retl
==&gt; jmpl %o7,  8, %g0 </b>
</Pre>

<P>
If the subroutine <b>foo</b> in the previous example is written as a leaf
subroutine, then it should have the following code:


<PRE>
        define(a8_s, arg8_s)
        define(a7_s, arg7_s)
        define(a6_r, o5)
        define(a5_r, o4)
        define(a4_r, o3)
        define(a3_r, o2)
        define(a2_r, o1)
        define(a1_r, o0)

        .global _foo

_foo:   add     %a2_r, %a1_r, %o0       !o0 = first + second
        add     %a3_r, %o0, %o0         !o0 += third argument
        add     %a4_r, %o0, %o0         !o0 += fourth argument
        add     %a5_r, %o0, %o0         !o0 += fifth argument
        add     %a6_r, %o0, %o0         !o0 += sixth argument
        ld      [%sp + a7_s], %o1       !the seventh argument
        add     %o1, %o0, %o0           !o0 += seventh argument
        ld      [%sp + a8_s], %o1       !the eighth argument
        retl
        add     %o1, %o0, %o0           !o0 += eighth argument
</PRE>


<hr>
<center>
<H2>Pointers as arguments to Subroutines</H2>
</center>

Consider the following example: 

<PRE>
swap (int *x, int *y)
{  int temp;
   temp = *x;
   *x = *y;
   *y = temp;
}
</PRE>

<P>
The corresponding assemply code is given below:

<PRE>
	define(x_s, -4)
	define(y_s, -8)

       .global _main
_main: save %sp, (-64 -8) &amp; -8, %sp
        mov     5, %o0
        st      %o0, [%fp + x_s]        !x = 5
        mov     7, %o0
        st      %o0, [%fp + y_s]        !y = 7
        add     %fp, x_s, %o0           !pointer to x in %o0
        call    _swap
        add     %fp, y_s, %o1           !pointer to y in %o1
        ret
        restore

        .global _swap                      ! a leaf routine
_swap:  ld      [%o0], %o2           !%o2 = x
        ld      [%o1], %o3              !%o3 = y
        st      %o2, [%o1]
        retl
        st      %o3, [%o0]
</PRE>

<P>
If <b>x and y are initially stored in registers</b>, then a few modifications
to the code are required, as shown below:

<PRE>
	define(x_r, l0)      ! x in %l0
	define(y_r, l1)      ! y in %l1
	define(x_s, -4)      ! where x might be stored on the stack
	define(y_s, -8)      ! where y might be stored on the stack

        .global _main
_main:  save %sp, -72, %sp
        mov     5, %x_r               !x = 5
        mov     7, %y_r               !y = 7  , now call swap
        st      %x_r, [%fp + x_s]   ! place args on stack
        st      %y_r, [%fp + y_s]
        add     %fp, x_s, %o0       !pass pointers to args on stack
        call    _swap
        add     %fp, y_s, %o1
        ld      [%fp + x_s], %x_r    !move values back into reg.
        ld      [%fp + y_s], %y_r
        ret
        restore

        .global _swap                   ! a leaf routine
_swap:  ld      [%o0], %o2         !%o2 = x
        ld      [%o1], %o3             !%o3 = y
        st      %o2, [%o1]
        retl
        st      %o3, [%o0]
</PRE>


<hr>

<center>
<H2>Machine Instructions</H2>

<H3>Instruction Codes</H3>
</center>

Another need for representation is in the <b>coding of instructions</b>.  Each
instruction must encode its opcode and its arguments, and once again the
issue in designing the encoding is efficiency.
 <P>

The principle design decision supporting efficiency is the fact that
instructions in the SPARC architecture are constant size.   Each
instructions occupies a <b>single word, 32 bits</b>.  This allows the
instruction fetch unit to be very simple and fast.  For each instruction
executed, the <b>i-fetch unit</b> simply gets one word from memory.
 <P>

The 32 bits that we have available to encode an instruction are divided
into <b>fields</b> -- contiguous subsets of the bits.  We need to define fields
to specify the instruction's <b>opcode</b>, and fields to specify the
instruction's <b>arguments (operands)</b>.

<P>
The format of the instruction should be uniform and as simple as
possible. A typical scheme is given below: 

<PRE>
8 bits - To specify the instruction (we get 256 instructions!!)
5 bits - For address of the three registers (32 different regs.)
1 bit  - To specify if second argument is a source register or constant
8 bits - Remaining 8 bits either combined with 5 for signed 
	 immediate constant or to provide additional 8 bits to 
	 specify floating point instructions.
</Pre>

<P>
<hr>
<center>
<h2>Instruction Decode</h2>
</center>

<P>
The 8 bits of the <b>instruction opcode</b> are divided into 2 parts:

<Pre>
op  -  2 bits

op3 -  6 bits
</Pre>

<P>
The division of the instruction into <b>fields</b> in done in three different
ways, called <b>formats</b>.   The format is specified in the <b>first two bits of
the instruction</b>:

<PRE>
<b>OP         INSTRUCTION CLASS		Format</b> 

00         Branch Instruction		Format 2 
01         call instruction		Format 1 
10         Format three instruction	Format 3
11         Format three instruction	Format 3
</PRE>

<hr>
<center>
<H2>Format 3 Instructions</H2>
</center>

There are two possibilities for Format 3 instructions: 
<PRE>
        op      rs1, rs2, rd
</PRE>
or
<PRE>
        op      rs1, imm, rd
</PRE>

where "imm" is an immediate value, that is, it is coded right in to the
instruction. 
 <P>

For the first case (3 registers), the fields in the instruction look
like this: 
<PRE>
Width:   2    5     6      5   1    8       5
        ----------------------------------------
        |  |     |      |     |0|        |     |
        ----------------------------------------
Name:    op   rd    op3   rs1      empty    rs2

        op:  10 or 11, indicating that this is a format 3 instruction
        rd:  numeric ID of destination register
        op3: encoding of opcode
        rs1: numeric ID of first source register
        rs2: numeric ID of second source register
</PRE>
The <b>numeric IDs</b> of registers are as follows:
<PRE>
        %g0 - %g7  -- 0 to 7
        %o0 - %o7  -- 8 to 15
        %l0 - %l7  -- 16 to 23
        %i0 - %i7  -- 24 to 31
</PRE>

<b>Five bits</b> are needed to encode a register, since there are only 32 of
them.  The numeric encoding of opcodes can be found in <b>Chapter 8, pp
215-216</b>.
 <P>

We can see that eight bits have been left unused, which is necessary to
"pad" the instruction out to the required 32 bit length.
 <P>

For the <b>second case</b>, (2 registers and an immediate value), the fields in
the instruction look like this:

<PRE>
Width:   2    5     6      5   1        13
        ----------------------------------------
        |  |     |      |     |1|              |
        ----------------------------------------
Name:    op   rd    op3   rs1    signed constant

        op:  10 or 11, indicating that this is a format 3 instruction
        rd:  numeric ID of destination register
        op3: encoding of opcode
        rs1: numeric ID of first source register
</PRE>


The way the processor tells these two cases apart is by the <b>1
or 0 right after the rs1 field</b>.
 <P>

Note that the <b>signed constant is only allotted 13 bits</b>.  This is a
consequence of our decision to limit all instructions to exactly 32 bits
in size.  The immediate value is encoded in two's complement, so the
range of values we can encode is <b>-4096 to +4095</b>.  Thus, if we try to use
an immediate value in a format 3 instruction that is out of this range,
the assembler will complain -- it just can't fit such a value in there.

 <P>
<b>7 bits</b> are used for format 3 instructions, so we can have a total of 
<b>128 possible instructions</b>. All the opcodes that are not used are named 
<b>UNIMP</b>

<img src="http://www.b4b0.org/images/barwhit.gif" alt="">
<H3>
For class 21 notes, <A HREF="class21.html">click here</A>
</H3>

<img src="http://www.b4b0.org/images/barwhit.gif" alt="">
<H3>
For more information, contact me at <A HREF="mailto:tvohra@mtu.edu">tvohra@mtu.edu</A>
</H3>

</BODY>
</HTML>
