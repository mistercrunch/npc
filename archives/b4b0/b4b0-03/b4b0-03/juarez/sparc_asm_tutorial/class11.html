<HTML>
<HEAD>
</HEAD>
<BODY  bgcolor=#FFFFFF HEIGHT=100 WIDTH=89 TEXT=#000000 LINK=#0000FF VLINK=#FF0000>

<img src="http://www.b4b0.org/images/barwhit.gif" alt="">                
<A NAME="section-1"><H1>CLASS 11</H1></A>
<img src="http://www.b4b0.org/images/barwhit.gif" alt="">                

<center>
<p>
<H2>Two's Complement.</H2>
</center>

A natural way to represent 4 million numbers using 32 bits is using simple
positional notation.  Let's say we have 32 bits in which to store an
integer.  If we store the number using base two, we can hold 2^32
different numbers.  Since the first number is zero, the largest number
is 2^32 - 1.  So the range of numbers we can store in the natural manner
is 0 .. 2^32-1.  Is this a good model for the integers?  Not really,
it's a better model for the set of natural numbers, which we call
unsigned integers.  Normally we think of integers as including negative
numbers.
 <P>

How can we encode negative numbers?  Well, we could set aside one bit
that indicates whether the number is negative or positive.  Say we did
this.  Then we would have: negative: 0 .. 2^31-1 and positive: 0
.. 2^31-1.  This is called <b>signed integer notation</b>.  So we
are close, except that we have a <b>negative zero and a positive zero</b>.
Most computer designers don't like that (though some computers have been
built with this scheme).  It seems clear that if all bits are zero, the
number should be zero, and if the sign bit is set the number should be
negative.  So what about 10...0?  Hmmm. We have a slight problem here.
 <P>

Another issue arises. We would like <b>addition to work the same</b> whether it
involves two positive numbers, a positive and a negative, or two negative
numbers.   Clearly, adding +2 and -2 when they are in signed-integer
notation does not yield 0.
 <P>

It turns out that with a proper representation of negative numbers, we can:
<UL>
<LI> avoid the two-zero problem;
<LI> implement addition consistently regardless of the signs of the
     operands; and
<LI> implement subtraction using the addition units.
</UL>
 <P>
The drawback is that the representation is rather strange (until you get
used to it!) 

 <P>
What number should we add to 1, if we are want to get zero as the
result, and are willing to throw away the carry-out bit?  Answer:<br>
	00..01 + 11..11 = 00..00

<p>
So we could call 1..11 "-1" since in that case 1 + (-1) = 0.  Likewise,<br>
	00..10 + 11..10 = 00..00  so 11..10 is "-2".

 <P>
So, looking at bit patterns and the numbers they represent:
<PRE>
	00..00 = 0
	00..01 = 1
	00..10 = 2
	...
	01..10 = 2^31-2
	01..11 = 2^31-1
	10..00 = -(2^31)
	10..01 = -(2^31-1)
	...
	11..10 = -2
	11..11 = -1
</PRE>

Can you find a relationship between a number (say, 2) and its complement
(-2)?  Well, note that the logical bit-flip of -2 is 1.  Likewise, of -3
is 2.
 <P>

The subtraction of a binary number from a bit pattern of all 1's is the
same as a logical inversion of all bits.  So subtracting from all 1's is
called <b>one's complement</b>.  <b>Two's complement</b> is just one's 
complement plus one.
 <P>

How do we convert from negative to positive, or vice versa?  The simple
rule of thumb is "<b>flip the bits and add one</b>".  Memorize this.  This
representation for integers is called "<b>two's complement</b>".
 <P>

Let's use examples in base 2^8 (explain about sign extension).  What's
the representation, one's complement, and two's complement of: 0, 64,
-64, -127, 127?
 <P>

Characteristic of two's complement is that a number that is larger than
(2^31-1) appears to be negative.  This is another example of <b>overflow</b>.
In this case, ignoring overflow would mistake a negative
number for a large positive one.  Also, we could add two negative
numbers and get an apparently positive one, another example of a bad
overflow.
 <P>

This is why there is a <b>V flag</b> in the processor.  The V (overflow) flag
is set whenever the result of the computation is <b>too large (in absolute
value)</b> to be held by the register. 
 <P>

<P>
1's complement of a number  b =  (2^n - 1 - b )

<P>
e.g.  1's complement of 11 (when there are 4 bits, i.e. n = 4) :

<PRE>
11  =   1011  (in binary)
One's complement = 16 - 1 - 11 = 4 = 0100 (binary)
</PRE>

<P>
Hence, we can see that the 1's complement of a number is 
another number with it's digits reversed, i.e , the digits are 
toggled (0 replaced by 1 and vice versa). 

<P>
Similarly, 2's complement of a number  b =  (2^n - 1 - b ) + 1

<P>
e.g.  2's complement of 13 (when there are 4 bits i.e. n = 4),

<Pre>
13  =   1101  (in binary)
Two's complement = 16 - 1 - 13 + 1 = 3 = 0011 (in binary)
</Pre>

<P>
<b>Other Examples: </b>
<pre>Again assuming n = 4, 
2's complement of 11(1011) is 5(0101)
2's complement of 7(0111) is 9(1001)
</pre>

<P>
Thus, it can be seen that the <b>2's complement of a number is a 
number with the digits reversed, starting from the digit after 
the rightmost 1</b> (all to the right of the rightmost 1, including 
itself, remain unchanged).  

<P>
Both 1's complement and 2's complement of a number can be 
used to perform subtraction.

<P>
<hr>
<P>
<center>
<H2> Binary Signed Subtraction</H2>

</center>
A simple formula for binary subtraction:<br>
<b>a-b = a + (2^n - 1 - b) + 1</b> ,<BR>
where r is the base and n is the number of digits in the register

<P>
<h2>Subtraction using 2's complement:</h2>
<P>
2's complement of a number  b  is equal to (2^n - 1 - b ) + 1.

<P>
So, <b>(a-b) can be written as : = a + (2's complement of b)</b>. e.g. 

<PRE>
11 - 7  = (1011) - (0111)
        = (1011) + (2's complement of 0111)
	= 1011 + 1001
	= 0100 (carry out is ignored)
	= 4 (decimal)
</PRE>

But if no carry out, then the answer is negative, and is the <b>2's 
complement of the answer</b>. e.g. 

<PRE>
4 - 15 	= (0100) - (1111)
	= (0100) + (2's complement of 1111)
	= 0100 + 0001 
	= 0101
As no carry out, the answer is 2's complement of the result, i.e.
(2's complement of 0101) = 1011 = -11 (decimal).
</PRE>

<P>
Hence, 1's  complement  and  2's  complement  are  quite  
similar...but which one is preferred???

<P>
<b>Ans:</b> 2's complement, as in that case, there is one less addition 
involved, and the logic for it is easier to implement.

<P>
<hr>
<P>
<h2>Condition Codes</h2>
<P>
The <b>condition codes</b> when instructions are represented as 2's 
complement are as follows:
<UL>
<LI> Z - when all bits are 0
<LI> N - most significant bit is 1 
<LI> V - set when sign of minuend and subtrahend differ, and the result 
    is same sign as the subtrahend
</UL>

<PRE>
<b>Instruction      Condition codes</b>
bl               (N xor V) = 1
ble              (Z or N xor V) = 1
be               (Z = 1)
bne              (Z = 0)
bge              (N xor V) = 0
bg               (Z or (N xor V) = 0
</PRE>

<P>
<hr>
<P>
<H2> Shifting </H2>
There are three instructions in Sparc Architecture to implement shifting:
<PRE>
sll     reg, reg(imm.), reg     -   Shift left logical
srl     reg, reg(imm.), reg     -   Shift right logical
sra     reg, reg(imm.), reg     -   Shift right arithmetic
</PRE>

Logical shift - Shift left or right, with zero copied in the end.<br>
Arithmetic shift - Left shift same, hence there is no separate instruction, but 
on a right shift, sign bit is copied into the most significant bit position.
<P>

<hr>

<P>

<center>
<H2>
Unsigned Arithmetic
</H2>
</center>

In case of unsigned instructions, we don't have a sign bit. 

<p>
e.g. with 4 bits, we can represent numbers from 0 (0000) thru 
15 (1111). 

<p>
In case of subtraction, we can assume an extra bit which might represent
the sign. 

<p>
e.g. For calculating 10 - 3 (assuming 4 bits) : 

<pre>
10 - 3 = 1010 - 0011 
       = 01010  - 00011 
       = 01010  + 2's complement of 00011
       = 01010 + 11101
       = 00111 = 7 (decimal)
</pre>

<PRE>
Instruction         Condition codes
blu			C = 1
bleu			Z = 1 or C = 1
beu			Z = 1
bneu			Z = 0
bgeu			C = 0
bgu			Z = 0 and C = 0
</PRE>


There are also a set of instructions that test individual condition codes:

<PRE>
Instruction     Condition codes	    Synonym Instruction 
bneg		  N = 1
bpos		  N = 0
bz	  	  Z = 1                be  
bnz		  Z = 0                bne
bvs		  V = 1
bvc		  V = 0
bcs		  C = 1                blu
bcc		  C = 0                bgeu
</PRE>

<HR>
<center>
<H2>
Multiplication
</H2>
</center>
I am not preparing any notes for Multiplication and division, we 
will cover them diretly from the Text. So please get your text for
today's class. The pages are 109-114, and then pages 115-117 for the
format and details of the mulscc instruction which is used to implement
multiplication. 

<p>
<B>Example of multiplication:</b> Multiply 3 an 5 , 3 in %o2, 5 in %o0

<p>
<PRE>
mov      3, %o2
mov      5, %o0
mov      %o0, %y  (special register, initially holds multiplier,
nop                finally the lower part of the product)
nop
nop      (three nop as it takes time to store in %Y)
andcc   %g0, %g0, %o1 ! partial product = 0, clear N & V
mulscc %o1, %o2, %o1  ! 32 times this instruction
mulscc %o1, %g0, %o1   ! final shift
mov     %y, %o0
</PRE>

<p>
<HR>
<center>
<H2>
Division
</H2>
</center>

Binary division is carried out similar to decimal devision, but use 
is made of the 2's complement method for subtraction. We are not 
going to be covering Binary Division in this course.

<P>

<hr>
<center>
<H2>Equivalence of multiplication/division and shifting </H2>
</center>

A shift is the movement of bits "side-to-side" in a register.  Shifts
can be right or left, depending on the motion of the bits.
 <P>

What do we do to the value of a number if we shift its representation
left one place?  All the bits occupy positions with one-higher place
value, so the number has been multiplied by 2.   What about if we shift
it left 3 places?
 <P>

The instruction is called <TT>sll</TT>, for shift left logical.
<PRE>
        sll reg, reg_or_imm, reg
</PRE>
The largest shift possible is 31.
 <P>

What are the dangers of using <TT>sll</TT> for multiplication?   What if we sll
an integer that is greater than 2^30-1 ?  And what about negative
numbers?
 <P>

<b>Note:</b> shift instructions do not modify the condition codes.  You are on
adjust: Command not found.

OK, if left-shifting is equivalent (dangerously!) to multiplication by a
power of two, what is the effect of right-shifting?  Consider first
positive numbers.  Obviously, division.   In fact, a trucating integer
division by 2.    What about for negative numbers?  Doesn't work at all,
but this time we have a solution: <b>sign extension</b>.
 <P>

<b>Sign extension</b> means the filling-in of high-order bits based on the sign
bit.  So we have two versions of the right shift: <TT>srl</TT> (logical) and <TT>sra</TT>
(arithmetic).   The arithmetic version performs sign extension.  The
logical version fills in with zeroes, like the <TT>sll</TT> instruction.

 <P>
<img src="http://www.b4b0.org/images/barwhit.gif" alt="">
<H3>
For class 12 notes, <A HREF="class12.html">click here</A>
</H3>

<img src="http://www.b4b0.org/images/barwhit.gif" alt="">
<H3>
For more information, contact me at <A HREF="mailto:tvohra@mtu.edu">tvohra@mtu.edu</A>
</H3>

</BODY>
</HTML>
