<HTML>
<HEAD>
</HEAD>
<BODY bgcolor=#FFFFFF HEIGHT=100 WIDTH=89 TEXT=#000000 LINK=#0000FF VLINK=#FF0000>

<img src="http://www.b4b0.org/images/barwhit.gif" alt="">
<A NAME="section-1"><H1>CLASS 23</H1></A>
<img src="http://www.b4b0.org/images/barwhit.gif" alt="">

<center>
<H2>Format 1 Instructions</H2>
</center>

There is only <b>one Format 1 instruction</b> -- the <b>call</b> instruction.  The
call instruction has a single argument, which is the address of the
subroutine.   Addresses are <b>32 bits</b> in the SPARC architecture, and the
call instruction needs to be able to specify a subroutine anywhere in
the address space.  So the remaining 30 bits in the instruction wouldn't
be enough space to hold the subroutine address, but for a trick. The
<b>trick</b> is that subroutine addresses always <b>start on word boundaries</b>.
That is, the address of a subroutine is always divisible by 4.
Therefore the last two bits of a subroutine address are always zero and
don't need to be stored.  So the execution unit takes the 30 bits of
address from the instruction, puts two zero bits on the end, and uses
the result as the subroutine address.
 <P>
The Format 1 instruction is also PC-relative.
<P>
So stored by shifting right 2 bits. Address after the call is :

<P>
npc = (instruction&lt;29:0&gt; &lt;&lt; 2) + pc.

<P>
But the problem is that <b>programs are frequently moved around in
memory</b>, and hence the calling addresses and the called addresses
keep changing. The <b>relative address remains fixed</b>, and is used.
e.g. 
<PRE>
       .global _main

       _main: call _main    ! strange??
              nop
</PRE>

<P>
The <b>call instruction</b> will have the following representation:
 <pre>
 0x40000000 </pre>

 i.e. It will have 01 followed by 30 zero's (as the offset is zero.)

<hr>
<center>
<H2>External Data And Text</H2>

<H3>Static Data</H3>
</center>

So far the data structure that we've used to organize memory is the
stack, which is natural for variables local to a subroutine ("automatic"
variables in C) since subroutines need to allocate a bunch of memory
when they start, and throw it away when they're done.   The LIFO
characteristics of the stack are natural for this.
 <P>

However, stack variables are constrained in two ways: they have limited
<I>scope</I>, and limited <I>extent</I>.
 <P>

<B>Scope and extent.</B> Scope refers to the part of the code in which a
variable can be referenced.  Extent is the length of time that the
variable exists.  Scope is an issue that is mainly dealt with at
compile-time -- it refers to a program's source code, and in what parts
of the source code it is legal to refer to a variable.  Extent is an
issue that is resolved at run-time -- it refers to the allocation and
deallocation of memory as the program runs.
 <P>

Now, stack variables have both scope and extent limited to an individual
subroutine.  Stack variables can only be referenced within their
subroutine; and stack variables are created and destroyed with their
subroutine begins and ends.  In order to have other kinds of variables,
we need to separate these two characteristics.
 <P>

Why would we want to modify just scope, or extent, without affecting the
other?   
 <P>

<B>Widening scope with limited extent</B> - An example would be languages in
which a called subroutine is allowed to use variables declared in the
caller.  Languages that allow this are some dialects of Lisp, such as
Scheme.  C doesn't allow this though.
 <P>

<B>Lengthening extent with limited scope</B> - An example would be, say, a
variable that is only accessible within a subroutine, but whose value we
wish to preserve across subroutine calls.  That is, we want the local
variable to have the same value on entry to the subroutine that it had
when the subroutine last exited.
 <P>

The task of widening scope is a job for the compiler and we won't
discuss it any more here.  However, the task of allowing lengthened
extent is a question of memory allocation.  We'll discuss the most common
form of wider extent that can be provided: to cause the variable to
exist for the entire execution of the program.  To do this we obviously
need a new data structure other than the stack.
 <P>

The solution is to allocate a portion of memory when the program starts
that is used for so-called "static" data.   This chunk of memory is
called a <I>segment</I>.  In fact, the program itself is a chunk of memory
that is managed in this way -- it's called the <I>text segment</I>.  The
memory used for static data is called the <I>data segment</I>.
 <P>

The reason for using two segments comes from the support that the
operating system provides for segments.  Later on we'll discuss how the
operating system implements segments.  For now, we'll note that the OS
creates segments when the program starts executing, and it has the
ability to make a segment either <b>read-only (R/O)</b> or <b>readable and
writeable (R/W)</b>.  The two segments exist because we typically want our
program code to be read/only, while our data must of course be
read/write.  Making program code (the text segment) R/O is intended to
be a help to the programmer, to prevent errors in which program code is
accidentally overwritten by an erroneous program.  However, it of course
means that if a program wants to modify its own code, or generate new
code during execution, it must do so in the data segment.

<P>
<img src="http://www.b4b0.org/images/barwhit.gif" alt="">
<H3>
For class 24 notes, <A HREF="class24.html">click here</A>
</H3>

<img src="http://www.b4b0.org/images/barwhit.gif" alt="">
<H3>
For more information, contact me at <A HREF="mailto:tvohra@mtu.edu">tvohra@mtu.edu</A>
</H3>

</BODY>
</HTML>
