
    Kryptografie      Geschrieben von Marc Ruef <marc.ruef@computec.ch> für
   Version 4.0alpha   http://www.computec.ch/
     (intern) 15.     Alle Rechte vorbehalten - Kopieren erlaubt!
    Dezember 2000     http://www.computec.ch/mruef/texte/kryptografie.html
  ------------------------------------------------------------------------

1.0 Inhaltsverzeichnis

     1.0 Inhaltsverzeichnis

     2.0 Einführung

          2.1 Kryptoanalyse

          2.2 OGR - Golomb Ruler

          2.3 Steganografie

     3.0 Wieso soll ich verschlüsseln?

     4.0 Symmetrische Kryptoalgorithmen

          4.1 Blowfish

          4.2 CAST-128

          4.3 Clipper

          4.4 DES (Data Encryption Standart)

          4.5 IDEA (International Data Encryption Standart)

          4.6 ROT13 & monoalphabetische Verschlüsselungen

          4.7 RC2 (Rivest Cipher 2)

          4.8 RC4 (Rivest Cipher 4)

          4.9 RC5 (Rivest Cipher 5)

          4.10 Safer

          4.11 Triple-DES (3DES)

          4.12 Twofish

     5.0 Assymmetrische Kryptoalgorithmen

          5.1 RSA (Rivest, Shamir, Adleman)

     6.0 Einwegverschlüsselungs-Algorithmen

          6.1 DH/DSS

          6.2 MD5 (Message Digest 5)

          6.4 SHA/SHA1 (Secure Hash Algorithm)

2.0 Einführung

     Die Kryptologie teilt sich in die beiden Tätigkeitsfelder
     Kryptografie und Kryptoanalyse auf. Als Kryptografie bezeichnet
     man die Wissenschaft von den Methoden der Ver- und
     Entschlüsselung von Daten. Die Kryptoanalyse als Wissenschaft
     versucht bestehende kryptografische Systeme zu brechen.

     In der Verschlüsselungstechnik werden grundsätzlich drei Arten
     von Daten gekannt: Als Klartext (engl. Plaintext) werden
     unverschlüsselte Daten bezeichnet. Im Gegensatz dazu benennt man
     verschlüsselte Daten als Schlüsseltext (engl. Ciphertext).
     Dazwischen wird natürlich noch ein Schlüssel verwendet, welcher
     der eigentliche Verschlüsselungsalgorithmus ist.

Verschlüsselung : Schlüsseltext = Verschlüsseln ( Schlüssel; Klartext )
Entschlüsselung : Klartext = Entschlüsseln ( Schlüssel; Schlüsseltext )
Signieren       : Signatur = Signieren ( Geheimer Schlüssel; Text )

     Moderne Kryptoalgorithmen basieren in der Regel auf dem
     Kerckhoff-Prinzip. Das nach Auguste Kerckhoff (1835 - 1903)
     benannte Prinzip besagt, dass die gesamte Sicherheit eines
     Algorithmus nur auf der Geheimhaltung des Schlüssels beruhen
     soll, und nicht auf der Geheimhaltung des kryptografischen
     Algorithmus. Der Gegensatz zu Kerckhoff ist das Prinzip der
     Sicherheit durch Verschleiern: Der Angreifer hat bei einem
     verschleierten System keine Ahnung, wie es funktioniert.

     2.1 Kryptoanalyse

          Um den Schlüssel eines Kryptoalgorithmus zu brechen,
          gibt es verschiedene Angriffsmöglichkeiten: Bei der
          "ciphertext only attack" kennt der Angreifer nur den
          Schlüsseltext, und versucht daraus den Schlüssel oder
          Plaintext zu generieren. Bei der "known plaintext
          attack" kennt der Angreifer mehrere
          Plaintext-Ciphertext-Paare, und versucht danach weitere
          zu generieren. Kann der Angreifer in der "chosen
          plaintext attack" und der "chosen ciphertext attack"
          eigene Klartext- bzw. Schlüsseltext-Paare generieren,
          dann ist dies der aussichtsreichste Angriff. Denn dann
          kann durch Probieren der geheime Schlüssel gefunden
          werden. Dies nennt man dann eine "brute force attack".

     2.2 OGR

          Im mathematischen Sinn ist ein "Golomb Ruler" eine
          Menge nichtnegativer ganzer Zahlen, wobei alle
          möglichen Zahlenpaare eine unterschiedliche Differenz
          haben. Das kann man mit einer Messlatte vergleichen,
          auf der keine zwei Paar Markierungen den gleichen
          Abstand haben. Ein OGR ist dann die kürzeste mögli-che
          Messlatte bei gegebener Anzahl Markierungen. Die
          Anwendungen dafür sind zahlreich, z. B. in
          Ra-dioastronomie oder
          Röntgenkristallographie.

          Zur Zeit sind die OGR mit bis zu 20 Zahlen bekannt.
          Auch Ruler mit mehr als 20 Zahlen sind bekannt,
          allerdings weis man von diesen nicht, ob sie optimal
          sind. Durch Testen aller möglichen Ruler bis zur Grösse
          des besten bekannten Rulers mit 21 Zahlen (und später
          dann auch mehr) kann man entweder einen besseren finden
          oder für den bekannten beweisen, dass er optimal ist.

     2.3 Steganografie

          Als erstes muss ich sagen, dass Steganografie ein
          Teilgebiet der Verschlüsselung darstellt. Steganografie
          ist die Kunst, die Daten einer Kommunikation in anderen
          Daten zu verstecken, so dass es aussieht, als hätte nie
          eine Kommunikation stattgefunden. Im Gegensatz dazu
          versuchen kryptografische Methoden nicht, die
          Kommunikation zu verschleidern, sondern deren Inhalt
          für jeden anderen, als die Ziel-Person, unleserlich zu
          gestalten.

          Die Ursprünge dieser Technik reichen bis in die Antike
          zurück. Im Mittelwalter wurden Bücher und Schriften
          verfasst, in welchen zum Beispiel Sätze aus privaten
          Dokumenten, wie Briefen, gesammelt wurden. Den
          einzelnen Sätzen wurden gewisse Bedeutungen zugewiesen,
          wodurch Informationen in Briefen versteckt werden
          konnten. Ein anderes Beispiel ist die Geschichte zur
          Zeit von Cäsar, als eine mit der richtigen Nachricht
          beschriftete Steinplatte mit Wachs überzogen wurde, um
          eine andere Nachricht darauf vorzutäuschen. In gewisser
          Weise ist auch das Handeln von David Copperfield der
          Steganografie zuzuschreiben, denn sei-ne Tricks
          versuchen etwas vorzugeben, was nicht wirklich
          elementar ist.

          Im Bereich der Telekommunikation via Internet sind
          MixMaster und Onion Routing Beispiele für
          Steganographie. Um die Tatsache der Kommunikation zu
          verbergen, wird die Netzlast zwischen Knoten konstant
          gehalten. Im Datenverkehr zwischen den Netzknoten wir
          die Kommunikation zwischen menschlichen Partnern
          verborgen. Wird eine Traffic-Analyse durchgeführt,
          lässt sich nicht feststellen, wer an wen Daten sendet.
          Man erkennt nur, dass Daten von einem Punkt zum anderen
          fliessen.

          MixMaster ist ein Programm, das dieses Prinzip auf den
          Versand von E-Mails überträgt. Onion Routing ist ein
          Ansatz, Steganografie auf der Ebene des
          Netzwerk-Standarts TCP zu implementieren. Das für den
          Otto-Normalverbraucher wohl interessanteste Programm
          zur Steganografie ist das Programm "Stegano", welches
          in der gewohnten Umgebung unter Windows 9x Daten in
          anderen Daten verstecken kann.

          Das Problem einer solchen Verschleierung ist, dass das
          Rauschen, mit dem die Information versteckt wird,
          wiederum nicht als Rauschen entdeckt werden darf.
          Gelingt eine Trenning von Rauschen und Informationen,
          ist zumindest die Verschleierung der
          Nachrichtenübermittlung aufgedeckt.

          Heute ist das eigentliche Anwendungsgebiet der
          Steganografie der Copyrightschutz von elektronischen
          Daten, wie zum Beispiel Bildern oder Sound-Dateien. So
          werden zum Beispiel elektronische Wasserzeichen
          (Englisch: watermarks) in ein Bild eingebettet. Das
          Wasserzeichen ist im Bild mit blossem Auge nicht
          sichtbar. Im Streitfall kann der Eigentümer allerdings
          durch ein geeignetes Programm die versteckte
          Information sichtbar
          machen, und dadurch die Standfestigkeit seiner meinung
          festigen. Probleme ergeben sich, falls das Bild
          verändert wurde. Es existieren Programme, mit denen ein
          Bild so verändert werden kann, dass der Bildinhalt nur
          geringfügig verändert wird, und das Wasserzeichen nicht
          mehr nachweisbar ist.

          Im Bereich der Betriebssysteme, die nach dem Orangebook
          (ITSEC) sicherheitszertifiziert wurden, besteht das
          Problem des "Hidden Channel". In entsprechenden
          Betriebssystemen sind alle Objekte (Dateien und
          Prozesse) nicht nur Benutzern und Gruppen zugeordnet,
          sondern auch Sicherheitsstufen. Aufgrund der Vorgaben
          aus dem Orangebook darf ein Objekt mit einer hohen
          Sicherheitsstufe keine Daten an ein Objekt niedriger
          Sicherheitsstufe weitergeben oder zugänglich machen.
          Durch die Erzeugung von sogenannten "Hidden Channels"
          kann dies jedoch
          umgangen werden. Ein solcher "Hidden Channel" kann zum
          Beispiel die künstliche Erhöhung der Systemlast in
          gewissen Zeitabständen oder Situationen sein. Zwei
          Prozesse, die per Definition nicht miteinander
          kommunizieren dürfen, können auf diese Weise trotzdem
          Informationen austauschen.

3.0 Wieso soll ich verschlüsseln?

     Wenn man geschäftliche oder persönliche Informationen lieber in
     einem geschlossenen Umschlag verschicke, weder die Informationen
     per Postkarte an jemanden weiterzuleiten, dann ist die logische
     Schlussfolgerung, dass man sich für eine Verschlüsselung des
     Datenverkehrs im Internet entscheiden sollte.

     Leider gelten unverschlüsselte E-Mails als absolut unsicher. Eine
     E-Mail passiert viele verschiedene Rechner/Knotenpunkte auf dem
     Weg durch das Internet, bis es schlussendlich einmal beim
     Empfänger eintrifft. Auf jedem dieser Rechner kann die Nachricht
     im Klartext gelesen werden, was keinen sonderlichen positiven
     Einfluss auf die Privatsphäre der beiden kommunizierenden
     Parteien hat. Beide würden von einem solchen passiven Eingriff
     auch nichts mitbekommen. Sicherheitsexperten und Paranoiker gehen
     davon aus, dass ein Grossteil des Datenverkehrs aufgezeichnet,
     und mittels Schlüsselwörtern, wie zum Beispiel "Attentat",
     "Anschlag", "Bombe", oder "Mafia" untersucht wird. Besonders die
     amerikanische Regierung, und die NSA (National Security Agency)
     gerieten ins Zwielicht, solche Informationsschnüffler und
     -Sammler zu sein.

     Auserdem gestaltet sich der Aufwand, sei es nun persönlicher oder
     finanzieller Natur, mittels des Verschlüsselns des Datenverkehrs
     als ausgesprochen gering. Das meist eingesetzte, und von mir
     empfohlene Programm ist PGP (Pretty Good Privacy), und ist als
     Freeware erhältlich. Somit sind frei kopierbare Versionen im
     Umlauf, welche als Standart für den Normalverbraucher, sowie auch
     unter den Experten angesehen wird.

     Solch starke Verschlüsselungen, wie sie bei PGP möglich sind,
     sind in der Schweiz durchwegs legal, und fallen unter kein
     Waffenexport-Verbot. Da der darin verwendete Algorithmus keine
     sonderlich hohen Hardwareanforderungen hat, ist PGP auf jedem
     gebräuchlichen PC einsetzbar.

4.0 Symmetrische Kryptoalgorithmen

     Die symmetrischen Kryptoalgorithmen basieren auf dem Prinzip, die
     Ver- und Entschlüsselung mit dem gleichen Schlüssel
     durchzuführen.

     4.1 Blowfish

          Der Autor von Blowfish heisst Bruce Schneider, und er
          entwickelte ihn im Jahre 1994. Die Blocklänge beträgt
          64 Bit, und die Schlüssellänge kann bis 448 Bit
          ausgeweitet werden.

          Ausgehend von den ersten 8336 Stellen der hexadezimalen
          Darstellung von Pi, wird aus dem Schlüssel die
          benötigten Grössen mt 521 Iterationen des
          Blowfish-Algorithmus erstellt. Damit will man
          eventuellen Hintertüren vorbeugen.

     4.2 CAST-128

          Als Autor von CAST-128 gilt C. M. Adams. Die Blocklänge
          beträgt 64 Bit, und die Schlüssellänge kann zwischen 40
          und 128 Bit liegen. Der Einsatzort wird nicht nur wegen
          der enormen Geschwindigkeit und dem Entfallen der
          Kosten hauptsächlich in PGP 5 gesehen. CAST-128 ist
          weltweit erhältlich und einsetzbar; Egal, ob für den
          privaten oder kommerziellen Gebrauch. Genauere
          Informationen erhält man in RFC2144.

          CAST-128 ist ein Verfahren, welches einen Klartext in
          12 oder 16 Durchgängen mittels des Feistel-Verfahrens
          und einer maximalen Blockgrösse von 128 Bit
          verschlüsselt. Es wird ein Umkehren der wichtigen
          Elemente eingesetzt, was das Verfahren immun gegen
          lineare und differentielle Attacken macht. Es wird eine
          Mixtur aus XOR, Additionen und Subtraktionen (modulo
          2**32) in einem Durchgang eingesetzt, wobei drei
          Variationen der Rundungsfunktion bis zum Endgültigen
          verschlüsselten Text zum Zuge kommen. Schlussendlich
          werden 8x32 S-Boxen eingesetzt, wobei die verschiedenen
          Rundungsfunktionen das Minimum von 74 nonlinearen und
          ein Maximum von 2 verschiedenen verteilungs Tabellen
          erreicht wird.

          CAST-128 stellt eine Form der Verschlüsselung dar,
          welche "Feister ciphers" genannt wird. Viele
          eingesetzte Operationen sind ähnlich, wie die des DES
          (Data Encryption Standart). Die komplette
          Verschlüsselung geschieht in folgenden vier
          Teilschritten:

          Eingabe           : Klartext k1...k64; Schlüssel s = s1...s128.

          Ausgabe           : Verschlüsselter Text c1...c64.

          Es werden 16 Subkey-Paare {Kmi, Kri} aus K gebildet. Es
          wird aus k1...k64 L0 und R0 gebildet, also der Klartext
          in zwei 32-Bit-Hälften gesplittet. L0 = k1...k32 und R0
          = k33...k64. Es werden i1...i16 gebildet, und Li und Ri
          wie folgt ergänzt, was dann f ergibt: Li = Ri-1 Ri =
          Li-1 ^ f(Ri-1, Kmi, Kri) c1...c64, also R16 und L16
          werden ausgetauscht, und der verschlüsselte Text ist
          gegeben.

          CAST-128 benutzt ein Subkey-Paar pro Prozedur, welche
          als 32-Bit-Quantität Km als "masking Key" und eine
          5-Bit-Quantität Kr als "rotation Key" generiert werden
          müssen.

          Drei verschiedene Rundungs-Funktionen kommen bei
          CAST-128 zum Zuge. Folgend möchte ich jene gerne kurz
          beschreiben, wobei D als Daten-Eingabe zur Funktion F
          und Ia und Id die höchstwertigen Bytes darstellen. Zu
          beachten ist, dass + und - als Addition und Subtraktion
          modulo 2**32 eingesetzt werden, und ^ als bitweise
          XOR-Funktion genutzt wird. Desweiteren gilt <<< als als
          zurkulierte Leftshift-Operation.

          Type 1:
          I = ((Kmi + D) <<< Kri)
          f = ((S1[Ia] ^ S2[Ib]) - S3[Ic]) + S4[Id]

          Type 2:
          I = ((Kmi ^ D) <<< Kri)
          f = ((S1[Ia] - S2[Ib]) + S3[Ic]) ^ S4[Id]

          Type 3:
          I = ((Kmi - D) <<< Kri)
          f = ((S1[Ia] + S2[Ib]) ^ S3[Ic]) - S4[Id]

          Die Rundungen 1, 4, 7, 10, 13 und 16 benutzen die
          f-Funktion Typus 1.
          Die Rundungen 2, 5, 8, 11 und 14 benutzen die
          f-Funktion Typus 2.
          Die Rundungen 3, 6, 9, 12 und 15 benutzen die
          f-Funktion Typus 3.

          CAST-128 greift auf acht Ersatz-Boxen zurück: Die
          S-Boxen S1, S2, S3 und S4 sind Rundungsfunktionen in
          Form von S-Boxen. S5, S6, S7 und S8 sind planmäsige
          S-Boxen. Schlussendlich brauchen 8 S-Boxen total 8
          Kbytes Speicher, wobei eigentlich nur 4 Kbytes währen
          des effektiven Umwandlungsvorgangs von Klar- zu
          Schlüsseltext, oder Umgekehrt benötigt werden.

          Als 128-Bit-Schlüssel nehme ich nun
          x0x1x2x3x4x5x6x7x8x9xAxBxCxDxExF, wobei x0 das
          höchstwertige Byte, und xF das niederwertigste Byte
          repräsentiert. Z0...zF stellen temporäre Bytes dar.
          Si[] gilt als S-Box i und ^ represäntiert eine
          XOR-Addition.

          Die Subkeys werden vom Schlüssel
          x0x1x2x3x4x5x6x7x8x9xAxBxCxDxExF gebildet, und
          gestalten sich nun wie folgt:

          z0z1z2z3 = x0x1x2x3 ^ S5[xD] ^ S6[xF] ^ S7[xC] ^ S8[xE]
          ^ S7[x8]
          z4z5z6z7 = x8x9xAxB ^ S5[z0] ^ S6[z2] ^ S7[z1] ^ S8[z3]
          ^ S8[xA]
          z8z9zAzB = xCxDxExF ^ S5[z7] ^ S6[z6] ^ S7[z5] ^ S8[z4]
          ^ S5[x9]
          zCzDzEzF = x4x5x6x7 ^ S5[zA] ^ S6[z9] ^ S7[zB] ^ S8[z8]
          ^ S6[xB]
          K1  = S5[z8] ^ S6[z9] ^ S7[z7] ^ S8[z6] ^ S5[z2]
          K2  = S5[zA] ^ S6[zB] ^ S7[z5] ^ S8[z4] ^ S6[z6]
          K3  = S5[zC] ^ S6[zD] ^ S7[z3] ^ S8[z2] ^ S7[z9]
          K4  = S5[zE] ^ S6[zF] ^ S7[z1] ^ S8[z0] ^ S8[zC]
          x0x1x2x3 = z8z9zAzB ^ S5[z5] ^ S6[z7] ^ S7[z4] ^ S8[z6]
          ^ S7[z0]
          x4x5x6x7 = z0z1z2z3 ^ S5[x0] ^ S6[x2] ^ S7[x1] ^ S8[x3]
          ^ S8[z2]
          x8x9xAxB = z4z5z6z7 ^ S5[x7] ^ S6[x6] ^ S7[x5] ^ S8[x4]
          ^ S5[z1]
          xCxDxExF = zCzDzEzF ^ S5[xA] ^ S6[x9] ^ S7[xB] ^ S8[x8]
          ^ S6[z3]
          K5  = S5[x3] ^ S6[x2] ^ S7[xC] ^ S8[xD] ^ S5[x8]
          K6  = S5[x1] ^ S6[x0] ^ S7[xE] ^ S8[xF] ^ S6[xD]
          K7  = S5[x7] ^ S6[x6] ^ S7[x8] ^ S8[x9] ^ S7[x3]
          K8  = S5[x5] ^ S6[x4] ^ S7[xA] ^ S8[xB] ^ S8[x7]
          z0z1z2z3 = x0x1x2x3 ^ S5[xD] ^ S6[xF] ^ S7[xC] ^ S8[xE]
          ^ S7[x8]
          z4z5z6z7 = x8x9xAxB ^ S5[z0] ^ S6[z2] ^ S7[z1] ^ S8[z3]
          ^ S8[xA]
          z8z9zAzB = xCxDxExF ^ S5[z7] ^ S6[z6] ^ S7[z5] ^ S8[z4]
          ^ S5[x9]
          zCzDzEzF = x4x5x6x7 ^ S5[zA] ^ S6[z9] ^ S7[zB] ^ S8[z8]
          ^ S6[xB]
          K9  = S5[z3] ^ S6[z2] ^ S7[zC] ^ S8[zD] ^ S5[z9]
          K10 = S5[z1] ^ S6[z0] ^ S7[zE] ^ S8[zF] ^ S6[zC]
          K11 = S5[z7] ^ S6[z6] ^ S7[z8] ^ S8[z9] ^ S7[z2]
          K12 = S5[z5] ^ S6[z4] ^ S7[zA] ^ S8[zB] ^ S8[z6]
          x0x1x2x3 = z8z9zAzB ^ S5[z5] ^ S6[z7] ^ S7[z4] ^ S8[z6]
          ^ S7[z0]
          x4x5x6x7 = z0z1z2z3 ^ S5[x0] ^ S6[x2] ^ S7[x1] ^ S8[x3]
          ^ S8[z2]
          x8x9xAxB = z4z5z6z7 ^ S5[x7] ^ S6[x6] ^ S7[x5] ^ S8[x4]
          ^ S5[z1]
          xCxDxExF = zCzDzEzF ^ S5[xA] ^ S6[x9] ^ S7[xB] ^ S8[x8]
          ^ S6[z3]
          K13 = S5[x8] ^ S6[x9] ^ S7[x7] ^ S8[x6] ^ S5[x3]
          K14 = S5[xA] ^ S6[xB] ^ S7[x5] ^ S8[x4] ^ S6[x7]
          K15 = S5[xC] ^ S6[xD] ^ S7[x3] ^ S8[x2] ^ S7[x8]
          K16 = S5[xE] ^ S6[xF] ^ S7[x1] ^ S8[x0] ^ S8[xD]
          z0z1z2z3 = x0x1x2x3 ^ S5[xD] ^ S6[xF] ^ S7[xC] ^ S8[xE]
          ^ S7[x8]
          z4z5z6z7 = x8x9xAxB ^ S5[z0] ^ S6[z2] ^ S7[z1] ^ S8[z3]
          ^ S8[xA]
          z8z9zAzB = xCxDxExF ^ S5[z7] ^ S6[z6] ^ S7[z5] ^ S8[z4]
          ^ S5[x9]
          zCzDzEzF = x4x5x6x7 ^ S5[zA] ^ S6[z9] ^ S7[zB] ^ S8[z8]
          ^ S6[xB]
          K17 = S5[z8] ^ S6[z9] ^ S7[z7] ^ S8[z6] ^ S5[z2]
          K18 = S5[zA] ^ S6[zB] ^ S7[z5] ^ S8[z4] ^ S6[z6]
          K19 = S5[zC] ^ S6[zD] ^ S7[z3] ^ S8[z2] ^ S7[z9]
          K20 = S5[zE] ^ S6[zF] ^ S7[z1] ^ S8[z0] ^ S8[zC]
          x0x1x2x3 = z8z9zAzB ^ S5[z5] ^ S6[z7] ^ S7[z4] ^ S8[z6]
          ^ S7[z0]
          x4x5x6x7 = z0z1z2z3 ^ S5[x0] ^ S6[x2] ^ S7[x1] ^ S8[x3]
          ^ S8[z2]
          x8x9xAxB = z4z5z6z7 ^ S5[x7] ^ S6[x6] ^ S7[x5] ^ S8[x4]
          ^ S5[z1]
          xCxDxExF = zCzDzEzF ^ S5[xA] ^ S6[x9] ^ S7[xB] ^ S8[x8]
          ^ S6[z3]
          K21 = S5[x3] ^ S6[x2] ^ S7[xC] ^ S8[xD] ^ S5[x8]
          K22 = S5[x1] ^ S6[x0] ^ S7[xE] ^ S8[xF] ^ S6[xD]
          K23 = S5[x7] ^ S6[x6] ^ S7[x8] ^ S8[x9] ^ S7[x3]
          K24 = S5[x5] ^ S6[x4] ^ S7[xA] ^ S8[xB] ^ S8[x7]
          z0z1z2z3 = x0x1x2x3 ^ S5[xD] ^ S6[xF] ^ S7[xC] ^ S8[xE]
          ^ S7[x8]
          z4z5z6z7 = x8x9xAxB ^ S5[z0] ^ S6[z2] ^ S7[z1] ^ S8[z3]
          ^ S8[xA]
          z8z9zAzB = xCxDxExF ^ S5[z7] ^ S6[z6] ^ S7[z5] ^ S8[z4]
          ^ S5[x9]
          zCzDzEzF = x4x5x6x7 ^ S5[zA] ^ S6[z9] ^ S7[zB] ^ S8[z8]
          ^ S6[xB]
          K25 = S5[z3] ^ S6[z2] ^ S7[zC] ^ S8[zD] ^ S5[z9]
          K26 = S5[z1] ^ S6[z0] ^ S7[zE] ^ S8[zF] ^ S6[zC]
          K27 = S5[z7] ^ S6[z6] ^ S7[z8] ^ S8[z9] ^ S7[z2]
          K28 = S5[z5] ^ S6[z4] ^ S7[zA] ^ S8[zB] ^ S8[z6]
          x0x1x2x3 = z8z9zAzB ^ S5[z5] ^ S6[z7] ^ S7[z4] ^ S8[z6]
          ^ S7[z0]
          x4x5x6x7 = z0z1z2z3 ^ S5[x0] ^ S6[x2] ^ S7[x1] ^ S8[x3]
          ^ S8[z2]
          x8x9xAxB = z4z5z6z7 ^ S5[x7] ^ S6[x6] ^ S7[x5] ^ S8[x4]
          ^ S5[z1]
          xCxDxExF = zCzDzEzF ^ S5[xA] ^ S6[x9] ^ S7[xB] ^ S8[x8]
          ^ S6[z3]
          K29 = S5[x8] ^ S6[x9] ^ S7[x7] ^ S8[x6] ^ S5[x3]
          K30 = S5[xA] ^ S6[xB] ^ S7[x5] ^ S8[x4] ^ S6[x7]
          K31 = S5[xC] ^ S6[xD] ^ S7[x3] ^ S8[x2] ^ S7[x8]
          K32 = S5[xE] ^ S6[xF] ^ S7[x1] ^ S8[x0] ^ S8[xD]

          Für das Maskieren und Rotieren der Subkeys gilt
          folgende Regel, wobei Km1...Km16 ein 32-Bit-maskierter
          Subkey, und Kr1...Kr16 den anderen Subkey für eine
          Sitzung darstellt. Nur die 5 höchstwertigen Bits werden
          in einem Durchgang benutzt.

          for (i=1; i<=16; i++)  { Kmi = Ki;  Kri = K16+i; }

          CAST-128 wurde so designt, dass der Schlüssel für eine
          Sitzung zwischen 40 und 128 Bits gewählt werden kann.
          Dabei muss man jedoch bedenken, dass der Schlüssel in
          8-Bit-Teile zerlegt werden muss, und somit nur die
          Schlüssellängen 40, 48, 56, 64, ..., 112, 120 und 128
          Bits möglich werden. Für eine variable Schlüsselgrösse
          sind folgende offiziellen Spezifikationen in RFC2144
          festgehalten:

          Für Schlüssellängen bis zu 80 Bits (also 40, 48, 56,
          64, 72 und 80 Bits) verwendet der Algorithmus die
          Standartbestimmungen, jedoch 12 Durchgänge, anstatt 16.
          Für Schlüssellängen, die grösser als 80 Bits sind,
          benutzt der Algorithmus alle 16 Durchgänge. Für
          Schlüssellängen, die kleiner als 128 Bits sind, werden
          die niederwertigsten Positionen mit Nullen aufgefüllt.

          Grob kann man nun sagen, dass CAST-128 anstandslos alle
          12 oben genannten Schlüssellängen akzeptiert, und
          verwerten kann. Zum Einsatz kommen jedoch vorwiegend
          die Schlüssellängen von 40, 64, 80 und 128 Bits. Bei
          vielen Implementationen ist eine Wahl zwischen diesen
          Schlüssellängen meist nicht möglich.

          Falls nun eine Konfusion auf Basis von CAST-128
          durchgeführt wird, kann das Verfahren einen anderen
          Namen enthalten. Als Beispiel sei eine Verschlüsselung
          mittels CAST-128 mit einem 40 Bit langer Schlüssel zu
          nennen, welche dann den Namen CAST5-40 erhält. Wird nun
          ein 128 Bit langer Schlüssel eingesetzt, wird das ganze
          als CAST5-128 benannt.

          Die Performance des als sicher geltenden Verfahrens
          kann sich durchaus sehen lassen. Wird ein Text mit
          einem Schlüssel von 128 Bit Länge ver- oder
          entschlüsselt, braucht man auf einem handelsüblichen
          Pentium Prozessor, welcher mit 150 MHz getaktet ist,
          nur 3.3 MB/sek.

          Das Dechiffrieren gestaltet sich relativ einfach: Denn
          genau wie Chiffrieren; nur die Reihenfolge der
          Teilschlüssel wird umgedreht. Trotzdem gilt dieses
          Verfahren als immun gegen lineare und differentiale
          Kryptoanalyse, da keine schwachen oder semi-schwachen
          Schlüssel existieren.

     4.3 Clipper

          Die amerikanische Regierung kündigte auf den Tag genau
          am 16. April 1993 eine neue Initiative der
          Datenverschlüsselung an, die jedermann ein grosses
          Masse an Sicherheit garantieren sollte. Die damalige
          Regierung verabschiedete deshalb den EES (Escrowed
          Encryption Standart), der gemeinsam mit dem KES (Key
          Escrow System) dieses Ziel verwirklichen sollte. EES
          sollte das bisherige DES-Verfahren ablösen, da das neue
          Verfahren einerseits als sicherer galt, andererseits
          wollte man Verbrechern, die ihre Rechner zu
          kryptografischen Festungen ausgebaut hatten, das
          Handwerk legen.

          Das Wichtigste aber an dieser Initiative war aber ein
          integrierter Hardware-Chip, der sogenannte
          Clipper-Chip, der die eigentlichen
          Sicherheitsmassnahmen darstellen sollte. Die Idee war,
          dass Verschlüsselungssystem für jederman implementiert
          werden konnte, um ein Entschlüsseln von Dritten zu
          verhindern. Doch davon ausgenommen sollten autorisierte
          Stellen der Regierung sein. Sie sollte in der Lage
          sein, bei Verbrechensbekämpfung verschlüsselte
          Nachrichten im Klartext lesen zu können, und so
          Verschlüsselungen benutzende kriminellen Vereinigungen
          (Terroristen, Mafia,...) das Handwerk zu legen.

          Der Clipper-Chip hat aber nicht nur in Amerika Aufsehen
          erregt, und da zahlreiche Proteste zur Folge waren,
          wurde das Projekt vorerst offiziell wegen Geldmangels
          auf Eis gelegt.

     4.4 DES (Data Encryption Standart)

          1975 wird DES (Data Encryption Standart) von NBS
          (National Buerau of Standarts), welches heute als NIST
          (National Institute of Standards and Technology)
          Erscheinung tritt, der NSA (National Security Agency)
          und IBM (International Business Machines) entwickelt.
          Dieser Algorithmus wurde vom DoD (Department of
          Defense) und der der NSA (National Security Agency)
          1977 zum öffentlichen Verschlüsselungsstandart erklärt.
          Er wird seitdem in sehr vielen Bereichen eingesetzt,
          darunter auch im Banken- und Finanzwesen. DES (Data
          Encryption Standart) verwendet einen geheimen
          56-Bit-Schlüssel, dessen Länge nicht variabel ist, und
          basiert auf einer Blocklänge von 64 Bit. Nach jeweils 5
          Jahren fand eine Untersuchung statt, der Zahn der Zeit
          nicht zu arg am Algorithmus genagt hat. Er bestand den
          Test in den Jahren 1987 und 1992/93, und wurde erst
          1998 durch den AES (Advanced Encryption Standart)
          abgelöst.

          Es gibt 4 als unsicher und ungünstig geltende
          Schlüssel, welche 0101010101010101, FEFEFEFEFEFEFEFE,
          1F1F1F1F1F1F1F1F und E0E0E0E0E0E0E0E0 lauten. Diese
          können zu einer Involution führen. Es gibt nur 256,
          also 7.2x1016 verschiedene Schlüssel. Das gilt im
          Zusammenhang mit heutigen technischen Hilfsmitteln als
          zu klein, und somit unsicher. Ein Ausweg aus dem
          Problem des zu kleinen Schlüsselraums bietet die
          mehrfache Chiffrierung mit verschiedenen Schlüsseln,
          wenn das Verfahren keine Schlüsselgruppe bildet. DES
          (Data Encryption Standart) definiert im Allgemeinen
          keine Gruppe. Die Anzahl der verschiedenen
          Chiffrierungen, die durch mehrfache DES-Anwendung mit
          verschiedenen Schlüsseln erreicht werden kann, beträgt
          mindestens 102499. Man sollte die tatsächlich
          erreichbare Komplexitätssteigerung mittels eines
          Meet-in-the-middle-Angriffs nicht ausser Acht lassen.

          DES (Data Encryption Standart) gilt als einer der meist
          durchleuchtesten Standarts für Verschlüsselungen. In
          all den Jahren wurden nie offensichtliche Mängel
          offengelegt, also kann der Algorithmus selber als sehr
          sicher eingestuft werden. Doch zugleich bleiben gewisse
          Zweifel, ob nicht doch Hintertüren für die NSA
          existieren, da sie ja stark an der Einführung des
          Standarts beigewohnt haben. Auch Frontpage von
          Microsoft benutzt DES-Verschlüsselungen.

     4.5 IDEA (International Data Encryption Standart)

          Dies ist der im Jahre 1990 an der ETH Zürich von Xuejia
          Lai und James Massey  vorgeschlagene Nachfolger des PES
          (Proposed Encrypton Standart). Der erste Entwurf von
          IDEA (International Data Encryption Standart) wurde
          PEES genannt. Genau wie der DES ist es eine
          64-Bit-Blockchiffrierung, welche aber mit einer auf 128
          Bit vergrösserten Schlüssellänge arbeitet. Durch die
          Reduktion der Iterationen auf die Hälfte derer des DES
          und dadurch, dass es keine Permtationsoperationen gibt,
          bleibt die Rechenzeit bei gleichzeitiger Steigerung der
          Sicherheit unter der ihres populären Vorgängers.
          Besonders interessant ist, dass keine Bitoperationen
          eingesetzt werden, sondern drei verschiedene
          Operationen auf 16-Bit-Blöcken:

             * Bitweise Addition zweier Zahlen ohne Übertrag
               (XOR).
             * Addition zweier Zahlen ohne Berücksichtigung
               des Übertrags über 2^16 hinaus.
             * Multiplikation zweier Zahlen und Bildung des
               Restes nach Division durch 2^16+1. Hierbei
               werden 0 und 2^16
             * besonders behandelt: Vor Beginn der
               Multiplikation wird eine 0 durch 2^16
               ersetzt, das Ergebnis 2^16
             * wiederum wird als 0 interpretiert. Daraus
               folgt: 0 x 0 = 1.

          Der 64-Bit-Klartextblock wird in 4 16-Bit-Blöcke
          aufgeteilt. 8 (bis auf die Teilschlüssel) identische
          Runden und die Abschluss-Transformation führen zum
          64-Bit-Geheimtextblock. Der 128-Bit Schlüssel wird in 8
          16-Bit Teilschlüssel aufgeteilt. Dann wird jede dieser
          Ausplittungen um 25 Bitpositionen zyklisch nach links
          verschoben und erneut in 8 16-Bit Teilschlüssel
          aufgeteilt. Weitere zyklische Verschiebungen und
          Aufteilungen dieser Art schliessen sich. Insgesamt
          werden 52 Teilschlüssel generiert.

          Die eigentliche Verschlüsselung läuft so ab, dass ein
          Klartextblock von 64 Bit Länge in vier Blöcke zu je 16
          Bit eingeteilt wird, die anschliessend dem Verfahren in
          Abb. 4 unterworfen werden. Dargestellt ist nur der
          erste Durchlauf, das Verfahren wird achtmal angewendet.

          Dechiffrieren erfolgt mit zu den Teilschlüsseln
          inversen Teilschlüsseln in (wie gewohnt) umgekehrter
          Reihenfolge. Es gibt eine Klasse von als schwach
          geltende Schlüssel. Jene sind aber in der Praxis leicht
          zu vermeiden. Aus diesem Grunde gilt IDEA
          (International Data Encryption Standart) als einer der
          stärksten öffentlichen Krypto-Algorithmen.

          IDEA (International Data Encryption Standart)
          unterliegt dem Patentschutz, und gehört somit der Firma
          Ascom Systec. Seine grosse Berühmtheit erlangte IDEA
          (International Data Encryption Standart) dank seines
          Einsatzes bei PGP (Pretty Good Privacy). IDEA gilt
          grundsätzlich als besseres Verfahren, weder DES, was
          die differentielle Kryptoanalyse von Biham und Shamir
          bewies.

     4.6 ROT13 - Monoalphabetische Verschlüsselung

          Die wohl bekannteste Form einer symmetrischen
          Verschlüsselung ist die vom römischen Herrscher Julius
          Cäsar erfundene Monoalphabetische Verschlüsselung.
          Dabei werden die Buchstaben im Alphabet vertauscht.
          Dabei kann aus einem "a" ein "f", und aus einem "f" ein
          "l" werden.

          Monoalphabetische Verschlüsselungen mit einer
          Schlüssellänge von 1 Bit werden auch noch in unserer
          Zeit eingesetzt. Vor allem im Internet wird der
          ROT13-Algorithmus oft in Newsgroups verwendet, um
          möglicherweise unerwünschte oder anstössige Nachrichten
          zu posten. Dabei wird jeder Buchstabe des Alphabets mit
          einem Buchstaben des um 13 Zeichen verschobenen
          Alphabets ersetzt. Der Buchstabe "A" wird dann durch
          ein "N" ersetzt, "N" wird wiederum durch "A" ersetzt
          und "Z" durch "M". Viele aktuelle Leseprogramme für
          Newsgroups können mit ROT13 verschlüsselte Nachrichten
          per Tastendruck chiffrieren bzw. dechiffrieren.

          Hier ist ein Beispiel für einen mit ROT13
          verschlüsselten Text:

                  Klartext                      Mit ROT13
                                                verschlüsselt

                  Ich würde                     Vpu jüeqr
                  hier                          uvre
                  gerne                         trear
                  meine                         zrvar
                  anstössige                    nafgöffvtr
                  Meinung                       Zrvahat
                  hinschreiben,                 uvafpuervora,
                  möchte                        zöpugr
                  aber aus                      nore nhf
                  Höflichkeitsgründen           Uösyvpuxrvgfteüaqra
                  ungern                        hatrea
                  jemand                        wrznaq
                  damit                         qnzvg
                  belästigen.                   oryäfgvtra.

          Gerne möchte ich das Prinzip dieser
          Verschlüsselungstechnik in einem Basic-Quelltext
          wiedergeben, damit damit hervorragend die Vorgänge, die
          für das Durchführen dieser Technik darstellbar ist.
          Folgend der Quelltext eines kleinen Programms, das
          jeden Buchstaben eines Textes beliebiger Länge mit
          einem Buchstaben des um 13 Stellen verschobenen
          Alphabets austauscht:

          10 CLS
          20 PRINT "GEBE DEN ZU CODIERENDEN TEXT EIN!"
          25 INPUT K$
          30 FOR I = 1 TO LEN ( K$ )
          40 X$ = MID $ ( N$, I, 1 )
          50 C = ASC ( X$ ) + 13
          60 IF C > 255 THEN C = C - 255
          70 C$ = C$ + CHR$ ( C )
          80 NEXT I
          90 PRINT "DIE CODIERTE NACHRICHT LAUTET:"
          95 PRINT C$

          Natürlich mutet der Quelltext zur Verschlüsselung noch
          zur Publikation des Sources zur Entschlüsselung an. Bei
          jenem werden die Buchstaben des um 13 Stellen
          verschobenen Alphabetes mit dem original Alphabet
          ausgetauscht:

          10 CLS
          20 PRINT "GEBE DEN ZU ENTSCHLÜSSELNDEN TEXT EIN!"
          25 INPUT V$
          30 FOR I = 1 TO LEN ( V$ )
          40 X$ = MID$ ( V$, I, 1 )
          50 C = ASC ( X$ ) - 13
          60 IF C < 0 THEN C = C + 255
          70 D$ = D$ + CHR$ ( C )
          80 NEXT
          90 PRINT "DIE DECODIERET NACHRICHT LAUTET:"
          95 PRINT D$

          Leider kann sich heuter ein weit weniger vreites
          Spektrum an Personen an der logischen Komplexität von
          Basic erfreuen, und arbeitet mit anderen
          Programmiersprachen. Damit jener nicht zu verachtenden
          Personengruppe keine Mussgunst zugeschrieben wird,
          möchte ich noch gerne einen Quelltext für die
          Handhabung eines Textes durch ein Webinterface eines
          HTML-Dokuments dank Java-Script veröffentlichen. Das
          Script dient gleichermassen zur Ver-, wie auch
          Entschlüsselung eines beliebig langen Textes:

          <script LANGUAGE="JavaScript" TYPE="text/javascript">

          <!--

          function rot_13()
          {
                  alert("Diese Funktion erfordert JavaScript
          1.1!")
          }

          // -->

          </script>
          <script LANGUAGE="JavaScript1.1"
          TYPE="text/javascript">

          <!--

          function rot_13(obj)
          {
                  var keycode     = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                  var text        = new
          String(obj.form.Text.value)
                  var textrot     = new String()

                  for(var i = 0; i < text.length; i++)
                  {
                          var codechar    = text.substring(i, i +
          1)
                          var pos =
          keycode.indexOf(codechar.toUpperCase())

                          if(pos >= 0)
                          {
                                  pos = (pos + keycode.length /
          2) % keycode.length
                                  codechar        = (codechar ==
          codechar.toUpperCase()) ?

          keycode.substring(pos, pos + 1) :

          keycode.substring(pos, pos + 1).toLowerCase()
                          }
                          textrot = textrot + codechar
                  }
                  obj.form.Text.value     = textrot
          }

          // -->

          </script>

     4.7 RC2 (Rivest Cipher 2)

          Diese Verschlüsselungen wurde von Ron Rivest erdacht
          und in die Tat umgesetzt. Daher bedeutet RC auch
          "Rivest Cipher". Sie bieten, im Gegensatz zum DES, die
          Möglichkeit, eine grössere und individuellere
          Sicherheit, da die Schlüssellänge frei definiert werden
          darf. Irrwitzigerweise benötigt es aufgrund des
          Waffenexportverbotes der Vereinigten Staaten, unter
          jenes auch starke Verschlüsselungen fallen, eine
          Erlaubis für dessen Nutzung ausserhalb von Amerika,
          durch die NSA (Natiolan Security Agency).

          Es liegt zwar offiziell eine Beschränkung der
          Schlüssellänge auf 40 Bit vor (eigentlich 56 Bit für
          Zweigstellen amerikanischer Firmen), jedoch gibt es die
          Möglichkeit, eine zusätzliche, bis 40 Bit lange
          Zeichenkette zu benutzen, die an den Schlüssel
          angehängt wird. Falls diese Zeichenkette wirklich nicht
          von Dritten eingesehen werden kann, ist eine
          Entschlüsselung praktisch mit den heutigen technischen
          Hilfsmitteln sinnlos. Zudem kann der Algorithmus
          mehrfach auf den zu verschlüsselten Text angewandt
          werden, womit die effektive Länge des Schlüssels
          vergrössert wird. Wegen der amerikanischen
          Exporteinschränken gewinnen diese Verfahren für
          Entwickler, welche ihre Produkte aus den Staaten
          exportieren wollen, immer mehr an Bedeutung.

     4.8 RC4 (Rivest Cipher 4)

          RC4 wurde von RSA Data Security, Inc. entwickelt, wobei
          das Design des Algorithmus jedoch geheimgehalten wird.
          Vor einiger Zeit jedoch tauchte ein Posting im Usenet
          auf, in welchem ein (wie behauptet wurde) aquivalenter
          Quellecode vorgestellt wurde. Es wird als sehr
          wahrscheinlich angenommen, dass der vorge-stellte
          Algorithmus wirklich aquivalent zu RC4 ist. Der
          Algorithmus ist sehr schnell, seine Sicherheit jedoch
          noch weitgehend unbekannt. RC4 ist im Prinzip ein
          Pseudo-Zufallszahlengenerator, wobei die Zahlen mit den
          zu verschlüsselnden Daten durch XOR verknüpft werden.
          Aus diesem Grund, sollte nicht zweimal der gleiche
          Schlüssel für die gleichen Daten verwendet werden.

     4.9 RC5 (Rivest Cipher 5)

          RC5 wurde 1995 von Ron Rivest entwickelt, und stellt
          Schlüssellängen zwischen 40 und 128 Bit zur Aus-wahl.

          Um einen geheimen 64-Bit-Schlüssel zu knacken, welcher
          mit RC5 generiert wurde, müssen 2^64 =
          18.446.744.073.709.551.616 verschiedene Schlüssel
          ausprobiert werden. Dies ist der 8-fache Aufwand
          gegenüber einem 56-Bit-Schlüssel. Ein einzelner Pentium
          II 400 MHz würde über eine halbe Million Jahre
          benötigen, um alle 2^64 Schlüssel auszuprobieren.

     4.10 SAFER

          Safer ist ein Byte-orientierter Block
          Verschlüsselungsalgorithmus welcher erstmals auf der
          Crypto'95 von James L. Massey vorgestellt wurde. Es
          gibt Versionen mit 64 Bit und 128 Bit Schlüsseln.

     4.11 Triple-DES (Data Encryption Standart)

          Dieses von IBM Mitte der 70er Jahre entwickelte,
          relativ langsame, symmetrische
          Verschlüsselungsverfahren ist sehr gut bekannt, und
          wurde bestens auf das mögliche Bestehen von
          Schwachstellen untersucht.

          Triple-DES nimmt drei verschiedene Schlüssel
          hintereinander, wobei mit dem zweiten entschlüsselt
          wird und mit dem ersten und dritten verschlüsselt.

     4.12 Twofish

          Der Twofish Algorithmus wurde von dem Counterpane Team
          (Bruce Schneier u.a.) entwickelt und ist ein
          Blockalgorithmus, welcher mit einer Blockgröße von 128
          Bit arbeitet, und mit einer Schlüsselgröße von bis zu
          256 Bit über 16 Runden zurecht kommt.

5.0 Assymmetrische Kryptoalgorithmen

     Im Jahr 1976 beschrieben Whitfield Diffie und Martin E. Hellman
     die Möglichkeit einen Verschlüsselungsalgorithmus zu entwickeln,
     der auf zwei unterschiedlichen Schlüsseln basiert. Ein Schlüssel
     ist dabei öffentlich, der andere geheim. Dabei ist eine mit einem
     öffentlichen Schlüssel verschlüsselte Nachricht nur wieder mit
     dem dazugehörigen privaten Schlüssel dechiffrierbar.

     Das erste ktyptographische Verfahren, welches wirklich eine
     assymmetrische Verschlüsselung benutzte, war RSA.

     Die beiden grössten Nachteile sind die Schwierigkeit des geheimen
     und möglichst versteckten Austausches des öffentlichen
     Schlüssels, und der Rechenaufwand, der sich negativ auf die
     Geschwindigkeit einer Session auswirkt. Normalerweise werden die
     öffentlichen Schlüssel während einer Sessioen ausgetauscht, die
     mit einer symmetrischen Verschlüsselungstechnik vor Blicken
     unberechtigter Personen geschützt ist.

     5.1 RSA (Rivest, Shamir, Adleman)

          Dieses Verfahren wurde 1977/78 von Ron Rivest (Siehe
          die RC-Algorithmen!), Adi Shamir und Len Adleman am MIT
          entwickelt, und gilt seitdem als der einzige allgemein
          anerkannte und implementierte Ansatz für die
          Public-Key-Verschlüsselung. RSA wurde patentiert bis
          ins Jahre 2000, jedoch noch  innerhalb der USA. Es ist
          frei erwerbbar. Der Name dieser Methode wurde jeweils
          aus den Anfangsbuchstaben der Nachnamen dessen Erfinder
          erzeugt. RSA verwendet für die Schlüsselerzeugung zwei
          möglichst hohe Primzahlen, aus deren Produkt sich ein
          privater und öffentlicher Schlüssel ableiten lässt.

          RSA gilt als das wohl berühmteste asymmetrische
          Verschlüsselungsverfahren. Dessen Name wurde durch die
          Anfangsbuchstaben der drei Entwickler Rivest, Shamir
          und Adleman gebildet. Als RSA 1977 das erste mal der
          Öffentlichkeit präsentiert wurde, war es das erste
          öffentlich bekannte Verschlüsselungsverfahren, welches
          die 1967 von Diffie und Hellman publizierte Idee eines
          öffentlichen Schlüssels tatsächlich einsetzen konnte.

          RSA basiert auf Rechnungen der ganzen Zahlen modulo ab,
          wobei p und q zwei Primzahlen sein müssen.
          Modulo-Operationen funktieren, indem mit dem Rest einer
          Divisionen gerechnet wird, also mit dem Rest von p und
          q. Wenn nun zum Beispiel pq = 15 ist, dann sind
          folgende Terme korrekt:

          2 + 5 = 7
          2 * 5 = 10
          4 * 5 = 5
          4 * 4 = 1
          1 / 4 = 4

          Von besonderem Interesse sind hier die
          Exponentialfunktionen:

          5 ^ 2 = 10
          4 ^ 7 = 4

          Es ist bis heute kein Verfahren bekannt, diese
          Rechen-Operationen umzukehren. Somit ist also die
          Auflö-sung von p ^ 5 = 12 nicht möglich mit
          mathematischen Möglichkeiten zu lösen.

          Weiterhin ist p ^ {phi (x)} ~= 1 (mod x) eine sehr
          interessante Beziehung, welche schon Euler bekannt war.
          Das ~=-Zeichen zeigt an, dass die oben erwähnte
          Modulo-Operation durchgeführt wird, und zwar mod x. phi
          (x) ist die Eulersche Phi-Funktion. Für uns wichtig ist
          jedoch nur, dass für die Primzahlen p und q phi (pq) =
          (p - 1)(q - 1) gilt:

          a ^ {phi (abq)} ~= 1 (mod ab)
          a ^ {(k * phi (ab))} ~= 1 (mod ab)
          a ^ {(k * phi (ab) + 1)} ~= a (mod ab)

          Wenn wir nun zwei Zahlen d und e einführen, von denen
          wir verlangen, dass de = k * phi (pq) + 1 gelten soll
          (k sei eine beliebige ganze Zahl, ungleich null), dann
          erhalten wir (ab sofort alle Rechnungen modulo pq):

          a ^ de = a
          a ^ d = b
          b ^ e = a

          Hierbei reicht jedoch die Kenntnis von b und d nicht
          aus, um a zu berechnen. RSA basiert nun darauf, dass
          als öffentlicher Schlüssel nun d fungiert, und das
          Produkt pq veröffentlich werden, und die Nachricht a
          damit vershlüsselt wird. Die verschlüsselte Nachricht b
          kann dann bedenkenlos versendet werden, da sie ohne e
          nicht entschlüsselt werden kann.

          Der Verschlüsselungsablauf von RSA funktioniert wir
          folgt:

             * Man wählt zwei verschiedene, möglichst grosse
               Primzahlen p, q.
             * Dann bildet man ihr Produkt n = p q. Weil p
               und q prim sind, ist PHI(n) = (p-1) (q-1).
             * Es müssen zwei Zahlen e und d gefunden
               werden, für welche e d == 1 (mod PHI(n))
               gilt. Man wählt zuerst d so, dass d relativ
               prim zu PHI(n) ist. Ideal ist eine Primzahl d
               > max(p,q) und d < PHI(n)-1. Um e zu finden,
               muss man eine Lösung mit ganzzahligen x und y
               für die Gleichung x d + y PHI(n) = 1 fin-den.
               Es gilt x d == 1 (mod PHI(n)). Setzt man e =
               x mod PHI(n), dann ist auch e d == 1 (mod
               PHI(n)).
             * e und d sind die Schlüssel, n der sogenannte
               Modul. Die Verschlüsselungsfunktion ist E(x)
               = xe mod n, die Entschlüsselungsfunktion ist
               D(x) = xd mod n. Da bei den Funktionen E(x)
               und D(x) modulo n ge-rechnet wird, muss x < n
               sein. Jede Nachricht X muss so in Blöcke x1,
               x2, ... unterteilt werden, dass x1, x2, ... <
               n sind.

          Um das Verfahren möglichst sicher zu machen, müssen
          folgende Regeln befolgt werden, damit die
          Faktorisierung von n = p q schwierig genug ist:

             * p q sollen grösser sein als 10100. Es ist
               sinnvoll, eine möglichst grosse Zahl d, mit d
               < PHI(n)-1, zu wählen, damit d nicht so
               schnell ermittelt werden kann.
             * p und q sollen in der Länge um einige Stellen
               variieren.
             * (p-1) und (q-1) sollen grosse Primfaktoren
               enthalten.
             * Der kleinste gemeinsame Teiler von (p-1) und
               (q-1) sollte möglichst klein sein.

          1993 schätzte man, dass für die Zerlegung der
          130-stelligen Zahl
          114'381'625'757'888'867'669'235'779'976'146'612'010'128'296'721'242'362'562'561'842'935'706'935'245'733'897'830'597'123'563'958'705'058'989'075'147'599'290'026'879'543'541
          in ihre zwei Primzahlen Millionen von Jahren
          dahinscheiden müssten. Tatsächlich gelang es einer
          Gruppe von über 600 Akademikern und Hacker, die sich
          über das Internet koordinierten, bereits ein Jahr
          später die Auflösung. Mathematiker neh-men heute an,
          dass bei einer Verlängerung des Schlüssels auf 250
          Stellen mit einer Zerlegung nicht einmal in einer
          Million Jahren zu rechnen sein könne.

          Die Angriffsmöglichkeiten auf RSA bestehen nun darin,
          aus a und b e zu berechnen. Dies gilt jedoch mo-mentan
          als unrealistisch zu durchführendes Unterfangen.
          Desweiteren kann man aus pq und d versuchen e zu
          berechnen. Dazu muss pq in seine Faktoren zerlegen, was
          ebenfalls nach heutigem technischen Stand nicht in
          annehmbarer Zeit durchführbar ist. Einer andere Attacke
          wird die Durchführung ermöglicht, sobald eine
          verschlüsselte Nachricht an verschiedene Empfänger
          geschickt wird. Dies wird jedoch nur möglich, wenn a an
          mehrere Empfänger verschlüsselt wird, wobei dasselbe d
          verwendet wurde. Dazu muss man dann seine
          mathematischen Fähigkeiten aus dem Ärmel schütteln.
          Dieser Fehler kann im Gebrauch mit PGP (Pretty Good
          Privacy) nicht passieren, da beim Verschlüsseln einer
          Nachricht für viele verschiedene Empfänger der
          IDEA-Schlüssel jedesmal mit einer neuen Zufallszahl
          berechnet wird.

          Public-Key-Verschlüsselungen stellen trotz Knackbarkeit
          der Schlüssel ein relativ hohes Masse an Sicher-heit
          dar, da erstens der öffentliche Schlüssel über
          ungesicherte Datenleitungen weitergegeben werden kann,
          und zweitens bei längeren Verbindungen der
          RSA-Schlüssel nach einer vorgegebenen Zeitspanne
          geändert werden kann. Ein Entschlüsseln einer
          Kommunikation ist somit nach einer gewissen Zeit
          sinnlos.

6.0 Einwegverschlüsselungs-Algorithmen

          Einwegverschlüsselungen werden für das Signieren von
          Nachrichten und das Erstellen von codierten
          Passwörtern, zum Beispiel auch unter UNIX/Linux,
          genutzt. Dabei wird ein Hash-Wert aus der
          unverschlüsselten Eingabe errechnet

          6.1 DH/DSS

               Das Diffie-Hellman-Verfahren wurde vom NIST
               (National Institute of Standarts and
               Technology) zusammen mit der NSA (National
               Security Agency) entwickelt und wurde nocht
               nicht sonderlich gut erforscht. Das Patent
               liegt bei der US-Regierung, die Nutzung des
               Verfahrens ist jedoch kostenlos.

          6.2 MD5 (Message Digest 5)

               MD aus dem Jahre 1991 bedeutet ausgeschrieben
               Message-Digest, und stellt ein Verfahren zur
               Erzeugung von digitalen Unterschriften
               (Hash-Werten) dar. Er gilt als Nachfolger von
               MD2 und MD4, wobei all jene von Ron Rivest
               entwickelt wurden. Er wird in RFC 1321
               definiert.

               Dieser Algorithmus akzeptiert als Eingabe
               eine Botschaft beliebiger Länge,und erzeugt
               davon eine Art Fingerabdruck, oder eine
               Botschaftsverarbeitung von 128 Bit Länge als
               Ausgabe. Die Chancen, dass aus zwei
               unterschiedlichen Texten ein identischer
               Fingerabdruck generiert werden kann, ist
               beinahe unendlich, aber nicht
               auszuschliessen.

               Den Boer und Bosselaers wurden fündig, was
               Schwachstellen anbelangt. Van Oorschot und
               Wiener liessen dazu genauere Abschätzungen
               verlauten.

               Als Zusatz zu MD5 gibt es "Noiz", ein
               Softwarepaket zur Akkumulation zum Erstellen
               von kryptographisch-starken Zufallszahlen.

          6.3 SHA/SHA1 (Secure Hash Algorithm)

               Ein zum Signieren gedachter Secure Hash
               Algorithm, welcher vom NIST und der NSA
               entwickelt wurde. SH1 ist der verbesserte
               Nachfolger vom im Jahre 1994 erschienenen
               SHA. Er ist relativ langsam, gilt jedoch als
               sicherer, als MD5.

  ------------------------------------------------------------------------
Siehe auch Algebra, Algorithmus, Arithmetik, Brute-Force, Kryptoanalyse,
Kryptografie, Kryptologie, Mathematik, PGP, Trigonometrie, Verschlüsselung
  ------------------------------------------------------------------------
                               Dieser Text ist unverfälscht frei kopierbar!
                                         Marc Ruef <marc.ruef@computec.ch>
                                                    http://www.computec.ch/
