
CRIPTOLOG¡A
===========

Unas definiciones b sicas:

. Criptograf¡a: ciencia y arte de escribir para que sea indescifrable el
contenido del texto escrito, para quien no posea la clave.

. Cifrado: proceso de transformaci¢n del texto original en el texto cifrado.

. Descifrado: proceso de transformaci¢n del texto cifrado en el texto original.

. Clave: par metros que controlan los procesos de cifrado y descifrado.

        NOTA: una clave no es simplemente una palabra, pueden ser dos n£meros
        primos, n£meros + operaciones, etc.

. Criptoan lisis: ciencia que estudia los m‚todos de descubrir la clave, a
partir de los textos cifrados, o de inserci¢n de textos cifrados falsos v lidos
para el receptor, u otros m‚todos (m s tarde veremos).

. Criptolog¡a: conocimiento que engloba la criptograf¡a y el criptoan lisis.
¨Mas (S/n/=)? 
Pre mbulo, a modo de esquema:

* Sistema criptogr fico CLASICO (no incluye sistema clave p£blica):

5 componentes:

   M: conjunto de TODOS los mensajes posibles a transmitir.

      NOTA: *NO* se refiere a todos los textos que se pueden construir con
      el alfabeto que usemos. Se refiere a todos los mensajes susceptibles
      de ser enviados. Por ejemplo, si NUNCA enviaremos un mensaje que diga
      "hoy llueve en Madagascar", pues dicho mensaje NO pertenece a M. ¨Ok?

   C: conjunto de TODOS los mensajes cifrados.

   K: conjunto de TODAS las claves posibles a usar.

   E: conjunto de TODOS los m‚todos de cifrado E={Ek/M->C para toda kîK}

   D: ¡dem con descifrar D={Dk/C->M para toda kîK}


Todo criptosistema debe cumplir:

   1. Todas las transformaciones Ek y Dk deben ser "f cilmente" calculables.
   (No puedes tardar 3 horas en cifrar un texto de 1000 letras).

   2. Los algoritmos de Ek y Dk deben ser f cilmente implementables.
   (Para ir r pidos el cifrado se hace por hard mejor que por soft).

   3. LA SEGURIDAD DEL SISTEMA S¢LO DEBE DEPENDER DEL SECRETO DE LAS CLAVES kîK
   Y NO DE LOS ALGORITMOS DE LAS TRANSFORMACIONES E y D.

* Ataques destinados a descubrir la clave secreta:

   . S¢lo con texto cifrado: el criptoanalista conoce todos los mensajes
   cifrados (tiene la l¡nea pinchada y ve circular los mensajes cifrados).

   . Con texto original conocido: conoce todas las parejas de texto
   cifrado/descifrado que han circulado hasta el momento.

   . Con texto original escogido: puede obtener el texto cifrado a cualquier
   original que L escoja (si conoce el de cualquier, aunque no lo escoja ‚l,
   ya no necesita saber la clave, jeje).

   . Con texto cifrado escogido: viceversa de la anterior.

Normalmente se dise¤an los S.C. de manera que resistan los ataques de los
puntos 1 y 3, que son los que dan "m s informaci¢n" al c.a.

* SECRETO: el criptoanalista es incapaz de determinar el texto original a
partir del texto cifrado que haya podido interceptar. Es decir, el c.a. chupa
un mensaje cifrado, y es incapaz de descifrarlo. Exige:

   1. el c.a. no debe poder determinar (computacionalmente hablando) la
   transformaci¢n Dk (NO CONFUNDIR Dk con D!! D es el m‚todo, lo conoce, lo que
   no conoce es m‚todo+clave, le falta la clave!!) a partir del mensaje cifrado
   c, aun conociendo el mensaje original m.

   2. el c.a. no debe poder determinar el mensaje original m, sistem ticamente,
   a partir de la sola intercepci¢n del mensaje cifrado c.

Resumiendo => El SECRETO requiere, £nicamente, no revelar Dk, mientras que Ek
puede ser p£blica. (Si Ek es p£blica el sistema se llama sistema de clave
p£blica, y si Ek secreta -NOTA de nuevo, Ek secreta, no E, E y D son siempre
p£blicos, los m‚todos!!- el sistema es de clave secreta o sistema criptogr fico
cl sico).

* AUTENTICIDAD: el c.a. es incapaz de improvisar, o sustituir, un texto cifrado
falso c' en lugar del texto real c sin que el receptor lo detecte. Tambi‚n
tiene dos requerimientos:

   1. el c.a. no debe poder determinar (computacionalmente hablando) la
   transformaci¢n Ek (no confundir con E, de nuevo!!) correspondiente a un
   mensaje cifrado c, aun conociendo el original m.
   2. el c.a. no debe poder determinar (computacionalmente) un mensaje cifrado
   c' tal que Dk(c')îM. Es decir, un mensaje que el receptor no detecte como
   extra¤o.

Resumiendo => La AUTENTICIDAD requiere, £nicamente, la no revelaci¢n de la
transformaci¢n de cifrado Ek, mientras que Dk puede ser p£blica.
NOTA: NO confundir Dk y Ek con D y E, D y E son los m‚todos, los algoritmos si
quer‚is, no la uni¢n del m‚todo m s la clave!! (entendiendo por clave no s¢lo
una palabra "password", clave engloba, dependiendo del m‚todo, otros factores,
como puede ser una operaci¢n o un conjunto de n£meros -por ejemplo 2 primos-
etc.).

* CRIPTOSISTEMAS:

   . Restringidos: mantienen secretos la naturaleza del proceso de cifrado y
   descifrado (es decir, los m‚todos E y D) ­­ESTAN FUERA DE CIRCULACI¢N!! No
   se consideran "viables" y el hecho de esconder el m‚todo no presupone mayor
   seguridad. Si la seguridad se basa en el secreto del m‚todo, es una
   porquer¡a, tarde o temprano se conoce y no necesariamente a trav‚s del
   canal, y si no, pues ¨para qu‚ esconderlo? :)

   . Clave privada: la clave es secreta (el conjunto de claves K debe ser muy
   extenso para evitar la b£squeda exhaustiva, por ejemplo, si las claves son
   de 3 s¡mbolos, simplemente con V26,3+V26,2*V26,1=26*25*24+26*25+26=16276
   pruebas considerando el alfabeto de 26 letras, o con 16646400 pruebas
   considerando el alfabeto ASCII extendido -256 s¡mbolos- listos).

   . Clave p£blica: la clave de descifrado es secreta, no as¡ la de cifrado. 
   Y es computacionalmente imposible encontrar Dk a partir de Ek.
   
   . Cu nticos
   
   . Probabil¡sticos

* Comunicaciones (desde un punto de vista criptol¢gico):
   
   . Privadas: no pueden haber intromisiones. IMPOSIBLE! Por eso las hacemos
   seguras!!

   . Secretas: cuando los esp¡as pasivos no pueden obtener ninguna informaci¢n
   de los mensajes interceptados.

   . Identificables: el emisor puede demostrar al receptor su identidad, pero
   el receptor no puede tener la certeza que no miente.

   . Aut‚nticas: el receptor est  convencido que la comunicaci¢n -el mensaje-
   proviene del emisor supuesto (presupone identificabilidad, claro).

   . Seguras: cuando la clave no es vulnerable:

   . Condicional: los m‚todos son seguros hasta que el c.a. disponga de
     mejores y m s eficientes medios (por ej. el DES).

   . Incondicional: cuando es absolutamente imposible obtener la clave.

   . Probable: cuando no se puede demostrar que el sistema ha sido vulnerado
     (por ej. el DES).

   . Computacionalmente demostrable: cuando el sistema se basa en la
      complejidad de los c lculos para obtener la clave (por ej. el RSA).

   La seguridad se basa no en el sistema criptogr fico en s¡, que generalmente
   se hace p£blico, sino en la clave (sistemas de clave privada) o en la
   complejidad del c lculo (sistemas de clave p£blica).

TEOR¡A DE LA SEGURIDAD PERFECTA (Shannon)
===============================

. Seguridad te¢rica: un sistema criptogr fico cumple los requisitos de
seguridad te¢rica si es irrompible, aun cuando el criptoanalista disponga de
tiempo y recursos ilimitados.

. Seguridad pr ctica: ¡dem pero suponiendo que el criptoanalista dispone de una
cantidad limitada de tiempo y de recursos.

Nota: irrompible = ning£n ataque criptoanal¡tico es eficiente para encontrar
la clave.

NOTA: hoy en d¡a ning£n sistema cumple los requisitos de la seguridad te¢rica,
exceptuando aqu‚l en que la longitud de la clave es la misma o superior a la
del mensaje y s¢lo se utiliza UNA vez.

* Propiedades de los s.c:
   
conj. mensajes originales M, probabilidades p(m) t.q. äp(m)=1
conj. mens. cifrados C, prob p(c) t.q. äp(c)=1
conj claves K, prob. p(k) t.q. äp(k)=1
p(mi/cj) es la probabilidad que mi haya sido enviado sabiendo que
cj ha sido recibido (= cj mensaje cifrado correspondiente a mi).

entonces, SECRETO PERFECTO si y solo si p(M/C)=p(M),
es decir, la interceptaci¢n del texto cifrado no da ninguna informaci¢n al
criptoanalista.

Un criptosistema con textos originales M y criptogramas C es perfectamente
secreto si y s¢lo si H(M/C)=H(M) donde H(X)=-äp(X)log(p(X))
³
À> el secreto perfecto existe:

      M, C, K incluidos en F^n con q elementos en F^n
      tenemos q^n claves, escogemos una, hacemos c=m xor k
         => p(m/c)=p(m/(m xor k))=1/q^n
         i como p(m)=1/q^n listos!!

=> COTA FUNDAMENTAL DE SHANNON: en un criptosistema perfectamente secreto se
cumple que H(K)>=H(M)

   Corolario: si los d¡gitos de la clave K y los del texto original M son
   escogidos de alfabetos con el mismo cardinal, ser  criptosistema secreto
   si y s¢lo si long(k)>=long(M)

      (= la longitud de la clave debe ser, como m¡nimo la misma que la del
      texto a cifrar, i s¢lo usarse una vez).

TEORIA DE LA AUTENTICIDAD PERFECTA (Simmons)
==================================

Se supone que el criptoanalista puede generar mensajes cifrados falsos
(fraudulentos), y que la clave s¢lo es usada una vez para formar el criptograma
aut‚ntico.

Entonces, el c.a. puede llevar a t‚rmino dos tipos de ataques:

  . Ataque de personalizaci¢n: formar un criptograma c' sin esperar a ver el 
    c. Tendr  ‚xito si el receptor legal acepta c'.

  . Ataque de sustituci¢n: formar un criptograma fraudulento c' una vez visto
  el aut‚ntico cîC. Tendr  ‚xito si el receptor acepta c' como aut‚ntico, y
  Dk(c')=m'<>m, siendo m el mensaje original.

* Probabilidad de enga¤o:

  Sea Pp la probabilidad de ‚xito del ataque de personalizaci¢n, y Ps la del
  ataque de sustituci¢n.


  Entonces, la probabilidad de enga¤o Pe=m x(Pp,Ps)<>0 SIEMPRE!

    Por qu‚ siempre ser  diferente de cero?

      Existen #M criptogramas c t.q. P(c/k)<>0
      entonces, si escogemos c' para atacar por personalizaci¢n,
              Pp=#M/#C
          ³
          ³
         \/
         Una buena protecci¢n contra el ataque de personalizaci¢n
         es #C>>#M

* Cota de Simmons:

  Pp verifica logPp>=-I(C,K)

  donde I(M,C) nos expresa la informaci¢n que sobre M variable aleatoria nos
  proporciona el conocimiento de la v.a. C, o viceversa: I(X,Y)=H(X)-H(X/Y)=
                                                              =H(Y)-H(Y/X)>=0
  y como Pe=max(Pp,Ps) tambi‚n verifica logPe>=-I(C,K)

* Autenticidad perfecta:

  Un criptosistema tiene la propiedad de autenticidad perfecta si verifica
  logPe=-I(C,K)

------------------------------------------------------------------------------

-> Consideraciones para el dise¤o de criptosistemas: (Shannon)

Th(n): cantidad media de trabajo necesario para encontrar la clave del
criptosistema, suponiendo que trabajamos con el mejor de los algoritmos de c.a.
conocidos.

Para maximizar Th(n), Shannon introdujo los conceptos de:

  . Difusi¢n: consiste en expandir la influencia de cada s¡mbolo del texto
  original sobre tantos s¡mbolos del texto cifrado como sean necesarios, para
  evitar un ataque sobre la clave basado en un fraccionamiento del texto
  cifrado.

  Explico: si no se aplica la difusi¢n, dos bloques iguales de texto original,
  una vez cifrados dar n como resultado dos bloques iguales de texto cifrado!!
  Si trabajamos a nivel de bit, la difusi¢n m s sencilla consiste en hacer un
  xor (porque es invertible con otro xor) con el bit anterior, o por bloques 
  de bits, los 8 bits de salida de t1 con los 8 bits de salida del paso t0
  anterior. (Nota: har n falta, ya sea un bit o una cadena de bits, unos datos
  iniciales para el primer xor, claro).

  . Confusi¢n: consiste en el uso de transformaciones de cifrado que compliquen
  la realizaci¢n de correlaciones estad¡sticas entre el texto original y el
  texto cifrado. (Por ejemplo utilizar sustituciones homof¢nicas, m s adelante
  veremos, teniendo en cuenta que por s¡ solas no ofrecen garant¡a de
  seguridad).


CRIPTOSISTEMAS DE CLAVE SECRETA (sim‚tricos o de clave £nica)
===============================

El emisor y el receptor comparten una £nica clave k => su caracter¡stica
principal es la existencia de un CANAL SEGURO para transmitir la clave.

(NOTA: aqu¡ aparece la incongruencia de "¨y por qu‚ no mandamos los datos por
el canal seguro?", pero como sois chicos inteligentes ya habr‚is deducido que
el canal seguro s¢lo es necesario que exista de vez en cuando, por ejemplo dos
de vosotros os veis de tanto en cuando y aprovech is para pasaros las claves
-incluso con una sola vez basta- mientras que como viv¡s en ciudades distintas,
por ejemplo, us is la Visi¢n cada d¡a, y no es un canal seguro, hehehe...
Bueno, no lo explico "cient¡ficamente" porqu‚ ya ha quedado claro as¡
pachanguero).


1. Basados en transposiciones: consisten en una reordenaci¢n de los caracteres
del mensaje cifrado mediante un esquema preestablecido. Ejemplo: escribir el
texto en una matriz, filas y columnas; entonces permutamos filas por columnas
y lo leemos de nuevo. Es decir, simplemente cambiar las letras de orden,
siguiendo unos patrones m s o menos complicados.

MUY F CIL DE ROMPER: las letras tienen el mismo # de apariciones en el mensaje
original que en el cifrado (si hay 70 a's en el original, hay 70 en el cifrado,
etc.)


2. Basados en sustituciones:

2.1. Sustituciones simples: cada letra del alfabeto à es cambiada por otra
letra del alfabeto á (los dos alfabetos con el mismo cardinal, es decir, hay
tantas letras en à como en á). Generalmente los dos alfabetos tienen los mismos
caracteres (de la A a la Z por ejemplo, o el ASCII ambos) pero en diferente
orden. La clave es la aplicaci¢n car cter-car cter.
Por ejemplo: Julio C‚sar usaba dos alfabetos à=(ABCDEFG..Z) y á=(DEFG...ZABC),
es decir, cambiaba las A's por D's, las B's por E's, etc. Hoy en d¡a lo
escribir¡amos como c=m+3 mod 26 donde A=0, B=1, C=2, etc.

2.2. Homof¢nicos: para evitar su rompimiento por frecuencias de aparici¢n
(estad¡stica, el m‚todo anterior es f cilmente rompible con este m‚todo, cada
letra en cada idioma tiene una frecuencia de aparici¢n determinada, igual que
los d¡grafos -ejemplo "qu" m s probable que "lk"- y los tr¡grafos -m s ya no
vale la pena-) se puede asignar un mismo car cter del texto a cifrar a un
conjunto de caracteres, y escoger uno aleatoria o c¡clicamente.
Por ejemplo, en lugar de cambiar las "a" por "p" las podemos cambiar por "â",
"" o "ä", y cuando nos llegue uno de estos tres s¡mbolos ya sabremos que es la
"a". Se rompe la estad¡stica pero siguen siendo f cilmente rompibles.

2.3. Polialfab‚ticos: usamos 'i' alfabetos para cifrar (ái) i cuando aparece
un s¡mbolo repetido para cifrarlo cambiamos de alfabeto. Tambi‚n son f cilmente
rompibles encontrando el n£mero 'i' de alfabetos usados y despu‚s resolvi‚ndolo
como 'i' sustituciones simples.


3. Matriciales: operan sobre bloques de s¡mbolos, dispuestos en forma de tablas
de dimensiones prefijadas.

M‚todo: tenemos una aplicaci¢n entre 2 alfabetos: à (caracteres) y á
(num‚rico), definimos una matriz cuadrada kxk que ser  la clave, llena de
n£meros de á. Ponemos el bloque de texto en una matriz M y hacemos la
aplicaci¢n à->á, entonces multiplicamos Mxk mod (#á + 1) y deshacemos la
aplicaci¢n.

(Si no ha quedado claro ya pondr‚ un ejemplo, dec¡dmelo).

4. Cifrado en flujo: las t‚cnicas vistas hasta ahora, cifrado en bloque, tienen
la desventaja que el texto cifrado correspondiente a dos bloques id‚nticos, es
id‚ntico. Para evitar este problema se usan t‚cnicas de encadenamiento entre
los bloques a cifrar, de manera que el cifrado de un bloque dependa de los
bloques que lo preceden (t‚cnica de difusi¢n de Shannon). INTRODUCIMOS EL
CIFRADO A NIVEL DE BITS!!

Nota: el bloque cifrado puede depender del/los bloques precedente/s originales
Y/O cifrados!!
------------------------------------------------------------------------------

Bueno, aqu¡ vendr¡an las descripciones de los m‚todos de cifrado DES y PES,
pero es un palazo picarlas (dibujitos, matrices, etc.) todo y ser dos
algoritmos no excesivamente complicados (mejor dicho, facilotes).


CRIPTOSISTEMAS DE CLAVE P£BLICA
===============================

Cada usuario dispone de una transformaci¢n de cifrado Ek, registrada en un
fichero p£blico, y de una transformaci¢n de descifrado Dk, que s¢lo ‚l conoce
(no confundir con Ek y Dk con E y D, no es el algoritmo, es la uni¢n de
algoritmo+clave!!).

Dk est  descrita en t‚rminos de una clave secreta y Ek lo est  mediante un
algoritmo o funci¢n que no permita, a pesar de su conocimiento y desde un punto
de vista computacional, la revelaci¢n de Dk. Por tanto es una transformaci¢n
unidireccional (con TRAMPA, porque existe la transformaci¢n inversa,
desencriptar!, si se conoce la clave! En el caso del RSA la clave son dos
n£meros primos de 200 d¡gitos como m¡nimo, que se dan a conocer multiplicados
entre s¡, para poder encriptar, pero como es computacionalmente imposible
factorizar dos primos tan enormes, nadie, salvo quien los conoce, puede
desencriptar... bonito truco, ¨eh?).

En este tipo de sistemas, el secreto y la autenticidad vienen dados por
algoritmos diferentes.

NOTA: a priori la autenticidad no est  garantizada, con este algoritmo de
encriptamiento, puesto que CUALQUIERA puede enviar un mensaje encriptado y
hacerse pasar por otro remitente!!.

Una forma de proteger la autenticidad es exigiendo que la pareja de
transformaciones Ek y Dk de cualquier usuario verifiquen, adem s, que Ek sea
la transformaci¢n inversa de Dk (FIRMA DIGITAL!), es decir, que Ek(Dk(m))=m.

Entonces, cualquier usuario puede firmar sus mensajes mediante la

TRANSFORMACI¢N SECRETA Dk!!

  . ejemplo: A quiere enviar a B el mensaje m, entonces primero lo firma con
  DkA(m)=s y lo env¡a a B con EkB(s)=c.

  Cuando B lo recibe lo descifra con DkB(c)=s, para ‚l s es incomprensible, y
  lo autentifica "cifr ndolo" con EkA(s)=m y listos!! Como A es el £nico que
  posee DkA, el mensaje es aut‚ntico.

(A m¡ este m‚todo me gust¢ mucho)


Veamos un cripstosistema de clave p£blica:

* RSA:

  La funci¢n de cifrado es E(e,n)(x)=x^e mod n

          0<x<n
          0<e<í(n) y mcd(e,í(n))=1

  donde n=pq y p,q primeros, diferentes y enooormes (como m¡nimo 200 cifras
  decimales).

  Nota: para cifrar 'n' es conocida, no as¡ 'p' y 'q', que s¢lo los conoce el
  que descifra.

  La de descifrado: D(d,n)(y)=y^d mod n donde 'd' es el inverso de 'e'

  La clave k es k={p,q,í(n),d}

  í(n) es la funci¢n de Euler, y se define como:

      N--->N
      n|-->í(n)=#{xîN/x<n, x primero con n}

  ejemplo: í(4)=n£mero de n£meros menores que 4 y primeros con 4: el 1 y el 3,
  í(4)=2 por lo tanto.

  Nota: si n es primero, í(n)=n-1, puesto que los n-1 anteriores son primeros
  con n!!

  La fortaleza del m‚todo se basa en la imposibilidad de factorizar 'n', es
  decir, quien sabe 'n' no puede encontrar, computacionalmente hablando
  (tardar m s de 100 a¤os se considera computacionalmente imposible, por
  ejemplo), 'p' y 'q'.

Firma digital en el RSA:

  E y D son inversas, pero si tanto el usuario A como el B quieren firmar los
  mensajes que se intercambien, llegamos a la conclusi¢n que nA=nB (donde nA 
  es el valor de n para encriptar los mensajes para A y nB el valor de n para
  encriptar los mensajes para B), con lo cual, tanto A como B conocen los
  valores p y q respectivos, pues son los mismos!!

A ver si me da tiempo a incluir tambi‚n unos breves apuntes sobre FLSR
(hardware espec¡fico para "divisiones largas" entre polinomios y que en
criptolog¡a se usan para generar secuencias pseudo-aleatorias de bits,
peri¢dicas, y que seguro que cae uno en el examen :>), pero aun no domino el
tema...

Espero que os hayan gustado estos boletines, y perdonad los errores!

