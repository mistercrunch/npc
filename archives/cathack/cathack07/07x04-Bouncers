.------------------.
| CatHack #007 - 3 |
| 07x03 - Bouncers |
| programació/hack |
| --[ adjunts ]--  |
| . pbouncer.mrc   |
| . pbouncer.c     |
`------------------'


  .------.
.'        `.         = = =                  = = =
| Bouncers |       =       =              =       =          =
`.        .'      =         =           =          =       =   =
  `------' =     =           =        =             =     =      = _________
           =    =             =     =                =   =        |         |
            =  =               =  =                   = =         | Pop.tPH |
             =                  =                      =          |_________|

________________
\ index.txt
 | 1. introducció
 |  1.1 teoria visual
 |  1.2 exemple extern
 |  1.3 exemple intern
 | 2. programació
 |  2.1 teoria
 |  2.2 pbouncer.mrc
 |  2.3 pbouncer.c
 | 3. Acomiadament



.-------------------.
| Introducció:      |
`-------------------'

Aquest article preten ser no tant sols d'introducció sino també de nivell alt,
programant i amb algunes practiques per demostrar el funcionament d'aquests
programes.

Els bouncers (de l'anglès "rebotadors" (d'aqui la parida del titol ascii xD))
són programes que, com el seu nom indica reboten conexions d'una maquina a
una altre, i per tant ocultant la identitat de la primera màquina.

Normalment aquests programes s'utilitzen com he dit abans per ocultar la
identitat, encara que també es poden utilitzar com a sock_proxys, ja que
si una màquina té accés a una altre xarxa, la resta d'ordinadors conectats
a ell a través del port x que controli el bouncer podran conectar-se a
maquines remotes de la xarxa indicada pel bouncer.

Una altre de les utilitats que li podem trobar a un bouncer, es que si es
capaç de redireccionar les entrades i sortides de la connexió en un fitxer
log, podriem ser capaços de poder controlar tot el que fa la gent quan
entra a cert port, per exemple, si nosaltres volem loguejar el sendmail del
Linux per saber qui envia emails, a on els envia i que envia podriem
modificar el port d'escolta del dimoni (en lloc del 25 canviar-lo a un
port alt (poc escanejable, ja q esta lluny dels utilitzats) com per exemple
el 65000, (aixo es fa modificant el fitxer /etc/services o el /etc/inetd.conf
i reiniciant el dimoni inetd (killall inetd , inetd &) i llavors cargar el
bouncer en el port 25 que redireccioni les conexions del port 25 al port
65000 de la maquina localhost (127.0.0.1).


1.1 Teoria visual:
------------------
Suposem que nosaltres som la maquina (A), que ens conectem a la maquina (B)
que té un bouncer escoltant al port X redireccionant les conexions d'aquell
port a la màquina (C) inaccesible per (A), ja que no té gateway.

 Subred 1 (192.168.0.0)       Subred 2 (192.168.1.0)
.-------------------------. .-------------------------.
    _____                                     _____
   |     |                                   |     |
   | (A) |------.        _____        .------| (?) |
   |_____|      |       |     |       |      |_____|
    _____       |-------| (B) |-------|       _____
   |     |      |       |_____|       |      |     |
   | (?) |------'                     `------| (C) |
   |_____|                                   |_____|


1.2 Exemple extern:
-------------------

(A) # configurem les taules d'enrutament i la ip de la maquina
     $ifconfig -v eth0 192.168.0.2
     $route add -net 192.168.0.0 netmask 255.255.255.0 dev eth0

(B) # configurem les taules d'enrutament i les ips de cada targeta
    # de red de la maquina (eth0, eth1)
     $ifconfig -v eth0 192.168.0.1
     $ifconfig -v eth1 192.168.1.1
     $route add -net 192.168.0.0 netmask 255.255.255.0 dev eth0
     $route add -net 192.168.1.0 netmask 255.255.255.0 dev eth1
    # aquesta maquina no té ip-masquerade (no fa de gateway)
     $./bouncer x (C) 23
          |     |  |  |___ port remot
          |     |  |______ maquina remota (192.168.1.x)
          |     |_________ escoltar al port x
          |_______________ suposat nom del bouncer (aquest programa no
                           existeix, i si existeix no l'incloc en l'article,
                           es simplement una demostració.

(A) # probem si podem accedir-hi desde (A) ((C) esta dins /etc/hosts :)
    # o (B) té la DNS compartida en les 2 xarxes, mal fet si no estan
    # enllaçades!
     $ping (C)

      PING 192.168.1.3 ((C)) : 56 data bytes
      ping sento: Network is unreachable
      ping wrote 192.168.1.3 64 chars, ret=-1
      ping sento: Network is unreachable
      ping wrote 192.168.1.3 64 chars, ret=-1
      ^C
      --- 192.168.1.3 statistics ---
      2 packet transmitted, 0 packets received, 100% packet loss

    # molt bé, no podem accedir-hi desde (A)

(B) # pinguem la maquina (C) desde (B) 
     $ping (C)

      PING 192.168.1.3 ((C)) : 56 data bytes
      64 bytes from 192.168.1.3 : icmp_seq = 0 ttl=255 time=1.3ms
      64 bytes from 192.168.1.3 : icmp_seq = 1 ttl=255 time=1.3ms
      ^C
      --- 192.168.1.3 ping statistics ---
      2 packets transmitted, 2 packets received, 0% loss
      round-trip min/avg/max = 1.3/1.3/1.3 ms

    # si que podem accedir desde (C)

(A) # ens conectem al bouncer de (B) per anar a la maquina remota.
     $telnet (B) x

      Trying 192.168.0.1...
      Connected to (B).
      Escape character is '^]'

      Linux 1.0.9 (486.pancake) (ttyp0)

      486 login:
    
    # la resposta que ens dona es la de la maquina (C) al port 23 
    # -hem accedit!



1.3 Exemple intern:
-------------------
Ara anem a ampliar la màquina (B) i a veure els processos que realitza dins
seu el programa bouncer quan rep una conexió i la redirecciona a la maquina
(C).    
        ________________________           ______________________
       | port |       (B)       |         | port |       (C)     |
       |______|_________________|         |______|_______________|
 .------ 1028 <------------.    |         |      |               |
 |     |      |             |   |         |      |               |
 |   .-----------[bouncer]--'   |         |      |               |
 |   `-- 1025 <---------------------------- 1320 <-------------. |
 |     | 1024 ---.              |         |      |             | |
 |     |  ^   |   `-.           |         |      |             | |
 V     |  `-----.    `--------------.     |      |             | |
       |      |  `-----------.  |   |     |      |             | |
(A) -> |  99  | --[bouncer]--'  |    `--> |  23  | --[telnetd]-' |
       |______|______ v ________|         |______|_______________|
                   __| |__
                   \     /
                     \ /
             ___________________
            | /tmp/bouncer.log  |
            |___________________|

NOTA: Els ports d'escolta son el 99 (B) i el 23 en (C) la resta son ports
asignats pel sistema operatiu per poder establir conexions, com un podeu
fixar per una conexió calen 2 ports (un a cada màquina), aquests ports
només poden ser utilitzats per la màquina i el programa q les han establert
...be tb podem fer hi-jacking, pero no vé a cuento fer res d'aixo ara :)


2.0 Programació:
----------------
Anem a fer el nostre propi bouncer, jo us explico la teoria i després us
donaré 2 bouncers escrits per mi, un en forma de shellscript per mirc i
un altre en forma de ASM per linux, si els probeu no us funcionaran...i
direu i pq?? doncs logicament pq estic en contra dels scripts-kiddies q
pillen un programa i l'executen sense saber q fa, aixi k abans de compilar
i probar: aprengueu a programar reviseu el codi i modifiqueu el k he
canviat pq no ruli.


2.1 Teoria:
-----------
Primer caldrà q analitzem el problema: volem un programa k escolti a un port
i que quan rebi alguna conexió l'accepti i realitzi una conexió a una maquina
remota, un cop realitzats aquests pasos tot el que llegeixi de cadascuna de
les dues conexions ho escriurà a l'altre conexio i viceversa.

Com a opció podem fer que el programa capturi la connexió, escribint una copia
de les entrades i sortides de les dues connexions, conseguint aixi una millor
seguretat ja que podriem veure si realment ens utilitzen per fer un telnet
a una maquina remota i punt o si aquella maquina remota l'utilitza de condó
per entrar en d'altres maquines,llavors caldria tancar la connexió i avisar al
nano k ho hagi fet, k utilitzar condons està mal fet (visca el sexe lliure xD)
i logicament si ens ha utilitzat de condó, nosaltres podriem veure ens els
logs del bouncer els logins i passwords de totes les maquines en k ha entrat
i avisar a les maquines remotes k tenen un usuari k els utilitza de condó,
o per el contrari utilitzar-los de condó (no recomenable ja q es ilegal :)

També podem interferir la conexió parant el reply de les dades d'un o de
l'altre, per mantenir la conexió en "wait" o "mute" depen del k vulguem.

(A) --> (B) --> (C)

(MUTE) - talla la comunicació de (C) cap a (A). Com a conseqüència (A) no
         podria llegir els replys de la maquina remota.

(WAIT) - talla la comunicació de (A) cap a (C). El usuari (A) podria
         escriure tot el k vulgues k mai arribaria a (C), en canvi, ell
         podria llegir el k (C) li diu.

També podem interferir en comunicacions, escribint coses a la pantalla de (A)
o escribint coses a la maquina remota (C) sense k (A) ho sapigues. Aixo
simplement es faria fent un write(out_sock,buffer,sizeof(buffer)); o in_sock
mentre la conexió estigués establerta.

Com ja us he dit abans, el codi no funciona correctament per la simple raó
d'evitar k els scripts-kiddies s'aprofitin del k no saben i es dediquin a
fer guerres, troyanos, condons i d'altres espècies per empitjorar la seguretat
a l'irc (dic irc pq es el k dona més joc en quan a guerres virutals).

Si voleu utilitzar els bouncers a continuació inclosos per millorar la
seguretat d'un servidor per loguejar les conexions i demés, estaria bé
que els tornéssiu a escriure vosaltres desde 0, acceptant més d'una conexió
a l'hora o donant missatges de "All Connections In Use", intentant delimitar
els buffers millor per evitar buffers overflow (ja que normalment els bouncers
es carguen com a root i podrien perillar la seguretat en la màquina) o 
Segment Fault (Core Dumped) que tallesin el funcionament del bouncer i amb
conseqüència una caiguda del servei ofert.


2.2 Bouncer.mrc:
----------------
Us proporciono un bouncer força configurable amb suport per logs a temps
real de cada una de les i/o de cada maquina conectada a nosaltres (A) i (C),
per cargar aquest bouncer cal incloure aquestes linies en el fitxer remote.ini
del mIRC o fer /load amb els corresponents flags per cargar-ho per remote.ini.

La finalitat d'aquest codi i la resta dels k hi ha més abaix es la d'experi-
mentar en l'us de les xarxes i intentar millorar la seguretat dels servidors
sense haver de modificar cap cf de cap dimoni i recompilar res, sino
simplement instal.lant un bouncer.

(mira la part d'attached)


2.3 pBouncer.c:
---------------
Cal dir que aquest codi és també experimental, i que falla per tot arreu i no
té gaires possibilitats, em sap greu haver de donar-vos aquest cf, però és el
k hi ha, entre tants examens, no tinc gaire per tocar l'ordinador :((

(mira la part d'attached)




3. Acomiadament:
----------------
Espero que us hagi agradat i li hagueu vist utilitats, o com a minim despertar-vos
les ganes de programar i practicar una mica amb mitjonets (sockets).

Per acabar us recordo que podeu col·laborar amb la ezine tant com vulgueu, ja que
estem totalment oberts.

Siau


(pop)
  |
  `--(ºoº)--.___.~~~
._.--´   `--.__.--.___