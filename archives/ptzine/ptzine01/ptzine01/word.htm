<HTML>
<HEAD>
<TITLE>.pt zine - Utilit&aacute;rio de cracking para DOS - word</TITLE>
</HEAD>
<BODY BGCOLOR="Black" TEXT="#000000" LINK="Green" VLINK="Red">
<IMG SRC="pt_small.gif" WIDTH=452 HEIGHT=81 BORDER=0>
<P>
<FONT SIZE="5" FACE="Arial" COLOR="#FFC639">
<B>Utilit&aacute;rio de cracking para DOS - word:</B><BR>
-----------------------------------------------
</FONT>
<BR>
<FONT SIZE="3" FACE="Arial" COLOR="#FFC639">
by Elektro
<P>
ATEN&Ccedil;&Atilde;O: O C&Oacute;DIGO DESTE PROGRAMA N&Atilde;O &Eacute; PORT&Aacute;VEL PARA SISTEMAS LINUX!!!!<BR>
         FOI 100% DESENVOLVIDO EM SISTEMA MS-DOS (TURBO C), E OCORRER&Atilde;O
         ERROS DE EXECU&Ccedil;&Atilde;O, QUANDO EXECUTADO NOUTROS SISTEMAS (LINUX)!
<P>
   Como j&aacute; disse num artigo anterior, no n&uacute;mero anterior da .pt zine no que
trata a cracking, &eacute; na minha opini&atilde;o, uma perda de tempo orientar esfor&ccedil;os,
em termos de programa&ccedil;&atilde;o, para a constru&ccedil;&atilde;o de um cracker! A n&atilde;o ser que se
trabalhe directamente em assembly, dificilmente se obter&aacute;, com as ferramentas
mais usuais, uma melhoria significativa, em termos de velocidade.
<P>
   Como toda a gente sabe um cracker, apenas encripta possiveis passwords,
e compara o resultado final com a entrada da password encriptada,...se
coincidirem...Bingo!
<P>
   Podem ent&atilde;o ver que realmente &eacute; uma perda de tempo estar a tentar 
   desenvolver ferramentas, neste sentido, e ser&aacute; mais pr&aacute;ctico investir tempo
   e
esfor&ccedil;o, em aplica&ccedil;&otilde;es que produzam as tais possiveis e provaveis passwords!<BR>
   Logo daqui se pode criar uma m&aacute;xima: No que toca a password cracking em
linux, o que interessa &eacute; ter uma boa wordlist!!
<P>
   Existem j&aacute; muitas aplica&ccedil;&otilde;es, incluindo crackers, que criam as pr&oacute;prias
wordlists, baseados, por exemplo, nas entradas gecos.
<P>
   A dificuldade porem e arranjar uma aplica&ccedil;&atilde;o, que reuna uma quantidade
razoavel de crit&eacute;rios de origem e altera&ccedil;&atilde;o, de possiveis passwords!!!
<P>
   Foi ent&atilde;o que num flash, que me surgiu a ideia de criar uma aplica&ccedil;&atilde;o que a
partir de um ficheiro passwd, criasse uma wordlist, cujas strings fossem
"retiradas", da entrada username, e gecos e dessas entradas gerar um n&uacute;mero
razo&aacute;vel de varia&ccedil;&otilde;es dessas entradas!!!(Pois s&atilde;o a partir destas entradas,
que os utilizadores criam as suas passwords!! Apesar dos muitos apelos, dos
SysAdm, a teoria de usar por exemplo o username invertido, ou o nome proprio,
como passwords continua a ser o p&atilde;o nosso de cada dia, nos sistemas
informaticos multi-user!). Mas o grande objectivo desta aplica&ccedil;&atilde;o, &eacute;
tentar reunir
o m&aacute;ximo de crit&eacute;rios possiveis e imagin&aacute;rios, e ir adicionando ao c&oacute;digo uns
novos,...para que seja possivel testar o m&aacute;ximo n&uacute;mero possivel de variantes
de uma string.
<P>
   O que esta apli&ccedil;&atilde;o faz &eacute; o seguinte:
<DD>   - Divide a string correspondente &agrave; entrada gecos em varias strings. Ex:
<DD    Maior Lame Imaginario
<P>
<DD>    o resultado ser&aacute; uma matriz:
<DD>    Maior
<DD>    Lame
<DD>    Imaginario
<P>
    A estas novas strings adiciona a entrada username.
<P>
    - Depois estas strings ser&atilde;o sujeitas a um "tratamento", em que ser&atilde;o
    criadas novas strings...,tais como a inversao,a concatena&ccedil;&atilde;o, e alguns
    mais conhecidos,...e outros menos usados mas que tambem produzem resultados
	positivos, tais como o acrescento do ano corrente etc...
<P>
    Por exemplo, a entrada dum ficheiro passwd:
    Username:e4\3dkr.4aqCO:502:100:Maior Lame Imaginario:/home/lame:shell
<P>
    Criar&aacute; as seguintes passwords:
<P>
<PRE>
    Username
    USERNAME
    username
    emanresU
    UsernameUsername
    Username97
    Maior
    MAIOR
    maior
    Mai0r
    roiaM
    Maior97
    Lame
    LAME
    lame
    emaL
    Lame97
    Imaginario
    IMAGINARIO
    imaginario
    Imaginari0
    oiranigamI
    Imaginario97
</PRE>
19 passwords geradas a partir de 1 entradas.
<P>
    Ou seja, os crit&eacute;rios que para j&aacute; est&atilde;o definidos no programa s&atilde;o:
<DD>    - a pr&oacute;pria string em si
<DD>    - todos os caracteres em maiusculas
<DD>    - todos os caracteres em minusculas
<DD>    - substitui&ccedil;&atilde;o (caso existam) dos 'o' ou 'O' por 0 (zeros)
<DD>    - invers&atilde;o da string
<DD>    - adi&ccedil;&atilde;o do ano corrente a string
<DD>    - a concatena&ccedil;&atilde;o do username (UsernameUsername)
<DD>   - caso o 1º caracter seja maius. passar&aacute; a minus. e vice-versa
<P>
   Como se pode ver a partir das strings "Username", "Maior", "Lame",
   "Imaginario", foram criadas 19 novas strings, possiveis passwords!
<P>
   Strings com menos de tr&ecirc;s letras ser&atilde;o ignoradas, porem isto pode ser
alterado,....basta alterar o valor de PASS_MIN_LEN.
<P>
   No final, o programa dar&aacute; informa&ccedil;&otilde;es, no que toca ao n&uacute;mero de entradas,
passwords geradas, contas desactivadas e sem password.
<P>
AVISO: O C&Oacute;DIGO DESTE PROGRAMA PODER&Aacute; (AFINAL ESSE &Eacute; O OBJECTIVO) SER
ALTERADO, DESDE QUE A ALTERA&Ccedil;&Atilde;O SEJA PARA ACRESCENTAR MAIS CRIT&Eacute;RIOS, E
      NUNCA PARA O TORNAR MENOS COMPLETO...AGRADECIA QUE SEMPRE QUE
	  ALTERASSEM O C&Oacute;DIGO, OU TIVESSEM SUGEST&Otilde;ES ME ENVIASSEM UM MAIL PARA:

<A HREF="mailto:elektro@kaotik.complex-x.net">elektro@kaotik.complex-x.net</A>

<P>						   
   Junto vai o bin&aacute;rio deste utilitario para quem nao possui um compilador
   de C para ms-dos.
   <DD><A HREF="word.exe">word.exe</A>
<P>
----------------------------- CORTE POR AQUI --------------------------------
<PRE>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;signal.h&gt;
#include &lt;time.h&gt;

#define SIM 1
#define NAO 0
#define PASS_MIN_LEN 3

char matriz[15][20];

struct passwd{
	      char pw_name[10];
	      char pw_passwd[14];
	      int  pw_uid;
	      int  pw_gid;
	      char pw_gecos[40];
	      char pw_dir[40];
	      char pw_shell[20];
	      };

struct passwd *getpwent(char *fn);
char *minus_maiusc(char *passwd);
char *maiusc_minus(char *passwd);
char *o_0(char *passwd);
int testa_o_0(char *passwd);
int testa_minus_maius(char *passwd);
char *maius_minus_todo(char *passwd);
char *inverte(char *passwd);
char *concatena(char *passwd);
void sinal(void);

		         /*  COMECO DA FUNCAO MAIN   */

void main(int argc, char *argv[]){

int entradas=0,
    contas_desactivadas=0;

unsigned int passwds=0;

short int i,
	  numero,
	  login_sem_passwd=0;

struct passwd *p;
struct tm *tempo;

time_t *apontador;


     if( argc!=2 ){
		   printf("Uso: %s <ficheiro_passwd>\n", argv[0]);
		   exit(0);
		  }
     
     signal(SIGINT, sinal);

     time(apontador);
     tempo=gmtime(apontador);

     while((p=(struct passwd*) getpwent(argv[1]))!=NULL)
     {

	  if( p->pw_passwd[0]=='*'){
	       if(strcmp(p->pw_passwd, "*")==0)
			  continue;
				   else{
					contas_desactivadas++;
				        continue;
					}
				    }
	  if( strlen(p->pw_passwd)!=13)
		   if(strcmp(p->pw_passwd, "x")==0) ;
		     else{
		          login_sem_passwd++;
		          continue;
		         }

	  entradas++;

		 printf("%s\n", p->pw_name);
	  if(testa_minus_maius(p->pw_name)==NAO){
		 printf("%s\n", minus_maiusc(p->pw_name));
		 passwds++;
		}
		 printf("%s\n", maiusc_minus(p->pw_name));
	  if( (testa_o_0(p->pw_name))==SIM ){
		 printf("%s\n", o_0(p->pw_name));
		 passwds++;
	        }
	  if( testa_minus_maius(p->pw_name)==SIM){
		 printf("%s\n", maius_minus_todo(p->pw_name));
		 passwds++;
	        }
		 printf("%s\n", inverte(p->pw_name));
		 printf("%s\n", concatena(p->pw_name));
		 printf("%s%d\n", p->pw_name, tempo->tm_year);
		 passwds+=4;

	  if( strcmp(p->pw_name, p->pw_gecos)==0)
					    continue;

     numero=strdiv(p->pw_gecos);
     for(i=0; i<=numero; i++){
		    printf("%s\n", matriz[i]);
	  if(testa_minus_maius(matriz[i])==NAO){
		    printf("%s\n", minus_maiusc(matriz[i]));
		    passwds++;
		   }
		    printf("%s\n", maiusc_minus(matriz[i]));
	  if( (testa_o_0(matriz[i]))==SIM){
		    printf("%s\n", o_0(matriz[i]));
		    passwds++;
		   }
	  if( testa_minus_maius(matriz[i])==SIM){
		    printf("%s\n", maius_minus_todo(matriz[i]));
		    passwds++;
		   }
		    printf("%s\n", inverte(matriz[i]));
		    printf("%s%d\n", matriz[i], tempo->tm_year);
		    passwds+=3;
			      }
		 }

printf("\n%d passwords geradas a partir de %d entradas.\n", passwds,entradas);
printf("%d logins sem password atribuida.\n", login_sem_passwd);
printf("%d conta(s) desactivadas.\n", contas_desactivadas);

 }


		       /* FIM DA FUNCAO MAIN */


	    /* funcao que carrega as entradas do ficheiro */

struct passwd *getpwent(char *fn)
{
static FILE *f = NULL;
static struct passwd p;
char s[200];
int l;

	if(f == NULL)
		if((f = fopen(fn,"r")) == NULL){
			perror("Erro no ficheiro");
			return NULL;
		}

	for(;;){
		if(fgets(s,200,f)==NULL){
			fclose(f);
			f = NULL;
			return NULL;
		}

		l = strlen(s)-1;

		s[l] = '\0';

		if(l == 0)
			continue;

		p.pw_name[0]	= '\0';
		p.pw_passwd[0]	= '\0';
		p.pw_gecos[0]	= '\0';
		p.pw_dir[0]		= '\0';
		p.pw_shell[0]	= '\0';

		strncat(p.pw_name,strtok(s,":"),9);
		strncat(p.pw_passwd,strtok(NULL,":"),13);
		sscanf(strtok(NULL,":"),"%d",&p.pw_uid);
		sscanf(strtok(NULL,":"),"%d",&p.pw_gid);
		strncat(p.pw_gecos,strtok(NULL,":"),39);
		strncat(p.pw_dir,strtok(NULL,":"),39);
		strncat(p.pw_shell,strtok(NULL,":"),20);
		return &p;
	}
}
           /* Funcao que coloca as palavras de uma string na matriz */

int strdiv(char *vector){
int LINHAS,COLUNAS,COLUNAS2=0;

   for(LINHAS=0;;LINHAS++){
       for(COLUNAS=0;;COLUNAS++){
          if(vector[COLUNAS2]=='\0'){
                         matriz[LINHAS][COLUNAS]='\0';
			 return(LINHAS);
                               }
          if(vector[COLUNAS2]==32 && vector[COLUNAS2+1]!=32)
            {
             COLUNAS2++;
             break;
             }

          matriz[LINHAS][COLUNAS]=vector[COLUNAS2];
          COLUNAS2++;
            }
		 matriz[LINHAS][COLUNAS]='\0';
		 if( strlen(matriz[LINHAS])<PASS_MIN_LEN )
       		 LINHAS--;
         }
     }


char *minus_maiusc(char *passwd){
static char temp[20];
int i;

strcpy( temp, passwd);

	for(i=0;;i++){
		if( temp[i]=='\0')
		    return temp;
		if( temp[i] >=97 && temp[i] <=122 )
				     temp[i]=temp[i]-32;
		}
	}

char *maiusc_minus(char *passwd){
static char temp2[20];
int i;

strcpy( temp2, passwd);

      if( temp2[0]>=65 && temp2[0]<=90)
	  temp2[0]=temp2[0]+32;
			 else
			   if( temp2[0]>=97 && temp2[0] <=122)
			     temp2[0]=temp2[0]-32;
                       return temp2;
	       		}

char *o_0(char *passwd){
static char temp3[20];
int i;

strcpy( temp3, passwd);

	for(i=0;;i++){
		if( temp3[i]=='\0' )
			   return temp3;
		if(temp3[i]=='o' || temp3[i]=='O')
			   temp3[i]='0';
				  }
		}

int testa_o_0(char *passwd){
int i;

      for(i=0;;i++){
	      if(passwd[i]=='\0')
			      break;
	      if(passwd[i]=='o' || passwd[i]=='O')
			      return(SIM);
		    }
			      return(NAO);
	       }

int testa_minus_maius(char *passwd){
int i;

  for(i=0;;i++){
	    if( passwd[i]=='\0')
			    break;
	    if( passwd[i]>90 )
			    return(NAO);
		}
		            return(SIM);
	     }

char *maius_minus_todo(char *passwd){
static char temp4[20];
int i;

strcpy( temp4, passwd);

     for(i=0;;i++){
	   if(temp4[i]=='\0')
			 return temp4;
	   if(temp4[i]>=65 && temp4[i]<=90)
			 temp4[i]=temp4[i]+32;
		 }
	 }

               /*  Funcao que inverte uma string  */

char *inverte(char *passwd){
static char temp5[20];
int i,tamanho;
char temp;

strcpy( temp5, passwd);
tamanho=strlen(temp5);

	  for(i=0; i<(tamanho/2); i++){
											 temp=temp5[i];
											 temp5[i]=temp5[(tamanho-1)-i];
											 temp5[(tamanho-1)-i]=temp;
											 }
	  return temp5;
	  }

                /*  Funcao que concatena duas strings  */

char *concatena(char *passwd){
static char temp6[20];
int tamanho;

strcpy( temp6, passwd);
strcat( temp6, passwd);
return temp6;
}

                /*  Funcao que lida com o sinal Ctrl-C  */

void sinal(void){
char opcao;

  printf("\n(s)air? ENTER para continuar: ");
  opcao=getchar();

  switch(opcao){
		  case 's': exit(0);
		  default : return;
				}
}

</PRE>
</FONT>
<P>
&nbsp;
<P>
<A HREF="http://www.complex-x.net/kaotik/"><IMG SRC="kaotikm1.gif" WIDTH=147 HEIGHT=50 BORDER=1></A>





</BODY>
</HTML>


