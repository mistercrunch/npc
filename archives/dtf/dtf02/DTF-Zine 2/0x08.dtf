=-( - Introduccion al Cracking - )-==-( - Simpson - )-==-(- DTF-Zine #2 -)-=

                           INTRODUCCIÓN AL CRACKING
                          por  Simpsom para DTF-Zine
                          http://www.dtfzine.cjb.net

 Índice de contenidos:

	1.- Lección 1 -- Introducción

		1.0 - Presentación
		1.1 - ¿Qué es crackear?
		1.2 - Un poquito de historia
		1.3 - Requisitos para empezar a ser un cracker
		1.4 - Algo de ensamblador
		1.5 - Ejercicios y conclusión
		1.6 - Links


                0000000000000000000000000000000000000000000000


 1.0 -  PRESENTACIÓN:

  Antes  de nada, me presento. Me  llamo Simpsom (xD) y es el primer tutorial
 que escribo, así que ruego me  disculpéis por  las más que  posibles erratas
 que  pueda cometer. No soy  ningún experto en  la materia, pero he hecho mis
 "pinitos" y todavía sigo aprendiendo y mi único deseo es que podamos hacerlo
 juntos y  transmitiros lo  poco que  se  para que  luego  podáis  seguir por
 vuestra  cuenta,  vamos, crear  una base. Para  no andar con  muchos rodeos,
 vamos a contar  un poco de qué va todo esto. Ah!, antes de que se me olvide.
 Estoy preparando una versión  en Flash para  poder disfrutar  del tutorial a
 través de  Internet con capturas de  imágenes para  apoyar el "tute", aunque
 podréis seguir bajando las lecciones en formato txt.


 1.1 -  ¿QUÉ ES CRACKEAR?:

  Los programas no son más que secuencias de "simples y tontas" instrucciones
 que  ejecuta  el microprocesador  para obtener  ciertos  resultados.  Dichas
 secuencias no  aparecen de la nada, sino que están almacenadas en la memoria
 previa carga desde  el disco duro. Pues  bien, nuestra labor es cambiar esas
 secuencias  para  que hagan "casi"  lo que nosotros  queramos. Debido  a que
 suelen  ser  bastante  largos (millones  de instrucciones)  no  resulta "mu"
 efectivo ir una a una para comprender  en conjunto  lo que  se hace, xD. Por
 ello, tenemos  ciertas  herramientas que  nos hacen  la vida un  poco mejor,
 aparte de  ciertas metodologías  de "ataque", pero eso es cosa de la próxima
 lección, impacientes, que la casa se empieza por abajo.
  Volviendo a  lo anterior, normalmente sólo  hace falta  cambiar una pequeña
 porción de los programas y se  suele  publicar ésta en  Internet en forma de
 los  "famosos" cracks para  hacernos la vida más  fácil a los pobres, aunque
 esto es a gusto  de cada uno, ya  que podemos optar  por todo lo contrario y
 mirarnos al  espejo y  decirnos: "joer, capullo, pero  que bueno eres, xDDD"
 (uno que no tiene abuela).
  La  pregunta es...¿todo  esto es tan  fácil?..,  mmm,  pues NO, xD,  broma,
 broma. En realidad todo, como  siempre,  depende, y me  explico. Normalmente
 los programadores no se suelen  complicar mucho  la vida a  la hora de hacer
 sus  programas y las  versiones  "trial" o sus demos y  utilizan sistemas de
 protección ridículos. Os  sorprenderéis de lo  fácil que es crackear algunos
 de compañías bastante  importantes y con  mucho nombre, pero no todo es así.
 Por otra parte nos  encontramos con  casos en que  se utilizan  sistemas  de
 protección combinados y  tendremos que darle  al coco mucho  tiempo. Estamos
 hablando de horas (o incluso días), pero esto es lo bonito.
  Hay  mucho "falso" cracker que  se  las  da  de  inteligente  por  utilizar
 parches,  aplicaciones, etc  desarrolladas  por otros, pero eso no vale para
 nada. El buen  cracker sigue  el lema "háztelo tu mismo". Pasa algo parecido
 con los hackers,  donde nos encontramos  con dos tipos,  y para resumir: los
 que utilizan los exploits de los demás y los que los crean.
  Pero crackear  es mucho más  que todo esto. Los crackers descubren agujeros
 de seguridad  en el código de  programas, en  sistemas operativos,  son, por
 decirlo  de  alguna  manera, los  que  "desmontan" todo  para  ver si sobran
 piezas.  Ufff,  creo que me  estoy pasando  un poquillo,  así que vámos a la
 siguiente sección.

 1.2 -  UN POQUITO DE HISTORIA:

  No hace  mucho tiempo, unos  cinco o  seis años, los  juegos y aplicaciones
 eran  de "risa"  comparados con  los de hoy  en día. De aquella  crackear un
 juego era, en  cierto sentido, más  fácil que  ahora (aunque  se disponía de
 muchas menos herramientas) por los sistemas de protección que  se empleaban.
 Sólo  hace  falta  fijarse  en  ejemplos  como  los  del  "Monkey  Island" y
 similares.  Proliferaban  con mucho  éxito  cierto tipo de  aplicaciones que
 recopilaban  gran cantidad  de "cracks"  para aplicar  a un  gran volumen de
 juegos. Mayoritariamente eran el  Nevlock, Rawcopy, etc. (que  yo recuerde).
 ¿Quién no los ha utilizado nunca?
  Pero las cosas han  cambiado  bastante. Se utilizan  sistemas de protección
 que  emplean  Internet  para  la  obtención  de licencias,  usuarios  únicos
 obtenidos  con CD-KEYs verificados  a través de Internet en la base de datos
 de  la  empresa  desarrolladora  (al  estilo  del  WON para  el  Half Life),
 Microsoft y  su sistema  de  activación  del  XP  (roto  con  las  versiones
 corporativas, pero  ya hablaremos  de esto, xD) y  muchas  otras  variantes.
 Pero, incluso así, nada es imposible para un cracker dispuesto a saltarse la
 barrera.  Solo  hay que  utilizar  la  imaginación, la  lógica y  pensar con
 claridad para encontrar la cerradura  porque, una vez  ante la puerta, si no
 se  abre, se  echa abajo. Si  no  entendéis  muy  bien  esto  ahora,  no  os
 preocupéis  que más  adelante  lo haréis.  En otras  ocasiones (para nuestra
 suerte, la  mayoría) la  cosa es muchísimo más fácil gracias a la "vagancia"
 de muchos  programadores y  en 5 o 10 minutos  habremos  conseguido  nuestro
 objetivo.

 1.3 -  REQUISITOS PARA EMPEZAR A SER UN CRACKER:

  Estaba  pensando  ahora que  este apartado  sobraba, porque  creo que  está
 bastante claro, pero, aun así, deciros  que lo primero que hay  que tener es
 PACIENCIA y  tiempo. Las  cosas no se  aprenden de  un día para otro  y todo
 tiene que ser gradual. No podemos esperar que salga a la séptima (xD,  si os
 sale a la primera, id al kiosco a hacer  la quiniela  o decidle al  director
 que os  ascienda  de curso que  en clase os  aburrís), pero si utilizamos la
 "cabecita" y con algo de práctica todo nos resultará bastante "sencillo". 
  Además  de  lo  anterior,  también  sería  bueno  que  supieseis   algo  de
 programación (si es en C, mejor, pero  tampoco es  imprescindible)  para que
 todo resulte más fácil,  aunque por Internet  me he encontrado  con casos de
 "crackers" que no saben programar y se defienden mejor  que  bien (y que yo,
 xD). En serio, es un consejo muy  bueno, así que ya  sabéis, a bajarse algún
 tutorial sobre C de Internet. En los links  tenéis algunas  direcciones. Por
 cierto, si sabéis programar en ensamblador, mejor que mejor, pero tampoco es
 imprescindible.
  Por supuesto,  ganas y que  os guste,  porque en otro caso, "chungo chungo,
 xD".
  Por último,  como todo carpintero tiene su martillo, nosotros necesitaremos
 nuestras propias  herramientas, que  no son pocas.  Unas las  usaremos más y
 otras menos, pero todas nos serán útiles. Por ejemplo, el SoftIce, que es un
 depurador (debugger) de código  en tiempo  real, es decir,  podemos  ver qué
 instrucciones se están ejecutando  en cada momento en el  ordenador y actuar
 sobre ellas (aunque existen otros de este estilo, éste es el más utilizado).
 También un  editor hexadecimal (WinHex  por ej), para guardar lo que hayamos
 echo y cambiar el programa original para  que funcione de la forma en la que
 lo  hemos  modificado   con  nuestro   depurador  y,  por   supuesto,  algún
 desensamblador (W32Dasm, por ejemplo) para ver  todo el código  del programa
 (si no está protegido, claro :). Existen  muchas  otras que nos pueden hacer
 la vida más fácil,  pero no quiero  profundizar mucho en todo esto porque lo
 haré en la próxima lección. Si  os queréis  arriesgar (que  es  lo bueno)  y
 probar  estos  programas,  mirad  en  los Links. De  todas formas, si tenéis
 problemas, (sobre todo  con el SoftIce) en la próxima lección explicaré como
 instalar algunos de ellos.
  ¿Cansado? ¿Me enrrollo  mucho? Ya  tamos terminando  con lo aburrido, ahora
 empieza lo bueno.

 1.4 -  ALGO DE ENSAMBLADOR:

  Hasta ahora os he  hablado  mucho sobre  secuencias de  instrucciones, etc,
 pero, ¿qué son?  Pues  bien, el microprocesador "sólo" entiende un puñado de
 instrucciones del tipo sumar  algo a una  variable, (aquí  sería  bueno  que
 supieseis algo de programación), restárselos, dividir dos variables, cambiar
 una variable por otra, comparar datos y obrar en consecuencia, etc.

		Por ejemplo:
			.
			cmp ax, variable
			jnz mensajedeserialincorrecto
                        .
 			.
			.

  En  el  ejemplo  anterior, tenemos  una parte  de un código  imaginario que
 compararía (cmp) el valor del  registro de  memoria ax (como  una variable),
 que puede ser el número de serie  introducido por nosotros siendo "variable"
 el correcto del  programa. Así, la  siguiente  instrucción nos viene a decir
 algo así como que  si no son iguales salte a la función que muestra un error
 de "número de serie" incorrecto  en la  pantalla.  Podemos  pensar  que  con
 cambiar el "jnz" por  el "jz" es suficiente, pero no siempre es así. Yo creo
 que, si nos es posible, lo mejor  es buscar "hacia  atrás" e  investigar  un
 poco del código anterior, para ver el contenido  de "variable" (el número de
 serie  correcto)  o, en  caso de  que  sea  un  flag (1 ó 0)  activado si es
 correcto o no, buscar dónde se realiza esa activación.
  Me estoy adelantando (esto es parte de los métodos de ataque), así que sigo
 con ensamblador. La  información que  vamos a  manipular se almacenará en la
 memoria y los registros (eax, edi, ax, etc) que no son más que posiciones en
 la memoria especiales sobre las que podemos actuar con las instrucciones del
 micro. Además, tenemos la pila, que es algo así (y a grandes rasgos) como un
 conjunto de registros apilados unos encima de otros y a los que sólo podemos
 acceder por arriba para escribir y leer de forma que, cuando  escribimos, se
 añade  uno  más por  arriba y,  cuando  leemos, se  quita  otro por la misma
 posición.  Es  algo  así como  una pila de platos, en la que  sólo ponemos y
 quitamos por arriba. Esto se utiliza  mucho para  guardar  el estado  de los
 registros en las  llamadas a las  funciones de  forma que podamos  guardar y
 recuperar el  estado de los registros para que puedan ser utilizados por las
 funciones. Esto se hace  con un par de  instrucciones, que  son "push" (para
 escribir) y "pop" (para quitar).

		Otro ejemplo:
                                mov edi,eax     ; Mueve   el  contenido   del
                                                ; registro eax a edi.
			bucle 	.
                                .               ; Secuencia de instrucciones.
				.
				cmp edi, ax
                                jz bucle        ; Si son  iguales,  salta  al
                                                ; bucle.
                                push edi        ; Almacena edi  en  la  pila.
                                call imprime    ; Llamada   al  procedimiento
                                                ; (subrutina)
imprime:
                                pop edi         ; Recupera  el  valor  de edi
                                                ; antes de  llamar a imprime.



  Después de todo esto, y si os  interesa el  tema, opino que  deberíais leer
 algún tutorial sobre  ensamblador  para aprender un poquito más y coger algo
 de soltura. Encontraréis,  como siempre,  direcciones  útiles en  los  links
 sobre tutoriales y compiladores para probar vuestras creaciones.      
				

 1.5 -  EJERCICIOS Y CONCLUSIÓN:

  Para realizar los ejercicios es "casi"  imprescindible  que os leáis  algún
 tutorial pequeño sobre ensamblador (el  de los links es más que suficiente).
 De  todas  formas,  esto sólo  es para  practicar  un poco  y son  todos muy
 fáciles.
  Las  soluciones  vendrán en la  Lección 2. Estad  atentos a la  página para
 saber la fecha de aparición.

        Ejercicio 1.- Desarrollar  una subrutina que reciba dos números en la
                      pila y que devuelva la suma de ellos en la posición más
                      alta (cima) de la pila.

			Ejemplo:
				 push ax
				 push edi
				 call Ejercicio1
				 pop edi

                      En edi debe aparecer el  resultado de sumar ax y el edi
                      anterior.

        Ejercicio 2.- Desarrollar una subrutina  que reciba dos números en la
                      pila y  devuelva  un 1 en la  cima  de  la pila  si  el
                      primero introducido es  múltiplo  del  segundo. En caso
                      contrario, devolver un cero.

			Ejemplo:
				 push ax
				 push edi
				 call Ejercicio2
				 pop edi

                      En edi debe aparecer un 1 si ax es múltiplo de edi y un
                      0 en el caso contrario. 

  Sinceramente, creo que  con esto  es  suficiente porque  no  hace falta que
 seáis expertos  en  ensamblador.  Y ya está, esto es  todo en esta  lección.
 Espero que no  os haya resultado  complicada o  aburrida y, si queréis hacer
 algún comentario,  tenéis mi  dirección en el DTF-Zine. Gracias  por vuestra
 atención y nos vemos en la próxima lección si queréis. Estad atentos al Zine
 para la fecha. Byes!!!


 1.6 -  LINKS:

	Tutorial programación en C:

		http://www.ciudadfutura.com/cworld/cursodec.htm

	Tutoriales programación en ensamblador:

		http://www.cgrsoftware.com/manuales_dir.htm?asm_1

	Compilador de C y ensamblador (gratuito):

		http://www.bloodshed.net/devcpp.html

	Herramientas para crackear:

  Para  que  nadie se  ofenda, he optado  por no  poner  links  aquí.  Podrás
 encontrar  cientos  y  cientos  poniendo  SoftIce,  W32Dasm  y/o  WinHex  en
 cualquier buscador. De todas formas, subiré los programas  a mi página  para
 que no perdáis el tiempo con links rotos.
