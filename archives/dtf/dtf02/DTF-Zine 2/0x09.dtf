
        -------------------------------------------------------------
         / Sistemas Virales Cooperativos: una aproximación técnica \
         \                (c) 2001  Tokugawa Ieyasu                /
        -------------------------------------------------------------


                              [ - AVISO LEGAL - ]

 ESTE ARTÍCULO ES UN ENSAYO TEÓRICO CON FINES EDUCATIVOS ÚNICAMENTE, EL AUTOR
 NO  SE RESPONSABILIZA  DE LOS  DAÑOS QUE  ESTA  INFORMACIÓN  PUEDA LLEGAR  A
 CAUSAR. DE TODAS FORMAS SE NECESITAN CONOCIMIENTOS PREVIOS (QUE NO SE PUEDEN
 ADQUIRIR  CON ESTE ENSAYO) PARA  HACER  MAL  USO DE  LA INFORMACIÓN, ASÍ QUE
 NINGÚN MIEMBRO DE DTF PODRÁ SER ACUSADO DE NINGÚN DELITO DERIVADO DE ESE MAL
 USO.


  [ .Prólogo ]

  Cuando trabajaba  con Win32/Seppuku, una idea  comenzó a tomar forma  en mi
 mente, si  un  virus puede  cambiar  su comportamiento, o  actualizarse  por
 Internet, ¿por qué no colaborar con otros virus? Trabajando sobre  esta idea
 conseguí crear las bases de un modelo teórico al que acabé llamando "Sistema
 Viral Cooperativo". En  este  artículo  intentaré sintetizar las  ideas  que
 considero más importantes a la hora de implementar dichos sistemas.


  [ .Índice ]

  1.- ¿Qué es un Sistema Viral Cooperativo?
  2.- Conceptos básicos sobre SVCs
      2.1.- ¿Debe un virus ayudar o colaborar con otro?
      2.2.- ¿Cómo puede un virus ayudar o colaborar con otro?
  3.- Banderas y registros: cimientos de la colaboración
  4.- Línea de comandos: comportamiento a la carta
      4.1.- Utilización de la línea de comandos y ejemplos prácticos
            4.1.1.- Establecer la línea de comandos
            4.1.2.- Obtener la línea de comandos
            4.1.3.- Acerca de la línea de comandos y código relacionado


  [ 1.- ¿Qué es un Sistema Viral Cooperativo? ]

  Un  Sistema Viral Cooperativo (SVC  a partir  de ahora) es un  conjunto  de
 virus, llamados  miembros del SVC, que  pueden trabajar juntos  para mejorar
 las  características de  cada  uno  de ellos. Existen  muchas  combinaciones
 posibles entre  dichos miembros, y su número está únicamente limitado por la
 complejidad del sistema.
  Debido al hecho  de que un SVC  con más de  dos  miembros  sería  demasiado
 complejo  para un artículo  como este,  me centraré aquí en SVCs de tan solo
 dos miembros. A pesar de esto, en el  artículo se podrán  encontrar consejos
 sobre sistemas de más miembros.


  [ 2.- Conceptos básicos sobre SVCs ]

  Uno de los conceptos  principales que  debemos tener claro acerca de un SVC
 es  que sus  miembros  no son virus  normales. No conozco  ningún virus  que
 compruebe  ciertos registros antes de empezar a trabajar, ni que se comporte
 de una manera o de otra dependiendo del valor de esos registros, al menos no
 como lo haría un miembro  de un SVC. Si no  tenemos en cuenta este hecho, el
 resto   del  virus   es  como  cualquier  otro,   con  sus   características
 particulares, que se podrían encontrar fuera de los SVCs.
  Pero  la  primera  pregunta  que  surge  es, ¿para  qué  necesita  un virus
 comprobar los registros antes de  empezar a trabajar? Simple, es posible que
 el host  en el que se  encuentra  esté  infectado por  más de un miembro del
 mismo SVC, y  es aquí  donde comienza  la principal  característica de estos
 sistemas, la colaboración entre  virus. Esta  pregunta y su respuesta pueden
 llevar a  otras, pero todas  ellas las  intentaré resolver  en este  pequeño
 artículo.

  [ 2.1.- ¿Debe un virus ayudar o colaborar con otro? ]

  Esta es quizá la pregunta más difícil del artículo. En mi opinión, un virus
 únicamente   debería  ayudar   o   colaborar   con   otro  en   determinadas
 circunstancias, y con ciertas limitaciones. No se trata de que en una docena
 de ejecuciones se puedan detectar  todas las variantes de cada  miembro, las
 casas   antivirus   acabarán  detectándolas  todas,   pero  no   habría  que
 facilitarles demasiado  el trabajo. Si el lector  ha implementado alguna vez
 técnicas de  polimorfismo lento  (Slow Polymorphism) sabe  ya lo  que  puede
 utilizar  para  decidir  si  actuar o no,  de  lo contrario  se  muestran  a
 continuación  varias circunstancias  que  pueden  ser  utilizadas  para  tal
 propósito:

        - X  meses tras  la  primera  infección  (del  host o  del  sistema).
        - Tras   un  número  aleatorio  (aunque  relativamente  elevado)   de
          infecciones.
        - Únicamente   cuando   el   virus   llegue  a   un  nuevo   sistema.
        - Etc, etc...

  [ 2.2.- ¿Cómo puede un virus ayudar o colaborar con otro? ]

  La respuesta  a esta pregunta  es,  sencillamente, que  un virus  no  puede
 ayudar  a otro de  ninguna manera, al  menos si el  virus al que se pretende
 ayudar no espera  ninguna ayuda. Sin  embargo, en la especial  circunstancia
 de que un archivo se encuentre  infectado por dos virus  distintos, entonces
 puede existir una colaboración o ayuda mutua entre dichos virus. El orden de
 infección del archivo  toma especial  relevancia cuando hablamos de SVCs, el
 primer virus en  infectar el archivo se convierte automáticamente, cuando el
 archivo es  nuevamente infectado por otro miembro del mismo SVC, en el virus
 al que se ayuda (o con  el que se colabora), y este segundo virus pasa a ser
 el virus  ayudante (o el que colabora con). No debería preocuparnos el orden
 de  infección, todos  los miembros de un  mismo SVC estarán preparados  para
 afrontar cualquier posible variación del esquema principal.

         NOTA: un miembro  de un  SVC es  siempre el  ayudante del  siguiente
               virus y ayudado por el virus precedente. Este es el  hecho que
               convierte a los  SVCs de más  de dos miembros  en sistemas tan
               complejos.

  El primer virus que se ejecuta, cuando intenta devolver el control al host,
 pondrá en determinados registros  del procesador unos  determinados valores,
 de  manera  que si  algún  otro  miembro  del  SVC se  ejecuta  ahora, podrá
 comprobar los valores que hay en  esos registros, y actuar  en consecuencia.


  [ 3.- Banderas y registros: cimientos de la colaboración ]

  Un hecho de todos  conocido es que no se pueden pasar argumentos a un virus
 por medio de variables, al menos desde otro virus (para hacer esto, el virus
 tendría que tener  un comportamiento  similar al de  una DLL). Lo único  que
 podemos utilizar para pasar estos  parámetros es la  línea de comandos o los
 registros. En  el artículo  trataré estos  dos métodos en  profundidad, pero
 debo añadir que son utilizados para  propósitos diferentes (y en situaciones
 diferentes).
  Como  seguramente sabrá  el lector, Win32/Girigat (escrito por Mr. Sandman)
 cambia su  comportamiento cada vez  que infecta un  nuevo ordenador. Esto lo
 consigue  mediante  la  utilización  de  una  serie  de  banderas  que tiene
 almacenadas  con los datos. Asumiendo que una bandera únicamente puede tomar
 dos valores (0/1) una  de las técnicas para pasarle parámetros a un virus es
 a través de los  registros. Actualmente  se pueden pasar hasta 32 parámetros
 en  un solo registro, pero  pronto los procesadores  de 64 bits serán de uso
 habitual,  y  los  parámetros  que se puedan  pasar en un  registro serán el
 doble.
  Usando únicamente unos pocos registros estamos en condiciones de sentar las
 bases  para un  algoritmo de gestión de  parámetros. Pero antes  de escribir
 código, pasaré a explicar algunos aspectos acerca de estos algoritmos.
  Algo que habría que tener en cuenta acerca del paso de parámetros a  través
 de los registros es que vamos a necesitar alguna manera de verificar que los
 valores de esos registros  provienen de nuestro  virus, y no  de otro sitio.
 Para realizar esa verificación vamos a necesitar algún  tipo de mecanismo de
 autentificación, que por supuesto será algo sencillo. Un algoritmo que puede
 ser  utilizado  es  el  CRC32,  un   algoritmo  de  fácil  implementación  y
 perfectamente válido para nuestro propósito. La principal  característica de
 este algoritmo (y por  lo tanto de la que vamos  a sacar provecho) es que es
 difícil  encontrar una  cadena  o  fragmento de  código  que tenga  un CRC32
 predefinido, y  también muy  difícil que un valor  escogido al azar coincida
 con un CRC32 previamente calculado. Por lo tanto en uno de los registros (el
 registro "autentificador") almacenaremos un CRC32, pero ¿de dónde va a salir
 ese  CRC32? Fácil,  lo  calcularemos a partir  del nombre  de alguno de  los
 miembros  del SVC. Aunque  este  mecanismo  es  perfectamente  válido y  muy
 sencillo, también podemos añadir  que es un mecanismo  débil, no ofrece  una
 garantía total de que el CRC32  fuese almacenado por  el virus ayudante.  Un
 añadido que podríamos hacer  sería encriptar ese CRC32 utilizando como clave
 algún valor  tomado de otros  miembros del SVC (o de donde al programador le
 parezca más conveniente). Un  ejemplo de  esto (que no es menos débil que el
 paso del CRC32 sin más, pero  que aclara  la idea) es encriptar el CRC32 del
 nombre del virus ayudante con el CRC32 del nombre del virus ayudado. Una vez
 se ejecuta  el virus ayudado  desencripta el  valor de  determinado registro
 utilizando  como clave el CRC32 de su propio  nombre, y si lo que obtiene es
 el CRC32 del  nombre del virus ayudante, entonces los parámetros almacenados
 en los registros son correctos. Espero haberme explicado con claridad.

         NOTA: este sistema es sencillo de implementar en un SVC con tan solo
               dos  miembros, si el SVC  tuviese  más miembros  el  algoritmo
               necesario  sería  más  complejo  (por  tener  mayor  número de
               posibilidades que deberían ser comprobadas).

  El siguiente fragmento de código es una versión modificada del utilizado en
 mi virus Win32/Seppuku v1.0 para devolver el control al host, es muy simple,
 pero demuestra de una forma práctica lo  que quiero decir. Se necesitaría un
 código mucho más elaborado para escribir un SVC.

                                                   ;
        mov     eax, [ebp + offset Host_ImageBase] ;
        add     eax, [ebp + offset Host_OldIP]     ; EAX     apunta     (como
                                                   ; explicaré  más tarde) al
                                                   ; código del segundo virus
                                                   ; localizado  en  el mismo
                                                   ; host.
                                                   ;
        mov     ebx, 05B42AA40h                    ; CRC32   del  nombre  del
                                                   ; virus ayudado.
        xor     ebx, 0E142C6E5h                    ; Ahora  EBX  contiene  el
                                                   ; CRC32   encriptado   del
                                                   ; nombre del virus ayudado
                                                   ; (0BA006CA5h).
                                                   ;
        xor     ecx, ecx                           ;
        mov     ecx, _EXE or _SCR or Direct_Action ; Banderas  almacenadas en
                                                   ; ECX
                                                   ;
        jmp     eax                                ; Salto al segundo virus.
                                                   ;

  El  esquema de  un SVC  (con sólo  dos miembros)  usando este código podría
 ser el siguiente:

               ------------------------------------  El  Virus 01  ha sido el
                | Archivo PE ejecutable original |   último  en  infectar  el
               ------------------------------------  archivo  ejecutable, así
                |            Virus 01            |   que es  el primer  virus
               ------------------------------------  que se ejecuta. El punto
                |            Virus 02            |   de  entrada del  archivo
               ------------------------------------  apunta a este virus, que
               tiene almacenado  otro punto  de entrada (como el  Virus 02 ha
               sido el primero en infectar el  archivo este punto  de entrada
               apuntará en  realidad hacia el  Virus 02). Cuando  el Virus 01
               intente pasar el control  al host, estará dando el  control al
               Virus 02.

         NOTA: por supuesto estoy hablando de virus que no usen técnicas EPO.
               Los  virus que usan EPO son mucho más difíciles de integrar en
               un SVC.

  Sin embargo  el código que muestro  tiene un defecto, va  a ejecutarse cada
 vez que un virus le pase el control al siguiente, y por lo  tanto siempre le
 va  a pasar  las mismas  banderas a este  siguiente  virus, y  esto  no  nos
 interesa.  En realidad  vamos a necesitar un algoritmo que compruebe ciertas
 condiciones, y que se comporte  según sean las  condiciones. Únicamente  con
 un algoritmo así  podremos cambiar y/o colaborar con los demás miembros  del
 SVC de una manera óptima y correcta.

      CONSEJO: como los virus tienen generalmente que obtener la dirección de
               unas determinadas APIs,  debería almacenar  en algún sitio (la
               pila, por  ejemplo) los  valores de  los  registros, y una vez
               obtenidas  las APIs  podría trabajar  sobre esos valores. Otra
               cosa que  se podría hacer sería  comprobar directamente si los
               valores provienen  del virus correcto, y  de ser así almacenar
               únicamente las banderas.


  [ 4.- Línea de comandos: comportamiento a la carta ]

  La idea que subyace tras la utilización de la línea de comandos en un virus
 es usar  a éste como si  se tratase de  una utilidad como podría ser gzip en
 Linux, es  decir, pasando una serie de  comandos al virus, que  actúe de una
 determinada manera. Las posibilidades son infinitas, el único límite lo pone
 la imaginación del programador. Aquí daré algunas ideas sobre la utilización
 de  esta técnica, pero  la última palabra siempre la tendrá el autor de cada
 SVC.
  Imaginemos la  siguiente situación,  tenemos un  SVC compuesto por un virus
 Direct Action  y otro  residente. El  virus  residente  ha  detectado que el
 usuario está copiando un  archivo ejecutable, por  ejemplo, en  un diskette.
 Tras haber detectado este  intento de copia  ha infectado el  archivo. Hasta
 aquí todo normal, pero ahora el  virus residente también  intentará infectar
 a ese  mismo  archivo con el  virus Direct Action, ¿qué  puede hacer? Podría
 intentar  copiar el virus en  el archivo, realizando  una infección  normal,
 pero esto sería en extremo complejo y, por  lo tanto, no se intentaría. Otra
 opción que tenemos es la  de utilizar la línea de comandos. Para esto habría
 que tener  localizado un archivo  infectado (con una seguridad del 100%) con
 el  virus  Direct Action, y  una  vez localizado  dicho archivo  habría  que
 ejecutarlo  pasándole cierta  información. Esta  información  puede ser  muy
 variada, pero tiene que contener obligatoriamente los siguientes datos:

        - La orden de no ejecución  del host: así  evitaremos que el programa
          infectado ejecute  su código  original, lo  que provocaría  ciertas
          sospechas en el usuario.
        - La ruta  completa más el  nombre del archivo que queremos infectar.
        - La  acción  que  queremos  que  el  virus  lleve  a cabo: si  hemos
          preparado al  virus para  realizar más de  una acción mediante este
          método tendremos que especificar qué acción debe realizar.

  Desde  luego que  con este  método tendremos  que tener especial cuidado en
 verificar  la proveniencia  de la línea de  comandos, puesto que esta podría
 ir   dirigida  al  host  y  no  al  virus.  Para  esta   autentificación  es
 perfectamente válido el planteamiento que se  dio para los registros, aunque
 adaptado al caso que nos ocupa.
  La idea  básica de la  línea de comandos  ha quedado  expuesta, ahora es el
 turno del lector para utilizarla apropiadamente.

  [ 4.1.- Utilización de la línea de comandos y ejemplos prácticos ]

  En este  apartado intentaré explicar  de una manera sencilla y resumida los
 conceptos  básicos  necesarios para  empezar a trabajar  con  las líneas  de
 comandos desde un programa escrito en ensamblador.

  [ 4.1.1.- Establecer la línea de comandos ]

  Establecer la línea de comandos es relativamente sencillo, si tenemos dicha
 línea almacenada  en una variable, lo único que habrá que hacer será pasarle
 el  offset de dicha  variable a la  correspondiente API, y ella se encargará
 del resto. Sin embargo, en nuestro caso, esto nunca será  posible, cualquier
 línea de  comandos que queramos pasarle a un  virus tendrá que ser creada en
 tiempo de ejecución debido al hecho de que  ciertos comandos serán obtenidos
 también  durante la ejecución  del virus. El  siguiente código  muestra cómo
 se  puede obtener  una línea de  comandos completa  partiendo de  sus partes
 constituyentes, es decir, cómo concatenar varias cadenas de texto:

                                                   ;
                lea     esi, Origen 1              ; Cargamos la dirección de
                                                   ; la  cadena  origen  y la
                lea     edi, Destino               ; dirección destino.
                                                   ;
        loop01: mov     al, [esi]                  ; Vamos copiando el origen
                cmp     al, 00h                    ; en   el  destino   hasta
                je      end_loop01                 ; que encontramos  el cero
                mov     [edi], al                  ; final de cadena.
                inc     esi                        ; Actualizamos         los
                inc     edi                        ; punteros   a   origen  y
                                                   ; destino.
                jmp     loop01                     ; Repetimos.
        end_loop01:                                ;
                                                   ;
                mov     byte ptr [edi], 20h        ; Incluimos   un   espacio
                inc     edi                        ; después  del  comando  y
                                                   ; actualizamos          el
                                                   ; puntero.
                lea     esi, Origen 2              ; Cargamos la dirección de
                                                   ; la    siguiente   cadena
                                                   ; origen.
                                                   ;
        loop02: mov     al, [esi]                  ;
                cmp     al, 00h                    ;
                je      end_loop02                 ;
                mov     [edi], al                  ;
                inc     esi                        ;
                inc     edi                        ;
                jmp     loop02                     ;
        end_loop02:                                ;
                                                   ;
        mov     byte ptr [edi], 00h                ; Añadimos  el  cero final
                                                   ; de   cadena    y   hemos
                                                   ; terminado.
                                                   ;
                                                   ; NOTA:
                                                   ; He parado  aquí, pero se
                                                   ; podría    seguir   hasta
                                                   ; donde  fuese  necesario.
                                                   ;

        NOTA: posiblemente éste no sea el código  más optimizado  posible, ni
              siquiera  el mejor o más sencillo, pero cumple perfectamente su
              cometido.

  [ 4.1.2.- Obtener la línea de comandos ]

  Ésta  es quizá la  parte más fácil  de todo el proceso  a realizar sobre la
 línea  de comandos,  obtenerla. Con  tan sólo  una API  podemos  obtener  un
 puntero  a  la  cadena  que  la  contiene,  y  con  sólo 20 bytes de  código
 nos quedaremos con  la parte realmente importante, los  comandos propiamente
 dichos. Todo el código que habrá que escribir es el siguiente:

        call    GetCommandLineA
        mov     edi, eax
        mov     al, 22h
        xor     ecx, ecx
        dec     ecx
        repnz   scasb
        repnz   scasb
        mov     al, 20h
        repnz   scasb

        Lo primero que se hace es llamar a la función GetCommandLineA (que se
        encuentra contenida en el kernel) para que nos devuelva  un puntero a
        la cadena que contiene toda la línea de  comandos, esta  cadena tiene
        un formato como el que sigue:

                "ruta ejecutable + nombre ejecutable" + comandos

        Es  decir,  la  ruta  completa  del  archivo  ejecutable se encuentra
        entrecomillada y a continuación están los comandos, que  son lo que a
        nosotros nos interesa. Es por esto que debemos eliminar toda esa ruta
        y también  el espacio  que queda entre la  última comilla y el primer
        caracter del primer comando de  la línea. Esto es  lo que consigue el
        código  anterior, deja  en EDI un  puntero a la cadena que empieza en
        ese primer caracter. Ahora todo lo que habría que hacer sería obtener
        cada comando  individualmente  a partir  de ese  puntero. Esta  tarea
        resulta sencilla  si a  la hora  de establecer  la línea de  comandos
        hemos  seguido  ciertas  normas,  como puede  ser comenzar  todos los
        comandos por un caracter en concreto o cualquier otra que nos permita
        identificarlos.

  [ 4.1.3.- Acerca de la línea de comandos y código relacionado ]

  El  código  mostrado en  los  dos anteriores apartados  está diseñado  para
 trabajar en  conjunto, cualquier  modificación  realizada  en alguno  de los
 fragmentos afectará, seguramente, a su correcto funcionamiento. Si el lector
 prefiere  utilizar otro  código en  lugar del  mostrado tendrá que  tener en
 cuenta  los  mismos  principios  que  se  han  seguido  en  el  diseño  y la
 implementación del código anterior.
  En el archivo zip que acompaña a  este artículo, el  lector encontrará  dos
 programas (con su correspondiente código fuente) llamados CLP.exe y SET.exe.
 CLP es un ejemplo de como se puede obtener la línea de comandos de la manera
 que  se muestra  en el anterior  apartado. SET es un  ejemplo de como  sumar
 varias cadenas de texto y pasárselas a CLP como línea de comandos. Por tanto
 para  ejecutar estos programas, deberán estar los dos en la misma ubicación.


  [ .Cierre ]

  Posiblemente el  tema que he tratado en este artículo podría dar más de sí,
 pero en estos  momentos otras ideas  consumen mi tiempo. Si  el lector tiene
 alguna idea, o va a implementar un SVC, por  favor, le ruego que se ponga en
 contacto  conmigo. También  serán  bien  recibidas  las críticas (tanto  las
 buenas como las malas) pues ayudarán a que mi estilo mejore.
  Desde aquí me  gustaría mandar un saludo a la gente de los canales #virus y
 #seguridad_redes en  el IRC-Hispano, y también  a la de #vxers, en Undernet.
 A continuación, las direcciones en las cuales puedo ser localizado:

        URL:                                           http://ieyasu.host.sk/
        Mail:                                             tokugawa@wanadoo.es
        IRC:                             IRC-Hispano: #seguridad_redes #virus
                                            Undernet: #vxers


                                                     (c) 2001 Tokugawa Ieyasu
        The distance between madness and genius is the sharpest Katana's edge