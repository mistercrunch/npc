
.--[ @_2500Hz - Underground Scene - ]--------------(http://www.2500hz.org)--.
|                                                                           |
| Titulo : Introduccion al 'mIRC Scripting'                                 |
| Autor  : nEuRoNaL (neuronal@linuxfan.com)                                 |
| Fecha  : 27/03/2000                                                       |
`-----------------------------------------------------(2500hz@mixmail.com)--´


-#- Indice/Contenidos -#-
-------------------------

 00.    Prologo...
 01.    Introduccion.
 02.    Listado de comandos.
 03.    Las partes programables en el mIRC:
  03.1.  Aliases.(creacion de alias, identificadores, ...)
  03.2.  Popups. (creacion de menus...)
  03.3.  Remotes.
   03.3.1  - Users.
   03.3.2  - Scripts.
   03.3.3  - Variables.
 04.    Estructuras "IF-Else"
 05.    Consejos y recomendaciones.
 06.    Despedida.

-------------------------



-#- 00.  Prologo... -#-
- -- - -- - -- - -- - -

        Este documento pretende ser un pequeño tutorial sobre la programacion
de scripts para el cliente de IRC 'mIRC'. Con esto quiero decir que todo
contenido aqui expuesto es valido en su totalidad para mIRC y, que al ser un
pequeño tutorial, el nivel del documento es, practicamente, basico.

Este documento puede ser distribuido libremente por cualquier tipo de
red/agrupacion, siempre y cuando se respete su entera integridad.

Para cualquier tipo de duda, critica, sugerencia... dirigios a:
neuronal@linuxfan.com y el autor respondera a todos los mails recibidos lo
antes posible.


-#- 01.  Introduccion. -#-
- -- - -- - -- - -- - -- -

        La definicion de que es un script para mIRC podria ser que es el
conjunto de varias rutinas o instrucciones aplicadas al mIRC para poder
ejecutar tareas en el IRC de forma automatica; es decir, que si cada vez que
entramos en un canal queremos decir: "Hola Mundo!" pues la verdad, es un
coñazo teclearlo manualmente, asi que podemos crear una instruccion para que
cada vez que entremos en un canal, el mIRC lance dicho mensaje
automaticamente...
Todas las rutinas que programamos en el mIRC se encuentran en "Las tres
partes programables del mIRC" en los aliases, popups y remotes... estas
partes son simplemente ficheros .ini (pueden tener cualquier extension) los
cuales se cargan en el mIRC.
Todas las instrucciones que programemos se basan en los "comandos base" que
el mIRC puede realizar; es decir, que si queremos decir algo automaticamente
(como el ejemplo anterior...) programamos una instruccion en la que se
encuentra el comando base "/say" (por ejemplo...)
Asi que si quieres diseñar un Script potente y con multitud de rutinas,
tendras que saber las posibilidades que tiene el mIRC; es decir sus "comandos
base" la lista es bastante amplia, ya que el mIRC es un programa que te da un
ancho campo para que puedas diseñar verdaderas maravillas. ;)

Bien y para acabar esta introduccion, cabe señalar un simple detallito;
La gente que programa en C y/o en cualquier otro lenguaje de programacion son
llamados "Programadores" asi como las personas que diseñan y mantienen
Paginas Web son llamamos "WebMasters".
Bien pues nosotr@s, los que programamos Scripts para mIRC, nos hacemos llamar
"Scripters" (Seguramente esta tonteria ya la sabias ;) esto lo digo para que
no "metais la pata" cuando le digais a vuestr@ padre/madre/colega/novi@...
que eres programador de scripts para mIRC (aunque tambien es valido), queda
mas "profesional" y "tecnico" decir que eres Scripter. ;)

Acabada esta pequeña introduccion, damos paso al tutorial...


-#- 02.  Listado de comandos. -#-
- -- - -- - -- - -- - -- - -- - -

        Bien pues en este apartado pongo todos los "comandos base" que el
mIRC incorpora... (Te recuerdo que esta lista es bastante importante, ya que
estos comandos van a ser los que utilices para diseñar tu propio script desde
cero!)
Tambien quiero que sepais que de memoria no me se todos los comandos, asi que
esta lista a sido sacada de la pagina web del canal #Ayuda_IRC
(http://www.ayuda-irc.net) y ha sido realizada por SomaTic
(sucubus@arrakis.es)
Os recomiendo que os imprimais esta lista, y asi la tendreis presente a todo
momento a la hora de hacer vuestro script...

                ----------------------( CuT HeRe )----------------------

        Esta es una guía de referencia de la mayoría de los comandos del mIRC y de su sintaxis tal y como se especifica en la ayuda del programa, versión 5.51. En la sintaxis he utilizado algunos símbolos cuyo significado es el siguiente:
Las palabras entre los símbolos "<" y ">" representan valores a introducir en el comando, no esas mismas palabras, sino lo que significan.
Todo lo que se encuentra entre los símbolos "[" y "]" son valores opcionales.
La barra "\", dentro de la sintaxis del comando, separa valores alternativos es decir, se puede introducir uno u otro pero solo uno cada vez.
Cuando vea especificaciones del tipo: -aqf, por ejemplo, se tratará de modificadores del comando, es decir, parámetros que modifican la acción de este. Estos son normalmente una sola letra precedida de un guión. En el ejemplo anterior deberá de poner -a, -q, ó -f. Sin embargo, en la mayoría de los casos es posible especificar más de uno cada vez a fin de combinar sus efectos, es este caso no es necesario más que un guión, por ejemplo: -af, -fq, -qa,...etc.
Por último recuerde que cuando se introduce un comando en la línea de escritura del programa es necesario iniciar esta con un símbolo especial, con el fin de que sea interpretada como tal comando y no como un mensaje normal al IRC. Este símbolo suele ser, en la inmensa mayoría de los casos, la barra inclinada: "/".
No se preocupe si de momento no entiende algunos comandos, bastantes de ellos realizan acciones avanzadas que ya conocerá con el tiempo y la práctica, puesto que están concebidos para dar su máxima utilidad dentro de rutinas de script, alias o popups; encontrará la explicación al manejo de estos recursos en los capítulos correspondientes de esta misma web.
Tenga en cuenta que el conocimiento de los comandos es el primer paso para entender el funcionamiento de los scripts y del IRC en general, es muy recomendable que los use habitualmente para irse familiarizando con ellos, aunque su programa de IRC pueda realizar estas mismas funciones de forma automática mediante opciones de menú. Muchos comandos no son exclusivos del mIRC, sino que son propios del protocolo IRC general y podrá, por tanto, usarlos sea cual sea su programa cliente.
Para cualquier duda puede dirigirse al canal #ayuda_IRC del IRC Hispano, mi nick es SomaTic. Cualquier aportación, critica, o consulta será bien recibida también en mi E-mail: sucubus@arrakis.es

/abook [nick]
Esta orden abre la agenda personal de mIRC, donde se pueden guardar los datos de los usuarios que se desee. Si especifica un nick la agenda se abrirá por la referencia a este nick concreto.

/ajinvite [on/off]
Activa o desactiva la opción de entrada automática en un canal cuando seamos invitados a este.

/alias [fichero] <nombre del alias> [<comandos>]
Añade, elimina, o reemplaza un alias en el fichero de alias especificado, o en el primero de los que existan si no se especifica uno. Para más información sobre los alias lea el capítulo "Los Alias del mIRC".
Este comando solo permite añadir alias sencillos, de una sola línea. Si ya existe un alias con el nombre indicado lo reemplazará por el nuevo que escribamos, si no ponemos comandos entenderá que debe de buscar un alias con ese nombre y eliminarlo.

/amsg <mensaje> y /ame <mensaje>
Envían el mensaje o la acción especificada a todos los canales en los que nos encontramos. Estos comandos no se pueden usar el remotes, como eventos ... etc.

/auser
Añade un usuario a su lista de usuarios remotos, encontrará una referencia a este comando y su manejo en el capítulo  "Usuarios remotos y eventos CTCP".

/away [mensaje de away]
Deja un mensaje explicando que en ese momento no estamos prestando atención a IRC. Cada vez que un usuario nos envíe un /msg o realice un /whois con nosotros verá automáticamente cualquier mensaje que insertemos. Utilizar /away sin parámetros elimina el mensaje de AWAY.

/background [-aemsgdluhcfnrtpx] [nombre_ventana] [fichero BMP]
Con este comando es posible especificar una imagen en formato .bmp como fondo para cualquier ventana del mIRC. Es la misma acción que el usuario puede realizar desde la opción BACKGROUND del menú de sistema de cada ventana, es decir, el que aparece haciendo click sobre el icono que se encuentra en el lado izquierdo de la barra de título de esta (no en la ventana IDE principal del programa).
Además del nombre de la ventana a tratar y del fichero de imagen a emplear se pueden usar los siguientes parámetros:
        -n = Aplica la imagen en modo normal, es decir, en su tamaño original y ajustada a la izquierda de la ventana.
        -c = Aplica la imagen centrada y en su tamaño original.
        -f = Aplica la imagen ampliandola hasta rellenar por completo la ventana.
        -r = Aplica la imagen centrada en la ventana y adaptandola al tamaño de esta.
        -t = Aplica la imagen en modo mosaico, es decir, rellenando toda la ventana con copias a tamaño original de dicha imagen.
        -p = Aplica la imagen reducida en la esquina superior derecha de la ventana.  
        -a = Aplica el fondo centrado a la ventana que se encuentre activa en ese momento adaptandola al tamaño de esta.
        -m = Aplica el fondo centrado a la ventana IDE principal del mIRC adaptandola al tamaño de esta.
        -s = Aplica el fondo centrado a la ventana de status adaptandola al tamaño de esta.
        -g = Aplica el fondo centrado a la ventana del finger adaptandola al tamaño de esta.
        -d = Aplica el fondo centrado a la ventana de querys adaptandola al tamaño de esta.
        -l = Aplica la imagen en modo mosaico como fondo de la barra superior de botones del mIRC.
        -u = Aplica la imagen como fondo de los botones de la barra superior del mIRC.
        -h = Aplica la imagen en modo mosaico como fondo de la barra de iconos del mIRC.
        -x = Elimina la imagen de fondo.
No es necesario especificar el fichero de imagen cuando se están modificando los atributos de visualización de alguno ya existente.

/ban [-u<número>] <#canal> <nick\dirección> [<tipo\máscara>]
Censura en el canal al usuario cuyo nick o dirección se ha especificado. Si el usuario no es operador del canal no podrá hablar en este, si está fuera o sale del canal no podrá volver a entrar. Cualquier operador del canal podrá realizar esta acción.
Por ejemplo: /ban -u600 #Tortosa PePe 2
La orden anterior banea al usuario PePe en el canal #tortosa durante 10 minutos (600 segundos). La censura se impone a través de su dirección de acuerdo a una máscara de tipo 2.
El parámetro -u permite especificar un ban temporal del número de segundos que se introduzca a continuación. Pasado este tiempo el ban se retira automáticamente. Para retirar manualmente un baneo utilice el comando /mode.
Si hemos especificado un nick el programa ejecuta internamente un /whois para conseguir la dirección del usuario, le aplica la máscara del tipo indicado y después realiza (ver comando /mode): /mode #canal +b máscara
Para una explicación detallada de las direcciones, las máscaras y sus tipos, consulte el capítulo "Las direcciones y las máscaras en el IRC"
El "tipo" es un número entre 0 y 9 que determina el tipo de máscara que se aplicará al baneo. El usuario permanecerá baneado mientras que no se le retire esta condición, o su dirección siga
coincidiendo con el patrón que especifica la máscara. El tipo es opcional (en su defecto se aplicará la máscara nick!user_id@dirección). También se puede especificar manualmente la máscara que se desea.
Por ejemplo: /ban #Tortosa *!*@*
Banea a todos los usuarios del IRC del canal #tortosa puesto que se ha introducido una máscara
genérica.
NOTA: Este comando utiliza La Lista Interna de Direcciones conservada por mIRC.

/beep <número> <retraso>
Emite pitidos a través del altavoz interno, un número determinado de veces con un retraso
especificado.

/channel
Hace surgir la ventana central del canal activo. Se trata de una ventana de dialogo donde se pueden manejar cómodamente los valores del topic, modos del canal, y lista de bans de éste.

/clear [-sghlc] [ventana]
Borra toda la memoria intermedia de desplazamiento en la ventana; es decir, limpia la ventana actual o la especificada de todos los mensajes impresos.

/clipboard <texto>
Copia en el portapapeles el texto especificado.

/close [-icfgms] [@nombre_ventana] [nick1] ... [nickN]
Cierra todas las ventanas del tipo, nombre, o nick especificados. Si no se especifica nick se cerrarán todas las ventanas existentes de ese tipo o tipos. Los tipos son: c para chat, f para fserve, g para get, i para "inactive dcc windows", m para query, y s para send. También se puede cerrar una ventana personalizada escribiendo su nombre precedido, como es costumbre en estos casos, del símbolo "@"
El siguiente ejemplo cierra las ventanas de chat y fserve abiertas con el usuario pepe:      
/close -cf pepe

/closemsg [nick]
Cierra la ventana de query del nick especificado.

/copy -ao <filename> <filename>
Permite dar una orden desde mIRC para copiar un fichero sobre otro fichero o directorio. Especificando el parámetro -o se sobreescribirán los ficheros si existen en el destino. Especificando -a se añadirá el contenido del fichero de origen al de destino.

/creq [+m\-m] [ask\auto\ignore]
Es la línea de comandos equivalente a las opciones de configuración del DCC que se pueden realizar en la ventana DCC\Options\Send (véase también el comando /sreq).

/ctcpreply <nick> <tipo_de_ctcp> [mensaje]
Especifica una respuesta para los requerimientos CTCP del tipo expresado.
Por ejemplo: /ctcpreply pepe HELP Llama a los bomberos ;-D.
Encontrará una explicación mas detallada a este comando y su uso en el capítulo "Usuarios remotos y eventos CTCP".

/dcc send <nick> [fichero1, fichero2,...]
Inicia un envío de ficheros hacia otro usuario. Se pueden especificar uno o más ficheros. Si no
ponemos ninguno se abrirá una ventana de diálogo desde donde podremos navegar por nuestro disco
para seleccionarlos.

/disconnect
Fuerza una desconexión inmediata. Este es diferente al comando /quit, el cual envía un mensaje de despedida al servidor y espera a que éste nos desconecte.

/dns <nick\dirección>
Se utiliza para resolver direcciones. Si especificamos un nick nos informará de su IP; si ponemos una IP intentará encontrar su resolución inversa. Para ser más precisos: si mIRC ve un "." en el nombre que hemos especificado, asume que es una dirección e intentará resolverla, de lo contrario asumirá que es un nick y realizará un /whois para averiguar su dirección y posteriormente resolverla. Si le damos una dirección IP, buscará el nombre del residente.
Es posible indicar más de un nick y/o dirección.

/dqwindow [on\off\show\hide\min]
Permite activar (on), desactivar (off), visualizar (show), ocultar (hide), o minimizar (min) una ventana destinada a recoger todos los querys recibidos. Usar esta ventana para todos los querys, en lugar de una para cada uno de ellos, implica que al responderlos deberemos de preceder cada mensaje de una indicación de a quien va dirigido, es decir, el comando /msg nick. Si usted observa que todos los querys le salen en la misma ventana y quiere cambiarlo para que exista una para cada uno de ellos, teclee: dqwindow off

/echo [color] [-e] [-s\-a\#canal\nick] <texto>
Imprime el texto especificado en la ventana, utilizando el color indicado (del 0 al 15). Sólo es impreso y visualizado por nosotros. Puede especificarse como destino de la impresión la ventana de status (-e), la ventana activa (-a), un canal determinado, o una ventana de privado con un nick concreto. El modificador -e añade una marca de separación una línea por encima y por debajo del mensaje.

/editbox [-s\-a\ventana] <texto>
Inserta el mensaje indicado en la línea de escritura (caja de edición) de una determinada ventana, en la de status (-s), o en la activa (-a).

/exit
Obliga a mIRC a desconectar y salir.

/finger <nick/dirección>
Realiza un "finger" en un usuario. Si indicamos una dirección ésta es señalada inmediatamente y si especificamos un apodo se busca la dirección del usuario utilizando un /whois y posteriormente es señalada.

/filter [-sgdfwxnpr] [n-n2] <origen> <salida> <cadena>
Este comando lee líneas de texto desde una ventana o fichero indicado como origen buscando la
cadena de texto especificada. Copia completas las líneas que encuentre conteniendo la cadena en otra ventana o fichero indicado como salida donde pueden ser consultadas.
Debemos de indicar en el comando si el origen y la salida son ficheros ambos (-ff), ventanas ambos (-ww), un fichero y una ventana (-fw) o una ventana y un fichero (wf)
Por ejemplo:    /filter -ff in.txt out.txt *mirc*
                /filter -wf #ayuda_irc out.txt *help*
Veamos la utilidad del resto de los parámetros que podemos emplear:
        El parámetro -x hará lo contrario a lo explicado antes, es decir, copiará las líneas que no contienen la cadena.
        El parámetro -n icluirá un número de línea delante de cada una de las que se copien.
        El parámetro -s hará que se use la ventana de status como origen.
        El parámetro -g hará que se use la ventana de finger como origen.
        El parámetro -d hará que se use la ventana dedicada de msg's como origen.
        El parámetro -p permitirá que se emplee una ventana personalizada como salida.
        El parámetro -r permite especificar un rango de líneas del origen a analizar.

/flash [-w\-b] <texto>
Este comando es muy útil para insertarlo en una rutina de script, a fin de que nos avise de cuando se produce un determinado suceso si estamos en otra aplicación y tenemos en mIRC minimizado.
Básicamente produce un aviso intermitente en el icono o botón del mIRC en la barra de tareas del Windows. El aviso continua hasta que pulsamos el icono y restauramos el mIRC.
Se puede especificar un texto que aparecerá una vez por segundo en el icono del mIRC También
podemos poner un "beep" que sonará con la misma frecuencia mediante el modificador -b, o bien otro sonido Midi o Wav si así lo indicamos en el diálogo "Event Beeps" de File/Options y usamos el modificador -w.
Puede ver un ejemplo inmediato escribiendo el comando: //.timer263 1 10 flash -b Esto es prueba
El timer nos dará tiempo a minimizar mIRC para ver los efectos del comando (he elegido el número 263 al azar). Pasados 10 segundos el botón del mIRC comenzará a mostrar intermitentemente la frase: "Esto es una prueba" y a emitir "beeps" de aviso; continuará así hasta que pulse el icono y restaure en pantalla el programa.

/font [[-a\-s\-b] [ventana] <tamaño de fuente> <nombre de fuente>]
Si indicamos el comando /font sin más parámetros activará la aparición del diálogo de fuentes en la ventana en la que estamos. Podemos también determinar directamente una configuración de fuentes para la ventana activa (-a), la de status (-s). u otra que indiquemos, dando un tamaño y nombre de fuente. El modificador -b fuerza la aparición en negrita de la fuente.

/fserve
Envía una sesión del servidor de ficheros para otro usuario utilizando un DCC Chat con con este. El usuario estará limitado a acceder sólo a los ficheros y directorios que indicamos en el comando. La sintaxis completa es:
/fserve <nick> <maxgets> <directorio_inicio> <Fichero_de_texto_de_bienvenida>
Los maxgets son el máximo número de DCC gets simultáneos que el usuario puede tener durante una
sesión del servidor de ficheros. El fichero de bienvenida es un texto que leerá el usuario cuando se conecta al servidor de ficheros.
Por ejemplo: /fserve pepe 5 c:\users c:\instruciones.txt
Esta línea iniciará una sesión del servidor con el usuario pepe, accediendo éste al directorio c:\users, y enviará a pepe el texto del fichero instrucciones.txt. El usuario sólo puede tener 5 gets simultáneos, es decir, sólo puede recibir 5 ficheros simultáneamente. En cada directorio o subdirectorio podemos colocar un fichero dirinfo.srv, que describe ese directorio. Cada vez que un usuario realice un CD para cambiar de directorio, mIRC buscará este fichero, y si lo encuentra, el texto que hay en su interior será presentado al usuario.
Los comandos principales que están a disposición del usuario, una vez conectado, son: cd (cambio de directorio), dir (listar directorio), ls (listar directorio en modo multicolumna), get <fichero> (recibir fichero vía DCC), read <fichero de texto> (leer el fichero). Todos los comandos disponibles han sido enormemente limitados con la esperanza de que puedan evitar una violación de seguridad.
Si un usuario se ha retrasado demasiado, el servidor cerrará automáticamente la conexión. Podemos instalar el tiempo de retraso en el diálogo de Opciones DCC.

/goto <etiqueta>
Se usa en definiciones de scripts para producir un salto incondicional a un punto diferente del script. Ver el capítulo "La estructura condicional IF-ELSE"

/help
Nos muestra la sección de Comandos básicos de IRC en el fichero help de mIRC. También podemos
ejecutar un /help palabra_clave , y si esta palabra coincide con un tópico de ayuda podremos acceder a él.

/ial [on\off]
Este comando activa o desactiva la Lista Interna de Direcciones del mIRC que es necesaria en algunos comandos e identificadores. Esta lista guarda los datos de los usuarios del IRC que vamos encontrando en nuestra sesión, los que están el los mismos canales que nosotros... etc. Su capacidad es limitada, por tanto los más antiguos se irán eliminando a medida que se cargan otros nuevos.

/identd [on/off] [User_id]
Activa o desactiva la opción Ident Server del Setup. Puede especificarse el USER ID deseado.

/ignore [-rpcntki] [-u<segundos>] <nick/dirección> [tipo]
Nos permite ignorar los mensajes procedentes de un nick especificado. Si no especificamos un tipo, sólo será ignorado el apodo del usuario, pero si lo hacemos, la dirección será buscada mediante un /whois y se aplicará la máscara correspondiente a ese tipo; todos los mensajes procedentes de esta dirección serán ignorados.
El modificador -r retira un ignore
Por ejemplo: /ignore -r PePe
Se puede especificar un ignore con una duración limitada en segundos: /ignore -u300 PePe
Así mismo se puede ignorar solo determinados envíos de un usuario, no todos ellos, mediante el
modificador adecuado: privados (-p), mensajes al canal (-c), notices (-n), ctcp's (-t), códigos de control (-k), e invites (-i). Puede indicar uno solo de ellos o varios simultáneos.
Por ejemplo: /ignore -pntik PePe
Este ejemplo pone un ignore al usuario PePe en todos sus envíos menos los que hace al canal.

/Invite <nick> <#canal>
Invita a otro usuario al canal.

/join [-inx] [<#canal>]
Nos introduce en el canal especificado. Con el modificador -i entraremos en el último canal al que nos hayan invitado. los modificadores -n y -x permiten minimizar o maximizar la ventana del canal tras nuestra entrada.

/kick <#canal> <nick>
Expulsa a este usuario de un canal especificado (solo para OP).

/linesep [-s\ventana]
Inserta una línea de separación en la ventana especificada. (-s es para la ventana de status).

/links
Presenta la lista de servidores de IRC enlazados en la red en que nos encontramos.

/list [<cadena> [-min<número>] [-max<número>]]
Nos presenta la lista de canales del IRC. Si especificamos una cadena de caracteres sacará solo
aquellos canales que contengan esa cadena en su nombre. También se puede indicar que presente
solo aquellos que tengan un número máximo y/o mínimo de usuarios en su interior     
Ejemplos:
        /list
        /list -min 5 -max 20
        /list #ayuda

/load <-a\-ps\-pc\-pq\-pn\-pm\-ru\-rs\-rv> <fichero>
Este comando permite cargar en el área de memoria RAM correspondiente al mIRC los ficheros de
alias, popups, y remotes que le indicamos. Solo podemos cargar uno cada vez.
Es la línea de comandos equivalente a la opción Load de los diálogos de alias (-a), popups (-p) y remotes (fichero de usuarios: -ru, fichero de script: -rs, y fichero de variables: -rv).
        /load -a <fichero>
        Carga un fichero de alias

        /load -ps <fichero>
        Carga un fichero de popups para el status

        /load -pc <fichero>
        Carga un fichero de popups para el canal

        /load -pq <fichero>
        Carga un fichero de popups para los query y chat

        /load -pn <fichero>
        Carga un fichero de popups para la lista de nicks

        /load -pm <fichero>
        Carga un fichero de popups para la barra de menús

        /load -rs <fichero>
        Carga un fichero de script

        /load -ru <fichero>
        Carga un fichero de usuarios

        /load -rv <fichero>
        Carga un fichero de variables

Los ficheros serán de texto. Pueden tener cualquier extensión aunque el formato más recomendable es el .INI. La capacidad de cada fichero es limitada, pero se pueden tener cargados tantos como se desee o permita la capacidad de nuestra RAM.

/loadbuf [<líneas>] <ventana> <fichero>
Permite imprimir en la ventana indicada el número de líneas que deseemos, contando desde la última, procedentes de un fichero de texto.
Por ejemplo: /loadbuf 10 #ayuda_irc mirc.ini
Esta orden imprimirá en la ventana del canal #ayuda_irc (siempre que estemos en él) las 10 últimas líneas del fichero mirc.ini. Estas líneas solo las veremos nosotros, no son enviadas al servidor.
También se puede especificar un rango de líneas, las comprendidas entre dos números:    
/loadbuf 10-20 #ayuda_irc mirc.ini
O incluso desde una línea hasta el final del fichero:    
/loadbuf 30- #ayuda_irc mirc.ini

/log <on\off> [<ventana>]
Nos permite conectar o desconectar la grabación "log" en una ventana, o de la ventana actual si no se especifica una.

/mkdir <nombre de directorio>
Permite crear un directorio con el nombre que deseemos.

/me <mensaje>
Envía una acción a la ventana activa, es decir un mensaje precedido de nuestro nick. Este comando no se puede usar en los remotes (eventos ... etc).

/mode [<#canal/nick>] [[+/-] modo [parámetros]]
Este es un comando que nos da gran control sobre los usuarios y el canal. Para cambiar los modos del canal se requiere el status de operador. La utilización del signo + o - equivale a la aplicación o retirada de los efectos del modo que se pone a continuación.

Modos para el canal:
        b <nick>: Banea a un usuario, equivale al comando /ban. La censura se extiende tanto al nick como al resto de la dirección del usuario.
Por ejemplo: /mode #bolsa +b PePe
        i: Hace el canal sólo para invitados.
        L<número>: El canal es limitado a un número máximo de usuarios.
        m: El canal es moderado (sólo los operadores o los usuarios con voz pueden hablar).
        n: Mensajes externos al canal no están permitidos.
        o <nick>: Convierte al nick en operador de canal
        p: Hace el canal es privado, es similar al modo s.
        s: El canal es secreto. No aparecerá en la lista de canales ni en el whois de los usuarios que
están dentro.
        t El topic es limitado, sólo los operadores pueden cambiarlo.
        k <clave>: Instala una clave secreta para acceder al canal (/join <#canal> <clave>).
        v: Proporciona voz a un usuario en un canal moderado.

Modos del usuario (cualquier usuario puede cambiar sus modos)
        i: Nos hace invisibles ante un usuario que no conozca las letras exactas de nuestro apodo, o no
esté en el mismo canal que nosotros.
        s: Recibe las noticias del servidor.
        w: recibiremos los Wall-op.
        d: Es un modo "ausente". no veremos los mensajes que se envien al canal, solo las acciones que se producen en este.

/msg <nick> <mensaje>
Envía un mensaje privado (query) a este usuario.

/nick <nick1> [<nick2>]
Cambia nuestro nick por otro que deseemos. Opcionalmente podemos indicar un segundo nick por si el primero ya está en uso.

/notify [-r] <nick> [<comentario>]
Añade un nick a la lista de notificación que nos avisará cada vez que este entre o salga del IRC.
Opcionalmente se puede añadir un comentario que también será visualizado.
Por ejemplo: /notify Adrian ¡Cuidado que este nukea!
Podemos eliminar un nick de la lista insertando el modificador -r. /notify -r Marisa
Podemos ver la lista de notify con los usuarios actualmente conectados mediante el modificador -s: /notify -s
O bien ocultarla con el modificador -h. /omsg [<#canal>] <mensaje>
Solo para operadores. Envía un mensaje privado a todos los operadores del canal actual o el
especificado.

/onotice [<#canal>] <mensaje>
Envía mediante notice el mensaje especificado a todos los operadores de un canal. Es necesario ser un operador para usar este comando. Si no se especifica el canal, entonces se utilizará el canal activo.

/part <#canal>
Produce nuestra salida del canal.

/partall
Produce nuestra salida de todos los canales en los que nos encontramos.

/perform [on\off]
Equivale a activar o desactivar la casilla "On connect, Perform these commands" del dialogo
File/Options/Perform. En esta ventana podemos indicar una serie de comandos que queremos que se
ejecuten siempre al inicio de las sesiones.

/play [-scp] [q<número>] [m<nick\#canal>] [r] [L<número>] [t<número>] [<ventana>] <fichero> [<retardo>]
Nos permite enviar textos procedentes de un fichero a un usuario o a un canal. El retardo se valora en milisegundos; si un usuario envía los ficheros a un servidor con demasiada rapidez, probablemente será desconectado por flood. El retardo por defecto es 1000. Las líneas vacías que se encuentren en un texto serán consideradas como un retardo.
/play -c \text\mypoem.txt 1500
El modificador -c obliga a mIRC a interpretar las líneas como comandos en lugar de un simple texto, por tanto los ejecutará.
El modificador -s permite imprimir en la pantalla de status sin necesidad de estar conectados al server.
El comando /play forma una cola con las ordenes de impresión cuando hay otras en curso. Esto se
debe a que si el comando intentara enviar todas las peticiones al mismo tiempo, el usuario podría ser desconectado del servidor por flood.
El modificador -p indica que ésta petición es prioritaria y por tanto debería ser colocada a la cabeza de la cola para su envío inmediato. La impresión en activo será detenida y reanudada posteriormente una vez que la de prioridad haya finalizado.
El modificador -q<número> especifica el número máximo de demandas que pueden estar en la cola.
Si su longitud es mayor o igual que el número especificado, la demanda de envío será ignorada. /play -q5 c:\text\info.txt 1000
El modificador -m<nick\#canal> limita el número de peticiones que pueden ser insertadas en la cola por un usuario o canal específicos (útil para comandos remotos). Si éstos se exceden o ya tienen el número acordado de peticiones, entonces la demanda de envío ser  ignorada.
/play -ml info.txt 1000
Esta línea limita a cada usuario a un máximo de una petición de una vez e ignora las demás.
NOTA: Los conectores -q y -m sólo se aplican a un /play iniciado a través de una definición remota, que no es especificada por usted. Para combinar los conectores anteriores, haríamos:
/play -cpq5ml info.txt 1000
El conector -r escoge aleatoriamente una línea individual de un fichero para enviarla.
/play -r action.txt 1500
El conector -L<número> envía el número de líneas especificado.
/play -L125 witty.txt 1500
Tanto para -r como para -L la primera línea del fichero debe ser un solo número que especifique la cantidad de líneas que hay en su interior
El modificador -t obliga a mIRC a buscar en el fichero el tópico especificado y a enviar todas las líneas bajo ese tópico.
Por ejemplo: /play - thelp1 c:\help.txt
En el fichero help.txt tendríamos:
        [help1]
        línea1
        línea2
        línea3
        [help2]....
El mIRC enviará  todo aquello que se encuentre después de [help1] y se detendrá cuando llegue al siguiente tópico o al final del fichero.

/pop <retardo> [<#canal>] <nick>
Ejecuta un Op retrasado en un nick. El propósito de este comando es el de evitar que la ventana del canal esté atestada de cambios de modo Op en los casos en que varios usuarios tengan al mismo nick en su sección auto-op. MIRC se detendrá en los segundos de retraso antes de ejecutar Op. Antes de ejecutar Op verificará si el usuario ya ha sido opeado. Si no especificamos el canal se considerará el canal activo.

/query <nick> <mensaje>
Abre una ventana de query a este usuario para enviarle un mensaje privado.

/quit [<mensaje>]
Cierra la conexión con el servidor de IRC. Permite opcionalmente enviar un mensaje de despedida a todos los canales en los que los encontramos. Por Ejemplo: /quit Hasta luego amigos!!

/raw [-q] <comando>
Envía los comandos que hemos insertado directamente al servidor. Es imprescindible conocer el
formato correcto raw del comando que estamos enviando. Es útil para mandar comandos que mIRC
aún no ha ejecutado. El conector -q realiza este trabajo sin imprimir lo que está enviando. Ojo, los comando raw no son necesariamente los mismos que los de un cliente de IRC, se trata de comando del servidor.
/raw PRIVMSG nick :Hellooo there!

/remini <fichero.ini> <sección> [palabra]
Este comando borrará una sección especificada de un fichero .INI (una sección es un bloque de líneas encabezado por un título entre corchetes). Opcionalmente podemos poner una palabra, en este caso solo se borrarán todas las ocurrencias de esa palabra.
PRECAUCIÓN: no use este comando para modificar ficheros .INI que se encuentren en uso.

/remove <fichero>
Se borrará el fichero especificado.

/rename <fichero> <nuevo_fichero>
Permite renombrar un fichero. También es útil para mover los ficheros de un directorio a otro aplicando la sintaxis: /rename <origen> <destino>

/resetidle
Pone a cero el identificador $idle.

/rmdir <directorio>
Permite borrar un directorio. Este directorio debe de estar vacío.

/run [-n] <fichero o programa> [parámetros]
Nos permite ejecutar un programa, bien especificandolo directamente o bien indicando un fichero de trabajo de ese programa. También es posible introducir parámetros que ese programa acepte por línea de comandos.
Por ejemplo: /run c:\comms\ftp\ftp.exe sunsite.unc.edu
Este ejecuta el programa ftp.exe con los parámetros sunsite.unc.edu

/savebuf [-s\-f] [-a] [n] [<ventana>] <fichero>
Salva en un fichero las n últimas líneas de una ventana especificada, o bien el rango de líneas que se marque.
Por ejemplo: /savebuf 20 #ayuda_irc copias.sav
/savebuf 10-15 status copias.sav
El modificador -s permite salvar el buffer de la ventana de status, y -a salvará la ventana actual.
Si el fichero de destino ya tiene algún contenido, y no queremos que se sobreesciba sino que las líneas salvadas se añadan al final de este, podemos utilizar el modificador -a.

/save <parámetros> <fichero>
Es la línea de comandos equivalente al botón SAVE TO en los diálogos de alias, popups y remotos, y es utilizado para salvar la sección especificada. Los parámetros y su uso son los mismos que en el comando /load, consultelo más arriba. Por ejemplo, si deseáramos salvar los alias en un fichero, haríamos: /save -a aliases.ini
NOTA: Sólo podemos referirnos a una sección de una vez, de forma que no podemos ejecutar:
/save -uce some.ini.

/say <mensaje>
Nos permite definir un alias que se escribe directamente en un canal como si estuviéramos diciendo algo. Así que, /say Hello there sería lo mismo que teclear "Hello there" en el canal actual. Es útil en el caso de un alias cuando queremos hacerle la misma pregunta (o enviar la misma información) una y otra vez:

/info /say "Visita la página: http://www.arrakis.es/~sucubus"
Cada vez que tecleemos el alias /info, la frase especificada se mostrará en el canal o ventana actual. Ver la sección "Los alias del mIRC"
NOTA: No se puede utilizar este comando en la sección remota, en su lugar use:
/msg <#canal> <mensaje>

/server <servidor\número> [puerto] [palabra clave]
Nos conecta a un servidor.
/server fuego.irc-hispano.org
Si tecleamos /server sin parámetros, mIRC conectará al último servidor que utilizamos. También
podemos indicar tan solo un número para conectarnos al que tenga este número de orden dentro de la lista de servidores del Setup. Si usamos el comando mientras estemos conectados seremos
desconectados al recibir el mensaje de abandono y seguidamente seremos conectados al servidor
especificado.

/showmirc -nrstx
Manipula la ventana principal del mIRC. -n = minimiza, -r = restaura, -s = activa, -t = iconiza, -x = maximiza.

/set <%variable> <valor>
Se usa en definiciones de scripts para crear y asignar valores a variables. Las variables deber de ir precedidas por el signo %. Este valor se puede eliminar con el comando /unset {variable}. Ver la sección "Variables del mIRC".

/sline [-a\r] <#canal> <número|nick>
Permite seleccionar o deseleccionar un elemento de la lista de nicks de un canal. El parámetro -a permite seleccionar un nick sin deseleccionar otros que ya lo estuvieran antes. El parámetro -r permite deseleccionar un nick.

/sound [nick/canal] <fichero de sonido> <mensaje>
Envía una demanda de sonido a otro usuario. Véase el diálogo de Opciones de Sonido para mayor
información. Tiene un ameno artículo sobre este tema en esta misma Web en: "El sonido en el mIRC".

/speak <texto>
Envía el texto especificado a "Monóloge" o a "Text Assist", programas que digitalizan sonido a partir de cualquier texto escrito que se les envía.

/splay <fichero de sonido\stop>
Ejecuta un fichero de sonido para escucharlo solo nosotros. la orden /splay stop detiene un sonido en curso.

/sreq [+m\-m] [ask/auto/ignore]
Es la línea de comandos que equivale a la configuración de los botones de la radio para solicitar un DCC Send y que se encuentra en el diálogo de opciones DCC (véase /creq arriba).

/timer<Nº/nombre> [-om] [tiempo] <repeticiones> <intervalo> <comandos>
Nos permite ejecutar comandos con un retardo de tiempo determinado, y que estos se repitan un
número concreto de veces, o indefinidamente hasta que detenemos el timer (poniendo las repeticiones a 0). El formato es: Por ejemplo: /timer1 0 20 /say está AWAY!
Timer1 imprimirá el mensaje en el canal actual, cada 20 segundos, hasta que detengamos el
temporizador.
/timer9 14:30 1 1 /quit Adiós, hora de salir
Timer9 esperará a las 14:30 y cerrará la sección con el server enviando el mensaje indicado.   
Con el modificador -m se puede especificar el tiempo del intervalo en milisegundos. Para ejecutar un timer es necesario estar conectado al server, salvo que usemos el modificador -o.
Para ver la lista de los temporizadores activos, teclee /timers. Para desactivarlos todos, teclee: /timers off, para desactivar uno determinado sería: /timer<N/nombre> off. También es posible desactivar un rango de timers simultáneamente, por ejemplo, la siguiente orden desactiva todos los timer entre el 30 y el 39: /timer3? off
Si estamos activando un nuevo temporizador, no necesitamos especificar el número del mismo,
simplemente hacemos lo siguiente: /timer 10 20 <comando>
Y mIRC añadirá  a este comando el primer temporizador libre que encuentre.
NOTA: Evidentemente es posible utilizar timers en rutinas de script aplicando identificadores. El inconveniente es que el timer no evalúa el contenido de estos tras la primera ejecución.
Por ejemplo: //time.reloj 0 600 echo -a La hora actual es: $time
Este timer nos daría la hora cada 10 minutos, pero siempre presentaría la misma porque $time solo es evaluado una vez, la solución es aplicar la variante: $!time. El símbolo "!" fuerza que el identificador sea evaluado a cada acción del timer.

/timestamp [-s\-a\-e] [on\off] [<ventana>]
Activa o desactiva la impresión de la hora delante de los mensajes que se reciben. La orden
/timestamp sin más parámetros nos indica su estado actual: on o off.
el modificador -s activa el comando solo para la ventana de status, -a lo hace para la ventana activa, -s lo aplicará a todas las ventanas.

/titlebar [@ventana_personalizada] <texto>
Presenta el texto especificado en la barra de título del mIRC o en una ventana personalizada que indiquemos.

/topic <#canal> <mensaje>
Cambia el tópico o mensaje explicativo del canal que todos los usuarios verán junto al nombre al hacer un /list, y en la barra de título de la ventana del canal.

/unload <-a\-rs> <fichero>
Descarga ficheros de alias y de script. Ver comando /load para más detalles.

/url [-d] [on\off\hide]
presenta la ventana de listas de URL. Si especificamos el parámetro -d , todas las opciones marcadas con "?" serán eliminadas antes de que aparezca la ventana. También podemos usar on\off para activar o desactivar la recepción de URL y hide para ocultar la ventana si ésta ya ha aparecido.

/uwho <nick>
Presenta la ventana de un usuario, en la que se muestra información sobre él. Se trata de la misma información que obtendríamos si ejecutáramos un /whois nick.

/whois <nick>
Muestra información sobre alguien.

/winhelp <fichero> [palabra]
Abre el fichero .hlp especificado. Si indicamos una palabra clave lo hará por la referencia a esa palabra.

/write [-cid -s<texto> -L<número>] <fichero> [texto]
Nos permite escribir líneas añadidas a un fichero. El modificador -c borra el fichero completamente antes de escribir en él; es decir, nos permite hacer borrón y cuenta nueva.
/write -c c:\info.txt Prueba
Este fichero será borrado y solo contendrá la cadena "prueba".    
        El modificador -L<número> especifica el número de líneas en la que se va a escribir el texto. si no lo insertamos, la línea será añadida al final del fichero: /write -L5 c:\info.txt Prueba
Esta línea sobreescribirá la línea 5 en el fichero "info.txt".
        El modificador -i indica que el texto debería ser insertado en la línea especificada en lugar de sobreescribirla. Si no indicamos ningún texto, una línea en blanco será insertada, y si no especificamos el número de línea, una en blanco será añadida al final del fichero.
/write -iL5 c:\info.txt
Una línea en blanco será insertada en la línea 5 del fichero "info.txt".
        El modificador -d elimina una línea del fichero. si no especificamos el número de la línea, la última del fichero será eliminada.
        El modificador -s<texto> escaneará el fichero buscando una línea que comience por el texto indicado y operará con ella.

/writeini <fichero ini> <sección> [item] [valor]
Permite escribir y modificar valores en un fichero de texto de tipo .ini.
Por ejemplo, podemos conseguir modificar una sección llamada [DDE] de un fichero: config.ini para que tenga la siguiente forma:
        [DDE]   
        ServerStatus=on   
        ServiceName=mirc
Las ordenes correspondientes serían:
        /writeini config.ini DDE ServerStatus on
        /writeini config.ini DDE ServiceName mirc

                ----------------------( eNd Of CuT )----------------------


-#- 03.  Las partes programables en el mIRC: -#-
- -- - -- - -- - -- - -- - -- - -- - -- - -- - -

        Bueno, y eso de las partes programables que es¿?... Pues simplemente
es el lugar en donde se escribe el codigo del script.
Estas partes (como ya sabreis) son tres: Aliases, Popups y Remotes; se
encuentran en el mIRC en la opcion Tools -->   Aliases
                                               Popups
                                               Remotes
O simplemente apretando Alt+A --> Aliases.
                        Alt+P --> Popups.
                        Alt+R --> Remotes.

Estas partes se encuentran o las podemos crear en archivos ini (te recuerdo
que puede ser cualquir extension...) que pueden estar en el mismo directorio
del mIRC32.exe o que pueden estar en un directorio especifico para este tipo
de archivos. (Por ejemplo el directorio /Sistema/)

A continuacion aprenderemos a programar el script en cada una de estas tres
partes...


-#- 03.1.  Aliases. -#-
- -- - -- - -- - -- - -

        En la parte de los aliases que es lo que pondremos? Pues las alias :P
Se accede a los aliases pinchando en "Tools" y luego en "Aliases" o
simplemente aprieta "Alt+A"
Las alias las podemos interpretar como comandos hechos por nosotros mismos.
(Recuerda que hay otro tipo de comandos que son los llamados por nosotros los
"comandos base" es decir, los comandos de mIRC)
Para que podais entender esta "tonteria" os pongo un simple ejemplo:

        /Hola /echo -s Hola que tal estas hoy ¿?

Bien pues en este facil ejemplo podemos ver el alias creado por nosotros
"/Hola" y este alias ejecuta el comando base: "/echo" ; Ahora cada vez que
escribas "/hola" automaticamente se visualizara en la ventana del status la
frase: "Hola que tal estas hoy ¿?"
como puedes ver los comandos "alias" son rutinas que creamos para automatizar
cualquier proceso que no queramos escribir una y otra vez.
Tienes que tener presente un pequeño detalle que puedes ver en el ejemplo
anterior; los comandos alias van precedidos del signo "/" (aunque este signo
puede no ponerse) luego el nombre del comando alias y seguidamente un
"espacio" (Esto es importante, ya que si no lo pones de este modo, el comando
creado puede resultar que no funcione...)

Los comandos alias que creemos pueden invocar a otro comando alias, es decir,
que se puede hacer una serie de comandos para que al final de todos esos
comandos ejecuten un comando final:
por ejemplo:

        /hola /decir
        /decir /echo -s Hola que tal estas hoy ¿?

En este ejemplo se ve claro como al ejecutar el comando "/hola" este llama al
comando "/decir" el cual ejecuta el comando final que queriamos.
Si por otro lado queremos crear un comando alias en el que se ejecuten
diversos comandos, tendremos que especificar nuestro comando alias con las
llaves "{" "}" (estas llaves sirven para encerrar todos los comandos que
querramos ejecutar en un mismo comando alias)
Por ejemplo:

        /multiple {     
          /nick nEuRoNaL
          /join #Scripters
          /part #Scripters
        } 

Bueno este ejemplo es como los anteriores... como ves la sintaxis de los
alias son bastante sencillas...
En este ejemplo se ve que con el comando que escribimos nosotros "/multiple",
automaticamete el mIRC nos cambiara el nick a nEuRoNaL, entrara en el canal
#Scripters y seguidamente saldra del canal #Scripters...
Como ves este simple comando nos puede ahorrar tiempo... Y esto es uno de los
principales factores a la hora de realizar un script, el de ahorrar tiempo y
automatizar nuestras acciones en nuestras sesiones de IRC. ;)
Tambien puedes crear el comando "/multiple" en una misma linea, mediante el
signo | entre cada comando.
Por ejemplo:

        /multiple /nick nEuRoNaL | /join #Scripters | /part #Scripters

Jeje, como ves hemos hecho lo mismo, pero ahora estan todos los comandos en
una sola y unica linea. ;)

Los aliases tambien nos permiten crear alias utilizando las teclas de funcion
(como las F1, F2, etc..). Esto es algo bastante util, ya que si durante tus
sesiones de IRC, estas continuamente tecleando o realizando alguna accion, la
puedes automatizar para que al apretar F1, o F2, o F3, o... se ejecute
automaticamente.
Por ejemplo; Nosotros siempre estamos haciendo los siguientes smelys: <[:) y
};-D. Bien pues esto nos puede resultar algo coñazo teclearlos siempre que
queramos ponerlos, asi que podemos hacer lo siguiente:

        F1 /say <[:)
        F2 /say };-D

Con estas dos pequeñas rutinas nos ahorraremos el teclear esos smelys, con
solo apretar la tecla "F1" el script devolvera al canal/query el smely "<[:)"
y lo mismo que al apretar la tecla "F2" devolvera el smely "};-D"
Tambien podemos crear alias para que cuando apretemos las teclas "Sift+F?" el
script ejecute alguna rutina automaticamente... Por ejemplo:

        /sF1 /quit $?="Mensaje de Salida"

Con esta rutina, al apretar "Sift+F1" el script invocara una ventana de
dialogo en donde te preguntara que mensaje quieres que salga en tu quit...

Bueno y si nos ponemos pesaos con este tema, pasa exactamente lo mismo con la
tecla "Ctrl+F?"
Ejemplo:

        /cF1 /join #$?="A que canal quieres ir¿?" 

Bien pues este ejemplo, es como los anteriores, pero ahora has de apretar las
teclas "Ctrl+F1" y en este caso el script te preguntara en una ventana de
dialogo que a que canal quieres entrar...

(Bueno, yo estos ejemplos os los explico, pero creo que son sumamente simples
y que cualquiera ya debe entenderlos e interpretarlos... ;o)

Tambien podemos crear comandos alias en donde podemos NO especificar, por
ejemplo, un canal al que quieres entrar; esto es posible mediante los llamados "Identificadores" Para que veais esto un poco mas claro pongamos un ejemplo...
(joer, que seria de este tutorial sin los ejemplos? xD ;)

        /j /join $1
                 ^^ -> representa al canal que quieras tu ("#canal")

Bien, pues en este ejemplo, como ya sabreis, el comando alias (es decir, el
que creamos nosotros) es el "/j" y el comando base (es decir, uno de los
comandos basicos del mIRC) el /join...
Con esto entramos en un canal el cual no lo especificamos en el alias... es
decir, que para poder usar ese alias tendriamos que
teclear --> /j "#canal" --> aqui escribes tu el canal al que quieras entrar
mediante el comando "/j"
Como ves, los Identificadores ($1, $2, $3, $...) son lo que le da
"flexibilidad" y manejabilidad a la hora de programar un script!

Tambien podemos hacer que el mIRC nos pregunte mediante una ventana de
diálogo lo que queramos; esto se hace mediante la sintaxis "$?" (en ejemplos
anteriores ya la hemos usado)... Por ejemplo:

        /j /join $?="A que canal quieres ir¿?"

Aqui se ve que al teclear "/j" el mIRC sabe que debe entrar en un canal
(/join) pero al no especificar que canal y estar el "$?" aparecera una
ventana de dialogo en donde te preguntara: A que canal quieres ir¿?
con esto se puede preguntar lo que quieras...
Como nuevo nick: /n /nick $?="Tu nuevo nick es¿?";
O lo que tu quieras...

El sector de los identificadores es muy amplio, asi que os pongo una lista
copiada de la web de #Ayuda-IRC (http://www.ayuda-irc.net)... (Aqui pasa como
con la parte de comandos base del mIRC, es una lista la cual no me se de
memoria, y en donde se recogen la mayoria de Identificadores...)

                ----------------------( CuT HeRe )------------------------

        A continuación se relaciona una lista con la mayoría de los
identificadores que se encuentran disponibles en la versión 5.31 de mIRC. Es
también necesario señalar que existe otra serie de identificadores asociados
con los eventos de mIRC de forma exclusiva, es decir, solo se pueden usar
dentro de estos y solo en algunos de ellos, puesto que son específicos para
los mismos; los podrá descubrir dentro de los ejemplos que se presentan del
el capitulo correspondiente a los eventos del mIRC.


                        IDENTIFICADORES DE TIEMPO Y FECHA
Se trata de una colección de funciones que devuelven valores relativos a la duración y tratamiento de intervalos de tiempo, así como al uso del importantísimo comando /timer.

$ctime
Devuelve el número total de segundos transcurridos desde las 0 horas de 1 de enero de 1970. Este valor es útil puesto que normalmente los servers, que suelen trabajar bajo sistemas UNIX, nos informarán de  los datos referidos a un momento determinado (conexión de un usuario ... etc), en este mismo formato, y podemos calcular los tiempos transcurridos entre dos sucesos, o uno y el momento actual, haciendo una simple resta y, luego transformandolo a formato semanas/días/horas/minutos/segundos mediante el identificador $duration.

$asctime(nº)
Si el número es 0 devuelve el dato: "Thu Jan 01 01:00:00 1970", si introducimos otro número este se entenderá como segundos, y transformará al formato fecha/hora el instante que resulta de sumar esos segundos al momento: "Thu Jan 01 01:00:00 1970".
Por ejemplo, si el server nos informa de que una Gline fue establecida en 8736924372, podemos ver, en formato más comprensible, la hora y la fecha que eso supone con la orden:
//echo -a $asctime(8736924372)

$date
Devuelve la fecha actual en formato: día/mes/año. Como ejemplo introduzca la siguiente orden:
//echo -a $date
Obtendrá una respuesta como: 19/05/98

$adate
Es igual a $date, pero devuelve al fecha en formato americano, es decir: mes/día/año

$day
Devuelve el nombre del día actual de la semana, en inglés claro ;)

$duration(nº)
Devuelve el número especificado de segundos transformado al formato: semanas/días/horas/minutos/segundos.
Por ejemplo: //echo -s $duration($ctime)
Esta orden devolverá el tiempo transcurrido desde las 0 horas de 1 de enero de 1970 hasta el momento presente, en formato semanas/días/horas/minutos/segundos.

$fulldate
Devuelve la fecha en formato largo, por ejemplo: Tue May 19 13:17:08 1998

$idle
Devuelve nuestro actual tiempo idle, es decir, el tiempo transcurrido desde que enviamos el último mensaje a IRC.

$ltimer
Devuelve el número del último timer activado con el comando /timer

$online
Devuelve el número de segundos transcurridos desde que se puso a cero el reloj contador del mIRC, es decir, los segundos transcurridos desde que nos conectamos en la sesión actual, o desde una fecha determinada, dependiendo como tengamos configurado el dialogo TIMER (menú TOOLS).

$ticks
Devuelve el número de ticks desde que se inició el sistema operativo. Esta es una unidad de medida propia del reloj interno de nuestro ordenador.

$time
Devuelve la hora actual en formato horas/minutos/segundos.

$timer(0)
Devuelve el número de timers activos en el momento actual (ver comando TIMER).

$timer(nº)[.propiedad]
Devuelve todas las propiedades de timer cuyo número se especifica: número de repeticiones, retardo y tipo... etc. Las propiedades que podemos usar son: com, time, reps, delay, type.
Por ejemplo: $timer(nº).com
Devuelve el comando o comandos asociados al timer especificado.

$timer(nº).type
Devuelve el tipo de status del timer especificado: online/offline.

$timestamp
Devuelve la hora actual en formato: [xx:xx]. Por ejemplo: [13:34]


                        IDENTIFICADORES DE NÚMEROS Y TEXTOS
Son funciones para el tratamiento aritmético de números y el manejo de cadenas de caracteres.

$abs(nº)
Devuelve el valor absoluto de un número, es decir, ese mismo número pero sin signo.

$asc(caracter)
Devuelve el número ASCII asociado al carácter que le introduzcamos.

$calc(operaciones)
Devuelve el resultado de las operaciones especificadas. Es útil para realizar operaciones múltiples de una forma sencilla.
Por ejemplo: $calc(3.14159 * (2 ^ %x % 3) - ($ticks / (10000 + 1)))
El símbolo "^" representa la potencia, el asterisco el producto, y "%" la división. Evidentemente "+" y "-" son la suma y la resta. No confundir el operador de la división con el símbolo "%" que precede a las variables (las cuales también se pueden incluir en la expresión), en el caso de estas el símbolo precede inmediatamente al nombre de la variable, mientras que si se trata del operador de división tendrá siempre espacios en blanco a ambos lados

$chr(nº)
Devuelve el carácter ASCII correspondiente al número especificado.
Por ejemplo: $chr(65)
Devolverá el carácter A. Como se puede apreciar es la operación inversa a la que realiza el identificador $asc.

$cos(N), $acos(N)
Devuelven el coseno y arcocoseno de un número.

$tan(N), $atan(N)
Devuelven la tangente y arcotangente de un número.

$count(cadena_1,cadena_2)
Devuelve el número de veces que cadena_2 se encuentra repetida dentro de cadena_1.
Por ejemplo: $count (jajajajaja, ja) Devolverá: 5

$int(nº)
Devuelve la parte entera de un número, sin redondear.
Por ejemplo: $int(3,94159) Devolverá: 3

$left(cadena,N)
Devuelve los N primeros caracteres de una cadena.
Por ejemplo: $left(goodbye,4) Devolverá: good

$right(cadena,N)
Devuelve los N últimos caracteres de una cadena.
Por ejemplo: $right(othello,5) Devolverá: hello

$len(cadena)
Devuelve el número de caracteres de una cadena, incluidos los espacios en blanco que contenga.

$lower(texto)
Retorna todos los caracteres de una cadena convertidos a minúsculas.
Por ejemplo: $lower(HOLA) Devolverá: "hola"

$mid(cadena,posición,número)
Devuelve el número especificado de caracteres de una cadena desde una posición dada.
Por ejemplo: $mid(othello,3,4) Retornará: "hell"

$pos(cadena,sub_cadena,número)
Devuelve la posición en que una sub_cadena comienza dentro de una cadena. El número sirve para especificar la subcadena cuando esta se repite en la cadena principal.
Por ejemplo: $pos(hello,el,1)
Devolverá: 2, puesto que la cadena "el" comienza en el segundo carácter de la cadena "hello"

$pos(hello,la)
Devolverá: $null (valor nulo), puesto que la subcadena no se encuentra dentro de la cadena principal.
Si el número especificado es 0 el identificador devolverá el número de veces que la subcadena se repite, igual que el identificador $count.
Nota: personalmente he detectado fallos en este identificador en algunos combinaciones, por lo tanto úsese con reservas y para casos contrastados.

$rand(valor1,valor2)
Devuelve un número o letra aleatorio comprendido en el rango [valor1-valor2] .
Por ejemplo: $rand(1,4)
Devolverá cualquier número entre 1 y 4, ambos inclusive.

$remove(cadena,sub_cadena)
Devuelve la primera cadena, de la que habrá suprimido la primera ocurrencia expresada en sub_cadena.
Por ejemplo: $remove(abcdefg,cd)
Devolverá: "abefg"

$replace(texto,cadena,reemplazo)
Busca una cadena dentro de un texto, y la reemplaza por otra especificada.
Por ejemplo: $replace(1234567,34,abc) Devolverá: "12abc567"

$round(número,N)
Devuelve un número especificado, con solo los N primeros decimales.
Por ejemplo: $round(3.14159,2) Devolverá: 3.14

$strip(texto)
Devuelve un texto del que eliminará los posibles códigos de colores, negrita y subrayado.

$str(texto,N)
Devuelve un texto dado repetido N veces.
$str(ho,3) Devolverá: "hohoho"

$upper(texto)
Devuelve un texto dado con todas las letras pasada a mayúsculas


                        IDENTIFICADORES DE FICHEROS Y DIRECTORIOS
Estas funciones permiten manipular y sacar información de nuestra estructura de ficheros y directorios en disco desde la sesión de mIRC, así como analizar aquellos que están relacionados con el propio programa mIRC.

$alias(n)
Devuelve el nombre de n-ésimo fichero de alias cargado en ese momento. Si se especifica un 0 devolverá el número de ficheros de alias que se encuentran cargados.
Es posible también especificar un nombre de fichero en lugar del número, la utilidad de esto es que el identificador devolverá $null si ese nombre de fichero no corresponde a ninguno de los ficheros de alias cargados en ese momento, e puede aprovechar en expresiones del tipo IF-ELSE (ver capítulo acerca de la estrutura IF-ELSE).
Ejemplos:
        $alias(0) Devuelve el número de ficheros de alias cargados en ese momento.
        $alias(2) Devuelve el nombre del segundo fichero de alias cargado en ese momento.
        $alias(aliases.ini) Devuelve $null si el fichero de alias especificado no está cargado.

$dir, $sdir, $file y $hfile
Presentan un cuadro de dialogo desde el que permiten seleccionar un fichero o directorio para ser utilizado dentro de la especificación de un alias, popup, o rutina de script. $dir presenta un dialogo desde donde se puede acceder a toda la estructura de ficheros y directorios del disco permitiendo seleccionar un fichero, mientras que $file presenta solo los ficheros contenidos dentro de un determinado directorio. En ambos casos se puede especificar mediante el comodín "*" qué tipos de ficheros se desea que aparezcan según su extensión. $hfile es igual a $file con la única diferencia de que presenta los ficheros horizontalmente. $dir permite seleccionar un directorio, es útil para casos en que no se desea que se especifique un fichero, sino tan solo un directorio.
El formato es: $dir[="Texto"] <path>
$file[="Texto"] <path>
$hfile[="texto"] <path>
$sdir[="Texto"] <path>
Por ejemplo, podemos definir una opción de popups que reproduzca los ficheros de tipo midi que hay dentro de un directorio llamado "midis", del que podremos seleccionar el que deseemos:
Música midi: splay $file="Selecciona la música" c:\midis\*.mid
Es útil poner un símbolo $ adicional (dos en total) delante del identidicador, de este modo, si no se selecciona ningún fichero o directorio el comando no se ejecutará, de lo contrario daría un mensaje de error de parámetro no especificado.
Nota: no usar estos especificadores para seleccionar un fichero a enviar por DCC, puesto que este comando lleva ya incorporado su propio dialogo de selección.

$exists(fichero)
Devuelve $true si el fichero existe, y $false si no es así. Es útil en instrucciones del tipo IF-ELSE.
$exists(c:\mirc\mirc.exe) Devolverá $true o $false.

$findfile(directorio, tipo_de_fichero, número)
Busca en el directorio especificado (y en todos sus subdirectorios), a todos los ficheros de un determinado tipo, y presenta el path y el nombre del que tiene el número de orden indicado. Si el número es 0 presentará toda la lista de ficheros encontrados de ese tipo.
Por ejemplo:    $findfile(c:\mirc,*.exe,1) Devolverá: c:\mirc\mirc.exe
                $findfile(c:\, auto*.*,1) Devolverá: c:\autoexec.bat

$getdir
Devuelve el directorio que tengamos especificado en el diálogo DCC options, como destino por defecto para las recepciones DCC.

$getdir(tipo_fichero)    
Devuelve el directorio que tengamos especificado en el diálogo DCC options, como destino para las recepciones DCC de ficheros del tipo especificado.
Por ejemplo: $getdir(*.txt)

$lines(fichero)
Devuelve el número de líneas que tiene un fichero de texto.
$lines(c:\irc\kicks.txt) Devolverá el número de filas del fichero: c:\irc\kicks.txt

$lof(fichero)
Devuelve el tamaño en bytes de un fichero especificado.

$logdir
Devuelve el directorio especificado en la sección Loggin del diálogo File/options, es decir, el direcctorio en los que se guardarán las copias (logs).

$mididir
Devuelve el directorio especificado para los ficheros Midi en la sección Sound Requests del diálogo File/options, es decir, aquel en el que mIRC buscará un fichero de extensión MID ante un requerimiento CTCP MIDI.

$nofile(fichero)
Devuelve el path o ruta de un fichero especificado.
Por ejemplo: $nofile(c:\mirc\mirc32.exe) Devolverá: c:\mirc\

$nopath(ruta y fichero)
Devuelve el nombre del fichero especificado, sin incluir el path.
Por ejemplo: $nopath(c:\mirc\mirc.exe) Devolverá mirc.exe

$mircdir
Devuelve el path donde se encuentra actualmente el programa mIRC.

$mircini
Devuelve el nombre del fichero .ini principal del directorio donde se encuentra el mIRC. Este es normalmente: mirc.ini.

$read
Lee una línea aleatoria de un fichero de texto, y la inserta dentro del alias en que se esté utilizando, interpretando esta línea como un comando de mIRC.
Su formato es: $read [-nL<número>] [-s<texto>] <fichero>
        El parámetro "-L<número>" permite especificar un número concreto de línea del fichero.
        El parámetro "-n" permite interpretar literalmente la línea, no como un comando.
        El parámetro "-s<texto>" devuelve la primera línea que comience por el texto especificado.
Ejemplos:
/say $read c:\funny.txt Imprimirá en pantalla una línea aleatoria del fichero c:\funny.txt.    
/say $read -l24 c:\funny.txt Imprimirá la línea 24 del fichero
/pateo /kick # $1 $read kicks.txt
Hará un kick del nick especificado dando como razón una línea elegida al azar del fichero "kicks.txt"
/say $read -smirc info.txt Busca una línea dentro del fichero "info.txt" que comience por "mirc", e imprime en pantalla el resto de la línea.
NOTA: si la primera línea del fichero es un número el programa entenderá que representa el número total de líneas del fichero; esto acelerará considerablemente la ejecución de $read. En caso de que especifiquemos el 0 como número de línea, y la primera de ellas sea un número, el identificador devolverá dicho número.

$readini
Lee información de un fichero .ini e inserta la fila correspondiente dentro del alias para su interpretación como un comando.
El formato es: $readini <-n><fichero> <sección> <item>
Por ejemplo: /echo $readini mirc.ini mIRC nick
Presentará nuestro nick actual tomándolo del fichero mirc.ini
El parámetro "-n" permite interpretar literalmente la línea, no como un comando.

$script(N/fichero)
Devuelve el nombre del n-ésimo fichero de script cargado. Si se especifica un nombre de fichero de script en lugar de un número, devolverá este mismo nombre, o $null si dicho fichero no se encuentra cargado.
Ejemplos:
        $script(0) Devuelve el número de ficheros de script cargados.
        $script(2) Devuelve el nombre del segundo fichero de script.
        $script(moo.txt) Devuelve $null si el fichero no está cargado, o moo.txt si lo está.

$wavedir
Devuelve el directorio especificado para los ficheros WAV en la sección Sound Requests del diálogo File/options.

                        IDENTIFICADORES DE NICKS Y DIRECCIONES
Algunas de las funciones más interesantes del mIRC se encuentran aquí. Una colección de identificadores útiles para el manejo y automatización de labores relaccionadas con los nicks y su dirección de conexión al IRC e Internet.

$address(nick,tipo)
Busca en la lista interna de direcciones la dirección asociada al nick especificado. Los tipos son los que se describen en el identificador $mask.
Por ejemplo: $address(nick,1)
Devuelve el formato: nick!User_ID@dominio.host
Si la lista interna no contiene el nick especificado, o se encuentra desactivada, se devolverá $null.

$comchan(nick,nº)
Devuelve los canales en que nos encontramos nosotros junto al nick especificado.
Por ejemplo:
        $comchan(nick,0) Devuelve todos los canales en que estamos nosotros y ese nick.
        $comchan(nick,1) Devuelve el primer canal en que nos encontramos junto a ese nick

$ial(máscara,nº)[.propiedad]
Devuelve direcciones de la lista interna de direcciones.
Propiedades: nick, user, host, addr.
Ejemplos:
        $ial(*!*@*.demon.co.uk,0) Devuelve todas las direcciones que concuerdan con la máscara especificada.
        $ial(*!*@*.demon.co.uk,3) Devuelve la tercera dirección de la lista que concuerda con la máscara especificada.
        $ial(*!*@*.com,0).nick Devuelve el nick que concuerda con la máscara.
        $ial(*!*@*.com,4).user Devuelve el User_ID que concuerda con la máscara.
Para escanear todas las direcciones de la lista interna se puede usar: $ial(*,0).

$ialchan(máscara,#canal,nº)
Igual al anterior pero solo referido a la lista de ocupantes de un canal especificado.

$level(address)
Busca dentro de nuestra lista de acceso remoto el usuario con la dirección especificada y devuelve su nivel de acceso.

$link(N)[.propiedad]
Devuelve el n-ésimo server de las lista de servers enlazados en la actual red de IRC.
Propiedades: addr, ip, level, info.
Ejemplos:
        $link(0) Devuelve el número de servers enlazados
        $link(1) Devuelve el primer server de la lista de links

$longip(address)
Convierte ina dirección IP en su formato en entero largo, y viceversa.

$maddress(máscara)
Busca el la lista interna de usuarios y devuelve la dirección del primer usuario que corresponde con la máscara especificada.

$mask(dirección,tipo)
Devuelve la máscara correspondiente al tipo especificado, para una dirección dada.
Por ejemplo: $mask(nick!khaled@mardam.demon.co.uk,1) Devolverá: *!*khaled@mardam.demon.co.uk
$mask(nick!khaled@mardam.demon.co.uk,2) Devolverá: *!*@mardam.demon.co.uk
Los tipos de máscara aplicables son los siguientes:
        0: *!User ID@host.dominio
        1: *!* User ID@host.dominio
        2: *!*@host.dominio
        3: *!* User ID@*.dominio
        4: *!*@*.dominio
        5: nick! User ID@host.dominio
        6: nick!* User ID@host.dominio
        7: nick!*@host.dominio
        8: nick!* User ID@*.dominio
        9: nick!*@*.dominio
La utilidad de este identificador es su uso en otros identificadores y comandos.

$me
Devuelve nuestro actual nick.

$nick(#canal,N)
Devuelve el n-ésimo nick de la lista de nicks del canal especificado. Si ponemos 0 devolverá en número de ocupantes del canal.

$nopnick(#canal,N)
Devuelve el enésimo nick de la lista de nicks que no tiene estatus de operador del canal especificado. Si ponemos 0 devolverá en número de no operadores del canal

$notify(N)[.propidad]
Igual a los anteriores pero referido a los nicks de nuestra lista de notificaciones. Además tiene las propiedades: note, sound, y whois.

$vnick(#canal,N)
Igual a los anteriores pero referido a los nicks que tengan voz dentro del canal especificado

$nvnick(#canal,N)
Igual a los anteriores pero referido a los nicks que no tengan voz dentro del canal especificado    

$opnick(#canal,N)
Igual los anteriores, pero referido solo a los nicks que tengan estatus de operadores del canal

$snicks
Devuelve en una línea, separados por comas, todos los nicks que tengamos seleccionados de la lista de nicks del canal.


                                                IDENTIFICADORES TOKEN
He mantenido el nombre de TOKEN para clasificar a este tipo de identificadores, tal como lo hace la ayuda de mIRC, porque es como se las alude normalmente en este "mundillo" y se trata de un grupo de funciones con una finalidad muy específica: el tratamiento de cadenas de caracteres, considerándolas como una serie de elementos individuales separados todos ellos entré sí por un carácter concreto.
Pensemos por ejemplo en una frase cualquiera; estará formada por una serie de palabras que se pueden identificar individualmente, aunque no entendamos su significado, porque tienen siempre un caracter ASCII concreto que las separa: el espacio en blanco. Otro ejemplo es la ruta de acceso completa de un fichero en nuestro disco duro, un caso: c:\musica\midis\películas\terminator.mid
Esta línea no es más que una cadena de caracteres que agrupa una serie de elementos individuales, identificables por el separador que hay entre ellos: la barra invertida: "\". Los identificadores TOKEN nos permitirán tomar cadenas de este tipo y manejar sus elementos, añadiendo, eliminando, sustituyendo... etc los que nosotros queramos, con solo especificar en la
función correspondiente cual es el separador común que hay entre ellos (este separador hay que identificarlo siempre mediante su correspondiente código ASCII; por ejemplo, el código del espacio en blanco es el 32 y el del punto el 46).
La gran utilidad de los identificadores TOKEN es que nos permiten hacer una buena emulación de lo que en programación se conoce como "tratamiento de arrays", es decir, manejar comodamente variables cuyo contenido es a su vez un conjunto de variables, todas ellas del mismo tipo, agrupadas para facilitar su manejo, e identificables individualmente por un índice.
Veamos los que están disponibles:

$addtok(cadena,elemento,separador)
Añade un nuevo elemento al final de la serie. Por ejemplo, hemos creado una variable conteniendo una serie de mombres: set %amigos Juan Antonio Pedro Luis
Desde este momento es indistinto usar la variable %amigos en el identificador o especificar la cadena completa: Juan Antonio Pedro Luis. Para el identificador no es más que una serie de elementos separados por un espacio en blanco.
Podemos usarlo para añadir un nuevo elemento a la variable, separado de los demás por un espacio en blanco, haciendo: $addtok(%amigos,Manuel,32)
Ahora la variable contendrá: Juan Antonio Pedro Luis Manuel. Podremos verlo facilmente con una orden que nos lo imprima en la ventana de estatus: //echo -s %amigos

$instok(cadena,elemento,posición,separador)
Es similar al anterior, permite añadir un elemento a la cadena, pero insertándolo en la posición que deseemos en lugar de al final de esta. Si especificamos una posoción superior a la última lo añadirá al final de la serie. Por ejemplo: $instok(1 2 3 4 5,R,3,32)
Este ejemplo devolverá: 1 2 R 3 4 5

$puttok(cadena,elemento,posición,separador)
Sustituye el elemento que se encuentra en una determinada posición por el que nosotros le especificamos.

$deltok(cadena,posición,separador)
Devolverá la cadena, de la que habrá eliminado el elemento que se encuentra en una determinada posición.

$gettok(cadena,posición,separador)
Nos devuelve el elemento de la cadena que se encuentra en una determinada posición. Si la posición es superior a la última nos devolverá $null.
Por ejemplo: $gettok(Juan Antonio Pedro Luis,2,32) Esta función nos devolverá: "Antonio".
Si en lugar de posición ponemos el valor 0 nos devolverá el número de elementos de la cadena.
También podemos indicar un rango de posiciones, es decir, pedir todos los elementos entre dos posiciones dadas, o una posición y el final:
$gettok(a.b.c.d.e,2-,46) Devolverá desde la 2ª hasta el final: b.c.d.e
$gettok(a.b.c.d.e,2-4,46) Devolverá los elementod desde el 2º al 4º: b.c.d

$findtok(cadena,elemento,número,separador)
Nos devolverá la posición el la que se encuentra el elemento especificado dentro de la cadena. Si el elemento no se encuentra devolverá $null.
El número sirve para señalarle a la función, en caso de que encuentre mas de un elemento igual al señalado, a cual de ellos nos referimos.
Por ejemplo: $findtok(A B C C D C,c,3,32)
Este ejemplo devolverá: 6, es decir, la posición del tercer caracter "c" dentro de la cadena.

$remtok(cadena,elemento,número,separador)
Buscará dentro de la cadena un elemento igual al indicado, si hay varios elejirá el que hace el número de orden que indicamos, y nos devolverá la misma cadena después de haber eliminado este elemento.
$reptok(cadena,elemento,nuevo_elemento,número,separador)
Buscará dentro de la cadena un elemento igual al indicado, si hay varios elejirá el que hace el número de orden que indicamos, sustituirá este elemento por uno nuevo especificado, y nos devolverá la cadena resultante.


                                        IDENTIFICADORES DE VENTANAS
Funciones que nos informan acerca de distintos aspectos referios a las distintas ventanas abiertas en la sesión de mIRC; ya sean de canal, chat privado, servidor de ficheros, etc.

$active
Devuelve el nombre de la ventana activa.

$appactive
Devuelve $true si mIRC es la aplicación activa en ese momento, y $false si no lo es.

$chan(N\#canal)[.propiedad]
Devuelve información sobre los canales en que nos encontramos.
Propiedades: topic, mode, key, limit.
Si se especifica un numero en vez de un canal, devuelve el nombre de ese canal.
        $chan(0) Devuelve el número de canales en que nos encontramos.
        $chan(2) Devuelve el nombre del segundo canal en que nos encontramos.
        $chan(2).key Devuelve la clave del segundo canal en que nos encontramos.
También podemos especificar un nombre de canal, pero solo devuelve información sobre este si nos encontramos dentro de él.
$chan(#mIRC).mode Devuelve los modos del canal #mirc.

$chat(N/nick)[.propiedad]
Devuelve información sobre las ventanas de DCC chat abiertas. Propiedades: ip, status.
Por ejemplo: $chat(2).ip Devuelve la IP del segundo DCC chat activo.

$fserv(N/nick)
Devuelve información sobre las ventanas abiertas del servidor de ficheros.
Propiedades: ip, status, cd (directorio abierto)

$get(N/nick)[.propiedades]
Devuelve información sobre los DCC get en curso (recepción de ficheros).
Propiedades: ip, status, file, size, rcvd, cps, pc.
Ejemplos:
        $get(0) Devuelve el número de dcc gets en curso.
        $get(2) Devuelve el nick que envía el segundo DCC get activo
        $get(2).rcvd Devuelve el número de bytes recibidos hasta el momento en el segundo dcc get.
        $get(2).cps Devuelve el número de caracteres por segundo que se están recibiendo en la segunda transmisión de ficheros
        $get(3).pc Devuelve el porcentaje transmitido en la tercera recepción en curso.

$query(N/nick)[.address]
Devuelve el nick o la dirección del enésimo query abierto.
Propiedad: address
Ejemplos:
        $query(0) Devuelve el número de querys abiertos.
        $query(2) Devuelve el nick del segundo query.
        $query(1).address Devuelve la dirección del primer query.

$send(N/nick)[.propiedad]
Devuelve información sobre los envíos de ficheros en curso (DCC sends).
Propiedades: ip, status, file, size, sent, cps, pc.
Ejemplos:
        $send(0) Devuelve el número de ficheros que se están enviando.
        $send(2) Devuelve el nick de destino del segundo envío.
        $send(1).sent Devuelve el número de bytes enviados en el primer DCC en curso.
        $send(3).pc Devuelve el porcentaje transferido en el tercer envío en curso.
        $send(3).status Devuelve el estado (activo, inactivo, o en espera) del tercer sed en curso.


                                        IDENTIFICADORES DIVERSOS
Aquí cabrían todos los identificadores no detallados anteriormente, que son muchos; pero, como ya he comentado, gran cantidad de ellos está vinculados necesariamente a ciertos eventos y no son aplicables siempre, por lo que en generál dos dejarémos para el capítulo de Eventos. Aquí incluiré una miscelánea de más dificil clasificación de acuerdo a la clasificación que hace el mIRC en sus ficheros de ayuda (como vengo haciendo en el resto de este documento), y algunos
más que vayan surgiendo y encuentre inetesante añadir.

$away
Devuelve el valor $true (verdadero) o $false (falso) Si estamos en estado de away o no.

$bits
Devuelve 16 o 32, según tengamos la versión de 16 o 32 bits del mIRC.

$cb
Devuelve los primeros 256 caracteres contenidos en el portapapeles.

$cr
Devuelve el carácter de retorno de carro. Es equivalente a poner: $chr(13)

$ddename
Devuelve el nombre actualmente especicado para el servidor DDE

$editbox(window)
Devuelve el texto contenido en la caja de edición (límea de escritura) de una determinada ventana.

$email
Devuelve la dirección de mail especificada en la correspondiente casilla del dialogo File/Setup.     

$host
Devuelve el nombre del actual Local host.

$ignore(N)[.type]
Devuelve la dirección del enésimo elemento de la lista de ignores.
        $ignore(0) Devuelve el número de elementos incluidos en la lista de ignores.
        $ignore(1) Devuelve la dirección del primer elemento de la lista de ignores.
        $ignore(2).type Devuelve el flag del segundo elemento de la lista de ignores, es decir, el tipo de ignore impuesto: a los querys, a los DCC...etc.

$inmidi e $inwave
Devuelve $true si se está reproduciendo un fichero midi o wave respectivamente, de lo contrario devuelve $false.

$ip
Devuelve nuestra dirección IP.

$lf
Devuelve el carácter de salto de línea. Equivale a: $chr(10).

$port
Devuelve el número del puerto del server en el que estamos conectados.

$server
Devuelve el nombre del server al que estamos conectados, o $null si estamos desconectados.
$server(N)
Devuelve la dirección del enésimo server de la lista de servers de File/Setup/IRC Server.
Propiedades: desc (descripción), port (puerto), group (grupo).
        $server(0) Devuelve el número de servers de la lista.
        $server(2) Devuelve la dirección del segundo server.
        $server(2).desc Devuelve la descripción del segundo server.
        $server(3).port Devuelve el puerto de conexión especificado para el tercer server.

$url
Devuelve la dirección URL de la página actualmente cargada en el navegador.
Ejemplo: /say Estoy viendo la página: $url ... os la recomiendo!

$usermode
Devuelve nuestros actuales modos de usuario.

$version
Devuelve la versión del mIRC en uso.

$+
Este identificador insertado en una línea de instrucción eliminará el espacio el espacio en blanco que se encuentra a su derecha, y el que se encuentra a su izquierda (ver la sección a Alias del mIRC).

$<número>-
Se puede usar $1 $2 ... $N para referirse a los parámetros o palabras individuales de una línea de comando. Además es posible especificar $nº- para referirse al parámetro o palabra de la posición especificada, y todos los que le siguen, y $nº_1-n_2º para referirse a todas la palabras comprendidas entre dos posiciones especificadas (ver la sección de Alias del mIRC).

$address
Devuelve la dirección de un usuario asociado a un evento, en la forma: User_ID@host.dominio.

$fulladdress
Devuelve la dirección de un usuario asociado a un evento, en la forma: nick!User_ID@host.dominio.

$group(N/#nombre)[.status]
Devuelve el nombre o estatus de un grupo de un script.
        $group(0) Devuelve el número de grupos del script.
        $group(1) Devuelve el nombre del primer grupo del script.
        $group(1).status Devuelve el estatus del primer grupo: on o off.
        $group(#name) Devuelve el estatus del grupo #name

$nick
Devuelve el nick de un usuario asociado a un evento.

$ulevel
Devuelve el nivel de acceso remoto de un usuario asociado a un evento.

                ----------------------( eNd Of CuT )----------------------

Como podras observar, hay muchisimos tipos de identificadores; tambien puedes
crear los tuyos propios... Simplemente creas uno con el nombre que quieras
(por ejemplo "&DecirHola") en ese identificador especificas el alias, el cual
es el que lleva la accion... Ejemplo:

        $DecirHola /hola
        /hola /say $me os envia un gran saludo!

El identificador "$DecirHola" invoca al comando alias "/hola" el cual es el
que envia el mensaje "$me(tu nick) os envia un gran saludo!"

Bueno, y que mas nos falta por saber sobre el aliases... que sepas que en el
aliases encontraras estructuras como las llamadas variables (se representan
por %?); las estructuras "IF-Else" (son estructuras que muestran una
condicion...) y muchas otras cosas que ya aprenderemos durante la marcha...
Aun nos falta saber las posibilidades que tienen las dos partes programables
restantes; los popups y los remotes.

En este tipo de programacion tienes que ver la relacion que hay entre
aliases, popups y remotes... (Seguramente, aun no veras dicha relacion, ya
que solo hemos dado la parte de los aliases); todas las alias se complementan
o con los popups o con los remotes y estos a su vez se relacionan entre
ellos; con lo que todas las partes estan ligadas unas con otras: Esto es
digamos el "secreto" de la programacion de Scripts para mIRC.

Resumiendo todo este tema de los aliases cabe tener muy claro que:

        _  Todo script es formado mediante los "comandos base" de mIRC.
           (/nick, /join, /kick,  etc...)
        _  Todos los comandos alias que creemos son unicamente comandos que
           invocan a los comandos base.
           (Ej: /n.join /nick nEuRoNaL | /join #Scripters | /part #Scripters
        _  Lo principal en las alias son los identificadores; (es lo que "da
           flexibilidad" a la hora de crear scripts). Son como otro tipo de
           comandos que muchas veces se entrelazan con comandos alias.
           (ejemplo: /j /join $?="A que canal quieres ir¿?" | $me os Saluda!)
        _  Tambien es importante en los aliases el uso de variables,
           estructuras "IF Else", etc... (Lo daremos mas adelante...)


-#- 03.2 Popups. -#-
- -- - -- - -- -- --

        Los popups son los menus que encontramos en el mIRC.
Se accede al popups pinchando en "Tools" y luego en "Popups" o simplemente
aprieta "Alt+P"
Estos menus pueden ser modificados creando nuestro propios menus para nuestro
script.
Para comprender bien el tema de los popups hace falta haber leido previamente
el tema de los aliases, y comprender su uso, ya que los popups son
practicamente un tipo de aliases aunque orientado a los menus mIRC. (con esto
quiero decir, que los popups son simplemente "ordenes" que, generalmente,
llaman a algun comando alias...)

Los menus de mIRC son los siguientes:

        _  Status: Este menu es el referente a la ventana "Status" del mIRC;
           se accede a el pulsando con el boton derecho del raton sobre la
           ventana "Status"
        _  Channel: Este menu es el referente al menu de las ventanas de los
           canales; se accede a el pulsando con el boton derecho del raton
           sobre la ventana de cualquier #canal.
        _  Query/Chat Este menu es el referente al menu de las ventanas
           "Query" y "DCC Chat"; se accede a el pulsando con el boton derecho
           del raton sobre la ventana de cualquier Query o DCC Chat.
        _  Nickname List: Este menu es el referente al menu de los nicks de
           un canal; se accede a el pulsando con el boton derecho sobre el
           nick que quieras que se abra el menu de Opciones "Nickname List"
        _  Menubar: Este menu es el referente al menu de la barra de tareas
           de mIRC (En el mIRC, el menu se expone como "Commands"; se accede
           a el pulsando con el boton izquierdo sobre la palabra "Commands"
           de la barra de tareas del mIRC...)

Para poder programar y modificar cada uno de los menus del mIRC, pincharemos
en "Tools" luego en "Popups" (como hemos dicho anteriormente...) y en la
ventana que aparece pulsamos sobre la opcion "View"; nos apareceran todos los
menus posibles que se pueden programar. (Status, Channel, Query/Chat,
Nickname List, Menubar)

Para comprender mejor los popups expondremos un ejemplo... A contnuacion
pondremos el menu popups del Status del mIRC (Modificado algo por mi...)

        Agradezco la ayuda a:/agradecimientos
        -
        Opciones del canal
        .Entrar en
        ..#mIRC:/join #mirc
        ..#irchelp:/join #irchelp
        ..Entrar en?:/join #$$?="Donde quieres entrar¿?"
        .-
        .Quien hay en¿?
        ..#mIRC:/names #mirc
        ..#irchelp: /names #irchelp
        ..Quien hay en?:/names #$$?="Sacar nick del canal...¿?"
        Opciones varias
        .Listar canales:/list
        .-
        .Cambiar tu nick:/nick $$?="Nuevo nick que quieres¿?"
        .Away
        ..Encender:/away $$?="Motivo porque estas away¿?"
        ..Apagar:/away
        .-
        .Whois ?:/whois $$?="Nick ¿?"
        .Query:/query $$?="Nick ¿?"
        -
        Desconectar del IRC:/quit Leaving!

Jeje, este es el Menu Status del mIRC (Aunque bastante cambiado ;)
Lo primero que has de entender es la estructura de los menus. Como ves, cada
linea del menu tiene en primer lugar un nombre (Por ejemplo -> "Opciones del
canal") Estos nombres son los que apareceran cuando pulses con el boton
derecho de tu raton sobre la ventana Status y se despliegue el menu.
El menu, a su vez puede tener otros menus (SubMenus) estos "SubMenus" se
describen mediante el punto "." que llevan delante algunos nombres...
(Por ejemplo -> .Quien hay en¿?
                ..#mIRC:/names #mirc)
Y estos submenus pueden tener otros menus y estos otros mas y asi
sucesivamente; un punto "." significa un SubMenu, dos puntos ".." significa
un Sub-SubMenu, tres puntos "..." significa un Sub-Sub-Sunmenu, y asi
sucesivamente... (Este rollo de los menus lo puedes comparar con el rollo de
los directorios de un Disco Duro; Un ejemplo de esto puede ser lo siguiente:
en el directorio "C:\Juegos" puede haber un subdirectorio llamado por ejemplo
"Quake2" y en este puede haver uno llamado "baseq2" y en este otro llamado
"players" y esto sucesivamente...)

En cada linea del menu (como hemos dicho anteriormente) esta compuesta por un
nombre; y seguidamente le acompaña el signo ":" despues de los dos puntos ":"
sigue la accion que finalmente se ejecutara (Esta accion normalmente es un
comando aliases; aunque tambien puede invocar a una opcion del remote; o
puede que la accion sea un comando base...) para entender esta tonteria
pongamos ejemplos ;)

Ejemplo 1:      Desconectar del IRC:/quit Leaving! --> (En esta opcion del
                menu, la accion que se ejecutara sera la de un "comando base"
                el comando /quit)

Ejemplo 2:      Agradezco la ayuda a:/agradecimientos --> (En esta opcion del
                menu la accion que se ejecutara sera la de un "comando alias"
                el comando alias "/agradecimientos")

        (No pongo ningun ejemplo de alguna opcion de menu que ejecute algun
comando de los remotes para que no veias como son y os podais liar; tened
paciencia, que si estais entendiendo hasta ahora todo o casi todo lo expuesto
hasta ahora, dentro de poco estareis distribuyendo en las mejores Webs
vuestro propio Script! ;)

Bueno pues otra pequeña cosa que cabe decir es el detalle de que en algunas
opciones del menu (como por ejemplo la de -> "Opciones del canal") no le
sigue ningun ":" ni ninguna accion a ejecutar, esto es debido a que al pasar
el raton por esa opcion se abrira un SubMenu, con esto quiero decir que las
opciones de menu que no tengan delante del nombre ninguna accion, es debido a
que en la siguiente linea le precede uno o mas SebMenus... Ejemplo:

        Opciones del canal
        .Entrar en
        ..#mIRC:/join #mIRC

Como vereis en el ejemplo, la opcion "Opciones del canal" no le precede
ninguna accion ni ":" pero si seguis viendo y pasais a la siguiente linea,
vereis que lleva un punto "." quiere decir que es un SubMenu; en este ejemplo
este SubMenu tampoco lleva precedido ninguna opcion ni ":" ello quiere decir
que la siguiente linea es otro SubMenu, es dezir, un "Sub-Submenu"
especificado con los dos puntos ".." de delante de la linea. En este ejemplo,
al final de el Sub-SubMenu, aparece la accion "entrar en el canal #mIRC"

Tambien cabe resaltar la raya esa "-" esta raya lo unico que representa es
una linea entre menu y menu... Ejemplo:

        Agradezco la ayuda a:/agradecimientos
        -
        Opciones del canal

Esta "-" marca una separacion entre cada menu. Como imaginareis tambien
ponemos separar mediante estas rayas los submenus... Ejemplo:

        .Listar canales:/list
        .-
        .Cambiar tu nick:/nick $$?="Nuevo nick que quieres¿?"

Aqui se ve claramente como el "SubMenu" Listar canales queda separado del
otro "SubMenu" Cambiar tu nick ...

Bueno pues ya estan explicados los popups, no es nada mas... como vereis, la
relacion que decia que existe entre los aliases y los popups se cumple, ya
que los menus popups pueden invocar a comandos aliases o a los remotes, con
lo que todas las partes programables del mIRC se relacionan entre si mimsas;
eso es "el secreto" del Scripting. (vuelvo a repetir x)


-#- 03.3 Remotes. -#-
- -- - -- - -- - -- -

        Personalmente creo que esta parte es la mas significativa e
importante de mIRC, ya que en ella podremos crear multitud de rutinas (como
por ejemplo crear listas de usuarios, ctcp´s, File Server...) con las que
podremos, verdaderamente, estar al tanto de todo lo que sucede alrededor de
nuestras sesiones de IRC.

Incluso podremos realizar menus popups y comandos aliases en los mismos
remotes (esto es muy util y utilizado por numerosos scripters para realizar
los llamados ADDon´s, ficheros, normalmente con extension .mrc, "de añadido"
que se cargan en el programa mIRC para que, de este modo, queden "instaladas"
nuevas funciones y/o menus en el mIRC.)
Se accede a los remotes pinchando en "Tools" y luego en "Remote" o
simplemente aprieta "Alt+R"

Los remotes se dividen en tres partes fundamentales:
    - Users.
    - Scripts.
    - Variables.


-#- 03.3.1 Users. -#-
- -- - -- - -- - -- -

        Se accede pinchando en "Tools" y luego en "Remote" (si lo prefieres,
aprieta "Alt+R") y luego pulsando sobre la solapa "Users".
En esta parte es donde asignaremos diferentes niveles de acceso para los
usuarios creando una lista de usuarios. De esta forma, podremos determinar
nuestra lista de amigos, enemigos...
Estos "niveles de acceso" que determinaremos son libres, es decir que
podremos asignar los numeros que queramos para cada tipo de nivel (Que sepas
que mIRC pone niveles a todos los usuarios como "normales", es decir sin
privilegios ni denegaciones (logico no?) y el numero que utiliza mIRC por
defecto es 1, aunque este numero puede variar segun lo que indique en la
opcion Tools/Remote/Options/Default User Level)

Una vez tengamos asignados numeros a nuestros deseados niveles para nuestra
lista de usuarios, deberemos utilizar los diferentes niveles para crear los
llamados eventos (estos son todos los sucesos que se van produciendo a lo
largo de una sesión de chat: join´s, part´s, quit´s, kick´s...). La creacion
de estos eventos se explicara mas adelante...
La sintaxis es la siguiente:

        <nivel>:<nick>!<user>@<host>/<ip>

Para facilitar la comprension de este tipo de estructura, pongamos un par de
ejemplos:

                50:nEuRoNaL!2500hz@195.53.66.56

En este ejemplo vemos que el nivel de usuario es '50' y que SOLO tendra acceso
a dicho nivel AQUEL usuario que tenga por nick 'nEuRoNaL', que su User ID sea
'2500hz' y que el host que tenga sea '195.53.66.56' (En este caso, si alguna
de estas tres cosas no coinciden, el usuario en cuestion no tendra acceso al
nivel 50)

                100:*!blackcode@*

Este caso ya es algo mas "flexible" ya que para que el usuario tenga acceso
al nivel '100', puede tener el nick que quiera (* significa que es valido
cualquiera...), el User ID debe ser 'blackcode' y su host/ip puede ser cualquiera...

Tambien es importante destacar que aquel usuario que tenga acceso a un nivel
determinado (100, por ejemplo.), tiene acceso tambien a cualquier nivel
inferior a ese (99, 98, 97, 96...); por ejemplo; en los ejemplos anteriores, el
usuario *!blackcode@* al tener acceso al nivel 100, tambien lo tiene sobre el
nivel 50.
Si quisieramos que el usuario *!blackcode@* unicamente tuviera acceso al
nivel '100' podriamos conseguirlo añadiendo un '=' delante de la sintaxis del
usuario.
Quedaria de la siguiente forma:

        =100:*!blackcode@*

Como vereis, el "=" delante del nivel '100' determina que la persona
*!blackcode@* unicamente podra tener acceso a los eventos del nivel
determinado...

Bien, una vez conocida y comprendida la estructuracion y sintaxis de los
niveles de usuario, vamos a ver como podria ser una posible lista de usuarios
con el fin de que os hagais una pequeña idea:

        ;Ejemplo de una lista de usuarios.
        ;---------------------------------
        ;Usuarios con:
        ;------------: nivel 500 - Yo
        ;------------: nivel 400 - Bots
        ;------------: nivel 300 - Auto Op
        ;------------: nivel 100 - Auto Voz
        ;------------: nivel 10  - Auto Kick
        500:*!*2500hz@195.53.66.56
        400:CHaN!-@-
        400:NiCK!-@-
        400:MeMo!-@-
        400:oPeR!-@-
        400:SHaDoW!^@^
        300:*!*blackcode@212.79.130.*
        100:*!*E-N-G@213.4.74.*
        10:*!*mig@63.67.171.*

Bien, pues con esta reducida lista de usuarios se ve claramente su
funcionamiento.
Para una mejor lectura he comentado mediante ";" la diferente numeracion que
ha sido asignada a cada nivel de usuario.


-#- 03.3.2 Scripts. -#-
- -- - -- - -- - -- - -

        Se accede pinchando en "Tools" y luego en "Remote" (si lo prefieres,
aprieta "Alt+R").
Es la seccion "mas importante" de los remotes puesto que es donde se
colocaran todos aquellos eventos que, unicamente, podran ser activos por
aquellos usuarios que tengan el nivel de acceso requerido. Este nivel de
acceso se especifica, como ya hemos visto, en la parte de Users.

Para esquematizar y ordenar de la mejor forma posible estos eventos, decimos
que estos se dividen en tres tipos fundamentalmente:
    - Events
    - CTCP
    - RAW (Numeros RAW)


        -#- Events -#-

        Bien pues, como dije anteriormente, los events (eventos) son todos
aquellos sucesos que se van produciendo a lo largo de nuestras sesiones de
IRC...
Antes de describir la mayoria de los eventos en esta seccion, vamos a poner
un ejemplo de uno para comentar su estructuracion:

Imaginaos que queremos que cuando algun usuario entre a algun canal en donde
estemos nosotros, nuestro script nos avise mediante un sonido e imprima en
pantalla un mensaje:
Bien pues para eso pondremos:

        ON ^1:JOIN:#: {
          /splay $mircdirsonidos/join.wav
          echo # - (J)oin - $nick ha entrado en # | halt
        }

Bien pues aqui vemos que cuando algun usuario con nivel 1, es decir cualquier
usuario (recuerda que mIRC por defecto asignaba el numero 1 al nivel
"normal": usuario cualquiera.) entra en el canal "#" (canal donde estemos)
mIRC ejecutara un sonido llamado "join.wav" el cual se encuentra en la
carpeta "sonidos".
A parte de ejecutar dicho sonido, imprimira en nuestra pantalla un mensaje
diciendo: "- (J)oin - $nick ha entrado en #" (donde $nick es el usuario que
ha entrado en # , es decir, en el canal.)

Como veis, consta de una estructuracion muy simple y bastante legible...

Bien ahora imaginaos que queremos dar OP automaticamente a aquellos usuarios
que tengamos en nuestra lista de usuarios con nivel de usuario: "Auto Op" (en
el ejemplo anterior de la lista de usuarios asignamos a dicho nivel el numero
300)
En este caso pondriamos:

        ON @300:JOIN:#: {
          mode $chan +o $nick 
        }

En este caso el nivel de usuario ha cambiado, ahora es 300 (Auto Op) con lo
que nuestro mIRC solo realizara la siguiente accion a aquellos usuarios que
tengan dicho nivel; la siguiente accion es dar op (mode $chan +o $nick) en
ese canal a dicho usuario "privilegiado".

Una vez explicado la estructuracion y sintaxis de cualquier evento, os
adjunto algunos de los eventos con los que se pueden componer los remotes.
(esta lista a sido sacada de la pagina web del canal #Ayuda_IRC
(http://www.ayuda-irc.net) y ha sido realizada por SomaTic
(sucubus@arrakis.es))


                ----------------------( CuT HeRe )----------------------

#- Evento ON TEXT
Este evento se produce al recibirse un mensaje especificado, bien en un privado, o bien en un canal en el que nos encontramos.

Formato: on <level>:TEXT:<texto>:<*><?><#[,#]>:<comandos>   
Ejemplo: on 1:TEXT:*ayuda*:*:/msg $nick ¿Cual es el problema?

El texto del mensaje que deseamos que produzca el evento se puede especificar de varias maneras:   
        *  El evento se producirá ante cualquier texto.
        &  El evento se producirá ante cualquier palabra.
        Texto  El evento se produce anta una palabra concreta y no otra.
        Texto*  Se produce ante una cadena de caracteres que comience por el texto especificado.
        *Texto  Se produce ante una cadena de caracteres que finalice por el texto especificado.
        *Texto*  El evento se produce si el texto contiene la cadena especificada, sea cual sea su                 posición.
Se puede especificar el lugar donde se controlará el evento de la siguiente forma:
        ?  Controlara la producción del evento dentro de un query o de un DCC chat
        #  Controlara la producción del evento dentro de un canal cualquiera en el que nos
           encontremos
        #canal_1,#canal_2,...  Controlará la producción del evento dentro de un canal
                                     especificado.
        *  Controla el evento en un privado o canal indistintamente.

Ejemplos:

        on 1:TEXT:Hola*:#:/msg $chan ¡Bienvenido al canal $chan $nick $+ !

Esta instrucción detectará cuando alguien diga la palabra "Hola" en cualquier canal que nos encontremos, y automáticamente le dará la bienvenida al canal en cuestión. El identificador $+ elimina los espacios en blanco que tiene a ambos lados, de ese modo podemos hacer que el nick de la persona que ha dicho "hola" aparezca en nuestra respuesta seguido del símbolo "!", si escribimos directamente este símbolo a continuación de $nick este no será reconocido como un identificador del nick del usuario, sino que aparecerá literalmente como está en la orden.   
           
También es posible emplear variables para dar más flexibilidad al formato del evento, por ejemplo:   
           
        on 1:TEXT:%text:%canal:/msg $nick Tú has escrito %text en el canal: %channel
           
Este ejemplo trabajará con los valores previamente guardados en las variables %text, y %canal.   
           
Nota: Este evento se producirá solo ante textos de otros usuarios, los de usted no desencadenarán el evento.

      
#- Eventos ON ACTION  y ON NOTICE
Tienen el mismo formato que on TEXT, y se producen a partir de una acción o de una noticia respectivamente. Recordemos que una noticia se produce cuando alguien nos envía un mensaje con el comando /notice, y una acción cuando alguien efectúa una acción de control dentro del canal; por ejemplo:   
           
        on 1:ACTION:*set mode*:#:/msg $chan ¡Ya estamos jugando con los modos!
           
Esta orden detectará cualquier acción que contenga la cadena "Set mode", y emitirá un mensaje al canal en que se produce.   
           
        on 1:NOTICE:*:?:/msg $nick Estoy ocupado, espera un momento!
           
Esta orden detecta cualquier /notice recibido estando en un privado, y responde con otro /notice al autor.   


#- Eventos ON BAN y ON UNBAN
Estos eventos se producirán cuando un usuario sea baneado o desbaneado en el canal.   

Formato: on <level>:BAN:<#[,#]>:<comandos>   
Ejemplos:
        on 1:BAN:#:/msg $nick Has sido baneado de: $chan
        on 9:BAN:#:/mode $chan -o $nick | /mode $chan -b $banmask

El segundo ejemplo es una acción múltiple que quita el estatus de operador al usuario que puso el ban, y elimina este cuando el usuario baneado tiene nivel 9 o superior en la lista de usuarios de nuestro programa (la función $banmask devuelve la máscara de baneo que fue empleada, y se usa, en este caso, para eliminar dicho baneo).


#- on 1:UNBAN:#:/msg $bnick Has sido desbaneado por $nick
Observe en este ejemplo el uso de la función $bnick. Esta devuelve el nick del usuario baneado o desbaneado, pero solo en caso de que dicho nick este incluido dentro de la máscara del baneo. En caso contrario $bnick = $null (nulo).   

Es posible tener en cuenta en la sintaxis de la instrucción los niveles del baneador y del baneado. A este fin se puede preceder el número de l nivel de los signos: <,>,<=,=>,<>, ó =. Por ejemplo:   

        on >=2:BAN:#:/msg $chan $nick baneado $banmask (legal)
           
En esta situación, si el nivel del baneador es mayor o igual que el del usuario baneado, se comunica queeste es un ban legal (como se podría comunicar cualquier otra cosa)   
           
Recuerde, esta sintaxis compara los niveles de baneado y baneador, nunca que este tenga o no nivel superior o igual a 2.   
           
Nota: Estos eventos solo operan cuando el server de IRC proporciona los nicks de baneador y baneado, y no su cuando da sus direcciones.   
           
Observe el siguiente ejemplo:   

        on 1:BAN:#: {   
          if ( $banmask iswm $address( $me ,0)) || ( $me isin $banmask ) { echo -s $nick te ha
          baneado con esta máscara: $banmask }
          if ( $me isop $chan ) { mode $chan -ob+b $nick $banmask $address($nick,2) }
        }

Esta rutina se inicia cada vez que se produce una acción de baneo en un canal en que nos encontramos. En primer lugar comprueba que la máscara del ban coincide con la nuestra o bien tiene incluido nuestro nick, en tal caso emite un mensaje a la ventana de estatus especificando la persona que lo ha realizado y la máscara con la que se ha hecho el ban, a continuación comprueba si somos operadores del canal, y en tal caso retira el estatus de operador a quien nos ha baneado, y le banea a su vez.


#- Eventos ON CHAT y ON SERV
Los eventos on CHAT y on SERV se producen cada vez que es enviado un mensaje la una ventana de DCC chat, o a un Fserve respectivamente. Es similar al evento on TEXT, el cual no funciona en un chat ni en un servidor de ficheros.

Formato: on <level>:<CHAT/SERV>:<texto>:<comandos>
Ejemplo: on 1:CHAT:*ayuda*:/msg $nick Cual es el problema?

La especificación del texto que producirá el evento se hace de la misma forma que en ON TEXT.


#- Eventos ON CHATOPEN y ON CHATCLOSE
Estos eventos se producen al abrirse o cerrarse (respectivamente), una sesión de DCC chat.   

Formato: on <level>:CHATOPEN:<comandos>
Ejemplo: on 1:CHATOPEN:/msg =$nick Bienvenido!
Ejemplos:

        on 1:CHATOPEN:/msg =$nick Hola, estoy contigo en un momento.
           
Esta instrucción envía una frase al DCC chat cuando este se abre por primera vez. El uso del signo "igual" delante de $nick es necesario para que el mensaje se dirija a la misma ventana del DCC chat, y no a una ventana privada aparte.

        on 1:CHATCLOSE:/notice $nick fin de la discusión!

Esto se produce al cerrar la ventana del DCC chat.


#- Eventos ON SERVOPEN y ON SERVCLOSE
Estos eventos se producen al abrirse o cerrarse (respectivamente), una sesión del FSERVE .

Formato: on <level>:CHATOPEN:<comandos>
Ejemplo: on 1:CHATOPEN:/msg =$nick Bienvenido!


#- Eventos ON CONNECT y ON DISCONNECT
El evento on CONNECT se produce cuando mIRC conecta al server de IRC, después de visualizar el MOTD (mensaje del día del servidor).

Formato: on <level>:CONNECT:<comandos>
Ejemplo: on 1:CONNECT:/join #ayuda_irc

on DISCONNECT es otro evento con el mismo formato, que se produce al desconectarse del server.

Ejemplo:   
        on 1:CONNECT:/echo Conectado a $server a las $time Tu nick es: $nick


#- Evento ON CTCPREPLY
Se produce cuando otro usuario responde a una pregunta CTCP por parte de usted.

Formato: on <level>:CTCPREPLY:<texto>:<comandos>
Ejemplo: on 1:CTCPREPLY:VERSION*:/echo $nick está usando IRC cliente: $1-

Ver evento on TEXT para los formatos de texto aceptados.
Ejemplo:

        on 1:CTCPREPLY:PING*:/echo -s $nick ha respondido al ping!


#- Eventos ON OP y ON DEOP
Se producen cuando un usuario del canal es opeado o deopeado.

Formato: on <level>:OP:<#[,#]>:<comandos>
Ejemplo: on 1:OP:#ayuda_irc:/msg $nick No abuses del estatus!

El evento on SERVEROP es exactamente igual, y se produce cuando un usuario es opeado por el server.
           
Ejemplos:

        on 9:OP:#:/mode $chan -o $opnick | /msg $nick no opees a esa persona!

En este ejemplo el evento se produce cuando es opeado un usuario de nivel de acceso 9 en nuestra sección de remotes. $opnick devuelve el nick de la persona opeada o deopeada, y $nick el de la que lo opeó o deopeó.

        on 1:DEOP:#ayuda_irc:/mode $chan +o $opnick

Con esta orden devolvemos el op a cualquier persona que sea deopeada en el canal #ayuda_irc.
          
Es posible tener en cuenta en la sintaxis de la instrucción los niveles del opeador y del opeado. A
 este fin se puede preceder el número de nivel de los signos: <,>,<=,=>,<>, ó =. Por ejemplo:

        on >=2:OP:#mIRC:/msg $chan $nick opeado (legal)

En esta situación, si el nivel del opeador es mayor o igual que el del usuario opeado, se comunica que este es un op legal (como se podría comunicar cualquier otra cosa)
Recuerde, esta sintaxis compara los niveles de opeado y opeador, nunca que este tenga o no nivel superior o igual a 2.

Nota: Estos eventos solo operan cuando el server de IRC proporciona los nicks de opeador y opeado, y no su cuando da sus direcciones.


#- Eventos ON VOICE y ON DEVOICE
Se produce cuando un usuario recibe o es privado de voz en un canal moderado en que nos encontramos.

Formato: on <level>:VOICE:<#[,#]>:<comandos>
Ejemplo: on 1:VOICE:#:/msg $vnick ya tienes voz en: $chan

Ejemplos:

        on 9:VOICE:#:/mode $chan -v $vnick | /msg $nick No des voz o ese tío!

Esta orden se ejecuta cuando el que recibe voz tiene nivel 9 o superior.

        on 1:DEVOICE:#mIRC:/mode $chan +v $vnick

Devuelve la voz al que se le quite en el canal.
Son aplicables también los prefijos de comparación de niveles descritos en on BAN y on OP.


#- Evento ON DNS
Se produce cuando hacemos un requerimiento DNS (comando /dns).

Formato: on <level>:DNS:<commandos>
Ejemplo: on 1:DNS:/notice $me resuelto: $raddress

Ejemplo:

        on 1:DNS:/echo $nick ip address: $iaddress named address: $naddress resolved address: $raddress


#- Evento ON ERROR
Se produce cuando el server envía un mensaje de error, por ejemplo, en una desconexión.

Formato: on <level>:ERROR:<texto>:<commandos>
Ejemplo: on 1:ERROR:*server full*:/echo Has salido del server!

Ver el evento on TEXT para el formato del texto.

Ejemplos:

        on 1:ERROR:*banned*:/echo Has sido baneado de este server!


#- ON FILESEND y ON FILERCVD.
   ON SENDFAIL y ON GETFAIL
Se producen al completarse un dcc send o un dcc get (envio o recepción de ficheros reapectivamente).

Formato: on <level>:FILESENT:<filename[,filename]>:<comandos>
Ejemplo: on 1:FILESENT:*.txt:/msg $nick ahí te mando: $filename !!

Los eventos on SENDFAIL y on GETFAIL se producen cuando un dcc send o un dcc get son fallidos.

Ejemplos:

        on 1:FILESENT:*.txt,*.ini:/echo Enviado $filename a $nick $address

Se produce cuando enviamos un fichero .TXT o INI. $filename devuelve el nombre del fichero enviado.

        on 1:FILERCVD:*.txt,*.ini:/echo Recibido $filename de $nick | /run notepad.exe $filename

Esta orden avisa cuando hemos recibido ficheros .TXT e .INI, y abre el bloc de notas para ver su contenido.

        on 1:SENDFAIL:*.txt:/echo Ha fallado el envío de $filename a $nick!!


#- Evento ON INPUT
Se produce cuando introducimos texto en una caja de texto y pulsamos INTRO.

Formato: on <level>:INPUT:<commandos>
Ejemplo: on 1:INPUT:/echo Texto introducido: $1-

La función $1- devuelve en este caso toda la cadena de texto introducida.


#- Evento ON INVITE
Se produce cuando un usuario nos invita a un canal.

Formato: on <level>:INVITE:<#[,#]>:<comandos>
Ejemplo: on 1:INVITE:#mIRC:/join $chan


#- Eventos ON JOIN y ON PART
Se producen al entrar o salir un usuario de un canal en que nos encontramos

Formato: on <level>:JOIN:<#[,#]>:<comandos>
Ejemplo: on 1:JOIN:#:/msg $nick Hola!


#- Evento ON KICK
Se produce cuando un usuario es expulsado de un canal en el que nos encontramos.

Formato: on <level>:KICK:<#[,#]>:<comandos>
Ejemplo: on 5:KICK:#:/invite $knick $chan | /msg $nick Hey, $knick ese es mi amigo!

Es aplicable también aquí la regla de comparación de niveles de los nicks descrita el los eventos on BAN y on OP.


#- Eventos ON LOAD y ON START
Estos eventos se producen cuando un fichero de script es cargado o descargado.

Formato: on <level>:LOAD:<commandos>
Ejemplo: on 1:LOAD:/echo mIRC Script cargado!


#- Eventos ON MIDIEND y ON WAVEEND
Se produce cuando el mIRC termina la reproducción de un fichero MIDI o WAV

Formato: on <level>:MIDIEND:<commandos>
Ejemplo: on 1:MIDIEND:/splay jazzy.mid

Este evento no tiene funciones asociadas. No se producirá si la reproducción se detiene a causa de una interrupción, solo lo hace cuando la reproducción es completada.


#- Evento ON MODE
Se produce cuando un usuario cambia los modos del canal (pero no los de usuario).

Formato: on <level>:MODE:<#[,#]>:<comandos>
Ejemplo: on 1:MODE:#ayuda_IRC:/notice $me $nick Cambia modos de $chan a: $1-


#- On SERVERMODE es otro evento que se produce cuando los modos son cambiados por el servidor.

Ejemplo:
        on @1:MODE:#:/notice $me $nick changed $chan mode to $1-

Esta instrucción se produce cuando alguien cambia los modos del canal teniendo nosotros también el estatus de operador.


#- Evento ON NICK
Se produce cuando un usuario cambia de nick dentro del canal.

Formato: on <level>:NICK:<commandos>
Ejemplo: on 1:NICK:/msg $nick Hi $newnick!

$nick devuelve el nick antiguo; $newnick el nuevo.


#- Evento ON NOSOUND
Este evento se produce cuando alguien activa un sonido en el canal y el mIRC no encuentra el fichero midi o wav en nuestros directorios de sonidos, los especificados en el dialogo FILE/OPTONS/SOUNDS.

Formato: on <level>:NOSOUND:<comandos>
Ejemplo: on 1:NOSOUND:/notice $nick No tengo el fichero $filename


#- Eventos ON NOTIFY y UNOTIFY
Se producen al entrar o salir del IRC un usuario que se encuentra en nuestra lista de notificaciones.

Formato: on <level>:NOTIFY:<commandos>
Ejemplos:

        on 1:NOTIFY:/msg $nick Hola nick, ya te veo venir!!! :)
        on 1:NOTIFY:/notice $me $nick se va del IRC *sniff* :-(


#- Eventos ON QUERYOPEN y ON QUERYCLOSE
Se producen respectivamente al abrirse una ventana de query.

Formato: on <level>:QUERYOPEN:<comandos>
Ejemplo:

        on 1:QUERYOPEN:/echo -s Abierto query con: $nick $address | / msg $nick Hola $nick


#- Evento ON QUIT
Se produce cuando un usuario que está en nuestro canal sale del IRC.

Formato: on <level>:QUIT:<commandos>
Ejemplos:

        on 1:QUIT:/notice $me $nick sale del IRC con el mensaje: $1- on 1:QUIT:/msg $chan Bye-Bye to $nick *sniff*


#- Evento ON SNOTICE
Se produce cuando recibimos una noticia del server.

Formato: on <level>:SNOTICE:<texto>:<commandos>
Ejemplo: on 1:SNOTICE:*client connecting*:/halt

Para una explicación del formato del texto, ver el evento on TEXT.

Ejemplo:

        on 1:SNOTICE:*split*:/splay hack.wav

Activa un fichero de sonido en caso de una noticia del server anunciando un split.


#- Evento ON TOPIC
Se produce cuando algún usuario cambia el tópico del canal.

Formato: on <level>:TOPIC:<#[,#]>:<comandos>
Ejemplo: on 1:TOPIC:#mIRC:/msg $chan Hmm, que tópico mas cutre!!!: $1-

La función $1- devuelve el texto completo del nuevo tópico.


#- Evento ON USERMODE
Se produce cuando cambiamos nuestros modos de usuario.

Formato: on <level>:USERMODE:<commandos>
Ejemplo: on 1:USERMODE:/echo nuevos modos: $1-


#- Evento ON WALLOPS
Se produce cuando recibimos un wallops message.

Formato: on <level>:WALLOPS:<texto>:<commandos>
Ejemplo: on 1:WALLOPS:*aviso*:/echo $nick mensaje de aviso a las: $time

Ver el evento on TEXT para una explicación de los posibles formatos del texto.


#- Eventos ON TOPIC
Se produce cuando algún usuario cambia el tópico del canal.

Formato: on <level>:TOPIC:<#[,#]>:<comandos>
Ejemplo: on 1:TOPIC:#mIRC:/msg $chan Hmm, que tópico mas cutre!!!: $1-

La función $1- devuelve el texto del nuevo tópico. 


                ----------------------( CuT HeRe )----------------------


        -#- CTCP -#-

        CTCP - Client To Client Protocol - podriamos decir que los CTCPs son
otro tipo distinto de eventos "especializados" en la comunicacion entre los
distintos usuarios conectados a un servidor de IRC.
Normalmente, usaremos los CTCP´s para hacer que el usuario haga/responda de
forma automatica alguna accion cuando reciba la informacion necesaria que
nosotros le hallamos enviado por CTCP.
Visto de esta forma parece algo dificil de entender; pongamos un ejemplo para
aclararlo:

Imaginaos que nosotros queremos saber cuanto LAG tiene el usuario de nick
'Pepe'. Para saber dicha "informacion" deberemos de enviarle un ctcp del tipo
'PING' y, de esta forma, el usuario 'Pepe' nos respondera con un 'Ping Reply'
donde obtendremos el tiempo de lag de dicho usuario.

La sintaxis del CTCP es de la forma: /ctcp <nick> <accion/mensaje>
Ejemplo: /ctcp Pepe ping

Tambien saber que podremos enviarle algun CTCP y no recibir respuesta
alguna... esto es que el script que utilice el usuario al que le hagamos el
CTCP que sea no tiene asignado un CTCP Reply (CTCP de respuesta) para ese
CTCP en concreto; por ejemplo:

        Nosotros enviamos un CTCP Ping al usuario Pepe:
                /ctcp Pepe ping
        Y su mIRC/Script nos respondera automaticamente un mensaje (CTCP
        Reply) con la informacion referida al CTCP Ping:
                [Pepe PING reply]: 2secs

En este caso SI que recibiremos respuesta por parte del usuario; pero si
realizamos algun CTCP que el usuario al que se lo hallamos hecho no tenga un
Reply para dicho CTCP, el usuario no nos respondera automaticamente.
Por ejemplo:

        Nosotros enviamos un CTCP hola al usuario Pepe:
                /ctcp Pepe hola
        Como el mIRC/Script de dicho usuario no tiene informacion asignada a
        dicho CTCP, no realizara ninguna accion ni mensaje...

Bien, con esto podriamos decir que mIRC en si trae por defecto asignados un
par de CTCP Replys para un par de CTCP´s. Estos son los siguientes:
- CTCP Ping - (Mensaje Reply: [Pepe PING reply]: 2secs)
- CTCP Finger - (Mensaje Reply: [Pepe FINGER reply]: <Mensaje> Idle 2799
                seconds)
- CTCP Version - (Mensaje Reply: [Pepe VERSION reply]: mIRC32 v5.7
                 K.Mardam-Bey)
- CTCP Time - (Mensaje Reply: [Pepe TIME reply]: Fri Feb 25 18:03:28 2000)

Si lo preferimos, tambien podemos modificar el tipo de "Mensaje Reply" para
que nos quede un poco mas vistoso.
Por ejemplo; el Mensaje Reply por defecto del CTCP Ping es:

        [Pepe PING reply]: 2secs

Bien, pues en vez de eso, podemos hacer que nos responda con otro tipo de
mensaje. Para ello, creamos un evento del tipo 'CTCPREPLY'.
Su sintaxis es la siguiente:

        on 1:CTCPREPLY:<ctcp>:{ comandos }

En <ctcp> pondremos el CTCP que queramos responder con nuestro Reply
personalizado... (Ping, version, Time...);
Ejemplo:

        on 1:CTCPREPLY:*PING*:{
          %lag = $ctime - $2  
          echo $nick tiene un LAG de: %lag Segundo(s)
          halt
        }

Aqui teneis un simple ejemplo de un PING Reply personalizado por nosotros.
%lag es una variable (las cuales las explicaremos mas adelante...) que, en
este caso, "recoge" la cantidad de lag que tiene el usuario a quien le
hayamos hecho un "/ctcp <usuario> ping"; la respuesta que recibiremos sera un
mensaje impreso en nuestro status diciendo lo siguiente:

        Pepe tiene un LAG de: 1 Segundo(s)

Donde 'Pepe' es $nick (es a quien le hemos hecho el CTCP Ping) y '1' son los
segundos que ha "registrado/recogido" la variable %lag sobre el usuario
'Pepe'

Una vez ya introducidos un poco en la sintaxis de los CTCP, aprenderemos a
realizar nuestros propios CTCP Replys para cualquier CTCP que queramos crear
para nuestro script.
Para empezar, veremos como son este tipo de eventos; su sintaxis es de la forma:

        ctcp <nivel>:<ctcp>:<#,?,*>:{ comandos }

Asi es la estructura general de cualquier CTCP Event; donde <nivel> es el
nivel de usuario que queramos que vaya dirijido el CTCP; <ctcp> es el CTCP
que queramos especificar para luego devolver el Reply; '#' se utiliza si nos
referimos a algun canal, '?' si es para un query, '*' si queremos que sea
para cualquier cosa...
Para verlo de una forma mas sencilla la estructuracion del CTCP Event,
pongamos un simple ejemplo:

        ctcp 1:*hola*:*:{
          /msg $nick Hola $nick - ¿Que tal? ;)
        }

Con este simple evento conseguiras que cuando alguien te envie un "/ctcp
<tu_nick> hola"; tu, automaticamente, le respondas al CTCP mediante el Reply
indicado; es decir, que le haras un /msg (mensaje/privado) a $nick (quien te
haya hecho el CTCP) diciendole: "Hola $nick - ¿Que tal? ;)"

Tambien podreis crear vuestros propios Reply´s a aquellos CTCP´s que mIRC
responde por defecto (es decir, los que ya comentamos anteriormente: ping,
version, finger, time).
Esto puede ser de utilidad si, por ejemplo, no quereis que nadie sepa vuestro
LAG cuando alguien os haga un "/ctcp <tu_nick> ping" o, si por otro lado,
quereis poner un 'Version reply' para vuestro script. (en vez del reply por
defecto de mIRC...)
Vamos un par de ejemplos:

        ctcp 1:PING:*:{
          /msg $nick Acceso denegado. Informacion no disponible...
          halt
        }

Este ejemplo es para el caso de que no quereis que nadie sepa vuestro LAG.
Cuando alguien os haga un "/ctcp <tu_nick> ping" vosotros le respondereis con
un mensaje diciendo "Acceso denegado. Informacion no disponible..." y luego
acabara la respuesta gracias al comando que hemos puesto "halt". (Como
vereis, gracias a 'halt' conseguimos no revelar nuestro LAG...)

        ctcp 1:VERSION:*:{
          .notice $nick Estoy usando '@_2500Hz mIRC-Script' v1.0 -
        }


        -#- RAW -#-

        Los numeros (tambien llamados codigos) RAW son quienes identifican
las diferentes respuestas que nos dara un servidor cuando estamos conectados
a el y le enviamos algun comando del mIRC (como por ejemplo /whois, /away,
/lusers...)
Pongamos el clasico ejemplo con el comando /whois "nick" ... Imaginaos que le
hacemos un /whois al nick 'nEuRoNaL' y no hay ningun usuario con ese nick; la
respuesta que recibiremos por parte del servidor sera:

        -
        nEuRoNaL No such nick/channel
        nEuRoNaL End of /WHOIS list
        -

Pues bien cada mensaje equivale a un numero RAW diferente... en este caso el
mensaje de 'nEuRoNaL No such nick/channel' equivale al numero RAW 401 y el
mensaje de 'nEuRoNaL End of /WHOIS list' equivale al numero RAW 318

Esto es basicamente los numeros RAW... y fundamentalmente se utilizan para
traducir los diferentes mensajes que responde el servidor al castellano,
tambien se le pueden poner colorines, negrita... todo lo que querais pudiendo
hacer un script con un buen diseño en todos sus aspectos x)

Bueno... sigamos con el ejemplo anterior; imaginaos que queremos traducir y
cambiar ese mensaje... para ello nos vamos a la parte de los remotes
(aconsejo crear un nuevo fichero con el nonmbre de raw.ini donde metais todos
los numeros RAW que querais para vuestro script, para que asi tengais mejor
organizado el codigo de vuestro script...) y escribimos lo siguiente:

        raw 401:*:echo -a - | echo -a <4 $parm2 1> no esta conectado al IRC... | halt
        raw 318:*:echo -a Final del Quien es: <4 $parm2 1> | echo -a - | halt

Como veis en las lineas anteriores... la sintaxis de los numeros RAW es:

        raw "numero":*:"comando" (el '*' equivale a un texto, lo normal es poner *, cualquiera)

Un detalle que cabe resaltar es como terminaos de definir el numero RAW: con
la orden 'halt' esto lo ponemos para que, despues de que imprima el mensaje
que le hayamos dicho, de por acabada la accion.

Poniendo las lineas anteriores en nuestros remotes obtendremos la siguiente
respuesta:

        -
        < nEuRoNaL > no esta conectado al IRC...
        Final del Quien es: < nEuRoNaL >
        -

Como vereis el mensaje ha cambiado, he incluso sale en color rojo y en
negrita el nick.

No hay que saber mucho mas de los numeros RAW, simplemente saber que todos
los mensajes equivalen cada uno a un numero RAW; como imaginareis la lista
puede ser inmensa con lo que si estas interesado en conocer todos los
numeros RAW te recomiendo que descargues de internet el  rfc 1459 : "Internet
Relay Chat Protocol". Este documento fue escrito en 1993 y aunque sea antiguo
nos sigue siendo muy util.
Lo podras encontrar en: http://members.es.tripod.de/anthrax/rfc1459.zip

Para finalizar con este tema os pondre una pequeña lista de los numeros RAW
mas comunes y utilizados; pero antes sigamos viendo un par de ejemplos mas:

Sigamos con el ejemplo de /whois "nick" esta vez veremos la respuesta que nos
da el servidor cuando dicho "nick" si esta conectado al servidor:

        nEuRonaL is 2500hz@195.53.66.56 * @_2500Hz - Underground Scene -
        nEuRonaL on @#@_2500Hz @#BLaCkCoDe #cyber_punk
        nEuRonaL using bigbang.irc-hispano.org Servidor irc de kaos-online
        End of /WHOIS list.

En el whois nos encontramos con cuatro lienas que equivalen a los numeros
RAW: 311 (RPL_WHOISUSER), 319 (RPL_WHOISCHANNELS), 312 (RPL_WHOISSERVER) y
318 (RPL_ENDOFWHOIS) respectivamente.

Bien pues una vez conocidos los numeros RAW para cada uno de los mensajes
podemos comenzar a personalizar la respuesta:

        raw 311:*:echo -a Quien es <4 $parm2 1> | echo -a . | echo -a Nombre: <4 $parm6* 1> | echo -a Direccion: <4 $parm3 $+ @ $+ $parm4 1> | halt
        raw 319:*:echo -a Canal(es) <4 $parm3* 1> | halt
        raw 312:*:echo -a Servidor <4 $parm3 - $parm4* 1> | halt
        raw 318:*:echo -a Final del Quien es: <4 $parm2 1> | echo -a - | halt

Con esto nuestro script nos mostrara la siguiente respuesta:

        Quien es < nEuRonaL >
        .
        Nombre: < @_2500Hz - Underground Scene - >
        Direccion: < blackcode@195.53.66.56 >
        Canal(es) < @#@_2500Hz @#BLaCkCoDe #cyber_punk >
        Servidor < bigbang.irc-hispano.org - Servidor irc de kaos-online >
        Final del Quien es: < nEuRonaL >

Si quereis ampliar la informacion del whois, por ejemplo si el usuario al que
le haces whois esta away, tambien puedes personalizar el mensaje añadiendo un
RAW mas a tu whois personalizado:

        raw 311:*:echo -a Quien es <4 $parm2 1> | echo -a . | echo -a Nombre: <4 $parm6* 1> | echo -a Direccion: <4 $parm3 $+ @ $+ $parm4 1> | halt
        raw 319:*:echo -a Canal(es) <4 $parm3* 1> | halt
        raw 312:*:echo -a Servidor <4 $parm3 - $parm4* 1> | halt
-->     raw 301:*:echo -a Esta Away, Razon: <4 $parm3* 1> | halt
        raw 318:*:echo -a Final del Quien es: <4 $parm2 1> | echo -a - | halt

Como veis, tenemos el whois del ejemplo anterior mas el numero RAW 301
(RPL_AWAY) que equivale al mensaje de Away; el mensaje que nos dara el script
si al usuario al que le haremos un whois esta away sera el siguiente:

        Quien es < nEuRonaL >
        .
        Nombre: < @_2500Hz - Underground Scene - >
        Direccion: < blackcode@195.53.66.56 >
        Canal(es) < @#@_2500Hz @#BLaCkCoDe #cyber_punk >
        Servidor < bigbang.irc-hispano.org - Servidor irc de kaos-online >
-->     Esta Away, Razon: < Estoy trabajando... >
        Final del Quien es: < nEuRonaL >

Como ultimo ejemplo veamos el comando /away; el mensaje que recibiremos a
ponernos away sera:

        You have been marked as being away

Para poder personalizar este mensaje tendremos que conocer con que numero RAW
se identifica; ese el el 306 (RPL_NOWAWAY) con que no nos queda mas que hacer
el mensaje:

        raw 306:*: { echo -a Ahora estas <4 Away 1> | halt }

Con esto conseguiremos cambiar el mensaje a:

        Ahora estas < Away >

Cuando volvemos a ejecutar el comando /away para quitarnos del estado de away
nos aparece por defecto el mensaje:

        You are no longer marked as being away

Este mensaje equivale al numero RAW 305 (RPL_UNAWAY) y para personalizarlo ya
sabeis que hacer no? ;):

        raw 305:* { echo -a Estado de  Away <4 Finalizado 1> | halt  }

Con esto conseguimos cambiar el mensaje a:

        Estado de Away < Finalizado >

Bueno y podriamos estar asi un laaaargo tiempo... como veis, el unico secreto
de los numeros RAW es saber que numeracion corresponde con cada mensaje.

A continuacion os remito una lista de algunos de los numeros RAW mas comunes
y utilizados; esta pequeña lista la he sacado del documento sobre numeros RAW
escrito por HOWE para #Scripting (http://www.lanzadera.com/canalscripting):

BIENVENIDA SERVIDOR
001     Respuesta Bienvenida Servidor - "Wellcome to..."
002     Respuesta Bienvenida Host - "Tu host es..."
003     Respuesta Bienvenida Fecha - "this server was created..."
004     Respuesta Bienvenida


AWAY
301     Respuesta Away - "Nick esta away - <motivo>"
305     Respuesta Away - "Dejas de estar Away"
306     Respuesta Away - "A partir de ahora estas Away"


WHOIS
311     Respuesta User
        $parm2 ---> nick
        $parm3 ---> user ident
        $parm4 ---> host
        $parm6 ---> Nombre "Real" (1ª palabra)
        $parm7 ---> Nombre "Real" (2ª palabra)
        etc...

312     Respuesta Servidor
        $parm3 ---> Su servidor IRC

313   Respuesta IRCop
        $parms por defecto: "<nick> :is an IRC operator"

317   Respuesta idle
        $parm3 Tiempo de idle
        $parm4 Tiempo de Conexion al server

401     Respuesta Whois - "NO SUCK NICK..."
        Indica ke el nick no se encuentra

318     Fin del Whois  END OF WHOIS

319   Canales en los ke esta el individuo
        $parm3 ---> primer canal
        $parm4 ---> segundo canal
        etc... (usa $parm3* para englobarlos todos)


WHOWAS
314     Respuesta Whowas
        $parm2 ---> Nick
        $parm3 ---> User Ident
        $parm4 ---> Host
        $parm6* --> Nombre "Real"

369     Respuesta Fin del Whowas


WHO
352     Respuesta del who
        $parm3 ---> User Ident
        $parm4 ---> Host
        $parm6 ---> Nick

315     Fin del Who


TOPIC
331     El canal .. no tiene ningun topic
        $parm2 ---> Canal

332   El topic del canal .. es ..
        $parm2 ---> Canal
        $parm3* --> Topic

333     Kien y cuando se puso el topic
        $parm3 ---> Kien lo puso
        $parm4 ---> Cuando lo puso


OTROS
351     Version del servidor
        $parm4
        $parm2

421     El comando no existe
        $parm2 ---> comando erroneo ejecutado

481     No eres IRCop

482     No eres OP

474     No puedes pasar al canal porke estas baneado
        $parm2 ---> canal donde te pusieron el ban

Por ultimo te recomiendo que para tener mas informacion sobre los numeros RAW
descarges el siguiente fichero:

	http://www.ayuda-irc.net/downloads/rawhelp.zip

Este archivo zip contiene dos archivos:
* numeric.hlp: Se trata del "Jeepster's numeric reference"; es una completa
referencia de los numeros RAW. Incluye una completa lista en formato .help
para Windows y alguna informacion mas de interes. (Esta en ingles.)
* rawtool.ini: No es mas que un fichero de script realizado por SomaTic, con
la idea de que cada vez que se introduzca un comando dirigido al server,
informase de cual es el numero raw de cada una de las lineas que recibia, el
nombre de esta (solo a titulo informativo), y el mensaje estandar que la
acompañaba.


-#- 03.3.3 Variables. -#-
-- - -- - -- - -- - -- --

        Se accede pinchando en "Tools" y luego en "Remote" (si lo prefieres,
aprieta "Alt+R") y luego pulsando sobre la solapa "Variables".
Las variables no son mas que una forma de almacenamiento de valores (datos)
temporal; podriamos decir que una variable es un area de almacenamiento en
donde podemos almacenar un valor cualquiera para que, posteriormente, podamos
utilizar dicha variable en alguna o varias rutinas, de este modo, no sera
necesario alterar la/as rutina/as cada vez que queramos modificar el valor
que queremos utilizar, sino que unicamente tendremos que asignarle el nuevo
valor deseado a dicha variable.
Las variables se representan con el signo '%' precedido de un nombre
cualquiera (p.ejemplo: %pepito)

Para comprender mejor que es y para que se usan las variables, pongamos un
pequeño ejemplo:
Imaginaos que creamos una variable llamada '%dat.name' y le asignamos el
valor 'Carlos' (es decir que quedaria de esta forma: %dat.name Carlos)
Entonces nos vamos a las Aliases (recordad: Alt+A) y creamos la siguiente
rutina:

        /nombre /echo -s Hola! mi nombre es %dat.name ¿Que tal?

Con esto conseguimos que cuando nosotros ejecutemos el alias: /nombre el mIRC
imprima en el Status el mensaje de: Hola! mi nombre es Carlos ¿Que tal? (Como
veis, mIRC a interpretado la variable %dat.name por su valor asignado
'Carlos')
Si quisieramos que dijera Pepe en vez de Carlos, no tendriamos mas que
modificar el valor de la variable %dat.name asignandole el nuevo valor
deseado Pepe

Bien, pues una vez explicado el sencillo manejo de las variables en mIRC,
vamos a explicar como controlarlas mediante sus sencillas ordenes:

        * set: Su sintaxis es: /set <%variable> [valor]
Con esta orden podremos crear/establecer variables con sus correspondientes
valores deseados. Ejemplo:

        /datos {
          set %dat.name Carlos
          set %dat.age 19
          set %dat.pais España
          echo Hola, me llamo %dat.name tengo %dat.age años y soy de %dat.pais
        }

Teniendo esta rutina en el aliases, lo que hacemos es que al ejecutar el
alias /datos, mIRC establezca automaticamente en la parte de variables las
variables %dat.name, %dat.age, %dat.pais con sus correspondientes datos e
imprima en pantalla el mensaje: Hola, me llamo Carlos tengo 19 años y soy de
España

        * unset: Su sintaxis es /unset <%variable>
Con esta orden borraremos la variable que especifiquemos de la lista de
variables. Ejemplo:

        /datos {
          set %dat.name Carlos
          set %dat.age 19
          set %dat.pais España
          echo Hola, me llamo %dat.name tengo %dat.age años y soy de %dat.pais
          unset %dat.name
          unset %dat.age
          unset %dat.pais
        }

Con esta rutina conseguimos la misma accion del ejemplo anterior pero esta
vez, al final de la rutina especificamos que mIRC borre las variables
%dat.name, %dat.age, %dat.pais.

Si por otra parte no quieres escribir tanto codigo y deseas borrar todas
aquellas variables que empiecen de la misma manera (como en los anteriores
ejemplos: %DAT.name, %DAT.age, %DAT.pais...) puedes hacerlo borrandolas todas
de un golpe. Esto lo conseguimos con el comodin '*'
Ejemplo:

        /datos {
          set %dat.name Carlos
          set %dat.age 19
          set %dat.pais España
          echo Hola, me llamo %dat.name tengo %dat.age años y soy de %dat.pais
          unset %dat.*
        }

        * unsetall: Esta orden no tiene sintaxis alguna.
Con esta orden borraremos todas las variables que tengamos establecidas en la
parte de vaiables de mIRC.
Ejemplo:

        /variables.NO {
          unsetall
          echo -s Lista de variables vacia.
        }

        * inc: Su sintaxis es /inc <%variable> [valor]
Con esta orden incrementaremos (aumentaremos) el valor de la variable que
hayamos especificado.
Ejemplo:

        /up {
          set %num 10
          set %num2 20
          inc %num %num2
          echo -a El numero resultante es: %num
        }

En este ejemplo establecemos las variables %num y %num2 con valores 10 y 20
luego, con la orden inc, añadimos el valor de la variable %num2 al valor de
la variable %num y finalmente mIRC imprimira en la ventana activa el mensaje:
El numero resultante es: 30 (donde 30 es el resultado de añadir el valor 20
de %num2 al valor 10 de %num --> 10+20=30)

        * dec: Su sintaxis es /dec <%variable> [valor]
Con esta orden decrementaremos (disminuiremos) el valor de la variable que
hayamos especificado. Ejemplo:

        /down {
          set %num 10
          set %num2 20
          dec %num %num2
          echo -a El numero resultante es: %num
        }

Este ejemplo es identico al anterior, solo que en vez de añadir el valor 20
de la variable %num2 al valor 10 de la variable %num, se la resta quedando el
valor -10 (10-20=-10) finalizando con el mensaje: El numero resultante es:
-10


-#- 04.  Estructuras "IF-Else" -#-
- -- - -- - -- - -- - -- - -- - --

        He decidido explicar este tipo de estructura apartandola fuera de las
secciones aliases, popups, remotes; ya que se puede poner en cualquier
parte...
Las estrcuturas IF-Else son aquellas que plantean una o varias condicion/nes;
es decir, que unicamente se ejecutara uno o varios comandos si se cumple o no
la condicion fijada...

Su sintaxis entera es de la forma:

        if (v1 operador v2) {comandos}
        elseif (v1 operador v2) {comandos}
        else {comandos}


La orden IF hace que 'v1' se compare con 'v2' mediante algun operador (ya los
daremos mas adelante) y, a raiz de esta comparacion, ejecutara los comandos
que se le indiquen o, por el contrario interpretara la orden else efectuando
los comandos que se le indiquen... Ejemplo:

        /sonido.start {
          if (%Sonidos == On) { .splay inicio.wav }
          else { halt }
        }

Con este ejemplo queda bastante claro para que sirven estas utiles
estructuras...
En este ejemplo al ejecutar /sonido.start el script interpreta la condicion
de que Si la variable '%Sonidos' tiene asignado el valor 'On', que ejecute el
sonido 'inicio.wav'; pero por el contrario, si el valor asignado a la
variable '%Sonidos' es otro distinto de 'On', que ejecute el comando halt...

Los operadores que podremos utilizar para realizar comparaciones son:
==              : Igual que
===             : No igual que (caso-seensible)
!=              : No igual que
<               : Menor que
>               : Mayor que
>=              : Mayor o igual que
<=              : Menor o igual que
//              : Es un multiplo de
\\              : No es multiplo de
&               : Es una comparacion

isin            : Cadena v1 esta en la cadena v2
isincs          : Cadena v1 esta en la cadena v2 (caso sensible)
iswm            : Comodin de la cadena v1 contiene la cadena v2
isnum           : v1 es numero en el rango de v2 en la forma n1-n2
                  (v2 opcional)
isletter        : Letra v1 es una letra en la lista de letras de v2
                  (v2 opcional)

ison            : Nick v1 esta en canal v2
isop            : Nick v1 es un op en canal v2
isvo            : Nick v1 tiene voz en canal v2
ishelp          : Nick v1 es un helper en canal v2

isreg           : Nick v1 es un nick normal en canal v2
ischan          : Si v1 es un canal en que estas.

isauto          : Si v1 es usuario en tu lista auto-op del canal v2
                  (v2 optional)
isignore        : Si v1 esta en la lista ignore con el parametro v2
                  (v2 opcional)
isprotect       : Si v1 es usuario en tu lista protect para el canal v2
                  (v2 opcional)
isnotify        : Si v1 es usuario en tu lista notify.

Estos son todos los operadores... si queremos negar algun operador deberemos
anteponer al operador que queramos negar el simbolo ! . Ejemplo:

        /sonido.start {
          if (%Sonidos !== On) { .splay inicio.wav }
        }

Este ejemplo es igual que el anterior pero totalmente diferente, ya que esta
vez se ejecutara el sonido inicio.wav si la variable '%Sonidos' NO tiene
asignado el valor 'On'

Tambien puedes combinar varias comparaciones en una misma condicion utilizando
los operadores:

&&              : AND (En castellano Y)
||              : OR (En castellano O)

Ejemplos:

        /sonido.start {
          if (%Sonidos !== On) && (%inicio == On) { .splay inicio.wav }
        }

Como vereis en este sencillo ejemplo... unicamente se ejecutara el sonido
'inicio.wav' si se cumple que la variable '%Sonidos' tenga asignado el valor
'On' Y que la variable %inicio tenga asignado el valor 'On'. (EXIGE que se
cumplan las dos condiciones!)

        /sonido.start {
          if (%Sonidos == On) || (%inicio == On) { .splay inicio.wav }
        }

Este otro ejemplo es tambien muy simple y claro... Interpreta que si la
variable '%Sonidos' tiene asignado el valor 'On' O si la variable '%inicio'
tiene asignado el valor 'On' que ejecute el sonido 'inicio.wav' (Este no
exige que se cumplan las dos condiciones, sino que da la opcion de que se
cumpla la una o la otra...)

Para acabar con la explicacion de estrcturas IF-Else vamos a explicar la
orden 'goto' el cual es un recurso muy util y utilizado...
Su sintaxis es: goto "etiqueta"

Por si no lo sabeis 'goto' en castellano significa 'ir a' con lo que podemos
decir que esta orden se utiliza dentro de una orden IF cuando queremos "dar
un salto" de forma automatica a otra instruccion de la orden IF... este salto
es la llamada 'etiqueta' la cual se identifica con el simbolo : delante.
Ejemplo:

        /sonido.start {
          if (%Sonidos !== On) goto restaurar
          :restaurar
          set %Sonidos On
          if (%Sonidos == On) { .splay inicio.wav }
        }


-#- 05.  Consejos y recomendaciones. -#-
- -- - -- - -- - -- - -- - -- - -- -

        En esta parte del documento vamos a comentar algun que otro consejillo
para que tengais en cuenta a la hora de hacer y distribuir vustros scripts...

-#- Primer Consejo: Estructuracion de archivos y directorios del script:
        Os aconsejo que cuando os pongais a diseñar un script, antes de
poneros a escribir codigo, os penseis una estructura de los archivos y
directorios del script...

Para vuestros archivos de aliases, popups y remotes podeis crear diversos
archivos y directorios para dividirlos...
        Por ejemplo, podeis crear un directorio llamado 'Sistema' y en el
creais tres directorios mas llamados 'Alias', 'Popups', 'Remotes' para que en
cada directorio metais los correspondientes archivos de alias, popups y
remotes...
Tambien estaria bien tener divididos en diferentes archivos los remotes,
teniendo los eventos en un archivo llamado events.ini; los ctcp´s en un
archivo llamado ctcp.ini; los numeros RAW en un archivo llamado raw.ini; etc.

Para las utilidades externas del script (como nukes, scanners... es decir
programas independientes) podeis crear otro directorio llamado 'utils'
Para los archivos que te envien por DCC otro directorio llamdado 'Incoming'
Para los logs un directorio llamdado 'Logs'
etc... asi con toda la estructura del script...

De esta forma tendras muy bien organizado cualquier archivo del script y
quedara mucho mas presentable...

-#- Segundo Consejo: Testeando nuestro script sin conectar a inernet:
        Ya que, por el momento, no todos los usuarios de internet podemos
disponer de una tarifa plana que nos sea asequible y rentable (Ejem, EJEM!
tome nota de esto Sr.Villalonga :P), tenemos que buscar diferentes
alternativas para poder probar aquellas rutinas que hayamos hecho a nuestro
script y que requieran estar conectado a un servidor de IRC...
Una posible y muy buena solucion es montar tu propio servidor de IRC para
que, de este modo, puedas conectarte de forma local a dicho server IRC...

Existen multiples servidores de IRC para cualquier plataforma... yo te
aconsejo dos de ellos:
        - WircSrv: Este es el que mas me gusta... ya que es muy sencillo de
          utilizar; practicamente solo tendras que instalarlo en el sistema y
          ejecutarlo. En principio no requiere ninguna configuracion por tu
          parte, ya que el mismo programa trae configurado el localhost por
          defecto (127.0.0.1) y el puerto 6667... Con lo que unicamente
          deberas ejecutar WircSrv y luego conectar al servidor 127.0.0.1 por
          el puerto 6667

          Puedes bajarlo de: http://www.wircsrv.com/

        - Conference Room: Este otro programa tambien esta muy bien... aunque
          probablemente, si tienes montada una red local (LAN) puedas tener
          algun que otro problema a la hora de hacer funcionar el servidor
          (Yo tuve que configurarle un par de cosillas para que fuera
          correctamente en mi red local...)

          Puedes bajarlo de: http://www.webmaster.com/products/conferenceroom/

Existen otros muchos servidores pero estos dos son los que recomiendo para
utilizarlos en plataformas Windows...
Realmente os podreis montar un excelente y seguro servidor de IRC para
vuestros experimentos y, si quereis llegar aun mas lejos con el tema del
servidor IRC, podreis llegar a montar de forma muy simple y sencilla
servicios de IRC fuera y dentro de vuestras redes locales x)

-#- Tercer Consejo: Publicando nuestros scripts:
        A la hora de hacer publicos nuestros scripts es muy importante que
todo este listo y a punto... A continuacion os propongo un par de consejos a
la hora de depurar, empaquetar, distribuir nuestro script:

        * Una vez tengas acabado tu script, deberas de "depurarlo" es decir,
tendras que revisar todo el codigo para poder eliminar aquellas lineas que
guarden informacion sensible sobre ti, como puedan ser passwords, datos
personales...
Tambien habras de revisar los archivos del script para asi eliminar los logs,
archivos inutiles, los archivos que hayan en el directorio 'Incoming', los
archivos generados por el script como son url.ini... etc...

Ten especial cuidado y consideracion sobre las variables que, normalmente,
guardan passwords y datos que no deseas que se sepan...

        * Una vez hayas "depurado" minuciosamente tu script, deberas de
empaquetarlo en un unico archivo comprimido y deberas de hacer que ocupe lo
menos posible para que, de este modo, los usuarios que decidan descargar tu
script tarden lo menos posible...
Para el tema del espacio... te recomiendo que utilices pocos (solo los
necesarios) archivos de sonido (*.wav, *.mid...), imagenes (*.bmp), archivos
ejecutables, como nukes, scanners, flooders, mail bombers.... (es decir...
los *.exe)
Si cargas mucho el script con este tipo de ficheros... al final el tamaño de
tu script sera muy elevado, te aconsejo que no superes las 5 megas de script.

Una vez hayas cuidado el tamaño del script y hayas reducido un poco su tamaño
(si acaso era necesario) deberas de escanearlo de virus para asegurar que el
script que distribuyes esta libre de cualquier virus.. Esto es muy importante
ya que a nadie le agrada descargar de la red un script y al ejecutarlo
infectarse con algun virus... (Tambien te aconsejo que cuando bajes algo de
internet le pases un antivirus actuializado... y si alguien que no conoces te
envia algun archivo ejecutable no te fies y, por si las moscas, no lo
ejecutes... 'mas vale prevenir que curar' x)

Para la compresion del script aconsejo que utiliceis Winzip para crear un
fichero zip y, posteriormente, utilicies el WinZip Self Extractor para crear
un archivo ejecuitable.
De este modo lograreis empaquetar el script con la mejor calidad y, ya que el
archivo es un ejecutable, los usuarios no tendran porque tener algun
descompresor para archivos zip... x)

        * Finalmente tendras que poner el script al alcance de todo el mundo.
Para ello recomiendo crear una pagina web atractiva y que vaya acorde con el
diseño del script...
No digo que hagais una web con miles de imagenes y muy pesada... sino que
hagais una pagina que tenga un par de imagenes y una buena estructura con un
par de secciones; asi como seccion de descarga del script, seccion de
caracteristicas del script, seccion de FAQ del script, una buena
presentacion...

Una vez tengais hecha una pagina web donde albergar vuestro script, debereis
de hacer una buena "Campaña de Publicidad".
Para hacer publicidad del script os aconsejo lo siguiente:
        * Tener un par de amigos que vayan difundiendo el script... y que
          vayan atrayendo a posibles usuarios...
        * Incluir tu script en todas aquellas webs donde se puedan descargar
          scripts (es decir, webs como 100Scripts, Ayuda-Irc, Xcalibre...)
          para ello envia mails a los correspondientes webmasters
          comunicandoles el nombre y version de vuestro script, version del
          mirc, autor, web del script... y por su puesto de una forma educada
          (Nada de exigire a nadie nada x)
        * Utilizar las redes de IRC para profanar el script... Para ello
          utiliza los topics, mensajes globales, mensajes de bienvenida, de
          despedida; haz propaganda del script en canales con un elevado
          numero de usuarios (#sexo, #amor, #mas-de*, ...), entra en diversas
          redes y haz propaganda en todas ellas... (Cuidado... una cosa es
          hacer propaganda del script y otra muy distinta es acosar a los
          usuarios! Te aconsejo que seas un poco pesado, pero no te repitas
          mucho o, de lo contrario, seras expulsado del canal donde te hayas
          excedido...)


-#- 06.  Despedida. -#-
- -- - -- - -- - -- - -

        Y aqui concluyo este pequeño, aunque intenso, tutorial sobre
scripting... Ya sabeis que si teneis alguna duda me la podeis hacer saber
comunicandomela via mail, o, si lo preferis, via IRC (suelo estar en el IRC
Hispano con mi nick nEuRoNaL en canales como #@_2500Hz, #blackcode,
#cyber_punk, #hacker_novatos, #mundomovil.... por supuesto un saludo a todos
ellos! x)

Os aconsejo que si quereis aprender mas y mejor este tipo de "programacion",
os bajeis mas documentos y referencias sobre el tema...
Aqui os pongo varias direcciones de algunas webs que tienen relacion con el
tema:
    - http://www.ayuda-irc.net
    - http://100scripts.islaweb.com/
    - http://www.mirces.com
    - http://fly.to/ayuda_scripting

Espero que os haya gustado esta introduccion al maravilloso mundo del mIRC
Scripting y que, por lo menos, sepais entender la basica estructuracion y
sencilla manipulacion de uno de los clientes de IRC, para plataformas
Windows, mas populares y usados en todo el planeta!
(- Lastima que no existan versiones de mIRC para Linux :( (Todavia... ;) -)

Por ultimo agradecer a gente como SomaTic, al equipo de #Ayuda-IRC, a los
chicos de #100scripts, ... por realizar tan excelente trabajo con el cual me
he basado y me ha servido de referencia para realizar de forma completa este
tutorial...

                                              Un saludo y hasta la proxima :)

--  nEuRoNaL  -- - -- - -- - -- - -- - -- - -- @_2500Hz - Underground Scene -
- -- - -- - -- - -- - -- - -- - -- - -- - -- - -- - -- - -- - -- - -- - -- --