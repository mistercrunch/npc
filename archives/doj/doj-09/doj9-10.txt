pooooopooooooooooppoooooopoopooooooooooooppooooooooopooooooopoooooooppoooooopoop
p           Discordant Opposition Journal - Issue 9 - December 2000            o
p                               File 10 of 15                                  o
poooooooopoooooooooooopoooopooooooopoooooopooooooooooooopooooooppooooooopoooooop

useful unix tidbits

intro type thing
~~~~~~~~~~~~~~~~

just thought some of you out there might be interested to have this for a
referance (lord knows the linux newbies will find this real handy). it's not
really to do with hacking. it's just a list of the common commands you might
use on a linux machine to do all the things you don't know how to do, and
are too embarrased to ask. 

so here goes.

how do i tell how much disk space a file/directory takes up?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

this can be done easy in gnome file manager or midnight commander or
something, so we're assuming that you don't have access to either of these.
but it's still easy. the du command (it doesn't take a rocket scientist to
figure out what they stand for) is used expressly for this purpose.

du by default shows the ammount in blocks, not kilobytes. to fix this, we
use the -h ("human readable") switch. for example:


fwaggle@sugarbaby$ du -h
 57K    .
fwaggle@sugarbaby$

simple eh?

can i change from one user to another, without logging in again?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

you sure can.... the su command (set user), allows you to take on another
user's login name, privilidges, etc - with or without modifying your
environment, depending on your choice.

for example, su root changes you to the root user. you have to enter the
correct password of course (we can't just have users changing to other
user's ids now can we?). on some unix/linux implementations (freebsd notably),
you must be a member of a certain group (often called "wheel") to be able
to su to root.

how can i tell what programs are running?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

this one's a no brainer, and almost everyone knows this.. however, there are
some people who don't, and therefore they are afraid to ask. so here goes.

the ps command lists processes. in it's default mode, it shows processes
which have a controlling terminal, and are your processes. for example:

fwaggle@sugarbaby$ ps
  PID  TT  STAT      TIME COMMAND
15509  p1  S      0:00.35 su (bash)
15719  p1  R+     0:00.00 ps

to show processes without a controlling terminal (background processes), we
use the x flag. like so:

fwaggle@sugarbaby$ ps x
  PID  TT  STAT      TIME COMMAND
15406  p0  Ss+    0:00.89 tail -f /var/log/ppp.log
15412  p1  Ss     0:00.45 -bash (bash)
15729  p1  R+     0:00.00 ps x

note, ps shows you all processes with your user id. this means that
processes from other logins will also show up. now, we can also see processes
and how much cpu and ram they are using. this is done with the u flag. as
shown here:

fwaggle@sugarbaby$ ps u
USER      PID %CPU %MEM   VSZ  RSS  TT  STAT STARTED      TIME COMMAND
fwaggle   261  0.0  0.0  1636    0  v0  IWs  -         0:00.00 -bash (bash)
fwaggle 15739  0.0  0.4   420  208  p1  R+    1:24PM   0:00.01 ps u

this can be used to identify run away processes (90% cpu usage is a telltale
sign of a runaway process), and kill them before your sysadmin catches you.

how do i kill a process that is running away, or i don't want any more?:

oh come on.. this really is a no-brainer. the kill command is used for this.
you must know the process id for the process you want to kill (us the ps command,
as shown above). then we simply issue:

kill <pid>

a TERM signal is sent to the process, asking that it terminates. some processes,
however, don't like to be killed.

how do i kill a process that won't listen to the TERM signal?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

it's time to get down and dirty. we have to issue the KILL signal to the
process. the difference between the two? it's like a little kid. say this
little kid is running around, screaming and squealing. you ask him nicely to
stop. that is a TERM signal. sometimes he will, sometimes he won't. 

if he won't, you stand up, put a gun to his head and say SIT DOWN AND SHUT THE
FUCK UP OR I'LL CREATE ABSTRACT ART ON THE WALL WITH YOUR FUCKING HEAD. that,
my friends, is a KILL signal. it basically doesn't ask the process nicely to
finish, it tells it to.

we do that like this:

kill -9 <pid>

there are whole bunch of other signals which we can send to processes. one
more is detailed below, but the rest can be found in man kill. (that means
type man kill into your console)

how do i restart a process without killing it?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

some processes die anyway with this (notably, ppp), but usually the HangUP
(or HUP) signal will cause a process to restart or rehash in some way. we
can do this like this:

kill -hup <pid>

again with the kill command?!? what's up with that? basically, kill is badly
named.. it's not used always to kill a process, it simply sends signals to it.
so in my humble opinion, it's badly named. but i'm not the one who invented
it am i? oh well.

how do i buffer something, to keep a more steady output?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

the most common context this question gets asked in, is with people asking
about CD-R recording on linux. i use freebsd, and have found the team utility
incredibly useful. search for it on freshmeat. it takes input via a pipe, and
buffers it, passing it steadily to the output. for example:

cat cd.img | team 100k 8 | ./yourcdwriterproggoeshere

pretty simple, and especially useful if you're copying off a slow or busy
device, such as your root hard disk, or a cd-rom drive.

can i watch a file to see if it gets modified?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

you sure can. the tail program is useful for this. for example, tail -f takes the last few lines of a file, and prints it to stdout. it then watches the file for any data which is appended to the end of the file, and prints that out on stdout as well.

this is useful for log files, however a file that gets saved in a text editor gets erased and started again (as opposed to text being appended to it). to watch files such as these, use tail -F. this may or may not help you ;)

the end
~~~~~~~

well that's about all i have time for right now. hope someone found something
useful here. have fun kids.

fwaggle
