<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="Author" CONTENT="The Electron">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.05 [en] (Win95; I) [Netscape]">
   <TITLE>Trojans</TITLE>
</HEAD>
<BODY TEXT="#33FF33" BGCOLOR="#FFFFFF" LINK="#33FF33" VLINK="#00CC00" ALINK="#FF0000" BACKGROUND="olive_wisps.jpg">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Trojans

<P>Trojans are one of the more insidious devices used to circumvent Internet
security: the
<BR>trojan horse, or trojan. No other device is more likely to lead to
total compromise of a system, and
<BR>no other device is more difficult to detect.

<P>What Is a Trojan?

<P>Before I start, I want to offer a definition of what a trojan is because
these devices are often
<BR>confused with other malicious code. A trojan horse is

<P>&nbsp;&nbsp;&nbsp;&nbsp; An unauthorized program contained within a
legitimate program. This unauthorized program
<BR>&nbsp;&nbsp;&nbsp;&nbsp; performs functions unknown (and probably unwanted)
by the user.

<P>&nbsp;&nbsp;&nbsp;&nbsp; A legitimate program that has been altered
by the placement of unauthorized code within it;
<BR>&nbsp;&nbsp;&nbsp;&nbsp; this code performs functions unknown (and
probably unwanted) by the user.

<P>&nbsp;&nbsp;&nbsp;&nbsp; Any program that appears to perform a desirable
and necessary function but that (because of
<BR>&nbsp;&nbsp;&nbsp;&nbsp; unauthorized code within it that is unknown
to the user) performs functions unknown (and
<BR>&nbsp;&nbsp;&nbsp;&nbsp; probably unwanted) by the user.

<P>The unauthorized functions that the trojan performs may sometimes qualify
it as another type of
<BR>malicious device as well. For example, certain viruses fit into this
category. Such a virus can be
<BR>concealed within an otherwise useful program. When this occurs, the
program can be correctly
<BR>referred to as both a trojan and a virus. The file that harbors such
a trojan/virus has effectively been
<BR>trojaned. Thus, the term trojan is sometimes used as a verb, as in
"He is about to trojan that file."

<P>Classic Internet security documents define the term in various ways.
Perhaps the most well known
<BR>(and oddly, the most liberal) is the definition given in RFC 1244,
the Site Security Handbook:

<P>&nbsp;&nbsp;&nbsp;&nbsp; A trojan horse program can be a program that
does something useful, or merely something
<BR>&nbsp;&nbsp;&nbsp;&nbsp; interesting. It always does something unexpected,
like steal passwords or copy files without
<BR>&nbsp;&nbsp;&nbsp;&nbsp; your knowledge.

<P>Another definition that seems quite suitable is that given by Dr. Alan
Solomon, an internationally
<BR>renowned virus specialist, in his work titled All About Viruses:

<P>&nbsp;&nbsp;&nbsp;&nbsp; A trojan is a program that does something more
than the user was expecting, and that extra
<BR>&nbsp;&nbsp;&nbsp;&nbsp; function is damaging. This leads to a problem
in detecting trojans. Suppose I wrote a program
<BR>&nbsp;&nbsp;&nbsp;&nbsp; that could infallibly detect whether another
program formatted the hard disk. Then, can it say
<BR>&nbsp;&nbsp;&nbsp;&nbsp; that this program is a trojan? Obviously not
if the other program was supposed to format the
<BR>&nbsp;&nbsp;&nbsp;&nbsp; hard disk (like Format does, for example),
then it is not a trojan. But if the user was not
<BR>&nbsp;&nbsp;&nbsp;&nbsp; expecting the format, then it is a trojan.
The problem is to compare what the program does
<BR>&nbsp;&nbsp;&nbsp;&nbsp; with the user's expectations. You cannot determine
the user's expectations for a program.
<BR>&nbsp;

<P>&nbsp;&nbsp;&nbsp;&nbsp; Cross Reference: All About Viruses by Dr. Alan
Solomon can be found at
<BR>&nbsp;&nbsp;&nbsp;&nbsp; http://www.drsolomon.com/vircen/allabout.html.

<P>&nbsp;&nbsp;&nbsp;&nbsp; Anyone concerned with viruses (or who just
wants to know more about virus
<BR>&nbsp;&nbsp;&nbsp;&nbsp; technology) should visit Dr. Solomon's site
at http://www.drsolomon.com/.
<BR>&nbsp;

<P>At day's end, you can classify a trojan as this: any program that performs
a hidden and unwanted
<BR>function. This may come in any form. It might be a utility that purports
to index file directories or one
<BR>that unlocks registration codes on software. It might be a word processor
or a network utility. In
<BR>short, a trojan could be anything (and could be found in anything)
that you or your users introduce to
<BR>the system.

<P>Where Do Trojans Come From?

<P>Trojans are created strictly by programmers. One does not get a trojan
through any means other
<BR>than by accepting a trojaned file that was prepared by a programmer.
True, it might be possible for a
<BR>thousand monkeys typing 24 hours a day to ultimately create a trojan,
but the statistical probability of
<BR>this is negligible. Thus, a trojan begins with human intent or mens
rea. Somewhere on this planet, a
<BR>programmer is creating a trojan right now. That programmer knows exactly
what he or she is doing,
<BR>and his or her intentions are malefic (or at least, not altruistic).

<P>The trojan author has an agenda. That agenda could be almost anything,
but in the context of Internet
<BR>security, a trojan will do one of two things:

<P>&nbsp;&nbsp;&nbsp;&nbsp; Perform some function that either reveals to
the programmer vital and privileged information
<BR>&nbsp;&nbsp;&nbsp;&nbsp; about a system or compromises that system.

<P>&nbsp;&nbsp;&nbsp;&nbsp; Conceal some function that either reveals to
the programmer vital and privileged information
<BR>&nbsp;&nbsp;&nbsp;&nbsp; about a system or compromises that system.

<P>Some trojans do both. Additionally, there is another class of trojan
that causes damage to the target
<BR>(for example, one that encrypts or reformats your hard disk drive).
So trojans may perform various
<BR>intelligence tasks (penetrative or collective) or tasks that amount
to sabotage.

<P>One example that satisfies the sabotage-tool criteria is the PC CYBORG
trojan horse. As explained
<BR>in a December 19, 1989 CIAC bulletin ("Information about the PC CYBORG
(AIDS) Trojan
<BR>Horse"):

<P>&nbsp;&nbsp;&nbsp;&nbsp; There recently has been considerable attention
in the news media about a new trojan horse
<BR>&nbsp;&nbsp;&nbsp;&nbsp; which advertises that it provides information
on the AIDS virus to users of IBM PC
<BR>&nbsp;&nbsp;&nbsp;&nbsp; computers and PC clones. Once it enters a
system, the trojan horse replaces AUTOEXEC.BAT,
<BR>&nbsp;&nbsp;&nbsp;&nbsp; and may count the number of times the infected
system has booted until a criterion number
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (90) is reached. At this point PC CYBORG hides
directories, and scrambles (encrypts) the
<BR>&nbsp;&nbsp;&nbsp;&nbsp; names of all files on drive C:. There exists
more than one version of this trojan horse, and at
<BR>&nbsp;&nbsp;&nbsp;&nbsp; least one version does not wait to damage
drive C:, but will hide directories and scramble file
<BR>&nbsp;&nbsp;&nbsp;&nbsp; names on the first boot after the trojan horse
is installed.
<BR>&nbsp;

<P>&nbsp;&nbsp;&nbsp;&nbsp; Cross Reference: You can find the CIAC bulletin
"Information about the PC
<BR>&nbsp;&nbsp;&nbsp;&nbsp; CYBORG (AIDS) Trojan Horse" at
<BR>&nbsp;&nbsp;&nbsp;&nbsp; http://www.sevenlocks.com/CIACA-10.htm.
<BR>&nbsp;

<P>Another example (one that caused fairly widespread havoc) is the AOLGOLD
trojan horse. This
<BR>was distributed primarily over the Usenet network and through e-mail.
The program was purported
<BR>to be an enhanced package for accessing America Online (AOL). The distribution
consisted of a
<BR>single, archived file. Unzipping the archive revealed two files, one
of which was a standard
<BR>INSTALL.BAT file. Executing the INSTALL.BAT file resulted in 18 files
being expanded to the hard
<BR>disk. As reported in a security advisory ("Information on the AOLGOLD
Trojan Program") dated
<BR>Sunday, February 16, 1997:

<P>&nbsp;&nbsp;&nbsp;&nbsp; The trojan program is started by running the
INSTALL.BAT file. The INSTALL.BAT file
<BR>&nbsp;&nbsp;&nbsp;&nbsp; is a simple batch file that renames the VIDEO.DRV
file to VIRUS.BAT and then runs it.
<BR>&nbsp;&nbsp;&nbsp;&nbsp; VIDEO.DRV is an amateurish DOS batch file
that starts deleting the contents of several
<BR>&nbsp;&nbsp;&nbsp;&nbsp; critical directories on your C: drive, including

<P>&nbsp;&nbsp;&nbsp;&nbsp; c:\
<BR>&nbsp;&nbsp;&nbsp;&nbsp; c:\dos
<BR>&nbsp;&nbsp;&nbsp;&nbsp; c:\windows
<BR>&nbsp;&nbsp;&nbsp;&nbsp; c:\windows\system
<BR>&nbsp;&nbsp;&nbsp;&nbsp; c:\qemm
<BR>&nbsp;&nbsp;&nbsp;&nbsp; c:\stacker
<BR>&nbsp;&nbsp;&nbsp;&nbsp; c:\norton

<P>&nbsp;&nbsp;&nbsp;&nbsp; When the batch file completes, it prints a
crude message on the screen and attempts to run a
<BR>&nbsp;&nbsp;&nbsp;&nbsp; program named DOOMDAY.EXE. Bugs in the batch
file prevent the DOOMDAY.EXE program
<BR>&nbsp;&nbsp;&nbsp;&nbsp; from running. Other bugs in the file cause
it to delete itself if it is run from any drive but the C:
<BR>&nbsp;&nbsp;&nbsp;&nbsp; drive. The programming style and bugs in the
batch file indicates that the trojan writer appears
<BR>&nbsp;&nbsp;&nbsp;&nbsp; to have little programming experience.
<BR>&nbsp;

<P>&nbsp;&nbsp;&nbsp;&nbsp; Cross Reference: You can find the security
advisory titled "Information on the
<BR>&nbsp;&nbsp;&nbsp;&nbsp; AOLGOLD Trojan Program" at http://www.emergency.com/aolgold.htm.
<BR>&nbsp;

<P>These trojans were clearly the work of amateur programmers: kids who
had no more complex an
<BR>agenda than causing trouble. These were both destructive trojans and
performed no sophisticated
<BR>collective or penetrative functions. Such trojans are often seen, and
usually surface, on the Usenet
<BR>news network.

<P>However, trojans (at least in the UNIX world) have been planted by individuals
that are also
<BR>involved in the legitimate development of a system. These are inside
jobs, where someone at a
<BR>development firm inserts the unauthorized code into an application
or utility (or, in rare instances, the
<BR>core of the operating system itself). These can be far more dangerous
for a number of reasons:

<P>&nbsp;&nbsp;&nbsp;&nbsp; These trojans are not destructive (they collect
intelligence on systems); their discovery is
<BR>&nbsp;&nbsp;&nbsp;&nbsp; usually delayed until they are revealed by
accident.

<P>&nbsp;&nbsp;&nbsp;&nbsp; Because most servers that matter run UNIX,
some highly trusted (and sensitive) sites can be
<BR>&nbsp;&nbsp;&nbsp;&nbsp; compromised. By servers that matter, I mean
those that provide hundreds or even thousands
<BR>&nbsp;&nbsp;&nbsp;&nbsp; of users access to the Internet and other
key networks within the Internet. These are generally
<BR>&nbsp;&nbsp;&nbsp;&nbsp; governmental or educational sites, which differ
from sites maintained, for example, by a single
<BR>&nbsp;&nbsp;&nbsp;&nbsp; company. With a single company, the damage
can generally travel only so far, placing the
<BR>&nbsp;&nbsp;&nbsp;&nbsp; company and all its users at risk. This is
a serious issue, to be sure, but is relevant only to that
<BR>&nbsp;&nbsp;&nbsp;&nbsp; company. In contrast, the compromise of government
or educational sites can place
<BR>&nbsp;&nbsp;&nbsp;&nbsp; thousands of computers at risk.

<P>There are also instances where key UNIX utilities are compromised (and
trojaned) by programmers
<BR>who have nothing to do with the development of the legitimate program.
This has happened many
<BR>times and, on more than one occasion, has involved security-related
programs. For example,
<BR>following the release of SATAN, a trojan found its way into the SATAN
1.0 distribution for Linux.
<BR>&nbsp;

<P>&nbsp;&nbsp;&nbsp;&nbsp; NOTE: This distribution was not the work of
Farmer or Venema. Instead, it was a
<BR>&nbsp;&nbsp;&nbsp;&nbsp; precompiled set of binaries intended solely
for Linux users, compiled at Temple
<BR>&nbsp;&nbsp;&nbsp;&nbsp; University. Moreover, the trojan was confined
to a single release, that being 1.0.
<BR>&nbsp;

<P>Reportedly, the file affected was a program called fping. The story
goes as follows: A programmer
<BR>obtained physical access to a machine housing the program. He modified
the main() function and
<BR>altered the fping file so that when users ran SATAN, a special entry
would be placed in their
<BR>/etc/passwd file. This special entry was the addition of a user named
suser. Through this user ID,
<BR>the perpetrator hoped to compromise many hosts. As it happened, only
two recorded instances of
<BR>such compromise emerged. Flatly stated, the programming was of poor
quality. For example, the
<BR>trojan provided no contingency for those systems that made use of shadowed
passwords.
<BR>&nbsp;

<P>&nbsp;&nbsp;&nbsp;&nbsp; NOTE: The slackware distribution of Linux defaults
to a nonshadowed password
<BR>&nbsp;&nbsp;&nbsp;&nbsp; scheme. This may be true of other Linux distributions
as well. However, the
<BR>&nbsp;&nbsp;&nbsp;&nbsp; programmer responsible for the trojan in question
should not have counted on that. It
<BR>&nbsp;&nbsp;&nbsp;&nbsp; would have been only slightly more complicated
to add a provision for this.
<BR>&nbsp;

<P>As you can see, a trojan might crop up anywhere. Even a file originating
from a reasonably trusted
<BR>source could be trojaned.

<P>Where Might One Find a Trojan?

<P>Technically, a trojan could appear almost anywhere, on any operating
system or platform. However,
<BR>with the exception of the inside job mentioned previously, the spread
of trojans works very much
<BR>like the spread of viruses. Software downloaded from the Internet,
especially shareware or
<BR>freeware, is always suspect. Similarly, materials downloaded from underground
servers or Usenet
<BR>newsgroups are also candidates.

<P>Sometimes, one need not travel down such dark and forbidden alleys to
find a trojan. Trojans can
<BR>be found in major, network-wide distributions. For example, examine
this excerpt from a CIAC
<BR>security advisory ("E-14: Wuarchive Ftpd Trojan Horse"), posted to
the Net in 1994:

<P>&nbsp;&nbsp;&nbsp;&nbsp; CIAC has received information that some copies
of the wuarchive FTP daemon (ftpd)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; versions 2.2 and 2.1f have been modified at
the source code level to contain a trojan horse.
<BR>&nbsp;&nbsp;&nbsp;&nbsp; This trojan allows any user, local or remote,
to become root on the affected UNIX system.
<BR>&nbsp;&nbsp;&nbsp;&nbsp; CIAC strongly recommends that all sites running
these or older versions of the wuarchive ftpd
<BR>&nbsp;&nbsp;&nbsp;&nbsp; retrieve and install version 2.3. It is possible
that versions previous to 2.2 and 2.1f contain the
<BR>&nbsp;&nbsp;&nbsp;&nbsp; trojan as well.

<P>wftpd is one of the most widely used FTP servers in the world. This
advisory affected thousands of
<BR>sites, public and private. Many of those sites are still at risk, primarily
because the system
<BR>administrators at those locations are not as security conscious as
they should be.
<BR>&nbsp;

<P>&nbsp;&nbsp;&nbsp;&nbsp; TIP: Pick 100 random hosts in the void and
try their FTP servers. I would wager that
<BR>&nbsp;&nbsp;&nbsp;&nbsp; out of those hosts, more than 80% are using
wftpd. In addition, another 40% of those
<BR>&nbsp;&nbsp;&nbsp;&nbsp; are probably using older versions that, although
they may not be trojaned, have security
<BR>&nbsp;&nbsp;&nbsp;&nbsp; flaws of some kind.
<BR>&nbsp;

<P>C'mon! How Often Are Trojans Really Discovered?

<P>Trojans are discovered often enough that they are a major security concern.
What makes trojans so
<BR>insidious is that even after they are discovered, their influence is
still felt. Trojans are similar to sniffers
<BR>in that respect. No one can be sure exactly how deep into the system
the compromise may have
<BR>reached. There are several reasons for this, but I will limit this
section to only one.

<P>As you will soon read, the majority of trojans are nested within compiled
binaries. That is to say: The
<BR>code that houses the trojan is no longer in human-readable form but
has been compiled. Thus, it is in
<BR>machine language. This language can be examined in certain raw editors,
but even then, only
<BR>printable character strings are usually comprehensible. These most
often are error messages,
<BR>advisories, option flags, or other data printed to STDOUT at specified
points within the program:

<P>my_function()
<BR>{
<BR>cout &lt;&lt; "The value you have entered is out of range!\n";
<BR>cout &lt;&lt; "Please enter another:"
<BR>}

<P>Because the binaries are compiled, they come to the user as (more or
less) point-and-shoot
<BR>applications. In other words, the user takes the file or files as is,
without intimate knowledge of their
<BR>structure.

<P>When authorities discover that such a binary houses a trojan, security
advisories are immediately
<BR>issued. These tend to be preliminary and are later followed by more
comprehensive advisories that
<BR>may briefly discuss the agenda and method of operation of the trojan
code. Unless the user is a
<BR>programmer, these advisories spell out little more than "Get the patch
now and replace the bogus
<BR>binary." Experienced system administrators may clearly understand the
meaning of such advisories
<BR>(or even clearly understand the purpose of the code, which is usually
included with the
<BR>comprehensive advisory). However, even then, assessment of damages
can be difficult.

<P>In some cases, the damage seems simple enough to assess (for example,
instances where the trojan's
<BR>purpose was to mail out the contents of the passwd file). The fix is
pretty straightforward: Replace
<BR>the binary with a clean version and have all users change their passwords.
This being the whole of
<BR>the trojan's function, no further damage or compromise is expected.
Simple.

<P>But suppose the trojan is more complex. Suppose, for example, that its
purpose is to open a hole for
<BR>the intruder, a hole through which he gains root access during the
wee hours. If the intruder was
<BR>careful to alter the logs, there might be no way of knowing the depth
of the compromise (especially if
<BR>you discover the trojan months after it was installed). This type of
case might call for reinstallation of
<BR>the entire operating system.
<BR>&nbsp;

<P>&nbsp;&nbsp;&nbsp;&nbsp; NOTE: Reinstallation may be a requisite. Many
more of your files might have been
<BR>&nbsp;&nbsp;&nbsp;&nbsp; trojaned since the initial compromise. Rather
than attempt to examine each file (or each
<BR>&nbsp;&nbsp;&nbsp;&nbsp; file's behavior) closely, it might make better
sense to start over. Equally, even if more
<BR>&nbsp;&nbsp;&nbsp;&nbsp; files haven't been trojaned, it's likely that
passwords, personal data, or other sensitive
<BR>&nbsp;&nbsp;&nbsp;&nbsp; materials have been compromised.
<BR>&nbsp;

<P>Conversely, trojans may be found in executable files that are not compiled.
These might be shell
<BR>scripts, or perhaps programs written in Perl, JavaScript, VBScript,
Tcl (a popular scripting
<BR>language), and so forth. There have been few verified cases of this
type of trojan. The cracker who
<BR>places a trojan within a noncompiled executable is risking a great
deal. The source is in plain,
<BR>human-readable text. In a small program, a block of trojan code would
stand out dramatically.
<BR>However, this method may not be so ludicrous when dealing with larger
programs or in those
<BR>programs that incorporate a series of compiled binaries and executable
shell scripts nested within
<BR>several subdirectories. The more complex the structure of the distribution,
the less likely it is that a
<BR>human being, using normal methods of investigation, would uncover a
trojan.

<P>Moreover, one must consider the level of the user's knowledge. Users
who know little about their
<BR>operating system are less likely to venture deep into the directory
structure of a given distribution,
<BR>looking for mysterious or suspicious code (even if that code is human
readable). The reverse is true if
<BR>the user happens to be a programmer. However, the fact that a user
is a programmer does not mean
<BR>he or she will instantly recognize a trojan. I know many BASIC programmers
who have a difficult
<BR>time reading code written in Perl. Thus, if the trojan exists in a
scripting language, the programmer
<BR>must first be familiar with that language before he or she can identify
objectionable code within it. It is
<BR>equally true that if the language even slightly resembles a language
that the programmer normally
<BR>uses, he or she may be able to identify the problem. For example, Perl
is sufficiently similar to C that
<BR>a C programmer who has never written a line of Perl could effectively
identify malicious code within
<BR>a Perl script. And of course, anyone who writes programs in a shell
language or awk would likewise
<BR>recognize questionable code in a Perl program.
<BR>&nbsp;

<P>&nbsp;&nbsp;&nbsp;&nbsp; NOTE: Many Perl programs (or other scripted
shell programs) are dynamic; that is,
<BR>&nbsp;&nbsp;&nbsp;&nbsp; they may change according to certain circumstances.
For example, consider a program
<BR>&nbsp;&nbsp;&nbsp;&nbsp; that, in effect, rewrites itself based on
certain conditions specified in the programming
<BR>&nbsp;&nbsp;&nbsp;&nbsp; code. Such files need to be checked by hand
for tampering because integrity checkers
<BR>&nbsp;&nbsp;&nbsp;&nbsp; will always report that the file has been
attacked, even when it has not. Granted, today,
<BR>&nbsp;&nbsp;&nbsp;&nbsp; there are relatively few dynamic programs,
but that is about to change. There is talk on
<BR>&nbsp;&nbsp;&nbsp;&nbsp; the Internet of using languages like Perl
to perform functions in Electronic Data
<BR>&nbsp;&nbsp;&nbsp;&nbsp; Interchange (EDI). In some instances, these
files will perform functions that necessarily
<BR>&nbsp;&nbsp;&nbsp;&nbsp; require the program file to change.
<BR>&nbsp;

<P>What Level of Risk Do Trojans Represent?

<P>Trojans represent a very high level of risk, mainly for reasons already
stated:

<P>&nbsp;&nbsp;&nbsp;&nbsp; Trojans are difficult to detect.

<P>&nbsp;&nbsp;&nbsp;&nbsp; In most cases, trojans are found in binaries,
which remain largely in non-human-readable
<BR>&nbsp;&nbsp;&nbsp;&nbsp; form.

<P>&nbsp;&nbsp;&nbsp;&nbsp; Trojans can affect many machines.

<P>Let me elaborate. Trojans are a perfect example of the type of attack
that is fatal to the system
<BR>administrator who has only a very fleeting knowledge of security. In
such a climate, a trojan can lead
<BR>to total compromise of the system. The trojan may be in place for weeks
or even months before it is
<BR>discovered. In that time, a cracker with root privileges could alter
the entire system to suit his or her
<BR>needs. Thus, even when the trojan is discovered, new holes may exist
of which the system
<BR>administrator is completely unaware.

<P>How Does One Detect a Trojan?

<P>Detecting trojans is less difficult than it initially seems. But strong
knowledge of your operating
<BR>system is needed; also, some knowledge of encryption can help.

<P>If your environment is such that sensitive data resides on your server
(which is never a good idea),
<BR>you will want to take advanced measures. Conversely, if no such information
exists on your server,
<BR>you might feel comfortable employing less stringent methods. The choice
breaks down to need, time,
<BR>and interest. The first two of these elements represent cost. Time
always costs money, and that cost
<BR>will rise depending on how long it has been since your operating system
was installed. This is so
<BR>because in that length of time, many applications that complicate the
reconciliation process have
<BR>probably been installed. For example, consider updates and upgrades.
Sometimes, libraries (or DLL
<BR>files) are altered or overwritten with newer versions. If you were
using a file-integrity checker, these
<BR>files would be identified as changed. If you were not the person who
performed the upgrade or
<BR>update, and the program is sufficiently obscure, you might end up chasing
a phantom trojan. These
<BR>situations are rare, true, but they do occur.

<P>Most forms of protection against (and prevention of) trojans are based
on a technique sometimes
<BR>referred to as object reconciliation. Although the term might sound
intimidating, it isn't. It is a fancy
<BR>way of asking "Are things still just the way I left them?" Here is
how it works: Objects are either files
<BR>or directories. Reconciliation is the process of comparing those objects
against themselves at some
<BR>earlier (or later) date. For example, take a backup tape and compare
the file PS as it existed in
<BR>November 1995 to the PS that now resides on your drive. If the two
differ, and no change has been
<BR>made to the operating system, something is amiss. This technique is
invariably applied to system files
<BR>that are installed as part of the basic operating system.

<P>Object reconciliation can be easy understood if you recognize that for
each time a file is altered in
<BR>some way, that file's values change. For example, one way to clock
the change in a file is by
<BR>examining the date it was last modified. Each time the file is opened,
altered, and saved, a new
<BR>last-modified date emerges. However, this date can be easily manipulated.
Consider manipulating
<BR>this time on the PC platform. How difficult is it? Change the global
time setting, apply the desired
<BR>edits, and archive the file. The time is now changed. For this reason,
time is the least reliable way to
<BR>reconcile an object (at least, relying on the simple date-last-modified
time is unreliable). Also, the last
<BR>date of modification reveals nothing if the file was unaltered (for
example, if it was only copied or
<BR>mailed).
<BR>&nbsp;

<P>&nbsp;&nbsp;&nbsp;&nbsp; NOTE: PC users who have used older machines
can easily understand this.
<BR>&nbsp;&nbsp;&nbsp;&nbsp; Sometimes, when the CMOS battery fails, the
system may temporarily fail. When it is
<BR>&nbsp;&nbsp;&nbsp;&nbsp; brought back up, you will see that a few files
have the date January 1, 1980.
<BR>&nbsp;

<P>Another way to check the integrity of a file is by examining its size.
However, this method is
<BR>extremely unreliable because of how easily this value can be manipulated.
When editing plain text
<BR>files, it is simple to start out with a size of, say, 1,024KB and end
up with that same size. It takes
<BR>cutting a bit here and adding a bit there. But the situation changes
radically when you want to alter a
<BR>binary file. Binary files usually involve the inclusion of special
function libraries and other modules
<BR>without which the program will not work. Thus, to alter a binary file
(and still have the program
<BR>function) is a more complicated process. The programmer must preserve
all the indispensable parts
<BR>of the program and still find room for his or her own code. Therefore,
size is probably a slightly more
<BR>reliable index than time. Briefly, before I continue, let me explain
the process by which a file
<BR>becomes trojaned.

<P>The most common scenario is when a semi-trusted (known) file is the
object of the attack. That is,
<BR>the file is native to your operating system distribution; it comes
from the vendor (such as the file csh
<BR>in UNIX or command.com in DOS). These files are written to your drive
on the first install, and they
<BR>have a date and time on them. They also are of a specified size. If
the times, dates, or sizes of these
<BR>files differ from their original values, this raises immediate suspicion.

<P>Evil programmers know this. Their job, therefore, is to carefully examine
the source code for the file
<BR>(usually obtained elsewhere) for items that can be excluded (for example,
they may single out
<BR>commented text or some other, not-so-essential element of the file).
The unauthorized code is written
<BR>into the source, and the file is recompiled. The cracker then examines
the size of the file. Perhaps it is
<BR>too large or too small. The process then begins again, until the attacker
has compiled a file that is as
<BR>close to the original size as possible. This is a time-consuming process.
If the binary is a fairly large
<BR>one, it could take several days.
<BR>&nbsp;

<P>&nbsp;&nbsp;&nbsp;&nbsp; NOTE: When an original operating-system distributed
file is the target, the attacker
<BR>&nbsp;&nbsp;&nbsp;&nbsp; may or may not have to go through this process.
If the file has not yet been distributed
<BR>&nbsp;&nbsp;&nbsp;&nbsp; to anyone, the attacker need not concern himself
or herself with this problem. This is
<BR>&nbsp;&nbsp;&nbsp;&nbsp; because no one has yet seen the file or its
size. Perhaps only the original author of the
<BR>&nbsp;&nbsp;&nbsp;&nbsp; file would know that something was amiss.
If that original author is not security
<BR>&nbsp;&nbsp;&nbsp;&nbsp; conscious, he or she might not even know.
If you are a programmer, think now about
<BR>&nbsp;&nbsp;&nbsp;&nbsp; the very last binary you compiled. How big
was it? What was its file size? I bet you
<BR>&nbsp;&nbsp;&nbsp;&nbsp; don't remember.
<BR>&nbsp;

<P>When the file has been altered, it is placed where others can obtain
it. In the case of
<BR>operating-system distributions, this is generally a central site for
download (such as
<BR>sunsite.unc.edu, which houses one of the largest collection of UNIX
software on the planet).
<BR>From there, the file finds its way into workstations across the void.
<BR>&nbsp;

<P>&nbsp;&nbsp;&nbsp;&nbsp; NOTE: sunsite.unc.edu is the Sun Microsystems-sponsored
site at UNC Chapel
<BR>&nbsp;&nbsp;&nbsp;&nbsp; Hill. This site houses the greater body of
free software on the Internet. Thousands of
<BR>&nbsp;&nbsp;&nbsp;&nbsp; individuals--including me--rely on the high-quality
UNIX software available at this
<BR>&nbsp;&nbsp;&nbsp;&nbsp; location. Not enough good can be said about
this site. It is a tremendous public service.
<BR>&nbsp;

<P>For reasons that must now seem obvious, the size of the file is also
a poor index by which to
<BR>measure its alteration. So, to recount: Date, date of last access,
time, and size are all indexes without
<BR>real meaning. None of these alone is suitable for determining the integrity
of a file. In each, there is
<BR>some flaw--usually inherent to the platform--that makes these values
easy to alter. Thus, generating a
<BR>massive database of all files and their respective values (time, size,
date, or alteration) has only very
<BR>limited value:

<P>&nbsp;&nbsp;&nbsp;&nbsp; ...a checklist is one form of this database
for a UNIX system. The file content themselves are
<BR>&nbsp;&nbsp;&nbsp;&nbsp; not usually saved as this would require too
much disk space. Instead, a checklist would
<BR>&nbsp;&nbsp;&nbsp;&nbsp; contain a set of values generated from the
original file--usually including the length, time of last
<BR>&nbsp;&nbsp;&nbsp;&nbsp; modification, and owner. The checklist is
periodically regenerated and compared against the
<BR>&nbsp;&nbsp;&nbsp;&nbsp; save copies, with discrepancies noted. However...changes
may be made to the contents of
<BR>&nbsp;&nbsp;&nbsp;&nbsp; UNIX files without any of these values changing
from the stored values; in particular, a user
<BR>&nbsp;&nbsp;&nbsp;&nbsp; gaining access to the root account may modify
the raw disk to alter the saved data without it
<BR>&nbsp;&nbsp;&nbsp;&nbsp; showing in the checklist.

<P>There are other indexes, such as checksums, that one can check; these
are far better indexes, but
<BR>also not entirely reliable. In the checksum system, the data elements
of a file are added together and
<BR>run through an algorithm. The resulting number is a checksum, a type
of signature for that file
<BR>(bar-code readers sometimes use checksums in their scan process). On
the SunOS platform, one
<BR>can review the checksum of a particular file using the utility sum.
sum calculates (and prints to
<BR>STDOUT or other specified mediums) the checksums of files provided
on the argument line.

<P>Although checksums are more reliable than time, date, or last date of
modification, these too can be
<BR>tampered with. Most system administrators suggest that if you rely
on a checksum system, your
<BR>checksum list should be kept on a separate server or even a separate
medium, accessible only by
<BR>root and other trusted users. In any event, checksums work nicely for
checking the integrity of a file
<BR>transferred, for example, from point A to point B, but that is the
extent of it.
<BR>&nbsp;

<P>&nbsp;&nbsp;&nbsp;&nbsp; NOTE: Users who have performed direct file
transfers using communication packages
<BR>&nbsp;&nbsp;&nbsp;&nbsp; such as Qmodem, Telix, Closeup, MTEZ, or others
will remember that these programs
<BR>&nbsp;&nbsp;&nbsp;&nbsp; sometimes perform checksum or CRC checks as
the transfers occur. For each file
<BR>&nbsp;&nbsp;&nbsp;&nbsp; transferred, the file is checked for integrity.
This reduces--but does not eliminate--the
<BR>&nbsp;&nbsp;&nbsp;&nbsp; likelihood of a damaged file at the destination.
If the file proves to be damaged or
<BR>&nbsp;&nbsp;&nbsp;&nbsp; flawed, the transfer process may begin again.
When dealing with sophisticated attacks
<BR>&nbsp;&nbsp;&nbsp;&nbsp; against file integrity, however, this technique
is insufficient.
<BR>&nbsp;
<BR>&nbsp;

<P>&nbsp;&nbsp;&nbsp;&nbsp; Cross Reference: Tutorials about defeating
checksum systems are scattered across
<BR>&nbsp;&nbsp;&nbsp;&nbsp; the Internet. Most are related to the development
of viruses (many virus-checking
<BR>&nbsp;&nbsp;&nbsp;&nbsp; utilities use checksum analysis to identify
virus activity). A collection of such papers (all
<BR>&nbsp;&nbsp;&nbsp;&nbsp; of which are underground) can be found at
<BR>&nbsp;&nbsp;&nbsp;&nbsp; http://www.pipo.com/guillermito/darkweb/news.html.
<BR>&nbsp;

<P>MD5

<P>You're probably wondering whether any technique is sufficient. I am
happy to report that there is
<BR>such a technique. It involves calculating the digital fingerprint,
or signature, for each file. This is
<BR>done utilizing various algorithms. A family of algorithms, called the
MD series, is used for this
<BR>purpose. One of the most popular implementations is a system called
MD5.

<P>MD5 is a utility that can generate a digital signature of a file. MD5
belongs to a family of one-way
<BR>hash functions called message digest algorithms. The MD5 system is
defined in RFC 1321.
<BR>Concisely stated:

<P>&nbsp;&nbsp;&nbsp;&nbsp; The algorithm takes as input a message of arbitrary
length and produces as output a 128-bit
<BR>&nbsp;&nbsp;&nbsp;&nbsp; "fingerprint" or "message digest" of the input.
It is conjectured that it is computationally
<BR>&nbsp;&nbsp;&nbsp;&nbsp; infeasible to produce two messages having
the same message digest, or to produce any
<BR>&nbsp;&nbsp;&nbsp;&nbsp; message having a given prespecified target
message digest. The MD5 algorithm is intended for
<BR>&nbsp;&nbsp;&nbsp;&nbsp; digital signature applications, where a large
file must be "compressed" in a secure manner
<BR>&nbsp;&nbsp;&nbsp;&nbsp; before being encrypted with a private (secret)
key under a public-key cryptosystem such as
<BR>&nbsp;&nbsp;&nbsp;&nbsp; RSA.
<BR>&nbsp;

<P>&nbsp;&nbsp;&nbsp;&nbsp; Cross Reference: RFC 1321 is located at
<BR>&nbsp;&nbsp;&nbsp;&nbsp; http://www.freesoft.org/Connected/RFC/1321/1.html.
<BR>&nbsp;

<P>When one runs a file through an MD5 implementation, the signature emerges
as a 32-character
<BR>value. It looks like this:

<P>2d50b2bffb537cc4e637dd1f07a187f4

<P>Many sites that distribute security fixes for the UNIX operating system
employ this technique. Thus,
<BR>as you browse their directories, you can examine the original digital
signature of each file. If, upon
<BR>downloading that file, you find that the signature is different, there
is a 99.9% chance that something
<BR>is terribly amiss.

<P>MD5 performs a one-way hash function. You may be familiar with these
operations from other
<BR>forms of encryption, including those used to encrypt password files.

<P>Some very extreme security programs use MD4 and MD5 algorithms. One
such program is S/Key,
<BR>which is a registered trademark of Bell Laboratories. S/Key implements
a one-time password
<BR>scheme. One-time passwords are nearly unbreakable. S/Key is used primarily
for remote logins and
<BR>to offer advanced security along those channels of communication (as
opposed to using little or no
<BR>security by initiating a normal, garden-variety Telnet or Rlogin session).
The process works as
<BR>described in "S/Key Overview" (author unknown):

<P>&nbsp;&nbsp;&nbsp;&nbsp; S/Key uses either MD4 or MD5 (one-way hashing
algorithms developed by Ron Rivest) to
<BR>&nbsp;&nbsp;&nbsp;&nbsp; implement a one-time password scheme. In this
system, passwords are sent cleartext over the
<BR>&nbsp;&nbsp;&nbsp;&nbsp; network; however, after a password has been
used, it is no longer useful to the eavesdropper.
<BR>&nbsp;&nbsp;&nbsp;&nbsp; The biggest advantage of S/Key is that it
protects against eavesdroppers without modification
<BR>&nbsp;&nbsp;&nbsp;&nbsp; of client software and only marginal inconvenience
to the users.
<BR>&nbsp;

<P>&nbsp;&nbsp;&nbsp;&nbsp; Cross Reference: Read "S/Key Overview" at
<BR>&nbsp;&nbsp;&nbsp;&nbsp; http://medg.lcs.mit.edu/people/wwinston/skey-overview.html.
<BR>&nbsp;

<P>With or without MD5, object reconciliation is a complex process. True,
on a single workstation with
<BR>limited resources, one could technically reconcile each file and directory
by hand (I would not
<BR>recommend this if you want to preserve your sanity). However, in larger
networked environments,
<BR>this is simply impossible. So, various utilities have been designed
to cope with this problem. The
<BR>most celebrated of these is a product aptly named TripWire.

<P>TripWire

<P>TripWire (written in 1992) is a comprehensive system-integrity tool.
It is written in classic Kernhigan
<BR>and Ritchie C (you will remember from Chapter 7, "Birth of a Network:
The Internet," that I
<BR>discussed the portability advantages of C; it was this portability
that influenced the choice of language
<BR>for the authors of TripWire).

<P>TripWire is well designed, easily understood, and implemented with minimal
difficulty. The system
<BR>reads your environment from a configuration file. That file contains
all filemasks (the types of files that
<BR>you want to monitor). This system can be quite incisive. For example,
you can specify what changes
<BR>can be made to files of a given class without TripWire reporting the
change (or, for more wholesale
<BR>monitoring of the system, you can simply flag a directory as the target
of the monitoring process).
<BR>The original values (digital signatures) for these files are kept within
a database file. That database file
<BR>(simple ASCII) is accessed whenever a signature needs to be calculated.
Hash functions included in
<BR>the distribution are

<P>&nbsp;&nbsp;&nbsp;&nbsp; MD5
<BR>&nbsp;&nbsp;&nbsp;&nbsp; MD4
<BR>&nbsp;&nbsp;&nbsp;&nbsp; CRC32
<BR>&nbsp;&nbsp;&nbsp;&nbsp; MD2
<BR>&nbsp;&nbsp;&nbsp;&nbsp; Snefru (Xerox secure hash function)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; SHA (The NIST secure hash algorithm)

<P>It is reported that by default, MD5 and the Xerox secure hash function
are both used to generate
<BR>values for all files. However, TripWire documentation suggests that
all of these functions can be
<BR>applied to any, a portion of, or all files.

<P>Altogether, TripWire is a very well-crafted package with many options.
<BR>&nbsp;

<P>&nbsp;&nbsp;&nbsp;&nbsp; Cross Reference: TripWire (and papers on usage
and design) can be found at
<BR>&nbsp;&nbsp;&nbsp;&nbsp; ftp://coast.cs.purdue.edu/pub/tools/unix/TripWire/.
<BR>&nbsp;

<P>TripWire is a magnificent tool, but there are some security issues.
One such issue relates to the
<BR>database of values that is generated and maintained. Essentially, it
breaks down to the same issue
<BR>discussed earlier: Databases can be altered by a cracker. Therefore,
it is recommended that some
<BR>measure be undertaken to secure that database. From the beginning,
the tool's authors were well
<BR>aware of this:

<P>&nbsp;&nbsp;&nbsp;&nbsp; The database used by the integrity checker
should be protected from unauthorized
<BR>&nbsp;&nbsp;&nbsp;&nbsp; modifications; an intruder who can change
the database can subvert the entire integrity
<BR>&nbsp;&nbsp;&nbsp;&nbsp; checking scheme.
<BR>&nbsp;

<P>&nbsp;&nbsp;&nbsp;&nbsp; Cross Reference: Before you use TripWire, read
"The Design and Implementation of
<BR>&nbsp;&nbsp;&nbsp;&nbsp; TripWire: A File System Integrity Checker"
by Gene H. Kim and Eugene H. Spafford.
<BR>&nbsp;&nbsp;&nbsp;&nbsp; It is located at
<BR>&nbsp;&nbsp;&nbsp;&nbsp; ftp://ftp.cs.purdue.edu/pub/spaf/security/Tripwire.PS.Z.
<BR>&nbsp;

<P>One method of protecting the database is extremely sound: Store the
database on read-only media.
<BR>This virtually eliminates any possibility of tampering. In fact, this
technique is becoming a strong trend
<BR>in security. In Chapter 21, "Plan 9 from Bell Labs," you will learn
that the folks at Bell Labs now run
<BR>their logs to one-time write or read-only media. Moreover, in a recent
security consult, I was
<BR>surprised to find that the clients (who were only just learning about
security) were very keen on
<BR>read-only media for their Web-based databases. These databases were
quite sensitive and the
<BR>information, if changed, could be potentially threatening to the security
of other systems.

<P>Kim and Spafford (authors of TripWire) also suggest that the database
be protected in this manner,
<BR>though they concede that this could present some practical, procedural
problems. Much depends
<BR>upon how often the database will be updated, how large it is, and so
forth. Certainly, if you are
<BR>implementing TripWire on a wide scale (and in its maximum application),
the maintenance of a
<BR>read-only database could be formidable. Again, this breaks down to
the level of risk and the need
<BR>for increased or perhaps optimum security.

<P>TAMU

<P>The TAMU suite (from Texas A&amp;M University, of course) is a collection
of tools that will greatly
<BR>enhance the security of a UNIX box. These tools were created in response
to a very real problem.
<BR>As explained in the summary that accompanies the distribution:

<P>&nbsp;&nbsp;&nbsp;&nbsp; Texas A&amp;M University UNIX computers recently
came under extensive attack from a
<BR>&nbsp;&nbsp;&nbsp;&nbsp; coordinated group of Internet crackers. This
paper presents an overview of the problem and
<BR>&nbsp;&nbsp;&nbsp;&nbsp; our responses, which included the development
of policies, procedures, and sdoels to protect
<BR>&nbsp;&nbsp;&nbsp;&nbsp; university computers. The tools developed
include `drawbridge', an advanced Internet filter
<BR>&nbsp;&nbsp;&nbsp;&nbsp; bridge, `tiger scripts', extremely powerful
but easy to use programs for securing individual
<BR>&nbsp;&nbsp;&nbsp;&nbsp; hosts, and `xvefc', (XView Etherfind Client),
a powerful distributed network monitor.

<P>Contained within the TAMU distribution is a package of tiger scripts,
which form the basis of the
<BR>distribution's digital signature authentication. As the above-mentioned
summary explains:

<P>&nbsp;&nbsp;&nbsp;&nbsp; The checking performed covers a wide range
of items, including items identified in CERT
<BR>&nbsp;&nbsp;&nbsp;&nbsp; announcements, and items observed in the recent
intrusions. The scripts use Xerox's
<BR>&nbsp;&nbsp;&nbsp;&nbsp; cryptographic checksum programs to check for
both modified system binaries (possible trap
<BR>&nbsp;&nbsp;&nbsp;&nbsp; doors/trojans), as well as for the presence
of required security related patches.
<BR>&nbsp;

<P>&nbsp;&nbsp;&nbsp;&nbsp; Cross Reference: Xerox hash.2.5a can be found
on the PARC ftp site
<BR>&nbsp;&nbsp;&nbsp;&nbsp; (ftp://parcftp.xerox.com/pub/hash/hash2.5a/).
This package is generally
<BR>&nbsp;&nbsp;&nbsp;&nbsp; referred to as the Xerox Secure Hash Function,
and the distribution is named after
<BR>&nbsp;&nbsp;&nbsp;&nbsp; Snefru, a pharaoh of ancient Egypt. The distribution
at the aforementioned site was
<BR>&nbsp;&nbsp;&nbsp;&nbsp; released in 1990, and source is included.
For those interested in hacking the Snefru
<BR>&nbsp;&nbsp;&nbsp;&nbsp; distribution, the material here is invaluable.
(Also, refer to a sister document about the
<BR>&nbsp;&nbsp;&nbsp;&nbsp; distribution and a more comprehensive explanation:
A Fast Software One Way Hash
<BR>&nbsp;&nbsp;&nbsp;&nbsp; Function by Ralph C. Merkle (there is a full
citation at the end of this chapter in the
<BR>&nbsp;&nbsp;&nbsp;&nbsp; Resources section).
<BR>&nbsp;

<P>The TAMU distribution is comprehensive and can be used to solve several
security problems, over
<BR>and above searching for trojans. It includes a network monitor and
packet filter.
<BR>&nbsp;

<P>&nbsp;&nbsp;&nbsp;&nbsp; Cross Reference: The TAMU distribution is available
at
<BR>&nbsp;&nbsp;&nbsp;&nbsp; ftp://coast.cs.purdue.edu/pub/tools/unix/TAMU/.
<BR>&nbsp;

<P>ATP (The Anti-Tampering Program)

<P>ATP is a bit more obscure than TripWire and the TAMU distribution, but
I am not certain why.
<BR>Perhaps it is because it is not widely available. In fact, searches
for it may lead you overseas (one
<BR>good source for it is in Italy). At any rate, ATP works somewhat like
TripWire. As reported by
<BR>David Vincenzetti, DSI (University of Milan, Italy) in "ATP--Anti-Tampering
Program":

<P>&nbsp;&nbsp;&nbsp;&nbsp; ATP 'takes a snapshot' of the system, assuming
that you are in a trusted configuration, and
<BR>&nbsp;&nbsp;&nbsp;&nbsp; performs a number of checks to monitor changes
that might have been made to files.
<BR>&nbsp;

<P>&nbsp;&nbsp;&nbsp;&nbsp; Cross Reference: "ATP--Anti-Tampering Program"
can be found at
<BR>&nbsp;&nbsp;&nbsp;&nbsp; http://www.cryptonet.it/docs/atp.html.
<BR>&nbsp;

<P>ATP then establishes a database of values for each file. One of these
values (the signature) consists
<BR>of two checksums. The first is a CRC32 checksum, the second an MD5
checksum. You might be
<BR>wondering why this is so, especially when you know that CRC checksums
are not entirely secure or
<BR>reliable, as explained previously. The explanation is this: Because
of its speed, the CRC32 checksum
<BR>is used in checks performed on a regular (perhaps daily) basis. MD5,
which is more comprehensive
<BR>(and therefore more resource and time intensive), is intended for scheduled,
periodic checks
<BR>(perhaps once a week).

<P>The database is reportedly encrypted using DES. Thus, ATP provides a
flexible (but quite secure)
<BR>method of monitoring your network and identifying possible trojans.
<BR>&nbsp;

<P>&nbsp;&nbsp;&nbsp;&nbsp; Cross Reference: ATP docs and distribution
can be found at
<BR>&nbsp;&nbsp;&nbsp;&nbsp; ftp://security.dsi.unimi.it/pub/security.
<BR>&nbsp;

<P>Hobgoblin

<P>The Hobgoblin tool is an interesting implementation of file- and system-integrity
checking. It utilizes
<BR>Ondishko Consistency checking. The authors of the definitive paper
on Hobgoblin (Farmer and
<BR>Spafford at Purdue) claim that the program is faster and more configurable
than COPS and generally
<BR>collects information in greater detail. What makes Hobgoblin most interesting,
though, is that it is
<BR>both a language and an interpreter. The programmers provided for their
own unique descriptors and
<BR>structural conventions.

<P>The package seems easy to use, but there are some pitfalls. Although
globbing conventions (from
<BR>both csh and sh/bash) are permissible, the Hobgoblin interpreter reserves
familiar and often-used
<BR>metacharacters that have special meaning. Therefore, if you intend
to deploy this powerful tool in a
<BR>practical manner, you should set aside a few hours to familiarize yourself
with these conventions.

<P>In all, Hobgoblin is an extremely powerful tool for monitoring file
systems. However, I should explain
<BR>that the program was written specifically for systems located at the
University of Rochester and,
<BR>although it has been successfully compiled on a variety of platforms,
your mileage may vary. This is
<BR>especially so if you are not using a Sun3, Sun4, or VAX with Ultrix.
In this instance, some hacking
<BR>may be involved. Moreover, it has been observed that Hobgoblin is lacking
some elements present
<BR>in other file-integrity checkers, although I believe that third-party
file-integrity checkers can be
<BR>integrated with (and their calls and arguments nested within) Hobgoblin.
<BR>&nbsp;

<P>&nbsp;&nbsp;&nbsp;&nbsp; Cross Reference: Hobgoblin and its source are
located at
<BR>&nbsp;&nbsp;&nbsp;&nbsp; ftp://freebsd.cdrom.com/.20/security/coast/tools/unix/hobgoblin/hobgoblin.shar.Z.uu.Z.
<BR>&nbsp;

<P>On Other Platforms

<P>You're probably wondering whether there are any such utilities for the
Windows platform. It
<BR>happens that there are, though they are perhaps not as powerful or
reliable. Most of these tools use
<BR>checksum integrity checkers and are, therefore, not as comprehensive
as tools that employ MD5.
<BR>Flatly stated, the majority for the Microsoft platform are intended
for use as virus scanners.

<P>For this reason, I have not listed these utilities here (a listing of
them does appear in Chapter 14,
<BR>"Destructive Devices"). However, I do want to address a few points:
It is generally assumed that
<BR>trojans are a security problem primarily for UNIX and that when that
problem is a Windows
<BR>problem, it usually involves a virus. There is some truth to this,
and there are reasons for it.

<P>Until recently, security on IBM compatibles running Microsoft products
was slim. There was no
<BR>need for complex trojans that could steal (or otherwise cull) information.
Thus, the majority of
<BR>trojans were viruses encased in otherwise useful (or purportedly useful)
programs. That situation has
<BR>changed.

<P>It should be understood that a trojan can be just as easily written
for a Microsoft platforms as for
<BR>any other. Development tools for these platforms are powerful, user-friendly
applications (even
<BR>VC++ far surpasses C compiling utilities made by other firms). And,
now that the Windows
<BR>environment is being used as Internet server material, you can expect
the emergence of trojans.

<P>Summary

<P>People generally equate trojan horses with virus attacks and, while
this is accurate to some degree, it
<BR>is not the whole picture. True, trojans on the PC-based operating systems
have traditionally been
<BR>virus related, but on the UNIX platform, a totally different story
emerges. On the UNIX platform,
<BR>crackers have consistently crafted trojans that compromise security
without damaging data or
<BR>attaching unauthorized code to this or that executable.

<P>In either case, however, one thing is clear: Trojans are a significant
security risk to any server as well
<BR>as to machines networked to that server. Because PC-based servers are
becoming more common
<BR>on the Internet, utilities (above and beyond those virus checkers already
available) that can identify
<BR>trojaned files must be developed.

<P>Resources

<P>Following you will find an extensive list of resources concerning object
reconciliation. Some of these
<BR>documents are related to the process of object reconciliation (including
practical examples) and
<BR>some are related to the process by which this reconciliation is performed.
All of them were
<BR>handpicked for relevancy and content. These are the main papers available
from the void (some
<BR>books are sprinkled in as well). I recommend that every system administrator
at least gain a baseline
<BR>knowledge of these techniques (if not actually implement the procedures
detailed within).

<P>"MDx-MAC and Building Fast MACs from Hash Functions." Bart Preneel and
Paul C. van
<BR>Oorschot. Crypto 95.

<P>&nbsp;&nbsp;&nbsp;&nbsp; ftp.esat.kuleuven.ac.be/pub/COSIC/preneel/mdxmac_crypto95.ps

<P>"Message Authentication with One-Way Hash Functions." Gene Tsudik. 1992.
IEEE
<BR>Infocom 1992.

<P>&nbsp;&nbsp;&nbsp;&nbsp; http://www.zurich.ibm.com/Technology/Security/publications/1992/t92.ps.Z

<P>"RFC 1446--1.5.1. Message Digest Algorithm." Connected: An Internet
Encyclopedia.

<P>&nbsp;&nbsp;&nbsp;&nbsp; http://www.freesoft.org/Connected/RFC/1446/7.html

<P>"Answers To FREQUENTLY ASKED QUESTIONS About Today's Cryptography."
Paul
<BR>Fahn. RSA Laboratories. 1993 RSA Laboratories, a division of RSA Data
Security.

<P>&nbsp;&nbsp;&nbsp;&nbsp; http://www.sandcastle-ltd.com/Info/RSA_FAQ.html

<P>"The Checksum Home Page." Macintosh Checksum.

<P>&nbsp;&nbsp;&nbsp;&nbsp; http://www.cerfnet.com/~gpw/Checksum.html

<P>"RFC 1510--6. Encryption and Checksum Specifications." Connected: An
Internet
<BR>Encyclopedia.

<P>&nbsp;&nbsp;&nbsp;&nbsp; http://www.freesoft.org/Connected/RFC/1510/69.html

<P>"RFC 1510--6.4.5. RSA MD5 Cryptographic Checksum Using DES (rsa-md5des)."
<BR>Connected: An Internet Encyclopedia. J. Kohl. Digital Equipment Corporation,
C. Neuman, ISI.
<BR>September 1993.

<P>&nbsp;&nbsp;&nbsp;&nbsp; http://www.freesoft.org/Connected/RFC/1510/index.html

<P>"Improving the Efficiency and Reliability of Digital Time-Stamping."
D. Bayer and S. Haber
<BR>and W. S. Stornetta. 1992.

<P>&nbsp;&nbsp;&nbsp;&nbsp; http://www.surety.com

<P>"A Proposed Extension to HTTP: Simple MD5 Access Authentication." Jeffery
L. Hostetler
<BR>and Eric W. Sink. 1994.

<P>&nbsp;&nbsp;&nbsp;&nbsp; http://www.spyglass.com/techreport/simple_aa.txt

<P>"A Digital Signature Based on a Conventional Encryption Function." Ralph
C. Merkle.
<BR>Crypto 87, LNCS, pp. 369-378, SV, Aug 1987.

<P>"An Efficient Identification Scheme based on Permuted Kernels." Adi
Shamir. Crypto 89,
<BR>LNCS, pp. 606-609, SV, Aug 1989.

<P>"An Introduction To Digest Algorithms." Proceedings of the Digital Equipment
Computer Users
<BR>Society Australia, Ross N. Williams. Sep 1994.

<P>&nbsp;&nbsp;&nbsp;&nbsp; ftp://ftp.rocksoft.com/pub/rocksoft/papers/digest10.tex

<P>"Data Integrity With Veracity." Ross N. Williams.

<P>&nbsp;&nbsp;&nbsp;&nbsp; ftp://ftp.rocksoft.com/clients/rocksoft/papers/vercty10.tex

<P>"Implementing Commercial Data Integrity with Secure Capabilities." Paul
A. Karger.
<BR>SympSecPr. Oakland, CA. 1988. IEEECSP.

<P>"Trusted Distribution of Software Over the Internet." Aviel D. Rubin.
(Bellcore's Trusted
<BR>Software Integrity (Betsi) System). 1994.

<P>&nbsp;&nbsp;&nbsp;&nbsp; ftp://ftp.cert.dfn.de/pub/docs/betsi/Betsi.ps

<P>"International Conference on the Theory and Applications of Cryptology."
1994
<BR>Wollongong, N.S.W. Advances in Cryptology, ASIACRYPT November 28-December
1, 1994.
<BR>(Proceedings) Berlin &amp; New York. Springer, 1995.

<P>"Managing Data Protection" (Second Edition). Dr. Chris Pounder and Freddy
Kosten,
<BR>Butterworth-Heineman Limited, 1992.

<P>"Some Technical Notes on S/Key, PGP..." Adam Shostack.

<P>&nbsp;&nbsp;&nbsp;&nbsp; http://www.homeport.org/~adam/skey-tech-2.html

<P>"Description of a New Variable-Length Key, 64-Bit Block Cipher" (Blowfish).
Bruce
<BR>Schneier. Counterpane Systems.

<P>&nbsp;&nbsp;&nbsp;&nbsp; http://www.program.com/source/crypto/blowfish.txt
<BR>&nbsp;

<P>E-Mail any questions, comments or deaththreats to:

<P>ameister@vol.com

<P>Copyright &copy; AcidMeister...

<P>Visit him at:

<P>http://www.vol.com/~ameister

<P>Disclaimer:
<BR>&nbsp;
<BR>&nbsp;
<BR>&nbsp;
<BR>&nbsp;

<P>This is for Educational purposes only it should not be used as a guide
to

<P>cause havoc or to hack. He He He, good luck!!! And don't get caught.&nbsp;
I

<P>would hate to see you in a cell with your 300 pound Bruno The Gay Ax

<P>murderer. He He He
<BR>&nbsp;
<BR>&nbsp;
<CENTER><B><FONT SIZE=+1><A HREF="!index!.htm#contents">Back To Index</A></FONT></B></CENTER>
&nbsp;
<BR>&nbsp;
<BR>&nbsp;
</BODY>
</HTML>
