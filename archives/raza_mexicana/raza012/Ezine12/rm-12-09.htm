<html>
<head>
<title>Raza Mexicana EZine 12 - Socks Protocol Versi&oacute;n 5</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</head>

<body TopMargin=0 LeftMargin=1 bgcolor="#FFFFFF" text="#000000">
<table width="100%" border="0" cellpadding="0" cellspacing="0">
  <tr> 
    <td width="110" background="Fondo.jpg" height="57">&nbsp;</td>
    <td width="" height="57"><b><font size="+3">Socks Protocol Versi&oacute;n 
      5</font></b><br>
      <i><font size="-1">Por Yo_Soy</font></i></td>
  </tr>
  <tr> 
    <td width="110" background="Fondo.jpg" height="126">&nbsp;</td>
    <td width="" height="126"> 
      <p align="justify"><b><font color="#0000FF">INTRODUCCION</font></b><br>
        <br>
        El uso de firewalls ha permitido separar estructuras de redes internas 
        del exterior de la misma. Muchos de estos firewalls no son equipos f&iacute;sicos 
        sino aplicaciones que act&uacute;an sobre la capa de aplicaci&oacute;n 
        del modelo OSI, actuando como proxy entre las maquinas que se comunican 
        entre si.<br>
        <br>
        El protocolo SOCKS fue creado para satisfacer esta necesidad que cada 
        vez era mayor, permitiendo una mejor autentificaci&oacute;n entre las 
        maquinas y logrando as&iacute; un mejor y mas fuerte control sobre el 
        acceso.<br>
        <br>
        SOCKS permite a los servidores detr&aacute;s de un firewall ganar acceso 
        a Internet. Reenv&iacute;a los paquetes de los sitios de Internet al Server 
        interno, permitiendo la transferencia hacia atr&aacute;s y hacia adelante. 
        Generalmente la aplicaci&oacute;n cliente env&iacute;a la petici&oacute;n 
        al servidor SOCKS, con la direcci&oacute;n de la maquina destino, el tipo 
        de conexi&oacute;n, y la identidad del usuario.<br>
        <br>
        Esto lo podemos representar f&aacute;cilmente en el siguiente diagrama:</p>
      <p><br>
        <font face="Courier New, Courier, mono" size="-1">&nbsp;&nbsp;&nbsp;.----------&lt;--------.<br>
        &nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;------------------.<br>
        localhost&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        socks_server&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        Internet<br>
        &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
        &nbsp;&nbsp;&nbsp;&nbsp;'-----------------&gt;<br>
        &nbsp;&nbsp;&nbsp;'----------&gt;--------'</font></p>
      <p align="justify"><br>
        Despu&eacute;s de que el servidor SOCKS recibe la petici&oacute;n, establece 
        un canal de comunicaci&oacute;n con el servidor de la aplicaci&oacute;n. 
        Un circuito se establece y el servidor SOCKS (que representar&iacute;a 
        el cliente), reenv&iacute;a los datos entre el cliente y el servidor.<br>
        <br>
        SOCKS realiza diferentes funciones de negociaci&oacute;n mientras el circuito 
        es establecido.</p>
      <p>SOCKS 5 realiza cuatros operaciones b&aacute;sicas:</p>
      <p> * negociaci&oacute;n<br>
        * autentificaci&oacute;n <br>
        * petici&oacute;n de conexi&oacute;n<br>
        * Establecimiento del circuito<br>
        * Reenvi&oacute; de datos</p>
      <p align="justify">El protocolo SOCKS 5 expande las caracter&iacute;sticas 
        de SOCKS 4, ya que adem&aacute;s de incluir el protocolo TCP, tambi&eacute;n 
        soporta UDP y el formato de direcciones de IP V6.<br>
        <br>
        Generalmente el demonio del servidor SOCKS estar&aacute; corriendo en 
        el puerto 1080.<br>
        <br>
        En el presente articulo veremos tan solo el procedimiento para clientes 
        TCP (siendo el mas com&uacute;n), pero si tu deseas profundizar en el 
        proceso para clientes UDP, puedes leer el RFC 1928 y/o visitar la pagina 
        oficial http://www.socks.nec.com<br>
        <br>
        <font color="#0000FF"><b>PROCEDIMIENTO PARA CLIENTES TCP</b></font><br>
        <br>
        <font color="#0000FF"><b>Negociaci&oacute;n:</b></font><br>
        <br>
        El cliente se conecta al servidor SOCKS, y env&iacute;a el formato de 
        negociaci&oacute;n, que puede verse as&iacute;:</p>
      <p> <font face="Courier New, Courier, mono" size="-1">.-------.------------.-----------.<br>
        | &nbsp;VER &nbsp;|&nbsp; NMETHODS &nbsp;|&nbsp; METHODS &nbsp;|<br>
        +-------+------------+-----------+<br>
        | &nbsp;&nbsp;1&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;1 &nbsp;&nbsp;&nbsp;&nbsp;| 
        &nbsp;1 a 255 &nbsp;|<br>
        '-------+------------+-----------'</font></p>
      <p align="justify">Nota: Los n&uacute;meros abajo indicados representan la 
        longitud en octetos de cada paquete.</p>
      <p> Posibles valores de cada paquete:</p>
      <p> <font face="Courier New, Courier, mono" size="-1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VER 
        : 0x05 &nbsp;&nbsp;&nbsp;Versi&oacute;n del Protocolo <br>
        NMETHODS : [valor] Representa el numero de m&eacute;todos.<br>
        &nbsp;METHODS :<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00&nbsp;&nbsp;&nbsp; 
        Sin autentificacion<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x01&nbsp;&nbsp;&nbsp; 
        GSSAPI<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x02&nbsp;&nbsp;&nbsp; 
        Username/Password<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xff&nbsp;&nbsp;&nbsp; 
        Ning&uacute;n m&eacute;todo aceptable</font></p>
      <p align="justify"><br>
        En el proceso de negociaci&oacute;n GSSAPI (Generic Security Service Application 
        Program Interface), los clientes negocian con el servicio SOCKS acerca 
        de la seguridad de los mensajes.<br>
        <br>
        La integridad y privacidad son las opciones que pueden aplicarse al resto 
        de los mensajes, incluyendo las peticiones al proxy provenientes de la 
        aplicaci&oacute;n cliente.</p>
      <p><br>
        <font color="#0000FF"><b>Peticiones:</b></font></p>
      <p align="justify">Una vez que la subnegociacion de los m&eacute;todos ha sido 
        completada, el cliente env&iacute;a los detalles de la petici&oacute;n 
        como sigue:</p>
      <p><br>
        <font size="-1" face="Courier New, Courier, mono">.-------.-------.-------.--------.------------.------------.<br>
        |&nbsp;&nbsp;VER&nbsp; | &nbsp;CMD &nbsp;| &nbsp;RSV&nbsp; |&nbsp; ATYP 
        &nbsp;| &nbsp;DST.ADDR&nbsp; | &nbsp;DST.PORT &nbsp;|<br>
        +-------+-------+-------+--------+------------+------------+<br>
        |&nbsp;&nbsp; 1 &nbsp;&nbsp;| &nbsp;&nbsp;1 &nbsp;&nbsp;|&nbsp;&nbsp;0x00 
        | &nbsp;&nbsp;&nbsp;1&nbsp;&nbsp; | &nbsp;Variable&nbsp; | &nbsp;&nbsp;&nbsp;&nbsp;2 
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>
        '-------+-------+-------+--------+------------+------------+</font></p>
      <p><br>
        Posibles valores de cada paquete:</p>
      <p> <font size="-1" face="Courier New, Courier, mono">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VER 
        : 0x05 Versi&oacute;n del Protocolo </font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CMD 
        : Comando<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x01 
        Connect<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x02 
        Bind<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x03 
        UDP</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RSV 
        : 0x00 Valor reservado</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> &nbsp;&nbsp;&nbsp;&nbsp;ATYP 
        : Tipo de direcci&oacute;n <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x01 
        direcci&oacute;n IP V4<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x03 
        Nombre de dominio<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x04 
        direcci&oacute;n IP V6</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> DST.ADDR : direcci&oacute;n 
        de destino<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[valor] 
        Longitud de la direcci&oacute;n de dominio<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[direcc] 
        Nombre de dominio o direcci&oacute;n de 4 octetos.</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> DST.PORT : Puerto 
        de destino.</font></p>
      <p></p>
      <p> <b><font color="#0000FF">SOCKS CHAINS</font></b><br>
      </p>
      <p align="justify">Nosotros podemos utilizar el protocolo SOCKS para actu&eacute; 
        efectivamente como proxy/firewall en nuestras conexiones salientes.<br>
        <br>
        Sockscap es una excelente utilidad para estos prop&oacute;sitos ya que 
        intercepta todas las salidas de nuestras maquinas por medio de un servidor 
        SOCKS, por lo que podemos utilizarlo para la mayor&iacute;a de los clientes 
        (aun aquellos que no tengan la opci&oacute;n definida), logrando que nuestras 
        conexiones sean mas 'an&oacute;nimas'.<br>
        <br>
        Sockscap puede encontrarse en -&gt; <a href="http://www.socks.nec.com/reference/sockscap.html">http://www.socks.nec.com/reference/sockscap.html</a><br>
        Un socks chainer puede encontrarse en -&gt; http://www.ufasoft.com/socks</p>
      <p></p>
      <p><b><font color="#0000FF">SOCKS EN PERL</font></b><br>
      </p>
      <p align="justify">Programar socks en Perl es relativamente sencillo ya que 
        ya existe un modulo creado para tal efecto, el autor es Clinton Wong y 
        el modulo puede encontrarse en CPAN <a href="http://www.perl.com/CPAN/modules/by-module/Net/">http://www.perl.com/CPAN/modules/by-module/Net/</a> 
        y actualmente solo soporta conexiones TCP.</p>
      <p>Se carga el modulo Net::SOCKS, despu&eacute;s se crea el constructor 
        as&iacute;:</p>
      <p> <font size="-1" face="Courier New, Courier, mono">$sockout = new Net::SOCKS(socks_addr 
        =&gt; '192.168.1.3',<br>
        socks_port =&gt; 1080,<br>
        user_id =&gt; 'the_user',<br>
        user_password =&gt; 'the_password',<br>
        force_nonanonymous =&gt; 1,<br>
        protocol_version =&gt; 5);<br>
        </font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> socks_addr = direcci&oacute;n 
        del servidor socks<br>
        socks_port = puerto del servicio socks<br>
        user_id = (opcional) nombre de usuario<br>
        user_password = (opcional) password de usuario<br>
        protocol_version = la versi&oacute;n del protocolo (4 o 5)<br>
        force_nonanonymous = fuerza la conexi&oacute;n a no ser an&oacute;nima</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"><br>
        </font>Despu&eacute;s nos conectamos mediante:</p>
      <p> <font size="-1" face="Courier New, Courier, mono">$sock-&gt;connect(peer_addr 
        =&gt; '192.168.1.3', peer_port =&gt; 79);</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> peer_addr es la direcci&oacute;n 
        destino y peer_port es el puerto.</font></p>
      <p>as&iacute;, un cliente que haga finger en perl se ver&iacute;a as&iacute;:</p>
      <p> <br>
        <font size="-1" face="Courier New, Courier, mono">&lt;++&gt; socks/safefinger.pl<br>
        #!/usr/local/bin/perl -w</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> use strict;</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> use Net::SOCKS;</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> print &quot;Attempting 
        to connect to 192.168.1.3 at port 79 using the socks\n&quot;;<br>
        print &quot;server at 192.168.1.3 port 1080\n&quot;;</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> my $sock = new Net::SOCKS(socks_addr 
        =&gt; '192.168.1.3',<br>
        socks_port =&gt; 1080,<br>
        #user_id =&gt; 'the_user',<br>
        #user_password =&gt; 'the_password',<br>
        #force_nonanonymous =&gt; 1, <br>
        protocol_version =&gt; 5);<br>
        my $f= $sock-&gt;connect(peer_addr =&gt; '192.168.1.3', peer_port =&gt; 
        79);<br>
        print &quot;connect status: &quot;,<br>
        Net::SOCKS::status_message($sock-&gt;param('status_num')), &quot;\n&quot;;<br>
        <br>
        if ($sock-&gt;param('status_num') == SOCKS_OKAY) {<br>
        print $f &quot;clintdw\n&quot;;<br>
        while (&lt;$f&gt;) { print }<br>
        $sock-&gt;close();<br>
        }</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> print &quot;Attempting 
        to listen() using the server at 192.168.1.3 port 1080\n&quot;;</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> $sock = new Net::SOCKS(socks_addr 
        =&gt; '192.168.1.3',<br>
        socks_port =&gt; 1080,<br>
        #user_id =&gt; 'the_user',<br>
        #user_password =&gt; 'the_password',<br>
        #force_nonanonymous =&gt; 1, <br>
        protocol_version =&gt; 5);</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> my ($ip, $ip_dot_dec, 
        $port) = $sock-&gt;bind(peer_addr =&gt; &quot;192.168.1.3&quot;,<br>
        peer_port =&gt; 9999);<br>
        print &quot;bind status: &quot;,<br>
        Net::SOCKS::status_message($sock-&gt;param('status_num')), &quot;\n&quot;;</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> if ($sock-&gt;param('status_num') 
        == SOCKS_OKAY) {<br>
        print &quot;Listening at the IP of &quot;, $ip_dot_dec, &quot; at port 
        &quot;, $port, &quot;\n&quot;;<br>
        $f= $sock-&gt;accept();<br>
        }<br>
        print &quot;accept status: &quot;, <br>
        Net::SOCKS::status_message($sock-&gt;param('status_num')), &quot;\n&quot;;</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> if ($sock-&gt;param('status_num') 
        == SOCKS_OKAY) {<br>
        while (&lt;$f&gt;) { print }<br>
        }<br>
        $sock-&gt;close();<br>
        &lt;--&gt;</font></p>
      <p><br>
        <font color="#0000FF"><b>SOCKS EN C</b></font><br>
      </p>
      <p align="justify">Programar clientes SOCKS en C es mas complicado debido 
        a que tenemos que trabajar a un nivel mas bajo. as&iacute; si recordamos 
        lo primero que debemos hacer es enviar la negociaci&oacute;n (si vamos 
        a enviar una negociaci&oacute;n de usuario y contrase&ntilde;a mirar el 
        RFC 1929) y luego enviar la petici&oacute;n.<br>
        <br>
        Como ejemplo ponemos una aplicaci&oacute;n que permite enviar correo mediante 
        un<br>
        servidor SOCKS:</p>
      <p><br>
        <font size="-1" face="Courier New, Courier, mono">&lt;++&gt; socks/rm-sm.c<br>
        /*<br>
        | Raza Mexicana Team 2001 - http://www.raza-mexicana.org<br>
        |<br>
        | (rm-sm.c) Sends e-mail thru a socks proxy server.<br>
        |<br>
        | Yo_Soy - &lt;yo_soy@raza-mexicana.org&gt;<br>
        |<br>
        | This program is free software; you can redistribute it and/or<br>
        | modify it under the terms of the GNU General Public License<br>
        | as published by the Free Software Foundation; either version<br>
        | 2 of the License, or (at your option) any later version.<br>
        */</font></p>
      <p><font size="-1" face="Courier New, Courier, mono">#include &lt;stdio.h&gt;<br>
        #include &lt;stdlib.h&gt;<br>
        #include &lt;string.h&gt;<br>
        #include &lt;sys/types.h&gt;<br>
        #include &lt;sys/socket.h&gt;<br>
        #include &lt;netinet/in.h&gt;</font></p>
      <p><font size="-1" face="Courier New, Courier, mono">#include &quot;socks5.h&quot;</font></p>
      <p><font size="-1" face="Courier New, Courier, mono">void uso (void);</font></p>
      <p><font size="-1" face="Courier New, Courier, mono">int main (int argc, 
        char *argv[]) {</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> struct sockaddr_in 
        sin;<br>
        unsigned int smtpuerto = 25,<br>
        socksport = 1080,<br>
        sockout;<br>
        char *mailfrom = argv[1],<br>
        *destino = argv[2],<br>
        *sockserv = argv[5],<br>
        *smtpserv = argv[4],<br>
        *mensaje,<br>
        respuesta[256],<br>
        sendbuff[256];<br>
        FILE *archivo;</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> if (argc &lt; 5) uso(); 
        </font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> printf (&quot;[++] 
        -&gt; Raza Mexicana - MailSock\n&quot;);</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> printf (&quot;\n[+] 
        Mail from....: %s\n&quot;, mailfrom);<br>
        printf (&quot;[+] Mail to......: %s\n&quot;, destino);<br>
        printf (&quot;[+] Smtp Server..: %s\n&quot;, smtpserv);<br>
        printf (&quot;[+] Socks server.: %s\n&quot;, sockserv);</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> if (argc &gt; 5) {<br>
        socksport = atoi(argv[6]);<br>
        printf (&quot;[+] Socks port...: %d\n&quot;, socksport); }</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> if ((archivo = fopen 
        (argv[3], &quot;r&quot;)) == NULL) {<br>
        printf (&quot;ERROR: Can't open file %s\n&quot;, argv[3]);<br>
        exit (EXIT_FAILURE); }</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> if ((sockout = socket 
        (AF_INET, SOCK_STREAM, 0)) == -1) {<br>
        printf (&quot;ERROR: Can't create socket.\n&quot;);<br>
        exit (EXIT_FAILURE); }<br>
        <br>
        sin.sin_family = AF_INET;<br>
        sin.sin_port = htons(socksport);<br>
        sin.sin_addr.s_addr = inet_addr(sockserv);</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> if ((connect(sockout, 
        (struct sockaddr *)&amp;sin, sizeof(sin))) == -1) {<br>
        printf (&quot;ERROR: Can't connect to host %s\n&quot;, sockserv);<br>
        exit (EXIT_FAILURE);<br>
        }</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> /* Negociacion */<br>
        sprintf (sendbuff, &quot;%c%c%c&quot;, SOCKS_VER, 1, METHOD_NOAUTH);<br>
        send (sockout, sendbuff, sizeof(sendbuff), 0);<br>
        <br>
        /* Request */<br>
        printf (&quot;Sendbuff = %s\n&quot;, sendbuff);<br>
        sprintf (sendbuff, &quot;%c%c%c%c%s%c%c&quot;, SOCKS_VER, CMD_CONNECT,<br>
        SOCKS_RSV, strlen(smtpserv), smtpserv,<br>
        (smtpuerto &gt;&gt; 8) &amp; 0xFF, smtpuerto &amp; 0xFF);<br>
        send (sockout, sendbuff, sizeof(sendbuff), 0);<br>
        <br>
        /* Checamos las posibles respuestas del sock_server */<br>
        recv (sockout, respuesta, 100, 0);<br>
        switch (respuesta[1]) {<br>
        case R_SUCCEDED:<br>
        break;<br>
        case R_FAILURE:<br>
        printf (&quot;ERROR: general socks server failure\n&quot;);<br>
        exit (EXIT_FAILURE);<br>
        break;<br>
        case R_NOALLOWED:<br>
        printf (&quot;ERROR: connection not allowed\n&quot;);<br>
        exit (EXIT_FAILURE);<br>
        break;<br>
        case R_NET_UNR:<br>
        case R_HOST_UNR:<br>
        printf (&quot;ERROR: network / host unreachable\n&quot;);<br>
        exit (EXIT_FAILURE);<br>
        break;<br>
        case R_REFUSED:<br>
        printf (&quot;ERROR: connection refused\n&quot;);<br>
        exit (EXIT_FAILURE);<br>
        break;<br>
        case R_TTLEXPIRED:<br>
        printf (&quot;ERROR: TTL expired\n&quot;);<br>
        exit (EXIT_FAILURE);<br>
        break;<br>
        case R_NOCMD:<br>
        printf (&quot;ERROR: command not supported\n&quot;);<br>
        exit (EXIT_FAILURE);<br>
        break;<br>
        case R_NOADDR:<br>
        printf (&quot;ERROR: address type not supported\n&quot;);<br>
        exit (EXIT_FAILURE);<br>
        break;<br>
        default:<br>
        printf (&quot;ERROR: %d\n&quot;, respuesta[1]);<br>
        exit (EXIT_FAILURE);<br>
        break;<br>
        }</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> /* Si llegamos aqui, 
        todo esta bien */</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> /* ahora enviamos 
        el mensaje */<br>
        sprintf (sendbuff, &quot;HELO RMHT\n&quot;);<br>
        send (sockout, sendbuff, sizeof(sendbuff), 0);</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> sprintf (sendbuff, 
        &quot;MAIL FROM &lt;%s&gt;\n&quot;, mailfrom);<br>
        send (sockout, sendbuff, sizeof(sendbuff), 0);</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> sprintf (sendbuff, 
        &quot;RCPT TO: &lt;%s&gt;\n&quot;, destino);<br>
        send (sockout, sendbuff, sizeof(sendbuff), 0);</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> sprintf (sendbuff, 
        &quot;DATA\n&quot;);<br>
        send (sockout, sendbuff, sizeof(sendbuff), 0);</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> while (! feof(archivo)) 
        {<br>
        if (fgets(mensaje, 255, archivo)) {<br>
        send (sockout, mensaje, sizeof(mensaje), 0); }<br>
        }<br>
        fclose (archivo);</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> sprintf (sendbuff, 
        &quot;\n.\n&quot;);<br>
        send (sockout, sendbuff, sizeof(sendbuff), 0);</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> sprintf (sendbuff, 
        &quot;QUIT\n&quot;);<br>
        send (sockout, sendbuff, sizeof(sendbuff), 0);</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> printf (&quot;[+] 
        Message sent to %s!\n&quot;, destino);</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> return (0);<br>
        } </font></p>
      <p><font size="-1" face="Courier New, Courier, mono">void uso(void) {<br>
        puts(&quot;\n[+] Raza Mexicana SocksMail - http://www.raza-mexicana.org</font></p>
      <p><font size="-1" face="Courier New, Courier, mono">Usage:</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"> rm-sm &lt;from&gt; 
        &lt;to&gt; &lt;message&gt; &lt;smtp&gt; &lt;socks_proxy&gt; &lt;socks_port&gt;</font></p>
      <p> <font size="-1" face="Courier New, Courier, mono">&lt;from&gt; from 
        mail address<br>
        &lt;to&gt; destination mail address<br>
        &lt;message&gt; the file with the message<br>
        &lt;smtp&gt; relaying smtp server<br>
        &lt;socks_proxy&gt; socks proxy server<br>
        &lt;socks_port&gt; default 1080 if not defined<br>
        &quot;);<br>
        exit(EXIT_SUCCESS); }<br>
        &lt;--&gt;</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"><br>
        y la cabecera necesaria con las constantes definidas en el RFC (socks5.h):</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"><br>
        &lt;++&gt; socks/socks5.h<br>
        /*<br>
        | Socks Protocol Versi&oacute;n 5 // RFC 1928<br>
        | by Yo_Soy &lt;yo_soy@raza-mexicana.org&gt;<br>
        */</font></p>
      <p><font size="-1" face="Courier New, Courier, mono">#define SOCKS_VER 0x05 
        /* socks protocol version 5 */<br>
        #define SOCKS_RSV 0x00 /* socks reserved */</font></p>
      <p><font size="-1" face="Courier New, Courier, mono">enum METHODS {<br>
        METHOD_NOAUTH = 0x00, /* no authentication required */<br>
        METHOD_GSSAPI = 0x01, /* GSAAPI */<br>
        METHOD_AUTH = 0x02, /* username / password */<br>
        METHOD_NOACCM = 0xff /* no acceptable methods */<br>
        } sockmethods;</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"><br>
        enum COMMANDS {<br>
        CMD_CONNECT = 0x01, /* connect */<br>
        CMD_BIND = 0x02, /* bind */<br>
        CMD_UDP = 0x03 /* udp associate */<br>
        } sockcmds;</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"><br>
        enum ADDRESS {<br>
        ADDR_IPV4 = 0x01, /* IP V4 address */<br>
        ADDR_DOMAIN = 0x03, /* domain name */<br>
        ADDR_IPV6 = 0x04 /* IP V6 address */<br>
        } sockatyp;</font></p>
      <p><font size="-1" face="Courier New, Courier, mono"><br>
        enum REPLIES {<br>
        R_SUCCEDED = 0x00, /* succeeded */<br>
        R_FAILURE = 0x01, /* general socks server failure */<br>
        R_NOALLOWED = 0x02, /* connection not allowed */<br>
        R_NET_UNR = 0x03, /* network unreacheable */<br>
        R_HOST_UNR = 0x04, /* host unreacheable */<br>
        R_REFUSED = 0x05, /* connection refused */<br>
        R_TTLEXPIRED = 0x06, /* TTL expired */<br>
        R_NOCMD = 0x07, /* command not supported */<br>
        R_NOADDR = 0x08 /* address type not supported */<br>
        } sockreply;<br>
        &lt;--&gt;</font></p>
      <table width="100%" border="0" cellspacing="0" cellpadding="0">
        <tr>
          <td>
            <div align="left"><a href="rm-12-08.htm"><img src="i.gif" width="88" height="30" alt="RMHT en el WWW" border="0"></a></div>
          </td>
          <td>
            <div align="right"><a href="rm-12-0A.htm"><img src="d.gif" width="88" height="30" border="0" alt="El lado humano"></a></div>
          </td>
        </tr>
      </table>
      <p>&nbsp;</p>
      </td>
  </tr>
  <tr>
    <td width="110" background="Fondoa.jpg" height="57">&nbsp;</td>
    <td width="" height="57">
      <div align="right"><font size="-1"><b>Comentarios a : <a href="mailto:yo_soy@raza-mexicana.org">yo_soy@raza-mexicana.org</a></b></font></div>
    </td>
  </tr>
</table>
</body>
</html>
