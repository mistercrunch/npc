[LoU] =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= [LoU]
                            %%%%%
        &&&   &&& &&&   &&%%    %%               keen veracity
        &&&  &&&  &&&   &&&   %%
        &&& &&&   &&&   &&& %%             volume 2: "the freshmaker"
        &&&&&&    &&&   &&%%%%%%%%
        &&&&&&&   &&&   &&&                    august 1998 release
        &&&  &&&    &&&&&
        &&&   &&&    &&&            an LoU joint    http://www.legions.org

[LoU] ---------------------------------------> [Legions of the Underground]

_-_-_-_-_-_-_-_-_-_
 Table of Contents
~-~-~-~-~-~-~-~-~-~

    00     * Introductions             - |        | - tip
           * --------------------------- |        | -
    01     * Unix Security             - |        | - Hyperlogik
           * --------------------------- |        | -
    02     * Local Digital Switching   - |        | - JF
           * --------------------------- |        | -
    03     * GSM System Security Study - |        | - David Dane
           * --------------------------- |        | -
    04     * Disrupting DSU Satellites - |        | - optiklenz
           * --------------------------- |        | -
    05     * Playing with Loopback     - |        | - ralph
           * --------------------------- |        | -
    06     * Active X                  - |        | - Defiant
           * --------------------------- |        | -
    07     * Windows with Sockets      - |        | - Sreality
           * --------------------------- |        | -
    08     * Life of a Wingate         - |        | - sektor
           * --------------------------- |        | -
    09     * Lighter Side of Anarchy   - |        | - Danse Fevah
           * --------------------------- |        | -
    10     * In Conclusion             - |        | - tip
           * --------------------------- |        | -

[00] =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= [00]
_-_-_-_-_-_-_-_
 Introductions                                                      by: tip
~-~-~-~-~-~-~-~

Obviously this is issue two of Keen Veracity. After an incident involving
the media, chilling out at Defcon, and putting shit together, finally
this issue has materialized and now resides before your very eyes. It's a
smaller issue than the last, but we feel it is a better product.

Regarding the incident involving the media: somewhere along the line, the
concept and ethics of hacking became lost. What was an intellectual
exercise with no malicious intention was subject to the prejudging eye of
self-claimed leetists. Ask yourself: What is hacking? Was anything harmed?
Would it have been better if people with indeed malicious intentions did
the same thing, yet not tell anyone about it?

The public eye for the scrutiny of perfection in terms of security is
always the best way to improve. How else would an operating system,
applications, or even a company's dial-ups be secure unless tested and
given attention to? Ask yourself that.


Links to check out: http://rhino9.ml.org
                    http://www.sekurity.org
                    http://www.insecure.org
                    http://www.linenoise.org
                    http://www.dope.org

Please contact us for article submissions, letters, comments, criticism,
etc. Thank you.

[01] =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= [01]
_-_-_-_-_-_-_-_-_
  Unix Security                                              by: Hyperlogik
~-~-~-~-~-~-~-~-~

Overview of Security Administration

Security is an aspect of the operation of your computer that must always
be kept in mind. A machine connected to phone lines or a local network has
the potential for intruders. Even an isolated machine is subject to idle
browsing by its legitimate users. Consider the possible loss if a file is
altered, destroyed, or if the wrong person sees it.

Suggestions for Making Your System Secure

The security of any system is ultimately the responsibility of all who
have access to it. As the administrator of your system, you need to
consider the following:

Restrict physical access to your computer (especially if it is a small
machine) so that someone does not simply walk off with it.

Set the access permissions to directories and files so that they can be
accessed only as needed by the owner, group or others. Publicly writeable
directories are a security hazard. Allow them only if you have a good
reason.

Assign passwords to all logins and change them regularly. You can force
them to be changed by implementing password aging. Do not pick obvious
passwords: six-to-eight characters nonsense strings using letters and
numbers are recommended over recognizable words. Remove or lock logins
that are no longer needed.

Do not keep sensitive information on a system with dial-up ports; the
security of your system with dial-up ports is difficult to guarantee.

Users who use the su command to become root, can compromise the security
of your system by accessing files belonging to others users without their
knowledge. For this reason, a log is kept on the use of the su(1) command.
Check the file /var/adm/sulog to monitor use of this command.

Keep in mind that login directories, user profiles, and files in /sbin,
/usr/sbin, and /etc that writetable by others are security give-aways.

Encrypt sensitive data files. The crypt(1) command together with the
encryption capabilities of the editors (ed and vi) provide better
protection of sensitive information. The Security Administration Utilities
package (U.S. customers only) , must be installed be fore you can run
crypt(1).

Do not leave a logged-in terminal unattented, especially if you are logged
in as root. If you must be away from your terminal, log off before leaving.

As system administrator, use full pathnames for critical commands (for
exmaple /usr/bin/su instead of su).

Don't mount a medium (such as diskette) unless the contents are trusted.
These file systems may contain set-user-ID or Trojan horse (undesirable
gift) programs.

Don't add packages or programs for untrusted sources. This is the most
common way of spreading computer viruses.

Logins and Passwords

To log in to the UNIX system, a user must enter both login name and a
password. Although logins are publicy known, passwords must be known only
by their owners. To enhance the security of your system and data, ask your
users to change their password occasionally. For a high level of security,
users should change their passwords about every 6 weeks. System
administration logins (such as root and sys) should be changed monthly or
whenever a person having the root password leaves the company or is
reassigned. Although voluntary compliance with this practice is desired,
the UNIX operating system provides a mechanism to force compliance
called password aging.

Choosing your Password

Most security breakins of computer systems involve guessing the person's
password. While the passwd(1) command has some criteria for making sure
the password is hard to obtain using mechanical means, a clever person
can sometimes guess a password just by knowing something about the person
and his/her habits.

Bad choices:
- names of family members or pets
- car license numbers
- telephone numbers
- Social Security number or employee number
- names related to a person's hobbies or interest
- words currently popular in the media (such as slangs from TV shows),
- seasonal themes (such as "turkey" in November or "superbowl" in January).
- any variations on this by substitution or addition of a special character.

Good choices:
- puns
- words in a foreign language
- a word reversed (yekrut for turkey), or a nonsense word made up of the
  first letter of every word in a phrase (Mhallifwwas - Mary had a little
  lamb, its fleece was white as snow).
- an additional non-alphabetic character in the middle of the password
  (be careful about magic characters such as #, @, and control characters).
- substitute a number for a similar letter (for exmaple, 0 for o, 3 for e,
  1 for l or i).

Remember that a clever code-breaker is also aware of the preceding rules.

Password Aging

The password aging mechanism forces users to change their passwords on a
periodic base. Provisions are made to prevent a user from changing a new
password before a specified interval. Password aging is selectively applied
to logins by using the passwd(1) command. If you require more access control
than what is provided by password aging, you can also change the
/etc/profile to require a second access code as part of the login process.

The password aging information requires setting the following parameters
for each login:

min   The minimum number of days required between password changes.
max   The maximum number of days the password is valid.
warn  The number of days that a warning message appears to a user
      before the password becomes invalid.

As a result of using passwd(1), the following parameters changes:

lastchanged  The number of days between January 1, 1970, and the date
             that the password was last modified.

Displaying Password Information

Password and aging information can be displayed using the -s option of the
passwd command. For example, if you type

passwd -s SynnerGy

the following information appears if there is password aging.

SynnerGy   PS   06/23/98   14   84   7

If password againg is not turned on, only the first two fields appear. The six fields contain the following information:

Login name (SynnerGy)

Password status (PS). The following string may appear:

      NP    No password for this login
      LK Login is locked
      PS Anything else

Date the password was last changed (06/23/98).

Minimum number of days after lastchanged before the user can change the
password (14).

Maximum number of days after lastchanged until the user will be forced to
change the password (84).

Number of warning days before the password must be changed (7).

Thus, the information obtained for this example shows that there is a
password for the login SynnerGy that cannot be changed before July 6 and
that must be changed by September 15, 1998. On September 8, 1998, this
users will see a warning message that the password will expire and should
be changed.

To display the password status aging information for all users on your
system, use the -a option to the passwd command, instead of specifying
individual logins:

           passwd -s -a

Only a privileged can use the -a option for the passwd command.

Sample passwd Commands

Password administration can be set up in a variety of ways to meet the
needs of different organizations. Some examples follow:

1. Change a password:

        passwd login_name

Because this command is run by the administrator, no prompt for the old
password is given. Instead, as a privileged user, the administrator is
prompted to enter the new password. The password is not displayed as it is
typed. The command requires you to enter the password twice to assure it
is typed accurately.

2. Turn on aging, set max to 84 and min to 7 days, respectively:

   passwd -x 84 -n 7 login_name

3. Force a user to change the password at the next session.

   passwd -f login_name

4. Lock a passwd, set max to 7 and min to 10 days:

   passwd -x 7 -n 10 login_name

Because min is greater then max, the password is locked and cannot be
changed but the user can still log into the system. Only root can change
this password.

5. Turn off aging by setting max to negative one:

   passwd -x -1 login_name

6. Warn the user starting 14 days before the password is set to expire
   that a new password must be chosen.

   passwd -w 14 login_name

   Starting 14 days before max, the user will see this message:

   Your password will expire in 14 days

   Each day, the number will decrease until the password expires or the
   user changes the password.

Password Recovery

Limiting the number of people that know the root password is an important
part of maintaining system security. Ideally, few people will know the
password for this privileged login. However, when fewer people know the
root password, the chances of losing or forgetting this password will
increase.

If you cannot recover your root password, call your support hotline.

File Protection

Because the UNIX operating system is a multiuser system, you usually do
not work alone in the file system. Systems users can follow pathnames to
various directories and read and use files belonging to one another, as
long as they have permission to do so.

If you own a file, you can decide who has the right to read, write in it
(make changes to it), or, if it is a program, to execute it. You can also
restrict permissions for directories. When you grant execute permission
for a directory, you allow the specified users to change the directory
and list its contents with the ls(1) command. Only the owner or a
privileged user can define the following:

Which users have permission to access data.

Which types of permission they have (that is, how they are allowed to use
the data).

File Types

When you display the contents of a directory with the ls -l command, the
first column of ouput describes the "mode" of the file. This information
tells you not only what type of file it is, but who has permission to
access it. This first field is 10 characters long. The first character
defines the file type and can be one of the following types, as shown below.

Type                          Symbol

Text, programs, etc.            -
Directories                     d
Character special               c
Block special                   b
FIFO (named pipe) special       p
Symbolic links                  l

File Access Permissions

In the first of the ls -l output, the next nine characters are interpreted
as three sets of three bits each. The first set refers to the owner's
permissions; the next to permissions of members in the file's group; and
the last to all others.
Within each set, the three characters show permission to read, to write,
and to execute the file as a program, respectively. For a directoy,
"execute" permission is interpreted to mean permission to search the
directory for a specified file. The permissions are as shown below.

Explanation                                       Symbol
The file is readable.                                r
The file is writeable.                               w
The file is executable.                              x
This permission is not granted.                      -
Mandatory locking will occur during access.          l
   (The set-group-ID bit is on and the execution
   bit is off.)
The set-user-ID or set-group-ID bit is on, and the   s
   corresponding user or group execution bit is
   also on.
The set-user-ID bit is on and the user               S
   execution bit is off.
The sticky and the execution bits for other are on.  t
The sticky bit is turned on, and the execution       T
   bits for other is off.

Explanation                                        Symbol

The directory is readable.                           r
The directory may be altered.                        w
   (Files may be added or removed.)
The directory may be searched. (This permission      x
   is required to cd to the directory.)
File removal from a writeable directory is limited   t
   to the owner of the directory or file unless
   the file is writeable.

Setting a default umask

When a file is created, its default permissions are set. These default
settings may be changed by placing an appropriate umask(1) command (see
below) in the system profile (/etc/profile).

Level of Security       umask   Disallows

Permissive              0002    w for others
Moderate                0027    w for group, rwx for others
Severe                  0077    rwx for group and others

Set-User-ID and Set-Group-ID

The set-user identification (set-UID) and set-group identification
(set-GID) bits must be used carefully. These bits are set through the
chmod(1) command and can be specified for any executable file. When any
user runs an executable file that has either of the bits set, the system
gives the user the permissions of the owner (or group) of the executable.

System security can be compromised if a user copies another program onto
a file with -rwsrwxrwx permissins. For exmaple, if the switch-user (su)
command has the write access permission allow for others, anyone can copy
the shell onto it and get a password-free version of su with no sulog
entry being made. Experience has shown that people who have had root
permissions once, tend to keep such a file around. The following paragraphs
provide a few examples of command lines that can be used to identify the
files with a set-UID bit. A vigilant system administrator will check the
system for potential problems periodically and investigate any unusual
occurrences.

For more information about the set-UID and set-GID bits, see chmod(1)
and chmod(2).

Check Set-UIDs

The following command line lists all set-UID programs owned by root. The
results are saved in a file in /tmp. All mounted paths are checked by this
command starting at /. Any surprises in the output should be investigated.
Search time is dependent on the number of entries in the directory to be
searched.

This program can be run by sys, bin, and mail, as well.

# find / -user root -perm -4000 -exec ls -ldb { } \ ; > /tmp/ckprm
# cat /tmp/ckprm
-r-sr-xr-x   1  root   bin  38836  Aug 10  16:16  /usr/bin/at
-r-sr-xr-x   1  root   bin  19812  Aug 10  16:16  /usr/bin/crontab
---s--x--x   1  root   sys  46040  Aug 10  15:18  /usr/bin/ct
-r-sr-xr-x   1  root   sys  12092  Aug 10  01:29  /usr/lib/mv_dir
-r-sr-xr-x   1  root   bin  33208  Aug 10  15:55  /usr/lib/lpadmin
-r-sr-xr-x   1  root   bin  38696  Aug 10  15:55  /usr/lib/lpsched
---s--x---   1  root   rar  45376  Aug 18  15:11  /usr/rar/bin/sh
-r-sr-xr-x   1  root   bin  12524  Aug 11  01:27  /usr/bin/df
-rwsr-xr-x   1  root   sys  21780  Aug 11  01:27  /usr/bin/newgrp
-r-sr-sr-x   1  root   sys  23000  Aug 11  01:27  /usr/bin/passwd
-r-sr-xr-x   1  root   sys  23824  Aug 11  01:27  /usr/bin/su
#

In this example, an authorized user (rar) has made a personal copy of
/usr/bin/sh and has it made set-UID to root. This mean rar can execute
/usr/rar/bin/sh and become the privileged user.

If you want to save this output for future reference, move the file out
of /tmp.

Check Set-UIDs by File System

The command line entry in the following example shows the use of the ncheck
command to examine the /usr file system (/dev/dsk/c0d0s4, assuming a
singledisk system with default slicing) for files. The -F tells ncheck that
it should expect an s5 file system type. The output of the modified ncheck
used as an argument to the ls command. In the following example, the
complete pathnames for the files start with /usr. /usr is not part of the
ncheck output but must be added [using sed(1)] for the ls to work. The use
of the ls command is possible only if the file system is mounted.

# ls -l 'ncheck -F s5 -s /dev/dsk/c0d0s4 | cut -f2 | sed 's:^:/usr:''
-r-sr-xr-x   1  root   bin   72579  Mar	 3  07:25  /usr/bin/at
-r-sr-xr-x   1  root   bin   33608  Mar	 3  07:25  /usr/bin/atq
-r-sr-xr-x   1  root   bin   23040  Mar	 3  07:25  /usr/bin/atrm
-r-sr-xr-x   1  root   bin   28424  Mar	 3  07:25  /usr/bin/crontab
---s--x--x   1  root   uucp  74762  Mar	 6  11:15  /usr/bin/ct
---s--x--x   1  uucp   uucp  83346  Mar	 6  11:15  /usr/bin/cu
-r-sr-xr-x   1  root   bin   29370  Mar	 3  10:44  /usr/bin/df
-r-xr-sr-x   1  bin    sys   11990  Mar	14  12:34  /usr/sbin/fusage
-r-xr-sr-x   1  bin    sys   36068  Mar	 3  01:37  /usr/bin/ipcs
-r-sr-xr-x   1  root   bin   34514  Mar	 3  10:46  /usr/bin/login
-r-xr-sr-x   2  bin    mail  88724  Mar	 3  10:46  /usr/bin/mail
-r-xr-sr-x   1  bin    mail  85034  Mar	 3  10:54  /usr/bin/mailx
-rwsr-xr-x   1  root   sys   8718   Mar	 3  10:44  /usr/bin/newgrp
-r-sr-sr-x   1  root   sys   21154  Mar	 3  10:44  /usr/bin/passwd
-r-sr-sr-x   1  root   bin   24202  Mar	 3  10:46  /usr/bin/ps
-r-xr-sr-x   2  bin    mail  88724  Mar	 3  10:46  /usr/bin/rmail
-rwsr-xr-x   1  root   sys   17526  Mar	 3  10:44  /usr/bin/sacadm
-r-xr-sr-x   1  bin    sys   39508  Mar	 3  02:50  /usr/sbin/sadp
-r-sr-xr-x   1  root   root  35128  Mar	14  13:07  /usr/bin/su
---s--x--x   1  uucp   uucp  78668  Mar	 6  11:15  /usr/bin/uucp
---s--x--x   1  uucp   uucp  36628  Mar	 6  11:15  /usr/bin/uuglist
---s--x--x   1  uucp   uucp  32254  Mar	 6  11:16  /usr/bin/uuname
---s--x--x   1  uucp   uucp  77550  Mar	 6  11:16  /usr/bin/uustat
---s--x--x   1  uucp   uucp  81424  Mar	 6  11:16  /usr/bin/uux
-r-xr-sr-x   1  bin    tty   14438  Mar	 3  10:47  /usr/bin/write
-r-sr-xr-x   1  root   sys   15864  Mar	 3  10:52  /usr/lib/mv_dir
---s--x--x   1  root   bin   26801  Mar	 3  02:46  /usr/lib/pt_chmod
-r-xr-sr-x   1	bin    sys   16682  Mar	 3  02:52  /usr/lib/sa/sadc
-r-sr-xr-x   1	root   sys   23824  Mar	11  01:27  /usr/rar/bin/su
-r-xr-sr-x   1	bin    tty   17488  Mar	 3  10:43  /usr/sbin/wall
-r-xr-sr-x   1	bin    sys   11274  Mar	 3  09:25  /usr/sbin/whodo
#

In this example, the /usr/rar/bin/su should be investigated.

Security Audit

After the system has been fully configured, the system administrator should
perform a check for SETUID/SETGID files and devices on root and /usr using
one of the previous procedures. The output from the check should be saved
on some medium (for example, on a diskette) and printed in hard-copy. The
system administrator should periodically rerun the procedure, compare its
results with the previous output, and investigate changes such as
additions, deletions, or changes in size or date.

[02] =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= [02]
_-_-_-_-_-_-_-_-_-_-_-_-_-_
  Local Digital Switching                                            by: JF
~-~-~-~-~-~-~-~-~-~-~-~-~-~

In the late 1990s in the UK there are really only two types of Switching
systems that are used.  Both are Digital systems which are installed over
the majority of the country.  The Electronic switches (TXEs) which were
used in the passt throughout the country have been slowly replaced by the
newer digital systems which at one time were only installed in the major
cities.  There are two types of Digital Systems which are used at
residential level to deal with the majority of calls, System X and System 
Y which is based on AXE10.  There are however other Digital Systems that
are used to control other networks such as 5ESS which is used for the DDSN
(Digitally Derived Service Network) which controls the 0800/0500/0891
service networks, the freefone numbers, premium rate numbers etc.

System X was the first Digital System to be used in the UK in the larger
cities and was suppose to be installed 100% as the premium Digital System
for the UK but this it deamed unfair that one digital system be able to
take over the market and be installed fully that other companies were
enabled to step in.  One notable company that stepped in was the Swedish
company, Ericsson.  Ericsson had designed and developed a digital system
of switching that was based on System X but highly improved and greatly
technologically advanced.  This was mainly due to the fact that System X
was designed by an Independant committee rather than a company and the
committee were rather slow at producing and releasing their final version
of the switch, which by the time it had been released was already outdated
by AXE10 which had become known as the System Y Digital System. 

The Basic principles of working within the Digital Systems are the same
between the two due to the fact that System Y was based on the original
System X.  The detailed workings within the system are seperated into
particular modules, with each module dealing with a specific function and
a certain stage of the switching process.  It all starts on a local level
with smaller digital exchanges performing tasks which make up the modules
within the system to make sure the processes run smoothly.   

A lot of processes make up for the local level of the system, which is
really the most important part of the system.  The lowest level is where
the meeting point for the lines is formed, these meeting places are called
Remote Concentrator Units (RCUs), these are where a very large number of
lines meet and basically form your locally telco depot.  The step up from
RCUs are the Digital Local Exchanges (DLEs) which host all the RCUs in the
area and form for a much wider distribution area, say, over the area of
quite a few miles.  The wide distribution of these DLEs into smaller
areas, with the use of RCUs makes for a much more organised and proficient
system of switching and exchange. 

The higher level switching of calls is dealt with by the Digital Switching
Unit (DSU) which deals with a high volume of calls in an area, for
example, the size of a large city.  The Digital Switching Units then
distibution the switching of calls to the smaller Digital Main Switching
Unit (DMSU) which controls the switching of calls on a smaller level and
delegates calls even further down the scale to the Digital Local Switching
Units (DLSUs) which forms the basis of call switching by making sure it
reaches its destination by setting the call along to the right connections
and Subsystem.

A few important factors effect whether a call is switched to its
destination perfectly.  The main factor relies on the Call Processing
Subsystem (CPS) which takes overall control over a local line, registering
its state whether engaged, free or otherwise out of order.  This function
is very sophisticated and a fundamental part of the digital exchange as it
is needed to ensure that harmony is achieved among the fonelines.  The
next needed function, or module, is Common Channel Signalling (CCS) which
is the process British Telecom (BT) use to reserve a speech channel for
switching and to enable the lines to coherently exist without cross-overs
etc, this is therefore the standard form of signalling on any digital
system and is used successfully in countries that make use of a digital
system of switching.  Although BT have produced a method of packet cutting
for signalling the voice along the channels to ensure perfect arrival.
They use a method called Pulse Code Modulation (PCM) to cut down voice
into smaller packets sending them down the channels, several calls are cut
at the sent time and sent seperatly without confusion, as the modulation
is programmed to be sensitive enough to control the lines and the 
differences between each without any problems.

When all the modules that make up the Digital System are combined and put
into functional order they work in harmony automatically with no problems
and with great efficiency.  If one module fails, the whole process fails,
each module relies on another and they all deem equal importance in the
system.

I hope this text has enabled you to grasp the concepts of the UK Digital
Systems of Switching and Signalling at the local level.  More texts can be
found on the Linenoise website addressing other issues within the UK fone
system.

[03] =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= [03]
_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
  GSM System Security Study                                  by: David Dane
~-~-~-~-~-~-~-~-~-~-~-~-~-~-~

Article 1

[David: Note that all the Figures and Pictures meaned in this article are
not included with this Article, that's because I didn't get them with the
Article. Sorry.]

                                          Overview of GSM Security Features

The object of this part of the report is to provide an overview of the
security features in the GSM system. The description is brief, and focuses
on the algorithms which are needed and how they are to be used: for a more
detailed description the reader is referred to the GSM recommendations GSM
02.09 and GSM 03.20.

Three distinct security services are provided. These are subscriber
identity authentication, user and signalling data confidentiality, and
subscriber identity confidentiality. Each of these is considered in turn,
and the mechanisms used to provide them outlined. Actually the second of
the services is a grouping of three GSM features: user data confidentiality
on physical connections, connectionless user data confidentiality and
signalling information element confidentiality. The reason for combining
them into one service is that they are all provided by one and the same
mechanism.

                                         Subscriber Identity Authentication

This subscriber identity authentication service is the heart of the GSM
security system. It is used to enable the fixed network to authenticate the
identity of mobile subscribers, and to establish and manage the encryption
keys needed to provide the confidentiality services. The service must be
supported by all networks and mobiles, although the frequency of
application is at the discretion of the network.

Authentication is initiated by the fixed network, and is based upon a
simple challenge-response protocol. When a mobile subscriber ( MS )
attempts to access the system, the network issues it a random challenge
RAND. The MS computes a response SRES to RAND using a one-way function A3
under control of a subscriber authentication key Ki. The key Ki is unique
to the subscriber, and is shared only by the subscriber and an
authentication centre which serves the subscriber's home network. The
value SRES computed by the MS is signalled to the network, where it is
compared with a pre-computed value. If the two values of SRES agree, the
mobile subscriber has been authenticated, and the call is allowed to
proceed. If the values are different, then access is denied.

The same mechanism is also used to establish a cipher key Kc for encrypting
user and signalling data on the radio path. This procedure is called cipher
key setting. The key is computed by the MS using a one-way function A8,
again under control of the subscriber authentication key Ki, and is pre-
computed for the network by the authentication centre which serves the
subscriber's home network. Thus at the end of a successful authentication
exchange, both parties possess a fresh cipher key Kc.

The pre-computed triples ( RAND, SRES, Kc ), held by the fixed networks for
a particular subscriber, are passed from the home network's authentication
centre to visited networks upon demand. The challenges are used just once.
Thus the authentication centre never sends the same triple to two distinct
networks, and a network never re-uses a challenge.

In practice the two functions A3 and A8 are combined into a single
algorithm, called A38, which is used to simultaneously compute SRES and
Kc from RAND and Ki. In this report this combined algorithm is referred to
as the authentication algorithm. The protocol described above makes it
quite clear that this algorithm need only be available to an authentication
centre and the mobile subscribers which that authentication centre serves.
In particular, there is no need for a common GSM authentication algorithm;
different networks may use different algorithms. ( The algorithms do,
however, need to have the same input and output parameters; in particular,
the length of Kc is determined by the GSM cipher algorithm ).
Never-the-less it is desirable that there is a GSM standard authentication
algorithm which may be used by all networks which do not wish to develop a
proprietary algorithm. There is just one candidate for such an algorithm;
it was proposed by the German administration, and is analysed in Part VI
of this report.

                                   User and Signalling Data Confidentiality

As mentioned earlier, this service consists of three elements; user data
confidentiality and signalling information on physical connections,
connectionless user data confidentiality and signalling information element
confidentiality. The first element provides for privacy of all user
generated data, both voice and non-voice, transferred over the radio path
on traffic channels. The second element provides for privacy of user data
transferred in packet mode over the radio path on a dedicated signalling
channel, whilst the third element provides for privacy of certain user
related signalling elements transferred over the radio path on dedicated
signalling channels.

All of these elements of service are provided using the same layer 1
encryption mechanism, and must be supported and used by all networks and
mobiles. The mechanism is now briefly described. Encryption is achieved
by means of a ciphering algorithm A5 which produces a key stream under
control of a cipher key Kc. This key stream is then bit-for-bit
exclusive-or'd with the data transferred over the radio path between the
MS and the base station ( BS ). The cipher key is established at the MS
as part of the authentication procedure, as described in the last
section, and is transferred through the fixed network to the BS after the
MS has been identified.

It is essential that the MS and BS synchronise the starting of their
cipher algorithms. A technique for achieving this is described a
different text, but this only directly addresses the situation when the
network initiates an authentication check. The procedures still need to
be specified in detail to cover the situation when the network does not
authenticate the MS. When the network intends to issue an authentication
challenge, the BS starts deciphering all data immediately after the MS
has been identified using the cipher key Kc which the MS will derive
upon receipt of the challenge RAND. The MS starts ciphering and
deciphering the moment it has computed Kc ( and SRES ) from RAND, as
described in the last section, and before SRES is transmitted. On the BS
side, enciphering starts as soon as SRES has been received, deciphered
and found to be correct. To cope with possible transmission loss or
errors, the authentication request and response message are repeated
under the control of timers.

Synchronisation of the ciphering key stream is maintained by using the
TDMA frame structure of the radio sub-system. The TDMA frame number
is used as a message key for the cipher algorithm AS, and the algorithm
produces a synchronised key stream for enciphering and deciphering the
data bits in the frame. For each frame, a total of 114 bits are produced
for enciphering / deciphering data transferred from the MS to the BS, and
an additional 114 bits are produced for deciphering / enciphering data
received at the MS from the BS. A frame lasts for 4.6 ms, so that the
cipher has to produce the 228 bits in this time.

The cipher algorithm A5 must be common to all GSM networks, and three
algorithms have been proposed as candidates for the GSM standard: a
French algorithm, a Swedish algorithm and a UK algorithm. These
algorithms are discussed in detail in subsequent parts of this report.

                                        Subscriber Identity Confidentiality

This service allows mobile subscribers to originate calls, update their
location, etc, without revealing their International Mobile Subscriber
Identity ( IMSI ) to an eavesdropper on the radio path. It thus prevents
location tracing of individual mobile subscribers by listening to the
signalling exchanges on the radio path. All mobiles and networks must be
capable of supporting the service, but its use is not mandatory.

In order to provide the subscriber identity confidentiality service it is
necessary to ensure that the IMSI, or any information which allows an
eavesdropper to derive the IMSI, it not ( normally ) transmitted in clear
in any signalling message on the radio path. The mechanism used to provide
this service is based on the use of a temporary mobile subscriber identity
( TMSI ), which is securely updated after each successful access to the
system. Thus, in principle, the IMSI need only be transmitted in clear
over the radio path at registration. In addition, the signalling elements
which convey information about the IMSI are enciphered as described in
the last section.

The TMSI updating mechanism functions in the following manner. For
simplicity, assume the MS has been allocated a TMSI, denoted by TMSIo,
and the network knows the association between TMSIo and the subscriber's
IMSI. The MS identifies itself to the network by sending TMSIo.
Immediately after authentication ( if this takes place ), the network
generates a new TMSI, denoted TMSIn, and sends this to the MS encrypted
under the cipher key Kc as described in the last section. Upon receipt of
the message, the MS deciphers and replaces TMSIo by TMSIn.

                                         The French Proposal for the Cipher

The cipher proposed by France has always been considered as a hardware
rather than a software algorithm. The study of this cipher is based on the
description reproduced in Appendix A and described in PDL ( program
definition language ) in Section 4. Software and hardware implementations
of the cipher are considered in Sections 5 and 6. The statistical tests
applied are discussed in Section 71 and there is a mathematical analysis
in Section 8.

                                             PDL Description of the Cipher

Main Algorithm

( Load Base Key )
FOR each base key bit from 1 to 64
    Load bit into corresponding LFSR cell
END FOR


( Load Message Key )
FOR each message key bit from 1 to 22
    shift_bits = f()         ( Call to shift function f )
    FOR each register i, from 1 to 3
        Exclusive-or message key bit into lsb
        IF bit i of shift_bits is set
          THEN Shift
        END IF
    END FOR
END FOR

( Produce both enciphering and deciphering streams )
FOR i from 1 to 2


    ( Perform additional shifts )
    FOR j from 1 to 100
        shift_bits = f()
        FOR each register k from 1 to 3
            IF bit k of shift_bits is set
              THEN Shift
            END IF
        END FOR
    END FOR

    ( Output stream of 114 bits )
    FOR J from 1 to 114
        shift_bits = f()
        FOR each register k from 1 to 3
            IF bit k of shift_bits is set
              THEN Shift
            END IF
        END FOR
        Output = Exclusive-or msb of all three registers
    END FOR
END FOR


	The Shift Function f


BEGIN FUNCTION f

    FOR each register i from 1 to 3
        Let middle[i] = the 'middle' bit of register i
    END FOR

    IF less than two of the 'middle bits' are '1'
      THEN bit-complement code
    END IF

    RETURN code

END FUNCTION

                                                         Software Estimates

In this section the cipher is described in a readable form similar to
microprocessor instruction code and an estimate of the speed is made from
this. It was suspected that it would not be practical to implement this
code in software, so the code was based on a very specialized
microprocessor, which may not even exist. If the cipher can not meet the
time requirement of 4.6ms on the specialized microprocessor then it will
not be able to meet it on a more general one. This special microprocessor
has a word size5 at least as long as the longest register, i.e., 23 bits,
it also has the function PARITY6 which exclusive-ors all the bits in the
accumulator and places the result in the least significant bit while
setting all the other bits to zero. Additionally it is assumed that the
CARRY can be loaded from the least significant bit of the accumulator. The
problem of directing the feedback bit to the appropriate part of the
accumulator is ignored.

The external memory, considered to be arranged so that REG contains the
registers and MASK contains bit masks for both the extraction of the
central bits of each register and for the calculation of the feedback
values, with the feedback masks last and in reverse order.

     The symbol & is used to mean 'address of'


     Evaluating the Shift Function f


The following code extracts the central bits of each register and
calculates the corresponding output of the shift function f.


Load registers and masks

        LOAD    index register 1 with &REG
        LOAD    index register 2 with &MASK

    5 Word size is considered here to be the natural size or accumulator
      and memory 'portions'.
    6 Which will be considered as an ALU operation

Extract middle bits of each register

LOAD    acc with MEM(index 1), POST INC index reg 1
AND     acc with MEM(index 2), POST INC index reg 2
PARITY  acc
STORE   acc in M1
LOAD    acc with MEM(index 1), POST INC index reg 1
AND     acc with MEM(index 2), POST INC index reg 2
PARITY  acc
STORE   acc in M2
LOAD    acc with MEM(index 1), POST INC index reg 1
AND     acc with MEM(index 2)
PARITY  acc
STORE   acc in M3

Calculate shift function f

XOR     acc with M2
AND     acc with M1
STORE   acc in I

LOAD    acc with M2
AND     acc with M3
OR      acc with I

XOR     acc with M1
STORE   acc in M1
LOAD    acc with I
XOR     acc with M2
STORE   acc in M2
LOAD    acc with I
XOR     acc with M3
STORE   acc in M3


Loading the data itself requires:

     2 index register operations  k cycles each

Extracting the middle bits of each register requires:

     6 index register operations  @ k cycles each
     3 ALU operations             @ m cycles each
     3 load / store operations    @ n cycles each

The function f requires:

     7 ALU operations             @ m cycles each
     8 load / store operations    @ n cycles each

This part of the code requires 8k + 10m + 11n cycles per iteration

                                                      Performing the Shifts

The following code clocks the appropriate registers using the results of
the shift function. Note that the values of M1, M2 and M3 determine whether
or not each register is clocked. Note also that the registers are treated in
reverse order since index register 1 'points' to the contents of shift
register 3 at this stage.

LOAD    acc with M3
BRANCH  if zero to A
LOAD    acc with MEM(index 1)
AND     MEM(index 2) to acc
PARITY  acc
STORE   acc in CARRY
ROTATE  acc right through CARRY
STORE   CARRY in 03
STORE   acc in MEM(index 1)

A:
DEC     index register 1
DEC     index register 2

LOAD    acc with M2
BRANCH  if zero to B
LOAD    acc with MEM(index 1)
AND     MEM(index 2) to acc
PARITY  acc
STORE   acc in CARRY
ROTATE  acc right through CARRY
STORE   CARRY in 02
STORE   acc in MEM(index 1)

B:
DEC     index register 1
DEC     index register 2

LOAD    acc with M1
BRANCH  if zero to C
LOAD    acc with MEM(index 1)
AND     MEM(index 2) to acc
PARITY  acc
STORE   acc in CARRY
ROTATE  acc right through CARRY
STORE   acc in MEM(index 1)

C:
LOAD    acc with CARRY
XOR     acc with 03
XOR     acc with 02
OUTPUT  acc

To estimate the speed it is assumed that 9/4 of the registers are clocked
on each iteration, i e., that 3/4 of the operations to shift the registers
are performed for each iteration.

Shifting the registers requires:

     3 branch operations           @ j cycles each
    13 index register operations   @ k cycles each
     6 ALU operations              @ m cycles each
     8 load / store operations     @ n cycles each

The calculation of the output bit requires a further:

     2 ALU operations              @ m cycles each
     1 load / store operation      @ n cycles

Therefore, the clocking requires a total of.
     
  3/4 x (3j + 13k + 6m + 8n) + 2m + n = 9/4j 39/4k + 13/2m + 7n cycles
     per iteration.

The data loading and shift function calculation requires a further
8k + 10m + 11n cycles per iteration.

Therefore the total number of cycles required is given by:

  9/4j + 71/4k + 33/2m + 18n

For typical values of j = k = 5 and m = n = 4 this gives
11.25 + 88.75 + 66 + 72 = 238 cycles per iteration.

The algorithm must be iterated 450 times to produce 228 bits of output.
This corresponds to ~~ 450 x 238 = 107100 clock cycles to produce 228
bits. On a 1ms microprocessor this would take approximately 107 ms.

                                                                    Summary

These estimates show that even on a specialized microprocessor, and
ignoring some of the detail, this cipher can not operate at the required
speed. It is therefore reasonable to assume that it would not be viable to
implement this cipher in software on a more general microprocessor.

In light of the unsuitability of this algorithm the memory requirement was
not estimated.

                                                         Hardware Estimates

The following estimates are based on the two Figures 2. and 3. Only the
hardware necessary for the shift registers and the shift function f is
considered, i.e., none of the control, interfacing or test circuitry is
studied here. The overall architecture is shown in Figure 1.

The transistor counts for various components are based on the Racal
Research Ltd., 2.5 mm CMOS microcell library.

Figure 1: Overall Architecture

     Notation

The elements of the circuits in Figures 2 and 3 are shown as boxes marked
with various symbols as described in the following table.

  ______________________________________
  Symbol    Function
  ______________________________________

  MUX       Multiplexor
  .
  _         Exclusive-or gate
  .

  -         Exclusive-nor gate
  .

  .         And gate

  +         Or gate

  Unmarked  D-type, i e., register stage
  ______________________________________
  [Symbols partly illegible]

All the signals shown are single bits. However. the various "Load
Control" signals in Figure 2 are different signals which control
different parts of the loading mechanism.

   Shift Registers

Figure 2 shows the register R1. The number of exclusive-or gates necessary
for each register depends upon the feedback function for that particular
register; in total seven such gates are needed for the three registers.

Figure 2: Shift Register Architecture for R1
   [Poor original]

To load the base key, the registers are concatenated together and the key
is shifted through, suppressing the output so that the key does not
reappear again. To load the message key the key bits are exclusive-or'd
into the feedback path. In ordinary operation the feedback path is fed
back to the left hand cell without obstruction. In order to implement this
a multiplexor is used to chose between the feedback and input, while an
and gate is used to suppress the external input to the exclusive-or on
the feedback path when it is not required. The overall components
together with their respective transistor counts are:

    64  D-types            @ 22 transistors each  =  1408 transistors
    6   2-input AND gates  @ 6 transistors each   =    36 transistors
    10  XOR gates          @ 10 transistors each  =   100 transistors
    3   2-input MUXs       @ 12 transistors each  =    36 transistors
                                                     1580 transistors

An additional two exclusive-or gates are required to combine the output of
the three registers, each requiring 10 transistors. This gives a total of
1600 transistors to implement the shift register.

     Shift function f

The shift function is implemented by producing a signal comp which is true
if the three bits M1, H2 and M3 need to be inverted. Th;s signal is the
exclusive- ored with each of the three original bits to effect the
inversion. If the three bits are regarded as numbers, then comp is true
if and only if their sum is greater than or equal to 2. Thus, if the three
bits are fed into a full adder, then comp is the negation of the carry
out signal. The equation for this carry out signal is:

                                        .
                                M1 .(M2 - M3) + (M2 . M3)
                                        .

which was also employed above. This is shown in Figure 3. Rather than
inverting this value, and then using exclusive-or gates, exclusive-nor
( XNR ) gates are used.

Figure 3: Shift Function f Architecture
   [Poor original]

This requires:

     2  AND gates  @ 6 transistors each   =  12 transistors
     1  OR gate    @ 6 transistors each   =   6 transistors
     1  XOR gate   @ 10 transistors each  =  10 transistors
     3  XNR gates  @ 10 transistors each  =  30 transistors
                                             48
In addition three further And gates are required to combine the output of
the shift function with the clock signal, see Figure 1.

The total number of transistors required is 1600 + 48 + 18 = 1666.

                                                            Speed Estimates

In order to produce the two 114-bit key streams the shift registers have to
be shifted the following number of times:

     64   : to load the base key
     22   : to load the message key
     100  : intermediate shifts
     114  : to produce the encrypt stream
     100  : intermediate shifts
     114  : to produce decrypt stream
     514

If these shifts take two clock cycles each then 1028 clock cycles would be
required. At a clock speed of 50ns per cycle then it would take 51.4ms to
produce the key streams from the keys, which is well within the requirement.

                                                                    Summary

A hardware implementation of this cipher requires a relatively small number
of transistors. approximately 1666. If the base key was loaded in parallel
then the circuitry would be more complex, however, given the speed estimate
above it is unlikely that this would be necessary.

These estimates suggest that it should be possible to produce a hardware
implementation of this cipher which meets the speed requirement using a
relatively small number of transistors.

                       The German Proposal for the Authentication Algorithm

The authentication algorithm need not be universal and different networks
are free to use algorithms of their own choice ( provided that the
parameters are of the correct length ). However, there will be a GSM
standard which can be used by any administrations who do not wish to
develop their own proprietary algorithms. The AEG have already decided
to recommend the German proposal also referred to as COMP128 in some
literature for this purpose. This algorithm was included in the study in
order to assess its suitability for the task. The algorithm is specified
in [8]. which is reproduced in Appendix D ( with the exception of the
details of the tables ).

The functionality of the algorithm is described in PDL ( program
definition language ) in Section "PDL Description of the Algorithm"
below. Using this description an estimate for the complexity of a
software implementation is made in Section "Software Estimates" below.
This algorithm will eventually be implemented in the Subscriber Interface
Module ( SIM )1 which will be either a smart card or plug-in module.
Both options for the SIM contain a microprocessor thus the authentication
algorithm will be implemented in software rather than hardware. Therefore
no hardware estimates were made for this cipher.

                                           PDL Description of the Algorithm

( Load RAND into last 16 bytes of input )
FOR i from 16 to 31
    x[i] = rand[i]
END FOR

( Loop eight times )
FOR i from 1 to 8

    ( Load key into first 16 bytes of input )
    FOR j from 0 to 15
        x[j] = key[j]
    END FOR

    ( Perform substitutions )
    FOR j from 0 to 4
        FOR k from 0 to 2j - 1
            FOR l from 0 to 24-j - 1

                m = 1 + k x 25-j
                n = m +24-j

                y = (x[m] + 2 x x[n]) mod 29-j
                z = (2 x x[n] + x[n]) mod 29-j

                x[m] = table [j,y]
                x[n] = table [j,z]

            END FOR
        END FOR
    END FOR

    ( Form bits from bytes )
    FOR j from 0 to 31
        FOR k from 0 to 7
            bit [4*j+k] = the (8-k)th bit of byte j
        END FOR
    END FOR

( Permutation but not on the last loop )
    IF (i < 8) THEN
        FOR j from 0 to 15
            FOR k from 0 to 7
                next bit = (8 x j + k) x 17 mod 128
                Bit k of x[j + 16] = bit[next_bit]
            END FOR
        END FOR
    END IF

END FOR

At this stage the vector x[ ] consists of 32 nibbles. The last 8 of these
are taken as the output SRES.

                                                         Software Estimates

In order to estimate the complexity of a software implementation of the
German authentication algorithm, it has been described in a readable form
similar to microprocessor instruction code. This code is then used as a
basis for the estimates.

Assume that the external memory is arranged as follows:

TAB     contains the compression tables.
KEY     contains the 128-bit key.
SRES    is 256 bits of external memory used to store the
        intermediate and final values - assuming that the
        last 16 bytes have been initialised with RAND.
TEMP    is 16 bytes of external memory available as working space.

The symbol & is used to mean 'address of'.

                                                              Substitutions

The following code performs the substitutions using the tables. Note that
the indices of the j, k and l loops run 'downwards' for reasons of
simplicity of coding. The corresponding PDL segment is

   FOR j from 4 to 0 step -1
       FOR k from 24-j - 1 to 0 step -1
           FOR l from 2j-1 to 0 step -1
               m = 2j -1 - 1 + (24-j - k - 1)x (2j+l)

Code to Perform the Substitutions

LOAD   index register 2 with &SRES
LOAD   acc with 8
STORE  acc with I

( Top of I loop )
I:
LOAD   acc with 16
STORE  acc in J

( Load key into first 16 bytes )
A:
LOAD   index register 1 with &KEY
LOAD   acc with MEM(index 1), POST INC index reg 1
STORE  acc in MEM(index 2), POST INC index reg 2
LOAD   acc with J
DEC    acc
STORE  acc in J
BRANCH if not zero to A

( Perform substitutions )
LOAD   acc with 5
STORE  acc in J

( Top of J loop )
J:
DEC    acc
STORE  acc in J
STORE  acc in X
LOAD   acc with 1
STORE  acc in T1
LOAD   acc with 16
STORE  acc in T2
LOAD   acc with X
BRANCH if zero to C

B:
LOAD   acc with T1
SHIFT  acc LEFT
STORE  acc in T1
LOAD   acc with T2
SHIFT  acc RIGHT
STORE  acc in T2
LOAD   acc with X
DEC    acc
STORE  acc in X                 ( T1 = 2**j )
BRANCH if not zero to B         ( T2 = 2**(4-j) )

C:
LOAD   acc with T2
STORE  acc in K

( Top of K loop )
K:
DEC    acc
STORE  acc in K
LOAD   acc with T1
STORE  acc in L                 ( L = 2**j )

( Top of L loop )
L:
DEC    acc
STORE  acc in L
LOAD   acc with T2
SUB    K from acc
DEC    acc
STORE  acc in M
LOAD   acc With J
INC    acc
STORE  acc in X

D:
LOAD   acc with M
SHIFT  acc LEFT
STORE  acc in M
LOAD   acc with X
DEC    acc
STORE  acc in X                 ( M = (2**(4-j)-K-1)
BRANCH if not zero to D              * 2**(J+1) )
LOAD   acc with M
ADD    T1 to acc
SUB    L from acc
DEC    acc
STORE  acc in M                 ( M = M+(T1-L-1) )
ADD    T1 to acc
STORE  acc in N                 ( N = M + T1 )
LOAD   index register 1 with &SRES
LOAD   acc with M
ADD    acc to index register 1
LOAD   acc with MEM(index 1)
STORE  acc in XM                ( XM = X[M] )
LOAD   index register 1 with &SRES
LOAD   acc with N
ADD    acc to index register 1
LOAD   acc with MEM(index 1)
STORE  acc in XN                ( XN = X[N] )
SHIFT  acc LEFT
ADD    XM to acc
SHIFT  acc LEFT                 ( Lose last bit of Y )
SHIFT  acc RIGHT
STORE  acc in Y                 ( Y = XM + 2*XW )
LOAD   acc with XM
SHIFT  acc LEFT
ADD    XN to acc
SHIFT  acc LEFT
SHIFT  acc RIGHT
STORE  acc in Z                 ( Z = 2*XM + XN )
LOAD   index register 2 with &INDX
LOAD   acc with I
ADD    acc to index register 2
LOAD   acc with MEM(index 2)
STORE  acc in P
LOAD   index register 2 with &TAB
ADD    acc to index register 2  ( Point to correct
LOAD   acc with Z                 table using INDX )
ADD    acc to index register 2
LOAD   acc with MEM(index 2)
STORE  acc in MEM(index 1)      ( table[Z] -> X[N] )
LOAD   index register 1 with &SRES
LOAD   acc with M
ADD    acc to index register 1
LOAD   index register 2 with &TAB
LOAD   acc with Y
ADD    acc to index register 2
LOAD   acc with P               ( Point to correct
ADD    acc to index register 2    table using INDX )
LOAD   acc with MEM(index 2)
STORE  acc in MEM(index 1)      ( table[Y] -> X[M] )
( Bottom of L )
LOAD   acc with L
BRANCH if not zero to L
( Bottom of K )
LOAD   acc with K
BRANCH if not zero to K
( Bottom of J )
LOAD   acc with J
BRANCH if not zero to J
LOAD   acc with I
DEC    acc
STORE  acc in I
DEC    acc                       ( No permutation
BRANCH if zero to Z                if I = 1 )

[04] =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= [04]
_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
  Disrupting DSU Satellites                                   by: optiklenz
~-~-~-~-~-~-~-~-~-~-~-~-~-~-~

overloading a remote satellite 651 dsu/csu station
assuming the satellite is run using T1/FT1 Frame Relay
services

Exploiting outdail frq service

Line Rate
                  Internal or external clock; 1.544 Mbps +/- 50 bps.
                  When timing is derived from input signal: 1.544 Mbps +/-
                  200 bps.
                  Output line rate follows input line rate.

There are 2 ways of exploiting the service one is being directly connected
and the other declining known digital frq's (frequencies)

The satellite's line code is AMI, B8ZS (B8ZS set as default) In order
to remotely change this you need to establish a direct connection
to the satellite module wether the connection be one that is idle
or accepted as a trusted user.  Using a binary overload method via 
terminal connection you can change the line code 2 different numeric 
values.  This will cause the dsu connection to send out differnt frq's
to other stations causing an over load in data.  The time it takes
to throw the station offline depends on how many communicated systems
there are.

Terminal Binary method:

Input Level DS-1 from 0 dB to -27.5 dB q=]
aCe;  qPer TR6241=] 
q=]

If you are prompted with  "DSU:" tpye /DS-1 from 0 dB%per to -27.5 dB as
0 is default

Using T1/FT1 to overload DSU module:

*********************************
====Compatibility===============
*********************************
 
      (+AT&T+)
 
     | TR 54016-1989 |
     | TR 62411-1990 |
     | TR 54019A     |
     |  PUB 43802    |

You can run a remote loop back test by using 
00.6000 as a default frq than running a 
Data port loopback test via remote terminal
connection.  All you need is a #. They probably
won't figure how this happend so once they've 
fixed things all you have to do is dailup
and do it again.

I should have my DSU satellite prefix scanner 
out for the next zine

[05] =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= [05]
_-_-_-_-_-_-_-_-_-_-_-_-_
  Playing with Loopback                                           by: ralph
~-~-~-~-~-~-~-~-~-~-~-~-~

This article is going to be fairly simple and I'm not going to get to deep
into how this shit works because it's easy to find out, and really, this
entire little trick is completely useless:)  Anyways here we go... Have
you ever wanted to BE the whitehouse computer? or the FBI computer? Or
any other computer for that matter? Well heres how you can, sorta.  This
is really easy, theres two programs youll be using to do this, 'ifconfig'
and 'route', both of which are network configuration tools.  Read ROUTE(8)
and IFCONFIG(8) if you wanna know more about them than what I tell you
here.  In a nutshell, ifconfig is used to setup a new network device,
and assign it an IP address, and route is used to setup network routes
for your computer.  All a route is, is the route a packet will travel to
get from point A to point B.  If you type ifconfig, right now, it will
most likely have two interfaces shown, depending on your situation.  If
you use a dialup and havn't messed around with the route tables, it will
probably show 'lo' and 'ppp0'.  If your on an ethernet or a cable modem
etc... you will have an 'eth0' there.  If you type route, right now,
there will be several routes setup, one of them being for your local
loopback.  It should look something like this..

loopback     *          255.0.0.0     U     0      0        0 lo

The command that enters this route into the kernel route table is in
/etc/rc.d/rc.inet1 on linux systems, it reads '/sbin/route add -net
127.0.0.0 netmask 255.0.0.0 lo' **NOTE: 127.0.0.1 is overrated, as you can
see here, the netmask 255.0.0.0 is used, so you can use
127.whatever.whatever.whatever for the same effect as 127.0.0.1** So the
first thing we have to do is take that route out of the kernel routing
table.  To do this we enter ' /sbin/route del -net 127.0.0.0 netmask
255.0.0.0 lo' again, a complete syntax can be found in the man page, but
you'll just have to trust me for now.  After you've done that type 'route'
to make sure the route is out of the routing table.  Next thing we have to
do is take down the 'lo' interface.  To do this type 'ifconfig lo down'
this takes DOWN the lo interface.  Type 'ifconfig' to make sure the
interface is gone.  Now we have to chose who we want to be.  Let's use
whitehouse.gov as an example.  We nslookup whitehouse.gov to find it's IP
address (198.137.241.30) and we then create the 'lo' interface and assign
it the whitehoust.gov IP address (198.137.241.30).  To do this we type
'ifconfig -a lo 198.137.241.30', now type 'ifconfig' to make sure the
interface was created, and with the correct IP address in the inet addr:
field.  Now we have to add a route that says "anything outbound towards
whitehouse.gov (198.137.241.30) should be redirected to the local
loopback".  To do this we type 'route add -host 198.137.241.30 lo', type
'route' to make sure the route entered the routing table.  If it did, your
pretty much all set.  Make sure telnet is enabled on your mashine and
'telnet whitehouse.gov' and watch it connect to your mashine.  Next thing
you'll want to do for convinience is to open /etc/hosts in a text editor
and change the line that says... 
127.0.0.1  localhost
to say...
198.137.241.30  localhost
That way localhost means YOUR MASHINE instead of 127.0.0.1.  Now if you
decide you want to KEEP your computer this way there are some other things
you must do as well, otherwise next time you reboot everything will go
back to normal.  Open /etc/rc.d/rc.inet1 in a text editor, and change the
following lines...
# Attach the loopback device.
/sbin/ifconfig lo 127.0.0.1
/sbin/route add -net 127.0.0.0 netmask 255.0.0.0 lo
to say...
/sbin/ifconfig -a lo 198.137.241.30
/sbin/route add -host 198.137.241.30 lo
And that should pretty much do it, of course you could have just edited
/etc/hosts to say 127.0.0.1  whitehouse.gov but then you can only use the
HOST NAME and plus it's more fun this way:)  bye.

[06] =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= [06]
_-_-_-_-_-_-_
  Active X                                                      by: Defiant
~-~-~-~-~-~-~

ActiveX poses many security dangers to people, especially as you cannot
tell what something is before you click on it most of the time. ActiveX
really is OLE, and Microsoft has repeatedly stated this. ActiveX / OLE
is basically a Windows software component, this means that an ActiveX
component is a Windows program that can be distributed from a web page,
such as this. 
ActiveX components also have the same control over your computer as a
normal windows program, complete. If i wanted it would be possible to
create an ActiveX component that could install backdoored Windows DLL
files so that I could have complete control over your computer, or even
write one which could format your hard drive. 

Most people thought that if someone signs with an AththentiCode is means
its safe, but all it does is attempts to identify who signed it. Anyone
can go out and get a code signature, all you need do it go to a page,
fill in a few details, that could be totally fake, and you will soon
receive your own code signature. This is one of the major problems, the
code signature is like sticking a label on a bomb, with anyone's name on
it.

ActiveX poses a little more of a security threat that a downloaded program
you run. When you download a program, you have the choice to install it,
and run a virus scanner before you even run it, but with ActiveX you don't
have this choice. Once you click you give full control of your computer
over. All that happens is a little scary dialogue box, that you have just
clicked on before and nothing dangerous happened. 

As a demonstration of how ActiveX can control your computer there is an
ActiveX component called exploder here for you to see. Exploder performs
a clean shut down of Windows 95 from a web page. Computers which include
power conservative BIOS, may also find that the power is shut of too after
shutdown. What this does is use an API function ExitWindowsEx() with the
flags EWX_SHUTDOWN and EWX_POWEROFF set, which is the same as using the
shutdown menu item in the start menu. 

If you wish to see a demonstration of exploder you can. I haven't signed
it due to the legal problems the original author has experienced. If you
wish to see if you need to set the security options in internet explorer
to medium and then follow the demonstration link. I take nor the original
author take any responsibility for what happens, it is used at your own
discretion.

[07] =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= [07]
_-_-_-_-_-_-_-_-_-_-_-_
  Windows with Sockets                                         by: Sreality
~-~-~-~-~-~-~-~-~-~-~-~

 Winsock 2
  -------
        Winsock has been laughed at in the past as the most pathetic
sockets implementation out there.. Among its faults is the fact that
you cant do IP header inclusion.. And, unfortunatly, you still cant.

        However, with the advent of winsock 2, you can make applications
that have almost the same syntax that of thier unix couterparts (at least
with the socket coding)...

        For instance, you have integer socket handle numbers now, rather
than a class. And most socket commands have the same input arguements, but
the function name is different.
(example: write(int sockfd, void* data, int size) ->
          send(int sockfd, void* data, int size, int flag))

        As you can see, its bascially the same command. They both send data
to an open client socket.. This facilitates porting of your unix sockets
applications to a windows 95+ environment.. "So What", you say.. well,
for that, I have no answer, but at least its now an option that you might
not have had if you'd learned all unix/berkley sockets programming, and
dont have the time to learn new implementations.. for me, winsock 2 is a
welcome development, and I hope to see more exploits and the like coded,
if not for windows, with macros or #ifdef's with windows code..

  Cygnus/w32
   --------
        Another option for the unix coder moving to windows, is the
cygnus w/32 suite available from www.cygnus.com, its a free port of the GCC
compiler and headers for making win-32 apps and porting unix programs to
the windows domain.. rather than facilitating windows styles under unix, it
does the oposite. In fact, most applications will work as they are, with
minimal to no modification, making this application suite one of the better
unix/windows porting suites out there..

        "Whats wrong with it?" you say, well.. I'll tell you.. it still
doesnt support IP header inclusion nor RPC support either. Therefore
(for the lamerz) you cant port exploits like statd, or some spoofers..
However, even with its faults, it purposes many options to the avid unix
exploit coder, who maybe in windows, and doesnt feel to reboot to goto a
unix or whatever. Fact being, to me, its a welcome package, and I hope to
see it support everything that the gcc/unix package supports.

  Wrap Up
    ----
        In the end, windows has the ability to be another choice for
the hackers of the internet.. and with the fact that windows has no
multiuser support, in the way of telnet in and shells, etc etc.. you can
remain "un-0wn'd" while continuing your 'sploits against other machines..
don't get me wrong, I dont wanna see windows flourish, however, with a few
modifications, it can prove quite useful.. Maybe someone aughta write a
replacement winsock dll with support for IP header inclusion... (*ahem*)..

P.S. This shit was written by a true procrastinator, therefore it was
written very quickly.. so don't complain, aiight ;)

[08] =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= [08]
_-_-_-_-_-_-_-_-_-_-_
  Life of a Wingate                                     by: sektor/matsonic
~-~-~-~-~-~-~-~-~-~-~

It all starts with little Bobby Joe Lamer scanning for wingates
on his shitty ass 14.4 going at 1 ip per hour.. he is really el8
becuase he has this wingate scanner he got from rootshell that
doesnt do shit but sit there becuase it uses stream sockets.

ok. after about a month the class-b he scanned is finished and he 
got about 100 wingates out of it.. pretty neat eh?

"OK! now its time to distribute these fuckers and use them all up!",
Bobby Joe said. As you can see he doesnt seem like the type of person who
wants to use a wingate for real purposes.

So.. Bobby Joe Lamer sits on irc in #2600 and gives out all his wingates
to a bunch of script kiddies who think they are leet putting clones on
wingate proxies. Within minutes, half of #2600 and then soon other
channels thoughout irc are filled with anxious lamers on Bobby's wingates.

The next week or two the 100 wingates that Bobby has is now narrowed down
to about 20. All of the lamers trying to use them to get on irc are
having no luck because they just so happen to be banned from every irc
server on earth.

A week later Bobby is pissed and starts scanning again for more wingates
while instead of using the wingates for irc the lamers are now using them
to connect to shells that they ripped from rolex's goons.

In the mean time.. here we are trying to use the wingates Bobby gave us
for good purposes like protecting ourselves from anal sysadmins of the
systems we 0wn but instead of getting that nice WinGate> prompt all we
get is lame messages like 'connection refused' or 'access denied'...
ohh I like the one that says 'too many connected users - try back
later'. that message tells you that there is a huge block of lamers
sucking it up dry.. when it says 'try back later'.. that really means
'in about an hour the message will change to access denied'.

So as you can see the life of a good wingate is only about 3 weeks
max depending on its use and how smart the owners are.

I hope this gives you wingate crazed assholes out there a little light on
the fact that your favorate wingate will soon die. It all depends on the
way you use it. 

[09] =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= [09]
_-_-_-_-_-_-_-_-_-_-_-_-_-_
  Lighter Side of Anarchy                                   by: Dance Fevah
~-~-~-~-~-~-~-~-~-~-~-~-~-~

#$%$#%#$%%#$%#$%#$%#$%$%#$%$#%#$%#$%#$%$#%#$%#$%#$%$#%#$%#$%$#%#$%$#
%$#%$#%#$%$#%#$%##%$#%$# LIGHTER SIDE OF  ANARCHY  @#$@#$@#$@#$@#$@#
@#$@#$@#$@#$#@$@#$@#$#@$#@$#@$#@$#@$#@$#@$@#$#@$#@$#@$#@$@#$@#$@#$@#

Contents:

Disclaimer

1a. Intro

Blowing Up Things
2a. Blowing up Animals
3a. Blowing up your spouse
4a. Blowing up your spouse after you have already blown up your spouse 
    the first time.

5a. Blowing up a baby animal while it is in process of leaving the 
    mothers womb.
6a. Blowing up a squerials nuts.
                
2a. Intro
Lighting Things on Fire
2b.  Starting a fire
3c.  Lighting your little sister/brother on fire.
4d.  Covering it up so no one notices you lit your little siter/brother
      on fire.
5b.  Lighting Animals on fire.                                      
6b.  Putting out the fire

1c. Intro
Stealing Things
2c. How to steal without getting caught.
3c. The laws of stealing.
4c. Stealing someones pride.
5c. Stealing someones pride after you have stoled it the first time.

1d. Intro
Blowing up and lighting breeding animals on fire
2b. How to get them to start breeding.
3b. Fire in goat ass.
4b. Kittie Kat Barbacue
5b. Doggy Style

1e. Intro
Blowing up Electronics Equipment
2e. Blowing up your stereo
3e. Blowing up someones car stereo while its still in the car.
4e. Blowing up a hand held radio while a relative is holding it.
5e. Escorting your relative to the hospital.

1f. Words from the Author
2f. Things you might need (alot of fucking water) and the number to your
    local medical facility,  some more water, 
     A couple of animals, sister/ brother or adopted child.
3f. Conclusion

Disclaimer:

This document was produced for educational purposes only.  I feel the topic's
I discuss in this document is of real importance that is why I am
providing it  for people to download and use at their own will and discretion. 


And now on with the show.....

1a. Introduction

	Section 1a will discuss the topic of blowing things up.

2a. Blowing up Animals

You can blow up animals many different types of ways all you need is the
animal and the materials you will need to blow the animal up.

In this Issue of "The Lighter Side of Anarchy"
I am going to tell you different ways of blowing up mouses, and snakes.

First things first for this you will need a long peice of wick gun powder
and a small box. Fill the bottle with the gun powder(not to much) stick the
wick in leaving a strand of the wick sticking out of small box and close
the box. After the box is closed tie the end of the wick to a stick and
shove the box end into the mouse.  Hold on to the stick tightly while
lighting the wick then quickly release the stick and RUN!
Seconds later you should have a blown up mousey.

Using this method on mouses and snakes at the same time.

Do the samething you did to the mouse except this time do not light the
wick instead feed the mouse to the snake (if its a rattle snake just stick
the rattle in the mouse's ass) then take a knife and plant a hole in the
area where the mouse is in the snake. Then take the a peice of wick  tie 
it to a stick implant that into the mouse
and light the wick on fire then you guessed it RUN!

3a. Blowing up your spouse.

Almost everyone who has a spouse knows how annoying they can be well using
the method provided below you can still sexually pleasure yourself with
your spouse.  Without your spouse bitching at you.  Here's how.

Blow off your spouces lips by putting gasoline or spraying something 
flamable at the tip of their ciggarettes  (also a neat way to get people to
quit smoking)

I'm going to throw in a freebie for the men (not that I'm sexist or
anything). The following has nothing to do with blowing up things.

Another way to injure your spouse is a small knife in the maxi pad or lots 
of needles in the tampon. Although this method still isnt as cool as
blowing them up. 

4a. Blowing up your Spouse after you've already blown them up.

After you have blown your spouse up the first time blow them up a second
time by adding  gun powder to the nicatine in their cigarette.  Or feeding
them Pepto Bizmo and Vinager while they are laying helpless on the ground.
If that doesnt blow them up try plugging up their anal socket and pumping
air threw their eye sockets while slowly inserting your index finger in
and out of the persons pussy to create tension.

5a. Blowing up a baby animal while it is in the process of leaving the womb.

For this you will need 3 or more fireCrackers if you dont have any then make
your own, preferbaly M-80's or M-100's

Method:

Put the pregnant animal in a box  tie a strand of firecrackers together stick 
one of the fire crackers up the pregnant animals ass  when you see the babys
head pop out quicky  light  the wick on one of the firecrackers make sure
you shove one of the firecrackers up the pregnant mothers ass though. then 
RUN!!!

6a. Blowing up a squerials nuts.

I found that squerials like to rub their food on their nuts before
consumption so I got an idea.  Since I live nearby a college with alot of
walnut tree's there are many squerials in the area.  

Precedure:

You will need 2 or 3 walnuts, gasoline, gun powder, and vasaline, wick,
matches

1. Dip the first walnut in gunpower on one side only the other side dip in 
   gasoline.  After doing that wait for the squerial to get the walnut and 
   proceed to rub the walnut on his own nuts.  The reason the squerial does
   this is the clean off the outer shell.  Anyhow doing this will cause the
   squerial to rub the gun powder and gasoline all over its balls.  when
   done the squerial will either consume the nut, or stash it for later.
   Either way your gonna see some blown up squerial genitles.  The suqerial
   will most likely return to the same area the first walnut was at.  

2. -The second walnut-
   
   The second walnut should just be covered in vasaline.  While the
   squerial was eating his first walnut you should have already placed a
   line of wick in front of the walnut as well as a small puddle of
   gasoline.  Once the squerial goes for the walnut throw a match directly
   in the puddle of gasoline this will cause the squerials nut-sack to
   ignite due to the excesive amount of hair on the squerials nuts the
   animal might not relize that its testicles are on fire instantly so it
   will continue going for the vasaline covered walnut.  When it trys
   picking up the walnut it will slip out of its grip, and also ignite.

   [rest to be continued]

[10] =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= [10]
  
In Conclusion                                                     by: tip
~-~-~-~-~-~-~-~-~

Nothing is to be taken seriously. Believe in the funk.
Special thanks to Kan.

[LoU] =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= [LoU]
