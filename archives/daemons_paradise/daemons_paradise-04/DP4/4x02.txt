<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< DP 4 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
**** [ cpu-1ph1c ][ cpu1ph1c@usa.net ] **************** { LINUX } ********
--------------------------------------------------------------------------

 8ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo8
                                                                           
                               ooooo           oooo        ooooo
  oooooo   ooooooo ooo   oo      888   ooooooo  888ooooo     888    oooooo
 88    888 88    8  88   88 oooo 888   88    8  888   888    888   88    888
 88        88   o8  8o   88      888   88   o8  888   888    888   88
  88oo888  88oo888  888oo88o   oo888oo 88oo888 o888o o888o oo888oo  88oo888
           88                          88             
           8o                          8o       ooo8 cpu-1ph1c 8ooo

 8ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo8
                             El kernel de Linux 
 8ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo8

 Este documento le ayudara a  manejar y a comprender el nucleo de Linux para
 diversos motivos, tanto como para investigar y  conocerlo, como para entrar
 a perfeccionar y recompilar la base del sistema  operativo. El documento es
 un descendiente de todos los  libros y textos que hablan sobre el kernel de
 Linux. El autor advierte  que el contenido  de este  texto no es copiado de
 ningun otro lugar, sin  embargo, las bases del autor sobre el kernel fueron
 adquiridas por muchos documentos rondantes en la red por lo tanto este sera
 de libre distribucion y puede ser tomado como base para futuros informes de
 los lectores,  siempre  y cuando se  respete su integridad y las fuentes de
 origen del mismo, asi como el autor. 

 Indice :
 --------

 - Primera vista
 - Por que actualizar o re-compilar
 - Los Modulos cargables
 - Requerimientos
 - Configuracion del kernel
 - Compilacion del kernel
 - Compilacion de los Modulos
 - Problemas
 - Probando los Modulos
 - Tiempo que tarda en compilar
 - Parchear el kernel
 - Bitacora al compilar
 - En la practica
 - Fuentes de Linux
 - Contacto

 Primera vista :
 ---------------

 El kernel de Linux tecnicamente es el sistema  operativo; se le llama Linux
 solo al kernel, pero se hace  referencia a el como si fuera el  conjunto de
 utilidades que  forman el sistema. En realidad, el  kernel no es util si no
 existen este tipo de utilidades; el kernel es el que le brinda la carretera
 de comunicacion a esas  utilidades, es el mediador  entre el software  y el
 hardware de la  computadora, los programas  acceden a los componentes de la
 computadora a traves del kernel y no directamente. La funcion principal del
 kernel de  Linux es brindar  soporte a los  componentes de la computadora y
 hacer  que  trabajen  correctamente, gestionando  la memoria  de todos  los
 programas y  procesos, asegurandoce de que se repartan  bien los ciclos del
 procesador. Generalmente se  actualiza  periodicamente  agregandole  nuevas
 funcionalidades y nuevos  manejadores de hardware, o bien para corregir los
 errores de las versiones pasadas. El kernel de Linux lo desarrolla un joven
 llamado Linus Benedict Torvalds y esta basado  en la licencia  GNU de libre
 distribucion, no cuesta nada adquirirlo y podemos modificar las fuentes del
 nucleo para  adaptarlo a nuestras  necesidades.  Lo podemos bajar de la red
 por http o por ftp segun  nuestra  conexion; las fuentes traen alrededor de
 5200 archivos que  reunen 62200 Kb (62.2 Mb) y comprimidas  ocupan un total
 de 16900 Kb (16.9 Mb); lo anterior  se  aplica a la  version del  kernel de
 Linux 2.2.14. Su tamano  puede  variar  segun como se vayan  sacando nuevas
 versiones. Para encontrar una lista de varios servidores y mirrors donde se
 pueden obtener las fuentes del kernel mire el apartado <Fuentes de Linux>.
 
 Por que actualizar o re-compilar :
 ----------------------------------

 Como dije antes, el kernel de  Linux tiene la funcion de servir de mediador
 entre el software y el hardware, haciendo que el sistema se administre y se
 manejen los recursos optimamente. Pues bien; como  es de suponer, el kernel
 de Linux es  el que  incluye los  manejadores (drivers) que nos sirven para
 manejar el  hardware de la computadora a traves de software. Linux a medida
 que pasa el tiempo, va reconociendo nuevas tecnologias y las va anadiendo a
 los  nuevos  kernels y  por  eso  es necesario actualizar el kernel. Si por
 ejemplo, necesitamos que nuestro OS Linux  acceda a un sistema  de archivos
 NTFS en  modo  lectura-escritura (rw) y cuando  leemos  la documentacion de
 nuestro kernel nos dice que no la soporta, entonces, ahi entra la verdadera
 importancia de la actualizacion del kernel. Ahora, necesitamos actualizar a
 un kernel que  soporte  el  sistema NTFS de Windows NT ya que nos seria muy
 util trabajar  conjuntivamente  en  Linux y poder acceder a la particion de
 Windows NT sin tener que re-iniciar la maquina y entrar en Windows NT. Bien
 nos enteramos que  tenemos  la version 2.0.32 del kernel y nos dicen que el
 nuevo kernel 2.2.14 soporta de maravilla el NTFS. Esa es una de las razones
 para actualizar el  kernel, cuando  necesitamos  mas poder en su soporte de
 sistemas de archivos. Otra razon  para  actualizar  puede  ser  que nuestro
 viejo kernel no soporte un determinado  hardware que tenemos en la PC y que
 queramos  utilizarlo  para  aprovechar  al maximo esa herramienta en Linux,
 y decidamos  actualizarnos a un  nuevo  kernel para  verla funcionar. Y por
 ultimo la razon mas comun  para actualizarnos es que el kernel que poseemos
 tenga errores en su codigo (bugs) y que no funcione bien. Hasta ahora hemos
 citado las razones para compilar  un nuevo kernel, ahora siguen las razones
 para re-compilar nuestro  kernel sin tener que actualizar. Bien; despues de
 que  instalamos  Linux, vemos  que  el  sistema  corre bien, pero en verdad
 podria correr mucho mejor, se ve lento y queremos que no se demore tanto en
 cargar y procesar alguna aplicacion. En  realidad, cuando se instala alguna
 distribucion  de  Linux, esta  compila  el  kernel  y  lo coloca en nuestra
 maquina con una  configuracion  standard, nos  coloca  muchos manejadores y
 muchas  funcionalidades  las  cuales  no  son  enteramente  necesarias para
 nuestra computadora, es el caso de que, se  anaden tantas que el sistema se
 demora mucho en cargar esas configuraciones cada vez que arranca y por ende
 se deteriora el rendimiento de nuestra maquina. Como ejemplo practico todas
 las distribuciones compilan el  kernel  con soporte para dispositivos SCSI,
 sin que nuestra maquina tenga discos o perifericos SCSI, esto se suma a que
 tambien el kernel se compilo  con soporte  para  redes sin que tengamos una
 NIC en nuestra PC, el caso es que  se anaden muchas cosas por defecto, otra
 es que se anade el emulador del  coprocesador (FPU) de la CPU, sabiendo que
 nosotros ya  poseemos FPU y  no  necesitamos  emuladores. En total se suman
 muchas  cosas  que  no  necesitamos  y si las quitamos de ahi notaremos que
 nuestra PC no  tiene  que cargar tantas cosas en memoria y por ende correra
 mas rapido y procesara mas rapido la informacion.

 Los Modulos cargables :
 -----------------------

 Puede que no nos guste la idea de  quitar  componentes de nuestro kernel, y
 puede  que los  queramos todos aunque no los necesitemos. Los colocamos con
 la  esperanza  de que algun dia vamos a utilizar tal manejador (SCSI) y que
 no seria bueno volver a re-compilar cuando nos compremos un periferico SCSI
 Tambien buscamos la  manera  de  que no quede muy grande el kernel y de que
 nuestra maquina  no se  haga tan lenta. De ahi surgio la necesidad de crear
 un metodo para  que se pudiera  compilar  el kernel con todas sus funciones
 pero que no cargara algunas de ellas, solo cuando el usuario las necesitara
 se cargaban. De ahi surgio el  termino Modulos Cargables que se empezaron a
 tratar cuando estaban por el kernel 1.99.14 pero que todavia seguian siendo
 parte del kernel, cuando  deberian estar a dispocision de los usuarios. Los
 verdaderos  Modulos  cargables  se  implementaron  desde la version 2.0 del
 kernel que hacia que  se  compilaran  partes del kernel en forma separada y
 que cuando el usuario los necesitara se enlazaran automaticamente al nucleo
 sin necesidad  de  ser  cargados  siempre  al inicio. Desde ese momento, la
 tendencia a modularizar manejadores era necesaria, cuantos mas, mejor; solo
 se dejaban sin modularizar los manejadores necesarios para el sistema, como
 ext2 o el controlador IDE/EIDE. Entonces, ahora  ya  si  podemos anadir mas
 funcionalidades al kernel sin temor a que  nuestra maquina se quede lenta o
 sin temor a que el kernel quede inmenzo y no pueda ser cargado.

 Requerimientos :
 ----------------

 Hay muchos tipos de requerimientos  para  poder  trabajar  con el kernel de
 Linux, que van desde el tipo de computadora, hasta la paciencia mental para
 esperar a  que  el  kernel  cargue. Lo  principal  es  saber moverce por la
 estructura de directorios de Unix, ejecutar ordenes,saber instalar paquetes
 de software,  descomprimir, saber  compilar programas, y lo fundamental, es
 tener instalada en el sistema alguna distribucion de Linux. En lo referente
 a las aplicaciones es necesario  tener las que recomienda Linus Torvalds en
 el archivo /usr/src/linux/Documentation/Changes de las fuentes  del kernel;
 ahi se citan las versiones de las  herramientas necesarias para su correcta
 compilacion y convivencia  con los demas programas. Voy a suponer que usted
 va a compilar  un  kernel 2.2.14 o  superior, por  lo  tanto debe tener las
 siguientes aplicaciones :

  - Kernel modutils          2.1.121           
  - Gnu C                    2.7.2.3           
  - Binutils                 2.8.1.0.23        
  - Linux libc5 C Library    5.4.46            
  - Linux libc6 C Library    2.0.7pre6         
  - Dynamic Linker (ld.so)   1.9.9             
  - Linux C++ Library        2.7.2.8           
  - Procps                   2.0.3
  - Procinfo                 16                
  - Psmisc                   17                
  - Net-tools                1.52              
  - Loadlin                  1.6a              
  - Sh-utils                 1.16              
  - Autofs                   3.1.3             
  - NFS                      2.2beta40         
  - Bash                     1.14.7            
  - Ncpfs                    2.2.0             
  - Pcmcia-cs                3.0.14            
  - PPP                      2.3.10            
  - Util-linux               2.9z              
  - Isdn4k-utils             v3.1beta7         
                                     
 Lo anterior fue una lista de las aplicaciones  basicas que un sistema Linux
 debe  tener  antes  de  compilar la  version 2.2.14  del kernel. No son las
 ultimas versiones de esas aplicaciones, son solo los requerimientos minimos
 de cada  una de ellas. En la  primera  columna se citan los  nombres de las
 aplicaciones, y en la segunda  columna las  versiones de esas aplicaciones.
 Para saber cual es la version de dicha aplicacion en nuestro sistema o para
 verificar si existe se hace :

  - En RedHat Linux (O en distribuciones basadas en RPM) :

    Se coloca el comando rpm -qi (Query Install) con su respectivo argumento
    en este caso colocamos solo el nombre del paquete :

    [cpu-1ph1c@/UNIX]# rpm -qi gcc

  - En Debian Linux (O en distribuciones basadas en DPKG) :

    Se coloca el  comando dpkg -s (Status) con su  respectivo  argumento, en
    este caso colocamos solo el nombre del paquete :

    [cpu-1ph1c@/UNIX]# dpkg -s gcc

 Estas no  son las unicas formas de averiguar si tenemos la version correcta
 de la  aplicacion. Tambien  se  pueden  averiguar  esos datos llamando a la
 aplicacion  en el inductor (prompt)  con una opcion que generalmente es -v,
 -V, --version o -version, eso  depende  de la aplicacion. Por ejemplo, para
 mirar que  version  tenemos de Gnu C, Bash, Binutils y Psmisc colocamos los
 siguientes comandos :

  [cpu-1ph1c@/UNIX]# gcc --version ; bash -version ; ld -v ; pstree -V
  
 Como se observa, cada  aplicacion  tiene un  metodo diferente (opcion) para
 mostrar la  version de su Release. Yo personalmente  le sugiero que intente
 primero con el  comando rpm -qi o con dpkg -s segun su distribucion, ya que
 ademas  de  presentar  la version, hace comprobaciones del archivo, muestra
 descripciones, muestra  los  autores  del  programa, etc. Despues  de haber
 comprobado la existencia de esas aplicaciones en su computadora, es posible
 que no haya encontrado una con las especificaciones requeridas, por ejemplo
 la  aplicacion PPP o Gnu C; Bien, no  se alarme, eso suele suceder, hay una
 forma facil de  adquirir esas  nuevas  aplicaciones; por Internet, hay unas
 cuantas  paginas  dedicadas  enteramente a  las aplicaciones para Linux que
 pueden ser bajadas gratuitamente. Estas paginas son :

  - http://www.linux.org
  - http://www.freshmeat.net
  - http://www.debian.org
  - http://sunsite.unc.edu
  - http://slug.ctv.es

 Despues de  encontrar la  aplicacion  requerida  se  procede a instalarla y
 verificamos que  quede bien en el sistema. Ahora, si  podemos estar felices
 con nuestros requerimientos con respecto a las aplicaciones. Ahora  despues
 de  los  requerimientos  de  conocimientos  y  de  aplicaciones, siguen los
 requerimientos  fisicos  de la  computadora. Generalmente se dice que Linux
 puede correr en un 80386 a 25MHz con 4 Mb de RAM y 50 Mb de Unidad de Disco
 duro, pero yo le recomendaria que pusiera las fuentes  del  kernel y alguna
 distribucion de Linux en una PC 80586 a 100Mhz con 32 Mb de RAM y con 700Mb
 de Unidad  de  disco  duro; eso es  lo medio-medio para  que Linux funcione
 optimamente con  todos  los  paquetes. Las  fuentes comprimidas ocupan unos
 16900 Kb (16.9 Mb) y una vez descomprimidas  ocupan unos 62200 Kb (62.2 Mb)
 asi que para  compilar un kernel 2.2.14 o superior  debemos tener unos 80Mb
 aproximadamente. Por ultimo, lo que  necesitamos es todas y cada una de las
 especificaciones del  hardware de  nuestra  computadora, seria recomendable
 que  las  copiara en  un  papel para  luego  apuntarlas  digitalmente en el
 programa de configuracion del kernel (es muy recomendable esto que dije).

 Configuracion del kernel :
 --------------------------

 Lo  primero  que  hay que  hacer es obtener las  fuentes del kernel, por lo
 general  vienen  con  extencion (tar.gz), tambien  vienen en otros tipos de
 extencion, como  es  la  de Debian (deb) o la de RedHat (rpm). El sitio mas
 recomendado para  bajar las fuentes es http://www.kernel.org, hay otros que
 los vera en el apartado <Fuentes de Linux>. Cuando bajamos el archivo, este
 tendra una pequena estructura :

  linux-x.y.z.tar.gz     ---> Archivo TarBall Slackware
  linux-x.y.z.deb        ---> Archivo deb para Debian
  linux-x.y.z.rpm        ---> Archivo rpm para RedHat

 Donde x.y.z es la version de las fuentes del kernel, actualmente la version
 estable es la 2.2.14 por lo que los paquetes anteriores quedarian asi :

  linux-2.2.14.tar.gz    ---> Archivo TarBall Slackware
  linux-2.2.14.deb       ---> Archivo deb para Debian
  linux-2.2.14.rpm       ---> Archivo rpm para RedHat

 Antes de descomprimir las fuentes  debemos  asegurarnos de que no existe el
 directorio linux dentro de /usr/src, y si existe hay que renombrarlo con el
 comando mv (Move) :

  [cpu-1ph1c@/UNIX]# mv /usr/src/linux /usr/src/linux-old

 Despues de que nos  aseguramos de que no exista tal directorio, copiamos el
 archivo de las fuentes al directorio /usr/src asi :

  [cpu-1ph1c@/UNIX]# cp linux-2.2.14.tar.gz /usr/src

 Y procedemos a  descomprimirlo  con  el comando tar xzvf, se haria entonces
 con el siguiente comando :

  [cpu-1ph1c@/UNIX]# tar xzvf linux-2.2.14.tar.gz

 Despues  de  este proceso, se creara el directorio linux dentro de /usr/src
 el  cual  contendra las  fuentes del kernel descomprimidas, listas para ser
 compiladas. El proceso  anterior  solo es para descomprimir las fuentes con
 extencion (tar.gz), para  instalar las otras fuentes de Debian y RedHat, se
 aplican comandos  diferentes. Lo unico  que hay que hacer es asegurarnos de
 que no exista el directorio /usr/src/linux y una vez verificado, ejecutamos
 el comando :

  [cpu-1ph1c@/UNIX]# dpkg -i linux-2.2.14.deb   ---> Para Debian
  [cpu-1ph1c@/UNIX]# rpm -i linux-2.2.14.rpm    ---> Para RedHat

 Quedara  un  archivo (tar.gz)  como  resultado  del anterior comando, en el
 directorio /usr/src, luego  se  procede  a descomprimirlo como cite arriba,
 con el comando tar xzvf.

 Despues  de  descargar  las fuentes, hay  que leer el fichero README que es
 donde se describen todos los pasos para compilar el kernel. Estan en ingles
 pero  no  se preocupe, aqui  le vamos  a decir como compilarlo. Primero que
 todo, debe existir el  fichero /bin/bash o /bin/sh, luego hay que entrar al
 directorio /usr/src/linux y ejecutar la orden :

  [cpu-1ph1c@/UNIX]# make config

 Despues  se  ejecutaran  unas  cuantas ordenes y se llegara a un dialogo en
 modo texto  donde  usted elige el tipo  de opcion que desee. Este metodo es
 muy viejo y  por eso se ha  implementado un nuevo metodo para hacer que ese
 dialogo en  modo  texto  cambie  por  menus  con colores navegables con las
 flechas del teclado. Este metodo se  integro desde las versiones 2.0.x y es
 muy  posible  que  usted  tenga una  superior a esa (obvio). Entonces, para
 arrancar la configuracion del kernel con menus y colores se hace asi:

  [cpu-1ph1c@/UNIX]# make menuconfig

 Como dato adicional, este programa fue escrito en lxdialog, que le permitio
 a Linus Torvalds hacer de la compilacion del kernel una tarea agradable. Se
 le abrira dicha  aplicacion  y  empezara a  seleccionar los manejadores que
 usted quiera, ya  vienen  unos  seleccionados, son los estandares; hay tres
 formas de  seleccionar  los  manejadores, con  una M (Modulo), con un * que
 indica que se enlazara dentro de la imagen del kernel y N que significa NO.
 Hay  dos  objetos, el [ ] y el < >. El  primero  indica  que  no  se  puede
 modularizar  ese  manejador, y que  solo  es posible  ponerle un *, el otro
 significa que podemos ponerlo con * o con M. Para ponerlo como * es preciso
 presionar  la tecla SPACE y para  ponerlo como M la tecla M o presionar dos
 veces la  tecla SPACE, y para  des-seleccionarlo  se oprime N o se presiona
 tres veces la tecla SPACE. Es el momento de crear nuestra configuracion del
 kernel, seleccione  lo  que  quiera (lo que soporte y tenga su PC). Si puso
 make config, debera  responder  a  cada una de las preguntas con M, con * o
 con N, tambien  incluye  la  posibilidad de ? donde se presenta una pequena
 descripcion del manejador. Por  ultimo, existe  otra forma de configurar el
 kernel en  X-Window, con el comando <make xconfig> tecleandolo en un xterm.
 Aparecera  un  programa  manejable con el Mouse, ahora en vez de [ ] y < >,
 aparecen  tres  bolitas -o o o-. Cuando  las  tres se pueden elegir, es que
 se permite anadir el  manejador  como  modulo, pulsando  en la bolita de la
 mitad, el resto  es  lo mismo que con [ ], en vez del asterisco se da click
 sobre la  bolita  que  diga Y y para  desactivarlo en la bolita que dice N.
 Ahora hay  que  salir de menuconfig o xconfig y grabar la configuracion, de
 inmediato le  saldra  un mensage que dice que revice el Makefile para poder
 cambiar opciones adicionales, si le interesa puede cambiar la configuracion
 de Makefile una vez compilado, con el comando rdev.

 Compilacion del kernel :
 ------------------------

 Ahora hay que ejecutar varios comandos, el primero es <make dep>, que es el
 encargado  de  alistar  las  dependencias  del kernel; este proceso se debe
 demorar varios minutos dependiendo de la  velocidad de su procesador. En un
 80586/Pentium a 120Mhz  se  demora 5 minutos. Vera  unos  caracteres  raros
 durante ese tiempo, cuando termine  le debe dar otro comando, <make clean>,
 que se encarga de limpiar  los ficheros objeto que dejo el kernel anterior,
 este proceso dura 10 segundos aproximadamente. En conclusion, usted hace :

  [cpu-1ph1c@/UNIX]# make dep ; make clean
  
 Ahora  sigue  el  comando  que  compilara  el  kernel, hay variantes de ese
 comando, el primero es <make zImage> donde zImage indica que el nucleo sera
 comprimido y puesto en /usr/src/linux/arch/i386/boot/zImage,el otro comando
 es <make zdisk> que copiara la imagen del kernel en el disco de 3/2 1.44 Mb
 y podra mas tarde arrancar con el disco el nuevo kernel, el otro comando es
 <make zlilo> que agrega de una  vez la imagen del kernel al lilo, dejandolo
 listo para ser arrancado, y el ultimo comando es <make bzImage> que utiliza
 un mecanismo mas moderno de compresion para que el kernel quede mas pequeno
 y pueda ser anadido correctamente al Lilo, este ultimo comando le puede ser
 util si con los  comandos  anteriores le surgieron  errores. En conclusion,
 ejecutamos alguno de estos comandos (solo 1) :

  [cpu-1ph1c@/UNIX]# make zImage    ---> Compilar el kernel
  [cpu-1ph1c@/UNIX]# make zdisk     ---> Compilar y arrancar con diskette
  [cpu-1ph1c@/UNIX]# make zlilo     ---> Compilar y anadirlo al Lilo
  [cpu-1ph1c@/UNIX]# make bzImage   ---> Maxima compresion del kernel

 De las anteriores opciones le recomiendo que ejecute <make bzImage>, ya que
 quedara  tan pequeno el kernel que compilara muy bien, ademas, se ahorra el
 tener  que  compilar  de  nuevo  si se  presentan errores con el tamano del
 kernel. Con relacion al tiempo de compilacion, se demora unos 20 minutos en
 una PC 80586/Pentium a 120Mhz. Ahora viene el paso de colocar la ruta de la
 imagen en /etc/lilo.conf para que lilo la reconozca y pueda arrancar con el
 nuevo kernel; se edita el fichero /etc/lilo.conf y se anaden las siguientes
 lineas :

  image=/usr/src/linux/arch/i386/boot/bzImage
          label=new-kernel
          root=/dev/hda1
          read-only

 Esto  anterior se  hace si se compilo con el  comando <make bzImage>, si se
 compilo con el comando <make zImage> se coloca lo siguiente :

   image=/usr/src/linux/arch/i386/boot/zImage
           label=new-kernel
           root=/dev/hda1
           read-only

 Si se compilo con los comandos <make zdisk> o <make zlilo>, no es necesario
 anadir las lineas  pasadas al /etc/lilo.conf, ya que se  arrancara desde un
 disco y en la  segunda  opcion se colocara  automaticamente el kernel en el
 lilo. Ahora, lo que sigue  despues de  colocar las lineas en /etc/lilo.conf
 es colocar el comando :

  [cpu-1ph1c@/UNIX]# lilo

 Aparecera  un  mensage  que dice  Added: new-kernel o similar. Este comando
 hace  que  se  anada al MBR la  configuracion  que se puso en LILO para asi
 poder arrancar la computadora y  poder  iniciar  con el nuevo kernel. Ahora
 solo hay que re-iniciar y cuando aparezca el prompt de LILO colocar:

  LILO boot: new-kernel

 Desde  ese momento se empezara a descomprimir y a cargarce su  nuevo kernel
 tiene que tomar ciertas precauciones, cuando coloque new-kernel se empezara
 a cargar el kernel pero mantenga el dedo en el boton de On/Off de su PC, es
 muy comun  que  halla hecho  algo mal y que la computadora empiece a hechar
 humo, es  necesario  que  la apague lo mas rapido posible para evitar danos
 graves e irreversibles (si, es broma).

 Compilacion de los Modulos :
 ----------------------------

 Antes de re-iniciar con  el nuevo kernel, necesitamos compilar los modulos,
 que  como  dije  antes, son  partes  que  se compilan por separado y que se
 enlazan  en  el  momento  de  ejecucion  al  nucleo de Linux. Bien, son dos
 comandos los que hay que colocar :

  [cpu-1ph1c@/UNIX]# make modules ; make modules_install 

 El primero <make modules> compila los modulos que nosotros seleccionamos en
 el programa  de  configuracion  del  kernel, este  proceso  se  demora unos
 cuantos  minutos  dependiendo  de la cantidad de modulos que elegimos y del
 tipo de maquina que  tenemos. El segundo <make modules_install> instala los
 modulos en el  directorio /lib/modules/2.2.14 y crea  un  fichero  con  las
 llamadas a los modulos, llamado  modules.dep. Por ultimo debemos colocar un
 comando ya estando trabajando en el nuevo kernel, es:

  [cpu-1ph1c@/UNIX]# depmod -a

 Que hace que  lean y se calculen las dependencias de todos los modulos para
 asi poder  ser cargados y  correctamente  leidos. Al siguiente arranque, el
 nuevo kernel estara listo para funcionar FULL, con modulos y todo.

 Problemas :
 -----------

 Puede  que le haya  dado el  comando <make menuconfig> y que haya aparecido
 un mensage raro que le impida entrar. Algo como :

  make: *** No rule to make target 'menuconfig'. Stop

 Este problema es comun, es tambien  muy facil de solucionar, el problema es
 que no  estamos  en  el  directorio  correcto, debemos asegurarnos  de  que
 estemos en /usr/src/linux y que  esten las  fuentes y ahi ejecutar dicho(s)
 comando(s).

 Si presentimos que el kernel hace cosas raras una vez que arrancamos con el
 y lo vemos funcionar y vemos que se cuelga de seguido y que tiene problemas
 con  algunos  dispositivos, puede  que  se  nos haya  olvidado ejecutar los
 comandos <make dep> y <make clean>, para estar seguros, vuelva a compilar y
 fijece  bien  al  ejecutar  los  comandos  en el  directorio /usr/src/linux
 despues de haber configurado el kernel. Se hace como cite arriba:

  [cpu-1ph1c@/UNIX]# make dep ; make clean

 Otro  problema es que cuando tratamos de compilar el nucleo, vemos que este
 se demora mucho, incluso con una computadora moderna, y al final nos suelta
 un  error  que  dice  que  no se pudo compilar por que la imagen del kernel
 quedo muy grande. Si usted  compilo el  nucleo con el comando <make zImage>
 intente mejor  con <make bzImage> para  que la  imagen del nucleo quede mas
 pequena y se  pueda  compilar bien. De lo  contrario  necesitara quitar mas
 componentes  que  selecciono  en la configuracion del kernel, o incluya mas
 Modulos y menos *.

 El nuevo kernel no  arranca; esto le puede suceder porque no configuro bien
 el /etc/lilo.conf y no ejecuto su comando <lilo>. Asegurece  de que este la
 nueva linea en el /etc/lilo.conf y ejecute lilo :

  image=/usr/src/linux/arch/i386/boot/bzImage
          label=new-kernel
          root=/dev/hda1
          read-only
  
  [cpu-1ph1c@/UNIX]# lilo

 Tambien asegurece de que las lineas que hay en el /etc/lilo.conf concuerden
 con la  configuracion  de  su  sistema, la  primera  linea <image=/usr/...>
 puede  cambiar  segun el  metodo  que  implemento  para  compilar, si usted
 utilizo el comando <make zImage> la debe cambiar por:

  image=/usr/src/linux/arch/i386/boot/zImage

 Y si utilizo <make bzImage> la debe cambiar por:

  image=/usr/src/linux/arch/i386/boot/bzImage

 La otra linea que debe  cambiar  segun su sistema es la de <root=/dev/hda1>
 con esa linea se hace referencia a la particion donde se encuentra el nuevo
 kernel. Para que se  oriente en  lo que digo, ejecute el comando <mount>, y
 utilice  como  referencia  la  linea  que tenga un /. (entendera  de lo que
 estoy hablando cuando ejecute el comando). Como ejemplo practico:

  [cpu-1ph1c@/UNIX]# mount
  /dev/hda1 on / type ext2 (rw)

 De  ahi se deduce que  tenemos que colocar en el /etc/lilo.conf en la linea
 root= el /dev/hda1 porque  eso  es  lo que aparece como sistema de archivos
 raiz de Linux. Si apareciera /dev/hda2 on / type ext2 (rw), se colocaria en
 vez de root=/dev/hda1, root=/dev/hda2.

 Otro  error tipico, para  los  usuarios  despistados, cuando  compilamos el
 kernel la verdadera imagen se crea en /usr/src/linux/arch/i386/boot/bzImage
 o su correspondiente; tambien se  crea otra que  confunde a los usuarios en
 /usr/src/linux/vmlinuz, no se  debe  utilizar  vmlinuz  para arrancar, sino
 la imagen citada <bzImage>, como causa de ese error podria salir un mensage
 como : 

  Not a compressed kernel image file

 Y por ultimo otro error o despiste que a veces confunde; cuando se instalan
 las funtes con  extencion (deb) o (rpm) se  desempaqueta un (tar.gz) que es
 puesto en el  directorio /usr/src. Una  vez que  descomprimimos las fuentes
 con el comando <tar xzvf>  se creara (en algunas  ocasiones) un  directorio
 diferente a linux, en  vez  de /usr/src/linux se puede  haber  creado  otro
 directorio  /usr/src/kernel-source. Lo  unico diferente en este caso es que
 en vez  de  compilar  en  el  directorio  /usr/src/linux, compilamos  en el
 directorio  /usr/src/kernel-source. Y  para  anadir  la  imagen  al archivo
 /etc/lilo.conf lo hacemos dependiendo de la ruta :

  image=/usr/src/kernel-source/arch/i386/boot/bzImage
          label=new-kernel
          root=/dev/hda1
          read-only

 Observece que ha cambiado la ruta donde esta la imagen compilada del kernel
 no se preocupe por saber donde esta la imagen de su kernel; al compilar, le
 da un  aviso que le dice  cual es la ruta exacta de la imagen compilada del
 kernel. Por si ninguno de los metodos  anteriores le sirvio para solucionar
 el problema, siempre  hay una posibilidad  de que las fuentes del kernel, o
 que el archivo donde  vinieron las fuentes tenga datos defectuosos, en este
 caso  no  queda  mas  que  volver  a  bajar  las  fuentes de otro sitio mas
 confiable; para esto ultimo mire el Apartado <Fuentes de Linux>.

 Probando los Modulos :
 ----------------------

 Cuando terminamos de  compilar y  arrancar nuestro nuevo kernel, la mayoria
 de componentes  que  seleccionamos  pudieron  ser  Modulos, y  por  eso  es
 necesario  comprobar que  esten  funcionando  bien. Esto se consigue con la
 aplicacion Kernel modutils 2.1.121. Este paquete tendra varias herramientas
 que  nos  serviran, <insmod> para  insertar  nuevos  modulos,  <rmmod> para
 eliminar  modulos, <lsmod> para  listar  los modulos en ejecucion, <depmod>
 para  computar las  dependencias entre los modulos y <modprobe> para probar
 que el modulo este correcto. hay muchas  mas  herramientas de modutils pero
 las que utilizaremos seran <lsmod>, <depmod>, <insmod> <rmmod> y <modprobe>
 Para listar los modulos que tenemos en ejecucion :

  [cpu-1ph1c@/UNIX]# lsmod
  Module      Pages    Used by
  ipx           3        0
  opl3          3        0
  sb            6        0
  uart401       2        [sb]
  sound         16       [opl3 sb uart401]

 Para  insertar  un  modulo (generalmente son  archivos con extencion .o) se
 coloca el comando <insmod>  seguido  del nombre  del fichero, como ejemplo,
 insertaremos el modulo prueba <probe_mod.o> :

  [cpu-1ph1c@/UNIX]# insmod probe_mod.o

 Para probar que el modulo este bien colocamos el comando <modprobe> seguido
 del nombre del modulo, no del fichero :

  [cpu-1ph1c@/UNIX]# modprobe probe_mod

 Para  computar las dependencias con los otros  modulos, ejecutamos la orden
 <depmod -a> :

  [cpu-1ph1c@/UNIX]# depmod -a

 Y para eliminar el modulo probe_mod.o se utiliza el comando <rmmod> :

  [cpu-1ph1c@/UNIX]# rmmod probe_mod

 Los  modulos se utilizan  tambien  para que se les den la oportunidad a los
 usuarios de incluir sus  propios manejadores, o para que los fabricantes de
 hardware  incluyan  facilmente  en  el kernel su manejador sin necesidad de
 enlazarlo  al  nucleo. Hay  muchos  manejadores  que  no  hacen parte de la
 distribucion  oficial  del kernel y que se  pueden anadir a el por medio de
 los modulos. Si  usted ve que en  el kernel  nuevo  no  esta soportado algo
 especial que tiene su computadora, busque el manejador en alguna pagina web
 la mejor que le recomiendo es:

  Linux Driver Support: http://www.torque.net/~campbell/

 Hay  muchos  drivers  que  se pueden  enlazar  al kernel  como modulos, son
 gratuitos y  puede que le  guste  ver funcionando ese hardware tan especial
 que tiene en su computadora.

 Tiempo que tarda en compilar :
 ------------------------------

 Compilar el kernel con sus modulos y aplicaciones  requeridas puede tomarce
 unas  cuantas  horas, sobre todo si tenemos  una  computadora con  una  CPU
 bastante  lenta. En  un  80586/Pentium a 120Mhz con 32 Mb de RAM se  demora
 unos 35 minutos en  compilar  el  kernel y sus modulos. En un 80386 a 25Mhz
 con 4 Mb de  RAM se demora unas 2 horas y media para compilar el kernel con
 sus modulos. Si tiene un 80686/Pentium III/K6-III a 500Mhz con 64 Mb de RAM
 se debe demorar unos 10 minutos para compilar el kernel con sus modulos. En
 fin, en cualquier  sistema se tarda mucho tiempo como para quedarce sentado
 viendo como se compila; le sugiero que  mientras se compila, se pase a otra
 terminal  virtual (Alt+F2) y haga lo que  quiera, recordemos que estamos en
 multitarea a 32 Bits y podemos ejecutar muchas aplicaciones a la vez. Puede
 ser el caso de que la PC se haga mas lenta o que este leyendo de seguido el
 disco y la memoria, pero  aun asi  podemos arrancar unas pesadas X-Window y
 trabajar  con  alguno que otro programa. O si lo prefiere, puede  apagar el
 monitor (ahorro de energia) mientras se compila el kernel e irse a leer o a
 ver television.

 Parchear el kernel :
 --------------------

 Se le llama  parchear el kernel al metodo que se  utiliza para realizar una
 actualizacion  incremental  de las  fuentes. Se modifican  directamente sin
 necesidad  de  borrar las  fuentes  antiguas y actualizarce a una nueva. El
 termino  parchear  confunde a la gente, no se trata de  remendar el  codigo
 fuente, solo  se trata  de  copiar  los ficheros  que se  modificaron y los
 nuevos  que se crearon, a las antiguas  fuentes, convirtiendolas  en  pocos
 segundos  en  unas  fuentes  actualizadas.  Quedarian  igual  que  con  una
 actualizacion de todas las fuentes, solo que la manera de instalarce es mas
 diferente, y por supuesto, el fichero patch de  actualizacion se reduce, en
 cuanto a tamano se refiere. Comunmente se  distribuyen los parches segun la
 version  del kernel; si  tenemos el  kernel 2.0.32 y queremos actualizar al
 2.0.33, debemos bajar el patch que tiene como nombre patch-2.0.33.gz. Antes
 de descomprimirlo debemos guardar una copia del arbol de directorios de las
 fuentes actuales del kernel, estando en /usr/src/linux hacemos :

  [cpu-1ph1c@/UNIX]# make clean

 Y estando en el directorio /usr/src hacemos :

  [cpu-1ph1c@/UNIX]# tar cvfz kernel-anterior.tar.gz linux

 Ahora  debemos  copiar el fichero patch-2.0.33.gz al  directorio /usr/src y
 ejecutar alguno de estos dos comandos (solo 1) :

  [cpu-1ph1c@/UNIX]# zcat patch-2.0.33.gz | patch -p0
  [cpu-1ph1c@/UNIX]# patch -p0 < patch-2.0.33

 El fichero patch-2.0.33 puede  cambiar de nombre, en vez de patch-2.0.33.gz
 puede  estar  otro  fichero llamado patch33.gz. Solo es cuestion de usar la
 logica; si tenemos uno que se llama patch33.gz se haria:

  [cpu-1ph1c@/UNIX]# zcat patch33.gz | patch -p0
  [cpu-1ph1c@/UNIX]# patch -p0 < patch33

 Notece la diferencia con respecto a los primeros (solo cambia el nombre del
 fichero), hay que recordar que solo uno de esos dos es el que ejecutaremos,
 es por si acaso alguno  nos da errores. El  segundo comando se asume que ya
 se  descomprimio el fichero  con el comando <gunzip patch33.gz>. Ahora vera
 unos  mensages que  pasan por el  monitor los cuales generalmente dicen que
 cambios  se  aplicaron  bien y cuales  no, este  proceso  dura unos cuantos
 minutos, todo  depende  de  su computadora. Despues, si todo a salido bien,
 solo es  ejecutar  <make clean>  <config>  y  <dep>. Una  vez terminados de
 ejecutar  estos comandos, se tienen las nuevas fuentes compiladas. Para mas
 informacion  revice  la  parte -Configurando el kernel-  y  - Compilando el
 kernel-. Es  recomendable  que lea el fichero README que viene junto con el
 patch, ya que, en versiones  modernas  puede  que  cambie la metodologia de
 parcheado.

 Bitacora al compilar :
 ----------------------

 Hay una opcion muy  interesante que puede servirnos si durante el parcheado
 o la compilacion se producen errores, utilizando comandos que redireccionen
 la salida  estandar de un  comando se pueden obtener logs. Esta sintaxis es
 tomada del documento Kernel-Howto cuyo autor es Brian Ward.Si se utiliza el
 shell bash o su  correspondiente sh (/bin/bash - /bin/sh) se puede capturar
 la salida del comando <make> con el siguiente comando :

  [cpu-1ph1c@/UNIX]# (command) 2>&1 | tee (output file)

 Donde (command) es el comando (como <make dep>, <make clean> <make bzImage>
 o  cualquier  otro) y (file) es el fichero  destino, donde se guardaran los
 logs que produzca  dicho comando. Si tenemos el shell csh o tcsh se pondria
 el comando asi :

  [cpu-1ph1c@/UNIX]# (command) |& tee (output file)

 Donde  (command)  es  el  comando, como  dije  anteriormente y (file) es el
 destino, a donde  va a ser  redireccionada la  salida estandar. La sintaxis
 del  comando  anterior  se  copia  sin  los parentesis (). Para  que  no se
 confunda, un ejemplo, el primero con bash y el segundo con csh :

  [cpu-1ph1c@/UNIX]# make bzImage 2>&1 | tee target
  [cpu-1ph1c@/UNIX]# make bzImage |& tee target

 Asi  quedaria la salida de <make bzImage> guardada en el fichero target. Si
 encuentra  errores en la compilacion puede mirar el fichero target y buscar
 algun metodo para resolverlos o pedir ayuda.

 En la practica :
 ----------------

 Aqui se hace  una  pequena  prueba o un pequeno simulacro, o mas bien dicho
 una  pequena  demostracion  de  como se configuran cada una de las opciones
 de un kernel actual. Se  ponen las especificaciones de una PC normal y  con
 base en ella se eligen las opciones que estan en el kernel.La configuracion
 inlcluye muchos modulos que no son necesarios  pero que a algunas  personas
 les  sera  de  utilidad. Es  la  configuracion  standard  junto  con nuevas
 funcionalidades  que  incluyen sistemas  de archivos, soporte SCSI, soporte
 para  Red, para  conexion  por  Modem, etc. En  conclusion, le servira para
 aquellos que nunca  han visto  como se  configura un kernel, ahi tendran la
 oportunidad  de observar a que se enfrentan y asi poder llegar con mas base
 al objetivo.

 Voy a colocar todas y cada una de las  opciones que hay en el kernel 2.2.14
 y voy a senalar las standares y algunas que seria bueno tenerlas. Para esto
 voy  a  colocar  primero  las  especificaciones  de  la maquina para que se
 oriente un  poco. Como  dato alentador; es la  maquina  mas estandar que he
 visto y que conozco :

 Tarjeta MainBoard AT
 Bus Sockets EISA y PCI
 Procesador Intel Pentium a 120MHz con coprocesador matematico
 112 Kb de Memoria Cache
 Unidad de CD-ROM IDE/EIDE ATAPI
 Controlador Secundario EIDE
 Tarjeta de video PCI con chipset S3 Trio64V+ y 2 Mb de Memoria
 Mouse Logitech con 3 botones por COM1
 Tarjeta de sonido EISA PnP ESS compatible Sound Blaster
 Teclado en Ingles con 102 Teclas
 Puertos COM1 COM2 y LPT1
 Monitor SVGA standard
 Unidad de diskett 3/2 1.44 Mb
 Unidad de disco duro de 5.6 Gb
 Bios AMI de 1996
 Modem ISA Rockwell RPI a 14.400 bps
 Impresora Hewlett Packard 693 Series
 Sistema de ficheros NTFS, FAT16, FAT32, Minix y ext2fs

 Esos  son los  datos mas  comunes en el que un kernel actual  puede dominar
 cada uno de sus  componentes, a continuacion voy a colocar las opciones que
 usted debe colocar en el programa de configuracion del kernel, esto lo hago
 suponiendo que  usted no sabe para  que son ese monton de opciones que hay,
 lo que coloco aqui le servira a todos los que tengan una computadora que se
 asemeje a la  descrita  anteriormente, incluso, si usted tiene dispositivos
 SCSI y otros especiales, le servira, porque  se incluiran  como modulos por
 si acaso los necesitamos :

 Code maturity level options --->
  [*] Prompt for development and/or incomplete code/drivers
 Processor type an features --->
  (386) Processor family
  (1GB) Maximum Physical Memory
  [*] Math emulation
  [ ] MTRR (Memory Type Range Register) support
  [*] Symmetric multi-processing support
 Loadable module support --->
  [*] Enable loadable module support
  [*] Set version information on all symbols for modules
  [*] Kernel module loader
 General setup --->
  [*] Networking support
  [*] PCI support
  (Any) PCI acces mode
  [*] PCI quirks
  [*] Backward-compatible /proc/pci
  [ ] MCA support
  [ ] SGI Visual Workstation Support
  [*] System V IPC
  [ ] BSD Process Accounting
  [*] Sysctl support
  <*> Kernel support for a.out binaries
  <*> Kernel support for ELF binaries
  <*> Kernel support for MISC binaries
  <M> Parallel port support
  [ ] Advanced Power Management BIOS support
 Plug and Play support --->
  [*] Plug and Play support
  < > Autoprobe for parallel devices (NEW)
 Block devices --->
  <*> Normal PC floppy disk support
  <*> Enhaced IDE/MFM/RLL disk/cdrom/tape/floppy support
  [ ] Use old disk-only driver on primary interface
  <*> Include ATA-2 DISK support
  <*> Include IDE/ATAPI CDROM support
  < > Include IDE/ATAPI TAPE support
  < > Include IDE/ATAPI FLOPPY support
  < > SCSI emulation support
  [*] CMD640 chipset bugfix/support
  [ ] CMD640 enhaced support
  [*] RZ1000 chipset bugfix/support
  [*] Generic PCI IDE chipset support
  [*] Generic PCI bus-master DMA support
  [ ] Boot of-board chipset firsts support
  [*] Use DMA by default when available
  [ ] Other IDE chipset support
  <M> Loopback device support
  <M> Network block device support
  [ ] Multiple devices driver support
  <M> RAM disk support
  < > XT hard disk support
  < > Mylex DAC960/DAC1100 PCI RAID Controller support (NEW)
  < > Parallel port IDE device support
  < > Compaq SMART2 support (NEW)
 Networking options --->
  <*> Packet socket
  [ ] Kernel/User netlink socket
  [ ] Network firewalls
  [ ] Socket Filtering
  <*> Unix domain sockets
  [*] TCP/IP networking
  [ ] IP: multicasting
  [ ] IP: advanced router
  [ ] IP: kernel level autoconfiguration
  [ ] IP: optimize as router not host
  < > IP: tunneling
  < > IP: GRE tunnels over IP
  [*] IP: aliasing support
  [ ] IP: TCP syncookie support (not enabled per default)
  [ ] IP: Reverce ARP
  [*] IP: Allow large windows (not recomended if <16Mb of memory>)
  <M> The IPX protocol
  < > Appletalk DDP
  < > CCITT X.25 Packet Layer (EXPERIMENTAL) (NEW)
  < > LAPB Data Link Driver (EXPERIMENTAL) (NEW)
  [ ] Bridging (EXPERIMENTAL) (NEW)
  [ ] 802.2 LLC (EXPERIMENTAL) (NEW)
  < > Acorn Econet/AUN protocols (EXPERIMENTAL) (NEW)
  < > Wan router (NEW)
  [ ] Fast switching (read help!) (NEW)
  [ ] Forwarding between high speed interfaces (NEW)
  [ ] CPU is too slow to handle full bandwidth (NEW)
  QoS and/or fair queueing --->
   [ ] QoS and/or fair queueing (NEW)
 Telephony Support --->
  < > Linux telephony support (NEW)
 SCSI support --->
  <M> SCSI support
  <M> SCSI disk support
  < > SCSI tape support
  <M> SCSI CD-ROM support
  <M> SCSI generic support
  [*] Probe alls LUNs on each SCSI device
  [*] Verbose SCSI error reporting (kernel size +=12K)
  [ ] SCSI loggin facility
  SCSI low-level drivers --->
   < > 7000FASST SCSI support
   < > ACARD SCSI support
   < > Adaptec AHA152X/2825 support
   < > Adaptec AHA1542 support 
   < > Adaptec AHA1740 support
   < > Adaptec AIC7xxx support
   < > IBM ServeRAID support (NEW)
   < > AdvanSys SCSI support 
   < > AM53/79C974 PCI SCSI support
   < > AMI MegaRAID support
   < > BusLogic SCSI support
   < > DTC3180/3280 SCSI support
   < > EATA ISA/EISA/PCI (DPT and generic EATA/DMA-compliant) support
   < > EATA-DMA [Obsolete] (DPT, NEC, AT&T, SNI, AST, Olivetti) support 
   < > EATA-PIO (Old DPT PM2001, PM2012A) support  
   < > Future Domain 16xx SCSI/AHA-2920A support
   < > GDT SCSI Disk Array Controller support
   < > Generic NCR5380/53c400 SCSI support
   < > Initio 9100(W) support
   < > Initio INI-A100U2W support
   < > IOMEGA parallel port (ppa-older drives) (NEW)
   < > IOMEGA parallel port (imm-newer drives) (NEW)
   < > NCR53c406a SCSI support
   < > Symbios 53c416 SCSI support
   < > Simple 53c710 SCSI support (Compaq, NCR machines) (NEW)
   < > NCR53c7, 8xx SCSI support
   < > NCR53C8XX SCSI support
   <M> SYM53C8XX SCSI support 
   (4) Default tagged command queue depth
   (32) Maximum number of queued commands
   (20) Synchronous transfers frequency in MHz 
   [ ] Enable profiling
   [ ] Use normal IO
   [ ] Inlcude support for the NCR PQS/PDS SCSI card
   [ ] Assume boards are SYMBIOS compatible (NEW)
   < > PAS16 SCSI support
   < > PCI2000 support
   < > PCI2220i support
   < > PSI240i support
   < > Qlogic FAS SCSI support
   < > Qlogic ISP SCSI support
   < > Qlogic ISP FC SCSI support
   < > Seagate ST-02 and Future Domain TMC-8xx SCSI support 
   < > Tekram DC390(T) and Am53/79C974 SCSi support
   < > Trantor T128/T128F/T228 SCSI support 
   < > UltraStor 14F/34F support
   < > UltraStor SCSI support
   < > SCSI debugging host adapter (NEW)
 Network device support --->
  [*] Network device support
  ARCnet devices --->
   < > ARCnet support
  Ethernet (10 or 100Mbit) --->
   [*] Ethernet (10 or 100Mbit)
   [ ] 3COM cards
   < > AMD LANCE and PCnet (AT15000 and NE21000) support
   [ ] Western Digital/SMC cards
   [ ] Recal-Interlan (Micom) NI cards
   < > RealTek 8129/8139 (not 8019/8029!) support (NEW)
   [ ] Other ISA cards
   [*] EISA, VLB, PCI and on board controllers
   < > AMD PCnet32 (VLB and PCI) support
   < > Ansel Communication EISA 3200 support (EXPERIMENTAL) (NEW)
   < > Apricot Xen-II on board Ethernet
   < > CS89x0 support
   < > DM9102 PCI Fast Ethernet Adapter support (EXPERIMENTAL) (NEW)
   < > Generic DECchip & DIGITAL EtherWORKS PCI/EISA
   < > DECchip Tulip (dc21x4x) PCI support
   < > Old DECchip Tulip (dc21x4x) PCI support (NEW)
   < > Digi Intl. RightSwitch SE-X support
   <M> EtherExpressPro/100 support
   < > Mylex EISA LNE390A/B support (EXPERIMENTAL) (NEW)
   < > Novell/Eagle/Microdyne NE3210 EISA support (EXPERIMENTAL) (NEW)
   < > PCI NE2000 support
   < > TI ThunderLAN support
   < > Via Rhine support
   < > SiS 900/7016 PCI Fast Ethernet Adapter support (NEW)
   < > Racal-Interlan EISA ES3210 support (EXPERIMENTAL) (NEW)
   < > SMC EtherPOWER II (EXPERIMENTAL) (NEW)
   [ ] Zenith Z-Note support (EXPERIMENTAL) (NEW)
   [ ] Pocket and portable adaptors
  Ethernet (1000 Mbit) --->
   < > Alteon AceNIC/3COM 3C985/NetGear GA620 Gigabit support (NEW)
   < > Packet Engines Yellowfin Gigabit-NIC support (NEW)
   < > SysKonnect SK-98xx support (NEW)
  <M> Dummy net driver support
  < > EQL (serial line load balancing) support
  < > General instruments SurfBoard 1000 (NEW)
  [ ] FDDI driver support
  <M> PPP (point-to-point) support
  <M> SLIP (serial line) support
  [ ] Wireless LAN (non-hamradio)
  Token ring devices --->
   [ ] Token ring driver support
  [ ] Fibre channel driver support (NEW)
  < > Red Creek Hardware VPN (EXPERIMENTAL)
  < > Traffic Shaper (EXPERIMENTAL) (NEW)
  Wan Interfaces --->
   < > Comtrol Hostess SV-11 support
   < > COSA/SRP sync serial boards support
   < > Sealevel Systems 4021 support
   < > MultiGate (COMX) synchronous serial boards support (NEW)
   < > Frame Relay DLCI support
  < > SBNI12-xx support (NEW)
 Amateur Radio support --->
  [ ] Amateur Radio support
 IrDA subsystem support --->
  [ ] IrDA subsystem support
 ISDN subsystem --->
  < > ISDN support
 Old CD-ROM drivers (not SCSI, not IDE) --->
  [ ] Support non-SCSI/IDE/ATAPI CD-ROM drives
 Character devices --->
  [*] Virtual terminal
  [*] Support for console on virtual terminal
  <*> Standard/generic (dumb) serial support
  [ ] Support for console on serial port
  [ ] Extended dumb serial driver options
  [ ] Non-standard serial port support
  [*] Unix98 PTY support
  (256) Maximum number of Unix98 PTYs in use (0-2048)
  [*] Mouse support (not serial mice)
  Mice --->
   < > ATIXL busmouse support
   < > Logitech busmouse support
   < > Microsoft busmouse support  
   [*] PS/2 mouse (aka "auxiliary device") support
   <M> C&T 82C710 mouse port support (as on TI Travelmate)
   < > PC110 digitalizer pad support
  Joysticks --->
   < > Joystick support
  < > QIC-02 tape support
  [ ] Watchdog timer support
  < > /dev/nvram support
  [*] Enhaced Real time clock support
  Video for Linux --->
   < > Video for Linux
  < > Double talk PC internal speech card support
  Ftape, the floppy tape device driver --->
   < > Ftape (QIC-80/Travan) support 
 Filesystems --->
  [ ] Quota support
  <*> Kernel automounter support
  < > Amiga FFS filesystem support
  < > Apple Macintosh filesystem support (experimental)
  <M> DOS FAT fs support
  <M> MSDOS fs support
  <M> UMSDOS: Unix-like filesystem on top of standard MSDOS filesystem
  <M> VFAT (Windows-95) fs support
  <*> ISO 9660 CDROM filesystem support
  [ ] Microsoft Joliet CDROM extensions
  <M> Minix fs support
  <M> NTFS filesystem support (read only)
  [*] NTFS read-write support (DANGEROUS) (NEW)
  < > OS/2 HPFS filesystem support (read only)
  [*] /proc filesystem support
  [*] /dev/pts filesystem for Unix98 PTYs
  < > ROM filesystem support
  <*> Second extended fs support
  < > System V and coherent file system support
  <M> UFS filesystem support
  < > SGI EFS sylesystem support (read-only) (EXPERIMENTAL) (NEW)
  Network File Systems --->
   < > Coda Filesystem support (advanced network fs)
   <M> NFS filesystem support 
   < > NFS server support (NEW)
   <M> SMB filesystem support (to mount WfW shares, etc)
   <M> NCP filesystem support (to mount NetWare volumes)
  Partition Types --->
   [ ] BSD disklabel (BSD partition tables) support
   [ ] Macintosh partition map support
   [ ] SMD disklabel (Sun partition tables) support
   [ ] Solaris (x86) partition table support
   [ ] Unixware slices support (EXPERIMENTAL) (NEW)
  Native Language Support --->
   < > Codepage 437 (United States, Canada) (NEW)
   < > Codepage 737 (Greek) (NEW) 
   < > Codepage 775 (Baltic Rim) (NEW)
   < > Codepage 850 (Europe) (NEW)
   < > Codepage 852 (Central/Eastern Europe) (NEW)
   < > Codepage 855 (Cyrillic) (NEW)
   < > Codepage 857 (Turkish) (NEW)
   < > Codepage 860 (Portuguese) (NEW)
   < > Codepage 861 (Icelandic) (NEW)
   < > Codepage 862 (Hebrew) (NEW)
   < > Codepage 863 (Canadian Frech) (NEW) 
   < > Codepage 864 (Arabic) (NEW)  
   < > Codepage 865 (Norwegian, Danish) (NEW)
   < > Codepage 866 (Cyrillic/Russian) (NEW) 
   < > Codepage 869 (Greek) (NEW) 
   < > Codepage 874 (Thai) (NEW)
   < > NLS ISO 8859-1 (Latin 1; Western European Languages) (NEW)
   < > NLS ISO 8859-2 (Latin 2; Slavic/Central European Languages) (NEW)
   < > NLS ISO 8859-3 (Latin 3; Esperanto, Galician, Maltese, Turkish) (NEW)
   < > NLS ISO 8859-4 (Latin 4; Estonian, Latvian, Lithuanian) (NEW) 
   < > NLS ISO 8859-5 (Cyrillic) (NEW)
   < > NLS ISO 8859-6 (Arabic) (NEW)
   < > NLS ISO 8859-7 (Modern Greek) (NEW) 
   < > NLS ISO 8859-8 (Hebrew) (NEW) 
   < > NLS ISO 8859-9 (Latin 5; Turkish) (NEW)
   < > NLS ISO 8859-14 (Latin 8; Celtic) (NEW) 
   < > NLS ISO 8859-15 (Latin 9; Western European Languages with Euro) (NEW)
   < > NLS KOI8-R (Russian) (NEW)
 Console drivers --->
  [*] VGA text console
  [ ] Video mode selection support
  < > MDA text console (dual-headed) (EXPERIMENTAL) (NEW)
  [ ] Support for frame buffer devices (EXPERIMENTAL) (NEW)
 Sound --->
  <M> Sound card support
  < > Support for C-Media PCI audio chips (EXPERIMENTAL)
  < > Ensoniq AudioPCI (ES1370)
  < > Creative Ensoniq AudioPCI 97 (ES1371)
  < > ESS Maestro
  < > ESS Solo1 (EXPERIMENTAL)
  < > S3 SonicVibes
  < > Support for Turtle Beach MultiSound Classic, Tahiti, Monterey
  < > Support for Turtle Beach MultiSound Pinnacle, Fiji
  <M> OSS sound modules
  <M> ProAudioSpectrum 16 support
  <M> 100% Sound Blaster compatibles (SB16/32/64, ESS, Jazz16) support
  <M> Gravis Ultrasound support
  [*] 16 bit sampling option of GUS (_NOT_ GUS MAX) (NEW)
  [*] GUS MAX support (NEW) 
  <M> MPU-401 support (not for SB16)
  <M> PSS (AD1848, ADSP-2115, ESC614) support
  [*] Enable PSS mixer (Beethoven ADSP-16 and other compatible) (NEW)
  <M> Microsoft Sound System support
  <M> Ensoniq SoundScape support
  <M> MediaTrix AudioTrix Pro support
  <M> VIA 82C686 Audio Codec
  <M> Support for OPTi MAD16 and/or Mozart based cards 
  [*] Support MIDI in older MAD16 based cards (requires SB) (NEW) 
  <M> Full support for Turtle Beach WaveFront (Tropez Plus)
  <M> Support for Crystal CS4232 based (PnP) cards
  <M> Support for Yamaha OPL3-SA2, SA3, and SAx based PnP cards
  <M> Limited support for Turtle Beach Wave Front synthesizer
  <M> Support for Aztech Sound Galaxy (non-PnP) cards
  <M> Support for AD1816(A) based cards (EXPERIMENTAL)
  <M> Yamaha OPL3-SA1 audio controller
  <M> SoftOSS software wave table engine  
  <M> FM synthesizer (YM3812/OPL-3) support
  <M> Loopbak MIDI device support
  <M> 6850 UART support
  <M> NM256AV/NM256ZX audio support
  Additional low level sound drivers --->
   [ ] Additional low level sound drivers 
 Kernel hacking --->
  [ ] Magic SysRq key

 Estas  son las opciones generales de un kernel 2.2.14, estan casi todos los
 manejadores; digo  casi todos  porque  no inclui algunos, como por ejemplo,
 los  manejadores para los Joysticks, o los manejadores para el sistema ISDN
 o los controladores  para el IrDA subsystem, o para el Video en Linux. Pero
 los  que  puse son *todos* por los  cuales se  debe preocupar. Aqui tambien
 entra la  parte del  soporte de dispositivos, los que usted ve ahi, son los
 que soporta  Linux, los  que  no estan ahi, pueden estar soportados pero no
 hacen parte de la  distribucion  oficial de las fuentes del kernel; como le
 dije anteriormente, busque estos drivers en :
  
  Linux Driver Support: http://www.torque.net/~campbell/

 Siempre  podra incluirlos como  modulos una vez que compile el kernel; para
 mas informacion lease la seccion <Probando los Modulos>.

 Fuentes de Linux :
 ------------------

 Podra adquirir las fuentes del kernel de Linux en algunos de los siguientes
 servidores, ya  sea por http o  por ftp; algunos  son  mirrors; algunos son
 sitios muy lentos y algunos muy  rapidos, el caso es que las fuentes no van
 a  pesar  menos  de 15000 Kb (15 Mb) y es  recomendable  bajar las  fuentes
 utilizando un navegador o programa que soporte Downloads con la utilidad de
 <Resuming> como GetRight; se incluyen  tambien los servidores que ponen los
 parches para el kernel; los servidores son :

  http://www.kernel.org
  ftp://ftp.funet.fi
  ftp://sunsite.unc.edu/pub/Linux/kernel
  http://www.linux.org.ar
  http://users.ox.ac.uk/~sann0312/kernel
  ftp://ftp.dfv.rwth-aachen.de/pub/linux/kernel
  ftp://fvkma.tu-graz.ac.at/pub/linux/linus
  ftp://ftp.ibp.fr/pub/linux/sources/system/patches
  ftp://kirk.bond.edu.au/pub/OS/Linux/kernel
  ftp://sunsite.rediris.es/pub/linux/kernel/sources
  http://www.debian.org
  http://www.freshmeat.net
  ftp://tsx-11.mit.edu/pub/linux/sources/system
  ftp://ftp.univie.ac.at/systems/linux/sunsite/kernel
  ftp://ftp.Germany.EU.net/pub/os/Linux/Local.EUnet/Kernel/Linus
  ftp://sunsite.informatik.rwth-aachen.de/pub/Linux/PEOPLE/Linus
  ftp://sunsite.anu.edu.au/pub/linux/kernel
  ftp://kernel.linux.org.ve/pub/linux/kernel
  http://www.linuxhq.com

 Contacto :
 ----------

 Si quiere puede contactar al autor de este documento o si lo prefiere puede
 comunicarce directamente con Linus Torvalds o con algunos de los muchos que
 desarrollan  y  perfeccionan  el  nucleo de Linux. Para lo ultimo que dije,
 mire el  archivo /usr/src/linux/MAINTAINERS  y /usr/src/linux/CREDITS. Para
 comunicarce con  Linus Torvalds <torvalds@transmeta.com> y para comunicarce
 con el autor del documento <cpu1ph1c@usa.net>

 cpu-1ph1c

 8oooooooooooooooooooo CopyRight (c) 2000 - cpu-1ph1c ooooooooooooooooooooo8
