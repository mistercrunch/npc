<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< DP 4 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
**** [ Marconi ][ inocraM@yahoo.com ] ***************** { CRACK } *******
--------------------------------------------------------------------------

hur hur!

Lo mejor sera ke komienze por presentarme: Respondo al nick de Marconi,y
podeis contactar conmigo escribiendo a:
                   inocraM@yahoo.com
Y soy uno de los miembros de la page:
             http://members.xoom.com/el_liceo

Bueno, pues una vez hechas las presentaciones, vamos a centrarnos en el tema
ke nos okupa. El caso es ke uno de los programas ke mas utilizo es el winzip,
y supongo ke a muchos de vosotros os pasara lo mismo. Yo tengo en casa la
version 8.0, y he tardado relativamente poco en kedar hasta los kojones del
botoncito de "i agree" y demas, y eso de ke los putos botones ( no son
imaginaciones mias verdad?) se cambien de posicion termino con mi paciencia
hace tiempo. Supongo ke conseguir en internet una pareja nombre-num_registro
para el programilla este es facil, pero el hacertelo tu mismo es mas
divertido, y es casi tan sencillo como la primera opcion. Asi, ke sin mas, 
voy a pasar a explicaros como lo hice yo:

-Conocimientos requeridos...
   
    Pues unos conocimientos minimos de ensamblador. Saber leer y contar al
menos hasta 10 tampoco estaria mal, y si sabes algo del cultivo de la maria,
entonces lo pones por escrito y me lo mandas (mi mail ta arriba)  :)

-Que programas necesito?...

    Yo utilice el W32Dasm, la version 8.93 :) Cada cual ke use lo ke le de
la gana y se atenga a las consecuencias... hay por ahi un
desensamblador/debugger muy bueno, el backdoor orifice o algo asi creo ke se
llama... :?


-Hechandole un vistazo a la aplicacion...

Vamos a comenzar por ejecutarla... y en la ventana to-ca-co-jo-nes en
cuestion podemos leer...

                      THANK YOU FOR TRYING WINZIP!
  This is a fully functional unregistered version fou evaluation use only.
           The registered version does not display this notice.

Pues eso, lo ke kiero es registrarme :)
y un poco mas abajo se puede leer:

  You can order the registered version online, by phone, or by mail.
   Immediate online delivery is available from www.winzip.com

Justo debajo de esto hay dos botones con "view evaluation license" y
"enter registration code"
mas abajo te suelta un otro rollo mas y despues los tres botones de
"i agree", "quit" y "ordering info".
Pues bien, despues de pulsar "ordering info", me sale una ventanita con
tres botones, uno para cancelar, otro para conectarse a la pagina de
winzip, y otro para poder ver un archivo de ayuda, donde nos enteramos
ke el registro cuesta 29 dolares. jarl! a cuanto ta el dollar??? :P

Ahora doy a "enter registration code" y nos aparece una ventana soltandonos
un rollo, y justo debajo dos campos,uno para el nombre y otro para el numero
de registro. Debajo de esto tenemos los botones de "ok","cancel", "continue
unregistered" y "help". Seguidamente relleno el nombre y el num. de registro
a bulto y le doy al "ok", apareciendome una ventana ke me dice "incomplete
or incorrect information", y con dos botones debajo, el de ayuda y el de
aceptar, y tambien tiene un dibujito en un lado.


-Vamos con ello...
 
 Lo primero ke vamos a hacer es desensamblar el archivo Winzip32.exe, usando
el W32Dasm. Una vez hecho esto, debemos buscar la cadena "Incomplete or
incorrect information" que aparecia en el mensaje de error. Esto lo podemos
hacer buscando la cadena en "String Data Refs", del menu "Refs" y haciendo
doble click sobre ella, o bien con la opcion "Find Test" del menu "Search".
Usando la primera opcion, tenemos acceso a una lista de cadenas, en la ke
debemos buscar la ke nos interesa, y despues de buscar un poco podemos ver...

                          .
                          .
                          .
   String Resource ID=00652: "Could not find %s"
   String Resource ID=00653: "WinZip Add-Ons cannot be...
   String Resource ID=00654: "Incomplete or incorrect information"
   String Resource ID=00655: "For full access to WinZip's...
   String Resource ID=00656: "However, a different copy...
                          .
                          .
                          .
 
Si ahora hacemos un doble click sobre la cadena ke nos interesa, el programa
se pondra a buscar donde se referencia esa cadena en el programa. Si hacemos
un segundo doble click el programa buscara una segunda referencia a la cadena
en el programa. Hacemos un doble click, y vemos como en la linea inferior del
W32Dasm aparece:

Line 16771 Pg 200 of 3275 Code Data @:0040800A @Offset 0000800Ah in....

que es donde se ha encontrado la referencia, si ahora hacemos otro doble
click vemos ke no nos movemos de ahi, lo ke indica ke solo hay esa
referencia.Pues mas facil ke nos lo ponen :) Si miramos la zona de codigo
donde estamos podemos ver...

                          .
                          .
                          .
|:00407FAA(C), :00407FB3(C), :00407FBC(C)
|
:00408005 E89C020000              call 004082A6

* Possible Reference to String Resource ID=00654: "Incomplete or incorrect
                                  |                          [information"
:0040800A 688E020000              push 0000028E
:0040800F E8D9750300              call 0043F5ED
:00408014 50                      push eax
:00408015 53                      push ebx
                          .
                          .
                          .


y si miramos un poco mas arriba podemos ver lo siguiente....




:00407F5F BF78CD4800              mov edi, 0048CD78
:00407F64 6A29                    push 00000029
:00407F66 57                      push edi
:00407F67 68800C0000              push 00000C80
:00407F6C 53                      push ebx
* Reference To: USER32.GetDlgItemTextA, Ord:0104h
                                  |
:00407F6D FF1528744700            Call dword ptr [00477428]
:00407F73 57                      push edi
:00407F74 E821790300              call 0043F89A
:00407F79 57                      push edi
:00407F7A E844790300              call 0043F8C3
:00407F7F 59                      pop ecx
:00407F80 BEA4CD4800              mov esi, 0048CDA4
:00407F85 59                      pop ecx
:00407F86 6A0B                    push 0000000B
:00407F88 56                      push esi
:00407F89 68810C0000              push 00000C81
:00407F8E 53                      push ebx

* Reference To: USER32.GetDlgItemTextA, Ord:0104h
                                  |
:00407F8F FF1528744700            Call dword ptr [00477428]
:00407F95 56                      push esi
:00407F96 E8FF780300              call 0043F89A
:00407F9B 56                      push esi
:00407F9C E822790300              call 0043F8C3
:00407FA1 803D78CD480000          cmp byte ptr [0048CD78], 00
:00407FA8 59                      pop ecx
:00407FA9 59                      pop ecx
:00407FAA 7459                    je 00408005
:00407FAC 803DA4CD480000          cmp byte ptr [0048CDA4], 00
:00407FB3 7450                    je 00408005
:00407FB5 E81BFAFFFF              call 004079D5
:00407FBA 85C0                    test eax, eax
:00407FBC 7447                    je 00408005
:00407FBE 57                      push edi
:00407FBF BFA4FF4700              mov edi, 0047FFA4
:00407FC4 6824DB4700              push 0047DB24
:00407FC9 57                      push edi
:00407FCA E80B360300              call 0043B5DA
:00407FCF 56                      push esi
:00407FD0 686CE64700              push 0047E66C
:00407FD5 57                      push edi
:00407FD6 E8FF350300              call 0043B5DA
:00407FDB 68C4FF4700              push 0047FFC4
:00407FE0 6A00                    push 00000000
:00407FE2 6A00                    push 00000000
:00407FE4 6830DB4700              push 0047DB30
:00407FE9 E8D3350300              call 0043B5C1
:00407FEE A1F47A4800              mov eax, dword ptr [00487AF4]
:00407FF3 83C428                  add esp, 00000028
:00407FF6 85C0                    test eax, eax
:00407FF8 7407                    je 00408001
:00407FFA 50                      push eax
:00407FFB FF1570704700            Call dword ptr [00477070]

* Referenced by a (U)nconditional or (C)onditional Jump at Address:
|:00407FF8(C)
|
:00408001 6A01                    push 00000001
:00408003 EB30                    jmp 00408035

* Referenced by a (U)nconditional or (C)onditional Jump at Addresses:
|:00407FAA(C), :00407FB3(C), :00407FBC(C)
|
:00408005 E89C020000              call 004082A6
:0040800A 688E020000              push 0000028E  <- "Incomplete or....
:0040800F E8D9750300              call 0043F5ED
:00408014 50                      push eax
:00408015 53                      push ebx
:00408016 6A3D                    push 0000003D
:00408018 E808800200              call 00430025
:0040801D 83C410                  add esp, 00000010
:00408020 FF05F87A4800            inc dword ptr [00487AF8]
:00408026 833DF87A480003          cmp dword ptr [00487AF8], 00000003
:0040802D 0F85F9000000            jne 0040812C
:00408033 6A00                    push 00000000

* Referenced by a (U)nconditional or (C)onditional Jump at Addresses:
|:00407F21(U), :00408003(U)
|
:00408035 53                      push ebx


Pues bien, es hora de recordar ke es exactamente lo ke hace la funcion
GetDlgItemTextA, de la libreria USER32 ( archivo de cabecera winuser.h):

      UINT GetDlgItemTextA (
                     HWND hDlg,            // handle.
                     int nlDDlgItem,       // Identificador de control.
                     LPTSTR lpString       // Direccion del buffer.
                     int nMaxCount         // tama¤o maximo de cadena.
                            );

Lo que hace esta funcion, es coger la cadena introducida por el usuario en
el cuadro de dialogo identificado por el handle. Con esto podemos 
saber ke la cadena que cogera la primera llamada a la funcion sera 
guardada en [0048CD78], y la cadena recogida en la segunda llamada sera
guardada en [0048CDA4] ( Antes de las llamadas se pueden ver como se
cargan alguno de estos dos valores en edi/esi y despues se pushean dentro
de la pila). LLamo la atencion sobre estas dos direcciones porke aparecen
un poco mas abajo, siendo comparado su contenido con 00h, lo ke ekivale a
preguntarnos si la cadena ke hemos cogido es la cadena vacia.

Despues de hecharle un vistazo al trozo de codigo visto antes encima llegamos
a las siguientes conclusiones:
 - No quiero que se ejecute el codigo que hay a partir de la direccion
00408005, pues en principio parece ke las lineas

:0040800A 688E020000              push 0000028E  <- "Incomplete or....
:0040800F E8D9750300              call 0043F5ED

que estan justo debajo lo ke hacen es ense¤ar el mesaje de error.

 - Las dos llamadas a la funcion GetDlgItemTextA(...) parecen ser las ke
recogen el nombre y el numero de serie.

 - La unica forma de ke se ejecuten las dos llamadas a esa funcion y de ke
despues no se ejecute el codigo ke nos ense¤aria el mensaje de error esta en

:00408003 EB30                    jmp 00408035

y para ke esto se pueda ejecutar se tiene ke dar todo lo siguiente:

:00407FA1 803D78CD480000          cmp byte ptr [0048CD78], 00
:00407FA8 59                      pop ecx
:00407FA9 59                      pop ecx
:00407FAA 7459                    je 00408005
:00407FAC 803DA4CD480000          cmp byte ptr [0048CDA4], 00
:00407FB3 7450                    je 00408005

1) Este trozo nos indica ke ninguna de las cadenas recogidas por sendas
llamadas a GetDlgItemTextA(...) deberia ser una cadena vacia

:00407FB5 E81BFAFFFF              call 004079D5
:00407FBA 85C0                    test eax, eax
:00407FBC 7447                    je 00408005

2) Este trozo nos indica ke esa funcion no deberia devolver eax=0

Bueno, pues parece ke ya tenemos la funcion ke se encarga de la 
comprobacion. Podriamos pensar ke una buena solucion seria cambiar ese
je por un jne pero debemos tener en cuenta lo siguiente: Este trozo de codigo
es el ke se ejecuta cuando intentamos registrarnos. Si hacemos ese cambio
lo ke konseguiriamos es que siempre podriamos registar el programa
independientemente del numero de registro introducido en la ventana de
registro. Pero esto presenta un problema, y es ke probablemente esa funcion
sea llamada desde otros puntos del programa, en cuyo caso descubriria ke
el registro no es valido.

Hechemosle un vistazo: Si nos situamos encima y
escogemos la opcion "Execute Call", del menu "Execute Text", nos 
situamos sobre la funcion en cuestion :)


* Referenced by a CALL at Addresses:
|:0040108B   , :00401221   , :004041E8   , :00407FB5   , :00433D12   
|
:004079D5 55                      push ebp
:004079D6 8BEC                    mov ebp, esp
:004079D8 81EC08020000            sub esp, 00000208
:004079DE 53                      push ebx
:004079DF 56                      push esi
:004079E0 33F6                    xor esi, esi
:004079E2 803D78CD480000          cmp byte ptr [0048CD78], 00
:004079E9 57                      push edi
:004079EA 0F849A000000            je 00407A8A
:004079F0 8D45EC                  lea eax, dword ptr [ebp-14]
:004079F3 50                      push eax
:004079F4 6868E34700              push 0047E368
:004079F9 E8AE9DFFFF              call 004017AC
:004079FE 8D85F8FDFFFF            lea eax, dword ptr [ebp+FFFFFDF8]
:00407A04 BF78CD4800              mov edi, 0048CD78
:00407A09 50                      push eax
:00407A0A 57                      push edi
:00407A0B E89B020000              call 00407CAB
:00407A10 8D85F8FDFFFF            lea eax, dword ptr [ebp+FFFFFDF8]
:00407A16 50                      push eax
:00407A17 8D45EC                  lea eax, dword ptr [ebp-14]
:00407A1A 50                      push eax
:00407A1B E8B0180600              call 004692D0
:00407A20 83C418                  add esp, 00000018
:00407A23 85C0                    test eax, eax
:00407A25 6A01                    push 00000001
:00407A27 5B                      pop ebx
:00407A28 7502                    jne 00407A2C
:00407A2A 8BF3                    mov esi, ebx

* Referenced by a (U)nconditional or (C)onditional Jump at Address:
|:00407A28(C)
|
:00407A2C 8D45EC                  lea eax, dword ptr [ebp-14]
:00407A2F 50                      push eax
:00407A30 6878E34700              push 0047E378
:00407A35 E8729DFFFF              call 004017AC
:00407A3A 8D45EC                  lea eax, dword ptr [ebp-14]
:00407A3D 50                      push eax
:00407A3E 57                      push edi
:00407A3F E88C180600              call 004692D0
:00407A44 83C410                  add esp, 00000010
:00407A47 85C0                    test eax, eax
:00407A49 750C                    jne 00407A57
:00407A4B FF15D8714700            Call dword ptr [004771D8]
:00407A51 84C3                    test bl, al
:00407A53 7402                    je 00407A57
:00407A55 8BF3                    mov esi, ebx

* Referenced by a (U)nconditional or (C)onditional Jump at Addresses:
|:00407A49(C), :00407A53(C)
|
:00407A57 6A14                    push 00000014
:00407A59 8D45EC                  lea eax, dword ptr [ebp-14]
:00407A5C 6A00                    push 00000000
:00407A5E 50                      push eax
:00407A5F E8AC010600              call 00467C10
:00407A64 68C8000000              push 000000C8
:00407A69 8D85F8FDFFFF            lea eax, dword ptr [ebp+FFFFFDF8]
:00407A6F 6A00                    push 00000000
:00407A71 50                      push eax
:00407A72 E899010600              call 00467C10
:00407A77 83C418                  add esp, 00000018
:00407A7A 85F6                    test esi, esi
:00407A7C 7413                    je 00407A91
:00407A7E E823080000              call 004082A6
:00407A83 8325DC9F480000          and dword ptr [00489FDC], 00000000

* Referenced by a (U)nconditional or (C)onditional Jump at Address:
|:004079EA(C)
|
:00407A8A 33C0                    xor eax, eax
:00407A8C E9B1000000              jmp 00407B42

* Referenced by a (U)nconditional or (C)onditional Jump at Address:
|:00407A7C(C)
|
:00407A91 8D85C0FEFFFF            lea eax, dword ptr [ebp+FFFFFEC0]
:00407A97 50                      push eax
:00407A98 57                      push edi
:00407A99 E8A9000000              call 00407B47
:00407A9E BEA4CD4800              mov esi, 0048CDA4
:00407AA3 8D85C0FEFFFF            lea eax, dword ptr [ebp+FFFFFEC0]
:00407AA9 56                      push esi
:00407AAA 50                      push eax
:00407AAB E820180600              call 004692D0
:00407AB0 83C410                  add esp, 00000010
:00407AB3 F7D8                    neg eax
:00407AB5 1BC0                    sbb eax, eax
:00407AB7 40                      inc eax
:00407AB8 A3DC9F4800              mov dword ptr [00489FDC], eax
:00407ABD 7568                    jne 00407B27
:00407ABF 8D85C0FEFFFF            lea eax, dword ptr [ebp+FFFFFEC0]
:00407AC5 50                      push eax
:00407AC6 57                      push edi
:00407AC7 E818010000              call 00407BE4
:00407ACC 8D85C0FEFFFF            lea eax, dword ptr [ebp+FFFFFEC0]
:00407AD2 56                      push esi
:00407AD3 50                      push eax
:00407AD4 E8F7170600              call 004692D0
:00407AD9 83C410                  add esp, 00000010
:00407ADC F7D8                    neg eax
:00407ADE 1BC0                    sbb eax, eax
:00407AE0 40                      inc eax
:00407AE1 A3DC9F4800              mov dword ptr [00489FDC], eax
:00407AE6 753F                    jne 00407B27
:00407AE8 8D85C4FEFFFF            lea eax, dword ptr [ebp+FFFFFEC4]
:00407AEE 6A04                    push 00000004
:00407AF0 50                      push eax
:00407AF1 56                      push esi
:00407AF2 E8C91B0600              call 004696C0
:00407AF7 83C40C                  add esp, 0000000C
:00407AFA 85C0                    test eax, eax
:00407AFC 7522                    jne 00407B20
:00407AFE 8D85C0FEFFFF            lea eax, dword ptr [ebp+FFFFFEC0]|
:00407B04 6A04                    push 00000004
:00407B06 50                      push eax
:00407B07 68A8CD4800              push 0048CDA8
:00407B0C E8AF1B0600              call 004696C0
:00407B11 83C40C                  add esp, 0000000C
:00407B14 85C0                    test eax, eax
:00407B16 7508                    jne 00407B20
:00407B18 891DDC9F4800            mov dword ptr [00489FDC], ebx
:00407B1E EB07                    jmp 00407B27
:00407B20 8325DC9F480000          and dword ptr [00489FDC], 00000000

* Referenced by a (U)nconditional or (C)onditional Jump at Addresses:
|:00407ABD(C), :00407AE6(C), :00407B1E(U)
|
:00407B27 682C010000              push 0000012C
:00407B2C 8D85C0FEFFFF            lea eax, dword ptr [ebp+FFFFFEC0]
:00407B32 6A00                    push 00000000
:00407B34 50                      push eax
:00407B35 E8D6000600              call 00467C10
:00407B3A A1DC9F4800              mov eax, dword ptr [00489FDC]
:00407B3F 83C40C                  add esp, 0000000C

* Referenced by a (U)nconditional or (C)onditional Jump at Address:
|:00407A8C(U)
|
:00407B42 5F                      pop edi
:00407B43 5E                      pop esi
:00407B44 5B                      pop ebx
:00407B45 C9                      leave
:00407B46 C3                      ret

Como podeis ver esta funcion es llamada desde 5 diferentes sitios dentro
del programa. Con esto keda efectivamente descartada como buena la idea de
modificar el salto ke habia antes de nuestra llamada a esta funcion.

Nuestro objetivo es ke al final de la funcion eax no sea igual a 0.

Y ahora se presentan dos posibles caminos:
 Primero, usando un heditor hexadecimal (Ultra Edit o similar) modificar
el archivo .exe para ke esta funcion devuelva siempre eax=1 por ejemplo.
 Modo de hacer esto:
 Nos fijamos en esta linea:
:00407B3A A1DC9F4800              mov eax, dword ptr [00489FDC]
Tenemos ke kojer un patron de buskeda ke kontenga esta instruccion, de tal
manera ke solo lo encontremos una vez. Por ejemplo si cogemos esta
instruccion solamente tendremos la cadena A1DC9F4800 pero al buscarla la
encontraremos en dos posiciones diferentes con lo ke no tenemos forma de
saber cual de las dos tenemos ke modificar. Sin embargo, cogiendo un trozo
de la instruccion anterior construimos la cadena 0600A1DC9F4800. Si con el
heditor hexadecimal buscamos esta cadena dentro del ejecutable solo la
encontraremos en una posicion. Ahora solo tenemos ke modificar esa cadena
para hacer ke devuelva siempre eax=1. Por ejemplo: 33C0 es xor eax,eax,
40 es inc eax y 90 es nop ( todo en hexadecimal, claro esta) si cambiamos el
A1DC9F4800 por 33C0409090 ya habriamos  hecho lo ke keriamos.

 Y el segundo camino: Teniendo en cuenta ke hemos llegado hasta aki con
bastante facilidad, bien podriamos seguir a ver ke nos encontramos. Volviendo
al codigo podemos ver que :

 - Si llegamos al final por el salto incondicional ke hay justo antes
de recuperar de la pila los valores de edi,esi y ebx, es ke se ejecuto
esto:

* Referenced by a (U)nconditional or (C)onditional Jump at Address:
|:004079EA(C)
|
:00407A8A 33C0                    xor eax, eax
:00407A8C E9B1000000              jmp 00407B42

con lo ke devolveriamos eax=0, y esto no nos vale... si miramos cual es
la condicion para ke esto se ejecute vemos...

:004079E2 803D78CD480000          cmp byte ptr [0048CD78], 00
:004079E9 57                      push edi
:004079EA 0F849A000000            je 00407A8A

con lo ke podemos ver ke la condicion es ke una de las cadenas 
recogidas por las llamadas a la funcion GetDlgItemTextA(...) sea la
cadena vacia, y ya habiamos dicho anteriormente ke esto no se deberia 
producir.

Seguimos mirando en el codigo ke hay justo antes de retornar, teniendo en
cuenta ke NO vamos a llegar al final de la funcion por el salto incondicional
ke nos lleva justo al final...
Mirando un poco mas arriba vemos...

:00407B35 E8D6000600              call 00467C10
:00407B3A A1DC9F4800              mov eax, dword ptr [00489FDC]
:00407B3F 83C40C                  add esp, 0000000C

lo ke indica ke el valor ke retornemos sera el guardado en [00489FDC].
Y justo antes de esto hay un punto referenciado por 3 saltos:

:00407ABD(C), :00407AE6(C), :00407B1E(U)

Miramos el primero de ellos...

:00407AAB E820180600              call 004692D0
:00407AB0 83C410                  add esp, 00000010
:00407AB3 F7D8                    neg eax
:00407AB5 1BC0                    sbb eax, eax
:00407AB7 40                      inc eax
:00407AB8 A3DC9F4800              mov dword ptr [00489FDC], eax
:00407ABD 7568                    jne 00407B27

Vemos ke antes del salto, ke se efectua si eax es distinto de 0, se guarda
eax en [00489fdc], ke era justo la posicion en el ke se guarda el valor ke
se retornara en eax. Las tres instrucciones neg eax, sbb eax,eax y inc eax
lo ke hacen en hacer eax=0 si eax!=0 y eax=1 si eax=0, con lo ke todo iria
de puta madre si la funcion 004692D0 devolviese 0. Hechemosle un peke¤o
vistazo a la funcion anterior... haciendo como antes, y podemos ver ke lo ke
hace esa funcion es comparar cadenas ke se le pasan como parametro,
devolviendo 0 si son iguales, y ademas no diferencia mayusculas de
minusculas..... ( lo podeis mirar vosotros mismos, es bastante sencillo)
Bien parece ke hemos llegado justo a donde keriamos... ahora es el
momento de usar el debugger ke tiene el W32Dasm....
Escogemos la opcion "Load Process" del menu "Debug", y no introducimos
parametro alguno. Apareceran las ventanas del debugger, que se parara
en la primera instruccion del programa ( no tiene porke, se puede parar
antes en alguna libreria por ejemplo si tenemos marcada la casilla de
"DLL Load Brk"). El caso es ke ahora ponemos tres puntos de ruptura,
dos en las llamadas a GetDlgItemTextA(...) para saber si hacertamos 
en nuestras hipotesis, y otro en la funcion 004692d0 para ver ke
kadenas compara :) (los puntos de ruptura se ponen pulsando F2 sobre
la linea deseada), y le damos al boton de RUN de la ventana del 
debugger ( o pulsamos f9) teniendo activa unicamente la casilla de 
"Enable Documented API Details", vemos como aparece la ventana del 
WinZip ( si se para antes, simplemente volved a pulsar RUN). Le damos
al boton de "Enter Registration Code", rellenamos el nombre "Marconi"
y el numero de registro "nosecuales"...le doy al ok. Y al momento salta
nuestro primer punto de ruptura :) pudiendo ver ke el primer
GetDlgITextA(...) lo ke hace es efectivamente coger el nombre y el segundo
la clave.(No me paro a explicar en detalle como funciona este debugger pues
creo ke es lo bastante sencillo e intuitivo ;)

Una vez visto ke estamos en lo cierto volvemos a pulsar RUN y el ultimo
breakpoint parara la ejecucion del programa en la funcion ke keremos ver :).
Si miramos a que cadenas apuntan esi y eax, ke son los valores  introducidos
en la pila, osea, las direcciones de las cadenas a comprar podemos ver ke
una es "nosecuales" y la otra "D50808C6". Pues bien, ahora le volvemos a dar
a RUN, y nos sale el mensaje de error. Volvemos a rellenar el numero de
registro esta vez kon el valor ke deberia servirnos, deshabilitamos los
breakpoints ( en una de las ventanas del debugger hay una lista de todos los
breakpoints, en la ke estos tienen un asterisco para indicar ke estan
activos,justo debajo de la ventana ke muestra el contenido de los registros
de segmento. A su lado  hay dos botones AA y DA para habilitar y
deshabilitar), y le damos a ok. Esta vez nos sale una ventana pidiendote ke
pulses ok para confirmar el registro :) y ya esta :))))

Como podeis ver, es mas ke sencillo :) y ya no tendreis ke soportar mas la
mierda de ventana pidiendo ke os registreis. :)... bien, pues con esto
termino. Cualkier pregunta/critica/sugerencia como siempre, mandadla a
mi email, ke he puesto arriba. Y por supuesto, si veis alguna errata ( ke
las hay, seguro, kon lo despistao ke soy...) agradeceria ke me lo
komunicaseis :) 

Notas de ultima hora: Si lo unico ke kieres es crackear el programa sin parar
a buscar tu numero de registro, lo mas rapido seria usar un debugger y no
pararse a desensamblarlo. Supongo ke todos os habreis fijado en el estilo de
la ventana de error cuando te ekivocas en el registro. Si usais el Softice
por ejemplo solo teneis ke poner un bpx en messageboxindirect() (USER.DLL)
para ke la ejecucion se detenga justo antes de dibujar la ventana, y seguir
a partir de ahi... No me paro a explicar esto en detalle pero es tan facil
como lo anterior :)
 Y si habeis hechado un vistazo con un poco de detenimiento tambien os
habreis fijado en ke el codigo de registro no es unico, sino ke hay al menos
tres numeros de registro posibles... Pero esto se escapa ya al objetivo de
este texto... Agur ;)

PD: Graziaz a Lykeios por sus sugerencias ;)
