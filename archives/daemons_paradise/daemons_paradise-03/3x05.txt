<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< DP 3 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
**** [ Kurtz ][ kurtzk@bigfoot.com ] ************ { PROGRAMACION } *******
--------------------------------------------------------------------------


--------------------------------------------------------------------------------
				PROGRAMACIÓN EN SHELL II
--------------------------------------------------------------------------------
by Kurtz Kurtzk@bigfoot.com 





6º TUBERÍAS Y REDIRECCIONAMIENTO
--------------------------------

En la ejecución de un programa normalmente necesita una entrada de datos(0), una
salida(1) de resultados y una salida(2) de posibles errores, en Linux (como todo
UNIX) se puede modificar los valores por defecto (el terminal para la entrada y
la pantalla para las dos salidas). Esto es muy útil ya que te puede interesar 
ver los errores de un programa en otro terminal o que los datos de salida te los
guarde en un fichero o los manipule otro programa.

comando <  archivo 	utiliza los datos de un archivo 
 
comando > archivo  	guarda los datos de salida en un archivo (si existe lo 
			sobrescribe)
comando >> archivo 	guarda los datos de salida en un archivo (si existe lo 
			guarda al final de este)
 
si ponemos 2> ó 2>> lo mismo pero con los errores 
si en vez de un archivo ponemos la dirección de un dispositivo (/dev/lp0, /dev/
tty6) lo redireccionaria a este dispositivo 

por ejemplo si ponemos 

$cat archivo > /dev/lp0  

imprimiría el archivo sin pasarlo por pantalla

Para redireccionar la salida a la entrada de otro programa se usan las tuberías:

comando | comando 

comando |tee comando1 comando2  la salida de comando la redirecciona a comando1
				 y 2    

este último es muy útil para guardar la salida a un archivo y a la vez 
encaminarla a otro programa

para introducir datos a un comando directamente, sin usar un archivo se pone:

comando <<corres  algo  corres		donde corres es la correspondencia que 
					se pone al final para comunicar que se 
					ha terminado de introducir datos. Si se
					pone <<- se eliminan los tabuladores al
					comienzo de una linea. 
ejemplo:

-------------------------------------------------------------------------------
while read n
do
echo"$n"
done <<A
1
3
4
A
-------------------------------------------------------------------------------



7º Filtros
-----------------------------

Se utilizan normalmente en tuberías para manipular la salida de un comando.

7.1 SORT
--------
 Este comando clasifica las lineas de uno o varios ficheros y muestra en la 
salida el resultado, la clasificación puede ser alfabética o numérica, se usa 
normalmente al final de las tuberías ya que consume muchos recursos.   
Con -t indicamos el separador de campos, si no se dice nada es : 
    
-n clasifica numéricamente 
-f ignora distinción mayúsculas minúsculas 
-b ignora los blancos antes del campo
+pos empieza a ordenar por la posición pos (0 es la primera )
-pos termina de ordenar en pos
-r clasifica en orden inverso (mayor a menor)
-d según el orden del diccionario
 
por ejemplo 

sort +4n -5r -t" " archivo   ordenaría la 4º numéricamente, luego 0,1,2,.... y 
				la última la 5º que la ordenaría inversamente, 
				el espacio sería el delimitador  


7.2 CUT
-------
Como su traducción literal indica coge un archivo y muestra las columnas que 
indiques con  -d indicamos el delimitador igual que se hace con el sort

-f especifica los campos que se quieren quitar (1 primer campo no como el sort)
 
-c se indica las columnas que se quieren quitar, i-j,k de la i a la j y además 
	la k también aquí empieza en 1 

por ejemplo 

cat archivo | cut -c1 | sort   mostraría el primer carácter del archivo ordenado

7.3 PASTE
---------- 
Este hace lo contrario que el cut coge varios archivos y pega sus columnas , 
con -d se especifica el separador que por defecto es el tabulador  si se ponen 
varios el primer carácter separaría los dos primeros ficheros y así sucesivamente
, si se acaban los separadores empezaría otra vez por el primero.

-s se usa para juntar las lineas de un archivo  

por ejemplo 

 cat passwd | cut -d: -f1 | paste -s  mostraría una linea con todos los usuarios
 


7.4 TR y UNIQ
--------------
Los he puesto juntos porque tienen poco que contar , el comando tr traduce una 
lista de caracteres por otra, ojo no palabras si no carácter a carácter:

tr [a-z] [A-Z] < archivo   cambiaría las minúsculas por mayúsculas

El comando uniq simplemente quita las lineas duplicadas

7.5 GREP
----------
seguramente es el más usado normalmente, básicamente busca una expresión dada en
 un/os ficheros y muestra las lineas donde se contienen, la expresión viene 
entre comillas y si hay varios archivos muestra primero el archivo de 
procedencia de la linea.

-c muestra el numero de lineas que contienen la expresión 

-i ignora mayúsculas o minúsculas en las comparaciones 

-l muestra solo los nombres de los ficheros que tienen la expresión

-n muestra el numero de linea delante de esta 

-s no muestra error

-v muestra todas las lineas menos las que tienen la expresión 

en las expresiones se usa lo dicho en la primera parte
por ejemplo 

gres -c '^[a]*$a' archivo  contaría las lineas que empiezan y terminan por a


7.6 WC
--------
Cuenta:
-l lineas
-w palabras
-c caracteres 


7.7 SED
--------
Este comando modifica un archivo en la salida, los comandos que modifican el 
texto pueden introducirse con -e programa ó -f fichero o directamente 
entrecomillados. Con la opción -n suprime la salida por defecto (solo muestra 
lo modificado)
 los comandos son(si no se pone la linea en el comando se aplica a todas):

nd   borra la linea n
 
na\  inserta texto después de la linea n (el texto después de \) 

ni\  inserta texto en la linea n 

s/cadena/sustitución   sustituye cadena por sustitución

p    imprime la linea (normalmente se pone -n para que solo salgan esas)

q    en toda la linea (s/algo/nada/q)


por ejemplo 

sed s/algo/hda archivo 			sustituye algo por hda

sed  

 

8º AWK
-----------------------------------

El comando awk es en realidad un filtro (entonces porque no está en el apartado
anterior???) pues porque complementa las carencias del shell hasta el punto de
poder ser considerado como un lenguaje de programación.

Como filtro busca lineas en un fichero y realiza operaciones con ellas . 

awk '/cadena/' {comando}  fichero

la cadena a buscar tiene la misma sintaxis que sed , si no se pone nada la
operación se realiza a todas las lineas por ejemplo {print} .
por ejemplo:

awk '/^a/' {print }  	imprimiría todas las lineas que empiecen por a   


8.1 IMPRESIÓN
--------------
Las lineas las divide automáticamente en campos cuyo separador es el espacio o
el tabulador, para modificar el separador se usa -F:.
A estos campos se los referencia por $1 $2 ...., para referenciar toda la linea
(por defecto) $0 y $NF el numero de campos.por ejemplo

awk  {print $1 " " $NF " " NF} fichero       mostraría el primer campo del 
						fichero, el último y el nº de 
						campos

para controlar mejor la impresión awk admite el comando printf de C, este tiene
esta forma:

who |awk '{printf( "%s se conectó  a %s\n",$1,$5)}'

% indica que tiene que sustituir por la variable de tipo s(caracteres), el 
primer %s sustituye $1 y el segundo $5. los tipos de printf son:

%d   	numero entero
%o 	numero octal
%x	numero hexagesimal
%u	entero sin signo
%e	notación científica
%f	decimal con coma flotante
%g	mas corto que %e o %f
%c	carácter único
%s	cadena de caracteres


8.2 OPERADORES
------------------
matemáticos:

a += 5   equivale a = a +5
a -= 5   equivale a = a -5
a *= 5   equivale a = a *5
a /= 5   equivale a = a /5
a %= 5   equivale a = a %5 

booleanos:

||	or
&&	and
!	not

Expresiones regulares:

~ ==	igualdad de cadenas
!~ ~=	desigualdad de cadenas

 
8.3 FUNCIONES INTERNAS
-------------------------


getline()    	lee la siguiente linea de entrada , actualiza NR
	
index(s1,s2)	devuelve la posición de la cadena s2 dentro de la cadena s1, 0 
		si no esta

length()	devuelve la longitud de una cadena, si no se pone nada pos todos
		los caracteres

split(string,array,sep)	divide la cadena string en campos cuyo separador es sep
			y los guarda en array[1],array[2], ...

printf()	pos eso

substr(cadena,pos,n)	saca una subcadena de n caracteres a partir de la 
			posición pos		

cos,exp,int,log,sin	pos hace coseno, exponencial, parte entera, logaritmo
			seno.


8.4 BEGIN END
-------------------------
  
Aunque  lo parezca no sirve para empezar o terminar los programas en awk sino
para realizar acciones antes ó después de comprobar los registros.
por ejemplo:

ps aux |awk '$1 == "root" END {print NR}'  pos imprimiría el numero de procesos
						que tiene el root
esto es muy útil para imprimir cabeceras y pies , la estructura de las tuberías
lo impediría


8.5 CONDICIONAL IF
------------------------

 Este condicional no tiene nada que ver con el del shell, su estructura es :

if (condicion)
	{acción}
   else
	{acción}

en la condición no se pone el comando text [] como en shell ni hay que poner 
then, normalmente se ponen en BEGIN o END , si solo se pone un comando en acción
se puede omitir{} pero si hay más hay que ponerlo.

8.6 BUCLE  FOR y WHILE
----------------------

EL bucle for también es muy diferente, hay que inicializar una variable como 
contador,decirle cuando para y el incremento:

for (inicontador;probarcontador;incremento)
	{acción}

El bucle while tiene la estructura:
 
while (condición)
	{acción}




9º  SEÑALES y COMUNICACIÓN ENTRE PROCESOS
--------------------------------------------

En shell podemos llamar a otros programas dentro de el, entonces habrá que 
poder mandarle variables y saber el resultado de las operaciones 

9.1 EXPORT
-----------------

Como su nombre indica pasa unas variables a un sub-shell, estas no pueden durar 
mas que el propio sub-sell y se pueden eliminar con el comando unset. Estas 
variables estarán en el entorno del sub-shell por lo que el shell padre 
permanece inalterado. la sintaxis es :

export var var ;sub-shell


9.2 SEÑALES
------------------

Son las señales que se pueden mandar a un proceso, la mayoría son de error se
manejan con el comando kill o trap , las señales son:

nº	nombre	generado por					acción

0	EXIT	sale de shell					salir
1	HUP	cuelgue						salir
2	INT	interrupción					salir
3	QUIT	abandonar					memoria
4	ILL	instrucción ilegal				memoria
5	TRAP	trace trap					memoria
6	IOT	abortar						memoria
7	EMT	emulación de atrapado				memoria
8	FPE	excepción de coma flotante			memoria
9	KILL	mata el proceso incondicionalmente		salir
10	BUS	error de bus					memoria
11	SEGV	el famoso segment fault				memoria
12	SYS	mal argumento para una llamada al sistema 	memoria
13	PIPE	escribe una tubería sin proceso que lo lea	salir
14	ALRM	alarma de tiempo de salida			salir
15	TERM	terminación de proceso ( kill )			salir	
16	USR1	definida por usuario(1)				salir
17	USR2	definida por usuario(2)				salir
18	CHLD	muerte del proceso hijo				ignorar
19	PWR	reconexión de caída de tensión			ignorar
20	WINCH	cambio de tamaño de la ventana			ignorar
21	URG	condición enlace urgente			ignorar
22	IO	posible enlace I/O				ignorar
23	STOP	parada incondicional				parar
24	STP	usuario parado					parar
25	CONT	continuar					ignorar
26	TTIN	para la entrada tty				para
27	TTOU	para la salida  tty				para
28	ALRM	temporizador virtual excedido			salir
29	PROF	temporizador de entorno excedido		salir
30	XCPU	tiempo limite de CPU excedido			memoria
31	XFSZ	tamaño limite del fichero excedido		memoria


9.3 TRAP
-----------------

Con este comando el programa shell puede capturar las señales que reciba para
tomar otras acciones que no sean las asociadas a esas señales(la tabla anterior)
esto es muy útil si hay que borrar archivos temporales antes de parar la 
ejecución de un programa .

trap "comando1;comando2;..." señal 	pues ejecuta los comandos al recibirla la
					señal

trap 					interrumpe el comando actual

trap ' ' señal				ignora la señal

trap señal				restablece el valor por defecto

evidentemente la señal 9 no se puede capturar (por si alguno pensaba en hacer 
un programa que no pudiera colgar el root) .
si se quiere meter una variable en los comandos hay que poner comillas simples
para que se interprete bien


9.4  GETOPTS
------------------

Si ya nuestro programa va a ser la leche y queremos que se metan opciones sin
tenerlas que tomar como parámetros posicionales ( como ls -la) se usa este 
comando:


while getopts opns nombre
do
	case $nombre in
		opn1)
			comandos;;
		opn2)
			comandos;;
		.
		.
		opnn)	comandos;;
		
		*) echo $USAGE
		exit 2;;
	esac
sone
shift 'expr $OPTIND -1'


opns son las opciones válidas para el comando(si necesita algún argumento se 
	sigue de : este argumento se guarda en la variable OPTARG 

OPTIND se asigna el numero de argumentos


si mete un argumento no válido le muestra la variable USAGE
nombre es la variable donde se mete las opciones metidas
mejor será poner un ejemplillo para visualizarlo:

----------------------------------------------------------------------------
USAGE='pos los parámetros son [-s] -r nombre]'
while getopts s r:  parámetros
do
	case $parámetros in
		s) adjetivo="capullo";;
		r) nombre=$OPTARG;;
		*)echo $USAGE;
		exit 3;;
	 esac
done
shift 'expr $OPTIND -1'

echo "$nombre eres un $adjetivo"
exit 0
----------------------------------------------------------------------------


9.5   WAIT
------------

Este comando es muy útil al ejecutar un shell hijo en modo background ya que 
espera a que termine la ejecución de este para seguir

comando
wait


9.6  EXEC
------------
 
Este comando modifica los descriptores de ficheros, estos son números a los que
se asocia la entrada y salida de los programas, en el apartado 6 vimos como 
modificar la entrada estándar (descriptor 0), la salida estándar (descriptor 1)
y la salida estándar de errores (descriptor 2). Del 3 al 20 se pueden definir
con el comando exec. 
El enlace de redireccionamiento con estos se hace con & , 

comando 2>&7 comando    

si se pone <&- y >&- cierran la entrada y salida estandar

Con el comando exec definimos a que archivo o dispositivo se manda la salida o
entrada cuando se hace referencia a ese descriptor, (si es un archivo tiene que
existir antes) por ejemplo:

exec 3> /dev/lp0 
echo "hola" >&3	

enviaría a impresión "hola" 




10º FUNCIONES
------------------------------------

En shell también podemos definir funciones dentro de nuestros programas de la
forma:

nombre () {comando; comando2 ...}

los paréntesis indican que se define una función

incluso si las incluyes en .profile te sirven para todos los programas que hagas
(pelin inseguro pero allá cada cual)
también se pueden pasar argumentos ( o parámetros si los has definido dentro de 
la función ) a modo de parámetros posicionales

para terminar  la función se suele usar el comando

return n 	(n es el código de retorno)

ya que exit mataría también el shell


Pos esto es todo,  espero que os sirva de algo, adjunto algun programilla (con 
poca utilidad) pa que lo repaseis, y lo mejoreis.  . 

* Esto no es un medicamento ( aunque se puede administrar de muchas maneras)  

* No me hago responsable de los efectos perniciosos así como las diarreas 
mentales que  pueda ocasionar la lectura y puesta en practica de este documento 

* Si tienen alguna duda consulten a un buen psiquiatra(¡yo me explico de PM!!) 
 


<++> DP3/CURSOS/SHELL/ejemplo1.sh

#!sh
#pues este programita lee de un arhivo passwd y shadow los usuarios con claves
#y los mete en otro archivo "claves" 
#no sirve de mucho si no se tiene permiso de lectura en los dos 
#by Kurtz


if [ \( x$1 = x \) -o \( x$2 = x \) ] ;then
echo " introduce el archivo passwd y shadow" ;
exit;
else
if [ ! \( -r $1   -o  -r $2 \)   ] ; then
echo " introduce el archivo passwd y shadow con permisos de lectura" ;
exit
fi
fi
lineas=`wc -l $1| cut -d" " -f6`;

i=1;   
while [ $i -le $lineas ]
do

user=`sed -n ${i}p $1 |cut -d: -f1`;
a=`grep $user $2 |cut -d: -f2 ` ;
if [ ! $a = "x" ];then
b=`sed -n ${i}p $1 |cut -d: -f3-7` ; 
a="${user}:${a}:${b}" ;
echo "$a " >>claves
fi
i=`expr $i + 1`;

done                                                                            

<-->








