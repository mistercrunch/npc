================================================================================
---------------------[ BFi14-dev - file 04 - 11/07/2007 ]-----------------------
================================================================================


-[ DiSCLAiMER ]-----------------------------------------------------------------
        Tutto il materiale contenuto in BFi ha fini esclusivamente informativi
        ed educativi. Gli autori di BFi non si riterranno in alcun modo
        responsabili per danni perpetrati a cose o persone causati dall'uso
        di codice, programmi, informazioni, tecniche contenuti all'interno
        della rivista.
        BFi e' libero e autonomo mezzo di espressione; come noi autori siamo
        liberi di scrivere BFi, tu sei libero di continuare a leggere oppure
        di fermarti qui. Pertanto, se ti ritieni offeso dai temi trattati
        e/o dal modo in cui lo sono, * interrompi immediatamente la lettura
        e cancella questi file dal tuo computer * . Proseguendo tu, lettore,
        ti assumi ogni genere di responsabilita` per l'uso che farai delle
        informazioni contenute in BFi.
        Si vieta il posting di BFi in newsgroup e la diffusione di *parti*
        della rivista: distribuite BFi nella sua forma integrale ed originale.
--------------------------------------------------------------------------------


-[ PHREAKiNG ]------------------------------------------------------------------
---[ PR0GETT0 MAGNET0 / DYNAMAGNET0 ]-------------------------------------------
-----[ EPTO (A) <epto@usa.com> ]------------------------------------------------


--------------------------------------------------------------------------------
                  :..::-= PROGETTO MAGNETO / DYNAMAGNETO =-::..:
                 ::....:: UN PROGETTO DI  PHREAK ESTREMO ::....::
                  :.............:: By EPTO (A) ::..............:
--------------------------------------------------------------------------------
        Indice:
        
        [1]     Introduzione: che cos'e' il Progetto Magneto.
        [2]     Stato attuale del progetto Magneto e del progetto DynaMagneto.
        [3]     Schede telefoniche: funzionamento, stuttura dei dati, codifica.
        [4]     La lettura passo-passo (dalla scheda al dump dei dati).
        [5]     Ipotesi varie ed eventuali sulle codifiche.
        [6]     Scelta del compilatore, linguaggio visuale, interfaccia grafica
        [7]     Algoritmi di Magneto, funzionamento ed implementazione.
        [8]     Dati tecnici su Magneto e lettori fatti in casa, per cominciare
                a leggere e scrivere le schede.
        [9]     HDSS: Hardware Digito Smanettament System
        [10]    DynaMagneto
        [11]    Progetti collaterali, work in progress...

  Sito del progetto: http://magneto.r8.org
                     http://magneto.eptousa.altervista.org

  Sito dei tramaci di Epto:
                     http://tramaci.r8.org
                     http://eptousa.altervista.org

                     EPTO (A)  epto@usa.com

--------------------------------------------------------------------------------
[1]  INTRODUZIONE: CHE COS'E' IL PROGETTO MAGNETO / DYNAMAGNETO

        Il progetto Magneto consiste nel riuscire a leggere e scrivere le schede
        telefoniche SIP/Telecom e studiarne la codifica.

        Fin dai tempi dei primi "magnetisti" che studiavano le schede, si sapeva
        attraverso un lentino magnetico a grandi linee dove erano scritti i dati
        della scheda.

        Si possono trovare anche una serie di datasheet a riguardo, indicano
        la posizione delle varie trame, ma le informazioni riguardano le schede
        del 2^o tipo (vedi seguito per la distinzione) e suggeriscono solo che
        le "barrette vericali" che stanno alla fine della scheda sono il credito
        e a grandi linee la posizione degli altri dati.
        
        Vedi immagine allegata: Magneto/image/ANABAND.gif

        La codifica delle schede telefoniche ed anche la modulazione sono un
        brevetto della Urmet e non sono stati diffusi dati tecnici. 

        Lo studio sulle schede nasce da quando ho trovato per caso un "lettore
        sospetto" per terra a 100 metri da una cabina telefonica Digito.
        All'inizio non avevo intuito cosa fosse, ma poi ho riconosciuto
        l'apposita feritoia dove si inseriscono le schede!

        Ho eliminato la scheda di controllo che c'e' sul lettore della Digito
        (Lettore Urmet/IPM) ed ho creato un'interfaccia compatibile con il PC.
        
        L'unica cosa che potevo fare era interfacciarmi direttamente alle parti
        meccaniche del lettore non avendo subito capito il funzionamento
        completo del lettore.

        Collegando opportunamente le testine magnetiche del lettore alla scheda
        audio, dopo la prima lettura ho ottenuto il wave della banda magnetica
        (vedi immagini allegate: Magneto/image/WAVE.gif e 
        Magneto/image/Banda.html).

        Dopo vari studi sui wave di piu' schede telefoniche ho fatto il
        programma Magneto che consente di leggere e scrivere schede basate sul
        sistema Urmet (non necessariamente telefoniche).
        Puo' leggere e scrivere le schede telefoniche Urmet/Telecom/SIP.

        La modulazione:
        Si tratta di un sistema pseudo-ternario che viene intervallato da degli
        spazi costituiti da interruzioni del segnale.
        La modulazione pseudo ternaria si evidenzia dal fatto che non esistono
        sequenze arbitrarie di + 0 - ma che le sequenze di poli diversi da
        zero sono sempre alternative: 

        Dopo un + c'e' sempre un -
        Dopo un - c'e' sempre un +

        Non e' un sistema F/2F perche' esistono sequenze di spazi doppie ed il
        segnale si interrompe in piu' punti.


        Dopo l'evoluzione di Magneto per la lettura e la scrittura delle
        schede si e' pensato alla realizzazione del progetto DynaMagneto:
      
        DynaMagneto e' un programma simile a Magneto, ma riscritto da capo, che
        serve per leggere e scrivere qualunque tipo di scheda a banda magnetica
        con qualsiasi tipo di codifica e di struttura, anche inventata. In
        pratica e' un editor di schede magnetiche molto potente che permette di
        editare non solo le schede magnetiche, ma anche le loro codifiche,
        magari puo' essere usato per sperimentare nuovi sistemi di
        memorizzazione dati su banda magnetica.
        DynaMagneto non e' altro che l'abbreviazione di Dynamic Magneto ovvero
        l'estensione del progetto Magneto a tutte le schede di ogni tipo.
        
--------------------------------------------------------------------------------
[2]  STATO ATTUALE DEL PROGETTO MAGNETO / DYNAMAGNETO

        Il progetto Magneto continua sempre, siamo riusciti a leggere le schede
        telefoniche ed anche a scriverle.
        La codifica resta confermata, siamo riusciti a tracciare l'automa a
        stati finiti (vedi seguito) per verificare la validita' delle schede.
        
        Oggi siamo arrivati alla versione Open Extra di Magneto che non e' piu'
        legata al funzionamento del vecchio driver TVIcLpt, ma funziona con
        NinOut32 sfruttando gia' una versione ridotta dell'lptclass di
        DynaMagneto (vedi seguito).

        Essendo Magneto nelle prime versioni un programma sperimentale e'
        stato usato il driver TVIcLpt che e' un driver per l'accesso alla
        porta LPT sulla quale va collegato il lettore.
        Dalle versioni piu' recenti e' stato impiegato il driver NINOUT32 per
        l'accesso alle risorse I/O dirette.
        Da questo e' stata creata la LptClass che implementa le stesse
        funzionalita' di TVIcLpt, ma non e' piu' legata al driver precedente.
        La LptClass e' una libreria che utilizza le porte LPT con I/O diretto
        ed e' una valida interfaccia software per la porta parallela LPT.

        Gli algoritmi di lettura sono diventati "piu' resistenti" e Magneto
        puo' lavorare anche in condizioni piu' estreme per leggere le schede
        piu' vecchie che avevano rimbalzi dell'onda wave piu' marcati od erano
        piu' smagnetizzate o con un segnale piu' debole.

        Ora stiamo lavorando alla codifica dei byte per estrarre le
        informazioni come taglio della scheda, data di scandenza, numero di 
        serie, etc...

        Stiamo sperimentando e testando tutti gli algoritmi di DynaMangeto.
        Il programma funziona dinamicamente su piu' livelli.
        Inizialmente non sara' impostabile tutto per mezzo della grafica, ma
        si useranno file XML (codec/rml) per impostare i parametri della
        codifica.

        DynaMagneto funziona cosi':
        Dall'inserimento della scheda si arriva ad una form dinamica che
        visualizza i parametri memorizzati sulla scheda in modo chiaro e
        semplice.

        Siamo riusciti a leggere molto bene queste codifiche:
        Ternario, Pseudo-ternario, F/2F, FSK, ASK, Fn/F (dove n e' variabile),
        Manchester, MFM, MLT-3 e molte molte altre...
        Eccetto Fn/F sono tutte codifiche standard.
        Fn/F e' una codifca implementata come tutorial di una codifica
        inventata per testare DynaMagneto.

        Legge gia' trame di tessere sanitarie, carte di credito, schede
        telefoniche, etc...

        Si possono eseguire moltissime operazioni sui bit ed i byte,
        addirittura sulle onde in caso di modulazioni "X" definite dall'utente.

        Supporta piu' tracce, si possono definire le singole posizioni e
        dimensioni per ogni banda, si possono definire le codifiche e le
        modulazioni per ogni singolo token in una banda.

        Sto anche lavorando ad un sistema intelligente di riconoscimento delle
        schede composite (fatte a piu' codifiche miste).

        Se riesce del tutto e' un bel programmaccio!
        Siccome il programma fa uso intensivo di grafici ho riscritto la GUI
        prendendola da un mio vecchio progetto per evitare di usare la gestione
        grafica di Windows che nei vari 98, XP, NT, 2000 o altri cambia sempre
        ed e' brutta.

        Allo stato attuale e' disponibile la versione OpenExtra di Magneto
        (vedi archivio allegato: Magneto/stm4src.zip e http://magneto.r8.org
        per nuove versioni) per DynaMagneto il coding e' ancora in corso (per
        una preview vedi immagine Magneto/image/DYNA.jpg)...

--------------------------------------------------------------------------------
[3]  SCHEDE TELEFONICHE: FUNZIONAMENTO STRUTTURA CODIFICA (FULL IMMERSION)

        Spieghero' qui di seguito il funzionamento delle schede telefoniche
        descrivendo un livello alla volta.
        
        Partendo dal wave:

        Si nota un picco all'inizio.
        Questo e' il cancelletto di apertura (l'inizio della banda magnetica).

        A seguito c'e' uno spazio molto lungo (questo viene riconosciuto come 
        spazio).

        A seguito c'e' una prima trama di dati/onde.
        
        Poi uno spazio.

        Poi un'oscillazione +- (separatore).

        Poi uno spazio.

        Una seconda trama di dati/onde.

        Poi uno spazio.

        Una terza trama di onde ripetitive (credito).

        Poi uno spazio.

        Un picco.
        Questo e' il cancelletto di chiusura (la fine della banda magnetica).

        In alcuni casi dopo il picco separatore +- puo' esserci una trama di
        onde/dati in piu' (la trama aggiunta).

        Ora vediamo nel dettaglio come funzionano queste onde:

        Sul nastro sono possibili solo 3 stadi: 
        Positivo (+) Zero/Neutro (0) Negativo (-)
        La modulazione e' pseudo ternaria e funziona cosi':
        Un picco (oppure un quanto di tempo pari alla lunghezza del picco)
        corrisponde ad un impulso di clock (manda avanti di 1 bit).
        Quando c'e' un picco + o - viene considerato come un bit 0, tieni in
        considerazione la lunghezza del picco (non di una oscillazione).

        Quando c'e' uno spazio (grande quanto un picco) viene considerato un
        bit 1.

        Ovvio che in un'onda c'e' sempre un'oscillazione e che dopo un + ci
        puo' essere solo un - e dopo un - ci puo' essere solo un +.

        Questo vuol dire che non capitera' mai: ++ -- +0+ -0-
        Tuttavia ci possono essere dei rimbalzi: +r0- -r0+ 
        (vedi immagine allegata: Magneto/image/Rimbalzi.gif)
        Si e' notato che le onde mano a mano che sono ripetitive sono sempre
        piu' forti (come se ci fosse inerzia) poi quando si arriva ad uno
        spazio talvolta la transizione e' lenta o ci sono proprio dei rimbalzi.

        Questa inerzia e' dovuta evidentemente a motivazioni elettroniche degli
        amplificatori oppure all'isteresi magnetica delle bobine della testina
        ed anche alla risposta dovuta al fatto che le bobine possono caricarsi
        e dar luogo ad un piccolo riflusso di correnti parassite.
        
        Per fare un esempio basta immaginare una retta orizzontale (e' l'asse
        X di un piano cartesiano che rappresenta il tempo).
        L'asse Y rappresenta la posizione di un punto attaccato con un elastico
        all' asse X.
        Se sposto il punto, questo torna verso l'asse X a 0 appena lo lascio.
        Se gli do un bel calcio questo torna anche oltre l'asse X, ritornando
        verso X=0, supera lo 0 e rimbalza nel quandrante negativo per poi
        tornare a 0.

        Si e' visto anche che al massimo gli spazi vuoti (i neutri, gli 0)
        possono essere non piu' di 2 di seguito.

        Per esempio si puo' fare:
        +- -+ +0- -0+ +00- -00+
        
        Capiamo al volo che il sistema pseudo-ternario prevede:
        + = 0
        - = 0
        0 = 1

        Questo ti fa capire che si decodifica cosi':

        +0-+-00+-+-00+-+-00+- = (Sostituzione)
        010001100001100001100

        A questo punto si deve tener conto che per il principio di oscillazione
        le trame di onde iniziano con una polarita' e finiscono con un'altra
        (come si vede nell'esempio di cui sopra +-+-+-+-+-)

        Le trame iniziano sempre con un +, finiscono con un - che NON SONO
        INCLUSI NEI DATI. E' come un'apertura e chiusura della trama.

        La struttura di una trama di onde/dati e':

        +<dati>-

        Vista la corrispondenza binaria ora possiamo passare al livello
        sucessivo.

        Riprendendo la nostra sequenza:
        +0-+-00+-+-00+-+-00+0-
        Leviamo i picchi iniziali e finali:
         0-+-00+-+-00+-+-00+0

        Decodifichiamo i bit:
        0-+-00+-+-00+-+-00+0
        10001100001100001101

        Visto il numero divisibile dei bit in tutte le letture e il
        comportamento dei dati in tutti i casi, dopo prove e prove si e'
        scoperto che i dati sono dei nibble.

        I nibble sono sequenze a 4 bit, in questo caso MSB senza parita' che
        d'ora in poi chiameremo impropriamente byte da 4 bit.

        1000 1100 0011 0000 1101.. etc...
        1    3    C    0    etc...
        N.B: I byte sono descritti in esadecimale.

        L'ultimo byte e' il test con il sistema LRC ovvero la parita' di tutti i
        bit eseguita per mezzo di uno XOR di tutti i byte della stringa.
        Se e' corretto deve risultare "0".
        In alcuni casi risulta "3" oppure "C" (in schede del 2^o tipo).

        C'e' una limitazione dovuta al fatto che non possono esserci piu' di
        due spazi (0) di seguito e di conseguenza non ci possono essere piu' di
        due 1 di seguito.

        Questo taglia fuori i seguenti byte:
        7 = 1110
        E = 0111
        F = 1111
        
        Analizzando le stringhe di bit, si e' notata un'altra caratteristica
        costante ed anche ovvia:

        Prova a scrivere 13C3 ? 
        1    3    C    * 3  
        1000 1100 0011 * 1100

        * = Ci sono addirittura 4 uno di seguito e non e' lecito che ce ne
            siano piu' di 2.
        La soluzione e' mettere in mezzo un byte 0, cosi' il problema non c'e'
        piu'!
        1    3    C    0    3   
        1000 1100 0011 0000 1100        

        Ora sappiamo che i byte che non vengono usati sono i seguenti (tra
        parentesi elenco anche il motivo):

        0 = 0000        (Elimina i troppi 1 tra i byte)
        7 = 1110        (Ha 3 uno di fila)
        B = 1101        (Non c'e' mai anche se si puo' scrivere
                         tranquillamente)
        E = 0111        (Ha 3 uno di fila)
        F = 1111        (Ha 4 uno di fila)

        Rimangono:
        123456 89A CD   11 possibili nibble!
        
        Se siamo molto svegli notiamo anche una cosa, grazie al + iniziale
        non c'e' il problema per sequenze che iniziano con 1 che poi sarebbe
        rappresentato come uno spazio e farebbe perdere l'inizio della trama
        durante la lettura.
        Grazie alla forma +<dati>- questo problema non sussiste.

        Ma alla fine potrebbe finire con uno spazio, ma grazie al - finale non
        si perde la fine della trama.

        Come dicevo nella forma +<dati>- i + e - finali non sono inclusi nei
        dati percio' meglio chiarire subito un dettaglio:

        ... 0100 FINE (-)
        dove '...' sta per cio' che c'e' prima.
        Come lo traduco?

        ... -0+- + (non si puo' fare)
        ... -0+- - (non si puo' fare)
        Aggiungere un byte 0 e' uno spreco, allora se c'e' un finale di una
        trama che e' un picco - viene aggiunto un bit 0 (o se preferisci un
        picco +):
        ... -0+- + -
        Cosi' la trama viene chiusa correttamente.
        
        Allora riassumiamo:

        Viene usato il sistema pseudo ternario: 0=1 +=0 -=0
        L'oscillazione e' continua: -+-+-+-+-+-+-+-+
        Ci sono i rimbalzi da togliere.
        Ci sono piu' elementi separati da spazi.
        La forma e': Picco Trama Separatore Trama Trama/Credito Picco
        I byte sono a 4 bit MSB senza parita'.
        C'e' LRC alla fine (chiamato in Magneto LRU).
        C'e' un controllo sui picchi delle onde.
        Non ci son i byte: 0 7 B E F
        Il byte B non appare mai (non e' usato).
        Il byte 0 spezza le sequenze di 1 consecutivi tra i byte.
        I dati sono contentuti tra picchi + e - ( +<dati>- )
        Viene aggiunto un picco + se la trama finisce con -

        Questo sistema controlla i picchi e verifica una parita'/disparita' sui
        picchi a livello ternario per controllare se ci sono errori.
        Il sistema pseudo-ternario e' resistente a cambi di velocita' (salvo
        quelli umanamente impossibili).
        C'e' un LRU che verifica i dati della trama.
        
        Capito questo possiamo passare al livello sucessivo, le trame:

        Per facilitare la scrittura di un'intera scheda telefonica mi sono
        inventato il formato MTEX: M come Mangeto, TEX come TEXT.
        Funziona cosi', associo ad ogni cosa un simbolo piu' congeniale:

        { = Cancelletto di apertura
        } = Cancelletto di chiusura
        | = Picco di separazione
        012345689ABCD = Dati
        ° = Bit 0 (alla fine)
        ' = Bit 1 (alla fine)
        () = Tra questa parentesi metto il credito in numero
             evitando di scrivere tutti i 33333333 (per il motivo vedi oltre):
             Se e' 3.50 euro metto (3.50E).
             Se sono 35 unita' metto (35).
             Se sono 6000£ metto (6000£) se sono 3.50 Euro ed un bit zero metto
             (3.50E°).
             Se voglio essere cosi' malato da mettere tutti i 3 (vedi seguito)
             scrivo con queste parentesi: [3333333]
             Nel caso dell'euro tra parentesi () posso anche mettere il
             simbolino dell'euro.

        Lo spazio corrisponde allo spazio, uno spazio extra come il doppio
        spazio (magari serve a qualcosa) e' il carattere _

        In pratica:
        {<1^a Trama> | <Trama aggiunta> <2^a Trama> [<Credito>] }

        Detto questo scrivo qui il contenuto completo di una scheda telefonica
        della SIP da 10.000£ scarica (la famosa "Compagna di tutti i giorni"
        meglio conosciuta come "portafoglio").

        {13C03C0942946816CC8432966664296433A19643 |333 A194332DCCC8642D84 [3']}

        Si vede subito che c'e' una trama in piu' e che c'e' solo un 3' alla
        fine.

        Non ho scelto la scheda a caso, ora spiego tutto:

        Ho diviso le schede in 3 tipi:
        1^ Tipo: { <trama> | <trama> <credito> }
                Scheda tel. Normale (Recente)

        2^ Tipo: { <trama> | 333 <trama> <credito> }
                Scheda Tel. Normale (vecchia e Recente)

        3^ Tipo: { <trama> | <trama> <trama> <credito> }
                Scheda Tel. Speciale (Concorsi o tariffe speciali)

        Questa e' la prima trama:
        13C03C0942946816CC8432966664296433A19643

        Questa e' la trama aggiunta (non c'e' sempre):
        333

        Questa e' la seconda trama:
        A194332DCCC8642D84

        Questo e' il credito:
        [3']

        Capito questo, passiamo al livello sucessivo:
        
        Secondo i "magnetisti" il credito veniva memorizzato in una serie di
        barrette verticali.
        Basta immaginare che loro vedevano la scheda dall'alto, noi la vediamo
        di taglio:
        Le barrette verticali sono delle sequenze fatte cosi':

        + -+00 -+00 -+00 -+00 -+00 -+00 -       Onda ternaria
          1100 1100 1100 1100 1100 1100         Bit
          3    3    3    3    3    3            Byte
          |    |    |    |    |    |            Barrette verticali ovvero
                                                unita' di credito da 200£
                                                o 10 eurocent (esclusa una)

        Gli spazi che ho scritto qui servono solo per dividere i byte!

        Ogni singolo 3, o barretta se preferite, corrisponde ad un'unita' di
        credito del valore di 200£ o di 10 centesimi di euro, escluso un 3
        o barretta.
        Questo 3 in piu' distingue il credito dal separatore.
        Questa trama non ha LRU!
        Una scheda scarica ha solo un 3 che diventa:
          1100
        + 00-+ -

        Sulle schede vecchie quando erano scariche aggiungevano anche un bit
        1 alla fine:

          1100 1
        + 00-+ 0 -

        Ora vediamo come funziona la prima trama:

        13C03C0 9 4 29 46816CC8432966664296433 A19643

        13C03C0 e' il magic number che e' una sequenza sempre identica per
                riconoscere le schede telefoniche.
        
        9       e' il codice di applicazione 9 = Scheda 2 = Test card
                        
                        (A riconferma della tesi che il byte "0" spezza le
                        sequenze di 1 tra i byte: sulle schede normali la
                        1^a trama inizia con 13C03C09 = 13C3C9
                        Sulla scheda test il 9 e' sostituito con il 2 percio'
                        si ha 13C03C2 = 13C3C2)
                        
        4       Tipo di scheda
        
        29      Resta invariato in schede dello stesso tipo
        
        46816CC Codici che seguono un'automa a stati finiti (vedi seguito)
        8432966
        6642964
        33

        A19643  Resta invariato in schede dello stesso tipo

        Ora la seconda trama:
        A194332DCCC8642D84

        Solo nelle schede vecchie o del 2^o tipo ci sono molti CCC di seguito.

        Ora un confronto con schede del 1^o e del 2^o tipo a distanza di 10
        anni:

        (Gli spazi allineano le 2 schede, ma in realta' non ci sono.
        I veri spazi sono rappresentati con "_" )

        Anno      Trame                         Valuta Tipo
        1993/1994  _ 333 _ A19433 2DCCC8 642D84 (Lire) 2^o Tipo
        2003/2004 294333294329433 329666 642D84 (Euro) 1^o Tipo 

        Nel 1993/1994 non esisteva ancora la rete intelligente che in teoria
        avrebbe tutti i codici di tutte le schede e verificherebbe il credito
        da remoto.
        L'unica differenza palese sta nelle sequenze:
        2DCCC8
        329666
        Con 11 simboli (in base 11) e 6 cifre si possono memorizzare solo
        1.771.561 schede (un numero un po' corto per confrontarlo con quello
        che si trova scritto visibile sulla scheda telefonica).
        Tutte le schede vecchie avevano sequenze anche piu' lunghe di 2DCCC8.

        Ora la trama aggiunta:
        Su schede del 2^o Tipo e' sempre 333
        Su schede speciali per esempio contiene:
        A19643A9
        Cio' comporta meno codici per la trama sucessiva.

        Questa trama e'ancora in fase di studio.

        Capito questo possiamo passare al livello sucessivo:
        
        Tutte le trame seguono (sono valide) rispetto ad un'automa a stati
        finiti, la cosa assurda e' che non potendo usare tutti i byte siano
        riusciti con un automa a stati finiti a fare sequenze che hanno 
        LRU=0 e che non violino il codice proprio avendo magari
        un LRU su 7, B, E, F.

        Ma che cos'e' l'automa a stati finiti delle schede?
        
        Supponiamo che ogni numero sia un incrocio da cui dovrebbero (visto il
        sistema) partire 11 collegamenti ad altri 11 numeri e dovrebbero
        arrivare 11 collegamenti a tutti i numeri (questo se l'automa
        non ci fosse).

        Per esempio se esistessero solo i simboli ABC sarebbe cosi':

        A -> A  B -> A  C -> A
        A -> B  B -> B  C -> B
        A -> C  B -> C  C -> C

        Se sono su "A" posso andare a scelta tra A, B, C.
        E questo anche per altre lettere.
        In questo caso posso scrivere tutte le sequenze non banali (non vuote)
        di A, B, C.

        Ma se fosse:

        A -> A  B -> C  C -> A
        A -> B          C -> B

        Non potrei scrivere tutte le sequenze possibili, potrei scrivere
        per esempio:
        AABCABCBC

        Perche' i soli cammini consentiti sono quelli.
        Non potrei scrivere:

        ACBACC

        Perche' A non va a C
        Perche' B non va a A
        Perche' C non va a C

        Un sistema del genere e' stato usato per le schede telefoniche con
        tutti i simboli esadecimali.
        Lo riporto qui mettendo anche il punto "." che significa fine della 
        trama.

        I cammini sono scritti in questo modo:
        Per esempio:
        1 => 357

        Vuol dire 1 va su 3 oppure su 5 oppure su 7
        N.B.:
        Ho messo anche lo Zero.

        0 => 369A
        1 => 2369D
        2 => 23459D
        3 => 23AC.
        4 => 02346A.
        5 => 4
        6 => 3468C
        8 => 0146
        9 => 1468.
        A => 1489C
        C => 028C
        D => 8C

        Tra l'altro le cifre 3 6 C sono sempre ripetitive.
        
        Come si puo' vedere nessun numero ha 22 accessi (11 in ingresso e 11 in
        uscita) percio' c'e' l'automa.

        Poi c'e'anche una sintassi:
        ci sono delle stringhe che sono ripetitive e comunque i cammini
        degli automi a stati finiti hanno dei passaggi e dei percorsi che si
        susseguono in una certa logica.
        La prima trama e' ancora in fase di studio, vi riporto alcune sintassi
        (cioe' quelle della seconda trama e della trama aggiunta):

        Queste sono le piu' ricorrenti:

        333
        294333294
        296+
        3+29[4]
        A19[6]4[3]A9+1
        8[6]4[3+][2]
        [2]D[C+]84[A19].
        1D[C+]8[6]4[3+][A91]

        Dove [] sta per facoltativo, '+' sta per stringhe non banali
        (ad esempio 3+ stringhe non banali di 3 ovvero 3, 33, 33333, etc..).
        Una tipica stringa puo' essere:
        294333294A19643A99912DCCC84A19
        Ho inventato una trama un po' lunga!

        Riassumendo:
        Vengono verificate le onde.
        Vengono verificate le polarita'.
        Vengono verificate le trame con LRU.
        Vengono verificate le trame con i codici e l'automa.
        
        Il credito e' contenuto nella parte finale della scheda.
        
        Le schede con concorsi o tariffe particolari (3^o Tipo) hanno la trama
        aggiunta con diversi codici, che sia un numero di serie oppure un
        identificativo dell'applicazione tariffa o concorso???

        In alcune schede non c'e'.
        In altre e' solo 333.

        333 in base 11 e' 2906 secondo l'alfabeto 12345689ACD ?

        Lascio l'interrogativo con alcune schede:
        
        Compagna di tutti i giorni
  {13C03C0942946816CC8432966664296433A19643 | 333 A194332DCCC8642D84 [3']}

        Stop AIDS
  {1124024804020440846491923A991923ACC8° | A19643A9 296642D84 [3]}
        (La prima trama non e' corretta perche' la scheda e' rovinata)

        Dilungatevi pure
  {13C03C09129123C0942542542942D843A84A44|294333294329433329666642D84 (3E)}
        
        Urmet Test Card (Prototipo) RARISSIMA
  {13C03C2246840632980AC864296664A9194333 | 333 2DCC8666432DC84A19° [3'']}

        Seconde trame:

        294333294329433329666642D84

           333   A194332DCCC8642D84
           333  2964A991D8643323D84
           333 1D86433A91DCCC842D84   
           333   2DCC8666432DC84A19
           333  329432DCCCCCCC84A19

--------------------------------------------------------------------------------
[4]  LA LETTURA PASSO PASSO (dalla scheda al dump dei dati)

        La lettura di una scheda telefonica o magnetica di qualsiasi tipo con
        Magneto non e' sempre diretta, se la scheda e' nuova ed e' letta
        correttamente dopo averla inserita nel lettore (o dopo aver aperto il
        wave) Magneto visualizza il contenuto corretto.

        Se la scheda e' stata letta male oppure non e' stato possibile
        ritrovare correttamente il livello minimo (o altri parametri) avviene
        una lettura distorta.

        Per capire se una lettura e' corretta (nel campo delle schede
        telefoniche) Magneto ha 3 strumenti di verifica che si trovano sulla
        finestra della scheda:

        Ci sono 3 spie sotto il dump della banda magnetica:
        3 DATI LRU
        Se sono tutte verdi la trama e' corretta, in alcune trame LRU non e' da
        considerare.
        LRU viene considerato in questi casi:

        Schede del 1^o Tipo:

                        Dati    LRU     3
        1^a Trama       Si      Si      Si
        2^a Trama       Si      Si      Si
        Credito         Si      X       Si

        Schede del 2^o Tipo o schede speciali del 3^o Tipo:

                        Dati    LRU     3
        1^a Trama       Si      Si      Si
        Trama aggiunta  Si      X       Si
        2^a Trama       Si      X       Si
        Credito         Si      X       Si

        X = Condizione di indifferenza, ovvero Si' o No non cambia nulla!

        L'altro strumento e' il tasto "rileva" che controlla la scheda in tutte
        le sue parti e riconosce secondo gli studi fatti che tipo di scheda e'.

        L'altro strumento e' l'integrita' del segnale in ampiezza e frequenza:
        Sono quelle due barre a destra che devono avere l'indicatore su verde,
        tra l'altro viene visualizzata la banda magnetica vista dall'alto come
        se ci fosse un lentino magnetico. Se una parte e' rossa e'
        evidentemente letta male.

        Se la lettura non e' corretta basta andare sulla finestra "wave della
        banda" e spostarsi all'inizio della prima trama, per fare questo piu'
        semplicemente puoi andare anche sulla finestra "scheda", selezionare
        la prima trama e cliccare sul tasto a sinistra "trova": il wave verra'
        posizionato sul punto corretto della banda e sara' possibile vedere
        sulla visuale tipo lentino magnetico la trama evidenziata con un
        riquadro giallo.

        Sulla finestra "wave della banda" basta vedere l'onda wave (quella
        verde) e trovare un rimbalzo (un punto +-0- per esempio), cliccare
        col tasto sinistro del mouse dove inizia il rimbalzo, cliccare col
        tasto destro del mouse dove finisce il rimbalzo.

        Si evidenzia una porzione dell'onda (solo il picco sbagliato).
        Sul menu' "Selezione" si clicca su "imposta come" e poi "rimbalzo".
        Questo cambia il valore minimo che e' indicato da 2 rette orizzontali
        rosse.

        Basta cliccare poi su "traduci" e la finestra "scheda" viene
        aggiornata. Se ci sono errori nell'onda andranno rimessi a posto
        manualmente.

        Per provare a fare questo sul sito di Magneto c'e' un file di esempio 
        che si chiama esercita.wav. E' una banda magnetica creata in
        laboratorio (Magneto si lamenta perche' non e' una situazione
        decisamente reale).

        Per altre informazioni a riguardo dalla versione OpenExtra esiste
        la guida completa.

        Stiamo anche preparando dei video per rendere anche piu' facile
        interpretare la guida (Magneto fa tante cose!).

--------------------------------------------------------------------------------
[5]  IPOTESI VARIE ED EVENTUALI SULLE CODIFICHE

        Ci sono stati molti esperimenti e molti test sulla codifica della banda
        magnetica, un'ipotesi tra le tante e' stata avanzata da Alex36987:

        Si presume che la banda magnetica sia codificata in f/2f a mezz'onda
        con l'ausilio dello "0" e poi in mfm.

        Questo tipo di modulazione non e' f/2f perche' ci sono sequenze 0 e 00
        messe non a caso, ma con ordine logico.
        Poi verrebbe smentito dal fatto che se ci sono sequenze nel sistema
        pseudo ternario del tipo:

        xx11 0000 1xxx
        xxx1 0000 11xx
        xx11 0000 11xx

        Viene aggiunto un byte 0 che sono 4 onde -+-+ o +-+-
        Si incasinerebbe poi con i bit 0 aggiunti alla fine se la trama
        finisce con -

        Francamente un f/2f inizia e finisce con la banda, non si interrompe in
        piu' punti.
        La codifca f/2f consiste in un segnale che e' lungo tutta la banda
        magnetica che modula 0 o 1 in base al fatto che un picco sia o meno
        la frequenza di clock oppure il doppio.
        Si implementa anche con picchi della stessa frequenza mettendo
        nell'istante dello zero crossing (quando l'onda passa per zero) uno
        zero (un quanto di tempo con polarita' neutra 0).

        Comunque ecco come funziona l'ipotesi sopracitata:

        La nostra sequenza di esempio:
        +0-+-00+-+-00+-+-00+-
        Si legge un picco alla volta e risulta 0 o 1 se tra i picchi ci sono
        degli 0.

        +0-
        -+
        +-
        -00+    Trascuriamo 00
        +-
        Etc...

        Sulla sequenza di bit ricavata, l'ultimo bit e' la parita' di tutto.
        Poi viene applicata la codifica MFM prendendo i bit a 2 a 2:
        
        00 = 0
        01 = 1
        10 = 1
        11 = Errore

        Fatto questo la trama diventa molto piu' piccola.
        Tra l'altro poi non fa una grinza nemmeno questa codifica.
        Certo non c'e' un LRU, un CHECKSUM o altro che ci faccia intuire se
        questi dati letti sono corretti.

        Fatti vari test si e' visto che finche' sono schede comuni il sistema
        MFM da' validita' quando da' validita il sistema pseudo-ternario.
        In pratica se una scheda risulta corretta per il sistema MFM in F/2F
        (quello dell'ipotesi) risulta corretta anche per il sistema pseudo
        ternario.
        Questo non avviene in tutti i casi:

        Non avviene sempre con le schede del 2^o e 3^o tipo che danno
        LRU = C

        Non e' nemmeno stabilito di che lunghezza siano i byte, sembra
        variabile.
        Tra l'altro ci si accorge che nel sistema pseudo ternario e' possibile
        leggere una scheda valida per il sistema pseudo ternario che pero' 
        non sia valida per il sistema con MFM.
        Il sistema pseudo ternario ha molti controlli per la validita' della
        scheda.

        Un'altra ipotesi e' che la codifica sia F/3F:

        +-   = 0
        +0-  = 1
        +00- = 2

        (valido anche per le polarita' inverse).

        La nostra sequenza:
        +0-+-00+-+-00+-+-00+-

        Verrebbe letta cosi':
        
        +0-     1
        -+      0
        +-      0
        -00+    2
        +-      0
        -+      0
        +-      0
        -00+    2
        +-      0
        -+      0
        +-      0
        -00+    2
        +-      0

        Magari corrisponde direttamente a MFM saltando un passaggio:

        +-   = 00 = 0
        +0-  = 01 = 1
        +00- = 10 = 1

        Oppure e' una codifica in base 3:
        1002000200020

        Un'ipotesi e' che secondo il sistema pseudo ternario siano sequenze a
        12 bit:

  {13C03C0942946816CC8432966664296433A19643 | 333 A194332DCCC8642D84 [3']}
        
        13C 3C9 429 468 16C C84 329 666 642 964 33A 196 43
        333
        A19 433 2DC CC8 642 D84

        C'e' un sistema che consente di scrivere i byte liberamente e poi
        vengono codificati per usare solo 11 simboli.

        Oppure che ci sia di mezzo un alfabeto in base 11:
        12345689ACD =
        0123456789_
        
        Oppure che ci siano dei caratteri di controllo ed un alfabeto ottale:

        12345689ACD =
        .01234567..
                        Oppure:
        01234567ACD     

        Insomma ci stiamo ancora lavorando....

--------------------------------------------------------------------------------
[6]  SCELTA DEL COMPILATORE, LINGUAGGIO VISUALE, INTERFACCIA GRAFICA.

        Purtroppo Magneto non e' ancora multipiattaforma, come compilatore e'
        stato usato Visual Basic 6.
        Il programma gira sotto varie versioni di Windows:

        Windows 98
        Windows 98Se
        Windows NT
        Windows 2000
        Windows ME
        Windows XP
        
        Inizialmente volevo fare il programma in C++, ma c'e' un piccolo
        particoalre che mi ha fatto cambiare rotta: la mia necessita' era fare
        un programma che operasse ad alto livello con molta grafica (per vedere
        grafici, fare esperimenti in real time, modificare velocemente il
        programma senza essere troppo vicino al linguaggio macchina, avere la
        possibilita' di vedere il contenuto di variabili in memoria, seguire il
        debug passo passo, etc...).

        Per ogni esperimento mi servono grafici che vengano su rapidi.
        Allora ho dovuto usare il sistema Windows e visto che Visual Basic e'
        un compilatore per applicazioni Windows in modalita' visuale, non mi
        sono mosso a lavorare in modalita' testuale e riga di comando.

        Tuttavia l'interfaccia di Windows ti rompe le balle per alcune cose:
        non e' facile in VB6 fare alcuni accorgimenti grafici come per esempio
        le icone come un desktop, ogni sistema operativo le visualizza come 
        vuole, cosi' ho creato il desktop virtuale prendendo un mio vecchio
        programma addirittura scritto in QB45 ed in assembler, lo ho tradotto
        in VB6 rifacendo cosi' le icone ed il desktop.

        Mi serviva anche la possibilita' di usare un linguaggio che programmasse
        in modo lineare, ad oggetti, ad eventi e che non avesse un minimo tipi
        dinamici (penso che Java sia un po' una porcheria per fare Magneto),
        cosi' ho scelto Visual Basic 6 che me lo giro come voglio!

        Addirittura in DynaMagneto ho rifatto proprio la GUI da capo, cosi'
        posso mettere i menu sulle MDIForm, posso mettere le icone come un
        desktop a parte, so come viene visualizzato, posso mettere l'immagine
        di sfondo, posso mettere delle OCX fatte da me piu' belle.
        Posso anche creare form dinamiche, mentre in VB6 e' difficile.

        Sono state aggiunte anche nuove routine di base al linguaggio tramite
        molte classi e dll (come per esempio VBE Visual Basic Extended by
        EPTO).
        Ho aggiunto addirittura la possibilita' di compilare alcuni file per il
        programma all'interno del file EXE stesso.
        Insomma lo ho spinto oltre le sue possibilita', di VB6 classico e'
        rimasto poco.

--------------------------------------------------------------------------------
[7]  ALGORITMI DI MAGNETO: FUNZIONAMENTO ED IMPLEMENTAZIONE

        Il programma e' sviluppato su piu' livelli e ognuno di questi si occupa
        di una parte della traduzione dal wave ai byte e viceversa.

        Ecco (per riferirsi) le principali parti:

        Moduli di Magneto:

        WaveLevel       Questo modulo esegue tutte le funzioni sul wave a basso
                        livello, esegue anche la conversione in wave ternario.

        Wavesolder      Modulo che gestisce il trattamento a livello intermedio
                        del wave.
                        
                Contiene:
                        
                DynaNorm        Normalizzazione dinamica
                GetPiccoMini    Rileva il valore minimo
                GetWaveMatrix   Rileva la matrice wave
                RilevaFondo     Riconosce il rumore di fondo
                RemoveReboun    Elimina i rimblazi

        WaveTern        Questo modulo riconosce il sistema ternario.
                
                Contiene:
                
                AggiustaTernario Corregge gli errori -- ++
                ClockDetect      Rileva il clock dei dati
                FreQScan         Rileva la stabilita' della banda magnetica
                                 trama per trama
                AnalizzaPicco    Analizza ogni singolo picco dell'onda
                MakeObjs         Crea la lista di picchi e di oggetti

                Tipi:
                Obj             E' il tipo di dati per creare la lista di
                                informazioni sul wave.                  

        WaveBinary      Questo modulo esegue la traduzione finale e tratta i
                        byte della scheda.
        
                Contiene:

                TramaCheck      Controlla la correttezza della trama letta
                Stream2Byte     Da insieme di bit a byte
                UrmetDecoder    Dalla stringa ternaria riconosciuta decodifica
                                tutta la scheda in ogni sua parte
                UrmetEncoder    Dalla scheda crea la stringa ternaria per la
                                scrittura               

                Tipi:

                Token           Oggetto della banda magnetica
                Skeda           Oggetto della scheda magnetica

        WaveWrite       Questo modulo si occupa della scrittura.

                Contiene:

                WriteToWav      Crea il wave della banda da scrivere
        
        
        Skedakey                Controlla la scheda secondo gli automi a stati
                                finiti, etc.

        LettoreMod              Gestisce il lettore/scrittore.

        GapModule101            Dalla versione 101 di Magneto c'e' questo modulo
                                che rileva il gap dal picco di separazione.

        BitWise                 Contiene tutte le funzioni per operare sui bit.

        Ci sono altri moduli (il doppio tra finestre e robe varie, questi sono
        quelli piu' importanti).

        Inizieremo da WaveLevel:

        Viene caricato il wave della banda magnetica in un array che contiene
        il PCM.
        Il wave viene normalizzato.
        La prima funzione ad intervenire e' RilevaFondo.
        In seguito con GetPiccoMini si riconosce il picco minimo dal wave
        della banda.
        
        Per rilevare il fondo basta ricampionare la scheda con risoluzione
        bassa, vedere dove sono i valori piu' bassi rispetto alle trame
        (all'inizio ed alla fine, tra gli spazi) calcolare tra questi il
         valore piu' alto e piu' usato.
        
        Per rilevare il valore minimo basta, dopo aver tolto il rumore di
        fondo, dividere il wave (Wpk) in tronconi con un sistema di zero
        crossing, ovvero l'onda viene messa nel troncone corrente finche' non
        passa per lo 0 o cambia direzione.

        Si prendono poi i tronconi e si trova il modulo del valore piu' alto.
        Si mette in un array in modo crescente e con una risoluzione ridotta
        che ci serve per evitare gli intoppi.

        Da questi tronconi si cancellano tutti i picchi sotto al rumore di
        fondo.
        Si fa anche una statistica di quanto riappaiono i valori dei picchi.
        Viene scelto un valore che sia il minimo, ma usato (GetMinSoglia).
        Questo valore, tolto il fondo, e' il valore del picco piu' basso
        appartenente al segnale (salvo somme strane di onde).
        Viene anche controllato se la misura e' coerente con il livello
        minimo rilevato prima.
        
        A questo punto GateSoglia leva i rumori di fondo di mezzo, portandoli
        a 0.
        GateTern trasforma cosi' i valori PCM in 3 Livelli + 0 -.

        MakeObjs attraverso un ciclo con AnalizzaPicco crea una lista di tutti
        i picchi e tutti gli spazi rilevati dal wave (Obj).

        Il nostro wave della banda e' diventato una lista di informazioni che
        si puo' vedere sulla finestra "wave della banda" sottoforma di
        divisioni verticali con le scritte + 0 - R G etc.

        Viene vista a questo punto consultando la lista la frequenza media del
        segnale.

        Viene chiamata ClockDetect che si occupa di trasformare gli spazi in
        divisioni o bit 1, rileva il clock del segnale.

        ClockDetect aggiunge informazioni alla lista OBjs e riconosce i Gap
        delle onde nei passaggi +- -+ per evitare di incappare in errori.
        
        Visualizza anche il rapporto tra l'ultimo picco e lo spazio (scritto in
        blu sul wave) per dare ulteriori informazioni.

        Vengono controllate le trame e/o viene eseguita la normalizzazione
        dinamica DynaNorm.

        Tutte le onde vengono portate a livello alto e corretto.
        A questo punto occorre ripetere i passaggi di sopra perche' il wave
        puo' cambiare: vengono rilevati fondo e valore minimo.

        Il wave viene convertito in Ternario con WaveTrinaryconvert.
        Viene creata la Matrice Wave con GatWaveMatrix.
        Vengono eliminati i rimbalzi con RemoveRebound.

        Si tiene conto del fattore relativo:
        se un'onda si e' mossa molto transitera' lentamente quando passa per 0.

        Viene rianalizzata l'onda ciclicamente piu' volte, finche' tutti i
        picchi sono ai livelli giusti.

        Viene usata ClockDetect per ottenere la lista corretta e viene passata
        a UrmetDecoder che decodifica tutto e crea l'oggetto Skeda.

        Viene controllata la stabilita' della banda magnetica.

        A questo punto se e' tutto corretto il programma finisce l'operazione,
        altrimenti riprova con valori diversi.

        I passaggi sono:
        Wave
        Wave a 3 livelli
        Liste oggetti:

        + f=100 a=20
        0 f=100 a=0
        - f=100 a=20
        etc.

        Ternario:
        -
        +0-+-00+-+-00+-+-00+-+-00+-+-0+-00+-+-0+-0+-00+-+-0+-00+-+-00+-+-...
        +-
        +-0+-0+-0+-0+00-+00-+00-+-0+-0+-0+-0+00-+-0+-0+-0+-0+00-+00-+00-+...
        +00-+00-+00-+00-+00-+00-+00-+00-+00-+00-+00-+00-+00-+00-+00-+00-+...
        +

        Token:
        { <trama> | <trama> <credito> }

        Bit:
        0100100100101100110011000100100100101100010010010010110011001100 ...
        etc...

        Trame:
        13C03C09129123C0942542542942D843A84A44
        294333294329433329666642D84
        3333333333333333333333333333333

        Scheda:
  {13C03C09129123C0942542542942D843A84A44 |294333294329433329666642D84 (3E)}
        
        Analizzando vari wave ed utilizzando i vari algoritmi sono emersi dei
        teoremi sulle onde abbastanza interessanti:

        RUMORE DI FONDO:
        Per trovarlo basta cercare tra i valori piu' bassi escludendo i segnali
        piu' forti, i valori piu' alti.

        E' una cosa elementare da fare:
        si trova al parte di segnale piu' bassa (per zone), poi da questa si
        escludono i segnali piu' forti.
        Il valore piu' alto tra i rimanenti e' il rumore di fondo.

        VALORE MINIMO:
        E' il primo picco piu' usato e piu' basso dopo il rumore di fondo.

        VALORE CORRETTO DI DYNANORM:
        Il valore piu' usato tra i piu' alti (in ampiezza del picco).

        FATTORE RELATIVO:
        Amplificando con DynaNorm, o per effetto della modulazione analogica
        delle schede, un'onda puo' transitare in +0- o -0+ facendo sullo 0 una
        transizione lenta ed ingannevole.
        Questa transizione e' tanto lenta quanto piu' e' alta l'onda e tanto
        piu' e' preceduta da oscillazioni complete.


--------------------------------------------------------------------------------
[8]  DATI TECNICI SU MAGNETO E LETTORI FATTI IN CASA,
     PER COMINCIARE A LEGGERE E SCRIVERE LE SCHEDE.

        Un lettore che possa funzionare correttamente con Magneto puo' essere:

        * Il lettore alternativo di Alex36987 (solo lettura)
          Vedi: http://eptousa.altervista.org/progetti/magneto/inta2/
        * Il lettore Digito modificato.
        * Un lettore fatto in casa.

        Come progettare un lettore/scrittore fatto in casa:

        La prima cosa da fare e' trovare una testina per un registratore
        audio.
        Bisogna sapere che siccome e' di forma diversa occorrera' fare molte
        prove per azzeccare l'azimuth (l'angolo della testina rispetto al
        nastro).

        Una volta costruita l'interfaccia come descritto nel progetto Magneto:

        Vedi: http://eptousa.altervista.org/progetti/magneto/int/

        (un sensore ottico vicino alla testina, un sensore per l'ingresso della
        scheda nel lettore, un sensore sulla ruota dentata del motorino, etc.)
        occorre tener conto appunto della ruota dentata del motore.

        Si consiglia di collegarla meccanicamente attraverso ingranaggi e non
        cinghie.

        Questa ruota deve essere grande ed avere molti fori, puoi anche giocare
        su riduzioni o moltiplicazioni meccaniche.
        Questi fori interrompono il sensore ottico e informano Magneto sulla
        velocita' e sulla posizione della banda magnetica.

        Una cosa che deve essere fatta lentamente e' contare le seguenti misure
        di impulsi (fronte di salita e fronte di discesa) del rotore:

        Lunghezza della scheda durante il passaggio sotto la testina:

        Quando il sensore della testina va a 1 bisogna contare quanti impulsi
        il rotore genera prima che la scheda finisca.
        Questo parametro e' la lunghezza della scheda.

        ZonaExit:
        Quanti impulsi servono per far uscire la scheda telefonica dopo che e'
        passata tutta sotto alla testina (quando il sensore della testina torna
        a 0).

        Lunghezza + ZonaExit + IngressoScheda = Percorso di tutta la scheda.

        Occorre mettere un condensatore in serie tra le testine e l'input MIC
        del Computer per evitare che l'alimentazione del microfono esterno
        danneggi le schede durante la lettura.

        Si sconsiglia di utilizzare l'amplificatore audio di un registratore a
        cassette perche' non e' del tutto fedele all'onda wave della banda:
        Ha una pendenza di -20 dB per decade, sulle cassette audio viene
        sovrapposta una frequenza di bias per enfatizzare i toni alti ed
        eliminare la pendenza di 20 dB per decade del nastro magnetico.

        Trovate le misure di prima, basta andare sul menu' opzioni di Magneto,
        alla voce Imposta Lettore.

        Nel riquadro Dimensioni:
        Alla voce ZonaExit va messo il numero di impulsi per far uscire la
        scheda.
        Alla voce Lettore va messa la lunghezza della scheda in impulsi.

        Poi occorre fare delle prove di lettura con diverse velocita'. Trovata
        la velocita' giusta cliccando sulla finestra Wave Della Banda al menu'
        Traduttore, sul tasto Trova della voce Zero Crossing apparira' la
        frequenza da mettere sulla finestra di calibratura del lettore alla
        voce Frequenza Di Scrittura nel riquadro Segnale.

        Esegui il test, ed inserisci la velocita' trovata, poi salvi il
        settaggio ed esegui il test.

        Fatto questo hai regolato tutti i parametri di Magneto per leggere e
        scrivere le schede telefoniche con il tuo lettore fatto in casa.

        Per fare delle schede compatibili con quelle telefoniche si possono
        usare dei fogli di cartoncino con appiccicato sopra del nastro di una
        cassetta VHS vergine; mettendoci poi sopra un peso, il collage viene
        uniforme. Si consiglia di seguire come esempio le vecchie schede SIP.

--------------------------------------------------------------------------------
[9]   HDSS: HARDWARE DIGITO SMANETTAMENT SYSTEM.

        HDSS (in inglese maccheronico) e' un progetto collaterale di Magneto
        sull'analisi del funzionamento della lettura/scrittura delle schede
        telefoniche effettuata dalla Digito con tecniche di debug applicate
        direttamente sull'hardware della Digito.

        Viene collegata una Digito accesa al computer e tramite vari strumenti
        di analisi degli stati logici viene fatto un reverse hardware della
        Digito e dei relativi segnali che circolano dentro.

        Ci focalizzeremo per ora su 2 componenti:
        * Scheda logica
        * Lettore Urmet/IPM

        Sulla scheda logica ci sono 2 processori:
        * HD6433047
        * 68LC302

        Il core principale e' costituito dalle 2 CPU, da una serie di memorie
        RAM, una scheda EEPROM collegata come espansione, 2 EEPROM siglate come
        MEW 320 e MEW 321.

        In questo articolo descriveremo l'HDSS relativo al processore HD6433047
        (Microcomputer Processore multiprotocollo della hitachi).

        Questo processorino ha tutta una serie di pin I/O programmabili con
        vari ingressi analogici, infatti tutti i segnali del lettore arrivano
        analogici fino a qui.

        Nel lettore ci sono dei dispositivi di comando, amplificatori dei
        segnali, una EEPROM AT24LC02 (famosa per essere quella delle chiavette
        connectionless) contente i dati del lettore e il sommario delle
        operazioni compiute dal lettore sotto forma di statistiche.

        In realta' la lettura viene fatta dalla scheda logica e dal
        microcomputer.

        Sulla scheda logica ci sono degli stadi analogici che sono basati su
        amplificatori operazionali in grado di normalizzare il segnale
        (rimbalzi compresi): in pratica gli algoritmi DynaNorm e tutto cio'
        che riguarda il modulo WaveSolder di Magneto viene eseguito dalla
        scheda logica.

        A seguito di un errore commesso da noi siamo riusciti ad avere un dump
        non del tutto fedele del work in progress all'interno del databus
        della Digito.

        Collegando l'ingresso della scheda audio alla data line della CPU nel
        punto di collegamento con la RAM abbiamo registrato qualcosa che e'
        un disturbo generato da diversi Mega hertz che la schedina audio non ha
        ovviamente potuto digitalizzare del tutto.

        Analizzando lo spettro dell'onda, come facevo nel 1992 con i cicli
        macchina dell'MSX (un computer basato su Z80), con una tecnica simile
        al Tempest, sono risucito a vedere cosa potrebbe fare la CPU (vedi
        immagine allegata: Magneto/image/CPUSTM.gif).

        In primo luogo si vede che la CPU campiona ciclicamente il segnale
        della banda magnetica. In seguito fa dei cicli macchina per un breve
        periodo	che hanno a che fare con il controllo del lettore.

        La sequenza pare essere:
        Ciclo {
         Qualcosa
          Ciclo {
           Lavoro intenso
           } Evento che esce dal ciclo
          Lavoro intenso
         } evento di fine banda
        Ciclo {
         poco segnale
         } fine ciclo

        A seguito c'e' un marasma che francamente non saprei cosa sia!
        A seguito si vede un ciclo macchina che segue fedelmente la forma
        d'onda letta dalla Digito (quella della banda magnetica).
        La forma dell'onda viene poi processata e cambia forma seguendo la
        sequenza della banda magnetica.

        A questo punto esce da una seriale una sequenza di dati che stiamo
        ancora cercando di decifrare, evidentemente non e' completa dal nostro
        punto di vista.

        Un dettaglio e' emerso dalla lettura dei wave attraverso gli stadi di
        ingresso della CPU:

        Nella prima parte della prima trama, gli impulsi - sono a distanze
        apparentemente casuali. Da un certo punto in poi gli impulsi - sono
        equidistanti nel tempo come se fossero un impulso di clock del sistema
        ternario.
        I rimbalzi amplificati come i segnali + fanno pensare ad una codifica
        del tipo:

        0 = -0+
        1 = -+0
        1 = -r+

        I dati tirati fuori da questa codifca non hanno alcuna verifica interna
        tipo parita' o checksum e sembrano casuali, non si esclude una
        modalita' da parte della Digito che sia leggermente diversa da Magneto
        nella lettura, anche se per il momento l'unica ipotesi che regge e' 
        quella del sistema pseudo ternario perche' ha piu' riscontro (99.99%
        dei casi) ed i checksum risultano validi.

        Si e' visto che si puo' collegare la Digito direttamente al computer e
        leggere le schede con il lettore originale facendole leggere dalla
        Digito alla velocita' giusta.
        Per fare questo implementero' nella prossima versione di Magneto due
        cose:

        * HDSS: Lettura dalla Digito.
        * DynaMagnetoLib: alcune librerie di DynaMagneto.

        Gia nella versione OpenExtra alcune parti dei sorgenti provengono da
        DynaMagneto, come per esempio la LptClass ed altri sistemi per le
        diverse codifiche.
        Queste librerie servono per implementare HDSS e le codifiche
        alternative poi verrano usate per rendere Magneto compatibile con
        DynaMagneto.

        La sperimentazione con HDSS e' ancora in atto...

--------------------------------------------------------------------------------
[10] DYNAMAGNETO.

        DynaMagneto e' completamente realizzato in VB6 con alcune estensioni
        del linguaggio (le VBE di ROTOR.DLL).

        Il programma dispone di un'interfaccia grafica (WinGui 2006) ed e'
        composto da 9 progetti (e' un project group) e da una cinquantina di
        moduli.

        Teoricamente lavorera' sulla superficie della scheda e le tracce
        saranno definite da un file XML che appartiene al linguaggio codec/rml.

        Il programma si basa su una procedura reversibile che attraverso il
        linguaggio dichiarativo codec/rml elabora i dati e le schede di
        qualsiasi tipo e codifica supportata.

        Ecco come funziona la codifica reversibile di DynaMagneto:

        La prima parte e' quella fisica:
                Viene creata un'immagine MxN bitmap magnetica della scheda in
                corrispondeza delle tracce.

        La seconda parte divide le tracce:
                Vengono divise e riconosciute le tracce magnetiche della
                superficie e viene creato un wave multitraccia.

        La terza parte divide gli eventuali token o trame:
                Si occupa di divisioni interne delle tracce.

        La quarta parte si occupa della modulazione:
                Decodifica le trame di bit.

        La quinta parte si occupa della codifica dei dati:
                Si occupa di passare da sequenze di bit, codifiche, alle form
                dinamiche dove si possono modificare i dati in modo semplice
                ed intellegibile.

        Il tutto viene controllato dal linguaggio codec/rml reversibile di
        DynaMagneto.

        Con lo stesso codice e' possibile transcodificare schede, leggerle,
        scriverle e modificarle.

        E' un progetto ambizioso che purtroppo procede a rilento a causa
        dell'esiguo numero di collaboratori.

        La scelta del codice dichiarativo a layer di DynaMagneto e' dovuta
        all'implementazione del programma.
        Visto che XML era il linguaggio che si avvicinava di piu' alle nostre
        esigenze, lo abbiamo cambiato di qualche dettaglio per avere un codice
        piu' semplice.
        
        Codec/rml sta per:
        Encoder/Decoder Reversible Markup Language.
        Tutte le operazioni possono essere fatte dritte o rovesce con lo stesso
        codice che dichiara il funzionamento della scheda.

        Riporto un esempio di codec/rml nella sezione di dichiarazione della
        codifica di una traccia nel membro scheda.traccia.codifica:

	<$strlen1 NIBBLE HIDE>
        <stringa NIBBLE STR LEN=$strlen1 MAX=4 ALFA="HEX" CAPTION="Dati">

        Questo definisce una classica situazione:
        1 Nibble per la lunghezza della stringa di nibble espressa in nibble.
        N Nibble per la stringa nell'alfabeto esadecimale di lunghezza massima
                 di 4 nibble.

        Visualizza nella form dinamica una casella di testo chiamata Dati,
        internamente la variabile si chiama 'stringa'.

        Esempio del dump della stringa '13C0':
        413C0

        Un tipico linguaggio codec/rml e' strutturato in diversi layer che sono
        annidati tra loro creando cosi' un oggetto dinamico di transcodifica.

        <surface>
          <track>codifica</track>
          ...
        </surface>

        In questo modo la prima versione di DynaMagneto usa un parser scritto
        da me per controllare tutto il programma.

        Allo stato attuale e' anche stato creato un generatore di parser per
        la classe Pharser di DynaMagneto e mi sono ritrovato a scrivere il
        codice dei sorgenti e del parser in altri ulteriori linguaggi
        dichiarativi piu' semplici.

        Ne riporto una porzione di codice:

        TAG{,* COMP CLO
                REQ,CAPTION $ Cap
        ,
                FAC,SIZE $#
                FAC,NOT !
                FAC,LSB !
                FAC,MSB !
                FAC,BENDIAN !
                FAC,LENDIAN !
                FAC,RENDIAN !
        ...
        },

        Sembra un misto tra assembly ed una dichiarazione di qualche tipo.
        Queste sono le prime righe del parser codec/rml nella sezione
        di dichiarazione delle form dinamiche.
        Definisce un tag dal nome arbitrario con dei parametri richiesti e
        facoltativi di vario tipo.

        Insomma: dietro c'e' molto lavoro...
        Sicuramente mi servira' una mano per scrivere guide e manuali vari.
        Nelle versioni successive faro' un'interfaccia grafica ad oggetti per
        semplificare la cosa (che in realta' e' gia' semplice).

        Per il momento il programma transcodifica i dati, ha un'interfaccia
        GUI stabile, utilizza il directsound per leggere e scrivere con lettori
        collegati alla scheda sonora, utilizza la LPTCLass per connettersi
        all'I/O per i lettori vari.

        Non so ancora quanto ci vorra' per la prima versione pubblica di
        DynaMagneto, per il momento sono a buon punto.

--------------------------------------------------------------------------------
[11] PROGETTI COLLATERALI, WORK IN PROGRESS...

        Work in progress dei progetti collaterali o collegati al progetto
        Magneto:

        Allo stato attuale il progetto Magneto si trova in fase di studio per
        l'implementazione dell'HDSS, in rete ed in allegato a questo articolo
        (vedi archivio: Magneto/stm4src.zip) e' disponibile la versione Open
        Extra che supporta l'elaborazione di schede telefoniche ed altre schede
        basate sul sistema pseudo-ternario.
        Possiamo tranquillamente dire che Magneto e' diventato un po piu'
        "Dyna" (dinamico), ma e' legato sempre alla codifica Urmet ed al
        sistema pseudo-ternario.

        Per quanto riguarda DynaMagneto il coding ed il test sono in corso. Si
        sono fatte anche alcune sperimentazioni di codifiche e test in tutte le
        modalita', in questo periodo ho ultimato il parser del linguaggio
        codec/rml; l'interfaccia I/O e' stata ampliata anche per l'utilizzo di
        schede PCI aggiuntive.
 
        Il progetto HDSS e' stato gia portato a compimento, piu' avanti si
        faranno ulteriori test.

        Il progetto Digito Chipset direi e' a buon punto, e' stato studiato il
        funzionamento della Digito in ogni sua parte, ora abbiamo un'idea molto
        precisa di come sia stata implementata a livello hardware.
        Faremo presto una pubblicazione in merito.

        SMS Gratis da cabine Digito:
        Allo stato attuale si puo' fare. Pare che, salvo errori della Digito,
        l'ipotesi del Database delle schede possa essere smentita e il credito
        si trovi memorizzato all'interno della scheda telefonica.
        Allo stato attuale pare che la scheda (anche una degli anni '90) venga
        riconosciuta dalla Digito come carica, tuttavia appena la Digito ha a
        che fare con la rete da' un errore di invalidita' della scheda.
        Nonostante questo io posso scalare credito sulla Digito che sto usando
        e non scalarlo sulla scheda.
        Questo crea forti dubbi sul fatto che il credito sia un'entita' remota
        in tutti i casi.

        Progetto 4444:
        Per il momento abbiamo visto che in ogni profilo si manifesta la stessa
        situazione, non e' dovuto ad un errore di installazione, ma ad un
        preciso profilo di centrale.
        Con il # sembra darci retta ed accettare altre cifre, ma pare che nel
        terminale ci sia un sistema che in caso di # tenta la sequenza di 
        configurazione.
        E' un preciso profilo di centrale che accetta numeri corti che
        iniziano con 4, il servizio 400 infatti funziona.
        Lo 0 da' invece la linea, ma non accetta chiamate.
        Con alcuni servizi come 400 o 410 la centrale stabilisce la
        comunicazione voce ed e' stabile. Quando pero' i servizi accedono
        all'identificazione dei numeri o consultano qualche db, il software
        di centrale sgancia la linea.
        E' da vedere se con il nuovo cambiamento del firmware e' variato
        qualcosa.
        Per il momento non posso comunicare altro sul progetto 4444.
        
        Infine ecco alcuni collegamenti a studi di terze parti sulle tessere
        magnetiche:

        "MTF project", Jack McKrak, BFi#2 Maggio 1998
        <http://bfi.s0ftpj.org/bfi2.zip>

        "Project MTF: localista o serialista?", Jack McKrak e |PazzO|,
        BFi#3 Luglio 1998 <http://bfi.s0ftpj.org/bfi3.zip>

        "Mag Stripe Madness", Major Malfunction, CanSecWest Aprile 2006
        <http://www.cansecwest.com/slides06/csw06-malfunction.pdf>
        
--------------------------------------------------------------------------------
[OUTRO]

        Ci sono tanti altri progetti in corso... di vario tipo...
        Facciamo sempre un sacco di tramaci anche MultiMendi.
        Con probabilita' molto alta anche quest'anno faremo un Phreak Meeting
        dove verranno presentati i nuovi progetti.
        E non dimenticate di venire ai tramacing...

        EPTO (A)
        
--------------------------------------------------------------------------------
------------------------------------- FINE -------------------------------------
--------------------------------------------------------------------------------
Fine?
I tramaci continuano :) ...


================================================================================
------------------------------------[ EOF ]-------------------------------------
================================================================================

