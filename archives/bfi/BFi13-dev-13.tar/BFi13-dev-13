================================================================================
---------------------[ BFi13-dev - file 13 - 20/08/2004 ]-----------------------
================================================================================


-[ DiSCLAiMER ]-----------------------------------------------------------------
        Tutto il materiale contenuto in BFi ha fini esclusivamente informativi
        ed educativi. Gli autori di BFi non si riterranno in alcun modo
        responsabili per danni perpetrati a cose o persone causati dall'uso
        di codice, programmi, informazioni, tecniche contenuti all'interno
        della rivista.
        BFi e' libero e autonomo mezzo di espressione; come noi autori siamo
        liberi di scrivere BFi, tu sei libero di continuare a leggere oppure
        di fermarti qui. Pertanto, se ti ritieni offeso dai temi trattati
        e/o dal modo in cui lo sono, * interrompi immediatamente la lettura
        e cancella questi file dal tuo computer * . Proseguendo tu, lettore,
        ti assumi ogni genere di responsabilita` per l'uso che farai delle
        informazioni contenute in BFi.
        Si vieta il posting di BFi in newsgroup e la diffusione di *parti*
        della rivista: distribuite BFi nella sua forma integrale ed originale.
--------------------------------------------------------------------------------


-[ HACKiNG ]--------------------------------------------------------------------
---[ P0WERBR0WSiNG ]------------------------------------------------------------
-----[ +mala <malattia@gmx.net> http://3564020356.org ]-------------------------


, - " ^ " - , . _ . , - " ^ " - , . _ . , - " ^ " - , . _ . , - " ^ " - , . 
~WhatYouSeeIsWhatYouChose~WhatYouSeeIsWhatYouChose~WhatYouSeeIsWhatYouChose~ 
 
                               POWERBROWSING 
                                  v1.1.0 
                              +mala, 20040715 

~WhatYouSeeIsWhatYouChose~WhatYouSeeIsWhatYouChose~WhatYouSeeIsWhatYouChose~ 
, - " ^ " - , . _ . , - " ^ " - , . _ . , - " ^ " - , . _ . , - " ^ " - , . 

1.  INTRO
1.1 Come navigate ora? 
1.2 Come funziona, invece?
1.3 Note
2.  TECNOLOGIE
2.1 Perche' conoscere HTTP? 
2.2 Perche' conoscere HTML? 
3.  PB TECHNIQUES: tools and basics
3.1 Alternative browser
3.2 Leecher e Teleporter
3.3 Spider e scraper
3.4 Proxy-like software
4.  PB TECHNIQUES: advanced
4.1 Impara a cercare
4.2 Esperimenti con curl
4.3 Oneliner con wget e lynx
4.4 Fight Against Flash
5.  Bot Basics
5.1 Detecting Web Patterns
5.2 Website navigation with bots
5.3 Data Extraction
6.  Perl PowerBrowsing Tools
6.1 Perche' Perl? 
6.2 Perl Packages 
6.3 LWP::Simple
6.4 LWP::UserAgent
7.  Condividete i vostri dati
7.1 Il Web e RSS
7.2 La mail
7.3 Il package Net::Blogger
7.4 TWO
8.  Esempi


=============================================================================
1. INTRO  
-----------------------------------------------------------------------------

Cos'e' il powerbrowsing? Il testo che leggete attorno al titolo costituisce
una buona spiegazione di questa parola: accedere ai contenuti del Web vedendo
solo quello che decidete di vedere. Anche se questa puo' sembrare una 
operazione semplice da portare a termine, in realta' non lo e' affatto e,
sicuramente, in futuro diventera' sempre piu' complessa, a meno che non
diventiate dei "powerbrowser".
Questo testo cerca di spiegare come funziona attualmente il Web e come
potete fare powerbrowsing, utilizzando strumenti gia' pronti o creandone
di nuovi per venire incontro alle vostre esigenze.


1.1 Come navigate ora? 
-----------------------------------------------------------------------------

Come naviga, ora, la maggior parte di voi? Molto probabilmente utilizzate il
browser predefinito del vostro sistema operativo, il che nella maggior parte
dei casi significa Internet Explorer. La possibilita' di personalizzare il 
modo in cui vedete i contenuti delle pagine Web e' limitata dalle opzioni 
che il browser vi mette a disposizione, quindi probabilmente scaricate sempre
tutte le immagini presenti in un sito e i contenuti attivi tipo Flash e 
applet Java, vedete sempre piu' pubblicita' all'interno delle pagine Web e
vi capita di dover chiudere tonnellate di popup quando visitate alcuni siti.

Sono sicuro, pero', che i piu' permalosi fra voi si staranno scandalizzando
per la mia generalizzazione, perche' usano un altro browser, anzi magari
addirittura un altro sistema operativo! Lasciatemi indovinare, pero': voi
seguite comunque i link che il browser (qualunque esso sia) vi mostra, vedete
le pagine all'interno di finestre scelte da lui e accedete solo agli URL che 
lui decide di farvi vedere. In alcuni casi, per raggiungere le informazioni
che vi interessano dovete seguire dei percorsi prefissati all'interno di un
sito (un po' come negli Autogrill... e ogni sito, naturalmente, ha la sua
"noce di pepe"). E per finire, scaricate sempre e comunque molto piu' codice 
HTML di quanto non ve ne serva in realta': magari non lo vedete, ma state 
certi che il vostro modem se ne accorge!

Ma in fin dei conti perche' preoccuparsi? Magari non e' esattamente quello 
che desideravate, ma i modem son sempre piu' veloci e poi questo e' quello 
che c'e' e non si puo' mica cambiarlo piu' di tanto...


1.2 Come funziona, invece?
-----------------------------------------------------------------------------

Ehi, sveglia! Ho una notizia per voi: un computer NON E' una televisione! Si
suppone che esso faccia quello che _voi_ gli chiedete, non quello che _altri_
gli dicono di fare. Inoltre, le cose non sono sempre come vi appaiono: prima
della fine di questo testo, vi renderete conto che e' possibile accedere 
direttamente a cio' che il browser di solito non vi mostra e nascondere cio' 
che invece siete solitamente costretti a vedere.

Ora, pensate alla possibilita' di scaricare un decimo dei dati che di solito
scaricate, saltando pubblicita' e popup, conservando tutte le informazioni
che vi interessano (e solo quelle) sul vostro computer, con la possibilita'
di rivederle, una volta scollegati, in modo semplice, personalizzato e piu'
efficace. Pensate al fatto che, una volta che queste informazioni stanno sul
vostro PC, voi potete scrivere dei programmi che le elaborano per produrre
nuove informazioni ancora piu' interessanti. Infine, valutate la possibilita'
di mettere questi dati a disposizione di chiunqe, magari in modo automatico.
Tutto questo assieme e' cio' che io chiamo powerbrowsing!


1.3 Note
-----------------------------------------------------------------------------

Forse alcuni di voi storceranno il naso leggendo espressioni come "fare 
powerbrowsing" o "essere dei powerbrowser". Ebbene, questa e' (forse neanche
la peggiore) conseguenza del fatto che questo testo e' nato originariamente
come semplice serie di slide, da presentare in lingua inglese. Quindi, vi
prego, portate pazienza :)

Parlando di conseguenze, mi sembra il caso di citarne altre: innanzitutto, la
presentazione doveva essere rivolta a un pubblico vario e cosi' e' anche il
testo che state leggendo. Questo significa che mentre alcuni di voi potranno
trovare una parte del tutorial interessante e il resto incomprensibile, altri
invece potranno annoiarsi per un bel po' prima di leggere qualcosa che li
stimoli, mentre altri ancora non troveranno fra queste righe nulla che valga 
la pena ricordare. A tutti quanti consiglio di saltare le parti meno gradite
e, in caso non rimanga nulla, poco male per voi: avete sicuramente speso meno
tempo a leggere di quanto io ce ne abbia messo per scrivere tutto.

Infine, mi sembra assolutamente d'obbligo citare il libro "Spidering Hacks",
di Tara Calishain e Kevin Hemenway (aka Morbus Iff), edito da O'Reilly, che
mi ha dato diverse idee interessanti e che chiunque abbia intenzione di 
creare dei bot secondo me dovrebbe leggere (e, perche' no, anche ACQUISTARE, 
se ritenete che l'autore lo meriti). Esso, tra l'altro, ha anche delle note
molto interessanti riguardanti la netiquette dei bot, che condivido e che
purtroppo non ho avuto tempo di inserire in questa versione del testo.


=============================================================================
2. TECNOLOGIE
-----------------------------------------------------------------------------

Per essere in grado di capire cosa succede all'interno del vostro PC quando
scaricate una pagina Web, dovreste conoscere le tecnologie a cui si appoggia
tutto il Web. All'interno di questo testo verranno date per scontate le basi
di HTTP e HTML, tuttavia cerchero' di spiegare almeno i concetti principali
con cui verrete in contatto. 
Poiche', pero', cio' che scrivo potrebbe avere anche dei riferimenti a dei
concetti piu' avanzati, eccovi un paio di link a siti che potreste trovare
utili:
  
http://www.w3.org/MarkUp/    (everything you need to know about HTML)  
http://www.w3.org/Protocols/ (everything you need to know about HTTP)  


2.1 Perche' conoscere HTTP? 
-----------------------------------------------------------------------------

In realta' non tutti i dettagli relativi a questo protocollo vi saranno
indispensabili. Tuttavia, piu' avanti nel testo sentirete parlare di alcuni
concetti, piu' o meno legati al protocollo HTTP, e conoscerne gia' il 
significato vi aiutera' a capire meglio cosa saranno in grado di fare i 
vostri bot in Perl. Inoltre, sapere quali dati il vostro computer scambia
con i server a cui si collega vi aiutera' a creare dei bot piu' stabili e,
soprattutto, sicuri.

GET e POST
----------
I "metodi" GET e POST sono i primi due termini che prenderemo in esame: essi
corrispondono ai due diversi modi in cui il vostro browser richiede dati al 
server. Senza entrare troppo nei dettagli, le caratteristiche principali dei
due metodi sono le seguenti:

- GET puo' essere utilizzato sia per richiedere una pagina statica sia per
  inviare parametri a una pagina generata dinamicamente (CGI, PHP e cosi'
  via). L'URL classico di una GET e' quello del tipo

  http://www.sito.web/pagina.php?parametro1=valore1&parametro2=valore2

  che ogni tanto vi capita di leggere nella barra degli indirizzi del vostro
  browser. La quantita' di dati che potete inviare con una GET e' abbastanza
  limitata, inoltre e' bene tenere presente che i parametri inviati con una
  GET vengono solitamente salvati (anche) all'interno dei log del server Web.

- POST viene utilizzato solo nel caso in cui si desideri inviare dei dati al
  server Web. La quantita' di byte che potete inviare e' superiore a quella
  di una GET e nei log del server verra' salvato solo l'URL a cui POSTate
  dati, e non i dati stessi. Questo particolare e' da tenere a mente se, ad
  esempio, desiderate creare dei bot che si logghino automaticamente dentro 
  a un sito: tenete presente, tuttavia, che se la connessione e' in chiaro 
  la vostra login e la vostra password non saranno necessariamente al sicuro.

Referer
-------
Fra i vari parametri che vengono solitamente passati insieme a una richiesta
GET o POST, se arrivate a una pagina seguendo un link i browser solitamente 
inviano al server anche il referer, cioe' l'URL del sito da cui state 
provenendo. In questo modo e' possibile per il server verificare che voi 
stiate effettivamente eseguendo un certo script dal sito stesso e non in 
locale, oppure creare delle statistiche in base a quanti utenti provengono 
da quale sito. 

User-Agent 
----------
Lo User Agent e' il software che si collega per vostro conto al server e che
dialoga con esso richiedendo pagine Web e ricevendole in risposta. In realta'
tale nome e' utilizzato piu' che altro per la stringa con cui il programma 
(che puo' essere un browser o un'altro tipo di applicazione) si identifica 
con il server. A volte, proprio in base a questa stringa alcune applicazioni 
vengono tagliate fuori da siti che, ufficialmente, sono "ottimizzati" per un 
particolare browser. I browser piu' intelligenti (se ve lo state chiedendo,
NO, Internet Explorer non e' tra questi) consentono di identificarsi in modi
differenti, e se avete intenzione di scrivere qualche applicazione seria per
il Web dovreste contemplare anche voi questa possibilita'.

Cookie 
------
I cookie sono dei file di testo che vengono salvati automaticamente dal 
browser sul vostro disco. Essi contengono informazioni di vario genere, il
piu' delle volte relative alle vostre precedenti connessioni a un sito o alla
vostra autenticazione. Per questo motivo, i cookie sono spesso mal visti da 
chi (a ragione) desidera proteggere la propria privacy. Tuttavia, essi sono
usati praticamente ovunque e alcuni siti non funzionano se l'applicazione che
si collega ad essi non li supporta.

Proxy 
-----
I proxy sono programmi che "girano" le richieste che partono dalle vostre 
applicazioni Web ai server desiderati e restituiscono al client le risposte 
di questi server. Il loro funzionamento puo' essere riassunto da questo
schema:


    +---------+                +---------+                +---------+
    |         |   richiesta    |         |   richiesta    |         |
    |         |--------------->|         |--------------->|         |
    | CLIENT  |                |  PROXY  |                | SERVER  |
    |         |<---------------|         |<---------------|         |
    |         |   risposta     |         |   risposta     |         |
    +---------+                +---------+                +---------+


L'utilita' dei proxy e' dovuta a vari motivi: 

- al client potrebbe essere precluso l'accesso al server, ma non al proxy: in
  questo caso, le applicazioni che girano sul client potrebbero ugualmente
  comunicare col server tramite il proxy

- alcuni proxy hanno una cache, all'interno della quale vengono salvati i
  file richiesti piu' di frequente. Se, allora, la connessione fra client e
  proxy e' molto piu' veloce di quella fra client e server allora si possono
  scaricare i file in cache molto piu' rapidamente

- alcuni proxy non rivelano al server il vero mittente della richiesta, in
  modo da poter rendere la connessione anonima per il client

- piu' avanti, vedremo come e' possibile sfruttare i proxy per ottenere altri
  vantaggi, addirittura piu' interessanti.


2.2 Perche' conoscere HTML? 
-----------------------------------------------------------------------------

Perche' tutto quello che il vostro browser vi fa vedere ha un suo sorgente
HTML, scritto a mano da qualcuno, generato da un programma oppure da uno 
script. Anzi, oltre a conoscere semplicemente le basi di HTML dovreste essere 
in grado di capire se del codice viene generato automaticamente o meno, in 
modo da poter utilizzare tag ricorrenti per spezzettare il contenuto di una 
pagina ed estrapolarne i contenuti. 

Poiche' all'interno dei siti dinamici i form la fanno da padroni, un po' di
tempo dovreste dedicarlo anche per capire come funziona questa tecnologia. In
realta' non si tratta di nulla di complicato, tuttavia un po' di esperienza 
sul campo vi permettera' non solo di padroneggiare la sintassi, ma anche di 
comprendere appieno il funzionamento di un sito. E senza particolari tecniche
intrusive, ma solo grazie alla conoscenza di form e html (e magari un po' di 
cervello), sarete in grado di far fare a uno script molto piu' di quanto si 
ritenga normalmente possibile.


=============================================================================
3. PB TECHNIQUES: tools and basics
-----------------------------------------------------------------------------

Di strumenti gia' pronti per fare powerbrowsing ce n'e' un sacco in giro,
disponibili gratuitamente (o, se proprio insistete, anche a pagamento), per
qualsiasi sistema operativo. Descriverli uno per uno sarebbe praticamente 
impossibile, ma possiamo perlomeno cercare di raggrupparli per tipologia e
descrivere le caratteristiche principali di ogni categoria.


3.1 Alternative browser
-----------------------------------------------------------------------------

I browser alternativi sono, fondamentalmente, tutti quelli diversi da una 
qualsiasi versione di Internet Explorer. Sebbene non siano la soluzione 
definitiva ad ogni problema, essi sono comunque un primo passo verso la 
liberazione del vostro sistema dai contenuti non richiesti, come ad esempio
i banner pubblicitari, i menu in flash e le finestre popup.

Opera, ad esempio, vi permette di attivare o disattivare il caricamento di 
tutte le immagini di una pagina (o di tutte quelle che non sono presenti in 
cache, nella fattispecie i banner) con un semplice clic, mentre per eseguire
la stessa operazione con Internet Explorer dovete perdervi all'interno dei 
menu di configurazione. Lo stesso browser vi permette anche di attivare o
disattivare al volo Javascript o altri contenuti dinamici presenti nelle
pagine Web. Allo stesso modo, infine, potete impostare una modalita' di
visualizzazione personalizzata delle pagine, con caratteri e colori scelti 
da voi anziche' quelli decisi da chi ha creato il documento originale.

Fra i browser grafici, ultimamente si parla molto bene anche di Firebird. Io
ancora non l'ho provato, quindi mi aspetto feedback numerosi e "powerbrowsing
hints" riguardanti questo browser. Ad ogni modo, senza andare troppo lontano,
anche Mozilla e' per vari motivi una scelta migliore di MSIE: rispetto ai
browser piu' recenti, inoltre, esso garantisce una maggiore compatibilita'
con buona parte dei siti Web, al prezzo pero' di una maggiore pesantezza nel
codice.

Se, invece, quello che vi interessa e' solo il testo di una pagina Web,
potete considerare la possibilita' di utilizzare un browser testuale come 
lynx o links o w3c: la velocita' con cui le pagine, private di tutti i 
contenuti pesanti, verranno scaricate vi sorprendera'. Inoltre, come potrete 
vedere in seguito, la possibilita' di richiamare il contenuto di una pagina 
Web dalla linea di comando apre la strada a diversi utilizzi piu' efficaci,
anche se forse meno convenzionali, delle informazioni provenienti dal Web.


3.2 Leecher e Teleporter
-----------------------------------------------------------------------------

I termini con cui viene definita questa categoria di programmi derivano
rispettivamente da "leech" (sanguisuga) e da "teleport" (letteralmente
teletrasporto, ma e' anche il nome di un programma -Teleport Pro- usato per 
il mirroring locale dei siti Web). Queste applicazioni permettono di salvare
grandi quantita' di file sul vostro disco, effettuando la copia completa di
un sito Web o prelevandone solamente i contenuti che a voi interessano.

Anche in questo caso, c'e' stato un tale proliferare di applicazioni che e'
praticamente impossibile stare dietro a tutte. Personalmente, quelle con cui
mi son trovato meglio nel corso degli anni sono state Teleport Pro e GetRight
per Windows, wget, curl e lynx sotto Linux. In realta', la distinzione fra
Windows e Linux si e' andata affievolendo, in quanto le applicazioni di un OS
girano ora senza problemi anche sull'altro: il risultato e' che ora i tool 
che uso piu' di frequente sono wget, lynx e GetRight (comodissimo per il suo
"GetRight browser", che si collega a una pagina e ne visualizza tutti i file
collegati permettendo di scaricare solo quelli che veramente interessano).

Un approfondimento a parte merita lynx: esso, pur essendo un browser, e' 
finito anche in questa categoria poiche', grazie agli switch -source e -dump 
e alla possibilita' di essere concatenato con altri programmi, e' in grado di
funzionare anche come leecher e di recuperare file o informazioni in modo
molto efficiente (piu' avanti, nella sezione 4.3, potrete vederne alcuni 
esempi).


3.3 Spider e scraper
-----------------------------------------------------------------------------

Visto che fino a qualche mese fa neanch'io avevo presente questa distinzione,
ho deciso di recuperare (grosso modo) la definizione che avevo letto su 
"Spidering Hacks" e che mi illumino':

- gli "spider" sono programmi che recuperano dati dal Web in modo automatico.
  Solitamente, essi sono piu' intelligenti dei teleporter (nel senso che non
  si limitano a seguire tutti i link che trovano, ma possono selezionarli in
  base a qualche particolare algoritmo) e tendono a scaricare l'intero 
  contenuto delle pagine;

- gli "scraper" sono programmi che estraggono solo alcune parti specifiche 
  dalle pagine Web. In realta' spesso essi devono comunque scaricare ogni
  pagina per intero, tuttavia i dati salvati riguardano solo le informazioni
  "interessanti" e non l'intero contenuto delle pagine.

Trovare in giro spider e scraper pronti da utilizzare non e' semplicissimo,
tuttavia ce n'e' qualcuno degno di nota: ad esempio, liberopop (con tutte le
sue varianti) e' un programma che consente di scaricare tramite il proprio
client di posta elettronica i messaggi ricevuti su una casella email di
libero, provider che da un po' di tempo ha lasciato il solo accesso Web per
la consultazione della posta. La cosa che mi e' piaciuta maggiormente di
liberopop e' la sua struttura (ehi, ma e' uguale a quella dei proxy!)


     +---------+             +----------+             +---------+
     |         | rich POP3   |          |  rich HTTP  |         |
     |         |------------>|   POP3   |------------>|         |
     | CLIENT  |             | EMULATOR |             | SERVER  |
     |         |<------------|          |<------------|   WEB   |
     |         | risp POP3   |          |  risp HTTP  |         |
     +---------+             +----------+             +---------+


praticamente identica a quella di un mio vecchio programma (ANO - Another
Non-working Offline forum reader, pubblicato in BFi08 e reperibile su
http://bfi.s0ftpj.org/online/bfi8/BFi08-20 ), che consentiva la consultazione,
tramite il proprio client di posta, dei forum via Web. Un'evoluzione di ANO e'
TWO (The Working Offline forum reader), uno scraper che verra' descritto piu'
in dettaglio nella sezione 7.2.


3.4 Proxy-like software
-----------------------------------------------------------------------------

I programmi di questa categoria sfruttano l'architettura di un server proxy 
per ottenere risultati diversi da quelli che normalmente ci si aspetterebbe
da un'applicazione del genere. Grazie alla loro posizione intermedia fra
client e server, infatti, essi possono operare sui dati le operazioni piu'
diverse, ad esempio filtrando le informazioni provenienti dal server e 
conservando solo cio' che vi interessa, oppure modificando al volo l'aspetto 
delle pagine che scaricate; allo stesso modo, essi possono elaborare le 
informazioni che voi mandate al server per riutilizzarle in un secondo tempo,
automatizzando le classiche procedure di inserimento dati all'interno di un
form o la navigazione di un sito.

Un esempio del primo tipo di proxy (quello, cioe', che rielabora i dati che
provengono dal server) e' costituito da Proxomitron, una piccola applicazione
per Windows che vi permette di filtrare le pagine Web, eliminando tutto cio'
che non vi va (banner pubblicitari, popup, javascript, spyware) e cambiandone
l'aspetto anche in modo radicale. Poiche' l'applicazione ha il grosso limite
di funzionare solo con il sistema operativo di Microsoft, un gruppo di 
valenti reverser sta lavorando a un progetto, chiamato Philtron, che mira a 
replicare il funzionamento di proxomitron e ad aggiungergli nuove funzioni.
Il linguaggio scelto per lo sviluppo e' PHP e il gruppo si sta coordinando
all'interno dei forum 

http://fravia.2113.ch/phplab/mbs.php3       (PHPLabs)
http://fravia.2113.ch/phplab/mbs.php3/mb001 (Seeker's messageboard)

Per quanto riguarda il secondo tipo di proxy, un esempio e' offerto da Web 
Scraping Proxy: quest'applicazione Perl e' in grado di "registrare" tutto 
cio' che voi fate all'interno di un sito, quindi crea automaticamente il
codice sorgente di un bot in perl che replichera' tutte le vostre azioni. Per
avere qualche informazione in piu' su questo programma, potete dare uno
sguardo al sito

http://www.research.att.com/~hpk/wsp

oppure vedere il relativo "hack" (il numero 30) su Spidering Hacks.


=============================================================================
4. PB TECHNIQUES: advanced
-----------------------------------------------------------------------------

Le tecniche di powerbrowsing piu' avanzate non si limitano all'utilizzo, per
quanto avanzato, di un singolo programma, ma tendono a sfruttare sia le 
conoscenze acquisite dai navigatori sia le potenzialita' di uno o piu' tool
(gia' esistenti o creati ad hoc). In questo modo i risultati che si ottengono
sono dei nuovi strumenti, decisamente piu' potenti ed efficaci. Procedendo
verso gli esperimenti piu' complessi, inoltre, potrete notare come ci 
sposteremo lentamente dal semplice scaricamento di file al piu' generale
(e, per quanto mi riguarda, piu' interessante) recupero di _informazioni_.

Chiaramente, l'abilita' del powerbrowser gioca qui un ruolo fondamentale e i
risultati saranno tanto migliori quanto maggiore sara' la vostra esperienza.
Tuttavia, gia' con le poche, semplici indicazioni che seguono potrete trovare
e scaricare molto piu' facilmente cio' che piu' vi interessa. 

A proposito degli esempi, tenete presente che come tali essi non hanno la
presunzione di essere particolarmente utili nella pratica. Anzi, data la
rapidita' con cui le informazioni sul Web cambiano alcuni di essi potrebbero
non funzionare neanche piu'. Non scoraggiatevi: leggeteli, capiteli, provate
a riadattarli e avrete sicuramente qualcosa in piu' che poche righe di 
codice.


4.1 Impara a cercare
-----------------------------------------------------------------------------

Come sicuramente avrete gia' intuito, per riuscire a vedere solo cio' che 
desiderate e' anche necessario, prima, _trovare_ cio' che desiderate. In 
altri casi, invece, sapete gia' dove si trova quel file che volevate 
scaricare, ma per qualche motivo non volete collegarvi al sito in cui e' 
salvato (ad esempio, perche' e' a pagamento): anche in questo caso, saper 
cercare vi aiutera' a trovare siti alternativi da cui scaricare lo stesso 
file.

Un primo consiglio che darei a chiunque e' quello di visitare Searchlores
(http://searchlores.org). All'interno di questo sito potete trovare
moltissimi tutorial dedicati alla ricerca e alle tecnologie del Web, in un 
ambiente che e' completamente libero da pubblicita', banner e schifezze 
varie. In particolare, vi consiglio di dare un'occhiata ai "search webbits",
stringhe di ricerca costruite ad hoc per particolari categorie di file o 
informazioni. 

Fra queste, il trucco dell'"index of" regna ancora sovrano, nonostante alcuni
siti commerciali cerchino gia' di sfruttarlo a loro vantaggio. In pratica, si
tratta di restringere la ricerca a quelle directory che rimangono aperte sul
Web e che, essendo nient'altro che dei lunghi elenchi di file, presentano 
sempre la scritta iniziale "Index of <nomedirectory>" e un link alla "parent
directory".

A questo punto, se ad esempio volete scaricare delle suonerie per cellulare
senza pagare una lira, perche' perdersi fra dialer e siti a pagamento quando
potete scaricare tutte le canzoni che desiderate in formato midi? Per trovare
i siti che le contengono, e' sufficiente dare in pasto a google la seguente
stringa:

    "index of" "parent directory" ringtones .mid

Un altro esempio riguarda i video divertenti, di quelli che si scarica quando
non si sa piu' come passare il tempo in ufficio. Con la stringa

    "index of" "parent directory" fun .mpg

(sostituite .mpg con il vostro formato video preferito) potete trovare tutti
i video che desiderate e, se vi va bene, anche diversi siti che vengono 
aggiornati periodicamente con nuovo materiale divertente.

Se, invece, volete provare lo stesso trucco con le mp3, probabilmente vi
ritroverete con un sacco di risultati sbagliati, che vi rimandano a siti
commerciali. Questo perche', come gia' vi avevo anticipato, una volta che si
comincia ad usare frequentemente un trucco "da questa parte", esso viene 
utilizzato anche "dall'altra" per attirare la gente dove in realta' non ha
la minima intenzione di andare. Per fortuna, indipendentemente da quante
fregature cerchino di rifilarci noi saremo sempre un passo avanti ;)

Abbastanza banalmente, se volete togliere il grosso dei risultati "fuffa" 
dalla vostra ricerca, potete provare ad eliminare le estensioni classiche
delle pagine web. Se poi vedete che ancora ottenete troppi risultati, potete
aggiungere qualche filtro su dei termini specifici:

    "index of" "parent directory" .mp3 Iron Maiden -.html -.htm -faq

Qui, ad esempio, siamo alla ricerca delle mp3 degli Iron Maiden, togliendo le
pagine HTML (che sicuramente non ci interesseranno) e i risultati che 
contengono la parola FAQ, poiche' nelle FAQ di un qualche neswgroup si era 
parlato di Iron Maiden e di mp3 e qualcuno ha avuto l'ottima idea di 
mirrorarle praticamente ovunque.

Se, infine, avete anche un'idea del titolo della canzone, potete provare a
inserirne l'ultima parola, attaccata all'estensione, oppure aggiungerne una
parte alle stringhe di ricerca:

    "index of" "parent directory" Metallica frantic.mp3 -.html -.htm


Un altro suggerimento che posso darvi sulla ricerca e' quello di sfruttare i
webtracker. Diversi siti Web utilizzano dei tracker per poter studiare le
statistiche relative agli accessi: quello che non tutti sanno, pero', e' che
diversi tracker commerciali sono aperti a tutti e consentono di controllare,
fra le altre cose, anche i referrer. Ad esempio, provate a dare un'occhiata
al mio webtracker:

http://extremetracking.com/open?login=alam

Come descritto in precedenza, i referrer sono gli URL da cui provenivano gli
utenti che hanno raggiunto un particolare sito, nel nostro caso quello che
utilizza il webtracker. Naturalmente, buona parte dei referrer saranno molto
probabilmente siti riguardanti lo stesso argomento: a questo punto, e' 
sufficiente cercare su google l'argomento di vostro interesse e il nome di
un webtracker (o il suo URL, o una stringa che lo identifichi) per poter
cominciare a scavare all'interno di una miniera di link potenzialmente
interessanti.

L'ultimo consiglio, se siete in cerca di un file particolare e specialmente
se e' coperto da copyright, e' quello di dare prima di tutto un'occhiata ai 
canali peer to peer: il download sara' molto probabilmente piu' lento di
quello da un normale sito web, tuttavia la probabilita' di trovare un film
o un libro anche solo a partire da un paio di parole del suo titolo e' molto
piu' alta. 

Se cercando file di una certa categoria incorrete spesso in nomi di gruppi 
che "rilasciano" periodicamente questi file, segnateveli: la volta 
successiva, avrete molte piu' probabilita' di trovare cio' che cercate 
usando questi nomi fra le stringhe di ricerca. Allo stesso modo, seguendo
(con un po' di attenzione) i link trovati all'interno dei classici file .nfo
mi e' capitato di trovare delle community monotematiche, decisamente piu'
specializzate e ricche di contenuti di qualsiasi motore di ricerca.


4.2 Esperimenti con curl
-----------------------------------------------------------------------------

Puo' capitare che all'interno di un sito sia presente un lungo elenco di
file dello stesso tipo, tutti quanti con un identico prefisso seguito poi da 
un numero incrementale. In caso l'elenco dei file sia visibile da Web 
(attraverso una pagina HTML, oppure perche' la directory in cui i file son 
salvati e' accessibile), il metodo piu' comodo rimane sempre wget:

wget -m -np http://url.del.sito/directory/

Eventualmente, e' possibile specificare l'estensione dei file che desiderate
scaricare:

wget -m -np -A <estensione> http://url.del.sito/directory/

Purtroppo, spesso l'accesso diretto alle directory e' precluso e molti siti
non mettono a disposizione un indice dei file, ma obbligano gli utenti a
scaricare almeno tante pagine (con immagini inutili, banner e popup) quanti
sono i file che si desidera scaricare. Per questo tipo di download, l'utility
piu' pratica da usare e' curl.

Curl permette di specificare, all'interno della linea di comando, uno o piu'
URL, specificando le parti variabili fra parentesi graffe o le sequenze di
caratteri alfanumerici fra parentesi quadre. Ad esempio,

http://url.del.sito/directory/file[1-100].txt
http://url.del.sito/directory/file[001-100].txt
http://url.del.sito/directory/file[a-z].txt
http://url.del.sito/directory/file[1-4]part{One,Two,Three}.txt

Vi permettono di scaricare tutti i file che iniziano allo stesso modo e che
continuano con, rispettivamente

- i numeri da 1 a 100
- i numeri da 1 a 100 (preceduti da zeri per ottenere sempre 3 cifre)
- le lettere da "a" a "z"
- i numeri da 1 a 4, seguiti da "partOne", "partTwo", "partThree"

Curl ha moltissime opzioni oltre a quelle descritte. Esso supporta inoltre
vari protocolli (HTTP, HTTPS, FTP, GOPHER, DICT, TELNET, LDAP, FILE) e puo'
essere utilizzato anche per l'upload di file (per saperne di piu', lanciate
"man curl" dalla shell). Tuttavia, esso ha ancora qualche limitazione: ad
esempio, non e' ancora in grado di gestire in modo efficiente i nomi di file
che contengono delle date. Se eseguite questo comando

curl -LO http://url.del.sito/fumettodelgiorno/[2000-2004][01-12][01-31].gif

scaricherete si' tutte le immagini che vi interessano, ma invierete al server
piu' richieste di quanto non sia necessario, cercando ad esempio di prelevare 
il file del 30 febbraio o quello del 31 giugno... 

Per ovviare a questo problema ci sono diverse tecniche: fra queste, ve ne
sono alcune che vedrete nella prossima sezione e che vi permettono di 
scaricare quotidianamente i vostri fumetti preferiti.


4.3 Oneliner con wget e lynx
-----------------------------------------------------------------------------

All'interno di questa sezione, avrete la possibilita' di vedere alcuni
oneliner creati partendo da wget e lynx. Essi partono da un progetto, che
avevo battezzato "Browsing the Web from the command line", a cui avevano
partecipato un po' di amici sul forum di RET (http://www.reteam.org). Il
progetto e' inattivo da tempo, ma essendo stato accorpato all'interno di
PowerBrowsing siete naturalmente liberi di partecipare, mandando commenti,
richieste o nuovi esperimenti. Grazie in anticipo :)

Il primo oneliner che prenderemo in considerazione consente di scaricare la
strip del giorno dal sito kevinandkell.com (ma non sara' molto diverso per
gli altri siti) recuperando la data odierna tramite il comando "date". Per
avere piu' informazioni su date, lanciate un "date --help" al prompt. Il
comando e' il seguente:

#============================================================================
wget http://www.kevinandkell.com/`date +"%Y"`/strips/kk`date +"%Y%m%d"`.gif 
#============================================================================

Notate come viene chiamato date entrambe le volte: esso e' racchiuso fra
backquote (in questo modo l'output del comando finisce a completare la
stringa dell'URL) e gli viene passato il parametro +"", all'interno del
quale viene specificato il formato della data desiderato. I codici usati per
specificare il formato sono i seguenti (presi pari pari dall'help):

  %Y   year (1970...)
  %m   month (01..12)
  %d   day of month (01..31)

Quindi, eseguendo questo comando ad esempio il 2 Aprile 2004 wget cercherebbe
di scaricare il file

http://www.kevinandkell.com/2004/strips/kk20040402.gif 

Una delle cose piu' belle di questo genere di comandi e' che, in un attimo, 
potete fare in modo che essi vengano eseguiti automaticamente ad ogni avvio
del vostro PC, oppure ogni giorno se il computer e' sempre acceso: avrete
cosi', sempre pronti sul vostro disco, tutti i file che desiderate. Se fra i
siti che decidete di controllare periodicamente ce ne sono alcuni che non
vengono aggiornati tutti i giorni, potete modificare il comportamento del
vostro script, eventualmente aggiungendo del codice per avvisarvi che in un
particolare giorno il download non e' stato eseguito:

#============================================================================
if [ `date +"%w"` -lt 6 ] && \ 
   [ $((`date +"%w"` % 2)) = 1 ]; 
then wget http://www.goats.com/comix/`date +"%y%m"`/goats`date +"%y%m%d"`.png; 
else echo no goats today; 
fi; 
#============================================================================

In questo script, il comando date con il parametro "%w" restituisce il giorno
della settimana (da 1 a 7). Se il giorno e' minore di 6 (cioe' non sabato o
domenica) oppure se e' dispari (quindi solo se e' lunedi', mercoledi' o
venerdi') allora l'immagine viene scaricata regolarmente; in caso contrario,
il programma avverte che oggi non ci sono immagini. Lo stesso giorno usato
per l'esempio precedente, cioe' il 2 Aprile 2004, il programma scaricherebbe
il file

http://www.goats.com/comix/0404/goats040402.png 


In entrambi gli esempi precedenti abbiamo usato wget nel modo piu' semplice
possibile, cioe' passandogli direttamente l'URL da scaricare. Esso, pero',
offre la possibilita' di eseguire autonomamente operazioni molto piu'
avanzate e, per darvene una prova, ecco il seguente esempio:

#============================================================================
wget -A mpg,mpeg,avi,asf -r -H -l 2 -nd -t 1 http://url.you.like 
#============================================================================

Qui wget e' utilizzato da solo, pero' con diversi switch. La loro descrizione
e' la seguente:

  -A comma-separated list of accepted extensions 
  -r recursive web-suck 
  -H go to foreign hosts when recursive 
  -l 2 maximum recursion depth = 2 
  -nd don't create directories 
  -t 1 set number of retries to 1 

Proviamo ad interpretare le singole descrizioni e ad unirle per comprendere
il funzionamento di questo comando: wget si collega alla pagina specificata,
segue ricorsivamente i link (-r) al massimo per una profondita' di 2 (-l 2),
uscendo eventualmente dal sito principale per collegarsi a server esterni 
(-H); quindi salva, all'interno della stessa directory (-nd), tutti i file
che hanno estensione mpg, mpeg, avi, asf. Ora, se pensate a quei siti pieni 
di link ad altri siti, a loro volta pieni di video gratuiti, capirete perche'
questo comando e' stato ribattezzato "wget-powered porn"!

Si parlava di collezioni di link: e se volessimo semplicemente estrarre tutti
i link da una pagina senza seguirli ma, eventualmente, per salvarli dentro a
un file di testo? Per questo possiamo usare lynx, insieme a qualche altro
tool:

#============================================================================
lynx -dump http://www.reteam.org/links.html \
    | sed 's/^ *[0-9]*\. [^h]*//' \
    | grep '^http'  
#============================================================================

Qui vengono utilizzati tre programmi, l'output di ognuno dei quali viene
passato come input al successivo:

- lynx scarica la pagina specificata e ne gira il dump a sed (tenete presente
  che il "dump" di lynx contiene, in fondo al testo, l'elenco di tutti i 
  link, http e non, presenti in una pagina)

- sed allinea a sinistra tutti i link di tipo http ed elimina tutti gli altri

- grep estrae solo le righe che cominciano con "http"

In questo modo, con una sola riga di comandi, abbiamo estratto tutti i link
presenti in una pagina, recuperando delle informazioni in piu' rispetto a
quelle che avevamo in precedenza e senza neanche il bisogno di aprire un
browser. Certo, lynx ci ha dato un aiuto non da poco, fornendoci una pagina
che presentava gia' l'elenco dei link, ma non sempre le cose sono cosi'
semplici: un'operazione piu' avanzata, ma non per questo particolarmente piu'
difficile da portare a termine, e' la seguente.

#============================================================================
lynx -nolist -dump 'http://www.reteam.org/board/viewforum.php?f=3' \
    | grep -2 "Browsing the web" \
    | tail -1 \
    | awk '{ print $1 }'  
#============================================================================

In questo caso i programmi usati sono quattro:

- lynx si collega all'indirizzo specificato, che e' quello di un forum, e
  scarica una pagina con l'elenco dei thread del forum

- grep estrae il thread che contiene le parole "Browsing the web" con un
  "contesto" di 2 righe (cioe' prende 2 righe prima e 2 righe dopo quella
  in cui trova la stringa "Browsing the web")

- tail recupera l'ultima riga del contesto, cioe' la seconda dopo il subject

- awk scrive la prima parola che trova all'interno di questa riga

Naturalmente, per creare una sequenza di programmi come questa non e'
sufficiente conoscerne il funzionamento, ma bisogna anche sapere come e'
strutturato il forum e come, all'interno del sorgente delle varie pagine Web,
vengono salvati i dati "statici" (cioe' quelli che non cambiano mai) e
"dinamici" (quelli, come il mittente di un messaggio o l'oggetto di un post,
che cambiano sempre). Come gia' anticipato, questa e' un'abilita' che si puo'
guadagnare solo con l'esperienza, quindi prima di darvi alcune linee guida
procedero' con un altro esempio, spiegato piu' in dettaglio: la battaglia
contro Flash!


4.4 Fight Against Flash
-----------------------------------------------------------------------------  

Perche' combattere contro Flash? Flash e' una buona tecnologia dal punto di
vista della comunicazione, permette di ottenere buoni effetti grafici senza
pesare troppo sui download ed e' compatibile almeno con i browser piu' 
diffusi.

In effetti, Flash non e' un problema, lo sono i suoi programmatori quando ne
abusano: se si tratta di costruire siti esclusivamente promozionali, fatti al
100% in flash, posso anche capire che crearne una versione esclusivamente in 
modalita' testo non abbia senso; quando, pero', all'interno di un sito 
informativo compare un inutile menu in flash, senza codice alternativo per
supportare i browser meno diffusi, allora questo diventa un problema. E se
per fortuna ultimamente la moda dei menu in flash sta leggermente calando,
basta cercare su google file tipo "menu.swf", "leftmenu.swf" o "navmenu.swf"
per capire quanto ancora siano diffusi.

E' un problema per diversi motivi: innanzitutto, fatta eccezione per il menu
in flash il resto del sito potrebbe anche interessarmi, quindi non e' mia
intenzione spegnere il computer e lasciar perdere; inoltre, a causa del
famigerato menu non solo i browser testuali come lynx non possono accedere
ai contenuti del sito, ma anche i dispositivi speciali come ad esempio le
barre braille. E, se nel mio caso basterebbe piegarmi ad utilizzare un altro
browser, c'e' chi questa scelta non ce l'ha e allora i contenuti del sito gli
sono completamente preclusi. Questo e' il motivo per cui, secondo me, e' bene
combattere contro flash ora e, piu' in generale, contro tutto quello che 
limitera' in qualche modo l'utilizzo di internet in futuro. 

In realta', la mia tecnica combattiva non e' particolarmente aggressiva: ho
semplicemente cercato di capire il funzionamento dei file flash e di estrarre
da essi piu' informazioni possibili, nel tentativo di ricostruire i contenuti
dei menu incriminati. Per fare questo ho utilizzato tre approcci, in ordine
di difficolta' -e di efficacia- crescente. Ancora non ho trovato una 
soluzione universale, ma son sicuro che lavorando su questi esempi saprete
fare di meglio ;)

Il modo piu' semplice per estrarre informazioni da un file swf e' quello di
visualizzarne le stringhe con il comando "strings". Supponendo che il file su
cui stiamo lavorando sia un menu, quello che ci interessa maggiormente sono i
link ai contenuti: possiamo allora passare in ingresso a strings il file swf
e redirigerne l'output al comando grep, che estrarra' solo le stringhe 
contententi "http":

lynx -source http://www.reteam.org/top.swf | strings | grep http  

Questo primo approccio fornisce gia' qualche risultato e con alcuni menu 
funziona perfettamente, tuttavia tralascia diversi altri tipi di link. Ad
esempio, nei siti che contengono anche link gestiti da codice javascript e'
necessario modificare la stringa passata a grep:

lynx -source http://www.mypetskeleton.com/mpsmain.swf | strings | grep http

lynx -source http://www.mypetskeleton.com/mpsmain.swf | strings \
| grep javascript  

Lavorando sulle stringhe e' possibile reperire diverse altre informazioni,
ma ancora il problema dei link non e' risolto: infatti, questo approccio va
un po' alla cieca, cercando nel mucchio se trova qualcosa di interessante ma
senza la certezza che sia effettivamente cio' che desideriamo. Per ovviare al
problema ho dato un'occhiata a diversi swf, cercando di capire in che formato
venissero salvati i collegamenti al loro interno: in tutti i flash che ho
esaminato, ogni link era rappresentato dalla sequenza di byte

0x00 0x83 0xLEN 0x00 "string" 0x00 

dove LEN e' la lunghezza della stringa, e 0x il prefisso usato per indicare
che tutti i valori son salvati in esadecimale.

A questo punto, e' stato un attimo creare un piccolo script in perl che mi
estraesse da un file tutti i link, utilizzando una regular expression. Se non
sapete cosa sia una regular expression, correte a studiare! In caso contrario
eccovi il sorgente dello script:

<-| powerb/flash.pl |->
#============================================================================
#!/usr/bin/perl 
 
undef $/; # enable slurp mode 
$_ = <>; 
 
# SYNTAX IS: 0x00 0x83 0xlen 0x00 "string" 0x00 
while (/\x00\x83.\x00(.*?)\x00/gs){ 
        print "$1\n"; 
}  
#============================================================================
<-X->

Si', e' gia' finito (capito perche' dovete studiarvi le regexp?). In realta',
non e' altro che un ciclo che dice "finche' trovi sequenze di byte come
quella descritta in precedenza, estrai la parte "string" e visualizzala".
L'utilizzo, supponendo sempre che il file swf sia da qualche parte nel Web,
e' il seguente:

lynx -dump http://web.site.url/menuname.swf | perl flash.pl 

Ad esempio:

lynx -dump http://www.reteam.org/top.swf | perl flash.pl 

Grazie allo script che abbiamo costruito siamo ora in grado di ricostruire
l'elenco completo dei collegamenti presenti nel menu, tuttavia non possiamo
recuperare il testo presente sui pulsanti, anche perche' talvolta esso viene
sostituito da delle immagini. Come possiamo, allora, sapere in anticipo dove
ci porteranno i link che abbiamo estratto?

Lo script che segue e' un estrattore di link _con prospezione_: esso segue
per conto nostro i collegamenti che ha trovato nel file Flash, estraendo (se
lo trova) il titolo delle pagine Web che visita e utilizzandolo per ricreare
un menu in HTML.

-- Flash Lookahead Link Extractor
<-| powerb/flash2.pl |->
#============================================================================
#!/usr/bin/perl 
 
use LWP::Simple; # used to get linked pages 
use URI::URL;    # used to absolutize URLs 
 
sub rel2abs { 
        my ($rel,$base) = @_; 
        my $uri = URI->new_abs($rel, $base); 
        return $uri->as_string; 
} 
 
$url   = $ARGV[0]; 
$flash = get($url) || die "Couldn't download $ARGV[0]"; 

# SYNTAX IS: 0x00 0x83 0xlen 0x00 "string" 0x00 
while ($flash =~ /\x00\x83.\x00(.*?)\x00/gs){ 
  my $nextitle; 
  my $link = rel2abs ($1,$url); 
  my $nextpage = get ($link); 
  if ($nextpage =~ /<title>(.*?)<\/title>/i){ 
    $nextitle = $1; 
  }else{ 
    $nextitle = $link; 
  } 
  print qq|<a href="$link">$nextitle</a><br>\n|; 
}  
#============================================================================
<-X->

Questo sorgente e' un po' piu' complicato del precedente, ma vi assicuro che
non c'e' da sapere molto di piu' per comprenderne il funzionamento: intanto,
l'utilizzo dello script da shell e' il seguente

perl flash2.pl http://url.you.like/menu.swf 

Notate che in questo caso fornite l'URL direttamente allo script anziche' 
passare da lynx: in questo modo, il programma sara' in grado di utilizzare
l'URL base per rendere assoluti i link che trovera' all'interno del file
flash, in caso questi siano relativi. Quest'operazione e' svolta dalla sub
rel2abs, che a sua volta utilizza un comando gia' pronto e contenuto nella
libreria URI::URL. L'altro package utilizzato e' LWP::Simple, che avrete
occasione di vedere piu' in dettaglio in seguito: per ora, vi basti sapere
che esso vi mette a disposizione il comodissimo comando "get", a cui e'
sufficiente passare un URL per avere il sorgente HTML della corrispondente 
pagina Web. All'interno dello script, tale codice sorgente viene salvato 
nella variabile $nextpage, sulla quale viene applicata la regular expression 
che estrae il titolo della pagina qualora esso esista.


=============================================================================
5. Bot Basics
-----------------------------------------------------------------------------

Durante la nostra guerra a Flash abbiamo visto il primo esempio di robot (o
piu' semplicemente bot) scritto in Perl: esso naviga per conto nostro dentro
a un sito, seguendo i link estratti da un menu in flash, e ricostruisce lo
stesso menu in HTML, associando ad ogni link il titolo della corrispondente
pagina Web.

Ma cosa identifica un bot e cosa dev'essere in grado di fare uno di questi
programmi? A prescindere da cenni storici o definizioni rigorose, un bot che
si rispetti deve perlomeno essere in grado di mettere a disposizione degli
utenti le funzioni tipiche degli spider e degli scraper: esso deve, cioe',
essere in grado di muoversi all'interno di un sito (seguendo i collegamenti
da una pagina all'altra, riempiendo form, autenticandosi e cosi' via) e di
scaricare intere pagine Web o parte di esse, estraendo le informazioni piu'
importanti e tralasciando tutto cio' che non interessa all'utente.

Naturalmente un bot non e' in grado, da solo, di riconoscere "cio' che e'
interessante", ne' sa prediligere alcuni link rispetto ad altri. Il robot in
generale e' una macchina all'interno della quale l'uomo e' in grado di fare
cio' che desidera: quindi, anche in questo caso, e' necessario innazitutto un
intervento umano, per sondare i siti a cui il robot dev'essere in grado di
collegarsi e per decidere cosa esso dovra' considerare degno di nota e cosa 
invece dovra' ignorare.


5.1 Detecting Web Patterns
-----------------------------------------------------------------------------

L'intervento umano nella fase di creazione di un bot e' fondamentale: la
macchina, infatti, non ha modo di lavorare direttamente sulla realta', ma 
opera solo su un modello che l'uomo crea in base a un'interpretazione 
personale di questa realta'. Ad esempio, mentre noi siamo in grado di 
riconoscere, fra i messaggi di un forum, l'oggetto di un messaggio (quindi 
percepiamo la _semantica_ della pagina, indipendentemente da come essa e' 
codificata), un bot puo' solamente capire che l'oggetto e' compreso fra 
alcune parti di codice HTML (quindi esso lavora a livello _sintattico_, 
strettamente dipendente dalla codifica della pagina). 

Naturalmente, tutto il lavoro che si sta facendo con il Web semantico serve 
proprio a rendere accessibile il Web tanto alle macchine quanto agli uomini,
e anche l'impiego dell'intelligenza artificiale nel campo dei wrapper puo'
portare a risultati discreti... ma questa e' un'altra storia: per ora, tenete
presente che, ancora per un po' di tempo, buona parte del lavoro la dovrete 
fare comunque voi.

Cosa sono i Web Patterns di cui si parla nel titolo? Essi non sono altro che
particolari schemi, individuabili all'interno dei contenuti di una o piu'
pagine Web, piuttosto che nei percorsi che siamo soliti seguire quando,
cliccando da un link all'altro, ci muoviamo all'interno di un sito. Essi sono
esattamente cio' che ci serve comprendere per poter istruire un bot a fare 
cio' che noi facciamo abitualmente, cioe' 

1) visitare un sito e
2) estrarre informazioni da esso

Nel primo caso, la domanda che ci dobbiamo porre e': si puo' trovare un modo
per far seguire automaticamente dei collegamenti a un programma? Certamente
si', lo dimostrano tutti i software in grado di eseguire il mirroring di un
sito Web. Ma e' anche possibile far SCEGLIERE alcuni collegamenti a un bot, 
e se si' quali?

In alcuni casi la risposta e' semplice: nel caso, descritto in precedenza, 
del "wget-powered porn" avevamo chiesto di seguire qualsiasi link e di 
salvare tutti i video a una distanza massima di due collegamenti. Questo
perche' sapevamo che la struttura dei siti su cui desideravamo usare wget era
la seguente:


         Sito contentente      1    Sito contenente     2     File
        link ad altri siti --------> link a video   --------> Video


In altri casi, la risposta e' piu' complessa: potremmo, ad esempio, trovarci
a voler scaricare tutte le immagini da una galleria dove ogni thumbnail ha 
un link all'immagine, e dove in fondo alla pagina c'e' un link alla pagina
successiva, il tutto senza sapere a priori quante pagine dobbiamo visitare.
In questo caso, dovremo dire al bot di collezionare tutti e soli i file che
corrispondono alle immagini desiderate, e di seguire i link che portano alla
pagina successiva finche' ne trovano, o finche' non trovano un particolare
terminatore (ad esempio, il link alla prima pagina del gruppo).

E se invece volessimo salvare tutti i messaggi di un forum? In questo caso,
avremmo molto probabilmente una situazione simile a quella della gallery,
ma con una gerarchia piu' profonda (Forum->Thread->Messaggi) e senza la
possibilita' di distinguere le informazioni che desideriamo in base a una
estensione. 

Come potete capire da questi esempi, essere in grado di riconoscere i pattern
navigazionali (cioe' i particolari schemi di navigazione all'interno di un
sito) puo' aiutare drasticamente nella progettazione di un bot. Naturalmente, 
come nel caso delle tecniche avanzate di PowerBrowsing, anche qui una certa 
esperienza e' indispensabile. Pur essendo implementati diversamente da un 
sito all'altro, i pattern navigazionali restano piu' o meno sempre gli 
stessi: questo significa che, col tempo, il lavoro in carico a voi sara' 
sempre piu' facile da portare a termine.

Come accennato in precedenza, oltre ai pattern relativi alla navigazione
esistono degli schemi ricorrenti anche a livello dei contenuti delle pagine 
Web, all'interno di uno stesso sito o anche fra siti diversi. Essere in grado
di individuare questi pattern vi permette di istruire il vostro bot ad 
estrarre da ogni pagina solo le informazioni che sono veramente interessanti.

Ad esempio, della generica pagina HTML di un forum (quella, cioe', contenente
il messaggio) vorremo probabilmente conservare solo il mittente, l'oggetto,
la data e il contenuto del messaggio. Nella pagina completa, invece, sono
solitamente presenti immagini, banner, codice HTML per la generazione delle
tabelle e cosi' via, fino a raggiungere una quantita' di dati anche 100 volte
superiore. Se, pero', prima e dopo le parti del messaggio che ci interessano
ricorre sempre lo stesso codice HTML, allora possiamo creare dei wrapper in
grado di riconoscere ed estrarre i vari elementi in base alle stringhe di 
codice a loro associate.

Se, nei vecchi siti fatti completamente a mano, si poteva supporre -ma non 
dare per certa- una certa ripetitivita' all'interno del codice HTML, nei siti
dinamici che ci troviamo ora a visitare tutto il codice fisso e' SICURAMENTE
sempre identico a se stesso, in quanto generato da una macchina. Questo ci
aiuta tantissimo in fase di creazione dei wrapper, in quanto ci basta vedere
il codice HTML di una generica pagina (ad esempio, di un messaggio in un
forum) per individuare le parti che non variano mai.

Come accennato in precedenza, grazie al diffondersi degli standard ora 
possiamo individuare pattern costanti anche fra un sito e un altro: basti
pensare alle news, disponibili in formato RSS, oppure a diversi BLOG che
mettono addirittura a disposizione un'API, o ancora a software come quelli
dei forum che, pur essendo scritti in linguaggi differenti, mantengono spesso
la medesima struttura e a volte generano codice HTML quasi identico.

Terminato il nostro compito di identificazione dei pattern, dobbiamo istruire
il nostro bot a riprodurli (nel caso della navigazione) o a rilevarli (nel
caso dei wrapper). Nelle prossime due sezioni avrete modo di leggere alcune
considerazioni, ancora indipendenti dal linguaggio di programmazione, che
forse potranno aiutarvi a progettare i vostri bot.


5.2 Website navigation with bots
-----------------------------------------------------------------------------

Per quanto riguarda la navigazione, queste sono le operazioni che un bot 
dovrebbe essere in grado di portare a termine senza difficolta':

- dato un URL, scaricare la pagina Web corrispondente (l'operazione, come 
  potrete vedere nel prossimo capitolo, e' banale, specialmente in Perl)

- estrarre da una pagina i collegamenti desiderati, in base a particolari 
  condizioni all'interno dell'URL: ad esempio, il nome del file deve finire 
  con .gif, oppure tutti i file devono appartenere alla directory /textfiles/
  o ancora essere tutti generati dallo script viewthread.php?f=1&thread=...
  Quest'operazione puo' essere portata a termine in modo semplice tramite
  delle regular expression

- estrarre da una pagina i collegamenti desiderati, in base a particolari
  condizioni all'interno del testo taggato: ad esempio, si sceglieranno solo
  i link visualizzati come "Next", oppure quelli che iniziano con "Document".
  Anche in questo caso, le regular expression aiutano nella fase di verifica

- seguire i collegamenti estratti fino a un certo livello di profondita': ad
  esempio, seguire tutti i link presenti in un lungo elenco e dai siti 
  visitati scaricare tutte le immagini

- seguire i collegamenti estratti all'infinito, o fino a una particolare
  condizione: ad esempio, continuare a "cliccare su Next" finche' tale link
  e' presente

- raccogliere i collegamenti estratti per poterli usare in un secondo tempo,
  dall'ultima pagina visitata oppure da tutte quelle attraverso cui si e'
  passati: ad esempio, si deve poter seguire i link per tre livelli di
  profondita' e poi collezionare tutti i collegamenti a immagini, oppure
  seguire tutti i link a "Next" in un forum e, per OGNI pagina incontrata,
  collezionare tutti i collegamenti a messaggi

Se mai deciderete di programmare bot in Perl, tenete presente che buona
parte di questo lavoro e' gia' stata fatta dal sottoscritto: nel capitolo
dedicato agli esempi, troverete la descrizione (e il link al sorgente) di un
package, chiamato "common", che contiene proprio delle funzioni in grado di
portare a termine le operazioni descritte.


5.3 Data extraction
-----------------------------------------------------------------------------

Per quanto riguarda l'estrazione dei dati, il sistema che in assoluto ho
trovato piu' comodo e' quello che fa uso delle Regular Expression. In realta'
ne esistono altri, che si appoggiano a XPath o a librerie specializzate nel
parsing dei testi. Nel prossimo capitolo faro' un accenno a tali librerie, ma
non ne parlero' in dettaglio: se lo desiderate, potete trovare informazioni a
proposito su Spidering Hacks... o in giro sul Web.

Le regexp consentono di "tagliare" il testo spezzettandolo in varie porzioni:
con una RE del tipo

  /<condizioni iniziali>.*?<condizioni finali>/gsi

dove 

  - le condizioni iniziali e finali sono codice HTML che circonda cio' che ci
    interessa

  - .*? e' una regular expression che matcha (cioe' viene soddisfatta da) la
    piu' piccola porzione di testo compresa fra le due condizioni

  - i "modificatori" gsi consentono di effettuare una ricerca iterata (g),
    case-insensitive (i) e trattando tutto il testo come una riga singola (s)

possiamo

  - dividere un testo in blocchi, ad esempio un thread nei messaggi che lo
    costituiscono oppure un lungo elenco di generici elementi nei singoli
    elementi che lo costituiscono (wrapper HEAD-TAIL)

  - estrarre da una riga una o piu' stringhe di testo (wrapper LEFT-RIGHT)


Poiche' i siti Web sono spesso soggetti a cambiamenti (per fortuna, quelli
generati in automatico da dei programmi lo sono un po' di meno), e' buona
norma creare i vostri Wrapper in modo parametrico: essi, cioe', devono essere
in grado di estrarre del testo in base a delle stringhe, che voi gli passate
di volta in volta, contenenti le regular expression da utilizzare. Quando il
sito cambiera', vi sara' sufficiente modificare la regexp per far funzionare
nuovamente il vostro bot (vedete, fra gli esempi del capitolo 8, quello 
relativo ai cinema).


=============================================================================
6. Perl PowerBrowsing Tools
-----------------------------------------------------------------------------

All'interno di questo capitolo parleremo di strumenti per il PowerBrowsing
scritti in Perl. Piu' precisamente, avrete la possibilita' di imparare a
creare dei bot che si collegano per conto vostro a dei siti Web, scaricando
i file che desiderate ed estraendo da questi le informazioni che vi sembrano
piu' interessanti; il tutto gestendo automaticamente tutte le procedure
collaterali quali l'identificazione col server, l'autenticazione, la gestione
dei cookie e dei referrer. 

La prima sezione del capitolo spiega la scelta di Perl come linguaggio di
programmazione per i bot. Nelle successive, avrete la possibilita' di vedere 
uno scorcio delle librerie dedicate al Web che Perl ci mette a disposizione, 
quindi un'analisi un po' piu' dettagliata dei principali oggetti e metodi da
utilizzare per creare i vostri bot.


6.1. Perche' Perl? 
-----------------------------------------------------------------------------

Perche' usare Perl per creare dei bot? In realta' il potere espressivo di
molti linguaggi di programmazione ormai e' quasi equivalente, ma sicuramente
ognuno di essi si distingue ancora dagli altri per alcune sfumature, piu' o
meno rilevanti a seconda della particolare applicazione che si desidera
sviluppare.

E' proprio una di queste sfumature, insieme alla passione che personalmente
nutro per questo linguaggio, che mi ha portato a decidere di usare proprio
Perl: la potentissima gestione dei testi tramite regular expression, infatti,
ci permette di creare in pochi minuti dei wrapper che, in altri linguaggi,
sarebbero stati probabilmente piu' complicati da programmare.

A questo dobbiamo aggiungere la grandissima disponibilita' di librerie pronte
all'uso, che ci aiuta (come vedremo in seguito) a trasformare i nostri 
semplici bot che recuperano dati in programmi che _condividono_ informazioni
attraverso i formati piu' diffusi. Inoltre, alcune di queste librerie (come
ad esempio la stessa LWP::Simple, che useremo per i primi bot) sono cosi' 
facili da usare che chiunque sara' in grado di programmare con esse.

Infine, dobbiamo aggiungere altre due caratteristiche notevoli: prima di 
tutto la portabilita', indispensabile per poter permettere a tutti di fare
esperimenti indipendentemente dal sistema operativo usato, quindi la presenza
di letteratura al riguardo (e devo dire che "Spidering Hacks", in questo 
caso, e' stato determinante).

Naturalmente, tutto quello che e' servito a me per motivare la decisione di
utilizzare Perl non vieta a voi di utilizzare un altro linguaggio. Anzi, mi
piacerebbe vedere altre implementazioni di bot e verificare se esse siano
piu' o meno semplici o potenti di quelle che descrivero' in seguito.


6.2. Perl Packages 
-----------------------------------------------------------------------------

Perl mette a disposizione diverse librerie per l'accesso al Web e per la
gestione dei principali oggetti con cui i vostri bot avranno a che fare. 
Anche se di queste librerie avrete occasione di usare frequentemente solo un
paio (LWP::Simple e LWP::UserAgent), eccovi una breve descrizione delle altre
piu' comunemente usate:

LWP
    Conosciuta anche come libwww-perl, e' un gruppo di moduli per l'accesso
    al Web

LWP::Simple
    E' la libreria piu' semplice che potete utilizzare per scaricare pagine
    dal Web: fra le funzioni che mette a disposizione, c'e' la classica "get"
    (che avete gia' visto nella sezione 4.4), la "getprint", che visualizza
    automaticamente a schermo cio' che scarica e la "getstore" che, invece,
    salva automaticamente i documenti scaricati

LWP::UserAgent
    E' una libreria piu' avanzata per l'accesso al Web (la vedremo piu' in
    dettaglio in seguito)

HTTP::Request
HTTP::Response 
    Sono oggetti utilizzati per gestire piu' in dettaglio le richieste da
    inviare al server e le risposte che provengono da esso
    
HTTP::Message
HTTP::Headers 
    Sono classi che offrono metodi aggiuntivi ad HTTP::Response

URI
    E' una classe che mette a disposizione metodi per operare sugli indirizzi
    Web, ad esempio per rendere assoluto un URL relativo o per estrarre da un
    link il nome di dominio o gli elementi del path

URI::Escape 
HTML::Entities
    Offono funzioni per l'escaping e l'unescaping, rispettivamente, degli URL
    e del testo estratto da un documento HTML, consentendo la gestione di
    caratteri non standard quali spazi negli URL o lettere accentate nel
    codice HTML

HTML::TokeParser, HTML::TreeBuilder, WWW::Mechanize 
    Le prime due classi sono specializzate nel lavoro di parsing dell'HTML e
    offrono metodi alternativi alle regular expression per l'estrazione di
    informazioni dai documenti; l'ultima classe consente di automatizzare
    l'interazione coi siti Web, riempiendo form, seguendo link e cosi' via.
    Tutte e tre assieme possono contribuire a semplificare e a rendere piu'
    robusti i vostri bot, tuttavia non vengono (per ora) trattate all'interno
    di questo testo.


6.3. LWP::Simple
-----------------------------------------------------------------------------

LWP::Simple e' la piu' semplice libreria che potete utilizzare per collegarvi
al Web tramite Perl. Essa infatti mette a disposizione il comando "get", che
scarica la pagina presente all'URL specificato e ne restituisce il contenuto,
pronto per essere salvato in una variabile. La sintassi e', appunto,

$contenuto = get ($URL);

Al contenuto potete applicare una regular expression, per verificare alcune
condizioni: ad esempio, il prossimo script e' in grado, in poche righe, di
dirvi se nel momento in cui lo eseguite c'e' uno stream di Radio Bandita 
online.

<-| powerb/lwpsimple.pl |->
#============================================================================
use LWP::Simple;                         # questa e' la libreria da usare

my $url = 'http://radio.autistici.org/'; # questo e' l'url che controlleremo

# scarica $url e salva il contenuto in $content 
my $content = get($url); 

# se si verifica un errore esci
die "Non son riuscito a scaricare $url" unless defined $content; 

# ora cerca all'interno del contenuto
if ($content =~ m/bandita/i) { 
    print "Radio Bandita sta strimmando!\n"; 
} else {  
    print "Non c'e' buona musica online.\n";  
} 
#============================================================================
<-X->

LWP::Simple mette a disposizione anche altre funzioni, come ad esempio 
"getprint" e "getstore", il cui utilizzo e' pero' piu' specifico e meno
frequente rispetto alla semplice get. Tuttavia, la getprint in particolare
puo' tornare utile per gli oneliners, in caso non si abbia a disposizione 
lynx: infatti, il comando

  perl -MLWP::Simple -e 'getprint "http://3564020356.org";'

e' equivalente a

  lynx -source http://3564020356.org


6.4. LWP::UserAgent
-----------------------------------------------------------------------------

LWP::UserAgent e', naturalmente, una libreria decisamente piu' complessa 
rispetto a LWP::Simple, ma offre anche numerose funzioni aggiuntive a volte
indispensabili per un bot che si rispetti. Grazie ad essa, infatti, potrete
identificare il vostro UserAgent con il server, aggiungere il campo "Referer"
fra gli header della richiesta, eseguire il POST dei dati di un form, gestire
i cookie e connettervi tramite un proxy.

-- LWP::UserAgent - 01 - Basics
<-| powerb/lwpuseragent.pl |->
#============================================================================
#!/usr/bin/perl -w 
use LWP 5.64; # usa LWP e verifica che la versione sia abbastanza recente

my $url = 'http://radio.autistici.org/'; 

# crea un nuovo useragent 
my $ua = LWP::UserAgent->new; 

# esegui la GET dell'URL specificato
my $response = $ua->get($url); 

# se si verifica un errore esci 
#(notare la gestione piu' accurata degli errori)
die "Non riesco a scaricare $url: ", $response->status_line 
    unless $response->is_success; 

# ora cerca all'interno del contenuto
if ($response->content =~ m/bandita/i) { 
    print "Radio Bandita sta strimmando!\n"; 
} else {  
    print "Non c'e' buona musica online.\n";  
} 
#============================================================================
<-X->

Quello che avete appena visto e' il piu' semplice esempio di programma che 
potete scrivere usando LWP::UserAgent. Esso e' un'evoluzione del precedente
script creato con LWP::Simple: non e' molto piu' complessa dell'originale, ma
gia' vediamo un'organizzazione piu' avanzata: innanzitutto, viene creato un
oggetto di tipo UserAgent che gestira' d'ora in poi le comunicazioni con il
server; poi, viene richiesto all'UA di eseguire una GET dell'url specificato
e di salvarne il risultato nella variabile $response; tale variabile non
contiene piu' il solo contenuto della pagina HTML, ma e' un vero e proprio
oggetto in grado di dire se l'operazione e' andata a buon fine o no (tramite 
il metodo is_success) e di fornire il contenuto della pagina (content) oppure
l'eventuale codice di errore (status_line). 

Lo stesso comando get, usato nella sua versione piu' semplice, vi permette di
specificare altri parametri: ad esempio, potete aggiungere degli header
personalizzati, contenenti la stringa di identificazione del vostro User
Agent, i tipi di file che accettate, il set di caratteri e il linguaggio che
preferite. Per fare cio', e' sufficiente salvare questi dati all'interno di
un array e passarlo come secondo parametro al metodo get:

-- LWP::UserAgent - 02 - Identify your bot
#============================================================================
my @ns_headers = ( 
    'User-Agent' => 'MaLaBot 1.0', 
    'Accept' => 'image/gif, image/x-xbitmap, image/jpeg, 
                 image/pjpeg, image/png,  */*', 
    'Accept-Charset' => 'iso-8859-1,*', 
    'Accept-Language' => 'en-US', 
); 
 
$response = $browser->get($url, @ns_headers); 
#============================================================================

Puo' capitare che alcuni siti si rifiutino di ricevere dei dati da voi, a
meno che questi non provengano da particolari URL: per effettuare questo
controllo i server verificano il vostro referer, quindi puo' tornarvi utile
sapere come modificarlo a mano. Per fare cio', dovete lavorare sull'oggetto
"request", creandolo in base al tipo di richiesta (GET o POST) che desiderate
fare, quindi aggiungendo il referer tramite l'omonimo metodo. L'esempio che
segue vi mostra le operazioni da compiere, nel caso di una POST a un form (in
questo caso, $POST_URL e $REFERER_URL sono delle variabili che contengono, 
rispettivamente, l'URL a cui intendete inviare la richiesta e l'indirizzo da
cui avete deciso di provenire).

-- LWP::UserAgent - 03 - custom referers
#============================================================================
# create request object, passing method 
my $req = HTTP::Request->new(POST => "$POST_URL"); 
    # this is used for post 
    $req->content_type('application/x-www-form-urlencoded'); 
    # line to post 
    $req->content("lang=it&descrizione=$letters&numero=&CheckExt=N"); 
    # referer URL 
    $req->referer("$REFERER_URL"); 
 
my $res = $ua->request($req); 
#============================================================================

Nell'esempio precedente avete visto come POSTare i dati di un form. In
particolare, abbiamo usato una stringa (quella specificata dal metodo 
"content" dell'oggetto "Request") di elementi concatenati l'uno con l'altro. 
Esiste tuttavia un altro metodo, che consiste nel passare al metodo "post"
dell'oggetto "UserAgent", insieme all'URL di destinazione, un hash (un array 
contenente le coppie chiave/valore) dei parametri da inviare.

-- LWP::UserAgent - 04 - post form data
#============================================================================
my $ua = LWP::UserAgent->new; 

my $url = 'http://url.of.the.form/path/form.php'; 
 
my $response = $ua->post( $url, 
    [ 'param1' => $value1,
      'param2' => $value2,
      'param3' => $value3,
      'param4' => $value4,
    ] 
); 
#============================================================================

Ricordate (ci ho sbattuto la testa per un po' prima di scoprirlo) che spesso
in seguito a una POST potreste venire redirezionati a un'altra pagina.
Affinche' il vostro UA vi restituisca la pagina a cui siete interessati (e
non quella che contiene semplicemente la redirect alla pagina che vi 
aspettate) e' necessario che, prima della richiesta, inseriate la seguente
linea di codice

  push @{ $ua->requests_redirectable }, 'POST'; 

che non fa altro che dire allo user agent che anche le POST sono delle
richieste per le quali e' necessario seguire automaticamente i redirect.

Per la vostra autenticazione all'interno di alcuni siti (o anche solo per il
semplice accesso ad altri) e' talvolta necessario che il vostro UserAgent sia
in grado di gestire i cookie. Niente di piu' semplice: potete usare uno dei
due seguenti metodi per abilitare l'UA all'utilizzo dei cookie.

-- LWP::UserAgent - 05 - use cookies
#============================================================================
use HTTP::Cookies; 

$ua->cookie_jar( HTTP::Cookies->new( # or HTTP::Cookies::Netscape 
    'file' => '/some/where/cookies.lwp',  # where to read/write cookies 
    'autosave' => 1,                      # save it to disk when done 
)); 
#----------------------------------------------------------------------------
$kj = new HTTP::Cookies; 
$kj->load("cookies.txt"); 
$ua->cookie_jar($kj); # activate cookie jar for the useragent 
#============================================================================

Ultimo, ma non per ordine di importanza (se state lavorando in un ufficio e
state dietro a un proxy, queste righe saranno per voi fondamentali), l'UA
creato con LWP::UserAgent e' in grado di connettersi attraverso dei proxy. Si
puo' usare il proxy impostato come variabile d'ambiente (env_proxy), in modo
da non doverlo riconfigurare, oppure impostarne uno a mano, scegliendo anche
il protocollo per cui lo si desidera utilizzare.

-- LWP::UserAgent - 06 - connect through a proxy
#============================================================================
$ua->env_proxy; 
#----------------------------------------------------------------------------
$ua->proxy(['http', 'ftp'], 'http://proxy.sn.no:8001/'); 
#============================================================================

E' tutto, per ora: questi esempi non sono certamente completi, ne' pretendono
di chiarire tutti i dubbi che vi potranno venire quando deciderete di creare
il vostro primo bot. Credo pero' che essi possano semplificarvi un po' la
vita, almeno all'inizio, e son sicuro che lavorandoci un po' su (e, perche'
no, collaborando con qualcun altro, se non con il sottoscritto) potrete
ottenere dei risultati piu' che soddisfacenti.


=============================================================================  
7. Condividete i vostri dati
-----------------------------------------------------------------------------  

Ora che sapete creare dei bot che vanno in giro a recuperare informazioni per
conto vostro, la cosa piu' bella che potreste fare e' trovare un modo per
condividere queste informazioni con altre persone. Naturalmente, questa e'
una scelta che ognuno di voi dovrebbe fare spontaneamente, insieme anche alle
modalita' con cui decidete di effettuare questa condivisione (dal floppy disk
alla telepatia tutto e' concesso!).

In questa sezione vorrei piu' che altro offrire degli spunti per chi desidera
condividere quello che e' riuscito a raccogliere coi propri bot ma non ha
ancora idea di come farlo. 


7.1 Il Web e RSS
-----------------------------------------------------------------------------

L'esempio minimale di condivisione che mi viene solitamente in mente e' lo
schermo del mio computer in modalita' testo, immagine che riesco a replicare
abbastanza fedelmente creando pagine web i cui contenuti sono racchiusi fra
le tag <PRE> e </PRE>.

Senza esagerare fino a questo punto, potete comunque creare dei siti Web 
leggeri, magari generati dinamicamente con PHP, esponendo cosi' le vostre
informazioni senza pero' perdere in usabilita': un piccolo motore di ricerca
e dei link per passare da una sezione all'altra dei vostri dati richiedono
relativamente poco tempo per l'implementazione, ma aggiungono molto alla
fruibilita' dei dati che mettete a disposizione.

Alternativamente, potete utilizzare il package Perl XML::RSS per pubblicare
i vostri contenuti in RSS: l'operazione e' assolutamente banale per voi e ha 
il vantaggio per l'utente di poter scegliere il client con cui visualizzarli.


7.2 La mail
-----------------------------------------------------------------------------

Parlando di poter scegliere il client, non puo' non venirmi in mente il caro,
vecchio, comodo e strautilizzato client di posta elettronica: se si potesse
consumare, il mio ormai non esisterebbe praticamente piu'! E' diventato ormai
per me cosi' comodo da usare che, anche se non e' piu' supportato da anni, 
continuo a utilizzarlo. Essendo un programma per Windows, e' uno dei pochi
motivi per cui ancora faccio macchine con il dual boot.

Insomma, se anche gli altri utenti si trovano comodi quanto me con i loro
client di posta elettronica, perche' non riproporre loro i dati tramite mail?
Ricordo alcuni servizi (ora ce ne sono sempre meno, ma ce n'e' ancora) che
permettevano di vedere pagine Web via mail; altri visitavano regolarmente un 
sito per verificare se c'erano degli aggiornamenti e in caso mandavano un 
messaggio agli utenti iscritti per avvisarli; io ho creato uno script perl 
che, chiamato da procmail quando riceve un messaggio con un particolare 
subject, invia un messaggio di posta con l'elenco di tutti i film attualmente
in proiezione nella mia citta'.

Ci sono diversi modi per comunicare dati via mail: uno, forse piu' complesso
se non si ha un server a disposizone, e' quello di usare procmail per 
filtrare i messaggi in arrivo e rispondere automaticamente in base alla
presenza di particolari stringhe nel subject o nel corpo del messaggio; un
altro metodo, invece, e' quello di creare un server POP3 virtuale come quello
descritto nella sezione 3.3.  


7.3 Il package Net::Blogger
-----------------------------------------------------------------------------  

Fra le varie possibilita' di pubblicazione che avete a disposizione, una 
delle piu' semplici e versatili e' quella di utilizzare un blog. Semplice
perche' si tratta di utilizzare una libreria gia' pronta, che utilizza le API
usate dai blog piu' diffusi; versatile perche' nel momento in cui pubblicate
dati su un blog li mettete a disposizione in HTML ma anche in RSS, li avete
salvati in un DB all'interno del quale potete fare delle ricerche e molto
probabilmente non avete neanche bisogno di un server vostro per conservarli.
Infine, e non e' una cosa da poco, potrete utilizzare queste applicazioni 
sataniche per uno scopo finalmente UTILE!

Non mi dilunghero' in spiegazioni a proposito di questa libreria: potete
trovare la documentazione online e il codice sorgente si commenta da se'.
Tenete presente che la parte dedicata alla pubblicazione e' contenuta tutta
nelle ultime venti righe, mentre le precedenti sono dedicate prima alla
dichiarazione delle variabili, quindi al codice dello scraper (che, in questo
caso, e' lo stesso dell'esempio "Things I've learned from B-Movies"). Se
modificate le prime righe dello script, inserendo l'URL dell'API del vostro
blog, il suo nome, la vostra login e la password, avrete in pochi secondi il
vostro primo Bloggerbot funzionante.

<-| powerb/bloggerbot.pl |->
#============================================================================
#!/usr/bin/perl

use Net::Blogger; # this is used to post articles 
use common;       # this is used for LWP related functions (getpage, exturl)

my $debug  = 1;
my $PROXY  = 'http://il.sito.del.tuo.blog/blog/nucleus/xmlrpc/server.php';
my $BLOG   = 'myblog';
my $LOGIN  = 'login';
my $PASS   = 'password';

my $TITLE  = "Things I've learned from B-movies";
my $CATEG  = "bot";

#------------------------------------------------------------------
# this is the scraper code

my $BADMOVIES_URL = 'http://www.badmovies.org/movies/';
my $LINK_FORMAT   = '/movies/.*?/index.html';
my @quotes;


my $idx_content = getpage ($BADMOVIES_URL);
my @movies = exturl ($idx_content,$LINK_FORMAT,'',$BADMOVIES_URL);
my $movies_size = @movies;
my $randurl = $movies[rand($movies_size-1)];

my $mov_content = getpage($randurl);

if ($mov_content =~ /<title>\s*Review for (.*?)\s*\n/si){
        $title = $1; chomp $title;
}

if ($mov_content =~ /learned\.gif>(.*?)<\/font><br>/si){
        my $learned = $1;
        while ($learned =~ /10>\s*(.*?)\s*\n/gsi){
                push @quotes,$1;
        }
}

my $quote_size = @quotes;
my $quote = $quotes[rand($quote_size-1)];
$DATA  = qq|$quote<br>|;
$DATA .= qq|(<a href="$randurl">$title</a>)|;

#------------------------------------------------------------------
# this is the blogger code

$blogger  = Net::Blogger->new(debug=>$debug);

$blogger->Proxy($PROXY);
$blogger->Username($LOGIN);
$blogger->Password($PASS);

# get blogid and assign it to the blogger
my $blogid = $blogger->GetBlogId(blogname=>$BLOG);
$blogger->BlogId($blogid);

# create post text
my $txt  = "<title>$TITLE</title>";
   $txt .= "<category>$CATEG</category>";
   $txt .= "$DATA";

# send and publish the new post
my $id = $blogger->newPost(postbody=>\$txt,publish=>1) 
         || die "Error: ".$b->LastError();
#============================================================================
<-X->


7.4 TWO
-----------------------------------------------------------------------------

TWO (The Working Offline forum reader) e' un progetto al momento non molto
attivo, ma che ho portato avanti per tutto lo scorso anno e che ora entra a 
pieni meriti fra le tecniche avanzate di PowerBrowsing. Grazie a una 
struttura molto modulare, basata su dei plugin, esso consente il download
dei contenuti da forum Web di diverse tecnologie (al momento sono supportate
quattro diversi tipi di forum), il salvataggio all'interno di un database 
unificato e la consultazione dei messaggi tramite interfaccia Web HTML+PHP o
la condivisione tramite Web Service (con client gia' pronti, seppur minimali,
in Java, Perl e C).


+------+    +--------+
|FORUM1|    |___UA___|----+                 +---> HTML+PHP
|      |<-->|wrapper1|    |                 |
+------+    +--------+    |                 |
                          |     ______      |                   +--> Java
+------+    +--------+    |    <______>     |                   |
|FORUM2|    |___UA___|----+--> |      |-----+---> Web Service --+--> Perl
|      |<-->|wrapper2|    |    |  DB  |                |        |
+------+    +--------+    |    <______>                |        +--> C
                          |                            |
+------+    +--------+    |                            V
|FORUM3|    |___UA___|----+                         REGISTRY
|      |<-->|wrapper3|                                ...
+------+    +--------+


Uno dei vantaggi principali di TWO, oltre alla possibilta' di condividere le
informazioni scaricate con altre persone, e' quella di unire all'interno
dello stesso database dati provenienti da siti con tecnologie diverse: in
questo modo, e' possibile trovare con un'unica ricerca messaggi scritti in
forum differenti. Inoltre, lo spazio che le informazioni estratte dai forum
occupano su disco e' una piccolissima percentuale dei dati scaricati, cosi'
come questi ultimi rappresentano solo una parte di quanto si sarebbe dovuto
scaricare con un normale browser. 

Ma _quanto_ spazio esattamente e' in grado di guadagnare TWO? Quelli che
seguono sono i risultati di alcuni test (potete trovare la versione completa
nella documentazione di TWO):

------------------------------
Forum data size (KB)    92741
TWO's data size (KB)     7892
------------------------------
Saved space.(KB)........84849
Saved space (perc)........91%   <= !!!
==============================

Lo spazio risparmiato, naturalmente, non va solo a vantaggio vostro, ma anche
a quello di tutti coloro che scaricheranno quei dati dal vostro PC. Se, ad
esempio, cominciasse uno scambio di forum fra utenti, basterebbe comprimere
quegli 8 mega circa di database per ottenere un file delle dimensioni di un
floppy disk, e chiunque in pochi minuti (o secondi!) di download potrebbe 
arricchire la propria base dati con una quantita' incredibile di nuove
informazioni. Usando una tecnologia un po' piu' avanzata, se attraverso un 
registry piu' Web Service di TWO mettessero a disposizione diversi database, 
ogni utente della rete potrebbe effettuare ricerche distribuite su diversi 
forum nello stesso istante. 

Chiaramente, le migliorie che si possono apportare a TWO sono ancora numerose
e gli errori che si dovrebbero correggere sono, probabilmente, ancora troppi.
Il codice sorgente e' fornito "as is" e non escludo vi ci vorra' un po' per
capire come funziona e come migliorarlo. Tuttavia, se siete interessati, 
potete scaricare i sorgenti e la documentazione di TWO collegandovi 
all'indirizzo http://two.sf.net. Fatemi sapere se ci combinate qualcosa di
buono! ;)


=============================================================================
8. Esempi
-----------------------------------------------------------------------------

In questa sezione avrete la possibilita' di vedere e provare alcuni esempi.
Per motivi di spazio, ho deciso di non pubblicare il loro codice sorgente 
direttamente all'interno di questo testo, ma di mettere un collegamento al 
sito da cui potrete scaricarli (NDR: li trovate anche nell'allegato powerb.tgz).
In caso non riusciate a collegarvi, potete mandarmi una mail e vi inviero' un
URL alternativo.

- Common lib
  http://3564020356.org/cgi-bin/perlcode.pl?file=common.pm
  
  common.pm e' un package che mi son creato quando stavo sviluppando TWO, per
  avere sempre a disposizione i comandi tipici per controllare la navigazione 
  di un bot:
  
  getpage e' molto simile alla get di LWP::Simple, tuttavia si appoggia in
    questo caso a LWP::UserAgent per ottenere qualche vantaggio in piu': essa
    e' infatti in grado di gestire i cookie, un proxy, l'identificazione
    dello UserAgent e tentativi multipli di accesso prima di dare per perso
    lo scaricamento di una pagina.
  
  exturl colleziona, all'interno di un array, tutti i link che si trovano
    all'interno di una pagina Web e che soddisfano una o piu' regular 
    expression nell'URL o nel testo taggato: questo permette di seguire link
    del tipo "tutti i file che finiscono in .txt" oppure "tutti i link il cui
    testo corrisponde a Next".

  walkpages e' una funzione ricorsiva che usa exturl per seguire una serie 
    di link specificati e collezionarne un'altra. Essa ha varie modalita' di
    funzionamento: puo' seguire link diversi a seconda della profondita' e
    collezionare solo quelli che trova nell'ultima pagina, oppure raccogliere
    collegamenti man man che naviga all'interno di un sito.
   
  walkpages_loop e' la versione ciclica di walkpages: essa segue cioe' gli
    stessi (o lo stesso) link all'infinito (o per una profondita' massima
    specificata) finche' trova risultati, collezionando man mano tutti i
    collegamenti da conservare che trova.


- Cinemaz
  http://3564020356.org/cgi-bin/perlcode.pl?file=cinema.pl
  NOTA: usa common.pm

  Cinemaz e' un programma che ho creato per uso personale, per ovviare alla
  struttura contorta del sito web http://www.monzacinema.it: per scegliere
  che film vedere, sapere in che cinema lo proiettano, gli orari e il numero
  di telefono per prenotare i click si sprecano!

  Il bot si collega alla pagina principale e scarica tutte le schede dedicate
  ai vari cinema, estraendone quindi il nome, il numero di telefono, il film
  proiettato e gli orari. Le informazioni vengono visualizzate in un file di
  testo spartano, ma contenente tutto il necessario. 

  Con un piccolo adattamento, sono riuscito ad usare lo stesso script con 
  procmail per poter ricevere, ovunque sia, una mail contenente lo stesso
  elenco ogni volta che mando al server un messaggio con subject "cinemaz" :)


- Things I've learned from B-Movies
  http://3564020356.org/cgi-bin/perlcode.pl?file=badmovies.pl
  NOTA: usa common.pm

  http://www.badmovies.com e' un sito molto divertente, contenente numerose
  recensioni a film di serie B. Una delle cose piu' simpatiche, all'interno
  di ogni scheda dedicata a un film, e' la sezione "Things I've learned from
  B-Movies", che contiene un elenco di frasi demenziali sulle lezioni che si
  imparano guardando questi film.

  Lo script, una volta lanciato, scarica l'elenco dei film con i relativi
  link alle schede, ne segue uno a caso, quindi estrae le frasi demenziali
  dalla sezione "Things I've learned from B-Movies" e, a seconda della
  modalita' con cui viene lanciato, le visualizza tutte o una a caso, a mo'
  di "fortune".


- Malacomix
  http://3564020356.org/cgi-bin/perlcode.pl?file=comics.pl

  Malacomix si connette al sito http://www.comics.com per farvi vedere, ogni
  giorno, le vostre strisce a fumetti preferite. Sfruttando la sintassi 
  comune con cui le pagine delle varie strisce sono salvate, e' sufficiente
  specificare nell'url i nomi delle strip che desiderate vedere per generare
  una pagina HTML contenente tutti i link alle immagini corrispondenti.


- Happy3 URL Extractor 
  http://3564020356.org/cgi-bin/perlcode.pl?file=happy3.pl

  Questo script e' stato creato per un preciso scopo: permettere a tutti di
  vedere _come desiderano_ (e non in una popup di dimensioni prefissate) o di
  scaricare sul proprio disco gli episodi di Happy Tree Friends. Lo script e'
  molto semplice, ma e' seguito a un lavoro di "flash reversing" un po' piu'
  avanzato. Magari un giorno, quando vi sarete ripresi da questo lungo testo,
  vi spieghero' anche questo ;)


================================================================================
------------------------------------[ EOF ]-------------------------------------
================================================================================

