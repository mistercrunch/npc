<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="Trenchcoat Legion">
   <meta name="GENERATOR" content="Mozilla/4.72 [en] (Win98; I) [Netscape]">
   <title>C.A.S.L (Custom Auditory Scripting Languaje)</title>
</head>
<body text="#00CC00" bgcolor="#000000" link="#33FF33" vlink="#99FF99" alink="#FF0000">

<center><font color="#FFFFFF">&nbsp;<font face="Courier New,Courier">C.A.S.L.</font></font>
<br><font face="Courier New,Courier"><font color="#FFFFFF">(Custom Auditory
Scripting Languaje)</font></font>
<br><font face="Courier New,Courier"><font color="#FFFFFF">Primera Parte.</font></font></center>

<p><font face="Courier New,Courier">Espero que esta sea una buena serie
de articulos que les sirva de algo, si la quieren ver de nuevo pues manden
mail pidiendola y me tomare el trabajo de escribir mas, si no...Esto ya
es tiempo perdido.</font>
<p><font face="Courier New,Courier">Aclaro ademas que lo pongo en esta
primera parte es: en parte traduccion y en parte cosas mias de "CASL for
Linux Red Hat 5.x Programing Guide" que es un documento que viene acompa&ntilde;ado
por el programa.</font>
<p><font face="Courier New,Courier">-> &uml;Que es CASL?</font>
<br><font face="Courier New,Courier">CASL es un lenguaje de scripting que
sirve para simular ataques de "bajo nivel" o "verificadores de recompilacion
de informacion" (no vi otra manera de traducirlo) en redes. Para hacer
scripts en CASL es necesario que construya los paquetes y los mande a un
host en una red, y los paquetes deben</font>
<br><font face="Courier New,Courier">ser iguales a los usados en un ataque
o un programa que consiga informacion. esto le permitira saber si el host
que se atacara es vulnerable a uno de los ataques mencionados anteriormente.</font>
<br><font face="Courier New,Courier">Lo otro que se necesita para hacer
programas en CASL es el interprete :)!</font>
<p><font face="Courier New,Courier">-> Requerimientos del Systema.</font>
<br><font face="Courier New,Courier">Esto es lo que usted necesita para
instalar el interprete de CASL:</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -Red
Hat Linux 5.x (no necesriamente :)</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -pentium
de 133</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -32
en ram</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -3
MB de espacio en el disco</font>
<br>&nbsp;
<p><font face="Courier New,Courier">-> Como se instala?</font>
<br><font face="Courier New,Courier">lo primero que se hace es bajar el
paquete del CASL que se debe, este viene con una extenci&oacute;n tgz,
ahora le damos:</font>
<p><font face="Courier New,Courier"># tar xvzf archivo.tgz</font>
<br><font face="Courier New,Courier">esto sera descomprimido en un directorio
llamado casl-2.0 donde se pondran todos los archivos de configuracion,
etc, etc. leanse la instrucciones!</font>
<p><font face="Courier New,Courier">Ahora si empezamos, aclaro como dije
antes que esto es sacado de una guia en ingles de CASL que viene con el
programa lo que estoy haciendo es tomandome el trabajo de traducirla y
agregar una que otra cosa.</font>
<p><font face="Courier New,Courier">Escribir programas que hagan o simulen
ataques de bajo nivel en los lenguajes de programacion tradicionales es
complicado y hay que saber mucho de ciertas cosas, pues para usar CASL
es bueno ser bueno es estos lenguajes de programacion aunque las cosas
se facilitan notablemente, pongamos un ejemplo:</font>
<br><font face="Courier New,Courier">El Tear Drop attack envia dos fragmentos
de paquetes a un servidor, estos dos gragmentos de paquetes se superponen
mutuamente lo que hace que windows nt y linux&nbsp; se caigan... la verdad
diciendolo es facil... pero esto no es facil en C y textualmente del manual
"impossible in COBOL" :)... el que me lo mande en cobol le doy un premio!...
La cosa es que esto en CASL no es tan complicado, mas bien facil.</font>
<p><font face="Courier New,Courier">Alguna de las ventajas que tiene el
CASL es la "portabilidad de codigo" ya que un programa hecho en linux tambien
se puede ejecutar (con su respectivo interprete de ordenes) en windows.</font>
<p><font face="Courier New,Courier">Esas son algunas de las caracteristicas
principales de CASL.</font>
<p><font face="Courier New,Courier">-> Estructura de los programas en CASL.</font>
<p><font face="Courier New,Courier">Para escribir programas en CASL solo
hace falta un editor de texto y por su puesto el interprete, ademas los
programas deben tener lo siguiente:</font>
<p><font face="Courier New,Courier">- Elementos</font>
<p><font face="Courier New,Courier">- Variables</font>
<p><font face="Courier New,Courier">- Comentarios</font>
<p><font face="Courier New,Courier">- Paquetes</font>
<p><font face="Courier New,Courier">Los programas en CASL estan compuestos
de declaraciones. Una declaracion va desde la una suma hasta leer un paquete
udp. estas declaraciones actuan sobre variables. Las variables pueden ser:</font>
<p><font face="Courier New,Courier">- un caracter ASCII, que representa
una sola expresion( ej, 'X')</font>
<p><font face="Courier New,Courier">- un numero que represente alguna de
estas 2 opciones:</font>
<p><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
- un entero positivo o negativo.</font>
<p><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
- un numero entero en exdecimal que se representa con 0xNUMERO</font>
<p><font face="Courier New,Courier">- cadenas de caracteres de dos clases:</font>
<p><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
- sucesiones de caracteres (ej "hola Mundo")</font>
<p><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
- secuencias de control (ej. "\n")</font>
<p><font face="Courier New,Courier">- Un buffer, osea que agarre una recolentacion
de datos, generalmente paquetes que salen.</font>
<p><font face="Courier New,Courier">- Una lista, osea que agarre una recolentacion
de datos, generalmente paquetes que entran.</font>
<p><font face="Courier New,Courier">El CASL soporta comentarios que son
ignorados por el interprete, esto en esta clase de programas en muy importante
para ver que sale que entra etc, y para que el dia que se lo pases a alguien
lo entienda o simplemente para que tu lo entiendas, los comentarios se
notan muy parecido que en C puede ser "//" o "/*" para abrir "*/" para
cerrar.</font>
<p><font face="Courier New,Courier">En CASL, uno puede crear packetes,
que son unidades de datos de protocolo, desde cero. O se pueden usar los
que CASL ya tiene predeterminados (muy comodo), definir un paquete en CASL
requiere seleccionar el repectivo protocolo y poner los datos que iran
en el paquete.</font>
<p><font face="Courier New,Courier">Ahora se a tomar un programa hecho
en CASL y se explicara "step by step".</font>
<p><font face="Courier New,Courier">vamos a hacer TCP Stealth Port Scan,
que es un escaneador de puertos que nos dice que puertos estan en espera
de comunicacion pero nunca abre una de esta completamente...</font>
<p><font face="Courier New,Courier">El TCP Stealth Port Scan, funciona
a groso modo de esta manera, manda un TCP SYN a la maquina en cuestion
y espera una respuesta, la cual pude ser:</font>
<p><font face="Courier New,Courier">- un acknowledgment, lo cual indica
que el puerto esta abierto o esperando para conexion.</font>
<p><font face="Courier New,Courier">- un reset, lo cual dice que no hay
conexion por ese lado.</font>
<p><font face="Courier New,Courier">- o nada, indeca algo como un firewall.</font>
<p><font face="Courier New,Courier">**EL TCP Stealth Port Scan, no abre
una conexion con el servicio si esta dispnible**</font>
<p><i><font face="Courier New,Courier">//**---------------------TCP Stealth
Port Scan--------------**</font></i>
<br><i><font face="Courier New,Courier">#include "tcpip.casl"</font></i>
<br><i><font face="Courier New,Courier">#include "packets.casl"</font></i>
<br><i><font face="Courier New,Courier">for(i =1;i &lt;1023;i =i +1){</font></i>
<br><i><font face="Courier New,Courier">&nbsp;&nbsp; OurSYN = copy SYN;</font></i>
<br><i><font face="Courier New,Courier">&nbsp;&nbsp; OurSYN.tcp_source
= 10;</font></i>
<br><i><font face="Courier New,Courier">&nbsp;&nbsp; OurSYN.tcp_destination
= i;</font></i>
<br><i><font face="Courier New,Courier">&nbsp;&nbsp; OurIP = copy TCPIP;</font></i>
<br><i><font face="Courier New,Courier">&nbsp;&nbsp; OurIP.ip_source =
127.0.0.1;</font></i>
<br><i><font face="Courier New,Courier">&nbsp;&nbsp; OurIP.ip_destination
= 127.0.0.2;</font></i>
<br><i><font face="Courier New,Courier">&nbsp;&nbsp; OurPacket =[OurIP,OurSYN];</font></i>
<br><i><font face="Courier New,Courier">&nbsp;&nbsp; ip_output(OurPacket);</font></i>
<br><i><font face="Courier New,Courier">&nbsp;&nbsp; OurFilter = [ "src
host ", 127.0.0.2, " and tcp src port ", i ];</font></i>
<br><i><font face="Courier New,Courier">&nbsp;&nbsp; ReadPacket = ip_input(2000,
OurFilter);</font></i>
<br><i><font face="Courier New,Courier">&nbsp;&nbsp; if(!ReadPacket)</font></i>
<br><i><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
continue;</font></i>
<br><i><font face="Courier New,Courier">&nbsp;&nbsp; if(size(ReadPacket)
&lt; size(IP) + size(TCP))</font></i>
<br><i><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
continue;</font></i>
<br><i><font face="Courier New,Courier">&nbsp;&nbsp; ReadIP=extract ip
from ReadPacket;</font></i>
<br><i><font face="Courier New,Courier">&nbsp;&nbsp; ReadTCP=extract tcp
from ReadPacket;</font></i>
<br><i><font face="Courier New,Courier">&nbsp;&nbsp; if(ReadTCP.tcp_ack
!= 1|| ReadTCP.tcp_syn != 1|| ReadTCP.tcp_rst == 1)</font></i>
<br><i><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
continue;</font></i>
<br><i><font face="Courier New,Courier">&nbsp;&nbsp; print("Port", i, "Alive");</font></i>
<br><i><font face="Courier New,Courier">}</font></i>
<p><i><font face="Courier New,Courier">//**---------------------TCP Stealth
Port Scan--------------**</font></i>
<br>&nbsp;
<p><font face="Courier New,Courier">ahora si la explicacion:</font>
<p><font face="Courier New,Courier">1- Para hacer un TCP Stealth Port Scan
se necesita crear paquetes de TCP/IP. las cabeceras de los paquetes de
TCP/IP ya estan incluidas en CASL. para poder accesarlas se usa:</font>
<p><font face="Courier New,Courier">#include "tcpip.casl"</font>
<br><font face="Courier New,Courier">#include "packets.casl"</font>
<p><font face="Courier New,Courier">2- Ahora se crea el TCP SYN que es
el paquete que se envia al puerto para "arrancar" la conexion. Para crear
el paquete TCP SYN se usa una cabecera de paquete TCP predeterminada, cambiando
los parametros predeterminados por los apropiados. para crear el paquete
se usa los siguiente:</font>
<p><font face="Courier New,Courier">OurSYN = copy SYN;</font>
<br><font face="Courier New,Courier">OurSYN.tcp_source = 10;</font>
<br><font face="Courier New,Courier">OurSYN.tcp_destination = 2049;</font>
<p><font face="Courier New,Courier">espero que se hallan tomado el trabajo
de leer el codigo fuente para que no se confundan... aca se ve con se le
asigna el puerto 10 al puerto de "fuente" (es un numero arbitrario) y al
puerto destino se le asigna 2049 (puerto tcp nfs) a la cabecera del pauqete
de tcp , esto ejemplifica un solo proposito. Estos puertos pueden ser cambiados
como se quiera... mencione que hay que tener alguna idea de programar para
seguir este texto???</font>
<p><font face="Courier New,Courier">3- lo que sigue es especificar el destino
al que vamos a mandar el paquete TCP SYN. Lo que se hace es adherir una
cabecera IP a la cabecera del TCP SYN, asi especificamos hacia donde vamos
a mandar el paquete. para hacer lo anterior ponemos:</font>
<p><font face="Courier New,Courier">OurIP = copy TCPIP;</font>
<br><font face="Courier New,Courier">OurIP.ip_source = 127.0.0.1;</font>
<br><font face="Courier New,Courier">OurIP.ip_destination = 127.0.0.2;</font>
<p><font face="Courier New,Courier">las IP's puestas aca son solo para
mostrar en el ejemplo pero cuando hagan el programa esten seguros de poner
diereciones que sirvan para algo (y no estoy diciendo que las del&nbsp;
ejemplo no sirvan)</font>
<p><font face="Courier New,Courier">4- ahora hay que combinar las las cabeceras
del IP y el TCP SYN, esto pues... pa que esto sirva! no? quien dijo no!
a ver!... ahora en serio, hay dos formas de hacer esto:</font>
<p><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
- una lista con varibles.</font>
<p><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
- lista con operadores.</font>
<p><font face="Courier New,Courier">para hacerlo con variables se pone
de la siguiente manera:</font>
<p><font face="Courier New,Courier">PacketList = [ OurIP, OurSYN ];</font>
<p><font face="Courier New,Courier">lo anterior crea crea una lista llamada
PacketList, con un operador para cada componenete de la lista, la categoria
que abre empieza la lista y la categoria que cierra termina la lista, los
valores individuales en la lista son separados por una coma (,).</font>
<p><font face="Courier New,Courier">ahora con operadores se hace de la
siguiente manera:</font>
<p><font face="Courier New,Courier">PacketList = PacketList push OurSYN;</font>
<br><font face="Courier New,Courier">PacketList = PacketList push OurIP;</font>
<p><font face="Courier New,Courier">Este tambien crea un PacketList, pero
con un operador separado para cada componente de la lista. las cabeceras
TCP e IP son metidas por separado. El ultimo elemento adherido a la lista
es el primer elemento escrito en la lista.</font>
<p><font face="Courier New,Courier">5- Sacar el paquete TCP SYN, esto se
hace de la siguiente manera:</font>
<p><font face="Courier New,Courier">ip_output(PacketList);</font>
<p><font face="Courier New,Courier">6- Definir las conexiones a los puertos.
para encontrar los puertos pues hay que decirle al</font>
<br><font face="Courier New,Courier">programa cuales buscar para lo cual
usaremos un bucle "for" de la siguiente manera:</font>
<p><font face="Courier New,Courier">for (i = 1; i &lt; 1023; i = i + 1)
{</font>
<br><font face="Courier New,Courier">//</font>
<br><font face="Courier New,Courier">}</font>
<p><font face="Courier New,Courier">aca lo que hay es un contador... todo
el mundo lo entiende... espero... mejor lo explico:</font>
<p><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
- i=1 desde donde se empieza</font>
<p><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-i > 1023 donde termina</font>
<p><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
- i = i+1 la cantidad que se cuenta</font>
<p><font face="Courier New,Courier">7- Ahora si la cosa completa, osea
mandar el paquete al puerto:</font>
<p><font face="Courier New,Courier">For (i = 1; i &lt; 1023; i = i + 1)
{</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp; OurSYN = copy SYN;</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp; OurSYN.tcp_source = 10;</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp; OurSYN.tcp_destination
= i;</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp; OurIP = copy TCPIP;</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp; OurIP.tcp_source = 127.0.0.1;</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp; OurIP.tcp_destination
= 127.0.0.2;</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp; OurPacket =[OurIP,OurSYN];</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp; ip_output(OurPacket);</font>
<br><font face="Courier New,Courier">}</font>
<p><font face="Courier New,Courier">8- Ahora vamos a leer las repuestas
TCP.</font>
<p><font face="Courier New,Courier">Se usan rutinas ip_input() para verificar
la respuesta de el host a la peticion de conexion hecha por el programa.
Las rutinas ip_input() especifican el tiempo (em milisegundos) en que se
atendio la conexion. ademas especifica los tipos de paquetes para ser leidos
usando un tcp_dump filter.</font>
<p><font face="Courier New,Courier">para leer la respuesta del host a nuestro
paquete usamos:</font>
<p><font face="Courier New,Courier">OurFilter = [ "src host ", 127.0.0.2,
" and tcp src port ", i ];</font>
<p><font face="Courier New,Courier">donde i es igual a 103</font>
<p><font face="Courier New,Courier">ReadPacket = ip_input(2000, OurFilter);</font>
<p><font face="Courier New,Courier">si IP_INPUT() no lee completamente
el paquete devuelve un valor de cero (0), entonces cada vez que se use&nbsp;
ip_input() hay que comprobar el valor que devuelve con cero (0), para lo
cual</font>
<br><font face="Courier New,Courier">usamos:</font>
<p><font face="Courier New,Courier">if(!ReadPacket)</font>
<br><font face="Courier New,Courier">continue;</font>
<p><font face="Courier New,Courier">lo que hace el continue es hacer que
el valor en el que va el bucle siga con el siguienteo, cuando el valor
este completamente leido ip_input devorvera la respuesta con un paquete
ip completo.</font>
<p><font face="Courier New,Courier">9- determinar los tipos de respuestas
TCP. ahora lo que hay que determinar es si la respuesta es un tcp SYN-ACK
que nos diria que el puerto esta escuchando y listo para recibir conexiones
o si nos da un un TCP RST que nos diria que el puerto no esta disponible.
esto se determina sabiendo el tama&ntilde;o y la cabecera del paquete...
ya explico...</font>
<p><font face="Courier New,Courier">primero se chequea el tama&ntilde;o
del paquete verificando que tenga cabeceras TCP e IP, para lo cual se usa:</font>
<p><font face="Courier New,Courier">if(size(ReadPacket) &lt; size(IP) +
size(TCP))</font>
<br><font face="Courier New,Courier">continue;</font>
<p><font face="Courier New,Courier">esto le indica al interprete que se
mueva hacia adelante en el bucle si el paquete IP es mas peque&ntilde;o
en tama&ntilde;o que la suma de de cabeceras de TCP e IP. de lo contrario
lo que haremos es estractar la cabecera del paquete entrante de la siguiente
manera:</font>
<p><font face="Courier New,Courier">ReadIP = extract ip from ReadPacket;</font>
<br><font face="Courier New,Courier">ReadTCP = extract tcp from ReadPacket;</font>
<p><font face="Courier New,Courier">ahora los tenenmos divididos usando
el operador "extract".&nbsp; ahora los compararemos individualmente para
hacer las comprobaciones correspondientes. los SYN y ACK deben ser tenidos
en cuenta mientras que los RST no. notese que si no son apropiados al condicional
la coneccion podra ser hecha.</font>
<p><font face="Courier New,Courier">if(ReadTCP.tcp_ack != 1 || ReadTCP.tcp_syn
!= 1 || ReadTCP.tcp_rst == 1)</font>
<br><font face="Courier New,Courier">continue;</font>
<p><font face="Courier New,Courier">esta es una instruccion normal en C
si no la entiende lo mejor es que se ponga a aprender algo de C antes de
seguir leyendo, de hecho si no los entendio no se ni como llego hasta aca
sin hartarse. lo que se dijo aca es que si el ack no existe o si un SYN
no existe o si el RST si existe seguir con el bucle ya que el puerto no
esta disponible, de lo contrario el puerto esta disponible.</font>
<p><font face="Courier New,Courier">10- Lo que sigue es virificar abrir
la conexion... al fin! con la instruccion "print" damos las salidas...
osea para mostrar lo que acabamos de hacer lo materializaremos en la pantalla
para lo cual ponemos:</font>
<p><font face="Courier New,Courier">print("Port", i, "Alive");</font>
<p><font face="Courier New,Courier">si "i" es 1022, entonces: "Port 1022
Alive".</font>
<p><font face="Courier New,Courier">11- El programa completo, ahora si
les va el programa como lo querian ver:</font>
<p><font face="Courier New,Courier">#include "tcpip.casl"</font>
<br><font face="Courier New,Courier">#include "packets.casl"</font>
<br><font face="Courier New,Courier">for(i =1;i &lt;1023;i =i +1){</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp; OurSYN = copy SYN;</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp; OurSYN.tcp_source = 10;</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp; OurSYN.tcp_destination
= i;</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp; OurIP = copy TCPIP;</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp; OurIP.ip_source = 127.0.0.1;</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp; OurIP.ip_destination
= 127.0.0.2;</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp; OurPacket =[OurIP,OurSYN];</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp; ip_output(OurPacket);</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp; OurFilter = [ "src host
", 127.0.0.2, " and tcp src port ", i ];</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp; ReadPacket = ip_input(2000,
OurFilter);</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp; if(!ReadPacket)</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp; if(size(ReadPacket) &lt;
size(IP) + size(TCP))</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp; ReadIP=extract ip from
ReadPacket</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp; ReadTCP=extract tcp from
ReadPacket</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp; if(ReadTCP.tcp_ack !=
1|| ReadTCP.tcp_syn != 1|| ReadTCP.tcp_rst == 1)</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;</font>
<br><font face="Courier New,Courier">&nbsp;&nbsp; print("Port", i, "Alive");</font>
<br><font face="Courier New,Courier">&nbsp;}</font>
<br>&nbsp;
<p><font face="Courier New,Courier">esto lo escriben en un editor de texto
y lo prueban (obviamente haciendo los cambios del caso, ya saben cuales)
y a probar!</font>
<br>&nbsp;
<p><font face="Courier New,Courier">Bueno creo que con lo que hay aca ya
se puede empezar a jugar, la verdad pienso que si a esto se le saca un
maximo provecho pues las cosas pueden ir muy bien y muy sensillas.</font>
<p><font face="Courier New,Courier">ya que esta es la primera parte...
pues esperate a la segunda que ya me dio pereza sequir escribiendo, pero
para la 2a perte esperen:</font>
<p><font face="Courier New,Courier">-> estructuras de los programas.</font>
<p><font face="Courier New,Courier">-> listas.</font>
<p><font face="Courier New,Courier">-> cabeceras de paquetes.</font>
<p><font face="Courier New,Courier">-> subrutinas.</font>
<p><font face="Courier New,Courier">y ya que no es mas pero tan poco menos
hasta aca llegamos por hoy, no oviden mandar sus mails diciendo si quieren
la 2a parte a -tcdiaries@uole.com- por que no me voy a poner a escribir</font>
<br><font face="Courier New,Courier">algo que nadie lee...</font>
<p><font face="Courier New,Courier">Mas informacion en <a href="http://www.roses-labs.com">HTTP://www.roses-labs.com</a>,
<a href="http://www.securityfocus.com">HTTP://www.securityfocus.com</a></font>
<br>&nbsp;
<br>&nbsp;
<br>
<center>
<p><font face="Courier New,Courier">=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=</font>
<br>&nbsp;
<br>&nbsp;
<p><font face="Courier New,Courier"><font color="#FFFFFF">traducciones,
comentarios y burradas varias</font></font>
<br>&nbsp;
<p><font face="Courier New,Courier"><font color="#FFFFFF">por</font></font>
<br>&nbsp;
<br>&nbsp;
<p><font face="Courier New,Courier"><font color="#FFFFFF">Flameboy / TrenchCoat
Legion.</font></font></center>

<p><br>
<br>
<br>
<br>
<br>
<p>
<hr WIDTH="100%">&nbsp;
<div align=right>
<br><font face="Courier New,Courier"><font color="#FFFFFF"><a href="index.html">--IR
AL MEN&Uacute; PRINCIPAL--</a></font></font></div>

</body>
</html>
