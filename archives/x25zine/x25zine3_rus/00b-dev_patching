
        ,┌s%$%s┐,      
       ┌$$7"^"?$$L     
      i$$',d$b,'$$;  
yyyyyyyy$ $$$$$ $$l    /dev/* patching на linux
^^""¤¤¤"' '%$%',$$F    by madcr
             ,s$$?;,_             __,,__                          
             '?$'j$$$$%syyy┌┌┌┌y╕$¤¤""^"¤
                ^¤$$$¤¤"^             

 
 Изначальная  статья задумывалась как некий довольно крупный туториал по работе
 с /dev/ ссылками ( => драйверами), но в итоге решив что это довольно простая и
 распространенная тема, я ограничился лишь небольшой теорией.

 В *nix существует 3 типа  драйверов - блочные, символьные и raw. raw  является
 типом  интерфейса блочных драйверов, не используются файл-системой  через /dev
 ссылки, и в нашем случае не нужен. Различие же блочных и символьных в том, что
 блочные предают информацию блоками, и буферизацию  блоков обеспечивает ядро, а
 символьные - передают  информацию  побайтно и буферизацию  данных обеспечивают 
 сами. У каждого  /dev файла есть major и minor номера. major указывает на кон-
 кретный драйвер, minor указывает на  конкретный девайс.В /proc/devices опреде-
 лены major номера блочных и символьных устройств и там-же  они добавляются при
 загрузке новых модулей и соответвенно удаляются при выгрузке. Номера  эти, это
 просто указатели на записи в неком "коммутаторе устройств" [1], а сами  записи
 это  непосредственно точки входа на соответствующие функции драйвера. Эти ком-
 мутаторы устройств и являются базовым интерфейсом драйвера устройств.Интерфейс
 для блочных и символьных устройств различен.Для символьных это cdevsw[] струк-
 тура:

 struct cdevsw[]
 {
 int (*d_open)();     
 int (*d_close)();    
 int (*d_read)();     
 int (*d_write)();    
 int (*d_ioctl)();
 int (*d_xpoll)();
 int (*d_xhalt)();
 struct streamtab *d_str;
 ...
 } cdevsw[];

 Для блочных это bdevsw[]:

 struct bdevsw[]
 {
 int (*d_open)();
 int (*d_close)();
 int (*d_strategy)();
 int (*d_size)();
 int (*d_xhalt();
 ...
 } bdevsw[];


 При обращении к любой /dev/ ссылке, ядро вызывает функцию open() требуемого 
 драйвера вот таким вот образом:  

 (*bdevsw[getmajor(dev)].d_open) (dev, ...);

 Переменная dev содержит minor и major номера. Макрос getmajor вынимает из этой
 переменной major номер,и отсуда есть возможность определять и minor(дабы драй-
 вер знал с каким minor номером вызывать функцию open() ).

 У каждого драйвера свой 'коммутатор устройств'. Т.е. структура всегда одна (по
 размеру),но для каждого драйвера функции (точки входа)в ней называются по раз-
 ному. Так как  драйверов очень  много всегда в системе, действует определенное
 соглашение в названиях точек входа: каждый драйвер имеет уникальное двухсимво-
 льное обозначение, используемое в качестве префикса названий функций. Т.е. для
 /dev/kmem имеется префикс 'mm'. Соответственно  и точки  входа (функции) этого 
 драйвера будут уже выглядеть так:

 mmopen();
 mmclose();
 mmread();
 mmwrite();
 и т.д.

 Если какой-либо драйвер не имеет поддержки стандартных функций  интерфейса, то
 ядро заменяет их в одной из структур на 'заглушки'. 

 Для  примера, приведу из [1] некоторые точки входа, общие для  различных типов
 драйверов. xx - уникальные префиксы конкретных драйверов:

 xxopen()      -  вызывается при каждом открытии устройства.    (sym/block/raw)
 xxclose()     -  вызывается когда число ссылок на драйвер = 0. (sym/block/raw)
 xxread()      -  чтение данных от устройства.                  (sym/raw)    
 xxwrite()     -  запись данных на устройство.                  (sym/raw)
 xxioctl()     -  общий интерфейс управления устройством.       (sym/raw)
 xxintr()      -  вызывается по прерыванию.                     (sym/block/raw)
 xxpoll()      -  производит опрос устройства.                  (sym/raw)
 xxhalt()      -  остановка драйвера.                           (sym/block/raw)     
 xxstrategy()  -  общая точка входа для block i/o.              (block/raw)
 xxprint()     -  вывод сообщение от драйвера на консоль.       (block/raw)

 и т.д.
 
 Т.к. как я рассматриваю вопрос по патчингу /dev/*,а не по написанию драйверов,
 то туда и будем уклоняться. 

 Зачем вся эта хренотень может понадобиться ? Я не говорю о том, что это  супер
 способы, и нельзя  аналогичных результатов сделать  проще и грамотней - просто
 рассматриваю это как  дополнительные  возможности. Скажем мы хотим сделать tty
 Трою на место старого tty или хотим заменить старый драйвер на новый (оставляя 
 те же  самые minor и major), в общем  хотим зделать зло с /dev/ файлами. Какие 
 для этого можно  придумать способы ? С ходу,  можно придумать  парочку, и их и 
 рассмотрим (способ типа стереть /dev ссылку и через mknod создать аналогичную,
 но с нужным minor/major - не трогаем как самый наисложнейший ж) ):

 1. Пишем новый модуль, подгружаем и меняем major/minor на нужной /dev ссылке
    на этот новый модуль. В итоге это очень громоздко, очень заметно, и старый
    драйвер идет в сад.

 2. Cчитываем модуль по известному major, выгружаем, исправляем, загружаем 
    обратно. Либо просто в наглую выгружаем старый и вгружаем новый. Это еще
    более менее приемлемый вариант.

 Что может понадобится при 1,2 действиях ?  Например нужно знать, что для того,
 чтобы  проинициализировать модуль в ядре (грубо  говоря, чтобы в /proc/devices
 появился major  номер подгруженного драйвера), нужно добавить его в символьную
 таблицу драйверов устройств  функцией register_module()  (linux/fs.h). Функция
 также возвращает  major номер для устройства. Выгрузка, наоборот - через unre-
 gister_module() функцию.  Считать major/minor  номера  конкретной /dev ссылки, 
 можно через syscall 'stat' по 16тому смещению. 

 Ну и особо полезно использовать ioctl. Через него можно делать различные инте-
 ресные вещи с /dev файлами.

 На этом все. Более плотно тему драйверов при желании я  расмотрю в x25zine4, а
 возможно и не рассмотрю :)
 


 Cсылки:

 [1] Андрей Робачевский "Операционная Система UNIX".
 [2] linux driver programming how-to.
