
        ,┌s%$%s┐,      
       ┌$$7"^"?$$L     
      i$$',d$b,'$$;  
yyyyyyyy$ $$$$$ $$l   Parrot Assembler. Все " cool kids " делают это.
^^""¤¤¤"' '%$%',$$F   by gkcj (daniel z.)
             ,s$$?;,_             __,,__                          
             '?$'j$$$$%syyy┌┌┌┌y╕$¤¤""^"¤
                ^¤$$$¤¤"^             

                             
 Parrot -- виртуальная  машина, написанная на C. Главной целью проекта является 
 создание  интерпретатора языка Perl 6, но в то же время  планируется поддержка 
 Perl 5, Python, Java и других  языков. Присутствуют  внутренние проекты языков 
 (Jako, MiniPerl, etc.).

 Название "Parrot" было выбрано после одной первоапрельской шутки,в которой со-
 общалось о слиянии Perl и Python в следующих версиях их интерпретаторов. Это и
 повлекло за собой идею о созданию виртуальной машины.

 На данной стадии  развития нормальная  поддержка  обеспечена только для Parrot 
 Assembler (собственно выполнение jako-программ обеспечено преобразованием про-
 граммы в .pasm  (Parrot  Assembler)). Сам  Parrot  выполняет Parrot's bytecode
 (.pbc),который можно получить из .pasm с помощью assemble.pl.Надо заметить,что
 присутствует также и disassemble.pl - назначение, надеюсь,понятно из названия.
 Увидев расширение .pl, я думаю стало понятно, что это perl-программы, следова-
 тельно вам понадобится еще и perl-интерпретатор.

 Как видно,parrot находится в самом начале пути к своей цели,но все же по тому,
 что есть, можно составить общее впечатление.

 bytecode программы  для Parrot может быть представлен в форме машинного  языка 
 абстрактной CISC-машины.Таким образом, возможно создание программы в bytecode,
 минуя интерпретатор assemble.pl.

 команды pasm, в общем, имеют вид:

    code destination, source1, source2

 а в условиях:

    code boolean, true_dest

 Параметры могут быть как целыми, так и строками. Код  операции содержит только 
 строчные латинские буквы и знак подчеркивания '_' Метки могут содержать латин-
 ские буквы,цифры и знак подчеркивания и заканчиваются двоеточием.К меткам, на-
 чинающимся со знака доллара '$' можно обращаться только из процедуры,в которой
 она определена (локальная метка).

 Все регистры должны содержать префикс типа: P для PMC (Parrot Magic Cookie), S 
 для строк, I для целых и N для чисел с плавающей точкой. (область значений для 
 I и N регистров определяется при компиляции исходного кода Parrot). количество 
 регистров ограничено (0..31). таким образом, у нас получаются переменные вида: 
 I1, S0, P1, N31.

 Думаю, что регистры S, I и N типов будут понятны даже начинающему, а вот о PMC
 необходимо рассказать чуть подробнее. PMC включен в Parrot для корректной под-
 держки SV в Perl 5 и объектов в Python. PMC это объект некоторого типа,который
 может быть использован  для выполнения  различных операций. Без  PMC Parrot не
 смогла бы быть языко-независимой.Некоторые типы PMC описаны в doc/vtables.pod,
 но вы тоже можете создать свой PMC.

 Теперь  на примере простой  программы на pasm давайте разберем общую структуру 
 программы:

<++> lmd4/parrot/fib.pasm !279ed249
# Some simple code to print some Fibonacci numbers
# Leon Brocard <acme@astray.com>

        print   "The first 20 fibonacci numbers are:\n"
        set     I1, 0
        set     I2, 20
        set     I3, 0
        set     I4, 1
REDO:   set     I5, I4
        add     I4, I3, I4
        set     I3, I5
        print   I3
        print   "\n"
        inc     I1
        lt      I1, I2, REDO
DONE:   end
<-->

и ее эквивалент на Perl:

<++> lmd4/parrot/fib.pl !34a6a9e2
#! /usr/local/bin/perl -w

print "The first 20 fibonacci numbers are:\n";

my $I1 = 0;
my $I2 = 20;
my $I3 = 0;
my $I4 = 1;

do {
    my $I5 = $I4;
    $I4 += $I3;
    $I3 = $I5;
    print $I3, "\n";
    $I1++;
} while ($I1 != $I2);
<-->

 Как показано в примере,метки позволяют нам организовать некое подобие циклов в 
 программе. Оператор set просто присваивает значение второго параметра перемен-
 ной первого параметра. оператор 'add I4, I3, I4' соответствует I4 = I3 + I4, а
 'inc I1' -- I1 = I1 + 1. Кстати, инкремент  можно задать и таким образом: 'int
 I1, 1', что  эквивалентно (разумеется 1 можно заменить на любое другое положи-
 тельное целое). Более сложная структура 'lt  I1, I2, REDO' означает "перейти к
 метке REDO, если I1 меньше I2".

 Теперь, если мы соберем fibb.pasm в bytecode, то получим:

<++> lmd4/parrot/fib.pbc.xxd !715a07e8
0000000: a155 3101 0000 0000 5c00 0000 0200 0000  .U1.....\.......
0000010: 7300 0000 3400 0000 0000 0000 0000 0000  s...4...........
0000020: 0000 0000 2400 0000 5468 6520 6669 7273  ....$...The firs
0000030: 7420 3230 2066 6962 6f6e 6163 6369 206e  t 20 fibonacci n
0000040: 756d 6265 7273 2061 7265 3a0a 7300 0000  umbers are:.s...
0000050: 1400 0000 0000 0000 0000 0000 0000 0000  ................
0000060: 0100 0000 0a00 0000 8c00 0000 1800 0000  ................
0000070: 0000 0000 3f00 0000 0100 0000 0000 0000  ....?...........
0000080: 3f00 0000 0200 0000 1400 0000 3f00 0000  ?...........?...
0000090: 0300 0000 0000 0000 3f00 0000 0400 0000  ........?.......
00000a0: 0100 0000 3e00 0000 0500 0000 0400 0000  ....>...........
00000b0: 2101 0000 0400 0000 0300 0000 0400 0000  !...............
00000c0: 3e00 0000 0300 0000 0500 0000 1300 0000  >...............
00000d0: 0300 0000 1800 0000 0100 0000 3f01 0000  ............?...
00000e0: 0100 0000 a100 0000 0100 0000 0200 0000  ................
00000f0: f0ff ffff 0000 0000                      ........
<-->

 Почему так  много нулевых байтов? Это объясняется структурой Parrot's bytecode 
 (doc/parrotbyte.pod).

 Я думаю,что важно будет поговорить о скорости Parrot.В поставку программы вхо-
 дят примеры некоторых простых задач. в их числе и mops.pasm, а также его экви-
 валенты на  C, Perl, Python, Ruby, etc. Собственно единственное что  программа 
 делает -- вычитает единицу из целого числа в цикле от 100000000 до 0. Это соп-
 ровождается измерением затраченного времени на выполнение программы.Результаты
 сведены в таблицу, упорядоченную по времени выполнения:


                     затраченное время, с         млн. операций в секунду

   gcc 2.95.3         0.492522                     406.073230
   parrot 0.0.4       11.161319                    17.919029
   parrot 0.0.4 (*)   11.635834                    17.188282
   parrot 0.0.4 (**)  13.975409                    14.310851
   python 2.1.1       78.9919279814                2.53190427314
   perl 5.005_03      94                           2.12765957446809
   ruby 1.6.5         105.74487                    1.891344705

   (*)  -- использовался mops.pasm, полученный из программы на языке Jako.
           пришлось немного поправить программу -- num_iter (в десять раз
           меньше положенного) и вместо декремента производился инкремент.

   (**) -- вместо mops.pasm использовался mops_p.pasm, отличающийся
           использованием PMC-переменных вместо целых чисел.



 Несколько слов о Jako. автор -- Gregor Purdy. Jako немного похож на Perl и C и
 имеет те же возможности,что и parrot assembler, но на более высоком уровне.Вот
 все та же программа для вывода первых 20-ти чисел Фибоначчи на экран:

<++> lmd4/parrot/fib.jako !3a428e7a
var int I1 = 0;
var int I2 = 20;
var int I3 = 0;
var int I4 = 1;
var int I5;

print("The first 20 fibonacci numbers are:\n");

while (I1 != I2) {
    I5 = I4;
    I4 += I3;
    I3 = I5;
    print("$I3\n");
    I1++;
}
<-->

 Преобразовав его в pasm с помощью jakoc получим:

<++> lmd4/parrot/fib.jako.pasm !bd3326ec
###############################################################################
# This Parrot assembler file was produced by the Jako compiler.               #
# Initial comments from the source code are reproduced below.                 #
###############################################################################

                                                    # var int I1;
                 set      I1, 0                     # I1 = 0
                                                    # var int I2;
                 set      I2, 20                    # I2 = 20
                                                    # var int I3;
                 set      I3, 0                     # I3 = 0
                                                    # var int I4;
                 set      I4, 1                     # I4 = 1
                                                    # var int I5;
                 print    "The first 20 fibonacci numbers are:\n" # print(...);
_W1_WHILE:
_W1_NEXT:        eq       I1, I2, _W1_LAST          #   _W1: while (I1 != I2) {
_W1_REDO:        set      I5, I4                    #   I5 = I4
                 add      I4, I4, I3                #   I4 = I4 + I3;
                 set      I3, I5                    #   I3 = I5
                 print    ""                        #   print(...);
                 print    I3
                 print    "\n"
                 inc      I1                        #   I1++;
_W1_CONT:        branch   _W1_NEXT                  # }
_W1_LAST:        end
<-->

 В общем-то ничего такой  исходник, за исключением забавной строчки 'print ""'. 
 Кривость меток можно списать на незнание структуры do..while (однако это можно
 исправить с помощью  использования все  тех же  меток -- Jako понимает метки и 
 очень интересно их обрабатывает). собственно ожидать чего-то лучшего от языков
 высокого уровня и не приходится. соответственно и pbc-файл будет иметь больший
 размер:

<++> lmd4/parrot/fib.jako.pbc.xxd !754525d6
0000000: a155 3101 0000 0000 7400 0000 0300 0000  .U1.....t.......
0000010: 7300 0000 3400 0000 0000 0000 0000 0000  s...4...........
0000020: 0000 0000 2400 0000 5468 6520 6669 7273  ....$...The firs
0000030: 7420 3230 2066 6962 6f6e 6163 6369 206e  t 20 fibonacci n
0000040: 756d 6265 7273 2061 7265 3a0a 7300 0000  umbers are:.s...
0000050: 1000 0000 0000 0000 0000 0000 0000 0000  ................
0000060: 0000 0000 7300 0000 1400 0000 0000 0000  ....s...........
0000070: 0000 0000 0000 0000 0100 0000 0a00 0000  ................
0000080: 9c00 0000 3f00 0000 0100 0000 0000 0000  ....?...........
0000090: 3f00 0000 0200 0000 1400 0000 3f00 0000  ?...........?...
00000a0: 0300 0000 0000 0000 3f00 0000 0400 0000  ........?.......
00000b0: 0100 0000 1800 0000 0000 0000 6500 0000  ............e...
00000c0: 0100 0000 0200 0000 1800 0000 3e00 0000  ............>...
00000d0: 0500 0000 0400 0000 2101 0000 0400 0000  ........!.......
00000e0: 0400 0000 0300 0000 3e00 0000 0300 0000  ........>.......
00000f0: 0500 0000 1800 0000 0100 0000 1300 0000  ................
0000100: 0300 0000 1800 0000 0200 0000 3f01 0000  ............?...
0000110: 0100 0000 1302 0000 eaff ffff 0000 0000  ................
<-->

 Возможности Parrot Assembler очень широки. представлены и математические функ-
 ции, и функции для работы  со строками, исключениями, объектами, файлами. Воз-
 можно создание внешних модулей (чем  не .pm в Perl?), присутствует сборщик му-
 сора. Рассмотреть все это в рамках одной статьи,к сожалению, не представляется
 возможным.

 Программирование на Parrot Assembler очень  интересное занятие. Думаю, что его
 полезно изучать как первый из языков ассемблера (во всяком  случае, краха сис-
 темы при ошибках на первых порах изучения можно будет избежать).


 ссылки по теме:
  http://www.parrotcode.org/
    официальный сайт проекта Parrot
  http://www.perl.com/pub/a/2001/04/01/parrot.htm
    первоапрельская шутка, давшая название виртуальной машине
