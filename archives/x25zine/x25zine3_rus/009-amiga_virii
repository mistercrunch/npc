
        ,┌s%$%s┐,      
       ┌$$7"^"?$$L     
      i$$',d$b,'$$;  
yyyyyyyy$ $$$$$ $$l    amiga вирусы или 'just for fun'
^^""¤¤¤"' '%$%',$$F    by madcr
             ,s$$?;,_             __,,__                          
             '?$'j$$$$%syyy┌┌┌┌y╕$¤¤""^"¤
                ^¤$$$¤¤"^             


 [1] ................................................................ введение.
 [2] ............................................. структура исполнимых файлов.
 [3] .............................................. загрузка исполнимых файлов.
 [4] ........................................................... инфицирование.
 [5] ................................................. как остаться резидентом.
 [6] .............................................................. заключение.



                                                    --- [1] dc.b "Введение", $a
   
    Некоторое время назад я написал эту статью для одного из журналов, но решив 
 что статья может быть интересна многим, я немного ее подправил и положил в наш
 zine.

                                 --- [2] dc.b "Структура исполнимых файлов", $a


  Для начала рассмотрим структуру стандартных исполнимых файлов в Amiga OS. Из-
 за того, что dos.library была написана в некоторой спешке, причем на BCPL язы-
 ке, имеются некоторые нюансы. Среди  которых и тот, что все данные должны быть
 выровнены по 32ух битному значению. Поэтому и не удивительно, что в исполнимом
 файле все поля также 32ух битные. Исполнимый файл можно разделить на 3 логиче-
 ские части:

  1. Заголовочная секция.
  2. Таблица резервирования памяти (memalloc table).
  3. Ханки (далее - секции).

 Рассмотрим каждую часть более подробно.

  ---[ Заголовок (20 байт) ]:

 1 поле: тип секции hunk_header - $000003f3
 2 поле: длинна имени резидентной/shared библиотеки. поле необходимо при созда-
         нии shared файлов,и для обычного исполнимого файла значение $00000000.
 3 поле: количество секций (включая  резидентные библиотеки и такие секции как
         code, data, bss)
 4 поле: Номер первой секции (отсчет с нуля, соответственно первая = $00000000)
 5 поле: Номер последней секции (с учетом того, что отсчет с нуля, т.е. -1)


  ---[ Таблица резервирования памяти (memalloc),]
     [ размер зависит от количества секций ]:

 Таблица описывает сколько необходимо зарезервировать памяти для каждой секции. 
 Каждое поле таблицы  содержит число longword'ов (в hex) необходимое для резер-
 вирования каждой секции. 

 
  ---[ Ханки (Cекции), размер также зависит от типа секции ]:

 Секции всегда имеют заголовок в одно поле - это hunk_name. Далее,в зависимости
 от того какая секция,могут быть различия. Для секций кода и данных после заго-
 ловка секции идут:

        длинна секции измеряемая в longwords (значение в hex). 
        данные
        [reloc секции и/или символьные секции].
        hunk_end ($000003f2)
 

 Сразу после memalloc таблицы как я и сказал выше идут секции.Первым делом идет 
 секция кода ($000003e9), поэтому ее и рассмотрим.

 Данная секция как и все секции имеет заголовок (hunk_code), длинну  секционных
 данных, данные, (т.е. непосредственно код), reloc и symbol секции (могут отсу-
 тствовать) и hunk_end. Рассмотрим reloc и symbol 'подсекции'. Секция reloc ис-
 пользуется при ссылках внутри секции и из секции в секцию. Например мы получим
 reloc секцию уже при таком коде:

 start:
	jmp start
 end
 
 reloc секция как и понятно не может быть сама по себе,и входит либо в data,ли-
 бо в code секцию. Всего есть 3 вида reloc секций (reloc32,reloc16 и reloc8),мы
 по понятым причинам рассматриваем только reloc32: 

 1 поле: hunk_reloc32 ($000003ec)
 2 поле: сколько раз ссылались
 3 поле: в какой секции ссылаемся (номер)
 далее в зависимости от количества ссылок,поля под каждую ссылку,в которых ука-
 заны смещения от начала кода на место где происходит ссылка.
 последнее поле секции: $00000000.

 Теперь для более полного понимания, посмотрим какой исполнимый файл генерирует
 genam, на примере hello:

 start:	

        move.l   #dosl,a1             ; dos.library
        move.l   4,a6                 ; load execbase
        jsr      -$228(a6)           
        move.l   d0,a6

        jsr      -$3c(a6)             ; get stdout handle (handle back to d0)

        move     d0,d1
        move.l   #text,d2
        moveq    #12,d3
        jsr      -$30(a6)             ; write text to stdout

        eor      d0,d0                ; dosbase
        move     d0,a1                ;
        move.l   4,a6
        jsr      -$19e(a6)            ; close dos.library

        rts                           ; exit

 dosl:  dc.b     "dos.library",0
 text:  dc.b     "hello world",$a
 end

 Amiga Shell:> genam hello_world.s
               ... bla bla bla ...
 Amiga Shell:> hello_world
 hello world
 Amiga Shell:> list nodates nohead hello_world
 hello_world             136  ----rwed
 Amiga Shell:> 
 
 136 байт. Из них:

  20 байт  - заголовок
   4 байта - memoloc table
 112 байт  - hunk_code:

		  4 байта - заголовок секции
	          4 байта - длинна секционных данных
	 	 76 байта - непосредственно код (в него и данные всунули)
	         24 байт  - reloc32_hunk
	          4 байт  - end_hunk


 Кстати здесь видно, что genam не генерирует вообще чего бы то не было лишнего. 
 Что говорит только в его пользу.Соответственно и уменьшить исполнимый файл пу-
 тем отрезания каких-либо не нужных секций мы не можем (не в пример elf). 

 Секция данных, которую по хорошему мы должны были бы определить в верхнем при-
 мере,имеет точно такую структуру как и секция кода,за исключением названия са-
 мой секции ($00003ea).

 Помимо этого есть конечно еще довольно много разных секций таких как bss,name,
 debug, etc,но они нам пока не понадобятся,и соответственно рассматривать их мы
 не будем.


                                  --- [3] dc.b "Загрузка исполнимого файла", $a


 Исполнимых файлов у нас всего 2 вида:

    1. обычные (что выше и рассматривали).
    2. резиденты (библиотеки, девайсы, дататайпы и тд).

 Запускаемый файл проверяется сначала загрузчиком и в зависимости от результата
 переправляет действие в соответствующую сторону.Проверяется по многим парамет-
 рам: сверяется со своей таблицей возможных ханков, проверка по специфичным по-
 лям и тд. Для фрагментированной загрузки файла в память (помним,что речь о dos
 library) используется LoadSeg() или InternalLoadSeg(). Первый вариант особенно
 простой - аргумент один, и это имя файла. Функция возвращает указатель на спи-
 сок сегментов (по одному сегменту на секцию). Структура сегментов для  обычных 
 файлов выглядит так:

 -4 длина сегмента+8 (в байтах)
  0 указатель-адрес на следующий сегмент в списке (0 для последнего)
  4 точка входа на данные. 

 Если же  загружаемый файл является резидентным, то струтура сегментов  заметно
 усложняется. Она состоит из структур: matchword и matchtag и занимает 26 байт:


 struct Resident 

 {

 -- первая структура (matchword,2 байта):

 MatchWord - mc68 оп-код для "illegal" = $4afc

 -- вторая структура (matchtag, 24 байта):

 4 байта MatchTag  - адрес на matchtag данные (т.е. на следующую ниже запись)

   4 байта EndSkip   - где продолжать поиск
   1 байт  Flags     - флаги. 1<<7
   1 байт  Version   - номер версии резидента
   1 байт  Type      - тип резидента (библиотека, девайс, дататайп, etc)
   1 байт  Priority  - приоритет инициализации
   4 байта Name      - указатель на имя модуля
   4 байта IdString  - указатель на идентификационную строку
   4 байта Init      - указатель на инит-часть или на авто-инит структуру

 };


                                               --- [4] dc.b "Инфицирование", $a


 Итак, мы очень кратко, но надеюсь более менее понятно, разобрались с загрузкой
 и структурой исполнимых файлов.Теперь пришло время узнать самый глупый и прос-
 той  способ инфицирования. Заключается он в дописывании своих данных в  первую
 секцию и изменения последнего rts на 'bra.b на вирус'. В этом  способе конечно
 куча недостатков, как например то, что можно писать как и в примере выше - вс-
 тавляя данные в секцию кода (тогда можно просто не добраться до rts). Или пер-
 вой секцией вообще может быть bss секция, и тогда мы много чего попортим. Но с
 другой стороны это компенсируется простотой реализации. Структура действий та-
 кова:

   a. открываем файл.
   b. читаем с hunk_header сколько всего секций, в зависимости от этого 
      попадаем на секцию кода (отсчитываем memaloc tablle).
   c. читаем и запоминаем размер секции кода (чтобы знать где конец).
   d. изменяем размер секции с учетом прибавленных байт вируса.
   e. переходим на конец, дописываем тело вируса и начинаем двигать вверх,
      в поисках rts.
   f. как только нашли rts, заменяем его на bra.b вирус, все это сохраняем
      и отпускаем файл.


  Это самый простой способ заражения файла и техника называется 'linking'. Сле-
 дующий способ посложнее. Заключается он в добавлении новой,первой секции. Сло-
 жнее он тем, что нужно заботиться о изменении reloc информации, все оригиналь-
 ные ханки смещаются на 1 и тд. Плюсов у этого способа как минимум 2:

	1. вирус выполняется перед самой программой. 
	2. код оригинальной программы не изменяется, 
	   соответственно нет ошибок контрольной суммы.
 
 Минус в том, что не можем заражать резидентов, поскольку резидент-структуры не
 будет в первом ханке. Для инфицирования резидентов уже нужно добавлять эту ст-
 руктуру в кодовую секцию вируса. 

 Cпособов заражения огромная куча, но так или иначе,большинство амижных вирусов
 основано на комбинации этих методов.


                                     --- [4] dc.b "Как остаться резидентом", $a


 Напоследок в кратце расскажу о том, как пропатчить некоторые функции amiga os
 оставшись резидентом. Что для этого нужно:

  1. отхапать памяти (лучший/понятный способ allocmem() ).
  2. в отхапанную память копируем вирус. здесь очень важно отчистить кэши,   
     перед переходом на новое место. Самый простой способ:
	
                                move.l   4.w,a6               ; взяли ExecBase
                                jsr      _LVOCacheClearU(a6)  ; очистили кэши

  3. непосредственно патчинг функций. самый простой способ просто пропатчить 
     библиотечные вектора. по идее тут надо повозится (считать библиотечные 
     контрольные суммы и тд), но на наше счастье есть системная функция кото-
     рая все это делает - SetFunction(). Что мы можем к примеру попатчить из
     dos.library:  loadseg(),open(),read(),seek(),examine() и тд. 
  
 Этот способ конечно очень простой, и для вируса он не пойдет. Так как даже са-
 мый убогий антивирус отслеживает изменение векторов. Конечно есть опять-же ку-
 ча других способов, но о них я пока не буду рассказывать,а xочу лишь сказать о
 том, каким образом вирусы переносят ресеты. Рассмотрим  самый стандартный спо-
 соб. В amigaos есть некоторые приятные особенности, которые играют на руку ви-
 русам: ExecBase-> ColdCapture, ExecBase-> CoolCapture и ExecBase-> WarmCapture
 входы которые вызываются на различных этапах загрузки. Обычно они  установлены
 в 0, но некоторые программы и большинство вирусов модифицируют их.Для их изме-
 нения нужно посчитать ExecBase->ChkSum и OS переделает ExecBase после ресета.
 Для подсчета контрольной суммы можно использовать вот такой вот код:

    move.l  4.w,a6          ;взяли ExecBase
    lea     SoftVer(a6),a0  ;начало подсчета контрольной суммы структуры
    moveq   #0,d0
    moveq   #24-1,d1        ;контрольная сумма через  24 слова
.l  add.w   (a0)+,d0        ;прибавим слова
    dbf     d1,.l
    not.w   d0
    move.w  d0,(a0)         ;запоминаем контрольную сумму в ExecBase->ChkSum
    jsr     _LVOClearCacheU(a6)  ; избегаем проблем с кэшами

 Это часто используется для bootblock вирусов.И конечно и для пережития рестар-
 тов есть также куча разных способов о которых я также пока не буду говорить.


                                                  --- [5] dc.b "Заключение", $a

 Думаю статья будет полезна для так сказать расширения кругозора. Хочется ска-
 зать особое спасибо полякам :), в частности beol/xine#2, madroger/epidemic и 
 конечно guru book.
 
 ci a.
