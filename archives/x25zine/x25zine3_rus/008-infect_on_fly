
        ,┌s%$%s┐,      
       ┌$$7"^"?$$L     
      i$$',d$b,'$$;  
yyyyyyyy$ $$$$$ $$l    Инфицирование на лету.
^^""¤¤¤"' '%$%',$$F    by free_hunter
             ,s$$?;,_             __,,__                          
             '?$'j$$$$%syyy┌┌┌┌y╕$¤¤""^"¤
                ^¤$$$¤¤"^             


  Затрагивая тему  linux  вирусов, зададимся вопросом, а что же может увеличить 
 скорость распространения этого животного? ;) Конечно,наиболее простой путь это 
 активное распространение (сканировать в поисках уязвимых  сервисов, ftp с воз-
 можностью  upload-a файлов итд), но это привилегия червей, а у нас простенький 
 вирус ;). Еще  один путь увеличить  скорость распространения  это инфицировать
 каждый запускаемый файл в файловой системе чтоб при копировании  файла на дру-
 гую систему он был со 100% вероятностью зараженным. Но эта задача очень ресур-
 соемкая,и заметная (должен быть активный процесс все это время,увеличение раз-
 мера файлов и тому подобное). Мы выберем путь попроще ;)

  Инфицировать файлы мы будем  прямо "на лету" в момент когда они  направляются 
 ядром к сетевой карте. Для того чтобы это реализовать мы должны знать как уст-
 роена  работа с сетью в ядре  linux. Leet ppl читающие фрак уже в курсе (Prack 
 55, article 12 "Building Into The Linux Network Layer"), а для остальных крат-
 кий пересказ :

 "TCP/IP это стек протоколов(igmp,icmp,ip,..).  Это означает что ядру нужно ис-
 пользовать  несколько обрабатывающих функций для процессинга пакетов различных 
 уровней по порядку для полного понимания пакета, соединения его сокетом и т.д.
 Во-первых, требуется функция для управления заголовком уровня данных (datalink
 -layer) и,после обработки на этом уровне, пакет проходит на IP-уровень где об-
 рабатывается своими функциями, потом на транспортный-уровень функций и так да-
 лее.Различные протоколы нуждаются в пути для общения с остальными во время об-
 работки пакета.Под Linux за это отвечают socket kernel buffers (sk_buff's).Они
 используются для прохождения данных между различными  уровнями протоколов (об-
 рабатывающих функций) и драйверами сетевых устройств.

 Структура sk_buff{} (Представлены только основные поля. За подробностями смот-
 реть linux/skbuff.h):

            sk_buff{}
            --------+
            next    |
            --------|
            prev    |
            --------|
            dev     |
            --------|
                    |
            --------|
            head    |---+
            --------|   |
            data    |---|---+
            --------|   |   |
            tail    |---|---|---+
            --------|   |   |   |
            end     |---|---|---|---+
            --------|<--+   |   |   |
                    |       |   |   |
            --------|<------+   |   |
            Обрабат.|           |   |
            пакет   |           |   |
                    |           |   |
            --------|<----------+   |
                    |               |
                    |               |
                    |               |
            --------+<--------------+

next:   указатель на следующий sk_buff{}.
prev:   указатель на предыдущий sk_buff{}.
dev:    устройство которое используется.
head:   указатель на начало буфера который держит наш пакет.
data:   указатель на начало данных протокола.  Оно может сильно отличаться
        в зависимости от уровня протокола на котором мы находимся.
tail:   указатель на конец данных протокола, также различается в зависимости
        от уровня протокола и использования им sk_buff.
end:    указывает на конец буфера содержащего наш пакет.Фиксированное значение.


 Для более точного понимания, представим следующие:

 - хост A посылает пакет хосту B

 - хост B получает пакет через соответствующие сетевое устройство.

 - cетевое устройство(драйвер) конвертирует полученные данные в sk_buff 
   структуры данных.

 - эти дата структуры добавляются в backlog очередь.

 - sheduler потом определяет какой уровень протокола прошли полученные
   пакеты.


  Наш следующий вопрос ... Как sheduler  определяет через какой протокол прошли
 наши данные? Каждый протокол зарегистрирован в packet_type{} структуре которая
 содержится в ptype_all листе или ptype_base хэш таблице.packet_type{} структу-
 ра содержит информацию о типе протокола, сетевом устройстве, указателе на фун-
 кцию обработки данных полученных для протокола и указателе на следующую packet
 type{} структуру. Сетевой  обработчик  принимает значение типов протоколов для 
 приходящего пакета (sk_buff's) с такими которые описаны в packet_type{} струк-
 турах. sk_buff в это время проходит совпадающую функци(ю\и) обработки протоко-
 ла.

  Что мы делаем,так это просто пишем свой модуль ядра который регистрирует нашу
 packet_type{}  структуру для  обработки всех входящих пакетов(sk_buff's) сразу 
 после того как они пришли с драйвера сетевого устройства. Это проще чем кажет-
 ся. Мы просто  заполняем packet_type{} структуру и регистрируем ее через испо-
 льзование функции ядра которая называется dev_add_pack(). Наш обработчик будет
 сидеть между драйвером сетевого устройства и следующим (до этого - первым) об-
 работчиком. Это означает что каждый sk_buff что прибыл с драйвера сетевого ус-
 тройства будет проходить сначала через наш обработчик пакетов.


  Итак, после  того как вы переварили эту  информацию, следует уточнить, что не 
 только приходящие пакеты будут обработаны, нашей функцией,но и пакеты предназ-
 наченные для отправки в сеть будут обрабатываться нами перед самым отправлени-
 ем.

  Теперь,встает еще одна важная задача,это как и куда встраивать наш код в про-
 ходящий мимо нас ELF файл. Ведь мы не имеем возможности  "дописать" в файл наш 
 код, так как протоколы прикладного уровня (ftp,http) как правило сообщают раз-
 мер передаваемого файла, и принимающая сторона просто закроет сокет после  по-
 лучения  нужного количества байт. Отслеживать и изменять размер не имеет смыс-
 ла, так как  наша задача  абстрагироваться от прикладного уровня насколько это
 возможно.

  Для  инфицирования ELF  мы будем использовать модную нынче технику называемую 
 (segmet padding) или выравнивание сегментов.Подробно она рассмотренна в некото 
 ром документе точнее в творении "The ELF Virus Writing HOWTO" by Alexander Bar
 tolich. В кратце, мы раздвигаем LOAD сегмент содержащий исполняемый код добав-
 ляя 4к,все остальное в файле сдвигаем вниз и исправляем соответствующие смеще-
 ния программных заголовков в заголовке програмных секций. И так как между сле-
 дующим LOAD сегментом содержащим данные  и окончанием первого, дыра в адресном
 пространстве  в 4к, то наш  код туда и грузиться, далее меняем точку вхождения 
 на наш код и после его исполнения прыгаем на оригинальный код.
 
  Единственная  проблема  данной  реализации, это размер файла. Итак необходимо 
 где-то откопать в ELFе 4к неиспользуемых данных;) Спецификация ELF расшифровы-
 вается как EXECUTABLE AND LINKABLE FORMAT (ELF), и соответственно названию она
 распространяется на типы файлов не только запускаемые но и всякие файлы содер-
 жащие разделяемый код,динамически линкуемые библиотеки и прочего хлама;) Соот-
 ветственно спецификация подразумевает два подхода к загрузке ELF-а, это компа-
 новка (LINKABLE) и собственно запуск.Для первого существуют символьные  секции
 и их заголовок, для второго программные.То есть,если глубже разобраться в спе-
 цификации ELF файлов, то можно обноружить что для запускаемых файлов практиче-
 ски не нужны символьные секции как таковые.А они занимают немалую часть в фай-
 ле, а  нужны реально только для отладки и тому подобных вещей. Есть  программа 
 называемая sstrip, написанная Brian Raiter-ом, которая просто берет и вырезает
 полностью все символьные секции, и что самое удивительное программы после это-
 го продолжают работать :) Кроме того, есть стандартная утилита strip из пакета
 bin-utils, которая вырезает не все секции а только неиспользуемые линковщиком:
 comment, stab, stabstr, но тем не менее генерируемые gcc, которые занимают до-
 вольно много места в файле (мне встречались от 4к до 8к). Все остальные секции
 к сожалению занимают не более 2к,то есть недостаточно для внедрения  нашего 4к 
 кода :( Использовать  меньший размер или  перекрывать  секции невозможно из-за 
 спецификации ELF, а также минимальным размером адресуемой памяти(4к). Еще один
 неприятный момент тот, что все  бинарные файлы из дистрибутива в /bin, /sbin и 
 т.д, обработаны утилитой strip, то есть не пригодны для инфицирования этим ме-
 тодом. Однако остальные файлы вполне подходят ;)

  В итоге,мы вешаем свой обработчик между драйвером и всеми остальными сетевыми
 обработчиками в ядре,и следим за появлением в потоке данных ELF сигнатуры.Про-
 веряем заголовок на "нормальность",не битость и прочее.Просматриваем также за-
 головки программных секций на нормальность и вычисляем размер который действи-
 тельно используется при запуске(основано на sstrip). Плюс проверяем количество
 символьных секций: если меньше 29,то считаем файл strip-нутым (то есть размера
 после вырезания всех символьных секций все равно не хватит для встраивания на-
 ших 4кб, и  оставляем его в покое). Иначе, модифицируем  секции как необходимо
 для инфицирования через выравнивание сегментов, запоминаем в  буфере код между 
 точкой куда начинаем писать наш код и полезным размером  файла, пропускаем 4кб 
 и  восстанавливаем запомненный код. Далее идет уже  неиспользуемый мусор, пос-
 кольку символьные секции мы вырезали.


  Как видно ничего сложного ;) И тем не менее эта lkm-ка позволяет инфицировать
 ELF-ы в не зависимости  от того по какому протоколу передается файл ftp, http,
 dcc, dns ... :) Естно если  протокол уровня  приложений  использует некую свою
 контрольную сумму не полагаясь на TCP, то оно выдаст ошибку,а также при докач-
 ке, или нехватки свободного места для записи наших 4к (сведенно к минимуму). А
 также  при передаче  по шифрованному  каналу типа sftp или в архивном виде :) 

 Кстати,говоря при передаче внутри tar архива инфицирование происходит успешно,
 так как он не считает cвою crc ;)

  Кроме того, инфицировать можно не только ELF файлы, но и win32-exe файлы ;) А 
 также исходники, вставляя например inline asm вместо подходящих по размеру ко-
 ментариев ;) Будет довольно интересный сюрприз для  тех кто лениться проверять 
 md5 checksum или смотреть в сырец перед компиляцией сплоитов ;)



 P.S. Код  в  бонусе  представлен, только для образовательных целей, соответст-
 венно вместо вируса вставляется  безобидный код  выводящий "ELF", я не отвечаю 
 за последствия его применения ;) Но помните, что эта ALPHA версия , причем до-
 вольно сырая ;0  Так как  во-первых, я не leet кодер, а во-вторых чтоб присечь 
 использование всеми подряд ;)

 P.S.S. НЕ  РЕКОМЕНДУЕТСЯ использовать этот код на  реальных системах ! Так как 
 существует большая вероятность что ядро  испугается этого кода и в панике убе-
 жит ;))

