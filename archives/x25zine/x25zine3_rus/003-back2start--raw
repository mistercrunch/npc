
        ,┌s%$%s┐,      
       ┌$$7"^"?$$L     
      i$$',d$b,'$$;  
yyyyyyyy$ $$$$$ $$l    back to start: raw
^^""¤¤¤"' '%$%',$$F    by madcr 
             ,s$$?;,_             __,,__                          
             '?$'j$$$$%syyy┌┌┌┌y╕$¤¤""^"¤
                ^¤$$$¤¤"^             


  Практически каждый сегодня знает что такое raw данные. И даже более того, са-
 мые умные могут писать программки которые этот raw используют :) При этом воз-
 никают целые треды обсуждений, faq, howto и статей касающихся данного вопроса.
 Но скажу честно, я нигде не видел действительно нормального объяснения как все 
 это работает на самом деле и почему. Естественно, что знающие люди без проблем
 решат проблему нехватки информации почитав исходники кернелов, но как я обычно
 говорю - журнал для тех кто учится, а не для тех кто уже выучился ж)

  Существует 2 самых используемых в области зла типа сокетов. Это raw и packet.
 Маны и ядро очень красноречиво говорят что это такое. Тип raw сокетов был соз-
 дан разработчиками для последующей возможности создания новых протоколов бази-
 рующихся на ipv4/6. И так получилось, что сделали еще и опцию ip_hdrincl кото-
 рая позволяет состряпать заголовок самим. Вот из-за этой возможности raw соке-
 ты и получили такое распространение и ажиотаж вокруг себя.Т.е. говоря нормаль-
 ным языком это в  принципе лажа, но довольно удобно когда нет желания думать о 
 ether фрэймах. Плюс ко  всему у raw есть некие особенности, такие как авто за-
 полнение контрольной суммы (только ip,не вышележащего протокола), длинны всего
 пакета и т.д. Есть и куча нюансов как например: ядро увидев, что  поднялся raw 
 сокет, засовывает  автоматом ether  заголовок в буфер, также  автоматом смещая
 данные находившиеся в буфере на 14 байт вниз.  

  Второй тип сокета это  packet, о котором также в инклудах и сорцах говорится,
 что тип сделан для работы на втором уровне osi. Это уже похоже на нечто норма-
 льное, но соответственно и  следить здесь придется за большим. Оно и понятно -
 никаких  автоматических заполнений чего бы там не было в  каких бы там не было
 протоколах здесь и быть не может. Зато можем срать в сетевуху хоть 1 байт,хоть
 1000000.
 

.globl _start   # m68k
_start:
.text
        eorl %d0,%d0
	movl %d0,%d1	    	
       
 # socket(PF_INET,SOCK_PACKET,htons(ETH_P_ALL)

        movl #0x2,%sp@          
	movl #10,%sp@(0x4)      
	movl #0x0003,%sp@(0x8)  
	
	movel %sp,%d2  
	movb #0x66,%d0 
	movb #0x1,%d1  
	trap #0        

 # sendto(sock,buffer,sizeof(buffer),0,&address,16)

        movl %d0,%sp@         
        movl #hlam,%sp@(0x4) 
        movl #100,%sp@(0x8)   
        movl #0,%sp@(0xc)       
        movl #sockaddr,%sp@(0x10)      
        movl #16,%sp@(0x14)   
                              
        movl %sp,%d2
        movb #0x66,%d0  
	movb #11,%d1    
	trap #0         

        movb #1,%d0
	trap #0 

.data
sockaddr: .byte 0x00,0x02
          .string "eth0"
.bss
hlam: .space 100,0  

 # as send.s -o send.o ; ld send.o -o send ; sstrip ./send ; la -la ./send
 -rwxr-xr-x    1 root     root      222  Aug  8 03:032 ./send
                                    (!)

 Что-же здесь происходит ? Поднимаем сокет packet типа, и посылаем 100 байт ну-
 лей в сетевуху. Единственное о чем здесь стоит упомянуть это о sockaddr. Опять
 же, достаточно, просто посмотреть в инклуды и станет понятно, что sockaddr это
 некая структура на  которой  основаны еще куча  подструктур (глупо и грубо так 
 сказано, но для понимания пойдет). 
 
 # more /usr/include/linux/socket.h 
 .....
 struct sockaddr {
         sa_family_t     sa_family;     /* address family, AF_xxx       */ 
         char            sa_data[14];   /* 14 bytes of protocol address */    
 };
 .....


 Ядро перед отсылкой какого бы то не было пакета, куда бы то не было,смотрит на
 заполнении sockaddr(это тоже можно почитать в сорцах ядра).Всякие sockaddr_in,
 sockaddr_sx25,sockaddr_pkt - это cделано только для простоты работы с этим са-
 мым sockaddr.Т.е. легче всего работать с ним и все. Также можно почитать в ин-
 клудах и манах то, что при работе с sock_packet, нужно  чтобы в sockaddr было: 
 номер семейства (af_xxx) и имя интерфейса. Что мы и делаем. 

 Обработкой конкретных протоколов занимается кернел (в случае с inet это tcp/ip
 стэк), соответственно все что  нам нужно это создавать какие мы хотим пакеты и 
 слать. При  правильной сборке  кернел все будет обрабатывать и понимать (опять 
 таки полезно почитать сорцы ядра). Для примера возьмем icmp request (x86):

.globl _start
_start:
.text

 # socket(PF_INET,SOCK_PACKET,htons(ETH_P_ALL)

        movl $0x2,(%esp)      
	movl $10,0x4(%esp)    
	movl $0x0300,0x8(%esp)
	
	movl %esp,%ecx        
	    	
	movl $0x66,%eax       
	movl $0x1,%ebx        
	int  $128             

 # sendto(sock,buffer,sizeof(buffer),0,&address,16)

        movl %eax,(%esp)         
        movl $packet,0x4(%esp) 
        movl $size_packet,0x8(%esp)   
   	movl $0,0xc(%esp)    
   	movl $sockaddr,0x10(%esp)      
   	movl $16,0x14(%esp)   
                              
        movl $0x66,%eax       
	movl $11,%ebx         
	int  $128             

        movl $1,%eax
	int  $128
 
.data
sockaddr: .byte 0x00,0x02
          .string "eth0"
packet:
       /* ethernet - 14 bytes       */
.ascii "\x00\x80\xad\xc6\x18\xbb"   /* mac dest:  00:80:ad:c6:18:bb (1.2) */
.ascii "\x00\x10\xa4\x10\xe8\x1d"   /* mac sorc:  00:10:a4:10:e8:1d (1.1) */
.ascii "\x08\x00"                   /* mac options 0806 - ARP, 0800 - IP  */
       /* ip header - 20 bytes      */
.ascii "\x45"                       /* version:4, ihl:5                   */
.ascii "\x00"                       /* type of service:                   */
.ascii "\x00\x22"                   /* total length ip header + data (34) */
.ascii "\x00\x00"                   /* id       	     	          */
.ascii "\x00\x00"                   /* flags                              */
.ascii "\x80"                       /* TTL                   : 255        */
.ascii "\x01"                       /* protocol (1=ICMP)                  */	         
.ascii "\xb7\x87"                   /* checksum 0xb787 (46983)            */
.ascii "\xc0\xa8\x01\x01"           /* ip source       : 192.168.1.1      */ 
.ascii "\xc0\xa8\x01\x02"           /* ip destination  : 192.168.1.2      */
       /* icmp header - 8 bytes     */
.ascii "\x08"                       /* 08 - echo request, 00 - echo reply */
.ascii "\x00"                       /* CODE = 0                           */
.ascii "\xcd\xd2"                   /* checksum 0xcdd2 (52690)            */
.ascii "\x00\x00"                   /* Identifer - if CODE 0, so 0 too    */
.ascii "\x00\x00"                   /* seq.num - if CODE 0, so 0 too      */
       /* icmp data - !>1472        */
.ascii "\x61\x62\x63\x64\x65\x66"   /* DATA                               */

size_packet = .-packet
 

 Выглядит довольно просто, единственный опять-таки нюанс, что здесь контрольные 
 суммы ip и icmp я посчитал руками,в то время как при нормальной работе пишется
 простенький макрос который занимается подсчетом и записью в буфер (пример есть
 в craft_pack из бонуса).


 p.s.Кстати для тех кто в танке: в rfc по udp/tcp есть некая недоработка.В час-
 тности при описании псевдо-заголовков говорится,что псевдо-заголовок это прос-
 то некоторые поля из ip  заголовка. Тут кроется обман, т.к. на самом  деле (не 
 понятно зачем) 2 раза считается длинна udp or tcp заголовка и их данных,вместо
 одноименного поля из iphdr. Мелочь, но неприятно было тратить лишние минуты.
