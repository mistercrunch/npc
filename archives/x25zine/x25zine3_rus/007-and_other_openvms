
        ,┌s%$%s┐,      
       ┌$$7"^"?$$L     
      i$$',d$b,'$$;  
yyyyyyyy$ $$$$$ $$l    А OpenVMSы здесь разные
^^""¤¤¤"' '%$%',$$F    by madcr 
             ,s$$?;,_             __,,__                          
             '?$'j$$$$%syyy┌┌┌┌y╕$¤¤""^"¤
                ^¤$$$¤¤"^             


 Во первых сразу хочется развеять некий миф о смерти OpenVMS. OpenVMS процвета-
 ет и по  сегодняшний день, взяв  себе не только древние vax, но и  современные
 alpha,с чем можно поздравить compaq. 7.3 версия поддерживается довольно рьяно,
 и количество док по ней (и не только) постоянно растет.Буквально полгода назад
 compaq  выдали в свет 'OpenVMS Guide to System Security'. В принципе  там есть 
 чего почитать :) 

 Первые VMS'ы были выпущены для vax процессоров и уже были нацелены на кластер-
 ную работу(!). Каждый кластер представлял из себя локалку, которые соединялись
 друг с другом образуя decnet. Самые олдовые товарищи помнят отчетливо 80-тые и 
 90тые годы и бурный всплеск интереса к этой сети. Достаточно  попасть на любую 
 OpenVMS, сделать show net и лезть дальше и дальше. Хочу  заверить - decnet су-
 ществует и дышит полной грудью и по сейчас,и людей которые им пользуются - ты-
 сячи (если не милионы). Адресация в нем довольно простая: x.y, где 'x' - номер
 области, а 'y' номер ноды в этой области. Чтобы соединиться с новым хостом вне
 кластера, нужен полный нодовый  номер в decnet  этого хоста, который считается 
 просто: y + (x * 1024). А далее set host <что_получили> и поехали.Либо же если
 лазить по кластеру, то просто show cluster, set host <name>.

 Пользоваться decnet'ом можно в принципе и  ничего не зная,но OpenVMS интересна
 не только им.В частности она имеет 2 разных ассемблера для 2х разных платформ,
 команд-лайновый язык (dcl) который довольно своеобразен, свой pascal, basic, C
 компилятор, своеобразная организация файловых  систем (ods-1,2,5). Естественно 
 своя структура *.exe файлов (которых 4 вида) для этих файловых систем и т.д. и 
 т.п. 

 Изначально файловая  система назвалась files-11 on-disk structure (ODS). Слово
 files-11 в народе (как обычно бывает) cамо-собой откинулось, и теперь мы гово-
 рим просто ODS:
 
 ODS-1 - Самая древняя. Только для vax. Длина имен файлов 9 байт.
 ODS-2 - Особо распространенная. И для vax и для alpha. Длинна имени файла 40.
 ODS-5 - Новая файл-система начиная от OpenVMS 7.2. Полнофункционально рабо-
         тает лишь для alpha. Можно монтировать и на vax, но особенностей ods5
         в распоряжении не будет. Имеет все навороты современной файл-системы.
 
 Так как ODS-2 до сих пор остается самой распространенной, ее в кратце и расс-
 мотрим. Файл-система использует некоторые контрольные файлы располагающиеся в 
 master file directory:

 indexf.sys;1 - довольно глобальный файл. содержит информацию об оси на данном
                томе и информацию о данных всех файлов на нем. имеет свою до-
                вольно интересную структуру,о которой лучше почитать в 'guide
                to openvms file applications'.
 bitmap.sys;1 - грубо говоря информация о доступном месте/размере.
 badblk.sys;1 - список бэд-блоков.
 000000.dir;1 - корневая директория.
 corimg.sys;1 - core image file. не поддерживается осью.
 volset.sys;1 - содержит список всех томов.
 contin.sys;1 - идентификация файлов при cross'e с одной партиции на другую.
 backup.sys;1 - зарезервирован для будущего использования.
 badlog.sys;1 - содержит список блоков подозревающихся как бэды.
 security.sys;1 - cодержит volume security профиль и используется set/show 
                  security командами.
  

 Корневой директорией является 000000. Т.е. $ cd aga$dra0:[000000]. Вообще осо-
 бо полезно сделать show  logical - будет много интересного. Лучше всего, опять 
 же почитать guide to openvms file application,т.к. всего в статье не уместить.
 Можно добавить еще, что измеряется все в блоках. Т.е. файлы могут быть конечно
 любого количества байт, но все  утилье будет смотреть именно по блокам (кстати 
 отсуда основная проблема уменьшения размера исполнимого файла, о чем будет ни-
 же).

 Из всех форматов файлов, нас более  интересуют исполнимые форматы, которых как
 я говорил выше 4 вида:


  executable - непосредственно и исполняется.
  shareable  - вызывается либо из других shareable, либо из executable, т.е. 
               unix'овыми словами - shared object file.	
  protected  - uwss (user_written system services). тот-же самый shareable, 
               только с механизмом привелегий. Исполняется в пространстве ядра.
  system     - используются ядром и непосредственно процом. т.е. просто куски
               кода не предназначенные для выполнения под осью. не имеют заго-
               ловков (хотя можно всеже всунуть) и таблицы глобальных символов.


  Так уж получилось,что не compaq, не ранее dec,не кто-либо другой не публикует 
 структуру  исполнимых файлов. Чем это вызвано я не в курсе, но возможно на  то
 есть объективные причины. Как-бы там не было, немного покопавшись я узнал все,
 что мне было нужно:

 Стандартный  исполнимый файл получаемый при link file (речь о VAX, не о alpha) 
 имеет нижеследующую структуру:

 1. заголовок - 48 байт.
 2. информация активации - 20 байт.
 3. GST/DST - 28 байт.
 4. идентификационная информация - 80 байт.
 5. заголовки секций - неопределенное количество. Окончание заголовков фиксиру-
    ется по ffffh. Обычно это 3-4 заголовка (не все секции берутся из файла).
 6. Первая секция - секция машинного кода.
 7. Вторая секция - 'activator fixup' секция.
 8. Третья секция - некоторая информация о модулях,метках и тд.
 
 Из всего этого  хлама по настоящему важно немного: заголовок, кусок информации
 активации, 3 заголовка секций и сам код. Т.е. все секции (кроме  кода ;) можно 
 безболезненно удалить (учитывая, что пишем без использования библиотек),но для
 этого нужно знать  где и как эти секции располагаются ;) Для начала рассмотрим 
 фиксированный заголовок из image header (48 байт) и структуру  заголовков сек-
 ций:


;----------fixed_header_from_image_header-------------------------------------

 offset  size               description 

  00h      1     image section descriptor length
  01h      1     image header descriptor length 

  02h      2     смещение от начала файла по которому лежит Image Activation 
                 Information.

  04h      2     смещение от начала файла по которому лежит 
                 Global Symbol Table & Debug Symbol Table Information

  06h      3     смещение от начала файла по которому лежит Image 
                 Identification Information

  09h      1     Patch Information. 00 - nope information, 1 - have info.

  0ah      2     Если не 0000h, то заголовок считается битым.
  0ch      2     Ident string: major id. тип файла. (обычно 3032h - 02)
  0eh      2     Ident string: minor id. тип файла. (обычно 3035h - 05)
  14h      8     n/a. можно любой хлам.
  
  1ch      2     I/O channel count (если 0000,то default)
  1eh      2     I/O page count (если 0000,то default)
  
  20h      1     linker flags:  bits     description

                                 0     IHD$V_LNKDEBUG   
                                 1     IHD$V_LNKNOTFR   
                                 2     IHD$V_NOP0BUFS   
                                 3     IHD$V_PICIMG     
                                 4     IHD$V_P0IMAGE    
                                 5     IHD$V_DBGDMT     
                                 6     IHD$V_INISHR     
                                 7     IHD$V_IHSLONG    
                                 8     IHD$V_UPCALLS    

  21h      2     зарезервированные 2 байта для будущего использования флагов.
  23h      2     hz
  25h      1     смещение от начала файла по которому лежит system version. 
  26h      2     hz
  28h      3     system version (minor)
  2bh      1     system version (major)
  2ch      4     hz

;----------------------------------------------------------------------------

 Заголовок секции (от 12 до 66 байт): 

;----------section headers information---------------------------------------

  00h     2      размер заголовка секции
  02h     2      page count 
  04h     3      адрес секции (записывается в количество блоков от начала). 
		 т.е. минимальное значение 00 = 1 блок (512 байт от начала)
 	         именно по этому файл ниже 512 байт нам не сделать)
  07h     1      page fault cluster size (0=default)
  08h     1      flags 
  09h     2      reserved flags
  0bh     1      тип секции:      00 - ISD$K_NORMAL
                                  01 - ISD$K_SHRFXD
	                          02 - ISD$K_PRVFXD
                                  03 - ISD$K_SHRPIC
                                  04 - ISD$K_PRVPIC 
			          05 - n/a (invalid type)
                                  FD - ISD$K_USRSTACK

  0ch    4       base VBN
  
  10h    3       global section minor id
  13h    1       global section major id
  14h    1       размер имени глобальной секции. (максимум 2b(43))
  15h   <43      имя глобальной секции.
 
 + при появлении в секции последнего поля, необходимо завершать секцию 00 00.
    
;----------------------------------------------------------------------------

 
  После отрезания всего-того, о чем я сказал выше, мы получаем 512 обязательных
 байт под первый блок (т.к. код может быть не ниже 512), и далее чисто машинный
 код.Можно в принципе делать переход в первый блок image header где у нас прак-
 тически 70% может быть  использовано (на дампе это 'a' символы), но это  будет
 проблематично. При попытке  полезть раньше чем за 512 байт без  дополнительных
 заголовков (которые адресуют секции поблочно,что тоже проблема) мы получим со-
 ответствующие  ошибки. Проблему  эту (организацию  файл-структуры более ;) уже 
 нужно обходить на системном уровне, для чего нужны конечно максимальные приви-
 легии. В любом  случае - мы получаем  всегда первый блок обязательно, а дальше 
 ровно столько сколько напишем (и смотря как напишем).

 $ dump/width=80/page test.exe

 Virtual block number 1 (00000001), 512 (0200) bytes

 35303230 00000000 00600044 003000B0 ╟.0.D.`.....0205 000000
 00000000 61616161 61616161 00000101 ....aaaaaaaa.... 000010
 61616161 00000000 61612861 610000A8 ╗..aa(aa....aaaa 000020
 61616161 00000000 00000200 7FFEDF68 hъЧ.........aaaa 000030
 61616161 61616161 61616161 61616161 aaaaaaaaaaaaaaaa 000040
 61616161 61616161 61616161 61616161 aaaaaaaaaaaaaaaa 000050
 61616161 61616161 61616161 61616161 aaaaaaaaaaaaaaaa 000060
 61616161 61616161 61616161 61616161 aaaaaaaaaaaaaaaa 000070
 61616161 61616161 61616161 61616161 aaaaaaaaaaaaaaaa 000080
 61616161 61616161 61616161 61616161 aaaaaaaaaaaaaaaa 000090
 61616161 61616161 61616161 61616161 aaaaaaaaaaaaaaaa 0000A0
 00000002 0000008A 00000001 00010010 ................ 0000B0
 0109001F FD00008C 003FFFEC 0014000C ....Л.?....Щ.... 0000C0
 0100000E 00000000 03000021 00000000 ....!........... 0000D0
 61616100 00313030 5F4C5452 42494C0A .LIBRTL_001..aaa 0000E0
 61616161 61616161 61616161 61616161 aaaaaaaaaaaaaaaa 0000F0
 61616161 61616161 61616161 61616161 aaaaaaaaaaaaaaaa 000100 
 61616161 61616161 61616161 61616161 aaaaaaaaaaaaaaaa 000110
 61616161 61616161 61616161 61616161 aaaaaaaaaaaaaaaa 000120
 61616161 61616161 61616161 61616161 aaaaaaaaaaaaaaaa 000130
 61616161 61616161 61616161 61616161 aaaaaaaaaaaaaaaa 000140
 61616161 61616161 61616161 61616161 aaaaaaaaaaaaaaaa 000150
 61616161 61616161 61616161 61616161 aaaaaaaaaaaaaaaa 000160
 61616161 61616161 61616161 61616161 aaaaaaaaaaaaaaaa 000170
 61616161 61616161 61616161 61616161 aaaaaaaaaaaaaaaa 000180
 61616161 61616161 61616161 61616161 aaaaaaaaaaaaaaaa 000190
 61616161 61616161 61616161 61616161 aaaaaaaaaaaaaaaa 0001A0
 61616161 61616161 61616161 61616161 aaaaaaaaaaaaaaaa 0001B0
 61616161 61616161 61616161 61616161 aaaaaaaaaaaaaaaa 0001C0
 61616161 61616161 61616161 61616161 aaaaaaaaaaaaaaaa 0001D0
 61616161 61616161 61616161 61616161 aaaaaaaaaaaaaaaa 0001E0
 FFFF6161 61616161 61616161 61616161 aaaaaaaaaaaaaa.. 0001F0

 Virtual block number 2 (00000002), 512 (0200) bytes

 00000000 00000000 00000455 01D00000 ..п.U........... 000000  movl #1,r5 + ret
 ...........................................................
 00000000 00000000 00000000 00000000 ................ 0001F0
 
 ctrl+c

 $ run test.exe
 $
 $ run/debug test.exe

 ops,ops not have gdt/map/etc/etc

          OpenVMS VAX Debug Version V7.2-019


 DBG> examine r5,pc
 0\%R5:  0
 0\%PC:  514
 DBG> s
 stepped to SHARE$TEST+5
 DBG> examine r5,pc
 0\%R5:  1
 0\%PC:  517
 DBG> s
 %DEBUG-I-EXITSTATUS, is '%NONAME-W-NOMSG, Message number 00000000'
 DBG> examine r5,pc
 0\%R5:  1
 0\%PC:  0
 DBG>
 DBG> exit
 $
 
 
 Раз речь коснулась дебагера, то самое время поговорить о ассемблере. Ассемблер
 используемый по умолчанию в openvms зовется 'macro'.  macro32 и macro64 - вер-
 сии под vax и alpha соответственно. Эта статья ориентирована на vax процессор,
 поэтому речь пойдет о соответствующем асме. Процессор имеет 16 регистров:

 с r1 по r11  - регистры общего назначения
 r12 или AP   - аргументный указатель. если использовать как регистр общего
                назначения то лучше использовать r12,если как указатель,то AP
 FP           - фрэймовый указатель
 SP	      - стэковый указатель
 PC           - программный указатель
 
 Банальный print с использованием библ будет выглядеть так:
 
 ; $ macro test.s
 ; $ link test.obj
 ; $ run test

 .entry start , ^m<>                    ; точка входа без сохранения регистров
         pushaq  s1                     
         calls   #1, g^lib$put_output   ; вызов
         ret
 s1:     .ascid  /x25zine#3/
 .end start


  Объяснять тут нечего, разве что  сказать, что lib$put_output использует далее
 decc$dprintf. print это  конечно круто, но более интересны возможности перехо-
 дов в кернел и прочее.Вот самый простой способ перехода (естевственно для него
 нужны привелегии cmkrnl):

 .entry i_want_to_kernel,^m<>           
        $cmkrnl_s -                 ; переключение в kernel mode.
               routin=super_code    ; наш супер код.
        ret                         ; выход.

 ; нижеследующий код уже исполняется в kernel mode

 .entry super_code,^m<>

        movl #1,r1 
        movl #1,r2                  ; супер code ;)
        movl #1,r3
        ret 
        $exit_s

 .end i_want_to_kernel


 Вот в принципе и все.На последок лишь расскажу один прикольный момент: cистем-
 ные часы в openvms тикают c 17 ноября 1858 года. Не  сложными подсчетами, зная 
 modified julian day и прочее,получается,что часы будут шагать до 31 июля 31086
 года ж)


 Cсылки:
 
 [1] VAX MACRO and Instruction Set Reference Manual
 [2] Guide to OpenVMS File Appilcation
 [3] OpenVMS Linker Utility Manual


