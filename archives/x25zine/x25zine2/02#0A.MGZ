
   ,g@S$$$$$S@g,  srb ;22222iiiiii;;;;
  J$$┘^````^┘$$$i $S@ i$$$$$$$$$$$$$$$   x25 zine. issue II. april 16/04/2002
 :$$[        i$$2 $$$ 2$$$$$$$$$$$$$$$ ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 `^^"       ,$$$' $$$ $$$$$$$$$$$$$$$$
         ,g$$$┘`, $$$ SSSSSSSSSSSS$╡$$
      ,g$$$┘`,g$$ $$$qqqqqqqqqqqq╖, ╘$   Пишем сканер на не блокирующих сокетах
   ,g$$$┘`,g$$$$$ $$$$$$$$$$$$$$$$$$,`                  Free_Hunt
  J$$┘`,g$$$$$$$$                `$$$    -------------------------------------
 i$2; $$$$$$$$$$$ %%%%%%%%%%%%%%%$$$7
 ```` """"""""""" $$$$$$$$$$$$$$$7╛'
 2@%/
 $$$2  Да  да,  и  мы решили написать на эту уже надоевшую всем тему сканеров-)
 $$$2  Но   не   пугайтесь,   здесь   будет   представлен  не один из вариантов
 $$$2  сканеров,  которых  в  сети  до кучи,  а очень шустрый сканер,работающий
 $$$2  в  рамках одного процесса,  но тем не менее не уступающий, а иногда даже
 $$$i  превосходящий сканеры использующие мультипоточность.
 $$$i  Итак,  к  делу.  Все  знают как работают сканеры, они вызывают системную
 $$$;  функцию   connect  и  ждут,  когда  она  завершиться,  либо  с  ошибкой,
 $$$;  либо  произойдет   соединение,и   далее   в   этот  сокет  в  дальнейшем
 $$$.  можно   будет  записывать   данные   для   передачи  по  сети. При этом,
 $$$.  программе  приходиться  ждать   пока   установиться  соединение,  что не
 $$$   есть  хорошо.  А  особенно,  если вызываемый  адрес  и  порт  не ответит
 $$$   вообще  (т.е.  ваш  Syn пакет дропнится где-нибудь  на брендмауре), ядро
 $$$   будет  ждать  установления соединения, иногда до   нескольких   десятков
 $$$   минут,    а    самое    плохое,  что  этот  таймаут устанавливается  при
 $$$   компиляции  ядра  и  никакими  программными средствами его не  изменить.
 $$$   Конечно,   можно  использовать сигналы, для выхода из процесса ожидания,
 $$$   но  это  не  красиво,  а  также при большом количестве соединений весьма
 $$$   сложно в реализации.
 ```
 ,,,
 $$$   Однако,  для устранения этих и других всевозможных проблем,  связанных с
 $$$   механизмом   сокетов,  придумали  так  называемые  опции  сокета,  среди
 $$$   которых  есть    и    необходима    нам    опция    NON-BLOCK,   которая
 $$$   переводит   сокет в  не блокирующий  режим  работы. Что это значит ? Это
 $$$   значит, что при вызове каких-либо  функций соединения, записи или чтения
 $$$   на данном сокете, программа не  будет  ждать  завершения соответствующей
 $$$   операции,  а  продолжит  выполнение дальше.  При  этом  функция  connect
 $$$   завершиться  с  ошибкой  EINPROGRESS,  что,  на  самом деле, не является
 $$$   ошибкой,  а  лишь индикатором того, что соединение еще  не  установлено.
 $$$   В   дальнейшем   мы   можем  проверить  состояние  сокета,  на   предмет
 $$$   произошло    ли   соединение  или  возможно  ли  чтение\запись  в  сокет
 $$$   используя   функцию   FD_ISSET,   которая   возвращает состояние сокета,
 $$$   то  есть,  готов    ли   он   к   записи\чтению   данных,   такому,  что
 $$$   программа    не   будет  приостановлена,а    данные,    из    системного
 $$$   буфера   премника\отправителя передадутся  программе  в  функцию  чтения
 $$$   или может быть произведена запись в сокет.
 ```

 ,,,
 $$$   Используя  этот  метод,  мы можем в  одной  програме\процессе  создавать
 $$$   множество  не блокирующих сокетов и просто отслеживать их состояние, что
 $$$   будет    очень    производительно    по   скорости,   так   как   задача
 $$$   распараллеливается   между  кол-вом  используемых  сокетов  и  при  этом
 $$$   не требуется вмешательство ядра,для управления  кучей   нитей\процессов,
 $$$   как  было  бы  если бы мы использовали мультипоточность\мультизадачность
 $$$   (а  кроме   того,  не  будет  офигевших глаз у  админа  после  просмотра
 $$$   результата команды ps, в котором он увидит кучу левых процессов =) ).
 ```

 ,,,
 $$$   Рассмотрим  пример.  Полный  исходный код можно найти  в  бонусе.  Сразу
 $$$   скажу  что  идея  и  местами  реализация была почерпнута мной из сканера
 $$$   grinder (под win32),который сканировал диапазоны на наличие веб-серверов
 $$$   и  выводил их версию, написанный групой rhino9.
 ```


/*
                Simple Scanner on NONblocking sockets.
                                <c> Free_Hunt

compile: gcc portscan.c -o portscan
*/

#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <err.h>
#include <errno.h>
#include <unistd.h>
#include <netdb.h>
#include <stdio.h>
#include <fcntl.h>

int MS=50;  //Number of Sockets to use.

main (int argc, char *argv[])
{

//структура позволяющая нам следить за состояниями сокетов,
//времени соединения каждого сокета, и удаленного порта, к которому
//присоединен данный сокет(и если будут сканироваться разные ip адреса,
//адрес удаленной системы тоже надо будет добавить)

        struct usock_descr{
                int s;                     // socket
                int state;                 // current socket state
                long timestamp;            // time, when sockets open in ms.
                unsigned short remoteport; // remote port
        };
        struct usock_descr sockets[MS];

        fd_set rfds, wfds;
        unsigned long start;
        struct hostent *nametocheck;
        struct sockaddr_in serv_addr;
        struct in_addr attack;
        struct timeval tv={0,0};
        char data[1024];
        int flags, max_fd ;
        int k,i,j,JB,JE,readb;
        int MAXTIME;


        if(argv[1] != NULL){start=inet_addr(argv[1]);} else usage();
        if(argv[2] != NULL){JB=atoi(argv[2]);} else usage();
        if(argv[3] != NULL){JE=atoi(argv[3])+1;} else usage();
        if(argv[4] != NULL){MAXTIME=atoi(argv[4]);} else usage();

        memset (&serv_addr, 0, sizeof (serv_addr));
        serv_addr.sin_family=AF_INET;
        serv_addr.sin_addr.s_addr = htonl(ntohl(start));
//всем сокетам установливаем 0 состоояние,т.е сокет не создан
        j=JB;for (i=0;i<MS;i++){sockets[i].state=0;};

        printf("Scan - scanner on NONblock sockets.\nRunning...\n");
        k=1;
//пока не все порты просканены и результаты получены, работает главный цикл.
    while((j<JE)||(k==1)){
//для каждого сокета, если не все порты еще просканированы, создаем сокет
//устанавливаем его в не блокирующий режим и присваиваем
//состояние 1 (не блокирующий сокет создан)
         for (i=0;(i<MS) && (j<JE);i++){
               if (sockets[i].state==0) {
                    if((sockets[i].s = socket (AF_INET, SOCK_STREAM,
                    IPPROTO_TCP))==-1){printf("error in socket %d\n",errno)
                    ;return 1;};
                    flags = fcntl(sockets[i].s, F_GETFL, 0);
                    if(fcntl(sockets[i].s, F_SETFL, flags | O_NONBLOCK) == -1)
                    {printf("error in NONBLOCK set\n");return 1;};
                    sockets[i].state=1;
               }
          };


          for (i=0;(i<MS) && (j<JE);i++){
//проверка существования сокетов и если есть сокеты в состоянии 1 пытаемся
//соединить данный сокет с удаленным портом при этом работа программы продолжа-
//еться ,а не преостанавливается
                if (sockets[i].state==1) {
                    serv_addr.sin_port = ntohs(j);
//выполняем функцию connect если она завершилась с ошибкой анализируем
//с какой именно.
//иначе соединение произошло за время системного вызова те порт открыт,
//а данный сокет переводим
//в состояние 3 готов для записи\принятия данных
                    if(connect (sockets[i].s, (struct sockaddr *)&serv_addr,
                    sizeof (serv_addr))==-1)  {
//если сокет не в состоянии ожидания соединения, значит произошла ошибка
//следует закрыть
//сокет и состояние обнулить иначе сокет в ожидании соединения те в состоянии 2

                            if(errno != EINPROGRESS)
                              {
//                                printf("error in connecting(not einproress)
                                  port: %d\terrno:%d\n",j,errno);
                                  shutdown(sockets[i].s,2);
                                  close(sockets[i].s);
                                  sockets[i].state=0;
                              }
else{sockets[i].state=2;};
                    }
//
                    else
                      {
                         printf ("CONNECT %d \n",j);
                         sockets[i].state=3;
                      }
;
//запоминаем время когда произошел запрос на соединение
//и порт, к которому мы пытаемся приконнектить наш сокет
                    sockets[i].timestamp=time(NULL);
                    sockets[i].remoteport=j;
//выбираем следующий  порт для скана
                    j++;
                };
          };
//обнуляем множества дескрипторов
          FD_ZERO(&rfds);
          FD_ZERO(&wfds);
          max_fd = -1;

          for (i=0;i<MS;i++){
//если сокет в состоянии ожидания соединения помещаем его в соответствующие
//множества дескрипторов для последующей проверки

                if (sockets[i].state==2) {
                       FD_SET(sockets[i].s, &wfds);
                       FD_SET(sockets[i].s, &rfds);
                       if(sockets[i].s > max_fd) max_fd = sockets[i].s;
                };
          };
//проверяем состояние сокетов
          select(max_fd + 1, &rfds, &wfds, NULL, &tv);

          for (i=0;(i<MS);i++){
               if (sockets[i].state==2) {
//смотрим есть ли данный сокет во множестве дескрипторов, которые готовы для
//записи или чтения
                      if(FD_ISSET(sockets[i].s, &wfds) || FD_ISSET(sockets[i]
                      .s, &rfds))
                      {
                              socklen_t err_len;
                              int error;
                              err_len = sizeof(error);
//если есть проверяем не произошла ли ошибка соединения , если произошла
//на сокете будет установлен флаг SO_ERROR
                              if(getsockopt(sockets[i].s, SOL_SOCKET,
                              SO_ERROR, &error, &err_len) < 0 || error != 0)
                                    {
//произошла ошибка при соединении , закрываем сокет и обнуляем его состояние
//                                  printf("error in connecting-
                                    getsocksopt %d\n",sockets[i].remoteport);
                                    shutdown(sockets[i].s,2);
                                    close(sockets[i].s);
                                    sockets[i].state=0;
                                    }
                                             else
                                             {
//если ошибки нет, а сокет готов для чтения или записи значит соединение
//успешно установленно и сокет переводим в состояние 3 готовности к передачи.
                                                  printf ("CONNECT %d \n",
                                                  sockets[i].remoteport);
                                                  sockets[i].state=3;
                                             };
                      }
                      else
//если сокет не готов для чтения или записи проверяем, как долго он в таком
//состоянии
//и если слишком долго (истек таймаут в секундах указанный в командной строке)
//закрываем сокет с обнулением состояния
                      { if ( (time(NULL)-sockets[i].timestamp) > MAXTIME)
                                       {
//                                     printf("error in connect - timeout\n");
                                       shutdown(sockets[i].s,2);
                                       close(sockets[i].s);
                                       sockets[i].state=0;
                                       };
                      };
               };
          };

//state 3         -------------------------------------------
//смотрим какие сокеты в состоянии 3 и проверяем готовы ли они к приему данных
          FD_ZERO(&rfds);
          max_fd = -1;

          for (i=0;i<MS;i++){
                if (sockets[i].state==3){
                       FD_SET(sockets[i].s, &rfds);
                       if(sockets[i].s > max_fd) max_fd = sockets[i].s;
                };
          };

          select(max_fd + 1, &rfds, NULL, NULL, &tv);

          for (i=0;(i<MS);i++){
               if (sockets[i].state==3) {
                      if(FD_ISSET(sockets[i].s, &rfds))
                      {
                              socklen_t err_len;
                              int error;
                              err_len = sizeof(error);
                              if(getsockopt(sockets[i].s, SOL_SOCKET,
                              SO_ERROR, &error, &err_len) < 0 || error != 0)
                                             {
                                                  shutdown(sockets[i].s,2);
                                                  close(sockets[i].s);
                                                  sockets[i].state=0;
                                             }
                                             else
                                             {
//сокет готов к чтению т.е. можно безболезненно выполнить функцию чтения,
//не боясь,что это приостановит выполнение прорграммы
                             printf("read data %d \n",sockets[i].remoteport);
                             memset(data,0,sizeof(data));
                             readb=read(sockets[i].s,&data,1024);
//а все ли данные мы получили ? не меняем состояния
                                                  printf("%s\n",&data);
                                                  sockets[i].state=3;
//если мы прочитали 0 байт, значит все данные получены и можно переходит
//в состояние 4 запись в сокет.
                                                  if (readb==0){
                                                  sockets[i].state=4;

                                                      };
                                             };
                      }
                      else
//Если не готов сокет для чтения за время таймаута, значит возможно что
//удаленна сторона не передает данные, а ждет данных от нас, переводим
//сокет в состояние 4
                      { if ( (time(NULL)-sockets[i].timestamp) > MAXTIME)
                                       {
                                                  sockets[i].state=4;
                                       };
                      };
               };
          };
//state 4
// смотрим какие сокеты в состоянии 4 проверяем готовы ли они к записи  данных

          FD_ZERO(&wfds);
          max_fd = -1;

          for (i=0;i<MS;i++){
                if (sockets[i].state==4) {
                       FD_SET(sockets[i].s, &wfds);
                       if(sockets[i].s > max_fd) max_fd = sockets[i].s;
                };
          };

          select(max_fd + 1, NULL, &wfds, NULL, &tv);

          for (i=0;(i<MS);i++){
               if (sockets[i].state==4) {
                      if(FD_ISSET(sockets[i].s, &wfds))
                      {
                              socklen_t err_len;
                              int error;
                              err_len = sizeof(error);
                              if(getsockopt(sockets[i].s, SOL_SOCKET,
                              SO_ERROR, &error, &err_len) < 0 || error != 0)
                                             {
                                                  shutdown(sockets[i].s,2);
                                                  close(sockets[i].s);
                                                  sockets[i].state=0;
                                             }
                                             else
                                             {
//если сокет готов к записи, записываем , не боясь приостановления программы
//и переводим сокет в состояние 5,в котором опять принимаем данные
                            printf("write data %d \n",sockets[i].remoteport);
                            write(sockets[i].s,"test\n",5);
                            sockets[i].state=5;
                                             };
                      }
                      else
//если запись так и не удалась за время таймаута закрываем сокет и обнуляем
//его состояние

                      { if ( (time(NULL)-sockets[i].timestamp) > MAXTIME)
                                       {
                                          shutdown(sockets[i].s,2);
                                          close(sockets[i].s);
                                          sockets[i].state=0;
                                       };
                      };
               };
          };

//state 5         -------------------------------------------
//смотрим какие сокеты в состоянии 5 и проверяем готовы ли они к еще одному
//приему данных


          FD_ZERO(&rfds);
          max_fd = -1;

          for (i=0;i<MS;i++){
                if (sockets[i].state==5){
                       FD_SET(sockets[i].s, &rfds);
                       if(sockets[i].s > max_fd) max_fd = sockets[i].s;
                };
          };

          select(max_fd + 1, &rfds, NULL, NULL, &tv);

          for (i=0;(i<MS);i++){
               if (sockets[i].state==5) {
                      if(FD_ISSET(sockets[i].s, &rfds))
                      {
                              socklen_t err_len;
                              int error;
                              err_len = sizeof(error);
                              if(getsockopt(sockets[i].s, SOL_SOCKET,
                              SO_ERROR, &error, &err_len) < 0 || error != 0)
                                             {
                                                  shutdown(sockets[i].s,2);
                                                  close(sockets[i].s);
                                                  sockets[i].state=0;
                                             }
                                             else
                                             {
//читаем данные, и если неудача, закрываем сокет и обнуляем состояние, иначе
//пробуем прочитать опять, переведя его в состояние 5
                                         memset(data,0,sizeof(data));
                                         readb=read(sockets[i].s,&data,1024);
                                         if (readb<1){
                                         shutdown(sockets[i].s,2);
                                         close(sockets[i].s);
                                         sockets[i].state=0;
                                         }else{
                              printf("read data %d \n",sockets[i].remoteport);
                                          printf("%s\n",&data);
                                                       };
                                                  sockets[i].state=5;
                                             };
                      }
                      else
                      { if ( (time(NULL)-sockets[i].timestamp) >2*MAXTIME)
                                       {
                                          shutdown(sockets[i].s,2);
                                          close(sockets[i].s);
                                          sockets[i].state=0;
                                       };
                      };
               };
          };
//чтоб наш цикл не завершился раньше, чем получены все результаты
//проверяем состояние сокетов
          k=0;
          for (i=0;(i<MS);i++){if(sockets[i].state>1){k=1;};};
    };

        printf("End.\n");
return 0;
};


int usage()
{
printf("Syntax:  portscan <ip> <port_begin> <port_end> <timeout in sec>\n");
printf("Example: ./portscan 127.0.0.1 80 139 5\n");
exit(1);
}

 ,,,
 $$$   Этот  порт  сканер, с функциями чтения баннеров, записи в открытый  порт
 $$$   строки   "тест"   и  получением  ответа  далеко  не  идеальный,  и  вряд
 $$$   ли  применимый  для   практических   задач, но я думаю, что теперь у вас
 $$$   достаточно  знаний  или  желания  узнать  все подробнее, чтоб переделать
 $$$   его  под  то,  что требует ваши нужды,  например  под эффективный сканер
 $$$   диапазонов  на  открытые  определенные  порты,  эффективность  которого,
 $$$   будет   не   хуже   nmap.   Или   заточить, под выполнение  определенных
 $$$   нужд   брутефорса,  который  будет очень эффективным, ведь  одновременно
 $$$   в   одном процессе будет проверяться несколько паролей или чего бы то ни
 $$$   было,  кол-во которых будет зависеть от количества используемых сокетов.
 $$$   Думаю   различные   модификации   данного   сканера   будут   вам  очень
 $$$   полезны.   В   любом   случае,  эта статья не претендует на полноту, или
 $$$   100%-ую   точность   в   определениях,   так  что,  кто  заинтересовался
 $$$   в написании подобных вещей, бегом читать маны и удачи в кодинге !;)
 $$$
 $$$!ig╖,_
 `|¤??$╡$$$A.
  .╖. `¤$$$L
,$$$$$$$, `$$$i
$$$$$$$$$  i$$$
?$$$$$$$7  $$$$qqqqqqqqqqqqq q   q
 `¤+?+¤` .╡$$$$$$$$$$22222222222 2  2   2   ;   ;    ;       ;
        ````````````````` `  `