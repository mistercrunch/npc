
   ,g@S$$$$$S@g,  srb ;22222iiiiii;;;;
  J$$┘^````^┘$$$i $S@ i$$$$$$$$$$$$$$$   x25 zine. issue II. april 16/04/2002
 :$$[        i$$2 $$$ 2$$$$$$$$$$$$$$$ ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 `^^"       ,$$$' $$$ $$$$$$$$$$$$$$$$
         ,g$$$┘`, $$$ SSSSSSSSSSSS$╡$$         ********************************
      ,g$$$┘`,g$$ $$$qqqqqqqqqqqq╖, ╘$         ***          Q.n.X           ***
   ,g$$$┘`,g$$$$$ $$$$$$$$$$$$$$$$$$,`         ********************************
  J$$┘`,g$$$$$$$$                `$$$                                     madcr
 i$2; $$$$$$$$$$$ %%%%%%%%%%%%%%%$$$7
 ```` """"""""""" $$$$$$$$$$$$$$$7╛'
 2@%/
 $$$2
 $$$2       0 ............................... Introduction
 $$$2       1................................ Что такое QnX. Cеть QnX.
 $$$i       2................................ Файловая система QnX.
 $$$i       3................................ Формат lmf (load module format).
 $$$;       4................................ QnX programming.
 $$$.
 ```
 ,,,
 $$$   0. Introduction.
 $$$
 $$$   Желание  написать подобного  рода статью росло довольно  продолжительное
 $$$   время и только теперь я решил это сделать . QnX сама  по себе оставалась
 $$$   довольно  неизведанной  OS в связи с тем, что не являлась freeware. Хотя
 $$$   freeware и не freeware - для русского человека только пустой звук,многих
 $$$   ленивых (зачастую умных?) людей, это останавливает. К тому же QnX не так
 $$$   сильно распространена и развита , как  возможно  кому-то хотелось бы (та
 $$$   пресловутая дискетка "уместим все" - была хорошей попыткой). Также  есть
 $$$   один интересный момент : до определенного  времени продажа QnX в  Россию
 $$$   была запрещена. Теперь этой проблемы нет.
 $$$   Некоторое время назад вышла официальная  freeware версия QnX - real time
 $$$   platform  (rtp - гибрид QnX neitrino) , но к сожалению она не имеет сов-
 $$$   местимости с QnX 4.2X файлами. (Кстати поддержка 4.2X официально прекра-
 $$$   щена QSSL в пользу RTP (но все же кое-какие патчи иногда выходят)).
 $$$   Здесь я буду в основном опираться на 4.2x, по своим личным соображениям.
 $$$   К тому же ОЧЕНЬ глобальной разницы нет.При желание все это можно преспо-
 $$$   собить и под RTP.
 ```
 ,,,
 $$$   1. Что такое QnX.
 $$$
 $$$   Итак, что же такое QnX ? QnX - это os реального времени. Частая фраза :)
 $$$   Только не многие понимают в чем же ее "реальность".Ее реальность в испол
 $$$   нении действий в четкие сроки. Сказали - сделай.Не зависимо от того сде-
 $$$   лается или нет: если не уложилось в четкий срок - извините. Конечно пре-
 $$$   дел времени может быть изменяем,но предел всегда будет. Сама OS является
 $$$   полно-функциональной, многозадачной,многопользовательской 32-битной сис-
 $$$   темой имеющая микроядро,размером всего около 10 kb! В остальных OS отлич
 $$$   ных от QnX, бедные ядра так нагружены, что они уже сами начинают из себя
 $$$   представлять операционную систему, а не ядро ;) В qnx же ядро  исполняет
 $$$   всего 2 задачи: планирование и передачу сообщений. Само ядро не планиру-
 $$$   ется(!), а взаимодействие с ним идет посредством процессов (с одинаковы-
 $$$   ми "правами"):
 $$$
 $$$                         ┌───────┐         ┌───────┐
 $$$                         │  net  │         │  dev  │
 $$$                         └──────┬┘         └┬──────┘
 $$$                               ┌┴───────────┴┐
 $$$                               │ microkernel │
 $$$                               └┬───────────┬┘
 $$$                        ┌───────┴┐         ┌┴───────┐
 $$$                        │  proc  │         │  fsys  │
 $$$                        └────────┘         └────────┘
 $$$
 $$$   Все функции (за исключением функций ядра) реализуются этими 4-мя систем-
 $$$   ными процессами которые можно представить как 4-pех 'китов-админов'. Эти
 $$$   процессы ничем не отличаются от обычных юзерских процессов и именно  это
 $$$   обеспечивает  QNX легкую  расширяемость  неограниченных размеров . Также
 $$$   очень неплохую мощность и элегантность QNX получила за счет IPC (который
 $$$   основан на принципе передачи сообщений,и кстати сказать QNX в этом плане
 $$$   стала первой коммерческой осью данного класса).
 ```
 ,,,
 $$$   QNX изначальна разрабатывалась как сетевая операционная система. И здесь
 $$$   стоит сделать остановку на идее. Идея в том, что сеть под QNX - это один
 $$$   большой организм! Реализован этот 'организм'(даже лучше сказать мозг) за
 $$$   счет большого количества ресурсов доступных в любой момент и любому при-
 $$$   ложению.Т.е.например на одной машине в сети идет очень сильная нагрузка,
 $$$   а другая 'халявит/простаивает' занимаясь обработкой какого нить текстика
 $$$   ,этот 'мозг' распараллелит все ресурсы именно так - как это нужно.Сколь-
 $$$   ко и кому необходимо, и в какой момент. Программная  реализация QNX сети
 $$$   написана довольно грамотно и можно сказать,что 'сеть QNX' довольно реак-
 $$$   тивна, чтобы все знать и везде успеть.
 $$$   У каждой машины в сети под управлением QnX есть свой id. Именно этот  id
 $$$   позволяет понимать - работает QnX как сеть или как однопроцессорная сис-
 $$$   тема. (здесь я имею ввиду логические id, т.к. есть еще и аппаратные (это
 $$$   те самые MAC-адреса если говорить только об ethernet картах)).
 $$$   Один из 4тырех китов-админов (net)  как и понятно  из слова призван  для
 $$$   работы с сетью. В частности он расширяет возможности QNX в области пере-
 $$$   дачи сетевых сообщений и IPC. Далее я думаю будет намного лучше почитать
 $$$   стандартные guide идущее в комплекте с QNX по networks.
 ```
 ,,,
 $$$   Переходя к файловой системе стоит добавить , что  официальный компилятор
 $$$   под QNX - это watcom c++. Соответственно и ассемблер - WASM. Другое пос-
 $$$   тавить тоже можно,но это уже история для отдельных статей.
 ```
 ,,,
 $$$   2. Файловая система QnX.
 $$$
 $$$   Поплотнее рассмотрим fsys.fsys - это и есть 'админ' файловой системы ко-
 $$$   торый ответственен за обработку разного рода запросов (чтение , запись ,
 $$$   открытие и тд). Этот 'админ' работает с разными типами файлов: regular ,
 $$$   catalog,symbol links,pipe, fifo). Он не работает т олько с одним типом -
 $$$   special  symbol file. С ним уже работает  админ 'dev'. Чем все  эти типы
 $$$   различаются - тоже лучше читать документацию. Доступ - примерно как и  в
 $$$   unix. (кстати совместимость с unix за счет поддержки POSIX (1003.1,1003.
 $$$   2)). Группа, пользователь, любой пользователь. Тотже setuid/setgid и тд.
 $$$   Сама файловая система очень живучая. Эта живучесть достигается  несколь-
 $$$   кими путями. Например при записи чего-то , критические для системы файлы
 $$$   - записываются немедленно , а некритические проходят специальный кэш-бу-
 $$$   фер (возникает небольшая задержка, которую конечно человеку уловить неп-
 $$$   росто) и только после этого записываются. Довольно хороший подход.Но ба-
 $$$   ги бывают везде , и супер надежного ничего нет. Поэтому с осью идет ути-
 $$$   литка chkfsys ;) Разделы QNX представляют  из себя набор  нижеследующего
 $$$   (это так сказать основа файловой системы QnX):
 $$$
 $$$   -блок загрузчика   '1
 $$$   -корневой блок     '2
 $$$   -битовая карта     '3
 $$$   -корневой каталог  '4
 $$$
 $$$   С первым все понятно. Первый , физический либо раздела либо блока винта,
 $$$   bios читает, и так далее. Второй уже более  интересен. Корневой блок - в
 $$$   нем лежит информация о 4-ех системных файлах:
 $$$
 $$$   / - корневой каталог
 $$$   /.inodes  -
 $$$   /.boot    -   образы осей которые могут быть
 $$$   /.altboot -   загружены при первых шагах bios
 $$$
 $$$
 $$$   Битовая карта - файл /.bitmap , который содержит все блоки диска ,каждый
 $$$   из которых представлен битом. Если 1 - блок юзается,если 0 - не юзается.
 $$$   И корневой каталог - это обычный каталог , который отличается от осталь-
 $$$   ных догадайтесь чем (по аналогии с unix).
 ```
 ,,,
 $$$   3. Формат lmf (load module format).
 $$$
 $$$   Довольно продолжительное время назад , я общался с неким andrew_golovnia
 $$$   (автором biew (более навороченный аналог hiew под  qnx) , который меня и
 $$$   просветил относительно lmf:
 $$$
 $$$   Весь файл разбит на секции. У каждой секции есть заголовок
 $$$   (struct _lmf_header) - тип записи и длинна после заголовка.
 $$$   Типы записей:
 $$$   _LMF_DEFINITION_REC - заголовок lmf-файла (см. ниже);
 $$$   _LMF_COMMENT_REC - запись комментариев (ни разу не видал ее);
 $$$   _LMF_DATA_REC - запись содержащая данные (код и данные сегментов);
 $$$   _LMF_FIXUP_SEG_REC - запись содержащая исправленные данные (код и данные
 $$$   сегментов);
 $$$   _LMF_FIXUP_80X87_REC - запись адреса операций с плавающей точкой (?);
 $$$   _LMF_EOF_REC - запись после которой ничего не рассматривается в файле
 $$$   (КОНЕЦ);
 $$$   _LMF_RESOURCE_REC - ресурсы;
 $$$   _LMF_ENDDATA_REC - запись с лицензией(как она зашифрована пока не знаю);
 $$$   _LMF_FIXUP_LINEAR_REC - (?);
 $$$   _LMF_PHRESOURCE_REC - (?).
 ```
 ,,,
 $$$   Заголовок lmf-файла содержит структуру  _lmf_definition и массив longint
 $$$   -ов - длин сегментов . Если ставшие 4 разряда каждой длинны сегмента со-
 $$$   держат код _LMF_CODE-сегмент кода.В поле cflags содержатся флаги _PCF_*.
 $$$
 $$$   Записи _LMF_DATA_REC,  _LMF_FIXUP_SEG_REC и, возможно, _LMF_FIXUP_LINEAR
 $$$   _REC содержат запись _lmf_data (и др.). В оной содержится индекс сегмен-
 $$$   та и смещение в теле сегмента. После этого  идет _lmf_header.data_nbytes
 $$$   -sizeof(struct _lmf_data) байт сырых данных,  которые записываются в сег
 $$$   мент с индексом _lmf_data.segment_index...
 ```
 ,,,
 $$$   4. QnX programming.
 $$$
 $$$   Поставив tcp/ip пакет со всем,чем нужно мы имеем привычное сокетное пред
 $$$   ставление и tcp/ip стэк.API эти основаны на berkley sockets,поэтому коор
 $$$   динальных отличий просто быть не может. Все те же accept,connect,blalba.
 $$$   (конечно появляется и новый 'админ' , этой новой tcp/ip сети).
 $$$   Вот наиглупейший примерчик:
 ```
 ,,,
 $$$   #include <sys/types.h>
 $$$   #include <sys/socket.h>
 $$$   #include <netinet/in.h>
 $$$   #include <netdb.h>
 $$$   #include <stdio.h>
 $$$
 $$$   int sock;
 $$$   int portnum;
 $$$
 $$$   main()
 $$$   {
 $$$   struct sockaddr_in server;
 $$$
 $$$    /* port number */
 $$$    portnum = 52555;
 $$$    portnum = htons ((u_short)portnum);
 $$$
 $$$    /* create socket */
 $$$    sock = socket(AF_INET, SOCK_STREAM, 0);
 $$$
 $$$    server.sin_family = AF_INET;
 $$$    server.sin_addr.s_addr = INADDR_ANY;
 $$$    server.sin_port = portnum;
 $$$
 $$$    if (bind (sock, (struct sockaddr *)&server, sizeof(server)) == -1)
 $$$       {
 $$$       perror ("not bindit! ()");
 $$$       exit (1);
 $$$       }
 $$$
 $$$    listen (sock,5);
 $$$    while (1);
 $$$    {}
 $$$   }
 ```
 ,,,
 $$$   Как я говорил используется в QNX watcom. Соответственно компиляция дово-
 $$$   льно тривиальна :
 $$$   wcc386 backdoor.c -i=/usr/include
 $$$   wlink file backdoor.o name backdoor form qnx libp /usr/lib:/usr/watcom/
 $$$   10.6/usr/lib
 $$$
 $$$   WATCOM Linker Version 10.6
 $$$   Copyright by WATCOM International Corp. 1985, 1996. All rights reserved.
 $$$   WATCOM is a trademark of WATCOM International Corp.
 $$$   loading object files
 $$$   searching libraries
 $$$   creating a QNX executable
 ```
 ,,,
 $$$   Теперь , например имея сишное файло , мы хотим получить асмовский сорец:
 $$$   (это я так плавно тему сменил на ассемблер).
 $$$   wdisasm file -l=file.asm -r -a
 $$$   и получаем file.asm - готовый к употреблению
 $$$   .386p
 $$$                  NAME    backdoor.c
 $$$                  EXTRN   _cstart_ :BYTE
 $$$                  EXTRN   listen_ :BYTE
 $$$                  EXTRN   exit_ :BYTE
 $$$                  EXTRN   perror_ :BYTE
 $$$                  EXTRN   bind_ :BYTE
 $$$                  EXTRN   socket_ :BYTE
 $$$                  EXTRN   htons_ :BYTE
 $$$                  EXTRN   __CHK :BYTE
 $$$   DGROUP         GROUP   CONST,CONST2,_DATA,_BSS
 $$$   _TEXT          SEGMENT BYTE PUBLIC USE32 'CODE'
 $$$                  ASSUME  CS:_TEXT ,DS:DGROUP,SS:DGROUP
 $$$                  PUBLIC  main_
 $$$   main_:         push    00000020H
 $$$                  call    near ptr __CHK
 $$$                  push    EBX
 $$$                  push    ECX
 $$$                  push    EDX
 $$$                  sub     ESP,00000010H
 $$$                  mov     dword ptr _portnum,0000cd4bH
 $$$                  xor     EAX,EAX
 $$$                  mov     AX,word ptr _portnum
 $$$                  call    near ptr htons_
 $$$                  and     EAX,0000ffffH
 $$$                  mov     dword ptr _portnum,EAX
 $$$                  xor     EBX,EBX
 $$$                  mov     EDX,00000001H
 $$$                  mov     EAX,00000002H
 $$$                  call    near ptr socket_
 $$$                  mov     ECX,EAX
 $$$                  mov     dword ptr _sock,EAX
 $$$                  mov     byte ptr +1H[ESP],02H
 $$$                  xor     EBX,EBX
 $$$                  mov     dword ptr +4H[ESP],EBX
 $$$                  mov     AX,word ptr _portnum
 $$$                  mov     word ptr +2H[ESP],AX
 $$$                  mov     EBX,00000010H
 $$$                  mov     EDX,ESP
 $$$                  mov     EAX,ECX
 $$$                  call    near ptr bind_
 $$$                  cmp     EAX,0ffffffffH
 $$$                  jne     short L1
 $$$                  mov     EAX,offset DGROUP:L3
 $$$                  call    near ptr perror_
 $$$                  mov     EAX,00000001H
 $$$                  call    near ptr exit_
 $$$   L1:            mov     EAX,dword ptr _sock
 $$$                  mov     EDX,00000005H
 $$$                  call    near ptr listen_
 $$$   L2:            jmp     short L2
 $$$   _TEXT          ENDS
 $$$   CONST          SEGMENT DWORD PUBLIC USE32 'DATA'
 $$$   L3             DB      6eH,6fH,74H,20H,62H,69H,6eH,64H
 $$$                  DB      69H,74H,21H,20H,28H,29H,00H
 $$$   CONST          ENDS
 $$$   CONST2         SEGMENT DWORD PUBLIC USE32 'DATA'
 $$$   CONST2         ENDS
 $$$   _DATA          SEGMENT DWORD PUBLIC USE32 'DATA'
 $$$   _DATA          ENDS
 $$$   _BSS           SEGMENT DWORD PUBLIC USE32 'BSS'
 $$$                  PUBLIC  _portnum
 $$$                  PUBLIC  _sock
 $$$                  ORG     00000000H
 $$$   _portnum       LABEL   BYTE
 $$$                  ORG     00000004H
 $$$   _sock          LABEL   BYTE
 $$$                  ORG     00000008H
 $$$   _BSS           ENDS
 $$$                  END
 $$$
 $$$   Получили асмовский исходник,теперь конечно хочется его скомпилить в бин.
 ```
 ,,,
 $$$   wasm file.asm - получаем объектник
 $$$   wlink file backdoor.o name backdoor form qnx libp /usr/lib:/usr/watcom/
 $$$   10.6/usr/lib
 ```
 ,,,
 $$$   WATCOM Linker Version 10.6
 $$$   Copyright by WATCOM International Corp. 1985, 1996. All rights reserved.
 $$$   WATCOM is a trademark of WATCOM International Corp.
 $$$   loading object files
 $$$   Warning(1028): _cstart_ is an undefined reference
 $$$   Warning(1028): listen_ is an undefined reference
 $$$   Warning(1028): exit_ is an undefined reference
 $$$   Warning(1028): perror_ is an undefined reference
 $$$   Warning(1028): bind_ is an undefined reference
 $$$   Warning(1028): socket_ is an undefined reference
 $$$   Warning(1028): htons_ is an undefined reference
 $$$   Warning(1028): __CHK is an undefined reference
 $$$   Warning(1023): no starting address found, using 0004:00000000
 $$$   creating a QNX executable
 $$$   file backdoor.o(backdoor): undefined symbol _cstart_
 $$$   file backdoor.o(backdoor): undefined symbol listen_
 $$$   file backdoor.o(backdoor): undefined symbol exit_
 $$$   file backdoor.o(backdoor): undefined symbol perror_
 $$$   file backdoor.o(backdoor): undefined symbol bind_
 $$$   file backdoor.o(backdoor): undefined symbol socket_
 $$$   file backdoor.o(backdoor): undefined symbol htons_
 $$$   file backdoor.o(backdoor): undefined symbol __CHK
 ```
 ,,,
 $$$   Здесь к сожалению номер не проходит. libp при компоновке асмовских сорц-
 $$$   ов неидет.Пробуем указать в ручную нужные библы.А какие нужны *.o - ник-
 $$$   то не знает. Поэтому делаем от сишного файла объектник, запускаем spatch
 $$$   (простенький qnx hex viewer) . И ползем в самый низ:
 ```

   00000380: 75 6D 00 00 00 00 00 05  5F 73 6F 63 6B 04 00 00  um......_sock...
   00000390: 00 00 B9 8C 0B 00 08 5F  63 73 74 61 72 74 5F 00  ......._cstart_.
   000003a0: 12 88 0B 00 80 9F 73 6F  63 6B 65 74 33 72 20 88  ......socket3r .
   000003b0: 09 00 80 9F 63 6C 69 62  33 72 11 88 0B 00 80 9F  .....clib3r.....

   000003c0: 6D 61 74 68 33 38 37 72  90 88 09 00 80 9F 65 6D  math387r......em
   000003d0: 75 33 38 37 67 8A 02 00  00 74 -- -- -- -- -- --  u387g....t------
   000003e0: -- -- -- -- -- -- -- --  -- -- -- -- -- -- -- --  ----------------
   000003f0: -- -- -- -- -- -- -- --  -- -- -- -- -- -- -- --  ----------------

 ,,,
 $$$   Видим socket3r и clib3r . Их и подключим :
 $$$
 $$$   wlink file backdoor.o name backdoor form qnx l /usr/watcom/10.6/usr/lib
 $$$   /socket3r l /usr/watcom/10.6/usr/lib/clib3r.
 $$$
 $$$   WATCOM Linker Version 10.6
 $$$   Copyright by WATCOM International Corp. 1985, 1996. All rights reserved.
 $$$   WATCOM is a trademark of WATCOM International Corp.
 $$$   loading object files
 $$$   searching libraries
 $$$   creating a QNX executable
 ```
 ,,,
 $$$   Для тех кого не удовлетворил 'вывернутый' асмовский сорец,я покажу наив
 $$$   ную и всех наверно уже _очень сильно_ доставшую hello world прожку ;) :
 $$$
 $$$   .386p
 $$$   extern printf_  :byte
 $$$   extern __CHK    :byte
 $$$   public main_
 $$$   DGROUP          GROUP   CONST
 $$$   _TEXT           SEGMENT BYTE PUBLIC USE32 'CODE'
 $$$   main_:          push    00000008H
 $$$                   call    near ptr __CHK
 $$$                   push    offset DGROUP:L1
 $$$                   call    near ptr printf_
 $$$                   add     ESP,00000004H
 $$$                   ret
 $$$   _TEXT           ENDS
 $$$   CONST           SEGMENT DWORD PUBLIC USE32 'DATA'
 $$$   L1              DB    'lalalala',0ah,00h
 $$$   CONST           ENDS
 $$$                   END
 ```
 ,,,
 $$$
 $$$   Также благодаря ваткому можно писать как говориться " Где угодно и под ,
 $$$   что угодно ". Вот например под dos/com:
 $$$
 $$$
 $$$   .model tiny
 $$$   .code
 $$$          org 100h
 $$$   start:
 $$$          mov ax,bx
 $$$          ret
 $$$   end start
 $$$
 $$$   wasm test.asm
 $$$   wlink f test form dos com
 $$$
 ```
 ,,,
 $$$   В общем ось довольно интересная и для тех кто хочет по настоящему ее ис-
 $$$   следовать я, попытался дать некоторую информацию к размышлению. Надеюсь,
 $$$   что этой статейки хватит для того , чтобы несколько уяснить для себя па-
 $$$   ру моментов и сделать соответствующие  выводы . А напоследок , несколько
 $$$   программных прерываний и функций найденных мною:
 $$'
 $'
 '
int #          Stupid desription                Where?

 0h   -  cause a fault                        cstrrq32.asm
 1ah  -  для работы с pci устройствами           pci.h
 f0h  -  Qnx Int. Аналог int 0x80h              kernel.h
  Функции в cтэк , через ax. For example:

         mov ax,0005h  ; write msg
         push ax           ; in a stack
         int f0            ; qnx int
         add sp,0ch    ; from stack

       0000h - send
       0001h - receive
       0002h - reply
       0003h - creceive
       0004h - read msg
       0005h - write msg
       0006h - relay
       0007h - sret
       0008h - priority
       0009h - netdata
       000ah - yield
       000bh - sendfd
       000ch - trigger
       0010h - semaphore

 f1h  -
 f2h  - Похоже относительный linux аналог int 0x80h. т.е в kernel.h
        говорится : kernel function calls.

 Функции в al :
        00h - send
        01h - receive
        02h - reply
        03h - crecieve ??
        04h - read msg
        05h - write msg
        06h - relay
        08h - priority
        09h - netdata
        0bh - sendfd
        0ch - trigger

 Функции в eax:
        000eh - kill
        010eh - sig_suspend
        0010h - semaphore
 f3h  -
 fah  - трэйсирoвка                              /usr/include/sys/trace.h

 ,
 $,
 $$,
 $$$
 $$$   p.s.  Изначально хотелось в этой статье добавить еще пару  пунктов:  qnx
 $$$   shellcode и сопутствующее. Но считаю, лучше искать все самим.Готовое оно
 $$$   может и хорошо , но для будущего - пользы практически никакой \n".
 $$$
 $$$!ig╖,_       p.s.s.
 `|¤??$╡$$$A.    Кстати есть даже некоторые вирусные попытки.Например Qnx.Probe
  .╖. `¤$$$L   Но пока еще очень сыроваты,да и распространиться по настоящему
,$$$$$$$, `$$$i  им я думаю не суждено в ближайшее время.
$$$$$$$$$  i$$$
?$$$$$$$7  $$$$qqqqqqqqqqqqq q   q
 `¤+?+¤` .╡$$$$$$$$$$22222222222 2  2   2   ;   ;    ;       ;
        ````````````````` `  `