
   ,g@S$$$$$S@g,  srb ;22222iiiiii;;;;
  J$$┘^````^┘$$$i $S@ i$$$$$$$$$$$$$$$   x25 zine. issue II. april 16/04/2002
 :$$[        i$$2 $$$ 2$$$$$$$$$$$$$$$ ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 `^^"       ,$$$' $$$ $$$$$$$$$$$$$$$$
         ,g$$$┘`, $$$ SSSSSSSSSSSS$╡$$         ********************************
      ,g$$$┘`,g$$ $$$qqqqqqqqqqqq╖, ╘$         ***      Just Demomaking     ***
   ,g$$$┘`,g$$$$$ $$$$$$$$$$$$$$$$$$,`         ********************************
  J$$┘`,g$$$$$$$$                `$$$                                     madcr
 i$2; $$$$$$$$$$$ %%%%%%%%%%%%%%%$$$7
 ```` """"""""""" $$$$$$$$$$$$$$$7╛'
 2@%/
 $$$2
 $$$2       I .................................................. introduction
 $$$2      II .................................................. retrace
 $$$i     III .................................................. fpu
 $$$i      IV .................................................. 3d
 $$$;       V .................................................. font use
 $$$.
 ```
 ,,,
 $$$   introdaction.
 $$$
 $$$   Demomaking уже долгое время остается довольно интерсными , спецефичным и
 $$$   необычным для большинства здоровых людей творчеством. Если 'в живую' про
 $$$   дукт художника , дизайнера или музыканта всецело зависит только от них ,
 $$$   то в demomaking преобладает все. К тому же добавляется довольно много не
 $$$   /менее важных фигур как кодеры , сваперы и тд. В demomaking все эта ком-
 $$$   пания собирается воедино , обзывается team , crew , group , just mans ;)
 $$$   для того,чтобы выпускать результаты совместной деятельности. Кто-то воз-
 $$$   можно этим занимается для славы, кто-то для развития каких-то способнос-
 $$$   тей , кто-то просто ради исскувства . У каждого свои личностные вопросы/
 $$$   проблемы ,но тем не менее исход один: какой-то конечный результат . Будь
 $$$   то demo , intro или просто cractro (которые кстати сказать  самыe лучшие
 $$$   (по моему мнению) на амиге)).О demomaking можно написать книгу вполне не
 $$$   маленькую (какая уже и написана (не в России)) и она конечно  многим не-
 $$$   посредственным участникам не понравится.Т.к. никто не опишет чужие жизни
 $$$   засунув  все  под один ярлык  'demomaking'. Здесь я просто даю маленькое
 $$$   представление для тех , кому это не известно или просто интересно узнать
 $$$   чего я написал в этом introdaction;).Как говорится 'официально' считает-
 $$$   ся , что demomaking зародился на c64. В чем я лично сомневаюсь. Да - как
 $$$   массовое распространение  ,он наверно состоялся именно на этой платформе
 $$$   ,но я уверен на 100%, что в далекие 70ый годы, когда немногие люди имели
 $$$   что-то типа Альтаира, с процессором 8080,4 килобайтами памяти и тд и тп,
 $$$   эти самые люди колбасили на банальных светодиодиках красиво переливающи-
 $$$   еся синусоиды (прототипы бегущих 'красивых' строк на компьютерах с мони-
 $$$   торами , но сейчас уже кажущиеся не актуальными в силу довольно сильного
 $$$   развития демомейкинга при помощи современных технологий). Конечно сохра-
 $$$   нить и распространить такое было  нельзя , но устроить локальное party у
 $$$   себя в универе я думаю им было не трудно ;). В общем как бы то не было ,
 $$$   demomaking есть , развивается , и как не странно все же 'не попсеет' го-
 $$$   воря желтым языком (хотя очень пытаются). С чем всех вас и нас я поздрав
 $$$   ляю и заканчиваю лить эту воду, т.к. статья слегка более практичная.
 ```
 ,,,
 $$$   retrace.
 $$$
 $$$   Не для кого конечно не секрет, что существуют мониторы на которых мы ви-
 $$$   дим некоторое изображение. Для дальнейшего понимания эту тему нужно раз-
 $$$   ложить поподробнее.В данное время пока (все еще) остаются более популяр-
 $$$   ными (а следовательно дешевыми и доступным)  мониторы с  электро-лучевой
 $$$   трубкой. Зовущиеся банально ЭЛТ (CRT) мониторы.Говоря совсем просто и по
 $$$   нятливо работают они так: Из трубки(пушки) идет луч,который предваритель
 $$$   но смешивается из красного,синего и зеленых цветов и попадает на люмино-
 $$$   фор экрана. Люминофор состоит из маленьких триад.Такое так скажем специ-
 $$$   альное вещество ,при попадании  на которое луча - они (триады)  начинают
 $$$   светится. И мы имеем ПИКСЕЛЬ. Пиксель определенного цвета, который полу-
 $$$   чился при смешивание 3 основных цветов разных интенсивностей (яркостей).
 $$$   Интенсивность каждого цвета  на низком уровне задается  видюхой , данные
 $$$   посылаются в схемку управления трубой и пошло/поехало.Вокруг трубы стоят
 $$$   отклоняющие пластинки, которые отклоняют трубку горизонтально и вертика-
 $$$   льно.В результате чего мы можем направлять луч в нужную нам точку экрана
 ```
 ,,,   Изображение строится так :
 $$$   Сначала луч бежит от верхнего левого угла горизонтально (строчно)до кон-
 $$$   ца данной строки (происходит горизонтальный ход луча),затем он идет слег
 $$$   ка диагонально назад, на начало следующей строки не рисуя при этом ниче-
 $$$   го . Это называется горизонтальный обратный ход луча. Луч таким  образом
 $$$   постепенно спускается вниз и мы имеем  вертикальный (кадровый ход луча).
 $$$   Дойдя до нижнего правого угла,луч диагонально идет обратно на начало эк-
 $$$   рана (левый-верхний угол) ничего при этом не рисуя - это  зовется верти-
 $$$   кальный обратный ход луча.
 $$$   А теперь ключевой момент - данные в видеопамять лучше выводить,когда эк-
 $$$   ран не обновляется. Т.е. когда мы имеем вертикальный(кадровый), обратный
 $$$   ход луча.
 $$$   Что нам это даст ? Это даст нам качество, плавность приятную глазу и тд.
 $$$   С обратными ходами лучей (и вертикальным , и горизонтальным) синхронизи-
 $$$   руется все и вся. Опять таки - для достижения плавности.Теперь непосред-
 $$$   ственно практичные примеры.Рассмотрим несколько процедур на асме под x86
 ```
 ,,,
 $$$   1. Ожидание вертикального хода луча.
 $$$   2. Ожидание горизонтального хода луча.
 $$$   3. Ожидание обратного вертикального хода луча. (2 варианта)
 $$$   4. Ожидание обратного горизонтального хода луча. (2 варианта)
 $$$
 $$$   У видео-карт существует довольно не слабое количество портов ввода/выво-
 $$$   да при помощи которых мы можем поиметь очень много приятных возможностей
 $$$   Не залезая в дебри скажу , что для 'дел с лучами' нам нужен только  один
 $$$   порт VGA - это 03dah (зовется ISR0 , он же регистр  состояния 6845). Нам
 $$$   нужны только 2 его бита. Это 3тий - если он в 1,то происходит вертикаль-
 $$$   ный обратный ход луча (если в 0 , то соответственно нет ж) ). И нулевой-
 $$$   который при 1 говорит , что происходит ЛЮБОЙ обратный ход луча.Как и где
 $$$   ждать,с чем синхронизировать - это выбирать уже вам.
 ```
 ,,,
 $$$   1. Ожидание вертикального хода луча.
 $$$
 $$$                   mov     dx,03dah
 $$$   not_active:     in      al,dx            ; прочитали этот регистр.
 $$$                   test    al,00001000b     ; смотрим , если 3тий бит
 $$$                                            ; равен 1 (происходит вер-
 $$$                                            ; тикальный обратный ход
 $$$                                            ; луча).
 $$$                   jz      not_active       ; то , будем скакать на
 $$$                                            ; этой процедуре пока он
 $$$                                            ; станет _не_равен 1.
 $$$
 $$$   Т.е. эта процедура ждет пока _не будет_ происходить обратного вертикаль-
 $$$   ного хода луча. Т.е. по другому сказать,она ждет _нормального_ хода луча
 $$$   ;),но раз _нормального_ хода луча нам по регистрам vga не увидеть  (хотя
 $$$   кто знает),то вот таким извратом мы ждем _нормального вертикального хода
 $$$   луча_.
 ```
 ,,,
 $$$   2. Ожидание горизонтального хода луча.
 $$$
 $$$                    mov     dx,03dah            ; все тот же регистр ISR1
 $$$   not_active:      in      al,dx               ; прочитали его.
 $$$
 $$$                    test    al,00000001b
 $$$   ; и смотрим 0ой бит. Это у нас - происходит любой обратный ход луча
 $$$   ; Т.к. горизонтальный происходит быстрее во много раз чем вертикаль-
 $$$   ; ный (оно и ясно) , то по нулевому биту , мы можем в общем судить о
 $$$   ; горизонтальном обратном ходе луча.
 $$$
 $$$                  jz      not active       ; прыгаем на процедуре ,пока
 $$$                                           ; 0вой бит станет _не равен_
 $$$                                           ; 1.
 $$$
 $$$   Т.е.если говорить нормальным языком - получаем ожидание _нормального го-
 $$$   ризонтального хода луча_.
 ```
 ,,,
 $$$   3. Ожидание обратного вертикального хода луча.
 $$$
 $$$                    mov     dx,03dah
 $$$    active:         in      al,dx
 $$$                    test    al,00000001b
 $$$                    jnz     active
 $$$
 $$$   Уже описывать нечего , я думаю и так все ясно. Лишь  надо заметить , что
 $$$   второй вариант это просто некоторое увеличение ожидания.Т.е. можно регу-
 $$$   лировать скорость плавности и тд.
 $$$
 $$$        mov dx,3DAh         ; наш  ISR1
 $$$   l1:
 $$$         in al,dx           ; прочитали его.
 $$$         and al,01h
 $$$         jnz l1             ; подождать конца текущего обратного хода луча.
 $$$   l2:
 $$$         in al,dx
 $$$         and al,01h
 $$$         jz  l2             ; а теперь начала следующего.
 $$$
 ```

 ,,,
 $$$   4. Ожидание обратного горизонтального хода луча.
 $$$
 $$$   Ну тут уже я думаю нет смысла , что либо говорить. Ибо по выше написан-
 $$$   ному в легкую можно написать и обратный и не обратный,и строчный и кад-
 $$$   ровый,и один вариант и 10.
 $$$
 $$$   Вывод один - используйте разные виды ожидание для достижения плавности.
 $$$
 $$$   Некоторый прикол : например на бейсике плавность можно достичь так :
 $$$   wait &h3da , X. где X = догадайтесь что ;). 8 - для 640на480 самое то ;)
 ```
 ,,,
 $$$   fpu.
 $$$
 $$$   Раньше,когда не было сопроцессоров (сначала отдельным чипом,потом интег-
 $$$   рированным в корпус с процом)людям все также хотелось крутить торы,гнать
 $$$   синусоидно бегущие строки и тд и тп - т.е. то,где нужны sin/cos и прочая
 $$$   тригонометрия. Как альтернатива сопроцессору, использовались таблицы си-
 $$$   нусов и косинусов. Т.е. банальный файл, где рассчитаны нужные значения и
 $$$   сложены в кучку,откуда потом брались при новом повороте или движении нуж
 $$$   ные значения по смещению в si регистре (x86ой регистр конечно), добавля-
 $$$   лись куда там надо и выводились.На самом деле - даже при современном по-
 $$$   вороте дел , где соппpоцессор уже перестают знать в лицо , а знают лишь,
 $$$   что процессор умеет тригонометрию и полезную математику , даже при таком
 $$$   повороте дел, большинство кодеров используют именно такой метод.(ну если
 $$$   не большинство , то многие).Скорость кстати догадайтесь где быстрее. Да,
 $$$   при маленьком 256байт эффекте с таблицами не развернешься , а в огромном
 $$$   деме писанной на асме - это имеет смысл ж).Но! Здесь речь именно про соп
 $$$   роцессор,а не про таблицы.Все,что я тут хочу сказать,что можно использо-
 $$$   вать и эту возможность, и ту, и кучу еще чего - просто дабы было из чего
 $$$   выбирать.Информации по сопроцессорам не то,чтобы уж очень много,но есть.
 $$$   Так, что проблем в этом думаю нет. Просто покажу малюсенький, глупенький
 $$$   пример на x86 асме:
 $$'
 $'
 '
.model tiny
.code
;/──────────────────────────────────────────────────────────────────────────\
; Рисование пикселя в 320x200                                               ;
; Вход: putpixel x y color                                                  ;
;\──────────────────────────────────────────────────────────────────────────/
putpixel macro x,y,color
         pusha
         xor di,di
         mov ax,0a000h
         mov es,ax
         mov eax,y
         mov dx,320
         mul dx
         add eax,x
         mov edi,eax
         mov ax,color
         stosb
         popa
endm

.386
     org 100h
start:
        mov al,13h
        int 10h
        mov ecx,150
        xor eax,eax
lala:   inc eax
        pusha
        mov x,eax
        fild x          ; в ST0 положили целое из X   ;
        fsin            ; sin(x) и результат в ST0    ;  sin(x)=y
        fistp y         ; взяли целое с ST0 и в Y     ;
        putpixel x y color
        popa
        loop lala
esc_handler:
        in al,60h
        cmp al,01h
        jne esc_handler
        mov ax,03h
        int 10h
        mov ax,4C00h
        int 21h
.data
x dd 0
y dd 0
color dw 40
end start

 ,
 $,
 $$,
 $$$
 $$$   Вот собственно наивная, глупая синусоида. Опять таки - выбор за вами,что
 $$$   использовать. Однако как я сказал - догадайтесь , что работает быстрее :
 $$$   sin берущийся в процессе подсчета , или уже взятый и лишь подставленный.
 $$$
 ```
 ,,,
 $$$   3D (3d point)
 $$$
 $$$   Теперь узнав , что такое ходы лучей и прикинув как лучше делать тригоно-
 $$$   метрию , подходим к одной из самой наверно актуальной части на сегодняш-
 $$$   ний день - 3D. Сразу стоит понять, что РЕАЛЬНО с 3D уделаться - это зна-
 $$$   чит очень хорошо понимать линейную алгебру , математику и тригонометрию.
 $$$   Для demomaking - хватит в общем-то не много.Можно даже обойтись без мат-
 $$$   риц. Но в общем сами понимаете - можно и без того и без сего, и в резуль
 $$$   тате ламма ламмой ;). Для тех кто досюда дочитал , а значит это интерес-
 $$$   но,я дам так скажем вводный курс. Необходимый минимум который  нужен для
 $$$   дальнейшего "пожизненного" продвижения вперед. Во многих доках которые я
 $$$   читал - сразу начинается все с сушняка. Который продолжается сухими фор-
 $$$   мулами. В общем-то .. точная наука :)
 $$$   Сразу стоит понять, что монитор и листок бумаги - это 2D. X и Y. Увидеть
 $$$   на них настоящую третью плоскость мы не можем  просто физически , как не
 $$$   хотели бы. А теперь ключевой момент - весь 3D мир , в 2D окне - это _на-
 $$$   ебалово_.Это наглым образом обман. Иллюзия 3D измерения достигается вве-
 $$$   дением разных форм глубины в 2D образ. В общем - это все, что надо знать
 $$$   для начала ж). Мы имеем (x,y,z) , далее некоторые действия и имеем (x,y)
 $$$   преобразованные от (x,y,z). Это объяснение которое я тут накарябал - са-
 $$$   мое простое в мире.Это так сказать ключевые моменты 3D. Далее собственно
 $$$   вопрос каким образом нам ввести глубину,т.е.как нам прийти от трех коор-
 $$$   динат точки,к 2м ? Ответ в проецировании. Конечно стоит почитать "книжки
 $$$   по вышки" , но можно сказать грубо: проецироание - это по  сути деление.
 $$$   Нам нужна глубина. Со школы помним (хотя  может и нет) , что это  третье
 $$$   измерение/плоскость берется за Z. (хотя не всегда и тд и тп). Раз у  нас
 $$$   это третье , нам нужное измерение, то проецировать на него и будем. Т.е.
 $$$   делить.
 ```
 ,,,
 $$$   readyX = X / Z
 $$$   readyY = Y / Z
 $$$
 $$$   И все. Больше ничего ;) Мы получаем "обманчивые" 2D координаты,3D точки.
 $$$   Т.е. к макросу putpixel добавляем просто :
 $$$
 $$$      mov ax,[x]
 $$$      mov bx,[z]
 $$$      div bx          ; проецирование X
 $$$      mov [tempx],ax
 $$$      xor dx,dx
 $$$      mov ax,[y]
 $$$      mov bx,[z]
 $$$      div bx          ; проецирование Y
 $$$      mov [tempy],ax
 $$$
 $$$   Не важно, что тут div,а не логические сдвиги - здесь суть не в скорости,
 $$$   а немного в другом ;).
 ```
 ,,,
 $$$   3D (3d rotate)
 $$$
 $$$   Теперь самый приятный,и второй по важности ключевой момент 3D - вращение
 $$$   Сразу надо уяснить , что вращаем мы ТОЧКИ (вектора),а не здоровые объек-
 $$$   ты.Не вдоваясь в подробности вывода формул,я просто их даю (они есть вез
 $$$   де и всюду,в куче док и книг ;).
 $$$
 $$$     ---=== X rotate ===---
 $$$   Y = y*cos(b) - z*sin(b)
 $$$   Z = y*sin(b) + z*cos(b)
 $$$
 $$$     ---=== Y rotate ===---
 $$$   X = x*cos(b) - z*sin(b)
 $$$   Z = x*sin(b) + z*cos(b)
 $$$
 $$$     ---=== Z rotate ===---
 $$$   X = x*cos(b) - y*sin(b)
 $$$   Y = y*cos(b) + x*sin(b)
 $$$
 $$$
 $$$   Все. Т.е. совсем чтобы просто :
 $$$   Взяли (x,y,z). Подсчитали (провернули) вокруг какой нам надо оси. Спрое-
 $$$   цировали. Вывели (x1,y1). Делаем цикл по изменению угла и пиксель враща-
 $$$   ется. Делаем сколько угодно пикселей (начальных и  конечных точек  линий
 $$$   скажем),рисуем чего нам надо , и уже и объекты закрутились ;)
 $$$
 $$$   Пример на м68к асме:
 $$'
 $'
 '


rot_XY:         move.w  d1,d3           ;rot on axis X
                move.w  d2,d4
                move.l  a4,d5
                muls.w  d5,d1   ;sinY
                muls.w  d5,d2   ;sinZ
                swap    d5
                muls.w  d5,d3   ;cosY
                muls.w  d5,d4   ;cosZ
                sub.l   d4,d1   ;sinY-cosZ=Y
                add.l   d3,d2   ;sinZ+cosY=Z
                lsr.l   d6,d2
                move.w  d0,d3           ;rot on axis Y
                move.w  d2,d4
                move.l  a5,d5
                muls.w  d5,d0   ;sinX
                muls.w  d5,d2   ;sinZ
                swap    d5
                muls.w  d5,d3   ;cosX
                muls.w  d5,d4   ;cosZ
                sub.l   d4,d0   ;sinX-cosZ=X
                add.l   d3,d2   ;sinZ+cosX=Z
                lsr.l   d6,d0
                lsr.l   d6,d1
 ,              lsr.l   d6,d2
 $,             rts
 $$,
 $$$
 $$$   Вот в общем тот минимум , который нужен для старта в 3D.
 ```
 ,,,
 $$$   font use.
 $$$
 $$$   Приятно когда в demo есть  текст. Приятно когда он не системный ;) . Еще
 $$$   приятнее писать обычные ascii символы в буфере и получать вывод уже в к-
 $$$   расивом, графическом шрифте. Для этого нужно иметь фонт-картинку , в ко-
 $$$   торой нарисованы нужные символы в нужных размера (одинаковых размерах же
 $$$   лательно, для последующего универсального вывода). Процедуру непосредст-
 $$$   венного вывода этого символа и процедуры " привязки " к ascii  символам.
 $$$   Процедура вывода зависит от того,какой графический формат обрабатывается
 $$$   Обычно это pcx, или, что намного проще - raw. Где данные лежат линейно и
 $$$   вывод банален: lodsb/stosb и пиксель на экране ;).
 ```
 ,,,
 $$$   vivod: mov cx,18
 $$$    ogo:  push cx
 $$$          mov cx,10
 $$$    aga: lodsb
 $$$         stosb
 $$$         loop aga
 $$$         add di,640-10
 $$$         add si,320-10
 $$$         pop cx
 $$$         loop  ogo
 $$$         ret
 ```
 ,,,
 $$$   В данном случае , высота 18 пикселей , ширина 10, а ширина картинки 320.
 $$$   К ascii символам привязку можно сделать например путем вычитания разнос-
 $$$   ти между каким-то символом ascii таблицы взятым за начало вашего фонта и
 $$$   умножения ее на длину символов по горизонтали.В результате мы будем ока-
 $$$   зываться на нужном нам графическом символе в фонте и далее его  выводим.
 $$$   Если font нарисован в одну строчку - то никаких проблем (так  собственно
 $$$   и проще всего. Скажем рисовать 1500x30). Но если в фонте пару строк  или
 $$$   больше,то к привязки ascii совать проверку на разность между первым сим-
 $$$   волом и числом больше которого уже вторая строка (или третья,или четвер-
 $$$   тая). И все.
 ```
 ,,,
 $$$   Если же просто используются фразы - то нет смысла убиваться с ascii-при-
 $$$   вязкой, можно просто рисовать спрайты и выводить. Растягивать по желанию
 $$$   и тд.Выбор как я уже говорил всегда за вами ;)
 $$$
 $$$!ig╖,_
 `|¤??$╡$$$A.    Надеюсь эта статейка помогла начинающим кое-что уяснить,а прод
  .╖. `¤$$$L   винутым узнать немного нового/хорошо забытого старого ;).
,$$$$$$$, `$$$i
$$$$$$$$$  i$$$
?$$$$$$$7  $$$$qqqqqqqqqqqqq q   q
 `¤+?+¤` .╡$$$$$$$$$$22222222222 2  2   2   ;   ;    ;       ;
        ````````````````` `  `