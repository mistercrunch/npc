
                         Parte 3 del curso de Cgi
                              Tercera parte


Interactividad,Forms & Scripts CGI [Primera Parte - Uso de los Forms]
                                   [Segunda Parte - Programaci¢n de Scripts]
                                   [Tercera Parte - Programaci¢n CGI avanzada]

Indice
------
PRIMERA PARTE
Introducci¢n.
C¢mo funciona la cosa.
Por donde empezar.
Forms.
   Forms simples.
   Text, Password y TextArea.
   Radio Buttons.
   Check Buttons.
   Pop-up Lists.
   Forms Multiples y el Reset Button.


SEGUNDA PARTE 
Que necesitamos para empezar.
Qu‚ son los scripts CGI?
Nuestro Primer Script.
Un script que hace Eco de un Form.
Un procesador de mensajes simple. (guestbook)
        -retornar una p gina est tica que no hallamos creado.
        -verificar que todos los campos de un form sean completados
         y que el email este correctamente especificado.
        -Editar un documento HTML e insertar informacion en el mismo.
Puntos importantes al programar scripts.  


TERCERA PARTE <<----
Im genes clikeables.
   Server-Side Image Maps. 
   Client-Side Image Maps. 
Desempaquetando informaci¢n.
   Parsers CGI.
Locking de archivos.
Scripts avanzados.
   Documentos Din micos.
       Client Pull.
       Server Push.
         Mensajes MIME multipart.      
       Gif multiparts.
   Counters.
P ginas Web con protecci¢n por password.
   Que significa proteger una p gina.
       El archivo .htaccess.
       El archivo .htaccess.

Final del tutorial (por ahora).
       Pr¢ximos desarrollos.
Ap‚ndice:  Librer¡as para la Programaci¢n de scripts CGI.
           Sites con informaci¢n acerca de CGI.
Vocabulario - Siglas.
Bibliograf¡a.
                                                                         S.Q        
------------------------------------------------------------------------------


Im genes clikeables.

A pesar que este tipo de elementos no est  conectado directamente con los
scripts CGI pens‚ en incluirlos dado que tambi‚n son una de las formas de
incrementar la interactividad entre el usuario y el web site.
B sicamente una im gen clikeable (es una acepci¢n que invent‚, ya fu‚ la que
me pareci¢ m s correcta en castellano) es una im gen, un gr fico que cuando es
clikeada en alguna de sus partes env¡a las coordenadas X e Y de la posici¢n del
mouse en ese momento y el server a partir de ellas genera un enlace con otras
p ginas.

El uso m s com£n de este tipo de im genes es crear barras de herramientas
personalizadas, o regiones en un gr fico que permitan al usuario navegar hasta
un nuevo documento.

En teor¡a existen tres formas de lograr este tipo de imagenes;
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Server-Side Image Maps (antigua)                                            ³
³Es la forma m s antigua, utilizaba un FORM para enviar la informaci¢n y     ³
³hab¡a que programar un script en el server que procesara dicha informaci¢n. ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Server-Side Image Maps (moderna)                                            ³
³Es la forma m s com£n y m s ampliamente utilizada, utiliza el tag ISMAP y la³
³informaci¢n es procesada por el web server.                                 ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Client-Side Image Maps                                                      ³
³Es la forma m s moderna (y menos difundida) s¢lo soportada por los browsers ³
³en sus £ltimas versiones,y la informaci¢n es procesada por el mismo browser.³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

Como todos los Web servers de la actualidad soportan la segunda forma,
descartaremos la revisi¢n de la primera y comenzaremos directamente a usar el
tag ISMAP.

Partiendo de una imagen (un .GIF) elegiremos dentro de ella las  reas que
funcionar n como links a otros documentos.
Dichas  reas pueden ser definidas en base a uno o m s de los siguientes
elementos.

RECT (x1,y1) (x2,y2) Determina un  rea rectangular en base a los v‚rtices de
su diagonal principal.
CIRCLE (a,b,r) Determina un c¡rculo de centro (a,b) y de radio r.
POLY (x1,y1) (x2,y2) .... (x1,y1) Determina un pol¡gono cuyos v‚rtices (x,y)
son dispuestos secuencialmente uno detr s de otro.

Almacenaremos estos elementos en un archivo que tendr  m s o menos el
siguiente formato:
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ default /default.htm                                     ³
³ RECTANGLE (475,157) (611,344) /principal.htm             ³
³ RECTANGLE (233,182) (447,359) /buscar.htm                ³
³ CIRCLE (130,54,20) /circulo.htm                          ³
³ POLY (46,27) (57,33) (58,23) (68,35) (46,27) /carita.htm ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

Usando un paquete gr fico cualquiera y revisando la posici¢n del cursor
podremos construir este tipo de archivos, el £nico problema es que nos puede
resultar bastante tedioso el hacerlo "a mano".
Existe un freeware realmente excelente llamado MapThis! que hace todo el
trabajo por nosotros que puede ser bajado de cualquier repositorio de
shareware como OAK, Garbo, CICA, SimTel, etc..

Veamos entonces la estructura del archivo. La primera l¡nea linkea el
documento que ser  cargado en caso de que no clikeemos en ninguna de las
 reas especificadas por los elementos que definimos. Si omitimos el tipo de
elemento el server tomar  por default el RECT.
Por convenci¢n, grabaremos este archivo con la extensi¢n .MAP en el directorio
que m s nos convenga.

Cuando tengamos que poner el tag IMG correspondiente a la imagen en la p gina
en cuesti¢n, agregaremos el par metro ISMAP y haremos un hyperlink al .MAP de
esta manera.

<A HREF="/maps/dibujo.map"><IMG SRC="/images/barrita.gif" BORDER=0 ISMAP></A>

Entonces una vez cargada la p gina en nuestro browser, cada vez que clikeemos
en alguna parte de la imagen , el browser enviar  las coordenas de la ubicaci¢n
en la que nos encontrabamos (esos numeritos que aparecen en la barra de status)
al server, y luego de esperar su proceso, ‚ste £ltimo nos devolver  la
respuesta correspondiente.

Este mecanismo (Server-side), induce un cierto retardo (el proceso por parte
del server de nuestro pedido) por lo cual recientemente Netscape introdujo un
un nuevo mecanismo conocido como Client-Side Image Maps el cual veremos a
continuaci¢n.

Client-Side Image Maps.
En vez de realizar la conversi¢n coordenadas/hyperlink en el server, esta
ser  realizada por el browser.
El .MAP que defin¡amos en el m‚todo anterior AHORA debe estar inclu¡do DENTRO
del c¢digo HTML con el siguiente formato.

<MAP NAME="barradetareas">
<AREA SHAPE="RECT" COORDS="475,157,611,344" HREF="principal.htm">
<AREA SHAPE="RECT" COORDS="233,182,447,359" HREF="buscar.htm">
<AREA SHAPE="CIRCLE" COORDS="130,54,20" HREF="circulo.htm">
<AREA SHAPE="POLY" COORDS="46,27,57,33,58,23,68,35,46,27" HREF="acarita.htm">
</MAP>

Y el link en el tag IMG quedar¡a as¡:
<IMG SRC="/images/barrita.gif" USEMAP="#barradetareas">

En MAPNAME definimos el nombre del mapa y en USEMAP lo referenciamos.
Al probarlo podremos ver que en la barra de status no aparecen las coordenadas
sino directamente el nombre de la p gina en cuestion. Si utilizamos nombres
de p gina significativos esto puede ser de gran ayuda para el usuario.

Este m‚todo obviamente es mucho m s r pido (no implica un intercambio de
informaci¢n con el server) pero tiene la desventaja de que no est 
implementado en todos los browsers todav¡a, a pesar de que est  propuesto
como est ndar para la definici¢n de HTML 3.0.
Para cubrir este aspecto podemos utilizar los dos m‚todos simult neamente
de esta manera.

<A HREF="/maps/dibujo.map">
<IMG SRC="/images/barrita.gif" USEMAP="#barradetareas" BORDER=0 ISMAP></A>

Si el browser no llegara a entender el USEMAP, procesar  nuestro pedido en
base al link del ISMAP.



Desempaquetando informaci¢n.

Aunque este tema puede resultar algo "t‚cnico" creo que resulta interesante
incorporarlo al tutorial, ya que nos permite conocer el funcionamiento de esas
"cajas negras" que son las librer¡as, las cuales hemos utilizado al programar
nuestros scripts.
Sabemos que cuando usamos el m‚todo POST toda la informaci¢n de un form es
"empaquetada" en una variable llamada QUERY_STRING, pero... en qu‚ forma?

La variable QUERY_STRING puede almacenar solamente un string continuo sin
espacios, de manera que para enviar varios campos (y espacios) debe existir
alg£n tipo de codificaci¢n de los mismos.
De hecho, podemos verla en el siguiente ejemplo.
Supongamos que en nuestro form solicitamos los siguientes datos:
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Nombre: Sebastian                 ³  (para variar :)
³Edad: 22                          ³
³Simpatizante de: Boca Juniors     ³ (que grande boquita:->
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

Como dec¡amos estos datos deben ser empaquetados en un £nico string, esto se
hace poniendo un "&" (ampersand) entre cada variable y reemplazando cada
espacio por un signo "+", con lo cual conseguimos que la variable quede as¡;

ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
ºQUERY_STRING = "nombre=Sebastian&edad=22&equipo="Boca+Juniors"º
ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

Adicionalmente, ciertos caracteres son reemplazados por su valor ASCCI en un
formato hexadecimal (%xx). Como vemos, esta ensalada de letras es imposible
de manejar tal como est , por lo tanto recurrimos a los "parsers" cuya funci¢n
es la de separar estos valores en c¢modas y agradables variables.

Parsers CGI.
La rutina escrita para Perl es un poco (s¢lo un poco) m s clara que su
correspondiente equivalente en C, por lo tanto la utilizaremos para la
explicaci¢n del funcionamiento de un parser.
Perl utiliza los llamados "arrays asociativos" que son muy similares
a los arrays que todos conocemos, excepto por la salvedad (y a la vez gran
ventaja) de que los ¡ndices no son n£mericos, sino alfan£mericos.
C¢mo es esto ? En esta rutina, todos los campos que se separan son almacenados
en un array asociativo con el nombre @in. Si queremos acceder al contenido
del campo edad, por ejemplo, ‚ste se encuentra en la posici¢n "edad" y el
c¢digo empleado es el siguiente.
@in { 'nombre'};

Lo que sigue es la rutina &ReadParse (que figura en la l¡breria "cgi-lib.pl"
de S.E.Brenner) comentada ampliamente para su mejor entendimiento.

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³# Perl Routines to Manipulate CGI input                                     ³
³# S.E.Brenner@bioc.cam.ac.uk                                                ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³# ReadParse                                                                 ³
³# Lee datos env¡ados con POST o GET, los convierte a texto simple,y pone    ³
³# un campo=valor en cada componente de la lista "@in"                       ³
³# Tambi‚n crea pares de campo/valores en %in, usando '\0' para separar      ³
³# selecciones m£ltiples                                                     ³
³                                                                            ³
³sub ReadParse {                                                             ³
³  # Definici¢n de las variables a utilizar.                                 ³
³    local (*in) = @_ if @_;                                                 ³
³    local ($i, $loc, $key, $val);                                           ³
³                                                                            ³
³  # De acuerdo al m‚todo de env¡o almacena en la variable $in el texto.     ³
³  if ($ENV{'REQUEST_METHOD'} eq "GET") {                                    ³
³    $in = $ENV{'QUERY_STRING'};                                             ³
³  } elsif ($ENV{'REQUEST_METHOD'} eq "POST") {                              ³
³    read(STDIN,$in,$ENV{'CONTENT_LENGTH'});                                 ³
³  }                                                                         ³
³                                                                            ³
³  @in = split(/&/,$in);     #separa en un array los contenidos de $in que se³
³                             encuentran separados por "&"                   ³
³                                                                            ³
³  foreach $i (0 .. $#in) {                                                  ³
³    #Convierte los "+" en espacios.                                         ³
³    $in[$i] =~ s/\+/ /g;                                                    ³
³                                                                            ³
³    # Separa el campo y su contenido .                                      ³
³    ($key, $val) = split(/=/,$in[$i],2); # corta en el primer =.            ³
³                                                                            ³
³    # Convierte %XX de n£meros hexadecimales a alfan£mericos.               ³
³    $key =~ s/%(..)/pack("c",hex($1))/ge;                                   ³
³    $val =~ s/%(..)/pack("c",hex($1))/ge;                                   ³
³                                                                            ³
³    # Asocia cada campo con su valor.                                       ³
³    # usando \0 como separador de elementos m£ltiples(checkbox por ej)      ³
³    $in{$key} .= "\0" if (defined($in{$key}));                              ³
³    $in{$key} .= $val;                                                      ³
³                                                                            ³
³  }                                                                         ³
³  return 1;                                                                 ³
³}                                                                           ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

Esta no es la £nica librer¡a que existe para manejar CGI bajo Perl , pero
s¡ la m s utilizada. Seg£n el autor nuevas versiones incorporar n m s
facilidades, tales como file uploading y otras.



Locking de archivos.

En la segunda parte de este documento plante‚ el hecho problem tico de que dos
usuarios pretendan acceder al mismo tiempo a un mismo archivo, como es el caso
del mini-guestbook.
En Unix tenemos recursos que nos permiten realizar este tipo de bloqueos con
una llamada al sistema, pero bajo otros sistemas (y para mantener la "transpor
tabilidad" de nuestros scripts, veremos una t‚cnica muy simple que puede ser
implementada en cualquier plataforma y que puede ser utilizada sin problemas.

Cuando dos usuarios quieren leer/escribir un mismo archivo (en realidad los
scripts llamados por ellos) se produce un conflicto, el de saber quien tiene
la prioridad al hacerlo. Una manera de resolver este conflicto es crear un
archivo "lock" cuya sola presencia nos indique que el archivo esta siendo
accedido en ese momento.
As¡ cuando nuestro script pretenda leer/escribir el archivo, primero consultar 
la existencia del "lock", si existe esperar  un segundo y volver  a intentar
y en caso de que no exista lo crear  y proceder  a la consulta.
Un ejemplo comentado en Perl nos mostrar  esta t‚cnica:

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³$salir = 'no';                                                     ³
³ while ($salir != 'si') {                                          ³
³   if (-e "/mini-gb.lock") {                                       ³
³     # Si el archivo existe,  esperamos 1 segundo.                 ³
³     sleep(1);                                                     ³
³     }                                                             ³
³   else {                                                          ³
³     # Al no existir el archivo, lo creamos y empezamos el proceso.³
³     open(LOCK,">/mini-gb.lock");                                  ³
³     close LOCK;                                                   ³
³  . . . . . . . . .Proceso de nuestro script. . . . . . . . .      ³
³                                                                   ³
³     # Destrabamos el archivo (lo eliminamos)                      ³
³     unlink("/guestlock");                                         ³
³                                                                   ³
³     #Salimos de nuestra rutina                                    ³
³     $salir = si;                                                  ³
³     }                                                             ³
³   }                                                               ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ




Scripts avanzados.
A partir de este punto analizaremos en detalle los requisitos para el manejo
de documentos din micos, profundizando en el conocimiento de la forma de
trabajo del protocolo HTTP y los mensajes MIME.

Documentos Din micos

Para introducirnos en el tema de los documentos din micos nos basaremos en una
aplicaci¢n pr ctica, la animaci¢n, es decir imagenes en movimiento sin dejar
de lado el hecho de que esta £ltima es s¢lo una de las m£ltiples posibilidades
que nos brinda el manejo din mico de la informaci¢n.

Actualmente existen tres m‚todos (si incluimos el gif multipart) para poder
manejar informaci¢n din micamente, en orden de eficiencia estos son;

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Client Pull                                                                 ³
³El server env¡a un "stream" de informaci¢n, incluyendo una directiva (en la ³
³respuesta HTTP) que dice "vuelva a cargar estos datos en 5 segundos" o "vaya³
³y cargue esta URL en 10 segundos". Desp£es de que se cumple el tiempo especi³
³ficado, el browser hace lo que se le indic¢, o sea recargar la p gina actual³
³o conseguir una nueva p gina.                                               ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Server Push                                                                 ³
³El server env¡a un "stream" de informaci¢n y el browser la muestra, pero    ³
³sigue manteniendo la conexi¢n abierta; cuando el server lo requiera, puede  ³
³continuar enviando m s informaci¢n para que el browser la muestre, y as¡    ³
³sucesivamente..                                                             ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Gif multipart                                                               ³
³Se trata del m‚todo m s avanzado (lo vieron en WebTV?) que utiliza un nuevo ³
³formato de imagen GIF en donde se incluyen m£ltiples cuadros separados por  ³
³comandos de animaci¢n, los cuales pueden ser vistos con el browser de       ³
³Netscape  partir de la versi¢n 2.0                                          ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

Analicemos en detalle cada uno de los m‚todos.

Client Pull
Para muestra basta un bot¢n, as¡ que de entrada prueben el siguiente c¢digo;

<META HTTP-EQUIV="Refresh" CONTENT=1>
<TITLE> Primera p gina</TITLE>
<H1> HOLA! </H1>
Una demostracion de documentos dinamicos<P>

Y?? Qu‚ pas¢?, por el bien de este tutorial espero que el documento haya sido
recargado por el browser al pasar un segundo.

Esto lo logramos al agregar el tag "META" (el cual permite simular respuestas
HTTP en p ginas HTML) que le dice al browser que el server le est  enviando
un header con la indicaci¢n "Refresh: 1".
Cambiando el valor, cambiamos el tiempo de retardo obviamente.
Observemos que cada directiva "Refresh" es £nica y por tanto la p gina NO ser 
refrescada cada un segundo eternamente, sino una £nica vez y que al tratarse
de una respuesta HTTP (simulada) la misma debe figurar al comienzo de nuestra
p gina. 
Otra cosa que podemos lograr con este tag es cargar otro URL luego de una
determinada cantidad de tiempo. La sintaxis es la siguiente:

<META HTTP-EQUIV="Refresh" CONTENT=10; URL=http://mimaq.midominio/dinamic.htm>

Que har  que el browser luego de diez segundos de haber cargado la primera
p gina vaya y traiga la que se encuentra referenciada por la variable URL.
Un detalle importante es que debemos utilizar URLs absolutos, es decir incluir
en la definici¢n el "http://..."  y no emplear URLs relativos.

Y que pasar¡a si hacemos lo siguiente:
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³pri.html                              ³ seg.html                            ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³<META HTTP-EQUIV="Refresh" CONTENT=3; ³<META HTTP-EQUIV="Refresh" CONTENT=3;³
³URL=http://mimaq.midominio//seg.html> ³URL=http://mimaq.midominio//pri.html ³
³                                      ³                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

M s de uno se habr  dado cuenta de que estos dos documentos se llaman el uno
al otro cada tres segundos, generando una especie de "loop" infinito.
A partir de este ejemplo, podemos inducir varias otras combinaciones tales
como la de un documento que se llame a si mismo cada 0 segundos provocando as¡
tambi‚n este tipo de "loops sin fin".
O podr¡amos hacer una cadena m s larga, como la que sigue;

P gina 1 ¿                              
     P gina 2 ¿                        Con la cual obtendr¡amos una especie
  ³           P gina 3 ¿                de animaci¢n aunque por cierto,
  ³                  P gina 4 ¿         bastante pobre.
  ³                         P gina 5    
  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


Un ejemplo de utilizaci¢n pr ctica de esta t‚cnica ocurre en aquellas p ginas
que nos indican que la p gina original ha cambiado de lugar y que en cinco
segundos seremos autom ticamente redireccionados a la nueva ubicaci¢n.

Server Push

En contraste con el Client Pull, este mecanismo aprovecha que el server puede
mantener una conexi¢n abierta por un tiempo indefinido, dejando espacio para
que sean enviadas varias respuestas secuencialmente.
Para lograrlo se utiliza un tipo MIME experimental (nuevo, no registrado a£n
como standard) llamado "multipart/x-mixed-replace".

Mensajes MIME multipart.
Existen varios tipos diferentes de mensajes "multipart"MIME. Cada uno de ellos
le indica al cliente como debe procesar las diferentes partes que le ser n
enviadas.
Con el tipo "multipart/mixed", la informaci¢n de cada parte es independiente
de las otras, y el cliente deber¡a mostrar una tras otra a medida que van
llegando. Con el tipo "multipart/alternative", la informaci¢n de cada parte es
id‚ntica, pero estan formateadas de una manera distinta de manera que el
cliente determina cual es el "mejor" formato que puede mostrar (por ejemplo
elige "rich text" en vez de plain text) y lo muestra.
Con el tipo "multipart/parallel", el cliente deber¡a mostrar cada parte
simult neamente, si le fuera posible.
Con el tipo "multipart/mixed-replace" que ser  el que utilizaremos, cada parte
del mensaje se superpone a la parte anterior; el cliente sobreescribe la
parte vieja con la m s nueva.

Un mensaje MIME multipart est  compuesto de un header y una o m s partes que
componen la totalidad del mensaje. El header indica como deben ser procesadas
las distintas partes del mensaje y cuales son los separadores de las mismas,
como ejemplo;

Content-Type: multipart/x-mixed-replace;boundary=SeparaPartes


Cuando el cliente encuentra este tipo en el header, hace un refresh del sector
correspondiente cada vez que una nueva parte del mensaje llega,
sobreescribiendo de esta manera la anterior.

Cada parte del mensaje tiene su propio header, el cual indica el tipo de datos
que esa parte contiene, "plain text", un gr fico GIF o HTML por ejemplo. 
El header de cada parte siempre se encuentra debajo del separador que
hallamos especificado (en la l¡nea que vimos le pusimos "SeparaPartes" de
nombre al separador , pero podr¡amos haber utilizado cualquier otro).

El server indica el fin de un mensaje multipart enviando un separador con el
agregado de dos guiones, por ejemplo nuestro separador quedar¡a;

--SeparaPartes

El script que sigue es una version reducida del NPH 1.2 creado por Matt Wright
y en ‚l veremos una implementaci¢n comentada del mecanismo que acabamos de
describir.
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ #!/usr/bin/perl                                                            ³
³ # Variables                                                                ³
³ $veces = "1";                                                              ³
³ $dirbase = "/WWW/images/animation/";                                       ³
³ @archivos = ("primero.gif","segundo.gif","tercero.gif","primero.gif");     ³
³ $tipo = "gif";                                                             ³
³                                                                            ³
³ # Hacemos que el stream de datos fluya sin un buffer para hacerlo mas rapid³
³ select (STDOUT);                                                           ³
³ $| = 1;                                                                    ³
³                                                                            ³
³ # Comienzo del contenido multipart.                                        ³
³ print "Content-Type: multipart/x-mixed-replace;boundary=separador\n\n";    ³
³ print "--separador\n";                                                     ³
³                                                                            ³
³ # Este for toma cada imagen de la secuencia, la env¡a, manda un separador  ³
³ #y luego env¡a la siguiente, repitiendolo las veces que indique $veces.    ³
³ for ($num=1;$num<=$veces;$num++) {                                         ³
³   foreach $archi (@archivos) {                                             ³
³        print "Content-Type: image/$tipo\n\n";                              ³
³        open(GIF,"$dirbase$archi");                                         ³
³        print <GIF>;                                                        ³
³       close(GIF);                                                          ³
³       print "\n--separador\n";                                             ³
³   }                                                                        ³
³ }                                                                          ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

Lo £nico que me quedar¡a por aclarar es que ya que el tipo "x-mixed/replace"
fu‚ definido por Netscape, solamente funcionar  con su browser versi¢n 1.1 y
posteriores.


GIF multipart.

En este caso no tendremos que programar nada y es por lejos la forma m s simple
de armar una animaci¢n, aunque mantiene la desventaja de ser visualizados
£nicamente por el Netscape 2.0 en adelante.
En definitiva se trata de ampliar las posibilidades del formato GIF89A (aquel 
que nos permite utilizar backgrounds transparentes).
Los archivos .GIF tienen al comienzo un "header" que indica su tama¤o y otros
datos, con programas como el Gif Construction Set ampliaremos este header e
inclu¡remos l¡neas con la secuencia de im genes y comandos de control.
El header de una animaci¢n simple quedar¡a de la siguiente manera:
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³ HEADERGIF89AScreen(320x200) ³
 ³ LOOP                        ³
 ³ CONTROL                     ³
 ³ IMAGE320x200,256colours     ³
 ³ CONTROL                     ³
 ³ IMAGE320x200,256colours     ³
 ³ CONTROL                     ³
 ³ IMAGE320x200,256colours     ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Ya que el Gif Construction Set trae un help bastante completo  y es sencillo
de usar no quisiera extenderme m s en el tema.
Sugerencia: Leer con el GifCon los .GIF que trae de ejemplo.

Si nos decidimos por utilizar este m‚todo tengamos en cuenta lo siguiente.
La mayor¡a de los browsers (descartando Netscape 2.0) mostrar n £nicamente el
primer cuadro de la animaci¢n y algunos pocos s¢lo el £ltimo.
De manera que si queremos que tratar de que la animaci¢n luzca bien en
cualquier browser, la soluci¢n m s simple es hacer que el primer cuadro sea
el m s presentable (nada de logos al rev‚s;) y que el £ltimo sea igual al
primero.


Counters.

Implementar un "counter" no es una tarea muy d¡ficil. B sicamente se graba en
un archivo el valor del contador, y cada vez que se hace un nuevo acceso a la
p gina controlada se lee este archivo, se incrementa en uno el valor le¡do y
se vuelve a grabar. Veremos un fragmento de script que hace esta tarea.
Por otro lado no quer¡a dejar de comentar que existen scripts m s complicados
que pueden generar una salida en la forma de un archivo .GIF. Estos scripts lo
que hacen es leer el valor a representar, "pegan" en una misma imagen los
d¡gitos que componen dicho n£mero y la env¡an.
Si seguimos avanzando tambi‚n encontraremos scripts que pueden controlar m s
de una p gina, ya que trabajan en base a un archivo ¡ndice que almacena el
valor de los contadores para cada p gina en particular.
A los fines de este tutorial el ejemplo presentado es lo suficientemente
entendible como para poder implementarlo y practicar sin mucho trabajo.
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ #!/usr/local/bin/perl                                                      ³
³                                                                            ³
³   open(CONTADOR,"$counter.dat") || die "Error al abrir el archivo: $!\n";  ³
³   $contador = <CONTADOR>;                                                  ³
³   close(CONTADOR);                                                         ³
³   if ($contador =~ /\n$/) {                                                ³
³      chop($contador);                                                      ³
³   }                                                                        ³
³                                                                            ³
³   $contador++;                                                             ³
³                                                                            ³ 
³   print "<HTML><HEAD><TITLE>Bla,bla,bla..</TITLE></HEAD>"                  ³
³                                                                            ³
³   open(CONTADOR,">$counter.dat") || die "Error al cerrar el archivo: $!\n";³
³   print CONTADOR "$contador";                                              ³
³   close(CONTADOR);                                                         ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ




P ginas Web con protecci¢n por password.

Para no dejar de lado el tema de la seguridad abordaremos el uso de passwords
en el acceso a un servidor Web.
Necesitaremos nuevamente tener algunos conocimientos previos, en este caso del
manejo de archivos UNIX.
Si utilizamos otro tipo de plataforma para correr el Web Server, como Windows
NT, tendremos este tema solucionado con una muy sencilla configuraci¢n a trav‚s
del uso de men£es (por lo menos con el Website).
Lo principal para aclarar antes de comenzar es que cuando utilizamos este
sistema (seg£n su mecanica interna) restringimos el acceso a un directorio,
no a una p gina en particular.

El m‚todo se basa principalmente en poner en cada directorio a proteger un
archivo de nombre ".htaccess" que contiene los par metros de configuraci¢n de
la protecci¢n implementada y el nombre del archivo que contiene las passwords
que normalmente es el ".htpasswd".

Y se acab¢ el misterio. Eso es todo. Cuando se le solicita al server una
p gina que tiene en su mismo directorio un ".htaccess", ‚ste se encarga de
enviar los c¢digos HTTP necesarios para que el browser levante la ventanita de
autentificaci¢n.
Para explotar este recurso completamente pasaremos a analizar en detalle los
par metros que pueden ser utilizados en el ".htaccess" y la forma en que
podemos mantener actualizado el ".htpasswd" .


El archivo ".htaccess".

Este archivo debe estar ubicado en el directorio que se desea proteger y dicha
protecci¢n afectar  a todos los subdirectorios del mismo, a menos que posean
sus propios archivos ".htaccess".
Dado que se trata de un archivo de texto com£n podremos actualizarlo con
cualquier editor del que dispongamos.

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ AutUserFile .htpasswd                         ³
³ AuthGroupFile /dev/null                       ³
³ AuthName Ingrese su user ID y su password.    ³
³ AuthType Basic                                ³
³                                               ³
³ <Limit GET>                                   ³
³ require user usuario1 usuario2 usuario3 ..... ³
³ </Limit>                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

Descripci¢n de los Par metros.

AutUserFile: es el nombre del archivo que contiene los nombres de los
usuarios (users ID) y sus respectivas passwords. Este archivo debe estar
ubicado en el mismo directorio que ".htaccess" pero puede llevar cualquier
nombre. Por convenci¢n le daremos el nombre de ".htpasswd" .

AuthGroupFile: Este es el nombre del archivo de grupo. Podemos setear
grupos de usuarios para que tengan acceso a un directorio, en el caso del
ejemplo no tenemos un archivos de estos armado, por lo que direccionamos
a null que significa que no existe ning£n archivo de grupos.

AuthName: Es el string que aparecer  en la ventanita que levanta el browser,
cuando se le pregunte al usuario su ID y su password.

AuthType: es la clase de seguridad que implementamos. "Basic" significa 
Autentificaci¢n B sica HTTP, es decir que la informaci¢n enviada a trav‚s de
la red NO ser  encriptada sino que ser  "uuencodeada" (uuencoded), lo cual
nos da un nivel de protecci¢n similar al de una sesi¢n de telnet.
Existen otro m‚todos adem s de ‚ste tales como PEM, PGP, Kerberos V5 y Digest.

En el ejemplo que vimos solamente el m‚todo GET est  restringido usando la
directiva <Limit>. Para limitar otras m‚todos (particularmente en los
directorios CGI-BIN) se puede especificar los mismos separados por espacios
dentro de la directiva LIMIT. Por ejemplo:

<Limit GET POST PUT>
require user usuario1 usuario2 usuario3 .....
</Limit>

El comando "require" le dice al server cuales son los usuarios que est n
autorizados en ese directorio. Este comando puede tomar dos formas, "require
user" para limitar el acceso seg£n usuarios o bien "require group" para
limitar el acceso seg£n grupos de usuarios.
Existen otros comandos que pueden ser implementados en este nivel, como
"allow" y "deny" que permiten otorgar o denegar (respectivamente) el acceso
a un dominio en particular.

<Limit GET POST PUT>
order deny,allow
deny from all
allow from .mecon.ar
</Limit>

Restringiedo el acceso a los documentos de ese directorio a aquellas m quinas
que se encuentren en el dominio .mecon.ar y excluyendo a las restantes.
Cabe destacar que los ID utilizados son completamente arbitrarios (es decir no
tienen relaci¢n con los usuarios del server).


El archivo .htpasswd .
Este archivo consiste en una lista de los user ID y sus password encriptadas,
es un archivo de texto com£n por lo que puede ser movido, copiado o borrado
como cualquier otro.

Por ejemplo:

pedro:WkSK1DE7N8.9.
pablo:hQty39EV1.g56
diego:JeB31vf9PSTgw
susana:EDRfRrfrw43q

Como no podemos crear una password encriptada "a mano" usaremos una herramienta
llamada htpasswd que permite construir este tipo de archivos.
Esta herramienta se usa de la siguiente manera:

Server> htpasswd -c .htpasswd USUARIO
Adding password for USUARIO
New password:********
Re-type new password: *******

Si queremos modificar la password de USUARIO en otro momento usamos la misma
sintaxis. Para eliminar usuarios simplemente se borra la l¡nea correspondiente
dentro del archivo.


Proteccion a nivel de grupo
Cuando tenemos un gran n£mero de usuarios que mantener podemos facilitar el
manejo de los mismos separ ndolos en "grupos" creando un archivo de nombre
".htgroup" (por convenci¢n) con el siguiente formato:

nombregrupo1: primeruser segundouser  .... £ltimouser
nombregrupo2: primeruser segundouser  .... £ltimouser
nombregrupo3: primeruser segundouser  .... £ltimouser

y debemos cambiar el require por un "require group nombregrupo ".



Final del tutorial (por ahora).

Con el tema de las "passwords" damos por terminada la tercera parte de este
documento, lo que sigue es un ap‚ndice con links que me fueron bastante £tiles
al momento armarlo, la bibliograf¡a utilizada y algo de vocabulario.
Terminar esta tercera parte fu‚ algo m s que un triunfo, (pensar que hab¡a
planeado tenerla lista para fines de marzo:), cada vez que agarraba el doc
surg¡a un tema nuevo, y as¡. 
Releyendo las otras partes me doy cuenta que faltan algunos ¡tems (oh no..m s
laburo :P) o que por lo menos est n un poco incompletos, paciencia en cuanto
pueda sale una nueva versi¢n corregida y aumentada.
Lo pr¢ximo que tengo en mente en cuanto a tutorials estar  basado en el uso de
frames y JavaScript en p ginas HTML, una tecnolog¡a interesante pero no madura
del todo en este momento, as¡ como tambi‚n una mini-introducci¢n al lenguaje
Perl, de manera que en algunos meses m s empezar‚ por ese lado.
A prop¢sito, ustedes notar n que desde que empez¢ esto del tutorial mis
preferencias program ticas han ido cambiando a lo largo del tiempo. 
Estos cambios tienen su fundamento; Perl es portable, es f cil de usar y de
aprender, es freeware y adem s es interpretado de manera que el ciclo edici¢n/
testeo se hace mucho m s corto.
Escribir este tutorial fu‚ una tarea bastante grata, aprend¡ much¡simo tratan
do de explicar algunos conceptos,y como siempre para hacer de esta una tarea
completa espero sus comentarios (de los buenos y de los otros ;), en mi email:
dquir@indec.mecon.ar ,los cuales ser n de gran ayuda en mis proyectos futuros.

Suerte y buenos scripts!
(frase afanada de alg£n lado)
                                        Sebass.


Pr¢ximos Desarrollos.
El protocolo HTTP y HTTP-NG.
Meta Tags y su uso ( y abuso).
CGI scripts en otros lenguajes (Visual Basic por ejemplo)
HTML/CGI como front/end de nuestros programas.
Introduccion a Java y JavaScript.
Introduccion a Perl y aplicaciones CGI.

PD: Parece que no puedo dejar de escribir, no quer¡a dejar de comentar que las
versiones HTML y Word del tutorial estar n disponibles en breve.


--
APENDICE: Librer¡as para la Programaci¢n de scripts CGI.

Estos son los URL de las librer¡as utilizadas en los ejemplos de este documento.

Librer¡a C      ÄÄÄÄ> UnCGI      ÄÄÄÄ> http://www.hyperion.com/~koreth/uncgi.html
Librer¡a Pascal ÄÄÄÄ> TPWCGI     ÄÄÄÄ> http://141.2.61.48/tpwcgi/tpwcgi.htm
Librer¡a Perl   ÄÄÄÄ> CGI-LIB.PL ÄÄÄÄ> http://www.bio.cam.ac.uk/cgi-lin/1.14/cgi-lib.pl.txt


Sites con informaci¢n acerca de CGI.
Estos sites contienen mucha de la informaci¢n que fu‚ utilizada para crear
este documento y son realmente muy interesantes.

http://shani.net:80/~tls/guide/index.html
http://www.stars.com/Vlib/Providers/CGI.html
http://super.sonic.net/ann/delphi/cgicomp/detail.html
http://www.city.net/win-httpd/httpddoc/wincgi.htm
http://www.aspectse.com/Product/dbWeb/dbWeb.html
http://128.172.69.106:8080/cgi-bin/cgis.html
http://users.aol.com/thingtone/workshop/index.htm



Vocabulario - Siglas.

URL: Universal Resource Locator
     Una nomenclatura que describe en forma compacta la ubicaci¢n de cada
     recurso en la Internet y el protocolo utilizado para acceder al mismo.

MIME: Multipurpose Internet Mail Extensions
     Una nomenclatura que permite identificar  correctamente el tipo de
     datos que se esta enviando a trav‚s de una conexi¢n.

HTML: HyperText Markup Languaje
     Un lenguaje para el "armado" de documentos de hypertexto incluyendo
     "links" y algunas otras carater¡sticas adicionales.

CGI: Common Gateway Interface
    Un mecanismo que permite a los browser de Web ejecutar programas en el
    server Web y recibir la "salida" de estos programas.
    
HTTP: HyperText Transport Protocol
     Un protocolo para la transferencia de documentos de hypertexto y otro
     tipo de archivos.

VRML:Virtual Reality Modeling Languaje
     Un lenguaje que mediante "modelos" permite generar visiones 3D de un
     universo con "links" y otras caracter¡sticas adicionales.



Bibliograf¡a.

An exploration of Dynamic Documents - Netscape Corporation.
Very Limited Guide to HTML - Kevin Werbach.
CGI tutor - Bex Lanner.
HTML-based Interfaces - Nik Swoboda.
CGI Tutorial - Agora.
An guide to HTML and CGI scripts - Mike Smith.
Mosaic User Authentication Tutorial - NCSA.
Web Page Password Protecion - CNC.


FIN DE LA TERCERA PARTE - FIN DEL TUTORIAL
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿                     01/05/96
ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ» ³Sebasti n Quiroga.
ºEste documento puede ser reproducido en su  º ³
ºtotalidad o en parte siempre que se conserveº ³Email:   
ºesta postdata o bien se haga clara menci¢n  º ³ dquir@indec.mecon.ar
ºde la fuente.                               º ³ diego@comunicaciones.mecon.ar
ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼ ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄ¿  
³Versi¢n: 1.00³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
