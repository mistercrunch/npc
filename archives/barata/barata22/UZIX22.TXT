   Página Inicialhttp://www.inf.ufsc.br/barata Email derneval@bigfoot.com
                           Índice barata22.html

---------------------------------------------------------------------------

                   UZIX - Implementacao de UNIX para MSX

Adriano C. R. da Cunha adrcunha@dcc.unicamp.br
http://www.adrpage.cjb.net

Nao, voce nao leu errado. E' isso mesmo. Uma implementacao de UNIX para
MSX. Lembra-se do MSX? Daquele Expert com gravador cassete ligado numa
televisao preta-e-branca velha, com joguinhos horriveis de 16 cores? Aquela
maquininha arcaica e ultrapassada de 8 bits, clock de 3.5MHz, 64k de
memoria, discos 5 1/4" (quem tem menos de 15 anos nao deve conhecer isso)
onde voce programava so' em linguagem BASIC?

Bom, se a imagem que voce tem do MSX e' essa, pode esquece-la. Vamos
passa-la para algo mais real, afinal, a evolucao vem pra todos. Vamos falar
de MSX2, com memoria de ate' 48Mb, discos 3 1/2", cartucho FM de 12 canais,
CD-ROM, HD SCSI ou IDE. Se voce nao ficou satisfeito, terei que
apresenta-lo ao MSX2+ ou ao MSX Turbo-R, mas isso foge ao amago deste
artigo. Quem sabe uma outra vez?

Nao vou tambem ficar explicando o que e' UNIX. Se voce esta' lendo este
e-zine, e' por que sabe o que e' UNIX e sabe o seu poder como sistema
operacional.

Mas o que tem a ver essas duas coisas: Expert com cassete e UNIX? Tem que
as primeiras versoes do UNIX rodavam em PDP-8 e PDP-11. Essas maquinas
tinham poder de processamento igual ou inferior ao MSX. A primeira
"workstation" (assim chamada), foi uma PARC, que tinha entre 256k e 512k de
memoria e alguns megabytes de HD. Isso em 81. Logo, da' pra se notar que o
MSX nao perde tao feio para uma maquina dessas, que rodava UNIX.

Entao voce ja' deve ter entendido que UNIX e MSX nao sao coisas tao
incompativeis assim. E como surgiu isso?

Em 1988, um programador chamado Douglas Braun resolveu fazer um clone do
UNIX 7th Edition da AT&T. Mas resolveu faze-lo para Z80 (o processador do
MSX). E criou entao o UZI (Unix Zilog Implementation). O UZI tem um kernel
de 32kb e suas aplicacoes tem, no maximo, tambem 32kb. O UZI roda em
maquinas com 64kb de memoria e HD. Como o Z80 nao tem suporte a
multi-tarefa, o truque e' fazer a troca completa de contexto do processo
que esta' rodando, usando... o HD! E', o UZI requer um HD razoavelmente
rapido (para os padroes da maquina em que ele estiver rodando) para ter um
desempenho.

O mais interessante e' que o UZI e' todo escrito em C, sendo somente os
drivers e partes criticas (chaveamento de processos, por exemplo) escritas
em assembly (na verdade, foram escritas em codigo para 8080). Isso torna o
UZI extremamente facil de ser portado para outras maquinas.

De fato, Stephan Nitschke portou o UZI para maquinas usando o Z280 e
rodando CP/M, em 1998, chamando esta versao de UZI280. Harold Bower adaptou
o UZI280 para maquinas usando o Z180 e CP/M, chamando-o de Z180. O
desempenho do UZI280 e' inclusive superior ao do CP/M na mesma maquina
(obvio...).

E um dia, dois malucos, um russo chamado Arkady Schekochikhin e um
brasileiro chamado Adriano Cunha (este que vos escreve) se "toparam" na
lista internacional de discussao sobre MSX com um objetivo comum: portar o
UZI original para MSX. Decidiram unir esforcos e trabalhar nisso.
Resultado: o UZIX.

Voce deve ter pensado "Po^, mas ai' e' facil, ate' eu consigo!". Ah, ledo
engano... Pegar um fonte de 200kb em C, entende-lo, porta-lo para o
compilador que voce vai usar (todo mundo sabe que C e' quase tao portavel
quando assembly :), definir toda a estrutura de memoria usada, reescrever
todos os drivers do sistema, corrigir os bugs, criar bibliotecas para as
aplicacoes, etc, etc, etc, nao e' facil.

Mas depois de muito trabalho, chegou-se ao resultado desejado: um sistema
UNIX para MSX. E com tudo que tem direito: multitarefa preemptiva (e' isso
mesmo, nao e' cooperativa nao!), multiusuario, sistema de arquivos
montavel, permissoes, subdiretorios, "pipes", "links" ("hard" e "soft"
links), nomes de arquivos sem a restricao do "8.3", etc.

O UZIX e' limitado atualmente a um maximo de 31 processos simultaneos, cada
um deles com, no maximo, 32kb de codigo (totalizando 1Mb de memoria - na
verdade, isto poderia ser estendido a 127 processos (4Mb de memoria) ou, no
caso insano, 1523 processos, com 48Mb de memoria, mas isto e' maluquice :).
Se voce acha que 32kb nao da' pra nada, e' melhor trocar seu compilador...
Com 32kb de codigo a Konami fez Knightmare para MSX. Se voce nao entendeu,
entao talvez se eu disser que em 32kb e' possivel ter a Bourne Shell, voce
comece a achar que da' pra fazer muita coisa com 32768 bytes. E se voce ver
que o kernel completo do UZIX tem pouco menos de 32kb (28k, pra ser exato),
entao acho que nao preciso dizer mais nada. Na verdade, com excessao de
aplicacoes pesadas (emacs, vi, compiladores, flex, bison, yacc, awk, etc),
a maioria dos programas de UNIX pode ser portada e cabe neste espaco de
memoria (como voce pode perceber pelos cerca de 100 programas de UNIX ja'
portados para o UZIX). Este limite e', na verdade, do Z80, que so' endereca
64kb de memoria linear. 32kb sao ocupados pelo kernel, restando 32kb para a
aplicacao.

O UZIX foi feito para funcionar em maquinas MSX2 ou superiores. O motivo e'
a necessidade de memoria mapeada para a multitarefa e relogio de tempo real
para o sistema (alem do que, 80 colunas e' bem melhor que so' 40...). Mas,
na verdade, nada impede que o UZIX funcione em maquinas MSX1 (e'! aquele
Expert com gravador cassete do primeiro paragrafo!). As modificacoes que
teriam de ser feitas se concentrariam na parte de gerenciamento de memo ria
e multitarefa para o uso de outro tipo de expansao de memoria (como a
MegaRAM) e de simulacao de relogio de tempo real. E voce continuaria tendo
todas as caracteristicas e vantagens de um sistema UNIX, como as citadas
dois paragrafos acima.

Apesar de, como ja' foi dito, o Z80 nao possuir suporte a multi-tarefa, o
UZIX desempenha este papel muito bem. A tecnica usada e' a mesma do UZIX
original (troca completa de contexto de execucao), mas com uma vantagem:
usar memoria mapeada, que e' muito mais rapida. O resultado e' uma troca
muito mais rapida e suave entre processos. Como qualquer sis tema
multitarefa com um unico processador, o resultado e' a ilusao de execucao
paralela de processos diferentes. Em outras palavras (e nao se apegando a
formalismos tecnicos), voce tem multitarefa com um simples Z80. E mais,
voce tem multitarefa preemptiva: usa-se uma interrupcao periodica para
marcar o "timeslice" dos processos e sua troca quando o tempo maximo de uso
da CPU expira (sem precisar contar com a boa-vontade do processo de querer
ou nao deixar os outros programas usarem a CPU, como uns certos sisteminhas
fazem por ai').

Bom, nao vou gastar mais eletrons discursando sobre caracteristicas do UZIX
que sao comuns a quaisquer outras versoes de UNIX. Isso voce pode comprovar
usando o sistema. Se voce achou interessante, ficou curioso ou simplesmente
quer ver pra crer, de uma olhada na pagina do projeto. O sistema (por
incrivel que pareca) funciona em emuladores de MSX.

O endereco e':  http://www.dcc.unicamp.br/~adrcunha/uzix
