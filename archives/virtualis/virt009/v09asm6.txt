   ___________________________________________________________________
  |                                                                   |
  |  Curso de Assembly - Lição 6                                      |
  |                                                                   |
  |                       traduzido e adaptado do original de AESOFT  |
  |                                                    por Dr Herman  |
  |___________________________________________________________________|


  Lição 6

  -----------------------------------------------------------
  Codificação das instruções no 8086 (continuação da lição 5)   
  Modos de endereçamento no 8086
  -----------------------------------------------------------

  -----------------------------------------------------------
  Codificação das instruções no 8086 (continuação da lição 5)   
  -----------------------------------------------------------
  
  Na lição 5 ficamos de decifrar o valor do byte EA na seguinte 
  instrução:

    MOV WORD PTR DS:[7654H],5 ---> C7 06 54 76 05 00

  Ficou claro sobre o primeiro byte (código da operação) que nunca 
  oferece problemas de interpretação. E ficou claro também o campo 
  "deslocamento" (formado pelos bytes 3 e 4), assim como o campo "valor
  imediato" (formado pelos bytes 5 e 6).

  Mas quando falamos no segundo byte (byte EA ou endereçamento) surgia
  a dúvida. 

  Foi provando instruções parecidas que se clareou um pouco o cenário. 
  E como conclusão posso dizer que quando se endereça uma posição de 
  memória (como destino) sem ajuda de nenhum registro (SI, DI, BX+SI, 
  etc), o byte EA terá valor 06. Digo isso de modo empírico. Não li 
  em lugar algum. Baseei-me em testes para encontrar algum sentido  
  para este 06.

  Sinceramente, não sei o porquê desta peculiaridade. Tudo porque 
  coloquei este exemplo ! :) Por exemplo, se tivessemos usado um
  registro junto com o deslocamento nesta instrução, haveria problemas.
  Vejamos como ficaria a coisa:

    * MOV WORD PTR DS:[DI+7654H],5 ---> introduz o valor 5 (tipo
      palavra) na posição de memória endereçada por [DI] + 7654H.
      É praticamente igual a instrução anterior, exceto que nesta,
      incluímos o registro DI para acessar a posição de memória
      desejada.

      A codificação da instrução fica assim:
      MOV WORD PTR DS:[DI+7654H],5 ---> C7 85 54 76 05 00

      Vejamos o 'byte EA' desta instrução tão parecida com a anterior:
      85h em binário fica 10000101.

      O campo MOD com valor 10 indica que se usam 2 bytes para
      codificar o deslocamento. Até agora tudo perfeito: 2 bytes para
      armazenar o deslocamento 7654h.

      O campo REG com valor 000, já que o valor a ser atribuído não
      está em nenhum registro, pois é um dado imediato (05).

      O campo RM fica com valor 101, indicando que o endereço final vem
      dado por [DI] + deslocamento.
  
      Como podemos ver, a codificação desta instrução está de acordo
      com as normas de codificação que vimos na lição 5.
 
    Vejamos outro exemplo, para que fique mais claro:
    
    * MOV BYTE PTR [DI+7],0AEH

      Esta instrução coloca o valor 0AEH na posição de memória apontada
      por DI+7, dentro do segmento endereçado por DS. Vejamos a sua
      codificação:
   
      MOV BYTE PTR [DI+7],0AEH ---> C6 45 07 AE

      Em primeiro lugar, temos o código de operação C6, que indica ao
      processador que vamos transferir um dado imediato do tipo byte
      em uma posição de memória.
      
      O terceiro byte (campo deslocamento) tem o valor 7, que é o que
      foi indicado na instrução. Este valor é o que deve ser somado a
      DI para endereçar a posição de memória desejada. 

      O quarto byte (campo 'valor imediato') tem um valor de AE. Este
      valor é o que se deve depositar na posição de memória endereçada
      por DI+7.

      Só nos resta estudar o segundo byte (byte EA ou modo de
      endereçamento), o qual tem o valor de 45 (em hexa). Este 45,
      fica 01000101 em binário.

      Temos assim, o campo MOD com valor 01. Se olharmos as regras de
      codificação (ver lição 5), veremos que 01 indica que se utiliza
      um byte para indicar o deslocamento.
     
      O campo REG tem valor 000. Como não há nenhum registro envolvido
      nesta instrução, este campo não tem importância. 
     
      Por último, o campo R/M tem o valor 101. Isto indica que o
      deslocamento final será dado por [DI] + deslocamento.

      Como vimos, nesta instrução está totalmente claro cada valor em
      cada um dos campos do byte EA ou 'modo de endereçamento'.      

    Um último exemplo:

    * MOV WORD PTR [BX+SI+37H], AX

      Esta instrução introduz o valor do registro AX no endereço de
      memória indicado pelo valor da soma BX+SI+37H. Dentro do segmento
      DS, suponho. Sempre que não é especificado outro segmento, as
      transferências de/para memória serão feitas sobre o segmento DS.
    
      Vejamos sua codificação:

      MOV WORD PTR [BX+SI+37H], AX ---> 89 40 37

      Simplesmente 3 bytes para codificar esta instrução que parece tão
      complicada.

      O primeiro byte (código de operação) tem valor 89 (hexadecimal).
      Este código 89 indica que vai ser realizada uma transferência de
      dados do tipo palavra de um registro (tamanho palavra) para um
      destino que pode ser (dependendo do valor do byte EA): um
      registro de tamanho palavra ou um endereço de memória. Já sabemos
      que o registro trata de um endereço de memória porque o indicamos
      assim ao digitar a instrução, mas o processador não saberá até 
      que decifre o valor do byte EA.
 
      Este byte EA tem o valor 40h, que em binário é 01000000.
 
      O campo MOD tem o valor 01, que indica que se usa 1 byte para
      codificar o deslocamento. Só é necessário 1 byte para codificar
      o valor 37h.

      O campo REG, que aqui tem o valor 000, indica que o registro
      fonte empregado é AX.

      O campo R/M com valor 000, indica que o endereço final se obtém
      com a soma: [BX] + [SI] + deslocamento.

      Veja as tabelas na lição 5.

      Como vimos aqui, também está totalmente claro que o valor do byte
      EA.

      O terceiro byte (campo 'deslocamento') contém o valor 37h como é
      indicado na instrução.

  Espero que estes novos exemplos tenham sido ilustrativos.

  Se houver alguma dúvida sobre a codificação das instruções, levante
  a mão. :)


  ------------------------------
  Modos de endereçamento no 8086
  ------------------------------

  Como já vimos, as instruções são codificadas com 0, 1 ou 2 operandos.
  Estes operandos são cada um dos campos que podem compor uma instrução
  ('byte EA', 'deslocamento' e 'valor imediato'). Pois bem, as operações
  se realizam entre registros ou entre registros e memória -- nunca 
  entre memória e memória. Se dermos uma olhada no esquema de codificação, 
  daremos conta do porquê: não existem dois campos para armazenar duas 
  posições diferentes de memória, mas pode-se indicar dois registros 
  diferentes (um fonte e outro destino) numa mesma instrução.

  Existem vários modos de endereçamento. Esta variedade se oferece para
  uma maior comodidade na programação. Assim por exemplo, pode-se
  utilizar o modo direto, quando se conhece o endereço da posição de
  memória que nos interessa.
  
  O resto dos modos são utilizados quando vamos acessar uma posição de
  memória que não conhecemos, ou quando é mais cômodo por qualquer
  motivo.

  * Modos de endereçamento:

    Imediato
    --------
   
    O dado aparece diretamente na instrução. Quer dizer, é indicado 
    explicitamente na instrução.
  
    Exemplo: MOV AL, 0AEh ---> armazenda o valor AE no registro do tipo 
                               palavra (AL).


    Modo Registro
    -------------

    Quando se realizam transferências entre registros do processador.

    Exemplo: MOV AX, BX ---> introduz o valor de BX em AX.


    Direto absoluto em memória
    --------------------------

    Aparece na instrução de forma explícita o endereço no qual se quer
    acessar. Isto é, na codificação da instrução podemos encontrar 2
    bytes indicando a posição de memória que se quer endereçar.

    Exemplo: MOV CX, WORD PTR DS:[7777] ---> introduz o valor
                                             armazenado na posição de
                                             memória 7777 (dentro do
                                             registro DS) no registro
                                             do tipo palavra (CX).
    

    
    Direto relativo a um registro base
    ----------------------------------

    Acessa uma posição de memória com a ajuda de um registro base.
    Estes registros base, como já vimos, são BX e BP.

    O endereço final da posição de memória será indicado na forma:

      Endereço final = [Registro_Base] + deslocamento.
      Onde Registro_Base é BX ou BP.

    Exemplo: MOV AX,BYTE PTR [BX+7] ---> introduz em AX o valor contido
                                         na posição de memória
                                         endereçada por BX+7.

    Direto relativo a um registro índice (indexado)
    -----------------------------------------------
    
    O endereço se obtém somando um deslocamento (que será indicado na
    instrução) ao conteúdo de um registro índice. Registros índice são:
    SI e DI. Onde SI somente será utilizado como registro índice fonte.
    'Índice fonte' em inglês = 'Source Index' = SI. Obviamente, DI será
    utilizado como registro destino 'Índice destino' em inglês =
    'Destination Index' = DI.
  
    O endereço final da posição de memória indica-se da seguinte
    maneira:

      Endereço final = [Registro_índice] + deslocamento.
      Onde Registro_índice é SI ou DI. 

    Exemplo: MOV AX,WORD PTR [SI+7] ---> introduz em AX o valor contido
                                         na posição de memória
                                         endereçada por SI+7.

    Na verdade, exceto quando se utilizam os dois registros fontes numa
    mesma operação (ao copiar cadeias de caracteres, e.g.), neste caso
    tem que se atribuir a SI o endereço da cadeia de origem, e a DI o
    endereço da cadeia destino... Exceto neste tipo de operações,
    podemos fazer uso dos registros SI e DI indistintamente ao
    trabalhar com endereçamentos. Quer dizer, que as duas instruções
    seguintes são corretas, e realizam exatamente a mesma tarefa 
    (sempre que SI e DI tenha o mesmo valor):
 
       MOV AX,WORD PTR [SI+7]
       MOV AX,WORD PTR [DI+7]


 
    Modos de endereçamento indireto
    -------------------------------

    Se nos dois últimos modos de endereçamento não se especificava o
    deslocamento, então falamos de:
  
    Modo de endereçamento indireto por registro base,
    Modo de endereçamento indireto por registro índice,respectivamente.
  
    Exemplo: MOV AX, BYTE PTR [SI] ---> introduz em AX o conteúdo da
                                        posição de memória endereçada
                                        através de SI.


    Indexado através de uma base
    ----------------------------

    A posição de memória selecionada se endereça aqui mediante quatro
    configurações possíveis. Um registro BX ou BP contém a base e um
    registro SI ou DI contém o deslocamento. Além do mais, pode existir
    um deslocamento opcional indicado mediante um valor numérico.

    O endereço final da posição de memória se indica da seguinte forma:
   
      Endereço final = [Registro_Base]+[Registro_Índice]+deslocamento.
      Onde: Registro_Base é BX ou BP.
            Registro_Índice é SI ou DI. 

    Teremos assim as quatro configurações possíveis mencionadas:

      - [BX] + [SI] + deslocamento
      - [BX] + [DI] + deslocamento
      - [BP] + [SI] + deslocamento
      - [BP] + [DI] + deslocamento

    Exemplo: MOV BYTE PTR [BX+SI], AL ---> introduz o valor do registro
                                           AL na posição de memória
                                           endereçada por [BX] + [SI] +
                                           deslocamento.
 
    Em todos os modos de endereçamento, exceto nos dois primeiros,
    pode-se indicar um segmento diferente em DS para realizar as
    operações com a memória.
  
    Desta forma, podemos manejar todo o megabyte de memória sem a
    necessidade de modificar o valor do registro DS (registro de
    segmento de dados).

    Assim, podemos utilizar o registro ES quando quizermos acessar
    posições de  memória que estejam fora de nosso segmento de dados.

    Exemplo: MOV AX, WORD PTR ES:[BX+7] ---> introduz em AX o valor
                                             contido na posição de
                                             memória endereçada por
                                             BX+7, dentro do segmento
                                             indicado por ES.


  --------------------------------------------------------------------
  Virtualis nº9 -- Curso de Assembly - Lição 6
