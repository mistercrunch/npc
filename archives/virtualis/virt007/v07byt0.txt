   ___________________________________________________________________
  |                                                                   |
  |   Assembly para Crackers - versão 1.0                             |
  |                                                                   |
  |                               Autor: Corn2 - tradutor: Dr Herman  |
  |___________________________________________________________________|


  Introdução
  ----------

  Para aqueles que tem pressa em por a mão na massa e não querem
  esperar a conclusão do nosso curso de assembly, selecionei este
  tutorial. Ele é muito básico e talvez pessoas com poucos
  conhecimentos de programação não possam aproveitá-lo. A única coisa
  que posso recomendar é continuar com o curso e sair fuçando por aí
  para ver se aprende alguma coisa sozinho.


  Assembly para Crackers - v1.0 
  -----------------------------
  
  Olá, este é um guia muito básico de assembly para aqueles que não tem
  saco para aprender tudo sobre o funcionamento de seus computadores e
  serem capazes de usar o mIRC sem ter que clicar no nariz de um cara.
  :)

  Basicamente, mostrarei apenas as coisas mais importantes que vocês
  precisam saber antes de começar a craquear. EU SEI que as coisas não
  estão numa ordem lógica, mas o que você quer de graça ?


  REGISTRADORES
  -------------

  Registradores basicamente são locais usados para armazenar dados.
  Precisamos nos preocupar apenas com os seguintes: (E)AX, (E)BX,
  (E)CX, (E)DX. ( (E) é significante apenas quando debugamos 32-bits )
  
  Existem também os pares importantes:
  
  DS:SI ; pode ser usados como fonte para operações em string
  ES:DI ; usado como destino em operações de string
 
  Entender os registradores não é muito importante para craquear. O que
  devemos saber é que eles são variáveis usadas para armazenamento de
  dados.


  FLAGS
  -----

  Flags são parecidos com os registradores. Diferem no fato que apenas podem
  ser Verdadeiro ou Falso (i.e. 0 ou 1). São alterados por comandos como CMP,
  e são usados para verificar se um desvio deve ou não ser feito. Exemplo:
 
  CMP AX, BX     ; compara AX com BX; se forem iguais, o flag zero é colocado em 1
  JZ  00124531   ; se o flag zero estiver ligado, desvie a execução para o endereço
                 ; 001234531

  PILHA e PUSH/POP
  ----------------
 
  Antes de qualquer chamada de função, um programa deve "empilhar" quaisquer
  parâmetros que a função espera na pilha. Pense nela como uma pilha de pratos:
  o primeiro prato colocado na pilha é o último a ser retirado. É importante
  lembrar este "primeiro a entrar / último a sair" principalmente quando olharmos
  uma chamada de função. Isto significa que os parâmetros serão passados em ordem
  reversa...

  Se todo este blá-blá-blá confundiu sua cuca, dê uma olhada no exemplo a seguir:

  A função da API do Windows GetDlgItemText necessita dos seguintes parâmetros:

  (1) handle da caixa de diálogo
  (2) identificador do controle
  (3) endereço do buffer de texto
  (4) tamanho da string

  Portanto, estes parâmetros devem ser passados da seguinte forma:

  MOV EDI,[ESP+00000220]   ; coloca o handle da caixa de diálogo em EDI
  PUSH 00000100            ; PUSH (4) tamanho da string
  PUSH 00406130            ; PUSH (3) endereço do buffer de texto
  PUSH 00000405            ; PUSH (2) identificador do controle
  PUSH EDI                 ; PUSH (1) handle da caixa de diálogo
  CALL GetWindowText       ; chama a função 

  Fácil, não ? Este pode ser uma das maneiras mais fáceis de se craquear
  uma aplicação protegida por um número de série. Se você sabe o endereço
  do buffer do número de série, neste caso 00406130, apenas coloque uma
  parada (breakpoint) ali, e você acabará chegando até a rotina que gera
  o número de série !!!

  POP é usado para remover o item presente no topo da pilha. Geralmente
  existe uma porrada a ser removida antes de uma função retornar ao
  programa principal...


  AND
  ---
  USO       : AND destino, fonte
  DESCRIÇÃO : realiza um E lógico com as duas entradas (destino e
              fonte) e o resultado é colocado em destino
  EXEMPLO   : AND BX, 03h

  Não há muito a dizer sobre isso. AND faz o que diz.


  CALL
  ----
  USO       : CALL endereço
  DESCRIÇÃO : executa uma função localizada em 'endereço'
  EXEMPLO   : CALL 10284312

  Chama a função localizada no endereço 'endereço' e , uma vez
  que a função terminar, a execução continua na instrução após
  o CALL.


  CMP
  ---
  USO       : CMP destino, fonte 
  DESCRIÇÃO : Subtrai fonte de destino e atualiza os flags.
  EXEMPLO   : CMP AX, 03h

  Está é uma instrução importante para nós (crackers). Em algum lugar num 
  programa, é usada para verificar algo, i.e, comparar o verdadeiro número
  serial que aquele que entramos, ou checar se um programa foi registrado, 
  etc.

  Esta instrução geralmente precede algum tipo de instrução jump.


  INT
  ---
  USO       : INT número_da_interrupção
  DESCRIÇÃO : chama uma função padronizada (geralmente localizada na BIOS)
  EXEMPLO   : INT 10h

  Você não encontrará muito esta instrução (se encontrar) quando 
  estiver debugando programas Rwindows, mas ela é uma verdadeira "praga"
  em programas DOS. Geralmente os parâmetros são passados nos registros
  padrões (AX, BX, CX, etc).

  Existem muitas chamadas INT para listar aqui. É melhor você arrumar uma
  cópia de uma lista de interrupções. A lista do Ralph Brown é muito boa !
   

  JMP
  ---
  USO       : JMP endereço
  DESCRIÇÃO : Equivale ao comando GOTO da linguagem BASIC, salta para
              uma seção do código
  EXEMPLO   : JMP 00402011 

  JMP é um salto incondicional para uma seção de um programa.
  
  Existem toneladas de variações desta instrução, e as mais importantes são:
    JZ   -  Salta se o flag ZERO estiver setado. (o mesmo que JE)
    JNZ  -  Salta se o flag ZERO não estiver setado. (o mesmo que JNE)
  
  Geralmente, vem junto da instrução CMP:
    CMP SerialVerdadeiro, SerialDigitada   ; compara a serial verdadeira com a nossa
    JNE CaiForaCrackerRuim                 ; Se não for igual, sai.

  
  MOV
  ---
  USO       : MOV dest, fonte
  DESCRIÇÃO : Copia o byte ou a palavra (WORD) de fonte para destino.
  EXEMPLO   : MOV AX, DX

  Você verá isso uma porrada de vez quando estiver executando passo-a-passo
  um programa. Basicamente, significa (fazendo uma analogia com BASIC),
  LET dest = src , ou seja, uma atribuição.

  Existem poucas variantes incluindo MOVSX, mas todas basicamente fazem a 
  mesma coisa. Dar uma olhada na especificação da Intel deve ajudar.

  Se você não entendeu esta, cara, 'cê 'tá fodido ! ;)


  OR
  --
  USO       : OR dest, fonte
  DESCRIÇÃO : realiza um OU lógico nas duas entradas colocando o resultado em dest
  EXEMPLO   : OR DX, AX

  Faz o que diz.


  RET
  ---
  USO       : RET
  DESCRIÇÃO : retorna de uma função
  EXEMPLO   : RET

  Você freqüentemente a verá no final de uma função, e ela simplesmente instrui o
  processador para retornar ao endereço que chamou a função.


  Coisa úteis
  -----------
  Definições de programação de processadores Intel : www.intel.com
  Lista de interrupções de Ralph Brown             : procure-a
  Referência do programador Win32                  : vem com qualquer linguagem visual

  Até onde eu entendo, isso é tudo que você precisa saber para craquear.
  A maioria das coisas são auto-explicativas, mas se você tiver problemas,
  contacte-me em: Corn02@hotmail.com ou vá até #cracking4newbies na EFNET.
  Lá você encontrará alguém que possa te ajudar. Comentários e contribuições
  são bem-vindas.
