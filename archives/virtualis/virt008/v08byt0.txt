
   ___________________________________________________________________
  |                                                                   |
  |   Tutorial C Shell                                                |
  |                          Ben Yoshino <ben@wiliki.eng.hawaii.edu>  |
  |                                           traduzido por Dr Herman |
  |___________________________________________________________________|

  
  O que é um shell ?
  ------------------
 
  Um shell é um programa que fornece uma interface com o usuário. Com 
  um shell, usuários podem digitar comandos e executar programas em um
  sistema Unix. Basicamente, a função principal que um shell realiza é
  ler o que é digitado em um terminal, executar os comandos e mostrar
  a saída para estes comandos.

  
  O que é tão bom no shell C ?
  ----------------------------

  O shell C foi escrito por Bill Joy na Universidade da Califórnia em
  Berkeley. Sua intenção principal ao escrever o shell C era criar um
  shell com uma sintaxe parecida com a linguagem C.

 
  O que pode ser feito como o shell C ?
  -------------------------------------
  
  O principal uso do shell C é como um shell interativo, mas podemos
  usá-lo para fazer programas também. Estes programas são chamados de
  'scripts shell'.

  
  Características do shell C
  --------------------------

  Algumas das características do shell C estão listadas aqui:
  
    - ambiente customizável;
    - comandos abreviados (aliases)
    - histórico (armazena comandos digitados anteriormente)
    - controle de jobs (executa programas em background ou não)
    - scripts shell (possibita a escrita de programas usando o shell)
    - atalhos de teclado


  Características do ambiente shell
  ---------------------------------

  O shell C fornece as facilidades de programação listadas abaixo:

    - construções de controle (exemplo: loop e comandos condicionais)
    - checagem de existência e permissionamento de arquivos
    - atribuição de variáveis
    - variáveis embutidas


  Arquivo para a customização do ambiente shell C 
  -----------------------------------------------

  O shell C tem três arquivos distintos que são usados para customizar
  seu ambiente. Estes três arquivos são .cshrc, .login, e .logout.
  Por estes arquivos começarem com . (ponto), eles geralmente não
  aparecem quando digitamos o comando ls. Para vermos estes arquivos
  que começam com ponto, a opção -a é usada como o comando ls.

  O arquivo .cshrc contém comandos, definições de variáveis e aliases
  usadas sempre que o C shell roda. Quando alguém se loga, o shell C
  começa lendo o arquivo .cshrc, e inicia estas variáveis e aliases.  

  O shell C lê o arquivo .login após ter lido o arquivo .cshrc. Este
  arquivo é lido uma vez apenas para login. Este arquivo deve ser 
  usado para configurações de terminais, por exemplo, backspace,
  suspend, e interrupt caracteres.

  O arquivo .logout contém comandos que devem ser executados após o
  usuário ter saído (logout) do sistema.


  Exemplo do arquivo .cshrc

  #!/bin/csh
  setenv EXINIT 'set smd sw=4 wm=2'
  set history=50
  set savehist=50
  set ignoreeof noclobber
  if ($?prompt) then
    set prompt='[\!]% '
    alias f finger -R
    alias lo logout
  endif


  Exempolo do arquivo .login

  #!/bin/csh
  stty erase ^H intr ^C susp ^Z
  echo "Bem-vindo ao Inferno\!"
  frm -s n
  

  Exemplo do arquivo .logout

  #!/bin/csh
  # Sample .logout file
  echo -n "Saindo do Inferno"
  date
  

  Caracteres especiais no shell C
  -------------------------------

  Alguns caracteres são especiais no shell, e a fim de digitá-los
  devemos precedê-los com uma barra invertida (\). Alguns estão
  listados aqui juntamente com seu significado para o shell.

  !    substituição do histórico 
  < >  redirecionamento de entrada / saída 
  |    pipes
  *    substitui qualquer string de zero ou mais caracteres
  ?    substitui um caractere qualquer
  [ ]  substitui qualquer conjunto de caracteres contido nos colchetes
  { }  substitui qualquer palavra da lista separada por vírgulas
  ;    usado para separar comandos
  &    usado também para separar comandos, mas coloca-os em background
  \    'Quota' o caractere seguinte
  $    obtêm o valor da variável
  '    toma o texto entre aspas literalmente
  `    toma o texto entre aspas como um comando, e o substitui com a
       saída
  "    toma o texto entre aspas, após substituir qualquer variável
       existente


  Variáveis
  ---------

  Variáveis no C shell são definidas usando o comando interno set. O
  shell C suporta variáveis simples e arrays (vetores). Alguns exemplos
  estão abaixo:
   
  set var1=a3       # coloca o valor a3 em var1
  set var2=(a b c)  # coloca os valores a,b e c na variável array var2


  Usando variáveis
  ----------------

  Variáveis podem ser usadas em shell C digitando um cifrão ($) antes
  do nome da variável. Se a variável é um array, o índice pode ser
  especificado usando colchetes, e o número de elementos pode ser
  obtido usando a seguinte sintaxe:

    $#var2

  A existência de variáveis pode ser checada usando a sintaxe
  $?variavel. Se a variável existir, a expressão retorna 1 (verdadeiro).
  Caso contrário, retorna 0 (falso). Cálculos simples envolvendo números
  inteiros podem ser realizados pelo shell C, usando os operadores da
  linguagem C. Para atribuir um valor calculado, o comando @ é usado
  como se segue:

    @ var = $a + $x * $z


  Variáveis pré-definidas do shell C
  ----------------------------------

  Certas variáveis controlam o comportamento do shell C, e algumas não
  necessitam de um valor (i.e., podem ser iniciadas apenas usando o
  comando set sem nenhum valor). O comando unset pode ser usado para 
  limpar quaisquer variáveis indesejadas.

  argv
    Variável especial usada por scripts shell para armazenar o valor
    de argumentos.

  autologout
    Contém o número de minutos que o shell pode ficar ocioso antes de
    efetuar um logout automaticamente.

  history
    Indica quantas linhas de histórico (comandos digitados anteriormente)
    devem ser armazenadas.

  ignoreeof
    Previne o logout por um control-D.

  noclobber
    Previne a sobrescrita de arquivos ao se usar redirecionamento.

  path
    Contém a lista de diretórios que podem ser procurados quando se
    exectam programas ou scripts shell.

  prompt
    Contém a string do prompt.

  term
    Contém o tipo do terminal atual.


  Histórico
  ---------

  Se a variável history é iniciada com um valor numérico, uma lista de
  comandos com comprimento deste valor, armazena os comandos digitados.
  Comandos do histórico são numerados começando com 1. Para ver o
  histórico, o comando history é usado.

  Comandos do histórico podem ser chamados novamente usando o ponto de
  exclamação. Por exemplo, !! repete o comando anterior, !25 repete o 
  comando número 25 do histórico, e !-2 repete o penúltimo comando.
  
  Pedaços de comandos também podem ser recuperados usando o histórico.
  Por exemplo, !25:$ retorna o último argumento (palavra) do comando 
  número 25, !!:* , retorna todos os argumentos (todas as palavras menos
  a última) do últimom comando, e !-2:0 retorna o comando (a primeira
  palavra) do penúltimo comando.

 
  Aliasing
  --------

  Uma abreviação pode ser atribuída para um comando ou seqüência de 
  comandos que são usados com freqüência. Ao atribuir um alias via
  comando alias, podemos criar nossos próprios comandos, e mesmo
  "sobrepor" comandos já existentes. Por exemplo:

    alias cc cc -Aa -D_HPUX_SOURCE

  Esta definição de alias substituirá cc com a opção de compilação ANSI
  num sistema HP (como Wiliki) sempre que cc for digitado. Para retirar
  uma definição de alias, devemos usar o comando unalias.

  Se os nomes de arquivos usados após um alias devem vir antes do texto
  ser substituído, a substituição do histórico pode ser usada, como 
  segue:

    alias manl 'man \!* | less -p'


  Esta forma do comando coloca argumentos colocados apos o alias man1,
  entre o comando man e | (pipe).



  Redirecionamento de entrada e saída
  -----------------------------------

  A entrada e saída de comandos podem ser enviadas ou pegas em arquivos
  usando o redirecionamento. Alguns exemplos são mostrados a seguir:

  date > arquivoData
    A saída do comando date é salva no arquivo arquivoData.

  a.out < arquivoEntrada
    O programa a.out recebe sua entrada do arquivo arquivoEntrada.
    
  sort arquivo2 >> arquivoTotal
    O comando sorte retorna sua saída e a anexa com arquivoTotal.

  Uma forma especial de redirecionamento usada em scripts shell:

  calcula << END_OF_FILE
  ...
  ...
  END_OF_FILE

  
  Nesta forma, a entrada é pega do arquivo atual (geralmente o próprio
  arquivo script shell) até que a string seguida por "<<" for 
  encontrada.

  Se a variável especial, noclobber, estiver setada (com valor), 
  qualquer operação de redirecionamento que vá sobrescrever um arquivo
  acontecer, uma mensagem de erro será dada e o redirecionamento
  falhará. A fim de forçar a sobrescrita de um arquivo já existente
  usando o redirecionamento, basta anexar um ponto de exclamação (!)
  após o comando de redirecionamento. Exemplo:   

    date >! arquivoData

  O arquivo arquivoData será sobrescrito independente de sua existência
  e conteúdo.

  Colocando um e-comercial (&) no final de um comando de redirecionamento
  de saída, juntará tanto a mensagem de erro e a saída padrão e colocará
  a saída no arquivo especificado.


  Pipes
  -----

  A saída de um comando pode ser enviada para a entrada de um outro
  comando. Isto é chamado "piping". Os comandos que são "pipeados" são
  separados pelo caractere | . Por exemplo:

    ls -l | sort -k 5n

  Este comando pega a saída do comando  ls -l  e a coloca como entrada
  do comando sort.

  Colocando-se um e-comercial (&) após o caractere "pipe", podemos 
  combinar o erro e a saída padrão e enviá-los para a entrada padrão do
  programa que recebe a saída do pipe.


  Controle de processos
  ---------------------

  O shell C permite o controle de processos. Isso permite que um usuário
  execute programa em background, e chame-os para 'foreground' quando
  necessário. Para colocar em background um processo que esteja em
  execução, o caractere 'suspend' deve ser definido pelo comando stty
  mostrado anterior. Processos podem ser colocados em background
  colocando o caractere & no final do comando.
  
  Quando um processo é colocado em background, informação para o
  processo é mostrada de maneira similiar ao exemplo abaixo:

  [1] 15934

  Isso especifica que o processo foi colocado em background, e é o
  processo 1. Para chamar processos colocados em background, o comando
  fg é usado, enquanto o comando bg coloca um processo recentemente 
  parado em background. O comando jobs mostra uma lista de todos os
  processos sobre o controle do shell atual. Colocando-se um sinal de
  porcentagem (%) com o número do  processo, coloca este processo em
  particular em 'foreground'.


  Estruturas de controle
  ----------------------

  O shell C possui estruturas de controle similares a linguagem C. São
  elas: foreach, if, switch e while. Geralmente são usadas em scripts.

  Existem duas formas do comando if. A primeira possui um comando 
  simples após a expressão. Este comando não pode ser um alias nem
  pode usar comandos que usando backquote (`). A segunda forma do
  comando if deve ter a palavra, seguida da expressão. Vários comandos
  if podem ser aninhados, através do uso do comando else. Este comando
  deve ter um comando endif correspondente.  

    Primeira forma
      if (expressão) comando

    Segunda forma
      if (expressão) then
      ...
      else
      ...
      endif

  O comando switch pode substituir vários comandos if ... then. Para
  uma determinada string fornecida ao comando switch, os comandos case
  que "casaram" com esta string são executados até que se encontre um
  comando endsw. Estes padrões podem conter ? e * para casar grupos de
  caracteres ou caracteres específicos.

    switch (string)
      case padrão1:
        comandos ...
        breaksw
      case padrão2:
        comandos ...
        breaksw
      default:
        comandos ...
        breaksw
    endsw

  O comando while entrará no loop apenas se a expressão for verdadeira
  (ou não zero). Uma vez dentro do loop, os comandos internos serão 
  executados até que a expressão seja falsa (zero).

    while (expressão)
      commands...
    end

  O comando foreach pega uma variável do tipo array e coloca cada um
  dos seus elementos na variável do loop para cada iteração.
  
    foreach variável (array ou lista)
    ...
    end
    
  O comando break sai do loop atual.

    break

  O comando continue retorna ao topo do loop atual após testar a 
  condição para o loop.
  
    continue

  O comando shift sem argumentos diminuirá em um o índice a variável
  argv. Ou seja, argv[2] será argv[1] e assim por diante. Se for
  fornecido um argumento -- um array -- o comando shift fará a mesma
  operação. 

  
    shift
    shift array


  Expressões condicionais
  -----------------------

  As expressões usadas nos comandos while e if são similares as
  expressões da linguagem C exceto o seguinte:

  =~  se o lado direito "casa" com um padrão, a condição é verdadeira.

  !~  se o lado direito não "casa" com um padrão, a condição é verdadeira.

  -d $var
    Verdadeiro se o arquivo é um diretório

  -e $var
    Verdadeiro se o arquivo existe.

  -f $var
    Verdadeiro se o arquivo é um arquivo (i.e., não é um diretório).

  -o $var
    Verdadeiro se o usuário é dono do arquivo (owner).

  -r $var
    Verdadeiro se o usuário tem permissão para leitura.     

  -w $var
    Verdadeiro se o usuário tem permissão para escrita.

  -x $var
    Verdadeiro se o usuário tem permissão para executar.

  -z $var
    Verdadeiro se o arquivo tem tamanho zero.


  Atalhos para linhas de comandos
  -------------------------------

  Aqui estão algumas teclas que podem ser pressionadas para realizar 
  certas funções.

  <escape>

    A tecla escape (ou ESC) precedida por parte de um comando ou nome
    de arquivo, tentará completar o comando ou nome de arquivo. Se há
    mais do que um comando que "casa" com o que já foi digitado, o 
    shell C mostrará as letras em comum e bipará.

  Control-D

    Quando digitado apoós um parte de um nome de arquivo, o shell C 
    mostrará uma lista de todos os comandos e nomes de arquivos que
    "casam" com o que já foi digitado.

  Control-W

    Apaga a palavra anterior.



  Scripts shell
  -------------
 
  Scripts shell são programas escritos em shell C. São arquivos textos
  que podem ser editados e criados em qualquer editor de texto.
  Entretanto, existem algumas regras a serem seguidas.

  1. Criar um arquivo usando qualquer editor de texto. A primeira linha
     deve começar com a string #!/bin/chs

  2. Dê permissão a você para executar com o comando 
     chmod u+x nome_do_arquivo

  3. Você pode executar o script shell simplesmente digitando o nome do
     arquivos como se ele fosse um comando normal.

  O script shell pode conter quaisquer comandos que possam ser digitados
  assim como as estruturas de controle descritas acima.


  Argumentos para scripts shell
  -----------------------------

  Quando você escreve um script shell, uma variável especial do tipo
  array chamada argv é criada como os argumentos digitados. Por exemplo,
  se o script shell testador for criado, e for executado digitando os
  argumentos como mostrado, testador um dois pulo, o array argv conterá
  "um", "dois" e "pulo" como seus três elementos.

