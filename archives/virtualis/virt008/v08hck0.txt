
  __________________________________________________________________
 |                                                                  |
 |  Outro documento sobre segurança no Linux - beta 0.2             |
 |                                                                  |
 |                                 Dr. Herman <virtualis@yahoo.com> |
 |                                                                  |
 |       traduzido do original "Another Paper on Linux Security" de |
 |                                Bronc Buster <bronc@shocking.com> |
 |__________________________________________________________________|


  Introdução
  ----------

  É grande o número de pessoas interessadas em usar o Linux hoje em
  dia. Semprem destacam sua estabilidade e sua segurança. Mas para
  alcançar esta segurança é necessário algum conhecimento. 
  
  Traduzi este excelente documento para todos que desejam ter uma
  máquina mais segura.


                                . . . 

  Outro documento sobre segurança em Linux ? Por que ? Bom, a maioria 
  dos que tenho visto por aí nunca são completos, são apenas dicas e
  truques de como deixar uma parte sugura, ou como ajustar um daemon
  ou processo, ou como corrigir rapidamente um problema. Eles nunca
  cobrem cobrem o processo inteiro, i.e., desde que o SO entra no
  modo multiusuário, com vários usuários se logando e disparando
  processos e tudo mais que isso implica. Eu quero cobrir isso. Eu
  sei, não importa o quanto eu tente, eu sempre vou esquecer alguma
  coisa, mas vou tentar cobrir tudo que faço quando eu instalo um
  sistema e o preparo para se utilizado. Além disso, indico algumas
  ferramentas gratuitas que considero muito eficazes.

  Mas atenção, se você está totalmente perdido e não conhece nada
  de Linux, vou poupar-lhe tempo e dizer-lhe para parar por aqui.
  Para que este documento seja útil, você deve ser um usuário de
  nível intermediário, ou um administrador que seja familiar com
  Unix. Se você está pensando em seguir este artigo durante a
  instação de seu sistema, LEIA-O PRIMEIRO, e então siga-o, caso
  contrário você pode esquecer alguma coisa ao instalar ou
  configurar um kernel.  

  Devo dizer-lhe uma coisa antes de você começar. Este documento é
  um trabalho em andamento. Desejo que seja um documento de fácil
  compreensão, portanto agradeço todas as sugestões, dicas e
  conselhos de como tornar este documento melhor.

  -------------------------------------------------------------------

  Conteúdo

  1. Instalação
  2. Boot
  3. Arquivos SUID e o sistema de arquivos
  4. Quotas
  5. Logs
  6. Segurança de acesso (remota e física)
  7. Outros arquivos 
  8. Ferramentas de terceiros
  9. Conclusões

  -------------------------------------------------------------------

  1. Instalação

  Este é um passo que todo artigo que eu vi desprezou. Desde a
  instalação você pode eliminar cerca de 1/3 dos problemas se 
  instalar corretamente, escolhendo apenas o que seu sistema
  necessita. Pense nisso. Pergunte-se: para que esta máquina vai
  ser usada ? Vai estar em rede como um servidor de arquivos de
  algum tipo, ou vai estar diretamente conectada a Internet como
  um servidor web, ou em sua casa executando PPP ? São perguntas
  importantes que você precisa responder ANTES de iniciar a 
  instalação.
  
  Se o sistema vai ficar num rack, como um servidor web, porque você
  instalaria o X-Windows ? Se você não vai usá-lo, no máximo dar uma
  olhadinha dia ou outro, saiba que é isso que um invasor está 
  procurando. Junto disso, temos programas SUID, programas que você
  pode nem saber que existem, mas que os invasores ficam loucos como
  um tubarão perto de sangue. Por outro lado, numa rede, onde você
  vai ficar no console, e um servidor X-Windows é necessário, veja
  outros componentes que você não vai usar, como PPP ou SLIP.

  Se você não tem certeza, compre um livro ou, se você é realmente
  pobre, pegue um emprestado. Leia o que cada componente faz e porque
  você precisaria dele. Na pior das hipóteses, ao instalar, leia cada
  seção cuidadosamente antes de ir marcando tudo que aparecer pela
  frente. Releia partes que são obscuras e não instale se você achar
  que não precisará daquele componente. Lembre-se que você sempre
  pode instalar componentes mais tarde. O sistema de arquivos do
  Unix pode ser muito complexo e profundo, e os invasores dependem
  disto quando estão escondendo programas e backdoors. Quanto mais 
  você entender o que você deve colocar em seu sistema, melhor saberá
  o que deve e o que não deve estar em sua máquina. Quanto menos
  coisas desnecessárias em seu sistema, menos você terá que se 
  preocupar mais tarde. Então, pare agora, antes de instalar, e pense
  no que você quer instalar.

  -------------------------------------------------------------------

  2. Boot

  Ok, após várias horas você consegui instalar o sistema, e agora
  você prepara para "bootá-lo". Se tudo der certo, o sistema entrará
  sem problemas. Se ocorrerem erros, serão os primeiros problemas que
  terá que resolver. No Linux (Slackware), existe um diretório
  chamado '/etc/rc.d' que guarda os arquivos que dizem ao seu sistema
  o que executar durante o boot. Este, como você pode imaginar, é um
  diretório muito importante, já que se alguém tiver acesso a estes
  arquivos poderá instalar uma 'backdoor', ou um processo que seja
  perigoso para seu sistema.

  De volta aos erros, e a edição de cada um destes arquivos.
  
  A maioria das pessoas, a menos que tenham experiência com Linux,
  ou não sabem da existência destes arquivos, ou não sabem o que
  fazer com eles ou têm medo de fuçar, lembrando-se do seus dias
  com o rwin95, onde você mexia num arquivo que controlava o boot
  e podia perder tudo e ter que reinstalar o sistema operacional.
  Não tema, isso aqui é Linux !
 
  hellbata:/etc/rc.d# ls -l
  total 40
  lrwxrwxrwx   1 root     root      4 Jun  5 01:31 rc.0 ->   rc.6*
  -rwxr-xr-x   1 root     root    396 Oct  2  1995 rc.4*
  -rwxr-xr-x   1 root     root   2273 Oct 17  1996 rc.6*
  -rwxr-xr-x   1 root     root   1244 May 21  1997 rc.K*
  -rwxr-xr-x   1 root     root   3439 Sep 25  1997 rc.M*
  -rwxr-xr-x   1 root     root   5054 Jun 16  1997 rc.S*
  -rw-r--r--   1 root     root   1336 Jul  9  1997 rc.cdrom
  -rwxr-xr-x   1 root     root     52 Jun 12 12:24 rc.httpd*
  -rwxr-xr-x   1 root     root   2071 Jul 29 14:19 rc.inet1*
  -rwxr-xr-x   1 root     root   2846 Jul  2 20:41 rc.inet2*
  -rwxr-xr-x   1 root     root    735 Jun 30 22:10 rc.local*
  -rwxr-xr-x   1 root     root   5251 Jun  5 09:23 rc.modules*
  -rwxr-xr-x   1 root     root   9059 Aug 23  1997 rc.serial*

  Eis um típico diretório '/etc/rc.d/'. Cada um dos arquivos 'rc.*'
  faz algo específico, dependendo do estado do sistema. Alguns deles
  são auto-explicativos, como 'rc.httpd', que simplesmente dispara
  seu servidor web HTTPD. O 'rc.cdrom' carrega seu drive de CD-ROM,
  se ele é suportado pelo seu kernel. O 'rc.modules' carrega módulos,
  se você tiver algum (módulos são drivers especiais ou programas
  que são adicionados ao kernel durante o boot, mas que não são
  compilados dentro do kernel. Modules são usados por NICs, às vezes
  modems e outros tipos de hardwares.) 'rc.serial' também é usado
  para carregar dispositivos seriais, como modems, impressoras e
  outras coisas. A maioria dos arquivos 'rc.*' que possuem nomes
  próprios, como '.cdrom', '.modules', '.serial' e '.httpd' não 
  devem ser mexidos já que foram automaticamente configurados pelas
  escolhas que você fez quando instalou o sistema. Alguns dos outros
  arquivos controlam as diferenças entre 'Modo Monousuário' e 'Modo
  Multiusuário', e alguns outros controlam quais daemons carregar e
  o que seu sistema operacional pode fazer.

  'rc.M' controla o sistema quando este passa para o 'Modo
  Multiusuário e carrega alguns outros arquivos 'rc.*', se houver,
  como 'rc.cdrom', etc. Examine este arquivo cuidadosamente ! Tudo
  que você não precisar, comente com um '#'. Na maioria dos casos,
  não terá muita coisa para mexer neste arquivo, mas terá nos outros.
  Vá até o arquivo 'rc.M' e olhe em cada um dos outros arquivos
  'rc.*' que ele executa. Olhe em cada um destes arquivos e repita
  o processo.

  Por exemplo, digamos que você está examinando o arquivo 'rc.inet2'
  e você não precise do nenhum serviço 'rpc' e você não quer que seu
  portmapper execute, basta comentar estas linhas e eles não serão
  executados.

  # Normalmente é assim que aparece. Para comentar, use #

  --- trecho ---
  # inicia o SUN RPC Portmapper.
  if [ -f ${NET}/rpc.portmap ]; then
    echo -n " portmap"
    ${NET}/rpc.portmap
  fi
  --- trecho ---


  # Eis a versão comentada

  --- trecho ---
  # inicia o SUN RPC Portmapper.
  #if [ -f ${NET}/rpc.portmap ]; then
  #   echo -n " portmap"
  #   ${NET}/rpc.portmap
  #fi
  --- trecho ---


  É importante editar o arquivo inteiro, do 'if' inicial até o 'fi' 
  correspondente no final, caso contrário você gerará alguns erros.
  Poderia passar por todos os arquivo e programas lançados por cada
  um dos arquivos 'rc.*', mas apenas você sabe quais são necessários,
  dependendo do tipo de servidor que você tem. Lembre-se que você
  precisa saber o que é necessário para que tudo funcione e então
  remova o resto. Se não tem certeza do que cada programa faz,
  pesquise na Rede e descubra o que ele faz e assim você vai saber
  se ele é necessário ou não.

  O arquivo 'rc.local' também é um arquivo importante no diretório
  'rc.d', ele possui todos os arquivos ou programa que você queira
  que seja executado durante o boot. Você pode incluir pode incluir
  qualquer coisa lá como você verá mais adiante.

  -------------------------------------------------------------------

  3. Arquivos SUID e o sistema de arquivos

  Antes que um usuário entre no meu sistema, eu me certifico em achar
  e isolar todos, repito, TODOS arquivos SUID no sistema. Primeiro,
  você precisa encontrar todos os arquivos SUID. Os comandos abaixo
  mostrarão onde estão todos eles:

  find / -perm 4000 >> suid.txt
  find / -perm 4700 >> suid.txt
  find / -perm 4777 >> suid.txt
  find / -perm 4770 >> suid.txt
  find / -perm 4755 >> suid.txt
  find / -perm 4750 >> suid.txt
  find / -perm 4751 >> suid.txt
  find / -perm 4500 >> suid.txt
  find / -perm 4555 >> suid.txt
  find / -perm 4550 >> suid.txt
  find / -perm 4551 >> suid.txt

  Agora tudo que você deve fazer é dar uma olhada no arquivo
  'suid.txt' e você terá os caminhos para todos os arquivos SUID no
  seu sistema. Em alguns sistemas, basta digitar 
  
  'find / -perm 4000 -print >> suid.txt' ou
  'find / -perm +4000 -print >> suid.txt' 
  
  que o resultado será o mesmo, mas já tive sistemas que não 
  mostraram todos os arquivos SUID por alguma razão. Para me
  certificar, eu uso um script simples que executa todos os comandos
  de uma vez só para que eu não tenha que ficar digitando sempre
  todos os comandos.

  Após ter encontrado todos os arquivos SUID, agora você terá que
  olhar todos estes arquivos e decidir quais você precisa, e quais
  seus usuários terão acesso. Nos meus sistemas, eu deixo os
  seguintes arquivos SUID, e dou um 'chmod 000' no resto.

    passwd
    ping
    traceroute
    screen
    su

  Todos os outros arquivo que podem ser SUID, os usuários não
  precisam usar, a menos que você esteja usando NFS ou X Server.
  Mantenha uma lista dos arquivos SUID no seu diretório home e
  assim você poderá lembrar onde eles estão se você precisar. O
  restante destes arquivos SUID, eu os movo para o mesmo diretório,
  e assim posso tê-los sob controle. Os meus estão em 
  '/usr/local/bin' ou '/bin' e assim, estão sobre o $PATH dos
  usuários. Mais adiante, mostrarei alguns programas alternativos (e
  até mais seguros). E lembre-se, é você, o administrador, quem
  decide quais programas você deseja que seus usuários acessem !!!
  
  -------------------------------------------------------------------

  4. Quotas

  Eu sempre uso quotas! A menos que você seja um provedor Internet
  comum, ou tenha algum motivo para limitar a quantidade de espaço
  que cada usuário poderá usar, a maioria não se importa com quotas.
  Bem, esta é uma atitude errada. Quotas podem salvar seu sistema de
  um usuário ignorante ou sacana. Quotas não apenas controlam quanto
  espaço um usuário pode usar, mas também controlam o número total
  de arquivos (inodes) que podem criar. Pense num usuário que faz um
  loop que cria diretórios ou arquivos de um byte ? Ele não apenas
  pode 'comer' toda a CPU e memória como, encher seu HD. Uma quota
  bem planejada não apenas pode impedir isso de acontecer, mas 
  também impedir que alguém sem cota encha seu HD com lixo. Testei
  um sistema Linux 3.0 (Slackware), com kernel 2.0.20. Enchi o HD e
  ele travou e não pude digitar mais nenhum comando. Nem mesmo
  consegui dar um 'shutdown' e bootá-lo novamente !

  Para usar quotas em seu sistema, simplesmente a selecione durante
  a instalação. Será instalado o componente quota, que inclui todos
  os programas necessários para sair trabalhando. Mais tarde você
  DEVE recompilar seu kernel para usar quotas, caso contrário ela
  não irá funcionar. Não vou ensinar como compilar o kernel. Este
  processo está mais do que documentado (dê uma olhada em 
  Kernel-HOWTO.tar.gz).

  Uma vez que o suporte a quotas esteja instalado no seu kernel, 
  inclua as linhas seguintes no final de seu arquivo '/etc/rc.local':

  # Suporte a quota e verificação de arquivo
  if [ -x /usr/sbin/quotacheck ] then
    echo "Verificando quotas. Este processo pode demorar."
    /usr/sbin/quotacheck -avug
    echo "Pronto."
  fi

  # Ligando quotas
  if [ -x /usr/sbin/quotaon ] then
    echo "Ligando quotas."
    /usr/sbin/quotaon -avug
  fi

  # Done


  Uma vez que você reinicialize a máquina, 'quotacheck' primeiro irá
  verificar o sistema de arquivos e certificar-se que ninguém está
  ultrapassando sua cota, e então 'quotaon' ligará o suporte a cotas
  em seu sistema. Um comando simples - 'quota usuário' - lhe
  informará as quotas de um usuário, ou 'quota grupo' lhe mostrará a
  cota de um grupo. Para alterar uma cota, use o comando 
  'edquota [usuário] ou [grupo]'. Isso abrirá um arquivo temporário
  em seu editor, como especificado em seu '.profile', e lhe dará o
  poder de alterar as quotas de um usuário ou grupo de usuários. Por
  exemplo:

  hellbata:/admin/bronc# edquota tidepool
 
  Quotas for user tidepool:
  /dev/hda1: blocks in use: 279, limits (soft = 10000, hard = 15000)
             inodes in use: 35, limits (soft = 1300, hard = 1500)


  Daqui você pode ver que a cota do usuário tidepooll no hda1 é 
  10 MB soft e 15 MB hard. Isso dá ao usuário um período de
  "perdão" para ficar com esta quota estourada. Se ele continuar com
  a quota estourada após o período de perdão (eu uso 10 dias), quando
  ele se logar de novo, não conseguirá fazer nada além de deletar
  arquivos. A mesma coisa serve para seus arquivos, ou inodes. Você
  pode determinar um limite soft e hard para estes também. Se 
  estiverem com '0' (zero), então não existe limite (má idéia).

  Você pode usar quotas de vários modos para segurar seu sistema
  contra ataques, e impedir seu disco rígido de encher. Se você
  deseja maiores detalhes, tente 'man quota'. 

  -------------------------------------------------------------------

  5. Logs

  Para ser um bom administrador de sistemas, você deve regularmente 
  examinar os logs do seu sistema, mas se você não sabe onde estão
  ou o que está sendo logado ? Esta é uma seção muito importante que
  você deve ler com bastante atenção ! A única maneira de saber se
  você está sendo atacado é verificando os logs.

  Mas onde estão os logs e como as informações são enviadas para
  eles? Bem, em um sistema Linux eles estão localizados num
  diretório chamado '/var/adm/' ou '/var/logs' mas geralmente eles
  estão linkados. Por default, existe apenas dois logs, 'syslogs' e
  'messages' mas precisamos de mais. Os logs são gerados por dois
  "daemons", 'klogd' e 'syslogd'. 'klogd' intercepta e loga as
  mensagens do kernel, enquanto 'syslogd' loga todas as mensagens do
  sistema. Estes são "daemons" do sistema que são automaticamente
  lançados por seus arquivos 'rc.*' durante o boot. Para configurar
  o que você quer logar, edite o arquivo '/etc/syslog.conf' -- este
  arquivo diz o que 'syslogd' deve logar e onde logar. Veja como
  configurei o meu:

  # /etc/syslog.conf file
  # for more information about this file, man `syslog.conf' or 
  # `sysklogd'
  #
  # Modified by Bronc Buster

  mail.none;*.=info;*.=notice                   /usr/adm/messages
  *.=debug                                      /usr/adm/debug
  *.err                                         /usr/adm/syslog
  *.=alert                                      root,bronc
  *.=emerg                                      root,bronc
  authpriv.*;auth.*                             /admin/bronc/auth.log
  authpriv.*;auth.*                             /var/log/secure
  mail.info;mail.notice                         /var/log/maillog
  daemon.info;daemon.notice                     /var/log/daemon.log
  *.*                                           /dev/tty12

  # EOF

  
  Ok, se você não sabe como este arquivo é formatado e o que incluir
  aqui, leia o manual online através de 'man syslog.conf'. Não vou
  gastar mais duas ou três páginas explicando como funciona. Vamos
  ver meu arquivo linha a linha e ver como funciona. Eu gosto de
  deixar meus logs simples e fáceis de entender. Primeiro, meu
  arquivo 'messages' estava ficando cheio de mensagens de erros sem
  importância vindas do meu programa de email. Resolvi excluir todas
  as mensagens associadas com emails; i.e., 'mail.none'. Eu quis
  todas as mensagens de níveis 'info' e 'notice' e para isso coloquei
  *.=info;*.=notice. Depois, quis todas as mensagens 'debug' indo
  para seu próprio arquivo, assim como todas as mensagens 'err'
  (erros). Quaisquer mensagens 'alert' ou 'emerg' (emergência) eu
  envio para o console ou terminal em que estiver logado, assim eu
  fico sabendo o que está acontecendo o mais rápido possível. As duas
  linhas seguintes tem a ver com conexões e possíveis logins. Quis
  ter um arquivo com nada além de quem e quando, para que pudesse
  verificar quem se logou e quando, e também coloquei uma cópia extra
  no meu diretório HOME (/admin/bronc/auth.log) para me previnir que
  se alguém editasse o arquivo auth.log de /var/log/secure, eu ainda
  teria minha cópia. É isso que as linhas com 'authpriv' e 'auth'
  estão fazendo. A primeira coloca o log no meu diretório e a segunda
  no diretório padrão (/var/log/secure). A linha seguinte trata de
  todas as mensagens de email que eu exclui do arquivo 'messages'. Eu
  as coloco num arquivo separado - isso facilita as coisas. A linha
  'daemon' loga todas as mensagens relacionadas a daemons do sistema
  e, como na linha 'mail' acima, estão indo para seu próprio arquivo.
  A última linha também é algo muito importante. Ela envia todas as
  mensagens de log para /dev/tty12. Assim, mesmo que seus logs sejam
  apagados, via console você pode teclar Ctrl+F12 e ver a última
  página de mensagens e ter idéia do que aconteceu. Estes diferentes
  logs cobrem diferentes aspectos do seu sistema, e deixa-os 'limpos'
  e fáceis de ler. Lembre-se, quanto mais claro, melhor.

  Se eu tivesse outra máquina, eu também iria direcionar todos os
  logs da minha máquina para a outra. Com syslog, você tem a opção de
  enviar todos os logs de uma máquina para outra. Você pode colocar
  um velho 386, com Linux, na sua rede com nada mais que 'inetd' e
  'syslogd' e enviar todos os seus logs para ele com uma simples
  linha no seu 'syslog.conf':

  # log ALL                       IP de outras máquinas
  #
  *.*                             @<IP de outra máquina aqui>

  Agora que os logs principais do seu sistema estão seguros, que tal
  fazer o mesmo para outros arquivos de log ? Você ainda tem 
  '/var/log/wtmp' e '/var/log/utmp' e ainda o histórico do shell de
  cada usuário. Em alguns sistemas, o 'cron' arquivaa seus logs e
  você normalmente não pode mudar seus atributos (chattr). Este
  comando altera os atributos de um arquivo no sistema de arquivos
  EXT2 que é o sistema de arquivos do Linux. Com este comando, você
  pode criar um arquivo que não possa ser editado ou deletado, exceto
  "apendado", i.e., só pode ser "aumentado" através da adição de
  linhas no seu final (tente 'man chattr' para maiores informações
  sobre este comando). Este comandinho mágico pode tornar os arquivos
  'wtmp','utmp' e outros, disponíveis em caso de problemas. Nem me
  lembro quantos usuários 'sacanas' já rastreie simplesmente olhando
  nos seus arquivos históricos. Como no exemplo a seguir:

  --- snip ---
  gcc smurf.c -o smurf
  smurf <IP edited out>
  smurf <IP edited out>
  gcc octpuss.c -o octop
  octop <IP edited out>
  ping <IP edited out>
  ping -s 2000 <IP edited out>
  rm smurf* 
  rm otc*
  rm .bash_history
  rm .bash_hirtory
  vi .bash_history
  exit
  logout

  
  Este usuário (que será removido em breve), estava usando um ataque
  DoS (Denail of Service) para atacar outro sistema, e em troca,
  os usuários do outro sistema estavam nos atacando. Usuários como
  este podem colocar você, administrador, numa fria e devem ser
  removidos imediatamente. Se eu não tivesse dado um 'chattr +a' em
  todos os históricos dos shells dos usuários, eu nunca saberia quem
  fez isso. Quando incluo um novo usuário, utilizo um script 
  'adduser' modificado para automaticamente dar um 'chatr +a' nos
  seus históricos. Para fazer isso, simplesmente abra o script
  'adduser' em um editor e inclua estas linhas no final:


  # Dá um 'chattr +a' nos históricos dos usuários
  if [ -d $HME ]; then
    chmod 711 $HME
    cd $HME
    /bin/touch .bash_history
    /bin/chown $LOGIN:users .bash_history
    /usr/bin/chattr +a .bash_history
    /bin/touch .ksh_history
    /bin/chown $LOGIN:users .ksh_history
    /usr/bin/chattr +a .ksh_history
    /bin/touch .sh_history
    /bin/chown $LOGIN:users .sh_history
    /usr/bin/chattr +a .sh_history
  fi


  É bom você estar sempre de olho nos seus arquivos de log -- eles
  são os olhos e ouvidos de seu sistema. Você precisa mantê-los em
  segurança e fáceis de ler. Certifique-se também se estão logando
  corretamente o que você precisa em seu sistema.

  -------------------------------------------------------------------

  6. Access Security (remote and physical)

  Acesso é outra parte substimada do quadro de segurança. Tanto o
  acesso remoto quanto o físico devem ser levados em conta. Não basta
  apenas um senha "forte" para manter intrusos longe de seu sistema,
  você tem que saber quais arqivos usar para controlar o acesso mesmo
  com logins e senhas válidos. Existem arquivos no seu sistema que
  podem ajudar e dar-lhe controle sobre quem conecta, e também 
  existem arquivos que não existem e que você precisa criar e que
  podem lhe ajudar. Eis os arquivos que nós vamos cobrir:

  /etc/suauth
  /etc/ftpaccess
  /etc/hosts.deny
  /etc/hosts.allow
  /etc/securetty

  Primeiramente, 'suauth', é o arquivo que controla quem tem
  permissão de usar o comando 'su' (Switch User - troca de usuário).
  Este comando, como você sabe, deixa você se tornar root, ou deixa
  você se tornar qualquer usuário que seja SUID. O arquivo 'suauth'
  tem o seguinte formato:

  TO:FROM:ACTION

  Bem simples. O campo 'TO' diz qual usuário você vai se tornar, 
  neste caso, digamos 'root'. O campo 'FROM' controla qual usuário ou
  grupo está sendo o campo 'TO'. O campo 'ACTION' diz o que fazer em
  cada caso. 'ACTION's que podem ser usada aqui são: 'OWNPASS',
  'DENY' e 'NOPASS'. Eis um trecho da página man de 'suauth' para que
  você possa ter uma idéia melhor do que estou falando.
 
       # Uma dupla privilegiada pode dar um 'su' 
       # para root com suas próprias senhas
       #
       root:chris,birddog:OWNPASS
       #
       # Ninguém mais pode dar um 'su' para root a não ser
       # aqueles do grupo wheel. This is how BSD does things.
       #
       root:ALL EXCEPT GROUP wheel:DENY
       #
       # terry and birddog são contas usadas
       # pela mesma pessoa.
       # O acesso pode ser feito entre elas
       # sem a necessidade de senha.
       #
       terry:birddog:NOPASS
       birddog:terry:NOPASS
       #

  No meu sistema, eu fiz o que está no segundo exemplo. Editei
  o arquivo '/etc/group' e adicionei um outro grupo chamado 'wheel'.
  Este grupo está entre os grupos 'users' e 'root'. Eu então
  adicionei usuários a este grupo os quais eu permito que usem o
  comando 'su'. No arquivo 'suauth', eu simplesmente digo para não
  permitir que ninguém mais a não ser quem esteja no grupo 'wheel'.
  Dúvidas ? Tente 'man suauth'.

  O próximo arquivo é o 'ftpaccess'. Este arquivo controla várias
  coisas ligadas ao serviço ftp, como quem pode fazer upload e
  download, se conexões anônimas são permitidas e se existem máquinas
  que você não deseja conectar-se em hipótese alguma. 

  O próximo arquivo é o 'ftpaccess'. Este arquivo controla várias
  coisas ligadas aos serviços de ftp, como quem pode fazer um upload
  ou download, se conexões anônimas são permitidas e se existem
  'hosts' que você não quer conectar em hipótese alguma. Por este
  arquivo controlar tanto, vou apenas mostrar como bloquear a conexão
  de 'hosts', já que estamos lidando com controle de acesso, então
  para maiores informações de outras características deste arquivo,
  'man ftpaccess'. Este arquivo tem um conjunto de regras bem 
  simples, e não é muito díficil colocar "coisas" nele. Por exemplo,
  se nós vamos adicionar alguém a nossa lista "deny" (bloqueio),
  podemos inseri-lo no início, no meio ou no fim que não faz
  diferença. Geralmente, eu coloco no final. O formato é muito 
  simples -- 'deny <ip ou domínio> <arquivo de mensagem>'. Eis como
  o meu se parece:

  # bloquear o acesso ao meu site FTP para estes domínios 
  #
  #deny   host                          arquivo de mensagem
  #
  deny    *.sekurity.org                /etc/msgs/msg.dead
  deny    *.303.org                     /etc/msgs/msg.dead
  dent    *.tacd.org                    /etc/msgs/msg.dead
  deny    *.dim.com                     /etc/msgs/msg.dead
  deny    *.comsite.net                 /etc/msgs/msg.dead
  deny    su1d.technotronic.com         /etc/msgs/msg.dead

  Creio que é muito simples entender o formato deste arquivo, exceto
  pela última parte, '/etc/msgs/msg.dead'. Isso é apenas o arquivo
  texto que será mostrado para aqueles que você bloqueou o acesso.
  Todos que se conectarem, ou forem bloqueados, serão mostrados no
  seus arquivo de log (/var/logs/secure) -- lembre-se de verificar
  estes arquivos de tempos em tempos se notar alguma atividade
  incomum.

  Os arquivos 'hosts.deny' e 'hosts.allow' trabalham juntos e são,
  por default, usados em quase todas as versão atuais de Unix.
  Estes arquivos trabalham em conjunção com "TCP Wrappers", que você
  está usando (mesmo não sabendo). "TCP Wrappers", em resumo, é um
  programa chamado 'tcpd'. Da página man -- ele monitora requisições
  de pedidos para telnet, finger, ftp, exec, rsh, rlogin, tftp, talk,
  comsat e outros servições que tem um mapeamento um-a-um com
  arquivos executáveis. O que isso significa? Resumidamente, ele
  monitora programas que estão no arquivo '/etc/inetd.conf'. Estes
  programas são lançados por 'inetd' quando uma requisição chega
  para um destes. O programa 'tcpd' está em 'inetd.conf' no lugar
  dos programas normais e sempre que uma requisição por serviços,
  o daemon inetd é "enganado" e roda o programa 'tcpd'. 'tcpd' loga
  os pedidos e faz algumas verificações adicionais. Quando tudo está
  bem, 'tcpd' executa o servidor apropriado e vai embora. Se olhar
  no seu arquivo '/etc/inetd.conf' deve encontrar uma linha parecida
  com esta:
    
    smtp  stream  tcp    nowait  root    /usr/sbin/tcpd  sendmail -bs

  Aqui você pode ver que meu 'tcpd' é disparado ao invés do sendmail
  quando uma requisição é enviada para minha porta smtp. 'tcpd' então
  loga a requisição e verifica seu 'hosts.deny' e 'host.allow'. Os
  arquivos 'hosts.*' fazem o que o nome sugere. Eles permitem, ou
  recusam conexões. Seu formato é muito fácil -- Conexão:IP.

    hellbata:~$ cat /etc/hosts.deny
    ALL:  130.85.3.8
    ALL:  207.172.56.57

  Aqui eu bloqueio TODAS as conexões vindas destes dois endereços
  IP. Se quissese, poderia bloquear a class C inteira, ou mudá-la
  para um domínio e bloqueá-lo. Você pode colocar quantos IPs você
  quiser, ou se você for super-paranóico, você pode até colocar
  'ALL:ALL' e bloquear todas as conexões. :) 

  Se você bloquear todo mundo, poderá selecionar hosts que você
  permitirá conexão. Aqui é que você usa seu arquivo 'hosts.allow'.
  Ele tem o mesmo formato que o arquivo deny mas, a menos que você
  use 'deny' 'ALL:ALL', eu nunca tive que usá-lo. Talvez você apenas
  queira permitir a algumas pessoas conectarem a sua máquina. Se for,
  é assim que você deve fazer. 

  Por último, vamos ver outro arquivo simples mas bastante 
  desprezado. O arquivo '/etc/securetty' simplesmente controla de
  ONDE o root poderá se logar. O default permite que o root se logue
  de qualquer tty, local ou remoto. Eis o default:

    console
    tty1
    tty2
    tty3
    tty4
    tty5
    tty6
    ttyS0
    ttyS1
    ttyS2
    ttyS3
    ttyp0
    ttyp1
    ttyp2
    ttyp3

  Isso é tudo. Você não tem idéia do que este arquivo faz ? Estes
  são os '/dev/tty's que estão no seu sistema, remotos e locais.
  Os 'ttyp*' e 'ttyS*' são remotos e o resto, como você pode deduzir,
  são locais ao console. Você (assim espero) deseja impedir que
  alguém se logue como root a partir de qualquer lugar, a não ser dos
  tty's locais. Para fazer isso, simplesmente edite este arquivo e
  comente todos os tty's remotos com '#':

    # impede o root de se logar de um /dev/tty remoto
    console
    tty1
    tty2
    tty3
    tty4
    tty5
    tty6
    #ttyS0
    #ttyS1
    #ttyS2
    #ttyS3
    #ttyp0
    #ttyp1
    #ttyp2
    #ttyp3

  Isso é tudo para segurança em acesso remoto. Agora tratarei de
  acesso físico. A segurança da sua máquina depende do local onde 
  ela vai estar. Se ele está no seu ISP (provedor), então ela deve
  estar segura. Se ela é alugada, o pessoal de seu ISP deve conhecer
  você e sua máquina. Se ela está numa rede local, mantenha-a
  trancada no seu escritório, ou se isso não é possível, tente mantê-
  la debaixo de sua mesa ou no chão onde ninguém possa notá-la. Minha
  máquina no meu ISP está num rack junto de outras quatro máquinas
  bem parecidas com a minha, todas sem monitor e apenas com teclados.
  Não existe nenhuma etiqueta ou marca que as identifique. Se alguém
  entrar na sala onde sua máquina está guardada, você não vai querer
  que ela seja facilmente identificada. Ele terá que conectar um
  monitor a cada máquina para descobrir qual é a sua máquina. Isso
  vai desencorajar um pouco este possível intruso.

  Um conselho muito importante - NUNCA se afaste do console com o 
  root logado, ou qualquer usuário. Dê um logout, ou 'tranque' o
  terminal !

  Se sua máquina está na sua casa, o que você pode fazer além de
  trancar suas portas ?! Se está no seu ISP, você tem que confiar
  neles. Se está no seu trabalho, mantenha-a escondida ou trancada.
  Seja esperto. Mantenha o console "trancado". Não deixe um monitor
  ligado a ela a não ser que esteja em sua casa. 


  -------------------------------------------------------------------
  
  7. Outros arquivos

  Agora vou cobrir outros arquivos que não se encaixaram em outras
  categorias. São poucos, mas importantes. São eles:

  /etc/inetd.conf
  /etc/services
  /etc/nologin
  /etc/issue.net e /etc/issue
  /etc/passwd
  /etc/shadow
  /etc/group

  Primeiro, vejamos o arquivo 'inetd.conf' file. Este é o arquivo de
  configuração do seu daemon 'inetd'. Este daemon fica "escutando"
  certas portas a espera de conexões e então decide quais serviços
  chamar, como visto no arquivo 'inetd.conf'. Como você pode 
  imaginar, este é um arquivo muito importante já que quaisquer
  serviços podem ser chamados por ele. Por default, todos os serviços
  nele são abertos. Eu acho que seus criadores viviam no "País das
  Fantasias" onde todos são bonzinhos, mas infelizmente isso não
  ocorre.

  Para editar este arquivo, como os outros, use '#'. Seu arquivo
  'inetd.conf' deve parecer como este antes de ser editado:

  -------- trecho ---------

  # os quatro primeiros serviços apenas são usados para depuração,
  # então recomendamos comentá-los já que podem ser alvos de algum
  # ataque tipo 'denail-of-service'.  Se você precisa deles, 
  # deixo-os descomentados.

  echo          stream  tcp     nowait  root    internal
  echo          dgram   udp     wait    root    internal
  discard       stream  tcp     nowait  root    internal
  discard       dgram   udp     wait    root    internal
  daytime       stream  tcp     nowait  root    internal
  daytime       dgram   udp     wait    root    internal
  chargen       stream  tcp     nowait  root    internal
  chargen       dgram   udp     wait    root    internal
  time    stream  tcp     nowait  root    internal
  time    dgram   udp     wait    root    internal

  #
  # Estes são serviçõs padrões.
  #
  ftp     stream  tcp     nowait  root    /usr/sbin/tcpd  wu.ftpd -l -i -a
  telnet  stream  tcp     nowait  root    /usr/sbin/tcpd  in.telnetd

  #
  #  
  # Use este se você deseja bisbilhotar usuários telnet
  # telnet stream  tcp     nowait  root    /usr/sbin/tcpd 
  /usr/sbin/in.telnetsnoopd

  #
  # Geralmente, isso é desnecessário. O daemon fornecido por INN
  # irá tratar as conexões NNTP.
  #
  nntp  stream  tcp     nowait  root    /usr/sbin/tcpd  in.nntpd

  #

  ----- trecho -----

  smtp  stream  tcp     nowait  root    /usr/sbin/tcpd  sendmail -bs

  #
  # O daemon comsat notifica o usuário de novos mails quando biff é setado em y:
  comsat        dgram   udp     wait    root    /usr/sbin/tcpd  in.comsat

  #
  # Shell, login, exec e talk são protocolos BSD.
  #
  shell  stream  tcp     nowait  root    /usr/sbin/tcpd  in.rshd -L
  login  stream  tcp     nowait  root    /usr/sbin/tcpd  in.rlogind
  exec  stream  tcp     nowait  root    /usr/sbin/tcpd  in.rexecd
  talk    dgram   udp     wait    root    /usr/sbin/tcpd  in.talkd
  ntalk   dgram   udp     wait    root    /usr/sbin/tcpd  in.talkd

  # Servicos de autentificação Kerberos 
  #
  # klogin    stream  tcp     nowait  root    /usr/sbin/tcpd  rlogind -k
  # eklogin   stream  tcp     nowait  root    /usr/sbin/tcpd  rlogind-k -x
  # kshell        stream  tcp     nowait  root    /usr/sbin/tcpd  rshd -k
  #
  # Serviços executados APENAS em servidor Kerberos
  #
  # krbupdate stream  tcp     nowait  root    /usr/sbin/tcpd   registerd
  # kpasswd   stream  tcp     nowait  root    /usr/sbin/tcpd  kpasswdd
  #
  # Pop e companhia
  #
  pop2  stream  tcp     nowait  root    /usr/sbin/tcpd  in.pop2d
  pop3  stream  tcp     nowait  root    /usr/sbin/tcpd  in.pop3d

  # O servidor ipop3d POP3 faz parte da distribuição Pine. Se você 
  # instalou o pacote Pine, pode ser que você queira mudar para ipop3d
  # comentando a linha pop3 acima, e descomentando a a linha pop3 abaixo.
  pop3    stream  tcp     nowait  root    /usr/sbin/tcpd  ipop3d
  imap2   stream  tcp     nowait  root    /usr/sbin/tcpd  imapd

  #
  # Serviço UUCP
  #
  uucp  stream  tcp  nowait  uucp /usr/sbin/tcpd /usr/lib/uucp/uucico-l

  #
  # O serviço Tftp é incluído apenas para boot. A maioria dos sites 
  # usa-o apenas em máquinas funcionando como "servidores de boot".
  #
  tftp  dgram   udp     wait    nobody  /usr/sbin/tcpd  in.tftpd
  # bootps dgram   udp  wait root /usr/sbin/in.bootpd     in.bootpd
  #
  # Finger, systat e netstat fornecem informações que podem ser úteis
  # para crackers em potencial. Muitos sites desabilitam alguns ou todos
  # estes serviços para aumentar a segurança. Tente "telnet localhost systat"
  # e "telnet localhost netstat" para ver estas informações.
  #
  finger  stream  tcp     nowait  nobody  /bin/sbin/tcpd  in.fingerd
  systat  stream  tcp     nowait  nobody  /usr/sbin/tcpd  /bin/ps -auwwx
  netstat stream  tcp     nowait  root    /usr/sbin/tcpd  /bin/netstat-a
  #
  # O serviço Ident é usado para autentificação de rede
  auth stream  tcp  wait root /usr/sbin/in.identd in.identd -w-t1 20 -l
  #
  #
  # Estes são para iniciar Samba, um servidor smb que pode exportar
  # filesystems para Pathworks, Lanmanager for DOS, Windows for Workgroups,
  # Windows95, Lanmanager for Windows, Lanmanager for OS/2, Windows NT, etc.
  # Se você estiver rodando smbd e nmdb a partir dos daemons em /etc/rc.d/rc.samba, 
  # então você não deve descomentar estas linhas.
  netbios-ssn     stream  tcp     nowait  root    /usr/sbin/smbd  smbd
  netbios-ns      dgram   udp     wait    root    /usr/sbin/nmbd  nmbd
  #
  # Serviços baseado em Sun-RPC.
  # <service name/version><sock_type><rpc/prot><flags><user><server><args>
  # rstatd/1-3 dgram rpc/udp wait root    /usr/sbin/tcpd  rpc.rstatd
  # rusersd/2-3 dgram rpc/udp wait root    /usr/sbin/tcpd  rpc.rusersd
  # walld/1   dgram   rpc/udp wait    root    /usr/sbin/tcpd  rpc.rwalld
  #
  # Final de inetd.conf.
  

  Isto são trechos do arquivo inetd.conf, mas o seu deve parecer
  bastante com isso. Você deve retirar alguns destes serviços --
  aqueles que você não utiliza e aqueles que você não precisa.
  Alguns deles dizem para que servem, outros não. Você deve decidir
  quais você precisa e quais não.

  Para um servidor normal, eu tiro quase todos estes serviços já que
  não são usados ou colocam a segurança em risco. Eis os serviços que
  costumo usar:

  time    stream  tcp     nowait  root    internal
  time    dgram   udp     wait    root    internal
  ftp     stream  tcp     nowait  root    /usr/sbin/tcpd  wu.ftpd -l -i -a
  telnet  stream  tcp     nowait  root    /usr/sbin/tcpd  in.telnetd
  smtp    stream  tcp     nowait  root    /usr/sbin/tcpd  sendmail -bs
  talk    dgram   udp     wait    root    /usr/sbin/tcpd  in.talkd
  ntalk   dgram   udp     wait    root    /usr/sbin/tcpd  in.talkd
  auth  stream  tcp wait root  /usr/sbin/in.identd  in.identd -w -t1 20 -l

  Os outros serviços eu não uso. Estes são os serviços essenciais que
  são necessários para um servidor que possua pelo menos alguns
  usuários. São serviços que eles precisam para poder se conectar,
  enviar mail, e outros serviços básicos (ftp, telnet, smtp, talk,
  ntalk), mais alguns outros que me auxiliam a verificar conexões
  (auth). Todos os outros você pode comentar sem medo de danificar
  o sistema.

  Também modifiquei um pouco o serviço finger. Geralmente, eu o deixo
  desligado, mas só para me divertir eu fiz isso:

  finger  stream  tcp     nowait  nobody  /bin/cat cat /etc/finger.txt

    
  Tudo que isso faz é, ao invés de retornar a informação habitual do
  comando 'finger', retorna o conteúdo do arquivo '/etc/finger.txt'.
  Você pode colocar o que quiser no arquivo 'finger.txt', por isso,
  divirta-se. :)

  O arquivo '/etc/services' lista as portas no seu sistema que tem
  algum serviço conectado. É bom você fechar todas as portas que não
  estão sendo usandas porque a maior pate dos 'exploits' rodam em
  portas que estão rodando algum serviço obscuro que ninguém tem
  conhecimento ou usa. Se você der uma olhada neste arquivo, verá
  que é bastante longo. Ele lista os números das portas juntamente 
  com o protocolo e serviço executado. Você pode 'comentar' as portas
  com o '#'. Eis a definição que o comando 'man' da para 'services':
  
  "'services' é um arquivo ASCII simples que fornece um mapeamento
  entre nomes amigáveis para serviços internet, e suas respectivas
  portas e protocolos. Cada programa que utiliza rede, deve olhar
  neste arquivo para obter o número da porta (e protocolo) para seu
  serviço."

  Ao invés de mostrar todas as portas, mostrarei quais portas eu
  abri, e você poderá ver como elas correspondem ao meu 'inetd.conf'.

  netstat         15/tcp
  ftp             21/tcp
  ssh             22/tcp        #Secure SHell
  telnet          23/tcp
  smtp            25/tcp        mail
  time            37/tcp        timserver
  time            37/udp        timserver
  whois           43/tcp        nicname
  finger          79/tcp
  www             80/tcp        http  # WorldWideWeb HTTP
  www             80/udp              # HyperText Transfer Protocol
  auth            113/tcp       tap ident authentication
  talk            517/udp
  ntalk           518/udp
 
  Como você pode ver, a maioria das portas não precisam ser abertas.
  Se você não sabe o que uma porta faz, tem usar o comando 'man'.
  Você pode até bloquear uma porta e ver o que acontece, e então,
  se necessário, desbloqueá-la depois. Uma coisa que você deve sempre
  lembrar -- se o serviço está ativo em 'inetd.conf', então deve
  estar aberto também em 'services'.

  O próximo arquivo é '/etc/nologin'. Este arquivo pode ser útil
  quando você precisa 'trancar' o sistema para encontrar um problema.

  Simplesmente criando um arquivo chamado 'nologin', ou o que é mais
  comum, 'mv'er o arquivo 'motd', nenhum usuário (com exceção do 
  root) estará permitido logar no sistema. Na verdade, o sistema
  permite que todos se loguem, mas mostrará o que está escrito no
  arquivo 'nologin', e terminará a conexão.

  Os arquivos '/etc/issue.net' e '/etc/issue' podem ser excelentes
  fontes de informação sobre seu sistema. Muitas pessoas simplesmente
  darão um telnet para seu sistema e olharão no seu prompt de login
  para ver o tipo de sistema operacional que esta sendo utilizado.
  Ao alterar o arquivo 'issue', que mostra isso:

  Welcome to Linux 2.0.35.
  hellbata login:_

  Você pode fazê-lo mostrar o que quiser. Estes arquivos são arquivos
  ASCII. Simplesmente edite-o e coloque-o onde você deseja:


  \__ ^^ __/     
     X  X 
     \  /                     
      \/
  
  Bem-vindo ao Projeto V
  hellbata login:_


  Os arquivos '/etc/passwd', '/etc/shadow' e '/etc/group' são muito
  importantes e espero que você já saiba disso. São eles que dizem
  para o sistema que é quem e quem tem poder para fazer o que. Espero
  que você, como administrador de um sistema, saiba da importância
  destes arquivos. Você deve assegurar-se que as senhas são 'fortes', 
  que não existam usuários sem senha, que não existam outros usuários
  com UID igual a 0 (exceto o root) e que o permissionamento destes
  arquivos esteja correto. Por default, as permissões estão corretas,
  então não as altere. 

  Tire um tempo para estudar cada um destes arquivos e se familiarizar
  com eles. Assim, ficará bem mais fácil quando um problema acontecer. 

  -------------------------------------------------------------------

  8. Ferramentas de terceiros

  Bom, esta seção eu inclui porque encontrei algumas ferramentas
  gratuitas pela Rede e que são extremamente úteis. Algumas destas
  ferramentas são "obrigatórias".

  SSH 
  ---

  Se você não estiver usando SSH, você precisa usar. SSH utiliza
  chaves, similar ao PGP, para autentificar logins e então encriptar
  a sessão de e para o servidor. Alguém rodando um sniffer pode
  facilmente capturar logins e senhas a partir de uma máquina na
  rede. Isso se você não estiver usando SSH. A maioria dos clientes
  SSH suportam vt100 e todas aquelas cores ASCII.

  Você pode baixar e ler mais sobre ele em:

  SSH FAQ's - http://www.uni-karlsruhe.de/~ig25/ssh-faq/
  FiSSH, Free SSH Win95/NT client - http://www.massconfusion.com/ssh/
  SSH Club FI - http://www.cs.hut.fi/ssh/


  Sentry
  ------

  Mesmo sendo uma versão beta, este programa é uma super ferramenta
  que eu uso em todos meus sistemas. Eis um trecho de seu arquivo
  README que descreve resumidamente o que ele faz:
  
  "Sentry é parte do pacote de ferramentas "Abacus Project". O
  "Projeto Ábaco" é uma iniciativa de se lançar uma ferramenta de
  detecção de intrusos que seja genérica, confiável e de baixa
  manutenção para toda a comunidade da Internet.

  Este programa 'escuta' portas que você designar e toma ações 
  diferentes dependendo das regras que você criou. Isso lhe dá dicas
  quando alguém está 'testando' seu sistema, ou tentando um ataque
  DoS. Ele pode logar a atividade, pode incluir o IP do atacante
  no arquivo '/etc/hosts.deny', o sistema local pode ser
  automaticamente configurado para rotear todo seu tráfego para um
  host 'morto' fazendo sua máquina 'desaparecer'. Ele também pode
  ser recofigurado para despejar todos os pacotes do servidor através
  de um 'filtro' de pacotes local.
  
  Bom, este é um programa que eu acho que você deve instalar, entender
  e usar.
  
  Você pode baixar e ler mais sobre ele em:
  
  Sentry Abacus Project
    http://www.psionic.com/abacus/abacus_sentry.html


  Logcheck
  --------

  Esta ferramenta faz parte do "Projeto Ábaco" e é indispensável.
  Quando usada em conjunto com SSH e Sentry, pode mantê-lo facilmente
  informado dos acontecimentos em seu sistema. Este programa, via 
  cron, verifica seus logs de tempo em temp por palavras que podem
  disparar um nível de alerta. Como Sentry, você define o que ele
  irá procurar e o que ele fará, e é facilmente configurado. Pode
  fazer coisas simples como enviar-lhe um email, ou "ecoar" uma
  mensagem em seu console ou mesmo dar um "shut down" no sistema
  dependendo das regras que você definir.

  Você pode baixar e ler mais sobre ele em:

  Logcheck Abacus Project 
    http://www.psionic.com/abacus/abacus_logcheck.html


  Secure Ping v1.0
  ----------------

  Este é uma alternativa segura para o programa 'ping' que vem junto
  com seu sistema. 'ping' geralmente é abusado por usuários tentando
  dar um 'ping da morte'. Este programa limita o tamanho e números dos 
  pacotes enviados por usuários normais ou o root. Se alguém tentar
  abusar do 'Secure Ping', ele simplesmente dirá ao usuário para dar
  um tempo e enviará uma linha para os arquivos de log que mais tarde
  o LogCheck pegará e lhe avisará.

  Você pode baixar e ler mais sobre ele em:
 
  Secure Ping 
    http://www.sy.net/security


  Smurf Logger v1.1
  -----------------

  Este programa faz o que seu nome diz. Ele loga ataques Smurf ICMP.
  Ao contrário do um programa rastreador Ping ICMP, este não irá
  encher seu HD com megas e megas de logs. Ele loga ataques repetidos
  em uma só linha. Este programa é bem legal e com ele você poderá
  ver se sua máquina está sendo atacada ou não, e então tomar medidas
  necessárias para bloquear os ataques ao nível de router.

  Você encontra o Smurf Logger v1.1 e maiores informações em 

  Smurf Logger 
    http://www.sy.net/security


  Tripwire
  --------

  Tripwire é uma ferramententa a ser usada apenas no caso do seu
  sistema ter sido invadido. Uma vez instalado corretamente, este
  programa olhará todos os arquivos, verificará seus tamanhos e suas
  datas e então, quando você quiser, os verificará novamente para ver
  se eles batem. Isso é uma boa maneira de descobrir se um arquivo
  foi alterado para conter uma 'backdoor' ou um 'cavalo-de-tróia'.
  O único inconveniente é que você precisa manter um disquete apenas
  para leitura no seu drive.

  Você pode baixá-lo em:
 
  COAST Archives 
    ftp://coast.cs.purdue.edu/pub/COAST/Tripwire


  Lsof
  ----

  Este utilitário verifica quais arquivos no sistema estão abertos.
  Tanto podem ser arquivos legítimos, como arquivos eggdrop, ou podem
  ser arquivos que alguém 'esqueceu' de fechar e que estão comendo
  100% de CPU. Este é mais um programa que você deve ter no seu
  arsenal.

  Prudue Unix Tools - ftp://vic.cc.purdue.edu/pub/tools/unix/lsof/

  Bom, eu sei que existem 'trocentos outros programas por aí, e que
  talvez façam um trabalho melhor que estes que lhes apresentei, mas
  eles são os que eu uso, funcionam e são fáceis de usar. Como surge
  um novo programa todos os dias, você deve manter-se informado das
  novidades.

  -------------------------------------------------------------------

  9. Conclusões
  
  Bom, como você pode ver pelo tamanho deste artigo, segurança em um 
  sistema operacional como o Linux não é tão simples como parece.
  Este artigo apenas cobriu o básico de coisas com as quais você
  deve conhecer e se tornar íntimo. Este artigo poderia estar num
  livro (e eu poderia ganhar uns $50, ahahah), mas como todos os
  bons artigos, ele é um trabalho em andamento.

  O que importa é que você deve saber quais são suas necessidades.
  Você deve implementar seu sistema para que atenda suas necessidades,
  e você deve estar alerta. O administrador de um sistema é que 
  importa quando o assunto é segurança. O administrador deve se manter
  alerta e monitorar seu sistema, deve acompanhar listas de discussão
  sobre segurança e manter-se informado sobre novos 'patches', kernels
  e programas. Enfim, é infinita a lista de coisas que um bom
  administrador deve saber e fazer para manter seu sistema seguro,
  mas o ponto de partida é conhecer SEU sistema. Espero que este 
  documento tenha ajudado.

  -------------------------------------------------------------------
