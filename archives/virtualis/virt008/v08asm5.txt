
   ___________________________________________________________________
  |                                                                   |
  |   Curso de Assembly                                               |
  |                       traduzido e adaptado do original de AESOFT  |
  |                                                    por Dr Herman  |
  |                                                                   |
  |___________________________________________________________________|


  -------------------------------------------
  Lição 5 - Codificação de instruções no 8086
  -------------------------------------------

     
  Codificação de instruções no 8086
  ---------------------------------

  Olá novamente, aplicados alunos :)  Nesta lição vamos tratar de
  conceitos muito técnicos sobre o formato das instruções em código de
  máquina. Veremos como se codificam as instruções no 8086.

  Codificação de instruções no 8086
  ---------------------------------

  Este trecho é muito técnico. Ainda que não seja imprescindível
  compreendê-lo para programar em assembly, é muito útil conhecer como
  o processador interpreta o que lhe pedimos. Isto nos dá um maior
  conhecimento sobre a máquina em questão. E desta forma entendemos o
  porquê de certas sintaxes de instruções. E resolveremos mais
  facilmente os erros quando aparecerem. Cada processador tem um
  conjunto de instruções para manejá-lo. Indiferente da linguagem de
  programação que estivermos utilizando, quando geramos um executável,
  este é composto unicamente por este tipo de instruções básicas
  (instruções de código de máquina). Dependendo da qualidade desta
  linguagem de programação, o código resultante precisará de mais
  instruções do processador ou menos. Todos nós sabemos que existem
  linguagens de nível alto ou médio (como C, Pascal, Basic, etc.) e que
  para fazer uma mesma tarefa, uma gerará um executável maior do que a
  outra. Isto não acontece com o assembly, que para cada instrução,
  existe um código de máquina correspondente.

  Pois bem, agora vamos ver a estrutura destas instruções básicas ou
  instruções de código de máquina.

  As instruções do 8086 se codificam em 4 campos no máximo, e têm um
  tamanho de 1 a 6 bytes. Quer dizer, dependendo da instrução é
  necessário mais ou menos bytes para sua codificação, assim como mais
  ou menos campos.

  Os quatro campos num instrução de código de máquina são:
  
  1. Código de operação: este campo sempre aparece (é óbvio). Uma vez
     que o processador decifra o significado deste campo, sabe se a
     instrução precisa de mais campos ou se trata de uma instrução de
     campo único.

  2. Modo de endereçamento (byte EA): indica ao processador o número de
     operandos que acompanham o código de operação assim como o tipo
     destes operandos (registros, memória, valor imediato).

  3. Deslocamento do dado (sobre 8 ou 16 bits): no caso de existir este
     campo, supõe um deslocamento sobre o endereço dado por um registro
     índice ou base (este registro é especificado no byte EA).

  4. Valor imediato (sobre 8 ou 16 bits): armazena um valor numérico de
     8 ou 16 bits, que vai ser utilizado para um transferência, uma
     operação aritmética, etc.
  
  
  Agora, veremos com um pouco mais de detalhe:

  Primeiro veremos um esquema de instrução em código de máquina:

  +-----------------------------------------------------------------+
  |    8 bits        2     3     3      8 ou 16 bits   8 ou 16 bits |
  | +-----------+ +-----+-----+-----+ +--------------+ +----------+ |
  | | código de | |     |     |     | |              | | valor    | |
  | | operação  | | MOD | REG | R/M | | deslocamento | | imediato | |
  | +-----------+ +-----+-----+-----+ +--------------+ +----------+ |
  |    1 byte            1 byte         1 ou 2 bytes   1 ou 2 bytes | 
  +-----------------------------------------------------------------+

  - o código de operação é codificado em 8 bits. Por meio deste campo
    se sabe se vai ser necessário os outros campos. Contém também a
    informação se vai trabalhar com palavras (word) ou bytes.

  - byte EA ou modo de endereçamento: contém 3 campos. Os campos MOD
    e R/M especifiam o modo de endereçamento, e o campo REG especifica
    o registro usado pela instrução.

    O campo MOD tem 2 bits e pode ter 4 valores diferentes: os 3 
    primeiros selecionam o deslocamento nos modos de endereçamento de
    memória. O quarto seleciona um registro.  Vejamos a função destes
    bits em cada uma das possibilidades:
    
      00 ---> não há deslocamento.
      01 ---> usa um byte para se codificar o deslocamento.
      10 ---> usa dois bytes (uma palavra - word) para codificar o
              deslocamento.
      11 ---> faz que R/M selecione um registro usando a mesma
              codificação dos registros para REG (ver mais abaixo), ao
              invés de um modo de endereçamento de memória. Quer dizer,
              faz-se uma transferência de um registro a outro.
    
    O campo REG possui 3 bits e codifica o registro utilizado.
    Portanto, é possível especificar até 8 registros diferentes por
    meio deste campo. Dependendo de se tratar de um acesso a palavras
    ou a octetos, será selecionado um registro num grupo de 8, ou de um
    segundo grupo de 8 registro. Quando se acessa registros de 16 bits,
    o campo REG codifica os registro de palavra da seguinte maneira:

          AX (000), CX (001), DX (010), BX (011)
          SP (100), BP (101), SI (110), DI (111)

    Quando se acessa registros de 8 bits, a codificação dos registros
    com tamanho de um byte se faz como segue:

          AL (000), CL (001), DL (010), BL (011)
          AH (100), CH (101), DH (110), BH (111)

    O campo R/M indica o segundo registro (se houver) ou o tipo de
    endereçamento de memória.

    No caso de haver um segundo registro, este se codifica da mesma
    forma que o campo REG.

    No caso de se tratar de um modo de endereçamento de memória, estes
    3 bits selecionam um dos modos de endereçamento possíveis de acordo
    com a seguinte tabela:

          000  deslocamento final = [BX] + [SI] + deslocamento
          001  deslocamento final = [BX] + [DI] + deslocamento
          010  deslocamento final = [BP] + [SI] + deslocamento
          011  deslocamento final = [BP] + [DI] + deslocamento
          100  deslocamento final = [SI] + deslocamento
          101  deslocamento final = [DI] + deslocamento
          110  deslocamento final = [BP] + deslocamento
          111  deslocamento final = [BX] + deslocamento


  - O deslocamento (caso exista), supõe um incremento no endereço dado
    por um registro índice ou base, dando lugar a um deslocamento
    final, dentro do segmento dado. Quer dizer, como se vê na tabela
    acima, podemos acessar a memória através de um registro base (BX)
    ou de um registro índice (SI, DI), etc., ou bem fazê-lo através de
    um destes registros, mas auxiliado de um deslocamento que se some
    ao endereço que foi estabelecido nestes registro. Veremos mais
    adiante a utilidade de utilizar deslocamento sobre um registro
    base ou índice.

    Por exemplo: temos o registro DI apontando para o (com valor igual
    a) endereço 3000h (endereços sempre em hexadecimal). Neste endereço
    temos o começo de uma cadeia de caracteres (string) que queremos
    converter em maiúsculas. E uma vez que tivermos convertido, queremos
    copiar a memória para a tela.

    Pois bem, podemos ir incrementando DI para tratar cada um destes
    caracteres, ou podemos utilizar DI junto de um deslocamento para
    acessar cada um destes caracteres. Quer dizer, para acessar o
    primeiro elemento seria DI+0, para o segundo, seria DI+1, etc.
    Desta forma, ao terminar a tarefa, DI continuaria apontando para o
    início da cadeia (string), e poderíamos copiá-la do início até onde
    se queira.
 
    Se utilizarmos o deslocamento, deveríamos ter uma variável
    apontando para o início da mesma cadeia, para tê-la disponível.
    Bom... isto é apenas um exemplo. As possibilidades de uso de
    deslocamentos acompanhados de registros base ou índice são muito
    mais interessantes da que acabamos de ver neste exemplo.


  - O valor imediato é utilizado quando fazemos atribuições de dados a
    registros ou memória. Por exemplo, queremos introduzir no registro
    AX a quantidade 37867 (93EBh). Pois estes 37867 seria o tal valor
    imediato.

    Em assembly, teríamos a seguinte instrução:
      MOV AX, 37867
    
    Simples, não ? Mover (MOV) a quantidade 37867 para o registro AX.
    Logo será visto o resto das instruções do assembly, e por enquanto,
    e por ser necessário, aprenderemos o uso da instrução MOV.
    
    A instrução MOV, como podemos ver, é utilizada para atribuições ou
    transferência de dados: de registro para registro, de registro para
    memória, e de memória para registro. Mas nunca de memória para
    memória, já que a arquitetura do processador e barramento (bus) não
    permitem isso.

    A sintaxe básica da instrução é seguinte:
   
      MOV destino, fonte

    O destino fica sempre a esquerda da vírgula enquanto a fonte fica
    sempre a direita.

    Exemplos:
  
    * MOV ax, 5 ---> move o valor imediato (o dado) 5 para o registro
      AX. Examinemos melhor esta instrução. Alguém poderia pensar que
      como o valor 5 cabe apenas em um registro de 8 bits (AL neste
      caso), o registro AH ficaria como estava antes da instrução. Mas
      não é assim. Se dissemos ao processador para introduzir 5 em AX,
      assim será. Coloca zero no registro AH, para que AX tenha valor
      5.
     
      Vejamos como se codifica esta instrução:
      MOV AX, 5 --->  B8 05 00 (código de máquina, sempre em
                                hexadecimal)

      Em primeiro lugar, temos o primeiro byte que contêm o código da
      operação (B8). Devido a este código de operação (B8) ter 
      implícito a utilização do registro AX como destino, não é 
      necessário o byte EA ou byte de endereçamento, que seria
      necessário em transferências para outros registros. Como vimos na
      primeira lição ao falar de registros, o registro AX (AH, AL) é
      utilizado normalmente como acumulador, de tal maneira que existem
      operações especiais para trabalhar com ele, como a instrução B8 e
      outras muitas de movimento de dados, nas quais não se especifica
      o registro no byte EA, já que está implícito no código da
      operação. Desta maneira se ganha velocidade na execução do
      programa utilizando os registros para que foram criados. AX
      acumulador, CX contador, etc.

      Depois do código de operação temos dois bytes (uma palavra).
      Estes dois bytes formam o campo VALOR IMEDIATO, que como vimos
      aqui é de 16 bits. Como já devem ter dado conta, dos quatro
      campos que pode ter uma instrução em código de máquina, esta tem
      apenas dois:

        O primeiro (código da operação) e o último (valor imediato).

      E voltando ao campo valor imediato e seu tamanho nesta instrução
      (2 bytes): a ordem destes bytes é muito importante. Vejamos...
      Temos o valor 5 para introduzir num palavra. O normal seria que o
      código para armazenamento deste 5 fosse [00 05], mas no 8086 isto
      não é assim. Como sempre, para acelerar o programa quando são
      feitas transferências de dados, se chegou a conclusão que se
      armazenarmos os bytes que compõem uma palavra em ordem inversa da
      normal, será muito mais rápido recuperá-los. E é assim que se faz
      na prática. Cada vez que armazenarmos uma palavra na memória, o
      byte de maior peso fica a direita do byte de menor peso. Conclui-
      se que ao introduzir 5 numa palavra de memória, teríamos 05 00.

      Outro exemplo: uma vez que armazenarmos o número 8BC3h na
      memória, e dermos um olhada para ver o como ficou, o veremos como 
      C3 8B.

      * MOV al, 5 ---> introduz o valor 5 no registro AL.
        Neste caso, AH fica como estava antes da instrução já que a
        mesma não intervem de nenhuma maneira neste registro.
      
        A instrução codifica-se como:
        MOV AL, 5 --->  B0 05
         
        Este exemplo é praticamente igual o anterior, exceto pelo
        código de operação ser B0 ao invés de B8, e além disso não
        temos mais 2 bytes no campo valor imediato, e sim um byte
        apenas já que vamos introduzir o dado num registro do tamanho
        de um byte.
      

      Exemplo de transferências entre registros:
      
      * MOV CX, SI ---> introduz o valor do registro SI no registro CX.
     
        A instrução é codificada como:
        MOV CX, SI --->  8B CE

        Nesta instrução temos um código de operando e o byte EA.
        Segundo o este byte EA, o processador sabe quais registros são
        usados na transferência. Decompondo o byte EA em dígitos
        binários, temos:

        CE ---> 11001110

        O campo MOD tem valor 11, o que faz R/M selecionar um registro
        como fonte.

        O campo REG tem valor 001, indicando que o registro destino é
        X.

        O campo R/M tem valor 110, indicando que o registro fonte é SI.
      

    Já vimos como introduzir um dado num registro. Mas como fazemos 
    para colocar um dado em memória ?

    Bom, para isto utilizamos as variáveis (que também existem em 
    assembly), ou se quisermos, uma posição de memória concreta.

    Existe uma terceira maneira que é utilizar os registros índice ou
    base.
   
    -> No primeiro caso, é muito simples. Se quisermos introduzir o 
       valor 70h na variável X, basta escrever MOV X, 70h. Antes disso,
       a variável X teve que ter seu tamanho definido - byte, palavra
       ou palavra dupla. Uma vez compilado o programa, o que antes era
       a variável X, agora vai ser a posição de memória ocupada pela
       variável. Quer dizer, que ao usarmos variáveis facilitamos
       bastante o trabalho de programação. Poderíamos fazer um programa
       sem usar variáveis, indicando as posições de memória diretamente,
       mas isso já é mais parecido com o código de máquina do que com
       assembly.

   -> No segundo caso, onde indicamos a posição de memória concreta,
      temos que levar em conta se esta posição de memória é utilizada
      como um byte ou uma palavra. Devemos explicitar isso pois o
      processador não sabe se queremos guardar, por exemplo, 5 num
      byte ou em uma palavra.

      +---------------------------------------------------------------+
      |                                                               |
      |  Para que não haja dúvidas, a linguagem assembly conta com    |
      |  certas convenções para tratar estas transferências de dados  |
      |  para a memória. Quando queremos introduzir um byte em uma    |
      |  dada posição de memória, fazemos no seguite formato:         |
      |                                                               |
      |                 MOV BYTE PTR DS:[7654H], 5                    |
      |                                                               |
      |  BYTE PTR indica que vamos acessar uma posição de memória do  |
      |  tipo BYTE.                                                   |
      |                                                               |
      |  Quando queremos introduzir uma palavra a partir de uma       |
      |  posição de memória, o formato fica assim:                    |  
      |                                                               |
      |                 MOV WORD PTR DS:[7654H], 5                    |
      |                                                               |
      |  WORD PTR indica que vamos acessar uma posição de memória do  |
      |  tipo WORD.                                                   |
      |                                                               |
      +---------------------------------------------------------------+

      Tendo em conta também que quando se quer acessar uma posição de
      memória concreta sem passar por uma variável, deve-se indicar
      entre colchetes, como nos exemplos acima.
       
      Mas isso não é tudo, deve-se indicar um segmento, para que o
      processador saiba a que zona de 64KB da memória pertence a posição
      dada entre os colchetes.

      Neste caso, indicamos o segmento DS (segmento de dados), que é o
      usual. Também poderiámos ter selecionado o segmento ES (segmento
      de dados extra) para podermos transferir algo para fora da nossa
      área de dados.

      Observe a maneira de indicar um endereço de maneira segmentada.
      Primeiro indica-se o segmento, logo depois, dois pontos (:),e
      depois, o deslocamento dentro deste segmento entre colchetes.

        Segmento:[deslocamento]
        DS:[2626h], ES:[FFFFh], etc.

    
   -> O terceiro caso nos valemos de um registro índice ou base, o qual
      contém o endereço da posição de memória que nos interessa, para
      acessar tal endereço de memória.
     
      Um exemplo: MOV BYTE PTR [DI],5
      
      Observe que aqui não é necessário indicar o segmento ao qual nos
      referimos. Usa-se implicitamente o segmento DS. De fato, quando
      acessamos a memória através de registros índice ou base, não é
      necessário indicar o segmento. Entretanto, se o fizermos de forma
      direta, indicando uma posição de memória como [2636h], devemos
      indicar o segmento que iremos tratar.

      Vejamos agora como se codifica uma instrução na qual se faz um
      acesso a memória.

      * MOV WORD PTR DS:[7654H],5 ---> esta instrução introduz o valor
        5 a partir da posição de memória 7654h. Digo a partir, já que é
        necessário duas posições de memória para armazená-lo, uma vez
        que se trata de um valor imediato de 16 bits (isso se determina
        ao colocar WORD PTR). Com isso, a palavra de valor 5, fica
        armazenada em duas posições de memória, a indicada [7654h] e
        a seguinte, [7655h]. Se levarmos em conta o que foi comentado
        sobre como o 8086 armazena dados do tipo palavra (WORD) na 
        memória, saberemos de antemão que a posição [7654h] conterá o
        valor 5 e a posição [7655h] conterá o valor 0.
      
      Vejamos como se codifica esta instrução:

        MOV WORD PTR [7654H],5 ---> C7 06 54 76 05 00

        Vimos que esta instrução ocupou todos os bytes disponíveis para
        codificação (6 bytes). De tal forma que os 4 campos de
        instrução estão presentes. Vamos estudá-la detalhadamente:

        O primeiro código que temos é o código de operação: C7.
        Este código indica uma operação MOV sobre um endereço concreto
        ou deslocamento, e com um valor numérico do tipo palavra.

        Os bytes 3 e 4 formam o deslocamento (levar em conta a ordem
        inversa), e os bytes 5 e 6 formam o valor imediato a ser
        introduzido (levar em conta a ordem inversa).

        E sobre o byte 2, que é o byte EA ou byte de endereçamento.
        E por que foi deixado para o final ?

        Porque eu levo 2 ou 3 horas tentando descobrir o porquê é 6.
        Não chego a lugar nenhum, já que este 6 indica que não há
        deslocamento, quando na verdade há.
   
     Veremos se na próxima lição consigo decifrar o mistério.
 
     Até lá !!!
