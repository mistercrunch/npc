---
title: "FULCRUM"
ezine: "fulcrum"
---

# FULCRUM

**Ezine:** fulcrum

<div className="ascii-content">

```
FULCRUM MAGAZINE #3                        31 de Marzo de 1996

                           Editorial

     Existe cierta tendencia a creer que con un super-procesa-
dor se pone al límite la velocidad de la PC y con esto solucio-
nar todos nuestros problemas, pero se pierde el concepto de que
la PC no es tan solo un montón de patitas (micro) soldadas a
una plaqueta. Es todo un sistema que está compuesto por diver-
sas variantes y calcular la velocidad real es un tarea muy com-
pleja , de nada sirven los Mhz del micro llegada esta hora, y
como dijo mi buen filósofo chino, 'un sistema será tan rápido
como el más lento de sus componentes'... si esto parece difícil
de calcular, en realidad lo será aun más ya que no todos los   
 'componentes' del sistema se usan por igual. Llendo al grano
de la cuestión, hay varios componentes que influyen en la velo-
cidad final y uno de estos es el refresco de memorias; también
como complemento existen estados de espera que inserta el micro
para compensar la desigualdad de velocidad en el hard, estos
temas son los que nos ocuparán en este número y de esta forma
mostrar que tener un micro muy rápido no sirve de mucho si es
acompañado de un hardware lento. Entonces, el sistema de tiem-
pos de la PC full-full en este número.
     Pero cambiando de tema, visto que la cosa va funcionando,
ya contamos con un par de bbs más donde pueden sacar la revis-
ta, estos son
     
     Raw Power............238-2144
     Dionysios II.........253-2096

y para los fidonenses, pueden sacarla de 4:901/325 (o sea el
nodo correspondiente a Raw Power)

     También a partir de este número se incluye una sección de
feedback que son preguntas que me van planteando y que son in-
teresantes ponerlas en esta área para que sean de público cono-
cimiento. Esta saldrá cada tanto, cuando tenga preguntas de
ustedes y por que no cuando tengo tiempo para ir contestándo-
las!!!    
     Espero que les guste y la verdad que me pongo mucho para
sacar día a día algo mejor, así que cualquier sugerencia y/o
pregunta me la hacen llegar para que juntos podamos sacar una
publicación competente que, en definitiva, nos beneficia a to-
dos.
Suerte y nos vemos en cualquier momento!!

                                                         by   
                                                       [Biggs]





                     Fundamentos teóricos
           "System timing and wait state generation"

     En las RAM dinámicas, la información es almacenada como
carga, es decir, que el 1 se almacena como una pequeña carga en
la juntura gate-source del transistor del tipo MOS. Dicho esto,
cabe aclarar que estas memorias están compuestas por una matriz
de transistores cada uno de los cuales puede ser direccionado
por una fila y una columna de dicha matriz. Pero como dicho
elemento posee pérdidas, la carga almacenada debe ser restaura-
da periódicamente para que dicho valor de tensión nunca supere
el nivel umbral y siempre sea reconocido como 1. Esto es así ya
que el capacitor ficticio que se forma en realidad en la juntu-
ra anteriormente mencionada, posee como cualquier otro pérdi-
das, en otras palabras no posee un Q infinito. Se llama Q al
factor de mérito de los capacitores y se lo define como :

     Q=PA/PD

Siendo PA la potencia almacenada por el capacitor y PD la po-
tencia disipada. 

     Los refrescos de memoria se realizan mediante el uso del
canal DMA-0 y este en realidad es un DMA encubierto ya que no
lee los datos sino que el direccionarlos los refresca. Dicho
ciclo ocurre cada 72 clocks del procesador y dura 5 clk. Por lo
tanto ya de movida se piede el 7% del tiempo refrescando la
memoria.

Incompatibilidades del Hardware


     El tiempo que le lleva al microprocesador para llegar a
una celda conteniendo información se llama tiempo de acceso.
Las memorias se clasifican según este tiempo que se mide en
nanosegundos clasificandoselas según este dato ( 70 Ns , 80 Ns
, etc ).
     La relación velocidad del procesador - velocidad de memo-
ria es muy importante. Si el procesador es muy rápido y las
memorias son lentas, se debe enlentecer el ciclo de acceso a
cada celda y esperar uno o más ciclos del procesador. Esto tor-
na notablemente más lento al sistema.
     Lo ideal es que el equipo no tenga tiempos de espera
(wait-state), es decir que tenga 0 WS para que el procesador
funcione a toda su potencia.
Si, por ejemplo, su equipo es un 486 DX 50 Mhz probablemente
tenga una performance similar al de un 486 DX 33 Mhz debido a
los wait state.
     Aunque no todos los equipos los usan, hay ciertos métodos
para que no disminuyan su performance:

Memoria entrelazada

          La memoria se accede en bancos donde se hallan alma-
          cenadas todas las celdas, pero si a un equipo se le
          ponen 2 bancos de memoria, ciertos diseñadores utili-
          zan el siguiente truco: Dividir la memoria en dos,
          donde las direcciones pares estén en un banco y las
          impares en el otro.
          Mientras se accede a la posición par, al mismo tiempo
          se    refrescan las direcciones impares. Como gene-
          ralmente el programa continúa en la próxima dirección
          el tiempo de acceso se minimiza. Como ejemplo de lo
          anteriormente dicho, citamos el de una 386 SX 25 Mhz
          que con un solo banco de memoria tiene una performan-
          ce medida por el SYSINFO de 13.5 y con dos bancos de
          memoria esta sube a 19.5.
          Generalmente la norma es vender la memoria en los
          módulos más grandes posibles para que se pueda expan-
          dir al máximo en un futuro.

Memoria caché externa

          Si por cada acceso a la memoria se traen las próximas
          direcciones y se guardan las últimas en una RAM está-
          tica, existen grandes posibilidades de que el progra-
          ma ejecute o repita las direcciones que se encuentran
          en la RAM estática ( recordamos que la RAM estática
          es más veloz que la dinámica ) sin tener que ir a
          traerlas de la RAM dinámica. Cuanto más datos se eje-
          cuten en la memoria caché (estática) sin tener que ir
          a la dinámica, más aumentará la velocidad del siste-
          ma.

Caché en el procesador

          Más rápida que una cahé externa es la caché dentro
          del procesador. Estos a partir del 486 en adelante
          poseen una caché interna (el INTEL 486 posee una ca-
          ché de 8KB). Los compiladores modernos realizan opti-
          mizaciones para aprovechar al máximo estas áreas con
          lo cual logran una mayor velocidad final.

     La combinación de caché interna, con caché externa y con
memoria entrelazada más el uso de programas que usen estos re-
cursos, optimizan al máximo la performance de su equipo.


SHADOW RAM

          También habíamos hablado que las memorias RAM estáti-
          cas eran mucho más rápidas que las RAM dinámicas y
          que estas a su vez más veloces que las ROM. Para que
          el sistema funcione más rápido, y si la BIOS lo per-
          mite, se puede colocar RAM en vez de ROM y copiarle
          su contenido. De esta forma las rutinas de la BIOS
          corren más rápido que si estuviesen en la ROM aumen-
          tando la performance del sistema. Esta RAM-ROM que el
          BIOS copia y protege es llamada SHADOW RAM.

     Este factor debilita mucho la performance del sistema
(wait-state), y por que ocurren??; Si tenes que hacer un inter-
cambio de información entre dos "objetos" y si estos funcionan
a una distinta velocidad, el más rápido debe enlenteserce para
ponerse a la par del más lento y de esta forma realizar la ope-
ración. Dicho en un ejemplo, si yo hablara tan rápido que nadie
me pudiera entender tengo dos opciones, o sigo hablando y nadie
me entiende un carajo o me freno y hablo a una velocidad que
los demás puedan entender. Dicho en otro ejemplo: si tengo un
micro de 66Mhz que obiamente posee un pulso de clock cada 
15.15 ns y este tiene que leer una posición de memoria, cuyo
tiempo de acceso es de 70 ns, quiere decir que  el micro se
tiene que bajar a dicha velocidad para hacer el intercambio de
información (baja agregando "relleno" que son precisamente los
Wait-State).
     Lo cierto es que tener un micro tan rápido, tan desparejo
en velocidad con el resto del hardware hace que este no pueda
desarrollar todo su potencial. Ustedes me dirán cuanto depende
el micro de estos factores externos... mucho. Si tiene que eje-
cutar un programa debe leer el HD, (peor que con las memorias
ya que el tiempo de acceso está en el orden de los mili-seg.) y
luego de cargado en memoria irá buscando instrucción por ins-
trucción y cargandolas en su IR (Registro de instrucciones)
para poder ejecutarlas. Hay soluciones que implementan los fa-
bricantes de micro's que tratan de ir zafando estos problemas
pero mas que soluciones son parches que van haciendo (en un par
de numeros me voy a dedicar un capitulo entero a explicar el
funcionamiento interno del micro y veremos que se está imple-
mentando).

     Dicho esto veamos cual es la lógica para la generación de
los famosos WAIT-STATE.

     Si recordamos, los ciclos del bus están normalmente com-
puestos por cuatro ciclos del reloj (T1..T4) pero en ciertas
oportunidades se incluía un quinto ciclo llamado TW. Este es el
primer ejemplo que podemos citar de Wait State y es insertado
automaticamente por el micro. La  señal READY del bus (I/O CHA-
NNEL READY) es utilizada para insertar ciclos adicionales en
caso de que la placa interfaz necesite de este tiempo para rea-
lizar su operación de I/O.

     Pero la generación de WS en los ciclos de memoria no es
generada por las placas de interfaz sino por un adaptador espe-
cialmente utilizado para esta función; El sistema está mues-
treando el estado de la señal READY con respecto al clock, si
no se desea insertar un tiempo de retardo, dicha señal READY
debe estar inactiva por lo menos 75 ns antes que se genere el
flanco ascendente del pulso T2, si en cambio se desea generar-
lo, esta señal se debe activar 60 ns antes que dicho pulso de
clock. READY debe ser desactivada antes del T3 para que un WS
sea generado luego de este. Si se desea generar otro WS, READY
debe ser activada antes del flanco del próximo clock para que
un segundo WS sea generado. 

     Retomando el tema de la inserción de WS extras en los ci-
clos de I/O, estos son generados de manera similar a los de
memorias, pero ahora la señal READY será controlada  por la
interfaz y debe activarse 75ns antes del pulso T3 para que se
genere un WS y caso contrario, debe permanecer inactiva 60ns
para que no se lo genere. 

     Pero en los ciclos de espera (WS) también pueden ser in-
sertados en los ciclos DMA. Ahora la lógica es diferente ya que
en los accesos DMA existe una operación de lectura y otra de
escritura, si es una lectura de memoria y escritura de puertos
o si es lectura de puerto-escritura de memoria, su modo operan-
do es diferente. Esto es así porque el controlador DMA muestrea
la señal READY buscando un flanco respecto del clock; En conse-
cuencia, la PC inserta automaticamente WS en los canales DMA1,
DMA2, DMA3. El canal DMA0 nunca sufre la inserción de WS. El
controlador DMA utiliza el clock del procesador y el clock de
los ciclos de bus, llamándolos "T" y "S" clocks. Cuando la se-
ñal AEN se activa, esta indica la presencia de un ciclo DMA. En
ese momento, se inserta automaticamente un WS. La señal READY
debe permanecer activada 135ns antes del flanco del pulso SW1
para que se inserte un adicional WS o permanecer inactiva 115ns
antes del próximo ciclo de S clock. Existen tres condiciones
diferentes para que un ciclo de espera sea insertado:

     1- Cuando un canal solicita un DMA

     2- Cuando el DMA es apuntado a un bloque de memoria espe-
     cífico.

     3- En el caso de que el DMA tiene que transferir desde un
     canal especifico al mismo tiempo que apunta a un bloque de
     memoria.
                                                               
                                                               
     Esto es todo respecto de los WS en DMA, sin embargo pienso 
     que la idea quedará mas clara cuando tratemos la generación 
     de DMA en una placa de interfaz en un futuro.

     Con esto damos por terminado el tema de Wait State y su
influencia en la degradación del sistema, pero para cerrar el
tema de este numero, vamos a analizar el sistema de tiempos de
la PC, el cual es accesible a nosotros mediante el uso del 8253
que ya habíamos mencionado anteriormente. Este es un IC muy
utilizado en la PC y de especial ayuda a la programación, cum-
pliendo además con funciones básicas que mantienen la correcta
temporización del sistema; Entonces antes que nada veremos cual
es el funcionamiento del TIMER 8253/8254 (son iguales, solo que
por una cuestión comercial se los conoce de esta forma, pero
genéricamente lo llamaremos 8254).

     Antes que nada vamos a ver en que consiste el 8254, bueno,
es un TIMER que posee 3 contadores de 16 bits, los cuales son
alimentados por 3 señales de clk y poseen sus correspondientes
salidas y además una pata de GATE que se utiliza para contro-
larlos. Está también un registro de control en el cual se pro-
grama el modo de trabajo de cada uno de los contadores (hay
seis). Así que primero veamos estas características...

     Por las patitas de clk soportan 2Mhz como frec. máxima.
Hay una pata de habilitación (CS) que debe ser controlada por
el decodificador de direcciones. Los 4 registros internos se
discriminan mediante las señales A0-A1 de la siguiente forma:

      A1 A0 Registro
      ──┼──┼─────────────── 
      0 │0 │Acceso al cont. 0
      0 │1 │Idem cont. 1
      1 │0 │Idem cont. 2                                       
      1 │1 │Reg. de control

     El proceso de programación implica cargar la palabra de
control adecuada, y luego cargar el valor del contador, primero
la parte baja y luego la alta.
     El reg. de control posee las siguientes posibilidades:

     Bits 7-6: eligen el cont. que se desea programar.
     Bits 5-4: selecciona la forma de carga 

                          RL1 RL0 Carga
                          ───┼───┼────────                     
                           0 │ 0 │Se cargan los 2 bytes        
                           0 │ 1 │Se carga el B. menos sig.
                           1 │ 0 │Se carga el B. más sig.
                           1 │ 1 │Reservado

     Bits 3,2 y 1: Determinan el modo de trabajo

                          M2 M1 M0  Modo   
                          ──┼──┼──┼─────────
                          0 │0 │0 │   0   
                          0 │0 │1 │   1
                          - │1 │0 │   2 
                          - │1 │1 │   3
                          1 │0 │0 │   4 
                          1 │0 │1 │   5

     Bit 0: especifica si la cuenta se realizará en código bi-
     nario o en BCD ( si es 0=bin, 1=BCD)


                                0 
┌───┬───┬───┬───┬───┬───┬───┬───┐ 
│SC1│SC0│RL1│RL0│M2 │M1 │M0 │BCD│
└─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┘
  └─┬─┘   └─┬─┘   └───┼───┘   └─Cont bin/bcd
    │       │         └─────────Modo de trabajo
    │       └───────────────────Carga del cont.
    └───────────────────────────Selección de cont.


Resta por lo tanto hablar de los 6 modos de trabajo que posee
el 8254:

     Modo 0:   La pata OUT pasa a nivel alto cuando la cuenta
               llega a cero; cuando GATE está en bajo se detie-
               ne la cuenta.

     Modo 1:   En este modo se espera el flanco ascendente de
               la señal GATE y una vez pasado esto, con el pró-
               ximo pulso comienza a decrementar el cont. pa-
               sando la salida OUT de nivel alto a bajo. Una
               vez finalizada la cuenta OUT permanece en alto
               nuevamente. Con GATE se reinicializa el conta-
               dor.

     Modo 2:   En este modo la salida OUT está en alto y cuando
               llega el pulso de fin de cuenta, pasa a bajo,
               pero una vez transcurrido dicho pulso retorna a
               nivel alto, es decir que se obtiene pulsos por
               out con un período determinado. GATE Inhibe di-
               cha salida.

     Modo 3:   Con este se genera una onda cuadrada, es decir,
               que OUT estará la mitad del tiempo en alto y la
               mitad en bajo. Si el valor de cuenta es impar,
               el tiempo de alto posee un período más que el de
               bajo.

     Modo 4:   La salido OUT pasa a nivel alto y una vez alcan-
               zado el valor de cuenta pasa a un nivel bajo
               durante el impulso de clock. GATE detiene el
               conteo.

     Modo 5:   Similar al modo 4 solo que no se inicia el con-
               teo hasta que se recibe un flanco ascendente por
               GATE y cada vez que se lo reciba se reiniciará
               dicha cuenta.

NOTA: Salvo aclaraciones se considera que una vez llegada a
cero la cuenta, se reinicializa automaticamente.
                         
     En la PC el 8254 está alimentado en su entrada de clock
con una señal de frecuencia de 1193180Hz y este utiliza su con-
tador 0 para generar la int 8h cada vez que llega al período
programado, ejecutándose una rutina de control de timing del
sistema. El segundo contador (Cont. 1) se encarga de realizar
el refresco de memoria por el canal DMA0. El tercer y último
contador está conectado al sistema de parlantes y genera un
impulso de sonido cada vez que completa un período. Podemos
calcular la frec. de trabajo como período=1193180/frec.
     Por último, podemos citar que el registro de control está
en 43h, mientras que los cont está, en 40h,41h y 42h.
     Pero el último contador, esta conectado al speaker a tra-
ves de un port del 8255, presente en el sistema de PC. Veamos
pues el sistema de control del parlante en la PC.
     Una vez programado el contador, que dará la frecuencia de
la señal a sacar por speaker, se debe activarlo para que la
señal sea generada. Este canal, es controlado por dos bits del
puerto 61h que controla la señal del amplificador del speaker
y, como ya dijimos proviene del 8255. Estos dos bits de los que
hacemos referencia son los dos menos significativos de la word 
y el bms controla la tx de pulsos por el 8253 y el otro conmuta
la señal de salida al speaker. Un mini ejemplo sería este:

---------------------------------------------------------------

     count = 1193280 / 3000        ;calculo "t" para 3000hz
     locount = count mod 256       ;calc. parte baja del valor
     hicount = count / 256         ;calc. parte alta del valor
     out &h43, &hb6                ;setea el 8253
     out $h42, locount             ;carga parte baja
     out &h43, hicount             ;carga parte alta
     oldport = inp (&h61)          ;lee el estado del port
     newport = (oldport or &h03)   ;calcula el valor del port
     out &61, newport              ;y lo manda (activa speaker)
     ...

     ...
     ...
     oldport = inp (&h61)          ;para apagarlo hace lo mismo
     newport = (oldport and &h03)  ;nada más que pone a 0 los 2
     out &61, newport              ;bms del word (address 61h)

---------------------------------------------------------------

es muy fácil no, ok ok pero cómo controlar el volumen en el
parlante??? es decir el control de la amplitud de la señal de
salida??... ok ok,  a continuación ...

Por desgracia el speaker no posee un control de volumen, pero
como el parlante posee una respuesta alineal, responde de dis-
tinta manera a una u otra frecuencia. Era de esperar que no se
pueda controlar el volumen ya que lo que se usa como señal (di-
go lo que se aplica al parlante) es la salida del 8253, no ??
los pulsos de out se originan cuando se alcanza la cuenta y son
siempre de una misma amplitud, no tengo la posibilidad de va-
riarla ya que se maneja con niveles lógicos. Ya aclarado esto,
y teniendo en cuenta que la respuesta no es lineal, les presen-
to este ejemplo que les va a permitir calcular el mejor sonido
que puede reproducir su speaker (levanta la curva de respuesta
en frec. )...

---------------------------------------------------------------

                    play "mf"
                    frec=37
                    while frec < 32000
                    print using "##.###";frec
                    sound frec,5
                    frec=frec*1.1
                    wend

---------------------------------------------------------------


     De esta forma, podemos dar por mencionado este, el sistema
de tiempos de la PC, quedando cerrado el tema de esta edición;
Espero haber sido claro y si no, contáctense a los números que
dejé antes, nos vemos en el próximo número de FULCRUM MAGAZI-
NE!!!  

                                                         by   
                                                       [Biggs]






```

</div>
