---
title: "7a69#11-art7"
ezine: "7a69"
---

# 7a69#11-art7

**Ezine:** 7a69

<div className="ascii-content">

```
-=( 7A69 E-zine 11 )=--=( art5 )=--=( Programacion en Perl )=--=( OvErDrIvE )=-
					
                ======================================
                        Programacion en Perl I
                ======================================

He decidido escribir este primer apartado como introducci≤n a PERL y conceptos
de programaci≤n en PERL, pero tengo pensado escribir 3 o 4 apartados mas en 
numeros posteriores o quizas mas, ya veremos. De paso mando un saludo a 
markit0s, que es el que me introdujo y me ha ayudado a aprender este lenguaje
de programacion y muchas cosas mas. De momento este es el primer apartado,que
es el basico, en el proximo texto que sera de un nivel medio, mas tarde el 
tercer texto que sera avanzado y posiblemente un cuarto texto de Perl orientado
a objetos. Estos articulos los he escrito siguiendo algunos libros de Perl que
he leido. Bien, sin mas preßmbulos comencemos.

        ========
        =Indice=
        ========
          + Introduccion a Perl
          + Conceptos basicos
          + El primer programa
          + Almacenamiento de datos
          + Operadores
          + Secuencias de escape
          + Matrices
          + Procesamientos de datos en Perl
          + Otros operadores
          + Operadores para trabajar con valores numΘricos
          + Operaciones con cadenas de texto
          + Operadores para comparaciones numericas
          + Operadores para comparar cadenas
          + Sentencias y bucles
          + Ruptura de bucles
          + STDIN y STDOUT

        ===================
        Introduccion a Perl
        ===================

En este documento intentara explicar una parte de programación en PERL
que significa Practical Extraction and Report Language. Perl a diferencia de
los lenguajes de los lenguajes de programación tradicionales como c/c++, no
necesita un compilador para generar programas ejecutables. Un programa en Perl
es un archivo de texto, este puede ejecutarse sin mas que utilizar un 
interprete Perl.

Perl, en un principio se diseño para extraer informacion de ficheros de texto y
generar informes.

La versión 5 de perl (actualmente la última), soporta programacion orientada a 
objetos. Debido a sus raíces Perl ha sido siempre popular entre los 
administradores de sistemas UNIX, cuando la World Wide Web se empezo ahacer 
popular y hubo necesidad de programas CGI (Common Gateway Interface o
Interfaz de Pasarela Común), perl, comenzó a "crecer", y es es estandar para
escribir programas CGI.

        =================
        Conceptos basicos
        =================

        No quiero extenderme mucho en este apartado, pero deberá saber el
significado de los siguientes conceptos en cualquier lenguaje de programación:

        - Variables: Almacenan datos. El contenido de la variable es su valor.
                Ejemplo; $nombre_del_libro
                         $precio_del_libro
        - Expresiones: Combinan variables usando operadores.
                Ejemplo; $precio_total = $precio_del_libro * 10;
                (Calcularía el precio de 10 libros).
        - Sentencias: Realizan alguna acción, como asignar un valor a una
                      variable o visualizar una cadena...
                Ejemplo; $nombre_del_libro = "El Quijote";
        - Sentencias de control de flujo: Son la estructura condicional
                                          if-then-else y bucles do-while.
                Ejemplo; if ($precio_total > 1000)
                         {
                                print "Ha gastado más de lo permitido\n";
                         }
                         else
                         {
                                print "Ha gastado menos del tope 1000\n";
                         }
        - Funciones: Agrupan distintas sentencias y se les da un nombre.

        ==================
        El primer programa
        ==================

        El primer programa, como siempre será el más simple, sacaremos una
cadena de caracteres por la salida estándar (la pantalla). Haremos el típico
programa para novatos, el hello world. Copie el siguiente código y guárdelo
como un archivo hola.pl

        #!usr/bin/perl
        #primer programa en perl
        print "Hola mundo!!!\n";

        Bien, no hay mucho que explicar, pero si a alguien no le ha quedado
claro, comentaré línea por línea el programa. La primera linea de programa
indica al sistema unix, que el fichero con el que está trabajando es un
programa escrito en Perl. La segunda linea, es un comentario (todo lo que
comience por # escepto la primera linea, el programa los ignorará y solo sirve
para que el programador, haga aclaraciones, notas, etc.). La tercera línea
utiliza la función print para sacar por pantalla lo que sigue entre comillas.
El \n indica una nueva línea.

        Facil, no? la verdad es que más simple no podía ser. Pero he decidido
empezar desde 0, para que todo el mundo lo entienda, aunque no sepa nada de
programación y nunca haya programado.

        Para ejecutar el programa en un sistema unix o variantes, deberemos de
hacelo ejecutable, si está familiarizado con cualquier sistema unix, seguro
que esto lo tiene demasiado claro. Para ello utilice el comando chmod de la
siguiente forma: chmod +x hola.pl. Luego ejecutelo escribiendo perl hola.pl.

        =======================
        Almacenamiento de datos
        =======================

Los datos se almacenan en variables, para luego trabajar con ellos.
Hay 4 tipos de almacenamiento de datos:

        - Variables escalares: almacenan elementos de datos únicos.
                Ejemplo; $precio = 2500;
                         $autor = "Robert L. Ziegler";
        - Variables matriciales/arrays: son listas de variables escalares.
                Ejemplo; @comandos = ("Nuevo", "Abrir", "Guardar", "Salir");
        - Matrices asociativas: son colecciones de parejas clave, en las que
                                la clave es una cadena y el valor es cualquier
                                valor escalar.
                Ejemplo; %gastos = ("Javi" => 200.9,
                                    "Pedro => 190,
                                    "Raul => 1900.95");

        Hagamos un segundo programa, donde por ejemplo, calcule el precio, de
cierto producto y saque cierta información por pantalla:

        #!usr/bin/perl
        # Calcula el precio de cualquier producto

        #Definimos las variables
        $titulo = "El Quijote";
        $precio = "7995";
        $numero = "5";
        
        #Expresión donde se calcula el total
        $total = $precio * $numero

        #Sacamos la información por pantalla
        print "El precio de $numero libros $titulo es de $total\n";

        Bien, ya tenemos el segundo programa, en el cual podemos cambiar el
valor de las variables a nuestro antojo, según el caso que sea. Intente hacer
un programa que calcule por ejemplo el iva de un producto, verá como es muy
simple.

        ==========
        Operadores
        ==========

        Los operadores son los siguientes:

                + Suma
                - Resta
                * Multiplica
                / divide

        Hay más operadores, pero de momento, utilice estos. A medida que vaya
avanzando utilizará más operadores.

        ====================
        Secuencias de escape
        ====================

        La secuencia de escape es la barra invertida seguida por uno o más
caracteres. Son las siguientes:

        \a  --> pitido
        \b  --> espacio atrás
        \cn --> control+N (N es cualquier carácter)
        \e  --> carácter de escape
        \f  --> comienzo de la siguiente página
        \l  --> convierte la siguiente letra en minúscula
        \n  --> nueva linea
        \r  --> retorno de carro
        \t  --> tabulado
        \u  --> convierte la siguiente letra en mayúscula
        \L  --> convierte todos los caracteres posteriores en minúsculas
                hasta el siguiente \E
        \U  --> convierte todos los caracteres posteriores en mayúsculas
                hasta el siguiente \E
        \E  --> fin de las secuencias de escape \L y \U
        \"  --> visualiza comilla
        \$  --> visualiza dólar
        \\  --> visualiza barra invertida
        \Onn -> inserta dígitos octales nn
        \xnn -> inserta dígitos hexadecimales nn

        Imagine que desea guardar el listado de un directorio en una variable
sería de la siguiente forma:

        $list = 'ls' #para sistemas UNIX
        ó
        $list = 'dir' #para windows

        ========
        Matrices
        ========

        La matriz se define con una secuencia de valores escalares separados
por comas y encerrados por paréntesis, como se muestra de la siguiente manera:

        @arc_perl = ("hello.pl", "var.pl", "print.pl");

        aunque podríamos hacerlo de la misma manera si es un listado de un
directorio, de la siguiente manera:

        @arc_perl = 'ls *.pl';

        Cada elemento en una matriz es una variable escalar y es posible
acceder a él conociendo su posición en la matriz. Siendo el primer elemento
de la matriz $arc_perl[0], el segundo $arc_perl[1] y así sucesivamente, debe
de fijarse que en realidad cada elemento es una variable y no una matriz, por
lo que debe cambiarse el símbolo @ (de matriz) por el de $ (de variable 
escalar). También debe de anotar, de que si desea acceder al último elemento
de la matriz debe de usar el índice -1, de la siguiente forma $arc_perl[-1].

        Si desea contar los elementos de una matriz, se debe inicializar una
variable escalar con el nombre de una matriz, de la siguiente manera:

        @colors = ("rojo", "azul", "verde", "amarillo");
        $num_colors = @colors;
        print "Tenemos $num_colors\n"; #imprimirá un 4

        Otra forma de obtener el número de elementos de una matriz es usar la
variable escalar $#arrayname (que es el nombre de una variable matricial) que
almacena el último índice de la matriz. $#num_colors es 3.

        Pasemos ahora a explicar la matriz @ARG, perl define esta matriz
usando todos los argumentos de la línea de comandos cuando el programa se
inicializa. Esto sería un ejemplo para que quede más claro:

        #!/usr/bin/perl
        print "Bienvenido $ARG[0],\n";
        print "Gracias por ejecutar nuestro programa.\n";

        Si ejecutásemos este programa llamado arg.pl escribiendo lo siguiente:

        perl arg.pl Javi

        El programa daría la siguiente salida:

        Bienvenido Javi
        Gracias por ejecuta nuestro programa.

        Bien, más o menos ya tenemos claro algo sobre las matrices, pero ahora
aprenderemos a añadir o eliminar los elementos de una matriz.

        Imagine que tenemos los siguientes elementos en una matriz:

        @names = ("Pedro", "Javi", "Paula", "Lorena");

        Si deseamos extraer el primer elemento de la matriz @names deberemos
utilizar la función shift, de la forma siguiente:

        $elim_primer = shift @names;

        Lo que hace esto es quita el elemento Pedro de la matriz @names, por
lo que esta matriz disminuirá el número de elementos quedándose en 3 elementos
y el elementos extraido (Pedro) se añadirá a la variable escalar $elim_primer.

        Si desea empezar por extraer el último elemento de una matriz deberá
usar la función pop, veamos un ejemplo para que quede más claro:

        @names = ("Pedro", "Javi", "Paula", "Lorena");
        $elim_ultimo = pop @names;

        Esto eliminará el ultimo elemento de @names que es "Lorena", utilice
la print si desea ver los resultados por pantalla, que resulta muy cómodo.
También puede ver el antes y el después para ver como actuan las funciones que
ha utilizado, de la siguiente forma:

        @names = ("Pedro", "Javi", "Paula", "Lorena");
        print "Tenemos estos nombres al principio\n @names\n.";
        $elim_ultimo = pop @names;
        print "Pero al utilizar la funcion pop, tenemos \n @names \n.";
        print "Y el valor que ha sido extraido es $elim_ultimo\n.";

        Sencillo, no? esto resulta muy útil, de forma que ve lo que se está
haciendo en todo momento, y que se ha eliminado y que no... etc.

        Hasta ahora hemos visto como eliminar elementos en una matriz, pero
ahora tenemos que saber como añadir elementos a una matriz.

        Para añadir elementos a la matriz utilizaremos las función unshift,
que añade un elemento al principio de la matriz y aumenta el tamaño de la
misma en una unidad, sería de la siguiente manera:

        @names = ("Pedro", "Pablo", "Javi");
        unshift (@names, "Juan", "Marcos");

        Por lo que la matriz habrá aumentado en 2 unidades, y el orden sería
el siguiente Juan, Marcos, Pedro, Pablo y Javi.

        Ahora bien, si queremos añadir elementos a una matriz, pero esta vez
al final de una matriz, deberemos utilizar la función push de la siguiente
manera:

        @names = ("Pedro", "Pablo", "Javi");
        push (@names, "Juan", "Marcos");

        En este caso la matriz @names contiene cinco elementos en el siguiente
orden; Pedro, Pablo, Javi, Juan y Marcos.

        Vayámos más adelante, e intentemos dar nuevos pasos y aprender así
nuevas técnicas de programación. Pasemos a explicar como clasificar los
elementos de la matriz. Si queremos clasificar los elementos de la matriz por
orden alfabético, debemos recurrir a la función sort. La función sort devuelve
una matriz clasificada, pero no altera la matriz original, es decir que se
debe guardar el resultado de la clasificación en otra matriz. Veamos un
ejemplo para que esto quede un poco más claro:

        @names = ("Juan","Pedro", "Marcos", "Dani", "Patricia");
        @alf_names = sort(@names);

        Es decir, la matriz @names sería el conjunto de estos elementos
ordenados de la siguiente manera; Juan, Pedro, Marcos, Dani y Patricia.
Mientras que la matriz @alf_names sería el conjunto de estos elementos 
ordenados de la siguiente manera; Dani, Juan, Marcos, Patricia y Pedro. Es
decir la primera matriz no es modificada, sinó que es creada una nueva matriz
con los elementos de la primera pero con su orden cambiado.

        También podemos usar la función splice, que puede remplazar una parte
de la matriz por otra matriz. La función splice elimina un número de elementos
dado por el parámetro longitud, inserta la matriz indicada en el lugar que
ocupaban los elementos borrados. La sintaxis de splice es la siguiente:

        splice(@antiguo, desplazamiento, longitud, @nuevo);

        Queda claro? veamos un ejemplo para evitar confusiones.

        @names = ("Pedro", "Javi", "Arturo", "Pablo", "Juan");
        @nuevo = ("Jovi", "Minero");
        splice (@names, 3, 1, @nuevo);
        print "@names\n";

        Si ejecutamos este programa, se produciría la siguiente salida:

        Pedro, Javi, Arturo, Jovi, Minero, Juan.

        Bien, por si no queda claro os lo explico; fíjese en la matriz @names,
la funcion splice salta "3" elementos y borra solo "1" y allí mismo inserta
los elementos de la matriz @nuevo, que son Jovi y Minero, quedando el orden
por detrás de todos escepto de Juan. Creo que ahora ha quedado más claro.

        Bien, más o menos las matrices han quedado claras, pasemos ahora a las
matrices asociativas. Que mejor, para verlo que un ejemplo:

        %gastos = ("Jovi", 1000,
                   "Minero" 999,
                   "Juan"   100,
                   "Javi"   350,
                   "Alberto" 60);
        $jovi_gastos = $gastos{"Jovi"};
        print "Jovi gastó \$$jovi_gastos.\n";

        La salida de este programa sería la siguiente:

        Jovi gastó $1000.

        En las matrices asociativas, a un elemento de la matriz se le asocia
otro elemento de la matriz, a diferentes personas se les asignan sus gastos
(que cada uno es diferente). Se busca el elemento de la matriz mediante el
nombre para saber el gasto, definimos una variable nueva en este caso esa
variable es $jovi_gastos, a la que se le busca a que elemento pertenece, que
se busca de esta manera $gastos{"Jovi"} donde utiliza el valor asociado a Jovi
que es 1000. Para comprenderlo mejor, haced ejemplos de matrices asociativas.

        Bien, imagine que desea añadir un "hueco" para un nuevo nombre que 
esté asociado a un gasto, se haría de la siguiente forma:

        %gastos = ("Pablo" => 100,
                   "Pedro" => 350,
                   "Javi"  => 670);
        #añadimos un nuevo elemento a la matriz asociativa
        $gastos {"Juan"} = 390;

        El elemento Juan con gasto 390, será añadido a la matriz asociativa,
después de que la matriz %gastos halla sido creada.

        Pasemos ahora a explicar la matriz asociativa %ENV. La variable PATH
guarda un valor que consiste en una lista de nombres de directorio, donde el
sistema operativo (tanto windows como linux, unix y demás) guardan donde han
de buscar los comandos para el sistema, comandos como ls, pwd, etc.

        En UNIX la variable de ambiente PATH se define mediante la siguiente
cadena:

        /usr/local/bin:/bin:/usr/bin:/usr/etc:/usr/X11/bin:

        Mientras que en windows suele tener la siguiente forma:

        C:\WINDOWS;C:\WINDOWS\COMMAND;C:\PERL5\BIN;

        Fíjese, que cuando utiliza un comando en un sistema UNIX, primero
buscará ese programa en /usr/local/bin, si no lo encuentra lo buscará en /bin,
y así sucesivamente (notese que la separación en estos sistemas en con ":").

        Lo mismo pasa en un sistema como windows, pero en este caso, son
separados los directorios mediante ";". Para ver el valor de la variable PATH
solo ha de escribir PATH en el prompt del sistema en el que se encuentre,
tanto en sistemas UNIX como Windows.

        Para acceder a la variable de ambiente PATH, mediante un programa en
pero se haría de la siguiente forma:

        print "El PATH actual es $ENV{PATH}\n;

        Aunque también se puede hacer haciendo una llamada al sistema:

        system("PATH");

        Debe de tener en cuenta una cosa muy importante cuando programa, y es
que siempre hay más de una forma de hacer las cosas, no solo hay un camino.

        Bien, sigamos y pasemos a explicar la visualización de variables de
ambiente; escriba el siguiente código en su intérprete:

        foreach $name (keys(%ENV))
        {
                $value = $ENV{$name};
                print "$name = $value\n";
        }

        Usamos la función keys y la sentencia foreach para visualizar todas
las variables. La función keys acepta como argumento una matriz asociativa y
devuelve todas las claves en esa matriz. De tal forma keys(%ENV) es una lista
de nombres de variables de ambiente.

        La sentencia foreach permitirá discurrir por una lista de elementos,
copiar uno de esos elementos en una variable, en este ejemplo $name. Se puede
acceder a los valores correspondientes utilizando cada clave como índice en la
matriz asociativa %ENV.

        Pasemos a utilizar una matriz asociativa como una pequeña base de
datos, para acceder a un elemento de una matriz asociativa se necesita una
clave, por lo que cuando se quiera consultar todos los elementos de la matriz
asociativa necesitará las claves. Utilicemos la función keys para tomar el
nombre de la matriz asociativa como argumento y que devuelva una matriz con
todas las claves. Veamos un ejemplo:

        #!/usr/bin/perl
        #definimos la matriz asociativa
        %gastos = ("Javi" => 1000,
                   "Jose" => 1500,
                   "Juan" => 14.5,
                   "Maria => 950.75");

        #Obtenemos las CLAVES y las visualizamos
        @claves = keys(%gastos);
        print "@names\n";

        Con este programa se visualizará la siguiente salida por pantalla:

        Juan Maria Javi Jose

        Bien, podemos observar como se han devuelto las "claves", pero si nos
fijamos bien veremos que las claves son devueltas con un orden aleatorio. Si
desea imprimir las claves en orden alfabético puede utilizar la función sort
como se muestra a continuación:

        #!/usr/bin/perl
        #definimos la matriz asociativa
        %gastos = ("Javi" => 1000,
                   "Jose" => 1500,
                   "Juan" => 14.5,
                   "Maria => 950.75");

        #Obtenemos las CLAVES y son ordenadas alfabeticamente
        @claves = keys(%gastos);
        @claves_alfab = sort(@claves);

        #Visualizamos los elementos UNO A UNO
        foreach $claves (@claves_alf)
                {
                print "$name gastó \$$gastos{$name}\n";
                }

        La salida de éste programa sería la siguiente:

        Javi gastó $1000
        Jose gastó $1500
        Juan gastó $14.5
        Maria gastó $950.75

        Puede ver como la salida del programa tiene una estructura ordenada,
pero también puede utilizar la función values muy parecida a la función keys:

        @claves = values(%gastos)
        print "@claves\n";

        Siendo la matriz asociativa %gastos definida anteriormente, la salida
del programa sería la siguiente:

        1000 14.5 1500 950.75

        Los valores son devueltos de forma arbitrária.

        Hagámos un programa que obtenga primero las claves y luego los valores
uno a uno, para ello puede utilizar la función each de la siguiente manera:

        #!/usr/bin/perl
        #definimos la matriz asociativa
        %gastos = ("Javi" => 1000,
                   "Jose" => 1500,
                   "Juan" => 14.5,
                   "Maria => 950.75");

        #Visualiza los pares clave-valor uno a uno
        while(($name, $money) = each(%gastos))
        {
                print "$name gastó \$$money\n";
        }

        $name y $money almacenan un par clave-valor, cuando no hay más
elementos en la matriz asociativa, la función each devuelve una matriz vacía y
el bucle while finalizará.

        Vayámos ahora al borrado de un elemento de la matriz asociativa. Vea
el siguiente ejemplo como se utiliza la función delete para eliminarlo:

        #!/usr/bin/perl
        #definimos la matriz asociativa
        %gastos = ("Javi" => 1000,
                   "Jose" => 1500,
                   "Juan" => 14.5,
                   "Maria => 950.75");

        #Muestra claves actuales
        @names = keys(%gastos);
        print "Claves originales: @names\n";

        #Eliminamos la entrada correspondiente
        delete($gastos{"Juan"});

        #Muestra las claves de nuevo
        @names = keys(%gastos);
        print "Después de eliminar la entrada: @names\n";

        Si ejecuta el programa verá la siguiente salida por pantalla:

        Claves originales: Javi Juan Jose Maria
        Después de eliminar la entrada: Javi Jose Maria

        Pasemos ahora a ennumerar algunas variables especiales:

        @ARG            ==>     Matriz que contienen los argumentos de las
                                líneas de comando utilizados para iniciar el
                                programa Perl.
        @ENV            ==>     Almacena variables de ambiente.
        $_              ==>     Varias funciones.
        @_              ==>     Lista de argumentos que se transmite a una
                                subrutina.
        $0              ==>     Nombre del fichero que contiene el programa.
        $]              ==>     Número de versión de Perl.
        $<              ==>     ID del usuario.
        $^X             ==>     Ruta completa del intérprete Perl.

        ===============================
        Procesamientos de datos en Perl
        ===============================

        Ya sabémos cómo almacenar datos, ahora solo hace falta saber como
efectuar datos con ellos, cómo escribir expresiones (fórmulas).

        Como ya hemos explicado antes, existen los operadores aritméticos,
tales como la suma(+), resta(-), división(/) o multiplicación(*).

        Escribamos un programa sencillo que realice operaciones artiméticas
usando constantes y variables.

        #!/usr/bin/perl
        
        #Definimos variables
        $producto_1 = "manzanas";
        $precio = 100;
        $iva = 1.16;

        #Operación que calcula el producto
        $producto_1_precio = $precio * $iva;
        $iva_producto = $producto_1_precio - $precio

        #Imprimimos por pantalla
        print "El precio de las $productos_1 con iva es $producto_1_precio\n";
        print "Por lo que el iva son $iva_producto pesetas\n";

        Bien, este programa calcula el iva de cierto producto, y además
calcula la diferencia entre el precio total con iva y el precio sin iva, es
decir la diferencia (el iva en pesetas segun el producto).

        También existen operadores muy comunes como ++ que es el operador de
autoincremento, si desea por ejemplo que una variable aumente su valor en uno
cada vez que se encuentre por ejemplo una palabra en un documento.

        $count++; #seria equivalente a $count = $count + 1;

        El operador de autoincremento se puede utilizarlo de dos formas; como
sufijo de una variable o como prefijo de una variable. El primero se
incrementa la variable DESPUÉS de que se ha utilizado en la expresión en curso
(llamado post-decremento). El segundo se incrementa la variable ANTES de que
se haya utilizado en la expresión en curso (llamado pre-decremento).

        Para que quede más claro, hagamos dos ejemplos con el operador de
autoincremento y veamos su salida.

        #Post-decremento
        $count = 100
        $count_now = $count + 1; #Sería lo mismo que $count++
        print "Cuenta actual = $count_now\nCuenta = $count\n";

        La salida de este programa sería la siguiente:

        Cuenta actual = 100
        Cuenta = 101

        Veamos ahora que pasaría con el pre-decremento:

        #Pre-drecremento
        $count = 100
        $count_now = ++$count
        print "Cuenta actual = $count_now\nCuenta = $count\n";

        El resultado sería:

        Cuenta actual = 101
        Cuenta = 101

        Aquí $count incrementa antes de utilizar el valor, $count cambia de
100 a 101 ANTES de que el valor se asigne a la variable $count_now.

        También existe el operador de autodecremento (--), que disminuye el
valor de la variable en una unidad. Existen dos formas de utilizar éste
operador al igual que el anterior: $count--, el valor de $count se decrementa
después de que el valor antiguo se utilice en la expresión actual. Mientras
que --$count, el valor de $count se decrementa antes de evaluar la expresión
actual.

        ================
        Otros operadores
        ================

        %               ==>     Operador de módulo o resto (9%4=1)
        **              ==>     Operador de exponente
        Virgulilla      ==>     Operador NOT
        &               ==>     Operador AND
        |               ==>     Operador OR
        ^               ==>     Operador OR exclusivo
        <<              ==>     Operador de desplazamiento hacia la izquierda
        >>              ==>     Operador de desplazamiento hacia la derecha

        ==============================================
        Operadores para trabajar con valores numéricos
        ==============================================

        +=              ==>     Operador de asignación de suma
        -=              ==>     Operador de asignación de resta
        *=              ==>     Operador de asignación de multiplicación
        /=              ==>     Operador de asignación de división
        $=              ==>     Operador de asignación de resto
        **=             ==>     Operador de asignación de exponenciación
        &=              ==>     Operador de asignación de AND binario
        |=              ==>     Operador de asignación de OR binario
        ^=              ==>     Operador de asignación de OR exclusivo
        <<=             ==>     Operador de asignación de desplazamiento hacia
                                la izquierda
        >>=             ==>     Operador de asignación de desplazamiento hacia
                                la derecha

        No me voy a extender en explicar cada uno de estos operadores, ya que
es muy extenso y se puede encontrar en cualquier libro o guia de referencia de
programación medianamente bueno.

        Cuando utilice operadores, puede alterar el orden de una determinada
parte de la expresión usando paréntesis.

        Perl incluye funciones como sin o como cos, para calcular el seno o
coseno respectivamente de cualquier valor, pero no incluye para calcular la
tangente, aunque se puede calcular de la siguiente manera:

        tan(A) = sin(A) / cos(A)

        Perl incluye también la función atan2 para calcular el arco tangente,
utilizado muy frecuentemente para calcular por ejemplo la pendiente de un
terreno ($A) dada la elevación ($elev) desde una distancia concreta ($dist):

        $A = atan2($elev, $dist)

        La función sqrt se utiliza para calcular raíces cuadradas, por ejemplo
podria calcular la raíz cuadrada de 2 catetos, obteniendo así la hipotenusa:

        #Definimos los lados
        $x = 4
        $y = 5
        $hipotenusa = sqrt($x**2 + $y**2);
        print "La hipotenusa de un rectángulo de $x por $y es $hipotenusa\n";

        Bién, veamos un poco por encima la función srand y rand, que son
utilizadas para inicializar la semilla para generar números aleatorios y
generar los mismos respectivamente. Veamos un ejemplo:

        #!/usr/bin/perl
        @seq = (); #Definimos Matriz vacía para guardar la secuencia aleatoria
        srand(time()); #Inicializa la semilla usando la salida de la función
                       #time
        $count = 0;
        while($count < 20) #Genera 20 números aleatorios entre 1 y 20
        {
                $number = int(rand(20) + 1); #Genera un número aleatorio y lo
                                             #lo convierte en entero
                for($i = 0); $i < $count; $i++) #Comprueba si el número ya está
                                                #en el array
                {
                        if($number == $seq[$i])
                        {
                                last; #El num. ya está en el array @seq
                        }
                }
                if($i >= $count) #Aun no está en @seq
                {
                #Guarda el num. en @seq e incrementa la cuenta
                        $seq[$count] = $number;
                        $count++;
                }
        }
        #Muestra la secuencia aleatoria
        print "Seq. aleatoria del 1 al 20:\n@seq\n";

        Al ejecutar este programa puede obtener una salida parecida a esta:

        Seq. aleatoria del 1 al 20:
        4 7 5 6 9 8 10 1 2 11 3 20 17 15 12 18 19 13 14 16

        ================================
        Operaciones con cadenas de texto
        ================================

        En lo que esto se refiere, no es más que por ejemplo combinar dos
cadenas de texto para formar una tercera, separar las lineas de un fichero en
varias partes, etc.

        Pasemos a explicar lo que es la concatenación de cadenas y como se
realiza, que en realidad es la unión de las mismas, veamos un ejemplo:

        #!usr/bin/perl
        #Definimos dos variables
        $nombre = "Javi";
        $apellidos = "Perez de la Torre";
        #Concatenamos las dos cadenas
        $nombrecompleto = $nombre. " ".$apellidos; 
        #Imprimimos por pantalla
        print "$nombrecompleto\n";

        La variable $nombrecompleto almacena el resulado de la operación, debe
haber un espacio en blanco entrecomillado entre las dos variables y la
concatenación es representada mediante el signo punto (.).

        Fijémonos ahora en la repetición de cadenas; el operador de repetición
representado mediante el símbolo x, repite una cadena un número específico de
veces. Un ejemplo:
                      
        $separador = "_" x 10
        print "$separador\nBienvenido\n$separador\n";

        Este programa tiene la siguiente salida;

        __________
        Bienvenido
        __________

        Pasémos ahora a explicar la extracción de una subcadena, imagine que
tenemos un fichero de texto que contiene sugerencias de diversas persona, cada
una de éstas sugerencias comienza con una línea informando de quién la envió:

        From: Juan Pérez
        sugerencia... bla bla bla
        From: Javi Pérez
        sugerencia... bla bla bla
        From: Jaime Piedra
        sugerencia... bla bla bla
        From: Jacobo Ibáñez
        sugerencia... bla bla bla
        
        Bién, imagine que desea hacer una lista de las personas que hayan
mandado sugerencias, para ello deberemos de EXTRAER una parte de la cadena,
exactamente la que sigue a la palabra From seguido de un espacio, para ello
podemos usar la función substr de la siguiente forma:

        #!/usr/bin/perl
        $line = "From: Juan Pérez";
        #Extrae el texto que va después de los primeros 6 caracteres
        $from = substr($line, 6);
        print "$from\n";

        Ésto imprimira Juan Pérez, en el próximo número ya escribiré como
acceder a un fichero y hacerlo con todas las lineas, de momento basta con
tener esto claro. Pero expliquemos un poco más la función substr, imagine que
tiene almacenado en una variable "Perl es un lenguaje de programación.", y que
de esa linea solo desea copiar la parte de "lenguaje", se podría hacer de la
siguiente manera:

        #!/usr/bin/perl
        #Cadena original
        $line = "Perl es un lenguaje de programación.";
        #Extracción de una parte de la cadena anterior
        $parte = substr($line, 12, 8);
        print "$parte\n";

        Lo que hace este programa, es extraer de la cadena almacenada en $line
a partir del caracter 12 y terminando de extraer 8 caracteres más.

        También puede hacer uso de la función index, imagine que no sabe la
posición en la que se encuentra la palabra lenguaje, y es la que desea extraer
esto se podría hacer de la siguiente forma:

        #!/usr/bin/perl
        $line = "Perl es un lenguaje de programación.";
        $pos = index($line, "lenguaje");
        $part = substr($line, $pos, 8);
        print "$part\n";

        Creo que queda bastante claro, pasemos ahora a calcular la longitud
por ejemplo de una cadena, es decir el número de caracteres que ésta contiene.
Para ello podemos usar la función length del siguiente modo:

        #!/usr/bin/perl
        #Cadena original
        $line = "Perl es un lenguaje de programación.";
        #Calcula la longitud de $line
        $longitud = length($line);
        #Muestr la candena original
        print "$line\n";
        Prepara la linea de guiones y las visualiza
        $uline = "-" x $length
        pritn "$uline\n";

        La salida de este programa sería la siguiente:

        Perl es un lenguaje de programación
        -----------------------------------

        Los guiones son utilizados para hacer una especie de subrayado, que
encajará perfectamente con la longitud de la cadena, ya que se multiplica el
número de guiones por la longitud de la cadena (que es $longitud). Avancemos
un poco y pasémos a explicar otros operadores.

        =======================================
        Operadores para comparaciones numéricas
        =======================================

        ==              ==>     Operador de igual que
        !=              ==>     Operador de distinto de
        <               ==>     Operador de menor que
        >               ==>     Operador de mayor que
        <=              ==>     Operador de menor o igual que
        >=              ==>     Operador de mayor o igual que
        <=>             ==>     Operador de comparación de tres vías

        ================================
        Operadores para comparar cadenas
        ================================

        eq              ==>     Verdadero si las cadenas X e Y son iguales
        ne              ==>     Verdadero si las cadenas X e Y son distintas
        gt              ==>     Verdadero si X es mayor que Y
        ge              ==>     Verdadero si X es mayor o igual que Y
        lt              ==>     Verdadero si X es menor que Y
        le              ==>     Verdadero si X es menor o igual que Y
        cmp             ==>     -1 si X es menor que Y, 0 si son iguales, 1
                                si X es mayor que Y

        Cuando comparamos cadenas, se dice que una cadena es mayor que otra,
comparando su "valor numérico" de los caracteres, es decir el valor de A es 65
el valor de B es 66, por lo que A es menor que B. El valor numérico de los
caracteres viene determinado por el código ASCII.

        ===================
        Sentencias y Bucles
        ===================

        Debe de tener claro la siguiente estructura:

        palabra clave (expresión)
        {
        bloque de sentencias
        }

        La expresión entre paréntesis se comprueba antes de que el bloque de
sentencias entre llaves se ejecute. Se deben de poner llaves para delimitar
las sentencias. Debe de utilizar las sentencias if y unless para ejecutar un
bloque de código basado en el valor de la expresión, pero tambien puede usar
las sentencias elsif y else con la sentencia if.

        ==
        if
        ==

        If ejecuta un bloque de sentencias si se cumple una condición. La
estructura de una sentencia combinada if-else tiene la siguiente estructura:

        if (expresión)
        {
        sentencias a ejecutar si la expresión es verdadera
        }
        else
        {
        sentencias a ejecutar si la condición es falsa
        }

        esto ejecuta unas sentencias si la condición es falsa, y otra
diferente si la condición es verdadera, pero a veces es necesario comprobar
más de dos alternativas, por lo que podría utilizar una sentencia if con
varias cláusulas elseif y una cláusula else para implementar ésta lógica, de
la siguiente manera:

        if ($longitud >= 10)
        {
                print "Es mayor de 9!!!!!!\n";
        }
        elseif ($longitud >= 6 && $longitud <= 9)
        {
                print "Es mayor o igual a 6 pero menor que 10!!!!\n";
        }
        elseif ($longitud > 3 && $longitud < 6)
        {
                print "Mayor que 3, pero menor que 6!!!\n";
        }
        } else
        {
                print "Muy Bajo!\n";
        }

        Imagine por ejemplo que desea salir del programa si el valor excede de
15, podría escribir lo siguiente para realizar esta operación:

        exit if($error >25);

        ======
        unless
        ======

        Muchas veces, quiere ejecutar un bloque de sentencias si una condición
es falsa, por lo que escribir "si no es el root, no ejecutar este programa",
queda un poco lioso, y es más facil utilizar la lógica de "a no ser que sea
root, no ejecutar el programa", esto se realiza con la sentencia unless , que
significa "a menos que". Veamos un ejemplo:

        unless(open(DATAFILE. "tree.dat"))
        {
                die "No se puede abrir el fichero de datos!\n";
        }

        El programa se podría leer de la siguiente manera: "a no ser que el
fichero se abra, paralizar el programa". La funcíon die provoca la salida del
programa después de visualizar el mensaje que tenemos como argumento.

        =====
        while
        =====

        Imagine que desea ejecutar un bloque de sentencias hasta que alguna
condición llegue a ser falsa, la operación de repetición de un bloque de
sentencias se le llama bucle. Veamos un ejemplo de un programa que sume los
números del 1 al 10 y hasta que no los sume no salga del bucle:

        #!/usr/bin/perl
        while($i <= 10)
        {
                $sum += $i;
                $i++
        }
        print "Suma del 1 al 10 = $sum\n";

        La salida del programa será la siguiente:

        Suma del 1 al 10 = 55

        La sintaxis del bucle es la siguiente:

        while (expresión)
        {
                bloque de sentencias a ejecutar MIENTRAS la expresión sea
                verdadera
        }

        =====
        until
        =====

        La sentencia until repite un bloque de sentencias hasta que una
determinada condición se haga verdadera, until ejecuta el bloque mientras la
condición es falsa y repite el bucle hasta que una expresión se cumpla. Veamos
un ejemplo:

        #!/usr/bin/perl
        #Procesa órdenes hasta que se introduce "quit"
        until ($command eq "quit")
        {
                $command = &lt;STDIN>; #Lee la orden
                chop $command; #Elimina el carácter final de nueva línea
                print "$command\n";
        }

        Éste programa acepta órdenes y las imprime hasta que se teclee quit,
por lo que $command es equivalente a quit y termina el bucle until.

        ===
        for
        ===

        La sintaxis del bucle for es la siguiente:

        for (expresion_1; expresion_2; expresion_3)
        {
                bloque de sentencias
        }

        La expresión expresion_1 se evalúa una vez, el bloque de sentencias se
ejecuta mientras la expresión expresion_2 sea verdadera. La expresión
expresion_3, se evalúa despues de cada ejecución del bloque de sentencias.
Debe de tener en cuenta que debe colocar las llaves alrededor del bloque de
sentencias incluso si no hay sentencias, veamos un ejemplo:

        for ($i=1, $sum=0; $i <= 10; $sum += $i, $i++) {}

        =======
        foreach
        =======

        Puede utilizar foreach para ejecutar el bloque de código con cada
elemento de la matriz y puede utilizar el bucle for para acceder a cada
elemento de una matriz mediante su índice.

        Imagine que desea hace un programa que encuentre el mayor valor en una
matriz, se podría hacer de la siguiente forma:

        #!/usr/bin/perl
        #Definimos la matriz
        @num = (55, 45, 54, 33, 22, 39, 10, 9, 57, 89, 99);
        #Encuentra el mayor valor
        foreach $num (@num)
        {
                if($num > $max)
                {
                        $max = $num;
                }
        }
        #Visualiza el mayor valor
        print "Valor máximo de la matriz = $max\n";

        Sencillo, no? bien, realmente la sintaxis sería la siguiente:

        foreach $variable (@matriz)
        {
                bloque de sentencias
        }

        Debe de saber, que si se omite la variable en una sentencia foreach,
Perl interpreta que se está utilizando la variable $_ para guardar el elemento
actual de la matriz.

        ================
        Ruputa de bucles
        ================

        A veces, es necesario romper un bucle antes de que se hayan realizado
todas la iteraciones, por ejemplo está buscando un nombre en una matriz y
desea que termine el bucle tan pronto como encuentre su objetivo, los nombres
se almacenan en la matriz @nombres y quiere buscar el nombre que se guarda en
la variable $customer.

        foreach $name (@nombres)
        {
                #rompe el bucle si se encuentra $customer
                last if($customer eq $name);
                #otro codigo...
        }

        Es posible usar last en todos los tipos de bucles. Puede tener un
bucle dentro de otro, y con el comando last puede romper el bucle exterior,
aunque last se encuentre en el bucle más interno, para ello primero ha de
etiquetarse el bucle exterior (darle un nombre), luego ha de colocarse el
nombre del bucle después de la palabra reservada last, un ejemplo:

        BUCLE_EXTERIOR: while($line =&lt;STDIN>)
        {
                chop $line; #Se omite el carácter de nueva línea
                foreach $name (@names)
                {
                        last BUCLE_EXTERIOR if ($line eq $name);
                        #Finaliza el bucle exterior
                }
        }

        La etiqueta que se le asigna, debe siempre ir seguida de : para que
Perl así lo identifique.

        También puede utilizar el comando next para saltar la iteración de un
bucle, en los casos que existe un bucle dentro de otro, se puede utilizar una
etiqueta con el comando next para designar al bcle que queremos saltar. Cuando
se use next sin etiqueta se salta la próxima iteración del bucle interno.

        ==============
        STDIN y STDOUT
        ==============

        Los programas Perl se diseñan generalmente para leer información de la
entrada estándar (el teclado) y enviarla a la salida estándar (la pantalla),
ésta entrada y salida estándar se puede redireccionar. La expresión siguiente
lee una línea de la entrada estándar "$line = &lt;STDIN>" y la almacena en una
variable llamada $line. La función print envía su salida a la salida estándar
que por defecto es la pantalla.

        Hay dos formas de redireccionar STDIN y STDOUT: Usando operadores de
redireccionamiento (por ejemplo enlazando la salida a un fichero) o usando la
salida de otro programa como STDIN.

        Puede usar operadores de redireccionamiento para enlazar STDIN y
STDOUT a ficheros en lugar de conectarlos al teclado y a la pantalla
respectivamente.

        El signo < es el operador de redireccionamiento de entrada, mientras
que el signo > es el operador de redireccionamiento de salida.

        Puede redireccionar el gestor STDOUT de cualquier programa al STDIN
de un programa Perl, para ello deberá usar el operador | (también conocido
como pipe o tubería), que conecta la salida STDOUT del primer programa con la
entrada STDIN del segundo.

        Perl evalúa &lt;STDIN> como resultado la siguiente línea de la entrada
estándar, todo lo que hay que hacer es asignar el valor a la variable:

        $linea = &lt;STDIN>;

        Lee la siguiente línea de la entrada estándar y almacena el texto en
la variable llamada $line. &lt;STDIN> lee todos los caracteres de la línea
incluyendo el carácter de nueva línea, si desea eliminar el carácter de nueva
línea, puede hacer uso de la función chomp de la siguiente manera:

        $linea = &lt;STDIN>;
        chomp $linea; #Elimina el caracter de nueva linea de $linea

        Por lo general, se asigna el valor de &lt;STDIN> a una variable, para
almacenar el texto de entrada que se utilizará después, la línea de texto se
asigna automáticamente a una variable llamada $_. Esto ocurre cuando se usa
&lt;STDIN> como la expresión condicional de un bucle while, un ejemplo:

        while(&lt;STDIN>)
        {
                print $_;
        }

        Este programa devolverá el carácter introducido hasta encontrar el
carácter de fin de fichero, que es marcado con control+D (en Unix) o control+Z
seguido de intro (en Windows).

        También puede asignar &lt;STDIN> a una matriz, por ejemplo:

        @line = &lt;STDIN>;

        Hay una forma especial de leer la entrada estándar mediante el
operador <>, por ejemplo:

        print while(<>);

        El programa almacena datos en un fichero.

        Veámos ahora STDOUT, se puede especificar a la función print que envíe
su salida a STDOUT, por ejemplo:

        print STDOUT "WeLcOmE tO pErL ;)\n";

        Si desea enviar la salida a un fichero abierto (que se identifica a
través de su gestor de fichero), debe de usar la función print con el nombre
de gestor de fichero como argumento:

        print GESTORDEFICHERO, "Texto a enviar al fichero";

        Debe de tener el fichero abierto para escritura, Para ello puede
añadir el prefijo > al nombre del fichero, lo que se hace al sistema operativo
es que se quiere abrir el fichero para escritura.

        Cuando abre un fichero puede utilizar la estructura Open OR die, por
ejemplo:

        open (GESTOR_DE_FICHERO, "Nombre_del_fichero") ||
        die ("No se puede abrir el fichero!!!!!\n");

        El funcionamiente se puede comprender de la siguiente manera: "abre el
fichero X o si no lo puede abrir por lo que sea el programa muere y muestra
por pantalla Y".

        Al terminar la utilización de un fichero es necesario cerrarlo
llamando a la función close, como se muestra a continuación:

        close GESTOR_DE_FICHERO;

        Con esto finaliza este articulillo, espero que os sea de gran ayuda.

        Algunas direcciones de interes, son las siguientes:

        Http://www.perl.com
        Http://www.cpan.org

Si teneis alguna duda sobre cualquier tema o articulo que hay escrito,os 
quereis poner en contacto conmigo por cualquier razón, quejas o cualquier
otra cosa podeis escribir a mi mail: overdrive@ono.com
        
Tambien podeis contactar conmigo en el irc en el servidor hispano, en los 
canales #programación y #perl.

-=(EOF)=-



```

</div>
