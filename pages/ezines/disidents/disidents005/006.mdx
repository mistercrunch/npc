---
title: "006"
ezine: "disidents"
---

# 006

**Ezine:** disidents

<div className="ascii-content">

```
[006]_MΘtodos_de_Compresi≤n_sin_PΘrdida_de_la_Informaci≤n_by_SparK_-_Disidents_Journal_5


                     -+-| DisidentS Hack Journal #5 |-+-
 
 
 
 
 
 
 
 
 
   ______________________________________________________________________
  |                                                                      |
  | -+- Titulo_____: MΘtodos de Compresi≤n sin PΘrdida de la Informaci≤n |
  | -+- Autor______: SparK                                               |
  | -+- E-Mail_____: dsd_cracking@portadaauga.org                        |
  | -+- Team_______: DisidentS Argentina - http://disidents-team.cjb.net |
  |______________________________________________________________________|
 
 
 
 
 
"la potencia sin control..no sirve de nada"
>>------------------------------------------------------------------------<<
 
 
 
----------------------------------------------------------------------------
----------------------------------------------------------------------------
 
.==========================================================================.
|===========~ INDICE ~======================================================
|===========================================================================
|=~ 1- Introducci≤n                                                        |
|=~ 2- ┐PorquΘ Compresi≤n?                                                 |
|=~ 3- Teorφa sobre algunos mΘtodos                                        |
|=~ 4- Metodo Central: Compresi≤n sin PΘrdida                              |
|=~ 5- Ejemplo paso a paso                                                 |
|=~ 6- Aplicaciones                                                        |
|=~ 7- Conclusi≤n                                                          |
|=~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~=.
======================================================~ INDICE ~============
============================================================================
 
.==========================================================================.
|===========~ 1- Introducci≤n. ~|===========================================
|===========================================================================
 
Buenas mis queridos seguidores y amigos, pues aquφ estamos de nuevo con una
nueva aventura.

Si se±or, se trata de una aventura comprimida, ┐c≤mo? , ni mßs ni menos que de
compresi≤n de la informaci≤n.
Nos adentraremos en algunos mΘtodos y algoritmos conocidos, pero mßs a·n nos
adentraremos en un mΘtodo muy ·til, llamado mΘtodo de compresi≤n sin pΘrdida.

Entre otras cosas veremos un ejemplo prßctico dise±ado, programado y testeado
por mφ, es un programa que comprime utilizando el mΘtodo que explicarΘ a con-
tinuaci≤n.

Les aviso desde ahora amigos/as que mi ejemplo seguramente tiene bugs, no estß
lo suficiente depurado y fallarß en la mayorφa de los casos, asφ que para 
aquellos crφticos, criticones que critican y saben hacer eso solamente, va 
esta aclaraci≤n. :D

Bien, sin mßs que decir en este apartado, pasemos al siguiente!! :)

-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 2- ┐PorquΘ Compresi≤n?. ~|====================================
|===========================================================================
 
Muchos se preguntarßn, con la misma pregunta que este apartado, bueno, les 
respondo: "La compresi≤n es casi la base de la informßtica!!"

Si se±ores asφ es, todo esta comprimido en la mayor parte del tiempo. 
A medida que escuchamos m·sica, un tipo de formato con algunas tΘcnicas en el
manejo de estructuras de informaci≤n son procesadas por nuestro procesador.

Muchos de nosotros vemos, que todo estß muy separado, pero no es asφ, todo
es byte, absolutamente todo es una mezcla de bytes, una mara±a eterna de 
bytes aparentemente sin sentido.

┐QuΘ es lo que le da forma a nuestros bytes?

Los formatos, estos son formas de guardar la informaci≤n, es decir, se han
dise±ado estructuras de la informaci≤n para almacenar de una manera un tipo
de datos especφficos, y a esa estructura se le da un nombre, este nombre, 
identifica el formato.

Estas estructuras de informaci≤n nos revelan la manera en que los datos estßn
almacenados, para que sirve cada uno, como se usa cada dato, donde y c≤mo se
aplica.

Por supuesto, como muchos pensaran, estas estructuras de datos son procesadas,
"entendidas" por algunas aplicaciones especialmente dise±adas para ello.
Exactamente es eso, una acplicaci≤n que abre un documento Word, ┐ quΘ hace ?,
simplemente trata de interpretar una cantidad de  bytes almacenados en una 
cantidad dada de sectores dentro de un disco rφgido, Θsta cantidad de sectores
a leer estß dada por tablas de informaci≤n que no son ni mßs ni menos que 
otras estructuras con la que el sistema operativo hace uso de ellas, para saber
cuales sectores del disco rφgido pertenecen a ese fichero el cual queremos 
acceder desde word.

Como verßn estamos frente siempre al mismo problema, el problema de hacer 
interpretar a nuestra PC que es lo que queremos, y como queremos que lo 
interprete.

Bien, Θste es el gran porquΘ de los drivers, del sistema operativo y demßs 
programas que forman parte de un sistema. 
Existe para decirle a nuestra pc, algo asφ: 

"Oye!, esta estructura es un fichero de sonido, debes pasarla por el driver de sonido!!"

Una estructura de datos que define a un formato especφfico serφa asφ:

typedef struct tagBITMAPINFOHEADER {    /* bmih */
    DWORD   biSize;
    LONG    biWidth;
    LONG    biHeight;
    WORD    biPlanes;
    WORD    biBitCount;
    DWORD   biCompression;
    DWORD   biSizeImage;
    LONG    biXPelsPerMeter;
    LONG    biYPelsPerMeter;
    DWORD   biClrUsed;
    DWORD   biClrImportant;
} BITMAPINFOHEADER;

Este es el header de un fichero BMP, una parte aclaro, como podemos ver
es una estructura que se guarda de un fichero, y el programa que quiera
procesarlo, deberß interpretar esta estructura.

Bueno, la compresi≤n justamente es una manera de interpretar la informaci≤n
y transformarla en otra informaci≤n con una sola diferencia, que el resultado
SIEMPRE sea menor o IGUAL al original.

La manera de interpretar datos comprimidos, es interpretando una estructura
previamente creada, durante el proceso de creaci≤n.

Una vez interpretadas las estructuras se puede proceder a la descompresi≤n.

-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 3- Teorφa sobre algunos mΘtodos. ~|===========================
|===========================================================================
 
Bien amigos, existen dos grandes categorφas, los mΘtodos con pΘrdida y sin
pΘrdida.

Con pΘrdida son aquellos los cuales como algunos esperarßn leer, pierden 
informaci≤n, ┐algunos ejemplos? MP3 por ejemplo, MPG, WMA, etc.

┐QuΘ no sabφan que perdφan informaci≤n esos formatos?

Bien, ┐c≤mo pueden imaginarse que un mp3 puede alojar la calidad de un CD en 
tan poco espacio?
Por eso amigos cuando queremos extraer a MP3 un cd de m·sica debemos elegir
la calidad, justamente lo que estamos eligiendo ahφ es que tan buena va a
ser la compresi≤n del mP3, y cuanta informaci≤n queremos que se pierda.

A menos calidad, mßs pΘrdida de informaci≤n y mayor compresi≤n.

Los sonidos mßs relevantes son destacados solamente, evitando por ej, el sonido
de un rasguido de una guitarra.

┐ Y que creen de los demßs formatos mencionados ?, pues, es lo mismo mis amigos
cuando en el photoshop u otra aplicaci≤n elegimos guardar en JPG, y nos pregunta
con que calidad, esto es lo mismo que en el MP3, se hace para saber que informaci≤n
debe evitar guardar, y cual no.

Les cuento un secreto jeejejje (ya deja de serlo), en la esteganografφa, se
aprovechan los problemas de compresi≤n para alojar bits ocultos, contenidos
de frases encriptadas.

Con problemas de Compresi≤n me refiero a que hay partes de un fichero que 
a pesar los mejores mΘtodos de compresi≤n, no se comprimen a pesar de parecer
estar "de mßs", estas partes son reutilizables para programas de ocultamiento
de informaci≤n para ocultar datos dentro de esos grßficos.

Por supuesto formatos como BMP, o GIF no son tan comprimidos, y puede haber mßs
zonas para ocultar nuestros preciados bits, ya hablaremos del caso ;) .

Bueno amigos, ahora le toca el turno a la compresi≤n sin pΘrdida, justamente es
eso, simplemente trata de comprimir sin perder informaci≤n, luego cuando la re-
cupera debe ser identica a la informaci≤n comprimida sino no servirß.

Justamente el fin para el cual es usada Θsta tecnologφa es para procesos en los 
cuales la informaci≤n es ·til en su totalidad, no hay desechos, toda debe pro-
cesarse, entonces se utilizan estos algoritmos, que no "tiran" nada a la basura.

ZIP, RAR, ACE, LZH, CAB, son algunos ejemplos de este tipo de compresi≤n.

Imaginen si un fichero EXE que queremos comprimir, hacemos que pierda informaci≤n
para que se comprima mßs, como si fuera un MP3, entonces, perderφamos trozos de
la cabecera del fichero quizßs, trozos de datos, c≤digo del programa, un tremendo
caos. :)

Actualmente este tipo de compresi≤n se estß tratando de implementar, para 
suplantar en algunos ambientes al MP3. ┐QuΘ se quiere ganar con esto?

Quieren un formato que comprima tanto como MP3 pero que no pierda tanto como MP3.

Entonces, estßn dise±ando mΘtodos de compresi≤n nuevos utilizando el mΘtodo
de compresi≤n sin pΘrdida.
El tama±o resultante no serß el de un fichero WAV pero tampoco serß del tama±o
de un MP3, con lo que podrφamos "sacrificar" un poco de espacio a cambio de la
mejor calidad.

TambiΘn estß naciendo un nuevo sistema de compresi≤n, una tercera categorφa, 
aunque a·n menor, yo la nombro igualmente es denominada:

			SISTEMAS DE COMPRESI╙N EMERGENTES 

Este tipo de compresi≤n permitirß a travΘs de un s≤lo fichero obtener, 
distintas versiones del mismo, es decir, podemos extraer de una imagen,
varias, simplemente eligiendo de quΘ calidad la queremos, esto es posible
ya que la imagen original esta contenida dentro del fichero.

-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 4- Metodo Central: Compresi≤n sin PΘrdida. ~|=================
|===========================================================================

Bien Θste mΘtodo pura y objetivamente estß centrado en la entropφa.

┐QuΘ es la entropφa?

CopiarΘ una definici≤n fφsica de Θsta:

"Todo aparato, sistema y objeto que forma parte de la realidad que nos rodea,
sufre un desgaste, contiene errores, o lo que es mßs com·n, deja de funcionar,
eso, es entropφa."

En este libro que tengo muy interesante sobre bioinformßtica hay una definici≤n
que nos lleva a los tiempos mßs remotos sobre la frase "el conocimiento es poder",
terminan concluyendo con esta igualdad: 
	
			Informaci≤n = Antientropφa

┐QuΘ hacemos entonces aquφ? ┐Regeneramos la realidad?, quizßs amigos.....

Como verßn el mΘtodo de la compresi≤n sin pΘrdida no produce pΘrdida de 
informaci≤n con lo que su radio de compresi≤n estß destinado a la ocurrencia
de patrones, es decir, a la frecuencia con que se repiten partes del fichero
para que puedan ser "resumidas".

De ahφ que Θste mΘtodo estß limitado por la entropφa, de la informaci≤n, o sea,
depende de la caocidad de Θsta.

Si por ejemplo, queremos comprimir un fichero que contiene:

		abcdefghijklm

No se comprimirφa en lo absoluto, ┐porquΘ?, pues porque no hay ning·n trozo
de informaci≤n repetida.

En cambio, si tenemos un fichero como el siguiente:

		aaaaaabbbbbbcbcbcbaaadddddd

Podrφamos decir que si se comprimirß, ┐porquΘ?, pues porque hay repetici≤n 
de algunos patrones determinados, es decir, algunas letras se repiten, y 
secuencias de las mismas tambiΘn se repiten.

Entonces se cumple lo que explique mßs arriba, el radio de compresi≤n, depende
de la entropφa de la informaci≤n que se desea comprimir.

┐quΘ hacer en este caso?

Este tipo de mΘtodos de compresi≤n, utilizan un diccionario para reemplazar
los patrones que se repiten.

┐QuΘ es un diccionario?

Bueno, justamente es una estructura de datos, creada por el mismo algoritmo
de compresi≤n, la cual servirß para decirle al algoritmo de descompresi≤n, cuantas
veces se repite determinado patr≤n, y donde volverlo a su estado inicial.

Puede especificar, muchas mßs cosas, pero para nuestro ejemplo lo reduciremos
a 1 sφmbolo utilizado para reemplazar un patr≤n determinado, y a que patr≤n
pertenece ese sφmbolo.

Por ejemplo podrφa especificar el radio usado para ese patr≤n, mßscaras de 
compresi≤n usadas, si es una entrada comprimida, etc.
Como muchos pensarßn se puede volver a comprimir utilizando el mismo diccionario
una y otra vez, para tratar de producir un fichero mßs peque±o, es una interesante
tΘcnica.

En el diccionario cada sφmbolo es ·nico, o sea, no se puede repetir para otro
patr≤n, si se repite, entonces no sabrß el algoritmo a que c≤digo pertenece
un patr≤n u otro.

En nuestro ejemplo que analizaremos mßs abajo he tratado de simular una compresi≤n
del tipo Lempel-Ziv.
Existen otros tipos de compresi≤n sin pΘrdida como por ejemplo codificaci≤n de 
Huffman y codificaci≤n aritmΘtica.

El mΘtodo de compresi≤n de huffman estß basado en ßrboles, donde cada nodo hacia
la izquierda es un 0 y a la derecha un 1, se clasifican los patrones en distintos
nodos del ßrbol de tal manera que para recuperarlo tenemos un sφmbolo que es
equivalente al recorrido que se debe hacer en el ßrbol para encontrarlo, por ej:

				0010 es igual a CAR

El mΘtodo que analizaremos es el Lempel-Ziv, Θste mΘtodo simplemente, recorre
la informaci≤n a comprimir, en b·squeda de patrones repetidos, utilizando algunas
complejas f≤rmulas estadφsticas del mΘtodo de Shannon.

Dependiendo del resultado de estas estadφsticas, que justamente reflejan la 
entropφa de la informaci≤n a comprimir, los algoritmos tomarßn esos resultados
y actuarßn en base a ellos.

Cada nuevo patr≤n que se repite, es una nueva entrada al diccionario, es se
le es asignado un c≤digo de identificaci≤n, este c≤digo, serß utilizado,
a posteriori, cuando se proceda a la compresi≤n, simplemente, se reemplazan
los patrones por cada sφmbolo equivalente seg·n lo registrado en el diccionario.

Para descomprimir, simplemente se busca en el diccionario por el sφmbolo encontrado
en el texto comprimido y se reemplaza por su patr≤n equivalente.
 
-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 5- Ejemplo paso a paso. ~|====================================
|===========================================================================
 
Paso a explicarles algo, la idea de este ejemplo es que ustedes vean, que pueden
con no mucho esfuerzo crear un algoritmo propio que haga lo que ustedes desean.
Utilizando algoritmos comerciales o freeware, puede ser a veces contraproducente.

┐PorquΘ?, pues porque son de estudio masivo entonces es mßs factible de que 
haya bruteforcers y programas que analicen la informaci≤n comprimida en el 
fichero.

Este ejemplo, como dije antes tiene bugs, es ineficiente, y no funciona siempre,
simplemente es una posible aplicaci≤n y una manera que se me ocurri≤ a mi
personalmente, cuando analicΘ el mΘtodo de Lempel-Ziv.

El mΘtodo original data del a±o 1978, y va generando el diccionario, tomando
en principio la unidad, 1 byte, luego cuando reconoce todos los diferentes
bytes de a 1, sigue con el patr≤n de longitud 2, y asφ agota todas las instancias
con esa longitud, sigue hasta el 3, y asi, hasta terminar con la string a comprimir.

Empezaremos por el principio amigos,he dise±ado el ejemplo con dos MEMO's, uno
tiene la string a comprimir, el otro, darß el resultado luego de la compresi≤n.

La string, que he tomado para probar es: abbaabbaababbaaaabaabba

Analicemos que patrones se repiten, cuantas veces, y que podrφamos hacer mentalmente
al menos para comprimirlo, luego tratarΘ de explicar lo hecho por mφ, tratando
de codificar mis pensamientos.... 

Seg·n el mΘtodo genΘrico tenemos dos unidades a y b, no hay otra letra.

Luego tenemos variaciones con estas dos letras, e inclusive algunas secuencias de letras
repetidas.

Tomando dos letras ahora, miremos que tenemos, empezando desde la izquierda, tenemos
ab, contemos la cantidad de veces que se repite este patron.

a = 13 veces
b = 10  ''
ab = 6  ''

Si tomamos ahora las proximas dos letras, pero, aquφ hay un problema con el que a 
la hora de implementar me enterΘ.
Si tenemos ab, y pasamos a la siguiente patr≤n, algunos tomarßn el que sigue, ba; 
pero nos estamos salteando una combinaci≤n bb, es la combinaci≤n de la segunda letra
de la primer combinacion, con la primer letra de la segunda combinaci≤n. 

Entonces, deberemos ir "pisando" la ·ltima letra de la combinaci≤n anterior para 
poder tomar todas las combinaciones posibles, y luego evaluar cuantas veces se
repite cada una.

Por ej, bb se repite 4 veces tambiΘn, si no hubiΘsemos hecho como les dije
no darφa lo mismo, y quizßs nos perderφamos un buen radio de compresi≤n.

Les mostrarΘ el resultado que di≤ el string anterior comprimido utilizando el
ejemplo que les explicarΘ a continuaci≤n: 

		Original:   		abbaabbaababbaaaabaabba

		Comprimido:		3313aa1a3


A continuaci≤n, mostrarΘ el trozo de c≤digo que hace la clasificaci≤n de cada patr≤n,
para que puedan observar como podrφa hacerse:

procedure TForm1.Button1Click(Sender: TObject);
var
arreglito,mejores:arreglo;
i,j:integer;
begin
       for j:=1 to 255 do
       begin
            mejores[j].patron:='';
            mejores[j].cod:=0;
            mejores[j].cant:=0;
       end;

   for i:=2 to length(memo1.lines.text) div 2 do
   begin
       for j:=1 to 255 do
       begin
            arreglito[j].patron:='';
            arreglito[j].cod:=0;
            arreglito[j].cant:=0;
       end;

      recorrer(arreglito,memo1,i);
      mejorratio(arreglito,mejores,memo1,memo2);
   end;
 comprimir(mejores,memo1,memo2);
end;

Bien, este proceso es el que se ejecuta cuando hacemos click en el bot≤n 
Comprimir, lo primero que hace, es vaciar un array llamado mejores, este 
array almacenarß los patrones que dan mayor radio para comprimir un string
dado.

El array es de registros, con lo que por cada celda tenemos tres campos a 
llenar, el patr≤n, el c≤digo del mismo, y la cantidad de veces que se repite
en la string a comprimir.

No identificamos las letras distintas que hay, ┐porquΘ?, pues porque si 
las identificamos, tenemos que comprimirlas sino malgastaremos espacio
en el diccionario, y ┐que radio de compresi≤n habrß? 1:1, una letra, 1 sφmbolo.

Ahora entonces empezamos con el primer for a recorrer la string a comprimir
desde 2, hasta la longitud de la string dividido dos. ┐porquΘ? , esto se hace
porque no encontraremos en una string de 20 letras 1 patr≤n de 11 letras que 
se repita al menos dos veces, porque esta string deberφa tener al menos 22 letras.

Entonces, analizaremos los patrones que al menos se repitan dos veces, para que
la compresi≤n tenga efecto, sino podrφamos reemplazar cualquier patr≤n por un
sφmbolo pero igualmente en el diccionario irφa definido, asφ que no hay compresi≤n
alguna.

Luego de vaciar el arreglito, que es otro array, copia, de mejores, ejecuta
dos procesos que he creado, uno llamado recorrer, donde lo que hace, es
buscar un determinado patr≤n, en la string, utilizando a i, i es un φndice
que en ese momento vale 2, la primera vez, y definirß la longitud del patr≤n
que deberemos escanear en la string a comprimir.

Arreglito cotendrß todas las posibles combinaciones dadas en el string, con 
la longitud de patr≤n dada en ese momento por el φndice i.

Recorrer contiene:

procedure recorrer(var arr:arreglo;var memo:tmemo;long:integer);
var
i,j,h,l:integer;
tmp:string;
begin
    for j:=1 to length(memo.lines.text) do
    begin
        h:=j;
        tmp:='';
        for i:=1 to long do
        begin
              tmp:=tmp+memo.lines.text[h];
              inc(h);
        end;
        for l:=1 to 255 do
        begin
             if (arr[l].patron = tmp) or(arr[l].patron  = '') then
                break;
        end;

        if (arr[l].patron <> tmp) then
        begin
            arr[l].patron:=tmp;
            arr[l].cod:=j;
            buscar(arr,memo,l);
        end;
    end;
end;

El primer for va desde 1 hasta la long del string, luego, el segundo for lo 
que hace es generar el patr≤n en ese momento dado la longitud, en nuestro
primer caso es 2, entonces hara desde 1 a 2, guardando en tmp, el patr≤n
que extrae de la string guardada en el memo1, el memo1 es pasado como
parßmetro a la variable del proceso memo.

Utilizo h para saber hasta que letra se extrajo, si utilizamos i, siempre
por cada iteraci≤n, sacaremos la primer letra, y no la que le sigue, en el 
string.

Ahora, l es utilizado para recorrer el arreglo y medir su dimensi≤n l≤gica
esto se hace para ubicar un lugar vacφo en el arreglo, y que no sea un
patr≤n existente, sino guardarφamos en el arreglo patrones ya registrados.

Una vez encontrada la dimensi≤n l≤gica, podemos guardar, el nuevo patr≤n,
con un nuevo c≤digo, este c≤digo es asignado por j, j es el φndice del primer
for, que se va incrementando en 1, entonces por cada patr≤n tendremos un 
c≤digo ·nico, como habφamos previsto. :)

Aparece una nueva llamada a otro proceso, llamado buscar veamos que hace:

procedure buscar(var arr:arreglo;var memo:tmemo;j:integer);
var
  i,k,h:integer;
  tmp:string;
begin
    for i:=1 to length(memo.lines.text) do
    begin
          h:=i;
          for k:=h to h+length(arr[j].patron)-1 do
          begin
               tmp:=tmp+ memo.lines.text[k];
               if (arr[j].patron = tmp) then
                    arr[j].cant:=arr[j].cant +1 ;
          end;
          tmp:='';
    end;
end;

╔ste es el algoritmo que hace la b·squeda "pisando" las letras.

Lo mßs importante aquφ es el segundo for, como verßn hace una iteracci≤n
media complicada de calcular a simple vista, esto es debido a que tenemos
que ir corriendonos por el string, entonces he usado una variable h temporal
que toma el valor de i por cada iteracci≤n, donde k se iguala a h entonces
puede seguir a partir del valor 3, en la siguiente iteracci≤n.

En tmp guarda el patr≤n buscado, y lo compara, si es igual, entonces cuenta 1.

Luego si volvemos a la rutina principal, encontraremos la llamada mejorratio.
Este proceso se encarga de elegir, que patrones darßn mejor ratio para luego
comprimir con esos, es una primera selecci≤n, ya luego habrß otra para
aplicar la compresi≤n.

Veamos como funciona:

procedure mejorratio(var arr,arr2:arreglo;var memo,memob:tmemo);
var
  calc,max,i,j:integer;
begin
     i:=1;
     max:=0;
     j:=1;
     while (arr[i].patron <> '') do
     begin
          calc:=(length(arr[i].patron)*arr[i].cant)-arr[i].cant;
          if (calc > max) and (arr[i].cant > 1) then
          begin
              max:=calc;
            while (arr2[j].patron <> '') do
                j:=j+1;
              arr2[j].patron:=arr[i].patron;
              arr2[j].cod:=cont;
              arr2[j].cant:=arr[i].cant;
              inc(cont);
          end;
          i:=i+1;
     end;
end;

Bien como podemos ver, este proceso utiliza dos arreglos, la llamada a este
proceso es asφ:   mejorratio(arreglito,mejores,memo1,memo2);
Con lo que tenemos el primer arreglo con los patrones definidos, escaneados, 
el segundo arreglo contendrß los mejores patrones, que daran mejor radio de
compresi≤n.

La cuenta que realicΘ para dar con el patr≤n que de mejor radio, es el siguiente:

En primera instancia usamos arr que es arreglito, para recorrerlo e ir calculando,
arr2 es el arreglo mejores.

El cßlculo se basa en un principio que me pareci≤ interesante, la longitud del patr≤n
por la cantidad de veces que se repite darß la cantidad de bytes que ocupa ese patr≤n
menos la cantidad de veces que se repite.

Acabo de encontrar un error, el resultado siempre serß igual a la longitud del patr≤n
la cual la chequearemos contra un mßximo, para ver que patr≤n es el que mßs conviene
usar primero, para sacar mßs radio al comprimir.

Luego evaluamos que la cantidad sea mayor a 1, para elegir los que se repiten dos
o mßs veces. DespuΘs recorremos con el while el arreglo mejores para encontrar su
dimensi≤n l≤gica, porque lo ubicaremos dentro de este arreglo ya que es un patr≤n
candidato a comprimir.

Este proceso sirve para hacer una segunda elecci≤n de los mejores patrones, asφ
a la hora de comprimir que es cuando se hace la llamada:

		 comprimir(mejores,memo1,memo2);

nos aseguramos de obtener el mejor radio posible.

El proceso que analizaremos y con Θsto termina mi humilde algoritmo:

procedure comprimir(var mejores:arreglo;var memo,memob:tmemo);
var
  j,i:integer;
  primer:boolean;
begin
    primer:=true;
    i:=1;
    while (mejores[i].patron <>'') do inc(i);
    dec(i);
    //para ver cual patron conviene mas
    j:=0;
    conveniencia(mejores,i,j,memo);

    while (mejores[i].patron <>  '') and (i >= 1) do
    begin
        if (primer) then
        begin
            memob.lines.text:=memo.Lines.text;
            memob.Lines.Text:=stripped(mejores,j,memob.lines.text);
            inc(i);
            primer:=false
        end
        else
            memob.Lines.Text:=stripped(mejores,i,memob.lines.text);
        dec(i);
    end;
end;

Bueno, comprimir funciona muy sencillo y creo que fue la parte mas fßcil y 
divertida del algoritmo, simplemente hace el reemplazo de los patrones por
los sφmbolos.

Si nos fijamos bien, tenemos otro proceso que hice, para elegir a·n mejor los 
patrones y saber cuales va a usar antes de comprimir, como les conte antes.
Se llama conveniencia, y lo llamamos pasamos el arreglo mejores, pasamos
a el φndice i, que contiene la dimensi≤n l≤gica, a j, que es 0 porque es un valor
devuelto por el proceso donde devuelve el φndice que apunta al patr≤n que mßs
conviente para comprimir.

ExplicarΘ antes el proceso conveniencia:

procedure conveniencia(arr:arreglo;i:integer;var j:integer;memo:tmemo);
var
k:integer;
maxl,r,max:real;
begin
 max:=0;
 maxl:=0;
if (max < 9999) then
 for i:=i downto 1 do
 begin
      k:= (length(memo.lines.text)) - (length(arr[i].patron) * arr[i].cant);
  if (k > 0) then
  begin
      r:=length(memo.lines.text) / k;
   if (r > max) then
   begin
    j:=i;
    max:=r;
   end;
  end
  else
      if (k = 0) and (maxl < length(arr[i].patron)) then
      begin
        max:=9999;
        j:=i;
        maxl:=length(arr[i].patron);
      end;
 end;

end;

Este proceso, funciona por maximos, el cual hago un cßlculo tambiΘn para saber
cual patr≤n es el mßs utilizable.
Calculo K utilizando la long del memo que le paso como parßmetro menos la longitud
del patr≤n multiplicado por la cantidad de veces que se repite el patr≤n.

Esto nos da un φndice que nos dice lo siguiente, tenemos una longitud de un string
que es igual a 20 bytes restada la longitud del patr≤n apuntado por el φndice en ese
momento, que puede ser 4 caracteres por ejemplo, multiplicado por la cantidad de 
veces que se repite ese patr≤n.

Por ej, se repite 4 veces, tendrφamos que ese patr≤n puede comprimir 16 bytes en 4
bytes, ya que cada patr≤n ocupa 4 bytes.
Ahora 20 - 16 es 4 , con lo que preguntamos si k es mayor a 4, y  si lo es, donde luego
calculamos una variable a la que llamΘ r, esta hace una division real, entre la 
longitud del string que es 20 en nuestro ejemplo y el 4 que estß contenido en k.

El resultado es 5, utilicΘ un real, porque a veces las diferencias son menores entre
patrones y repeticiones, eso es chequeado si es mayor a la variable max, significa
que se repite mas veces, entonces obtendremos mejor radio de compresi≤n.

Si el resultado es mejor, entonces se testea si es igual a 0, porque puede ser que 
de justo entonces, estarφamos frente al mejor patr≤n, el cual se repite exactamente
una cantidad de veces, por ejemplo en una string: abababab donde abab se repite 2 
veces.

Y preguntamos tambiΘn si la longitud del patr≤n indicado es mayor que la variable maxl
esto, sirve para saber si es la longitud mßxima de un patr≤n el cual tiene el mejor
radio.

Una vez sucedido esto, max toma el mßximo valor posible, le asignamos el φndice donde
se encuentra el patr≤n, y terminamos.

Por ·ltimo en cuanto a la rutina comprimir nos quedamos en esta parte:

    while (mejores[i].patron <>  '') and (i >= 1) do
    begin
        if (primer) then
        begin
            memob.lines.text:=memo.Lines.text;
            memob.Lines.Text:=stripped(mejores,j,memob.lines.text);
            inc(i);
            primer:=false
        end
        else
            memob.Lines.Text:=stripped(mejores,i,memob.lines.text);
        dec(i);
    end;

Donde iteramos hasta terminar con la dimension l≤gica del arreglo. La primera
vez, utilizamos una variable booleana, la cual llamamos a una funcion de delphi
para sacar el texto utilizando j, el cual apunta al mejor patr≤n, con mejor
radio.

Luego por ·ltimo en la segunda o X vueltas utilizamos i, el cual elije por 
orden seg·n el arreglo mejores.

Bueno, yo habia mostrado el texto original, y el texto comprimido, explicarΘ
el porquΘ del resultado:

		Original:   		abbaabbaababbaaaabaabba

		Comprimido:		3313aa1a3

Como podemos ver, hay cuatro 3, y dos 1. Encontramos el patr≤n abba que se
repite cuatro veces, supongamos que nuestro algoritmo le dio al patr≤n abba
el sφmbolo 3.

		a b b a| a b b a| a b| a b b a| a| a| a b| a |a b b a
		   3   |    3   |  1 |    3   | a| a|  1 | a |   3

El diccionario serφa el siguiente:

				patr≤n   c≤digo   ocurrencias

				 abba	    3          4
				  ab        1	       2

			 
-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 6- Aplicaciones. ~|===========================================
|===========================================================================
 
La aplicaci≤n de mi ejemplo propone solamente compresi≤n con letras, o sea no 
puede haber n·meros en el string, porque sino al utilizar n·meros como sφmbolos
en el diccionario, confundirß los n·meros originales con los del diccionario, no
pudiendo reconocer uno de otros.

Sin embargo, podemos utilizar un caracter especial para n·meros, o una serie
de caracteres especiales para los dφgitos (0..9), de Θsta manera sabremos cuales
son.

Lo interesante, es que hemos comprimido bastante, y el diccionario no se ha
agrandado demasiado, podrφamos no agregar el campo de ocurrencias al diccionario
final, de esta manera nos ahorrarφamos 2 bytes.

El diccionario ocuparß 8 bytes, mßs 9 bytes del texto comprimido, son 17 bytes.
El texto original ocupa 23 bytes, en total, 6 bytes comprimidos. :D

Como podemos ver, un fichero txt con este texto dentro, comprimido con rar nos
darφa algunos miles de bytes, 0 de compresi≤n.... 

Pero bueno, el rar tiene mucha mas tecnologφa, CRC y demßs, que nosotros no, 
eso lo dejaremos para otras versiones, o porquΘ no experimenten ahora ustedes,
ya tienen el conocimiento en sus manos, ya tienen el poder. :)

-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 7- Conclusi≤n. ~|=============================================
|===========================================================================
 
Bueno amigos/as, espero que les haya entretenido lo suficiente este artφculo humilde
que les presento, simplemente a contribuir a la causa, una causa justa, conocimiento
para todos, capacidad de elecci≤n, posibilidad de crear nuevas cosas, nuevas
lφneas de aplicaciones, nuevas ideas.

Lo mßs importante de Θsto, es que ya tienen la base de un mΘtodo interesante, ahora
pueden utilizarlo en una emergencia, para sus propias aplicaciones, o para crear
un nuevo mΘtodo mejor que los actuales, por favor si logran algo, mßnden un mail a
mi casilla de correo, me sentirφa muy orgulloso de haber sido de alguna manera
un cosechador de ideas de las que ahora han florecido. :)

Adjunto el c≤digo en Delphi, no es nada del otro mundo, y el c≤digo es el
mismo que he explicado, espero que les sirva. 

Saludos, y gracias por su tiempo.
	
			"Mi delito es mi inteligencia".

	"There is a crack, a crack for everything, that's how the light gets in..."


								SparK

-----------------------------------------------------------------------------
                   DisidentS Hacker Team 2003 (c).
 
----------------------------------------------------------------------------
                 Mail del Team: disidents@yahoo.es
----------------------------------------------------------------------------
 
                               0
                             X0 0X
                               S

```

</div>
