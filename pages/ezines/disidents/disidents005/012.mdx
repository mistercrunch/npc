---
title: "012"
ezine: "disidents"
---

# 012

**Ezine:** disidents

<div className="ascii-content">

```
[012]_Recuperaci≤n_de_Informaci≤n_Borrada_by_TMaster_-_Disidents_Journal 5_
 
 
                     -+-| DisidentS Hack Journal #5 |-+-
 
 
 
 
 
 
 
 
 
   ______________________________________________________________________
  |                                                                      |
  | -+- Titulo_____: Recuperaci≤n de Informaci≤n Borrada                 |
  | -+- Autor______: TMaster                                             |
  | -+- E-Mail_____: PaulMaster_SPC@HotMail.Com                          |
  | -+- Team_______: DisidentS Argentina - http://disidents-team.cjb.net |
  |______________________________________________________________________|
 
 
 
 
 
"la potencia sin control..no sirve de nada"
>>------------------------------------------------------------------------<<
 
 
 
----------------------------------------------------------------------------
----------------------------------------------------------------------------
 
.==========================================================================.
|===========~ INDICE ~======================================================
|===========================================================================
|=~ 1- Introducci≤n                                                        |
|=~ 2- Source en BASIC                                                     |
|=~ 3- Source en PASCAL                                                    |
|=~ 4- Source en C++                                                       |
|=~ 5- Source en Perl                                                      |
|=~ 6- Explicando el Proceso                                               |
|=~ 7- Conclusi≤n                                                          |
|=~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~=.
======================================================~ INDICE ~============
============================================================================
 
.==========================================================================.
|===========~ 1- Introducci≤n. ~|===========================================
|===========================================================================
 
Este es un peque±o articulo (pero no por ello deja de ser importante) en el
que demostrare como se pueden leer de una manera facil los datos que 
contiene nuestro querido disco rigido, o disquete. Ahora, te preguntaras, ¿y cual es
la joda de eso? si yo leo perfectamente mis archivos...

Pero, la joda esta en que con este metodo se pueden recuperar datos, que
hayan sido borrados anteriormente. Digo datos porque si lo que queremos
recuperar es un binario, podemos, pero corremos el riesgo de enloquecernos
antes de ello. Lo mas facil de recuperar es texto o codigo, porque 
teoricamente sabemos donde empieza y donde termina.

Asi que creias que estabas a salvo porque borraste toda la evidencia..?  
}:o)

Mmmm, no, si yo pude recuperar datos, imaginate alguien que se empeñe en
verdad en sacar esos datos que quedan como basura, te sacaran hasta cosas 
que ni siquiera tienes en el disco.      ;oP.
Creo que la unica manera de evitar o tratar de evitar eso en usando algun
programita de 'borrado seguro'.

Con estos programitas recupere datos hasta de un disquete formateado con el
'formato rapido'.

Lo que hago con el programa, es crear un archivo del tamaño que quiera en
la unidad que quiera, despues lo edito con un editor normal y miro lo que
encontre, es facil y les aseguro que se llevaran sorpresas.

Primero echenle una mirada a los fuentes, y despues explico en teoria que es
lo que pasa, o por lo menos lo que me parece que pasa.

-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 2- Source en BASIC. ~|========================================
|===========================================================================
(Microsoft - QuickBasic V: 4.5)

DIM Archivo AS STRING, LenData AS LONG, File AS INTEGER, Char AS STRING * 1

Archivo = "c:\recover1.txt"          ' Nombre del archivo de salida
File = FREEFILE                      ' Obtengo un manejador de archivos
Char = "*"                           ' Caracter que voy a escribir
LenData = 500000                     ' Tamaño del archivo en bites (-1)
OPEN Archivo FOR BINARY AS #File     ' Abro el archivo en forma binaria
        PUT #File, LenData, Char     ' Escribo el caracter en la pos. 
deseada
CLOSE #File                          ' Cierro el archivo
BEEP                                 ' Sin comentarios...
END                                  ' Y fin del programa.
 
-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 3- Source en PASCAL. ~|=======================================
|===========================================================================
(Borland - Turbo Pascal V: 7.0)
 
Program Recover;

Uses Dos, Crt;

Type
    MisDatos = Record
          Caracter: Char;
    End;

Var
   NombreArchivo : String[80];
   Archivo       : File Of MisDatos;
   LenData       : LongInt;
   Datos         : MisDatos;

Begin
     NombreArchivo := 'C:\Recuperado.TxT';
     LenData := 500000;
     Datos.Caracter := '*';

     Assign(Archivo, NombreArchivo);
     {$I-}
     Reset(Archivo);
     {$I+}
     If (IoResult<>0) Then
     Begin
          ReWrite(Archivo);
          Seek (Archivo, LenData);
          Write(Archivo, Datos);
          Close(Archivo);
     End
     Else
         WriteLn('Ups!, -No se pudo crear el Archivo!-');
End.
 
-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 4- Source en C++. ~|==========================================
|===========================================================================
(Borland - Turbo C++ V: 2.0)

#include &lt;stdio.h>
#include &lt;io.h>

int main(void)
{
	FILE *archivo;
	long lendata = 500000;
	char datos = '*';

	if ((archivo = fopen("C:\\Recuperado.TxT", "wb")) == NULL)
	{
		fprintf(stderr, "\nError al abrir/crear el archivo!");
		exit(1);
	}

	fseek(archivo, (lendata * sizeof(char)), SEEK_SET);
	fwrite(&datos, sizeof(datos), lendata, archivo);
	fclose(archivo);
	return 0;
}
 
-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 5- Source en Perl. ~|=========================================
|===========================================================================
 
#!/usr/bin/perl
$datos= "*";
open ARCHIVO, ">/recuperado.txt";
seek(ARCHIVO, 500000, 0);
print ARCHIVO "$datos";
close ARCHIVO;
print "Operacion terminada...\n";

-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 6- Explicando el Proceso. ~|==================================
|===========================================================================

	Ahora viene la explicacion teorica de esto, a ver si me sale:
    - Bueno, cuando usamos archivos abiertos en modo binario o aleatorio, si
      queremos escribir en el, le debemos decir al sistema operativo (SO) que
      datos queremos escribir, el tamaño de estos, la posicion dentro del
      archivo para los datos y lo mas importante, un handle o apuntador a
      nuestro archivo abierto.
      
	En todos los lenguajes se deben indicar estos datos al SO, pueden
      estar dados de distinta manera, implicitos y otras cosas raras pero
      siempre estaran.

    - Datos a escribir:
        una variable de cualquier tipo (no, no cosas raras como Objects!!).
    - Tamaño de los datos:
        los bits que ocupa la variable a escribir, podria ser algo como
        len(NombreVariable) o sizeof(TipoVariable)
    - Posicion dentro del archivo:
        
	Cuando un archivo es modificado por una operacion de escritura, el SO
        crea un puntero a la posicion actual de donde se escribieron esos
        datos. En principio, cuando se crea el archivo el puntero esta en 0.
        pero al leer o escribir, el puntero se coloca en la posicion de los
        datos leidos mas uno (creo).
        Piensen un poquito, ┐que pasaria si creamos un archivo le decimos al
        SO que escriba un solo caracter '*' en el?
        
	┐Nada raro no?, ya que el puntero de posicion estaba a cero el caracter
        se escribio en el inicio del archivo.
        
	Pero, si ahora le decimos que lo escriba en una posicion distinta de
        cero?, yo pense, el archivo tiene cero bytes, no se puede, dara un
        error o algo de eso porque apuntara a quien sabe que posicion en el
        disco, y entonces Sorpresa!!! no dio error, nadie me dijo nada y el
        archivo se creo de un tamaño igual al del puntero.
        
	Y aun mas Sorpresa!!! porque solo escribe en esa posicion sin tocar
        los datos que hay antes (esos datos son los que nos interesan  :o) ).
       
	 Hay que tener cuidado, si la cantidad de bytes asignados a la 
	posicion del puntero es mayor que el espacio en disco, te dara un error.
        
	Ejemplos de esto:
            seek(Handle, Posicion)  o  fseek(handle, bytes, desde_donde)

    - Handle:

        Al abrir un archivo, el SO crea una referencia a este, un handle o
        puntero que se almacena en una variable (en los lenguajes de prog.).
        Entonces, cuando queremos hacer algo en el archivo 'x' previamente
        abierto, le hacemos referencia a el a travez de su handle, lindo, no?.

        Ejemplos:
            FILE *Handle;
            Open NombreArchivo For Binary as #Handle

    - Despues que se usa un archivo no hay que olvidarse de cerrarlo, ya que
        es ahi cuando el SO 'libera' el archivo y las referencias hacia el
        de la tabla de archivos abiertos.
 
-----------------------------------------------------------------------------
.==========================================================================.
|===========~ 7- Conclusi≤n. ~|=============================================
|===========================================================================

Espero que todo esto les haya servido para algo.

Gracias a todos los que hicieron posible que este articulito exista,
comenzando por mi padre, que es el que me inicio en este fantastico
mundo de la informatica, asi que a el le debo casi todo... y a mi madre
por tenerme y soportarme, asi que nada mas que ¡¡¡¡LOS QUIERO VIEJOS!!!!!.

Se que estos fuentes se pueden mejorar mucho, tienen lineas de mas, como
declaraciones y asignaciones a variables que podrian no estar, pero las
puse asi para mayor legibilidad y que se entienda mas.
 
-----------------------------------------------------------------------------
                   DisidentS Hacker Team 2003 (c).
 
----------------------------------------------------------------------------
                 Mail del Team: disidents@yahoo.es
----------------------------------------------------------------------------
 
                               0
                             X0 0X
                               S

```

</div>
