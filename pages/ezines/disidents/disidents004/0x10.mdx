---
title: "0X10"
ezine: "disidents"
---

# 0X10

**Ezine:** disidents

<div className="ascii-content">

```

                     -+-| DisidentS Hack Journal #4 |-+-





  _____________________________________________________________________
 |                                                                     |
 | -- Titulo_____: Guφa de programaci≤n con ncurses (Parte I)          |
 | -- Autor______: <+CoOL~ShADoW+>                                     |
 | -- Team_______: Disidents Espa±a - http://www.disidents.org         |
 | -- Tema_______: Programacion Linux                                  |
 |_____________________________________________________________________|




.==========================================================================.
|===========~ INDICE ~======================================================
|===========================================================================
|=~ 1.0 Introducci≤n                                                       | 
|=~ 2.0 Funciones principales                                              | 
|=~ 3.0 Salida de texto                                                    |
|=~ 4.0 Ingreso de datos                                                   |
|=~ 5.0 Mßs funciones para divertirte                                      |
|=~ 6.0 Usando men·s                                                       |
|=~ 7.0 Ejemplos                                                           |
|=~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~=.
======================================================~ INDICE ~============
============================================================================



.==========================================================================.
|=======~ 1.0 INTRODUCCION     ~============================================
|===========================================================================


┐QuΘ son las Ncurses?


Digamos que para UNIX existen unas bibliotecas llamadas curses, pues las Nc-
urses (New curses) son un clon de estas pero libre.
Las Ncurses nos permiten la creaci≤n de aplicaciones  grßficas  dentro de la 
consola, claro que no se tendrß la misma calidad que X.
Nos permiten la creaci≤n de multiples ventanas, formularios, men·s, utiliza-
ci≤n de colores (si la terminal los soporta), etc.


Compilaci≤n


Obiamente usaremos el gcc. Para compilar un programa que utilice ncurses de-
berφamos usar: gcc -lcurses archivo.c -o programa

Y en el c≤digo fuente colocaremos:

#include &lt;curses.h>

Muchas distribuciones usan  un enlace  sφmbolico a curses.h  desde ncurses.h
pero es conveniente usar curses.h en nuestro c≤digo.				


curscr y stdscr


Estas  dos son estructuras, stdscr  contiene lo que se ve en la pantalla, es 
decir como si todo fuese una imagen, mientras que curscr contiene la idea de 
como es la pantalla en forma corriente. Estas dos estructuras son necesarias 
por ejemplo para poder refrescar la pantalla.

.==========================================================================.
|=======~ 2.0 FUNCIONES PRINCIPALES  ~======================================
|===========================================================================



Ahora veremos las funciones que mßs o siempre usaremos.

  WINDOW *initscr(void);

Inicia stdscr y curscr, y averigua las capacidades del terminal.
Si en alguna de estas tareas se produce alg·n fallo se de importante  infor-
maci≤n, y se retorna NULL, si tiene exito el valor apunta a stdscr.
Tenemos que recordar que antes de usar cualquier funci≤n de  ncurses hay que 
llamar a initscr (solo una vez al principio).

 SCREEN  *newterm(const  char  *type,  FILE  *outfd,   FILE *infd);

Si  vamos a usar E/S desde mßs de un terminal debemos usar esta funci≤n. Por 
cada terminal se tendrß que llamara.
En caso de que  como  primer  argumento  usemos NULL se usarß $TERM, y en el 
resto de los argumentos como Linux tiene la gran ventaja de tratar todo como
archivos usaremos stdout y stdin.

 SCREEN *set_term(SCREEN *new);

Antes de usar E/S del terminal hay que convertirla en la terminal actual, si 
falla retorna NULL, en caso contratrio retorna la terminal previa.

 int refresh(void);

Con esta funci≤n se obtiene la salida actual a la  terminal, hace una compa-
raci≤n entre  strscr y curscr y  copia las  direrencias a  este  ·ltimo.  Es 
decir refresca  la pantalla, en este  caso se toma por defecto a strscr pero 
se puede apuntar  a cualquier  ventana  con la funci≤n wrefresh, no me voy a
meter en el tema  asφ que si quieres mßs  informacion ya  sabes, man refresh
que son menos de 100 lineas ;)

 int endwin(void);

Esta  funci≤n sale del  modo visual de  las curses,  es decir quedamos en la 
terminal en modo texto, la  ventaja de esta funci≤n es  que no libera la me-
moria que estß  siendo usada, lo que  nos  permitirφa volver con refresh. Si 
falla rerotna ERR si no retorna OK

 void delscreen(SCREEN* sp);

Para  liberar la  memoria de la  estructura SCREEN, debemos  usarla luego de 
endwin cuando estemos con newterm.

Como vamos, tamos con todo que ya tan rßpido pasamos las principales funcio-
nes, pero a·n queda camino.


.==========================================================================.
|=======~ 3.0 SALIDA DE TEXTO  ~============================================
|===========================================================================


Bueno antes p≤dimos crear una ventana, terminarla, restarurarla, y saber sus 
medidas, pero no creo que eso solo sirva de mucho si no sabemos mandar cade-
nas de texto a estas.

 La verdad es que la cosa estß fßcil y seguirß asφ, ya verßs.

 int addch(chtype ch);

Muestra en la pantalla el caracter ch, no hay que precouparse  por  calcular 
la posici≤n del  puntero ya que la  funci≤n los desplaza automaticamente. Si 
ch es un  caracter de  control que  no sea un retorno, una tabulaci≤n, o una 
nueva linea se debe usar la notaci≤n ^X (X es el caracter).

 int waddch(WINDOW *win, chtype ch);

Pues lo mismo que el anterior pero puedes espesificar la ventana.

 int mvaddch(int y, int x, chtype ch);

Mßs de lo mismo pero esta vez podemos desplazar el cursor a donde queramos.

 int mvwaddch(WINDOW *win, int y, int x, chtype ch);

No es muy  difφcil de deducir que esta rutina combina las caracteristicas de 
las 2 que se nombraron anterirormente (ventana y mover el cursor).

 int echochar(chtype ch);

Es una llamada a addch seguida de una a refresh esto permite obtener una me-
jor performance cuando se trabaja sin caracteres de control.

 int wechochar(WINDOW *win, chtype ch);

waddch seguida de wrefresh no me hagan escrbir pa na :P
Todas estas rutinas que nombrΘ retornan ERR si hay alg·n error o OK si  todo
 sale bien.

 int insch(chtype ch);

Inserta el caracter ch antes del cursor, todo lo que estΘ depuΘs  de este se
corre un espacio a la derecha (como nos facilitan la vida no?).

 int winsch(WINDOW *win, chtype ch);
 int mvinsch(int y, int x, chtype ch);
 int mvwinsch(WINDOW *win, int y, int x, chtype ch);

A estas  alturas ya debemos adivinar para que sirven por su nomenclatura asφ 
que no los describirΘ.
 Si fallan retornan ERR si no OK.

 int printw(char *fmt [, arg] ...);

Es como printf pero la usamos cuando estemos con ncurses asφ que no hay nada
que explicar.

 int wprintw(WINDOW *win, char *fmt [, arg] ...);
 int mvprintw(int y, int x, char *fmt [, arg] ...);
 int mvwprintw(WINDOW *win, int y, int x, char *fmt [, arg] ...);

Tampoco hay que ser un genio para saber su funcionamiento. TambiΘn  retornan
ERR o OK.

 int addchstr(const chtype *chstr);

Copia chstr a la estructura de la imagen de la ventana y  luegov la posici≤n 
actual del cursor.

 int addchnstr(const chtype *chstr, int n);

Lo mismo que la  anterior  pero se elige  la cantidad  de  bytes a copiar si 
n = -1 se copia toda la cadena.
Entonces ya podemos deducir las demas:

 int waddchstr(WINDOW *win, const chtype *chstr);
 int waddchnstr(WINDOW *win, const chtype *chstr, int n);
 int mvaddchstr(int y, int x, const chtype *chstr);
 int mvaddchnstr(int y, int x, const chtype *chstr, int n);
 int mvwaddchstr(WINDOW *win, int y, int x, const chtype *chstr);
 int mvwaddchnstr(WINDOW *win, int y, int x, const chtype *chstr, int n);

A excepci≤n de waddchnstr, todas  son macros, son mßs rßpidas pero no proce-
san caracteres como  los  de retorno  de  carro, nueva linea o retorno y  no 
avanzan el cursor; si una cadena es muy larga  para entrar en una linea esta
es truncada. Yo prefiero printw pero hay que mostrar las alternativas.
Como ya es com·n retornan ERR o OK.


.==========================================================================.
|=======~ 4.0 INGRESO DE DATOS   ~==========================================
|===========================================================================


Ahora toca una de la parte mßs importante, la que sin ella  nuestro programa
no tendrφa  casi ninguna  interacci≤n  con el  ususario, sin  mßs palabrerφo 
vamos a ver algunas funciones ;)

 int getch(void);

Retorna el caracter tecleado o ERR  si falla, manda el eco o  no dependiendo 
de si estß habilitada en la terminal.
Para manejar esto necesitamos estas dos funciones:

  int echo(void);
  int noecho(void);

Se deben llamar antes del  getch, echo (eco) permite  que el  texto se envφe
a la ventana, y noecho para el caso contrario.
Esto  es ·til por ejemplo si queremos hacer un  programa que use contrase±as 
y no  queremos que se  vean, pero hay otro  problema; el modo de  entrada de 
caracteres que se estΘ  usando. Cuando comienzan  las ncurses el modo en que 
se procesa la entrada de caracteres es haciendo que el kernel los envφe a un
buffer hasta que llegue  uno de  nueva linea (un enter) y  ahφ los envφa to-
dos, esto en mi  opini≤n son dos desventajas, la primera es que  es bastante 
inc≤modo, y la  segunda  es que  si  trabajamos  con  un  programa  que  use 
passwords no es muy lindo que se  valla todo para  un buffer (sin encriptar) 
ya que dumpeando esa zona se podrφa obtener per nah no hablo mßs.

Para solucionar esto usaremos:

 int cbreak(void);
 int nocbreak(void);

Con  cbreak solucionamos el  problema ya que nos pone en un modo que los ca-
racteres  no son llevados a ning·n buffer (ni son procesados lo que nos da a 
nosotros el control ya que nos llega como lo mandamos para que  nuestro pro-
pio programa procese lo que quiera), es  decir cada caracter que se tipea es 
enviado  sin  la  necesidad de  ingresar un  caracter de  nueva linea. Y con 
nocbreak pues lo dejamos en el modo feo de antes :P.

Espero  no  haber explicado  esto mal, les  recomiendo  leer los manuales de 
getch (donde encontrarßn algunas otras funciones) y de cbreak, donde tambiΘn 
se explica los modos de delay, no delay y medio-delay que yo no expliquΘ.



.==========================================================================.
|=======~ 5.0 MAS FUNCIONES PARA DIVERTIRTE   ~=============================
|===========================================================================


 void getmaxyx(WINDOW *win, int y, int x);

Esta  macro guarda en dos variables de tipo entero el altura y la ancho (fi-
las y columnas) de la ventana espesificada en el primer argumento.
Es ·til para  cuando se quiere redimensionar una ventana y  luego volverla a 
la normalidad.

 int bkgd(const chtype ch);

Establece la propiedades del  fondo de  una ventana. Por ejemplo para que la 
salida fuese en negrita serφa bkgd(A_BOLD), para ver los posibles  atributos 
de video lee el man curs_attr (si eres curioso busca en curses.h) y para mßs 
informaci≤n man bkgd (recomiendo una leida).

De todos modos copio los atributos definidos en curses.h:

/* attributes */

#define NCURSES_BITS(mask,shift) ((mask) << ((shift) + 8))

#define A_NORMAL	0L
#define A_ATTRIBUTES	NCURSES_BITS(~(1UL - 1UL),0)
#define A_CHARTEXT	(NCURSES_BITS(1UL,0) - 1UL)
#define A_COLOR		NCURSES_BITS(((1UL) << 8) - 1UL,0)
#define A_STANDOUT	NCURSES_BITS(1UL,8)
#define A_UNDERLINE	NCURSES_BITS(1UL,9)
#define A_REVERSE	NCURSES_BITS(1UL,10)
#define A_BLINK		NCURSES_BITS(1UL,11)
#define A_DIM		NCURSES_BITS(1UL,12)
#define A_BOLD		NCURSES_BITS(1UL,13)
#define A_ALTCHARSET	NCURSES_BITS(1UL,14)
#define A_INVIS		NCURSES_BITS(1UL,15)


 chtype getbkgd(WINDOW *win);

Obtiene el estado del fondo de una ventana. Para mßs informaci≤n leer el ma-
nual que dije anteriormente.

int border(chtype ls, chtype rs, chtype ts, chtype bs, chtype tl, chtype tr, 
           chtype bl, chtype br);
 
Dibuja un borde a la ventana.
Los argumentos son:
ls	costado izquierdo
rs	costado derecho
ts	lado superiror
bs	lado inferior
tl	superior-izquierda
tr	superior-derecha
bl	inferior-izquierda
br	inferior-derecha

Pero hay una macro que simplifica la tarea:

 int box(WINDOW *win, chtype verch, chtype horch);

Mucho mßs fßcil, por ejemplo con box(stdscr,ACS_VLINE,ASC_HLINE) hemos hecho
lo   mismo  que  con   border(ACS_VLINE,  ACS_VLINE,  ACS_HLINE,  ACS_HLINE, 
ACS_ULCORNER, ACS_URCORNER, ACS_LLCORNER, ACS_LRCORNER);
Si se usa 0 son esos por defecto. Si  nos damos cuenta  la funci≤n verdadera 
es wborder solo que border es lo mismo pero a stdscr.
NOTA: puedes averte dado cuenta que en Θstas ultimas  funciones los argumen-
tos son chtype, pero en los ejemplos he  usado constantes  de las ncurses lo 
que pasa es que esas constantes son caracteres que las ncurses los usan para
 lineas, estilos, etc.

/* VT100 symbols begin here */
#define ACS_ULCORNER	(acs_map['l'])	/* upper left corner */
#define ACS_LLCORNER	(acs_map['m'])	/* lower left corner */
#define ACS_URCORNER	(acs_map['k'])	/* upper right corner */
#define ACS_LRCORNER	(acs_map['j'])	/* lower right corner */
#define ACS_LTEE		(acs_map['t'])	/* tee pointing right */
#define ACS_RTEE		(acs_map['u'])	/* tee pointing left */
#define ACS_BTEE		(acs_map['v'])	/* tee pointing up */
#define ACS_TTEE		(acs_map['w'])	/* tee pointing down */
#define ACS_HLINE	(acs_map['q'])	/* horizontal line */
#define ACS_VLINE	(acs_map['x'])	/* vertical line */
#define ACS_PLUS		(acs_map['n'])	/* large plus or crossover */
#define ACS_S1		(acs_map['o'])	/* scan line 1 */
#define ACS_S9		(acs_map['s'])	/* scan line 9 */
#define ACS_DIAMOND	(acs_map['`'])	/* diamond */
#define ACS_CKBOARD	(acs_map['a'])	/* checker board (stipple) */
#define ACS_DEGREE	(acs_map['f'])	/* degree symbol */
#define ACS_PLMINUS	(acs_map['g'])	/* plus/minus */
#define ACS_BULLET	(acs_map['~'])	/* bullet */
/* Teletype 5410v1 symbols begin here */
#define ACS_LARROW	(acs_map[','])	/* arrow pointing left */
#define ACS_RARROW	(acs_map['+'])	/* arrow pointing right */
#define ACS_DARROW	(acs_map['.'])	/* arrow pointing down */
#define ACS_UARROW	(acs_map['-'])	/* arrow pointing up */
#define ACS_BOARD	(acs_map['h'])	/* board of squares */
#define ACS_LANTERN	(acs_map['i'])	/* lantern symbol */
#define ACS_BLOCK	(acs_map['0'])	/* solid square block */
/*
 * These aren't documented, but a lot of System Vs have them anyway
 * (you can spot pprryyzz{{||}} in a lot of AT&T terminfo strings).
 * The ACS_names may not match AT&T's, our source didn't know them.
 */
#define ACS_S3		(acs_map['p'])	/* scan line 3 */
#define ACS_S7		(acs_map['r'])	/* scan line 7 */
#define ACS_LEQUAL	(acs_map['y'])	/* less/equal */
#define ACS_GEQUAL	(acs_map['z'])	/* greater/equal */
#define ACS_PI		(acs_map['{'])	/* Pi */
#define ACS_NEQUAL	(acs_map['|'])	/* not equal */
#define ACS_STERLING	(acs_map['}'])	/* UK pound sign */

Creo que ahora si se entiende ;)
Pueden usar  las constates, o acs_map['letra'], yo uso las constantes porque
son mßs fßciles de recordar.

 int hline(chtype ch, int n);
 int whline(WINDOW *win, chtype ch, int n);
 mvhline(int y, int x, chtype ch, int n);
 mvwhline(WINDOW *, int y, int x, chtype ch, int n)

Dibuja  en foma horizontal el caracter ch (usar ACS_HLINE)  y su longitud es
n. TambiΘn estßn sus variantes para ventanas y posici≤n.

 int vline(chtype ch, int n);
 int wvline(WINDOW *win, chtype ch, int n);
 int mvvline(int y, int x, chtype ch, int n);
 int mvwvline(WINDOW *, int y, int x, chtype ch, int n);

Lo mismo pero vertical.
Con hline se dibuja de izquierda a derecha  y con vline de arriba hacia aba-
jo, no  cambian la  posici≤n del cursor. Como vimos  estas funciones  no son
impresindibles  ya  que  p≤driamos crear  algunas que hicieran  lo mismo con
unas pocas lineas de c≤digo. 

 int clear(void)

Borra la pantalla, como estas funciones no tiene mucha ciencia solo digo que
 si quieren ver todo el conjunto estß bien documentado en curs_clear.

 int putwin(WINDOW *win, FILE *filep);

Guarda toda la informaci≤n asociada a win en el archivo al que apunta filep.

 WINDOW *getwin(FILE *filep);

Lee la informaci≤n  de un  archivo  (creado con putwin) y crea  la ventana y 
retorna  el puntero  a  la ventana. Recomiendo ver  tambiΘn  las  rutinas de 
dumpeado en scr_dump. 



.==========================================================================.
|=======~ 6.0 USANDO MENUS   ~==============================================
|===========================================================================


Primero que nada para poder  usar los men·s  se necesita incluir el  archivo 
menu.h. Asφ que en nuestro c≤digo quedarφa:

#include &lt;curses.h>
#include &lt;menu.h>
Y con el gcc usarφamos: /gcc -lmenu -lcurses archivo.c -o programa.

Los pasos para crear y mostrar un men· serφan:

1	initscr
2	new_item
3	new_menu
4	set_menu_format (opcional)
5	post_menu
6	refresh

Y para terminarlo:

1	unpost_menu
2	free_menu
3	free_item
4	delwin

 MENU *new_menu(ITEM **items);

Crea un nuevo men·. Si falla retorna NULL.

 int free_menu(MENU *menu);

Desconecta el men· y libera la memoria asignada. Puede retornar los  siguen-
tes valores: Si no hay ning·n error E_OK en  caso contrario, E_SYSTEM_ERROR,
E_BAD_ARGUMENT, o E_POSTED.

 int post_menu(MENU *menu);

Muestra el men·.

 int unpost_menu(MENU *menu);

Lo borra.
Estas dos funciones retornan E_OK  si todo  sale bien y en  caso  contrario: 
E_SYSTEM_ERROR,   E_BAD_ARGUMENT,    E_POSTED,    E_BAD_STATE,    E_NO_ROOM, 
E_NOT_POSTED,  E_NOT_CONNECTED. Para  ver  el  significado de estos mensajes 
/man post_menu.

  ITEM *new_item(const char *name, const char *description);

Crea un nuevo φtem del men·, si hay alg·n error retorna NULL.

 int free_item(ITEM *item);

Libera la memoria asignada a ese φtem. Retorna E_OK si todo  sale bien y  en 
caso contrario da: E_SYSTEM_ERROR, E_BAD_ARGUMENT o E_CONNECTED.
 
 int menu_driver(MENU *menu, int c)

Se debe  usar luego del que men· sea mostrado, permite desplazarse entre los
φtems. En c le decimos que hacer, agunos de los argumentos son: 

 REQ_LEFT_ITEM		Se mueve a la izquierda
 REQ_RIGHT_ITEM		Se mueve a la derecha
 REQ_UP_ITEM		Hacia arriba
 REQ_DOWN_ITEM		Hacia abajo
 REQ_FIRST_ITEM		Va al primer φtem
 REQ_LAST_ITEM		Va al ·ltimo φtem

TambiΘn existe uno para las entradas del rat≤n  llamado  KEY_MOUSE, pero  no 
explicarΘ su comportamiento. Si todo sale bien retorna E_OK de lo contrario: 
E_SYSTEM_ERROR,E_BAD_ARGUMENT, E_BAD_STATE, E_NOT_POSTED, E_UNKNOWN_COMMAND, 
E_NO_MATCH, E_REQUEST_DENIED. Para  obtener mßs infomaci≤n lee  el manual de 
menu_driver.

 int set_menu_format(MENU *menu, int rows, int cols);

Establece el tama±o del men·, por filas y columnas. Por defecto son 16 filas
y una columna. Los valores que retorna son: E_OK si no hay errores  y si los 
hay retorna E_SYSTEM_ERROR, E_BAD_ARGUMENT, o E_POSTED.

.==========================================================================.
|=======~ 7.0 EJEMPLOS   ~==================================================
|===========================================================================


Ejemplo de ingreso y salida de datos:

/* Este programa tecles  la tecla que se a va escribiendo "que rßpido"  este 
mΘtodo se usa en muchas pelφculas para  hacer creer que la persona realmente 
escribe a gran velocidad pero en realidad  ta tecleando cualquier cosa :P */

#include &lt;curses.h>
#include &lt;stdlib.h>

int main() {
int contador = 1 ;

if ((initscr()) == NULL) {			/*	           */
    perror("initscr") ;				/* Inicio ncurses   */
    exit(EXIT_FAILURE) ;			/*	           */
}

noecho() ;				/* Para que no salga en pantalla lo que se escribe */

keypad(stdscr, TRUE) ;			/* Habilito entrada de rat≤n y tecaldo */

while(getch() != 'q') {			/* Mientras no se precione "q" no se saldrß del programa */
    switch(contador) {
      case 1:
          addch('q') ; contador++ ; break;	/* Se va mostrando de char en char y se incrementa el valor de contador */
      case 2:
          addch('u') ; contador++ ; break;
      case 3:
          addch('e') ; contador++ ; break;
      case 4:
          addch(' ') ; contador++ ; break;
      case 5:
          addch('r') ; contador++ ; break;
      case 6:
          addch('ß') ; contador++ ; break;
      case 7:
          addch('p') ; contador++ ; break;
      case 8:
          addch('i') ; contador++ ; break;
      case 9:
          addch('d') ; contador++ ; break;
      case 10:
          addch('o') ; contador++ ; break;
      default:
          clear() ; contador = 1 ;		/* cuando se termina el mensaje borro la pantalla y reinicio el contador */
    }
    refresh() ;				/* refresco la pantalla */
}

endwin() ;				/* termino la pantalla */
exit(0) ;				/* y termino el programa */
}


Ejemplo de men·s:

/* Para este  ejemplo me basΘ  en el  del libro "Programaci≤n  en linux  con 
ejemplos" , ya que  estuve  probando  otros mΘtodos  pero con ninguno mejorΘ 
este, espero que no sea tratado como un plagio */

#include &lt;stdlib.h>
#include &lt;curses.h>
#include &lt;menu.h>

int main()
{
static const char *opciones[] = { "uno", "dos", "tres" , "Salir" , NULL } ;	/* Array de cadenas con los items */
const char **popciones ;
int cascii , *itemsel ;
ITEM *items[sizeof(opciones)];
ITEM **pitems = items ;
MENU *un_menu ;

if ((initscr()) == NULL) {						/*	           */
   perror("initscr") ;							/* Inicio ncurses   */
   exit(EXIT_FAILURE) ;						        /*	           */
}

noecho();                                                               /* Para que no salgan las letras que presionamos */

keypad(stdscr, TRUE) ;	/* Habilito las entradas de teclado y rat≤n */

for ( popciones = opciones; *popciones; popciones++ ) *pitems++ = new_item(*popciones, "");	/* Recorro el array para                                                                                                 agregar los items */
     *pitems = NULL ;
     un_menu = new_menu(items) ;		/* Creo el men· */
     set_menu_format(un_menu, 1 , 4) ;	/* Columnas y filas del men· */
     post_menu(un_menu) ;		/* Lo muestro */
     while ((cascii = getch()) != 'q' ) {			/* Este loop termina cuando el usario presione q terminando                                                                 el programa */
        if (cascii == KEY_DOWN || cascii == KEY_RIGHT ) { menu_driver(un_menu, REQ_RIGHT_ITEM) ; }    /* Cambia la                                                                                                                 selecci≤n de un item */                                                              
        else if (cascii == KEY_UP || cascii == KEY_LEFT ) { menu_driver(un_menu, REQ_LEFT_ITEM) ; }	/* de acuerdo a las                                                                                                         teclas   */
        else {	/* Si se presiona cualquier tecla que no sea q o las flechas de deplazamiento */
           itemsel = current_item(un_menu) ;
           if (*itemsel == "uno") { printw("opci≤n 1\n") ; }
           if (*itemsel == "dos") { printw("opci≤n 2\n") ; }	 /*  Comprueba que   */
           if (*itemsel == "tres") { printw("opci≤n 3\n") ; }	 /* item se selecion≤  */
           if (*itemsel == "Salir") { goto salir ; }
       }
    }

    salir:
       unpost_menu(un_menu) ;	/* Quito el men· */
       free_menu(un_menu) ;	/* Libero la memoria del men· */
       for ( pitems = items; *pitems; pitems++ ) free_item(*pitems) ; /* Libero la memoria de cada item */
       keypad(stdscr, FALSE) ;	/* Desabilito las entradas de teclado y rat≤n */
       endwin() ; 		/* Termino la ventana */
       exit(0) ;
}



Con esto termina la primera parte del curso, en la segunda entrega veremos como 
usar el rat≤n, usar colores, formularios, y crear sub-ventanas.

Hasta la pr≤xima ;)

```

</div>
