---
title: "criptogr"
ezine: "dtoc"
---

# criptogr

**Ezine:** dtoc

<div className="ascii-content">

```

CRIPTOLOGíA
===========

Unas definiciones básicas:

. Criptografía: ciencia y arte de escribir para que sea indescifrable el
contenido del texto escrito, para quien no posea la clave.

. Cifrado: proceso de transformación del texto original en el texto cifrado.

. Descifrado: proceso de transformación del texto cifrado en el texto original.

. Clave: parámetros que controlan los procesos de cifrado y descifrado.

        NOTA: una clave no es simplemente una palabra, pueden ser dos números
        primos, números + operaciones, etc.

. Criptoanálisis: ciencia que estudia los métodos de descubrir la clave, a
partir de los textos cifrados, o de inserción de textos cifrados falsos válidos
para el receptor, u otros métodos (más tarde veremos).

. Criptología: conocimiento que engloba la criptografía y el criptoanálisis.
¿Mas (S/n/=)? 
Preámbulo, a modo de esquema:

* Sistema criptográfico CLASICO (no incluye sistema clave pública):

5 componentes:

   M: conjunto de TODOS los mensajes posibles a transmitir.

      NOTA: *NO* se refiere a todos los textos que se pueden construir con
      el alfabeto que usemos. Se refiere a todos los mensajes susceptibles
      de ser enviados. Por ejemplo, si NUNCA enviaremos un mensaje que diga
      "hoy llueve en Madagascar", pues dicho mensaje NO pertenece a M. ¿Ok?

   C: conjunto de TODOS los mensajes cifrados.

   K: conjunto de TODAS las claves posibles a usar.

   E: conjunto de TODOS los métodos de cifrado E={Ek/M->C para toda kεK}

   D: ídem con descifrar D={Dk/C->M para toda kεK}


Todo criptosistema debe cumplir:

   1. Todas las transformaciones Ek y Dk deben ser "fácilmente" calculables.
   (No puedes tardar 3 horas en cifrar un texto de 1000 letras).

   2. Los algoritmos de Ek y Dk deben ser fácilmente implementables.
   (Para ir rápidos el cifrado se hace por hard mejor que por soft).

   3. LA SEGURIDAD DEL SISTEMA SóLO DEBE DEPENDER DEL SECRETO DE LAS CLAVES kεK
   Y NO DE LOS ALGORITMOS DE LAS TRANSFORMACIONES E y D.

* Ataques destinados a descubrir la clave secreta:

   . Sólo con texto cifrado: el criptoanalista conoce todos los mensajes
   cifrados (tiene la línea pinchada y ve circular los mensajes cifrados).

   . Con texto original conocido: conoce todas las parejas de texto
   cifrado/descifrado que han circulado hasta el momento.

   . Con texto original escogido: puede obtener el texto cifrado a cualquier
   original que ÉL escoja (si conoce el de cualquier, aunque no lo escoja él,
   ya no necesita saber la clave, jeje).

   . Con texto cifrado escogido: viceversa de la anterior.

Normalmente se diseñan los S.C. de manera que resistan los ataques de los
puntos 1 y 3, que son los que dan "más información" al c.a.

* SECRETO: el criptoanalista es incapaz de determinar el texto original a
partir del texto cifrado que haya podido interceptar. Es decir, el c.a. chupa
un mensaje cifrado, y es incapaz de descifrarlo. Exige:

   1. el c.a. no debe poder determinar (computacionalmente hablando) la
   transformación Dk (NO CONFUNDIR Dk con D!! D es el método, lo conoce, lo que
   no conoce es método+clave, le falta la clave!!) a partir del mensaje cifrado
   c, aun conociendo el mensaje original m.

   2. el c.a. no debe poder determinar el mensaje original m, sistemáticamente,
   a partir de la sola intercepción del mensaje cifrado c.

Resumiendo => El SECRETO requiere, únicamente, no revelar Dk, mientras que Ek
puede ser pública. (Si Ek es pública el sistema se llama sistema de clave
pública, y si Ek secreta -NOTA de nuevo, Ek secreta, no E, E y D son siempre
públicos, los métodos!!- el sistema es de clave secreta o sistema criptográfico
clásico).

* AUTENTICIDAD: el c.a. es incapaz de improvisar, o sustituir, un texto cifrado
falso c' en lugar del texto real c sin que el receptor lo detecte. También
tiene dos requerimientos:

   1. el c.a. no debe poder determinar (computacionalmente hablando) la
   transformación Ek (no confundir con E, de nuevo!!) correspondiente a un
   mensaje cifrado c, aun conociendo el original m.
   2. el c.a. no debe poder determinar (computacionalmente) un mensaje cifrado
   c' tal que Dk(c')εM. Es decir, un mensaje que el receptor no detecte como
   extraño.

Resumiendo => La AUTENTICIDAD requiere, únicamente, la no revelación de la
transformación de cifrado Ek, mientras que Dk puede ser pública.
NOTA: NO confundir Dk y Ek con D y E, D y E son los métodos, los algoritmos si
queréis, no la unión del método más la clave!! (entendiendo por clave no sólo
una palabra "password", clave engloba, dependiendo del método, otros factores,
como puede ser una operación o un conjunto de números -por ejemplo 2 primos-
etc.).

* CRIPTOSISTEMAS:

   . Restringidos: mantienen secretos la naturaleza del proceso de cifrado y
   descifrado (es decir, los métodos E y D) ¡¡ESTAN FUERA DE CIRCULACIóN!! No
   se consideran "viables" y el hecho de esconder el método no presupone mayor
   seguridad. Si la seguridad se basa en el secreto del método, es una
   porquería, tarde o temprano se conoce y no necesariamente a través del
   canal, y si no, pues ¿para qué esconderlo? :)

   . Clave privada: la clave es secreta (el conjunto de claves K debe ser muy
   extenso para evitar la búsqueda exhaustiva, por ejemplo, si las claves son
   de 3 símbolos, simplemente con V26,3+V26,2*V26,1=26*25*24+26*25+26=16276
   pruebas considerando el alfabeto de 26 letras, o con 16646400 pruebas
   considerando el alfabeto ASCII extendido -256 símbolos- listos).

   . Clave pública: la clave de descifrado es secreta, no así la de cifrado. 
   Y es computacionalmente imposible encontrar Dk a partir de Ek.
   
   . Cuánticos
   
   . Probabilísticos

* Comunicaciones (desde un punto de vista criptológico):
   
   . Privadas: no pueden haber intromisiones. IMPOSIBLE! Por eso las hacemos
   seguras!!

   . Secretas: cuando los espías pasivos no pueden obtener ninguna información
   de los mensajes interceptados.

   . Identificables: el emisor puede demostrar al receptor su identidad, pero
   el receptor no puede tener la certeza que no miente.

   . Auténticas: el receptor está convencido que la comunicación -el mensaje-
   proviene del emisor supuesto (presupone identificabilidad, claro).

   . Seguras: cuando la clave no es vulnerable:

   . Condicional: los métodos son seguros hasta que el c.a. disponga de
     mejores y más eficientes medios (por ej. el DES).

   . Incondicional: cuando es absolutamente imposible obtener la clave.

   . Probable: cuando no se puede demostrar que el sistema ha sido vulnerado
     (por ej. el DES).

   . Computacionalmente demostrable: cuando el sistema se basa en la
      complejidad de los cálculos para obtener la clave (por ej. el RSA).

   La seguridad se basa no en el sistema criptográfico en sí, que generalmente
   se hace público, sino en la clave (sistemas de clave privada) o en la
   complejidad del cálculo (sistemas de clave pública).

TEORíA DE LA SEGURIDAD PERFECTA (Shannon)
===============================

. Seguridad teórica: un sistema criptográfico cumple los requisitos de
seguridad teórica si es irrompible, aun cuando el criptoanalista disponga de
tiempo y recursos ilimitados.

. Seguridad práctica: ídem pero suponiendo que el criptoanalista dispone de una
cantidad limitada de tiempo y de recursos.

Nota: irrompible = ningún ataque criptoanalítico es eficiente para encontrar
la clave.

NOTA: hoy en día ningún sistema cumple los requisitos de la seguridad teórica,
exceptuando aquél en que la longitud de la clave es la misma o superior a la
del mensaje y sólo se utiliza UNA vez.

* Propiedades de los s.c:
   
conj. mensajes originales M, probabilidades p(m) t.q. Σp(m)=1
conj. mens. cifrados C, prob p(c) t.q. Σp(c)=1
conj claves K, prob. p(k) t.q. Σp(k)=1
p(mi/cj) es la probabilidad que mi haya sido enviado sabiendo que
cj ha sido recibido (= cj mensaje cifrado correspondiente a mi).

entonces, SECRETO PERFECTO si y solo si p(M/C)=p(M),
es decir, la interceptación del texto cifrado no da ninguna información al
criptoanalista.

Un criptosistema con textos originales M y criptogramas C es perfectamente
secreto si y sólo si H(M/C)=H(M) donde H(X)=-Σp(X)log(p(X))
│
└> el secreto perfecto existe:

      M, C, K incluidos en F^n con q elementos en F^n
      tenemos q^n claves, escogemos una, hacemos c=m xor k
         => p(m/c)=p(m/(m xor k))=1/q^n
         i como p(m)=1/q^n listos!!

=> COTA FUNDAMENTAL DE SHANNON: en un criptosistema perfectamente secreto se
cumple que H(K)>=H(M)

   Corolario: si los dígitos de la clave K y los del texto original M son
   escogidos de alfabetos con el mismo cardinal, será criptosistema secreto
   si y sólo si long(k)>=long(M)

      (= la longitud de la clave debe ser, como mínimo la misma que la del
      texto a cifrar, i sólo usarse una vez).

TEORIA DE LA AUTENTICIDAD PERFECTA (Simmons)
==================================

Se supone que el criptoanalista puede generar mensajes cifrados falsos
(fraudulentos), y que la clave sólo es usada una vez para formar el criptograma
auténtico.

Entonces, el c.a. puede llevar a término dos tipos de ataques:

  . Ataque de personalización: formar un criptograma c' sin esperar a ver el 
    c. Tendrá éxito si el receptor legal acepta c'.

  . Ataque de sustitución: formar un criptograma fraudulento c' una vez visto
  el auténtico cεC. Tendrá éxito si el receptor acepta c' como auténtico, y
  Dk(c')=m'<>m, siendo m el mensaje original.

* Probabilidad de engaño:

  Sea Pp la probabilidad de éxito del ataque de personalización, y Ps la del
  ataque de sustitución.


  Entonces, la probabilidad de engaño Pe=máx(Pp,Ps)<>0 SIEMPRE!

    Por qué siempre será diferente de cero?

      Existen #M criptogramas c t.q. P(c/k)<>0
      entonces, si escogemos c' para atacar por personalización,
              Pp=#M/#C
          │
          │
         \/
         Una buena protección contra el ataque de personalización
         es #C>>#M

* Cota de Simmons:

  Pp verifica logPp>=-I(C,K)

  donde I(M,C) nos expresa la información que sobre M variable aleatoria nos
  proporciona el conocimiento de la v.a. C, o viceversa: I(X,Y)=H(X)-H(X/Y)=
                                                              =H(Y)-H(Y/X)>=0
  y como Pe=max(Pp,Ps) también verifica logPe>=-I(C,K)

* Autenticidad perfecta:

  Un criptosistema tiene la propiedad de autenticidad perfecta si verifica
  logPe=-I(C,K)

------------------------------------------------------------------------------

-> Consideraciones para el diseño de criptosistemas: (Shannon)

Th(n): cantidad media de trabajo necesario para encontrar la clave del
criptosistema, suponiendo que trabajamos con el mejor de los algoritmos de c.a.
conocidos.

Para maximizar Th(n), Shannon introdujo los conceptos de:

  . Difusión: consiste en expandir la influencia de cada símbolo del texto
  original sobre tantos símbolos del texto cifrado como sean necesarios, para
  evitar un ataque sobre la clave basado en un fraccionamiento del texto
  cifrado.

  Explico: si no se aplica la difusión, dos bloques iguales de texto original,
  una vez cifrados darán como resultado dos bloques iguales de texto cifrado!!
  Si trabajamos a nivel de bit, la difusión más sencilla consiste en hacer un
  xor (porque es invertible con otro xor) con el bit anterior, o por bloques 
  de bits, los 8 bits de salida de t1 con los 8 bits de salida del paso t0
  anterior. (Nota: harán falta, ya sea un bit o una cadena de bits, unos datos
  iniciales para el primer xor, claro).

  . Confusión: consiste en el uso de transformaciones de cifrado que compliquen
  la realización de correlaciones estadísticas entre el texto original y el
  texto cifrado. (Por ejemplo utilizar sustituciones homofónicas, más adelante
  veremos, teniendo en cuenta que por sí solas no ofrecen garantía de
  seguridad).


CRIPTOSISTEMAS DE CLAVE SECRETA (simétricos o de clave única)
===============================

El emisor y el receptor comparten una única clave k => su característica
principal es la existencia de un CANAL SEGURO para transmitir la clave.

(NOTA: aquí aparece la incongruencia de "¿y por qué no mandamos los datos por
el canal seguro?", pero como sois chicos inteligentes ya habréis deducido que
el canal seguro sólo es necesario que exista de vez en cuando, por ejemplo dos
de vosotros os veis de tanto en cuando y aprovecháis para pasaros las claves
-incluso con una sola vez basta- mientras que como vivís en ciudades distintas,
por ejemplo, usáis la Visión cada día, y no es un canal seguro, hehehe...
Bueno, no lo explico "científicamente" porqué ya ha quedado claro así
pachanguero).


1. Basados en transposiciones: consisten en una reordenación de los caracteres
del mensaje cifrado mediante un esquema preestablecido. Ejemplo: escribir el
texto en una matriz, filas y columnas; entonces permutamos filas por columnas
y lo leemos de nuevo. Es decir, simplemente cambiar las letras de orden,
siguiendo unos patrones más o menos complicados.

MUY FáCIL DE ROMPER: las letras tienen el mismo # de apariciones en el mensaje
original que en el cifrado (si hay 70 a's en el original, hay 70 en el cifrado,
etc.)


2. Basados en sustituciones:

2.1. Sustituciones simples: cada letra del alfabeto α es cambiada por otra
letra del alfabeto ß (los dos alfabetos con el mismo cardinal, es decir, hay
tantas letras en α como en ß). Generalmente los dos alfabetos tienen los mismos
caracteres (de la A a la Z por ejemplo, o el ASCII ambos) pero en diferente
orden. La clave es la aplicación carácter-carácter.
Por ejemplo: Julio César usaba dos alfabetos α=(ABCDEFG..Z) y ß=(DEFG...ZABC),
es decir, cambiaba las A's por D's, las B's por E's, etc. Hoy en día lo
escribiríamos como c=m+3 mod 26 donde A=0, B=1, C=2, etc.

2.2. Homofónicos: para evitar su rompimiento por frecuencias de aparición
(estadística, el método anterior es fácilmente rompible con este método, cada
letra en cada idioma tiene una frecuencia de aparición determinada, igual que
los dígrafos -ejemplo "qu" más probable que "lk"- y los trígrafos -más ya no
vale la pena-) se puede asignar un mismo carácter del texto a cifrar a un
conjunto de caracteres, y escoger uno aleatoria o cíclicamente.
Por ejemplo, en lugar de cambiar las "a" por "p" las podemos cambiar por "Γ",
"" o "Σ", y cuando nos llegue uno de estos tres símbolos ya sabremos que es la
"a". Se rompe la estadística pero siguen siendo fácilmente rompibles.

2.3. Polialfabéticos: usamos 'i' alfabetos para cifrar (ßi) i cuando aparece
un símbolo repetido para cifrarlo cambiamos de alfabeto. También son fácilmente
rompibles encontrando el número 'i' de alfabetos usados y después resolviéndolo
como 'i' sustituciones simples.


3. Matriciales: operan sobre bloques de símbolos, dispuestos en forma de tablas
de dimensiones prefijadas.

Método: tenemos una aplicación entre 2 alfabetos: α (caracteres) y ß
(numérico), definimos una matriz cuadrada kxk que será la clave, llena de
números de ß. Ponemos el bloque de texto en una matriz M y hacemos la
aplicación α->ß, entonces multiplicamos Mxk mod (#ß + 1) y deshacemos la
aplicación.

(Si no ha quedado claro ya pondré un ejemplo, decídmelo).

4. Cifrado en flujo: las técnicas vistas hasta ahora, cifrado en bloque, tienen
la desventaja que el texto cifrado correspondiente a dos bloques idénticos, es
idéntico. Para evitar este problema se usan técnicas de encadenamiento entre
los bloques a cifrar, de manera que el cifrado de un bloque dependa de los
bloques que lo preceden (técnica de difusión de Shannon). INTRODUCIMOS EL
CIFRADO A NIVEL DE BITS!!

Nota: el bloque cifrado puede depender del/los bloques precedente/s originales
Y/O cifrados!!
------------------------------------------------------------------------------

Bueno, aquí vendrían las descripciones de los métodos de cifrado DES y PES,
pero es un palazo picarlas (dibujitos, matrices, etc.) todo y ser dos
algoritmos no excesivamente complicados (mejor dicho, facilotes).


CRIPTOSISTEMAS DE CLAVE PúBLICA
===============================

Cada usuario dispone de una transformación de cifrado Ek, registrada en un
fichero público, y de una transformación de descifrado Dk, que sólo él conoce
(no confundir con Ek y Dk con E y D, no es el algoritmo, es la unión de
algoritmo+clave!!).

Dk está descrita en términos de una clave secreta y Ek lo está mediante un
algoritmo o función que no permita, a pesar de su conocimiento y desde un punto
de vista computacional, la revelación de Dk. Por tanto es una transformación
unidireccional (con TRAMPA, porque existe la transformación inversa,
desencriptar!, si se conoce la clave! En el caso del RSA la clave son dos
números primos de 200 dígitos como mínimo, que se dan a conocer multiplicados
entre sí, para poder encriptar, pero como es computacionalmente imposible
factorizar dos primos tan enormes, nadie, salvo quien los conoce, puede
desencriptar... bonito truco, ¿eh?).

En este tipo de sistemas, el secreto y la autenticidad vienen dados por
algoritmos diferentes.

NOTA: a priori la autenticidad no está garantizada, con este algoritmo de
encriptamiento, puesto que CUALQUIERA puede enviar un mensaje encriptado y
hacerse pasar por otro remitente!!.

Una forma de proteger la autenticidad es exigiendo que la pareja de
transformaciones Ek y Dk de cualquier usuario verifiquen, además, que Ek sea
la transformación inversa de Dk (FIRMA DIGITAL!), es decir, que Ek(Dk(m))=m.

Entonces, cualquier usuario puede firmar sus mensajes mediante la

TRANSFORMACIóN SECRETA Dk!!

  . ejemplo: A quiere enviar a B el mensaje m, entonces primero lo firma con
  DkA(m)=s y lo envía a B con EkB(s)=c.

  Cuando B lo recibe lo descifra con DkB(c)=s, para él s es incomprensible, y
  lo autentifica "cifrándolo" con EkA(s)=m y listos!! Como A es el único que
  posee DkA, el mensaje es auténtico.

(A mí este método me gustó mucho)


Veamos un cripstosistema de clave pública:

* RSA:

  La función de cifrado es E(e,n)(x)=x^e mod n

          0&lt;x&lt;n
          0&lt;e<φ(n) y mcd(e,φ(n))=1

  donde n=pq y p,q primeros, diferentes y enooormes (como mínimo 200 cifras
  decimales).

  Nota: para cifrar 'n' es conocida, no así 'p' y 'q', que sólo los conoce el
  que descifra.

  La de descifrado: D(d,n)(y)=y^d mod n donde 'd' es el inverso de 'e'

  La clave k es k={p,q,φ(n),d}

  φ(n) es la función de Euler, y se define como:

      N--->N
      n|-->φ(n)=#{xεN/x&lt;n, x primero con n}

  ejemplo: φ(4)=número de números menores que 4 y primeros con 4: el 1 y el 3,
  φ(4)=2 por lo tanto.

  Nota: si n es primero, φ(n)=n-1, puesto que los n-1 anteriores son primeros
  con n!!

  La fortaleza del método se basa en la imposibilidad de factorizar 'n', es
  decir, quien sabe 'n' no puede encontrar, computacionalmente hablando
  (tardar más de 100 años se considera computacionalmente imposible, por
  ejemplo), 'p' y 'q'.

Firma digital en el RSA:

  E y D son inversas, pero si tanto el usuario A como el B quieren firmar los
  mensajes que se intercambien, llegamos a la conclusión que nA=nB (donde nA 
  es el valor de n para encriptar los mensajes para A y nB el valor de n para
  encriptar los mensajes para B), con lo cual, tanto A como B conocen los
  valores p y q respectivos, pues son los mismos!!

A ver si me da tiempo a incluir también unos breves apuntes sobre FLSR
(hardware específico para "divisiones largas" entre polinomios y que en
criptología se usan para generar secuencias pseudo-aleatorias de bits,
periódicas, y que seguro que cae uno en el examen :>), pero aun no domino el
tema...

Espero que os hayan gustado estos boletines, y perdonad los errores!


```

</div>
