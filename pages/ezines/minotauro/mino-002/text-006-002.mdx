---
title: "TEXT_006"
ezine: "minotauro"
---

# TEXT_006

**Ezine:** minotauro

<div className="ascii-content">

```
Curso de Debug...
-------------------------------------------------------------------------------

	"El DEBUG es una porqueria" diran muchos de ustedes. Y tienen razon,
pues como debugger es un pornoco al lado de otros como el Turbo Debugger o
el ya mucho mas avanzado TD386. Pero el tema es que el DEBUG no es "solo" un
debugger, sino toda una herramienta para la persona que quiere saber y
experimentar en bajo nivel (y en virus). Permite hacer algunas cosas que los
otros no permiten, y ademas da mayor libertad al programa que esta siendo
debugeado. El debug no ha mejorado en nada a traves de las versiones de DOS
(excepto en size), los DEBUG de DOS 3.3, 5.0 y 6.0 eran siempre igual. Pero
la mejor prueba de que es una maSa es que nosotros seguimos pasandonos virus a 
traves de el (via scripts de debug)! Bueh, suficiente introduccion...

 LISTA DE COMANDOS:
 ------------------

 - A : Assemble [address]
	Para ensamblar. La direccion por default en que se empieza es el
	CS:IP inicial.
 - C : Compare [address1] [address2] [range]
	Compara los dos sectores de memoria dentro del rango, y devuelve las
	diferencias. Si no devuelve nada son iguales. Ejemplos:
	-C 100 200 100
	-C 100 600 50
	05DE:0100  B8  F7  05DE:0600
	05DE:0101  00  90  05DE:0601
 - D : Dump [start address] [end address]
	Dumpea (vuelca) memoria a pantalla, a partir del address dado o del
	default, si no se da ningun address. Si no se pone un end address,
	este comando vuelca 80H bytes. Ejemplos:
	-d 100 10F
	05DE:0100 B8 02 00 BA 07 00 CD 21 - B8 00 4C CD 21 90 90 90
	-d
	05DE:0110 90 90 90 90 90 90 90 90 - 90 90 90 90 90 90 90 90
	05DE:0120 90 90 90 90 90 90 90 90 - 90 90 90 90 90 90 90 90
	...
	05DE:0190 90 90 90 90 90 90 90 90 - 90 90 90 90 90 90 90 90
	-d 100 110
	05DE:0100 B8 02 00 BA 07 00 CD 21 - B8 00 4C CD 21 90 90 90
	05DE:0110 90
 - E : Enter [address] [lista]
	Entrar bytes a memoria, a partir del address. Si no se da la lista,
	el DEBUG la pregunta en un prompt. La lista se puede dar en Hex o
	directamente. Dentro de este prompt, '-' va al byte anterior,
	espacio va al siguiente, y enter sale. Ejemplos:
	-e 100 "baba"
	-e 100 b4 4c cd 21
	-e 100
	05DE:0100 B4.00 4C.00 CD.00 21.00-
	05DE:0102 00.FF-
	05DE:0101 00.FF
 - F : Fill [start address] [end address] [string]
	Llenar 80H bytes a partir del address con la string. Si no se da
	end address, se llenan 80H bytes. Ejemplo:
	-f 100 "PIPI"
	-f 100 1000 "TETRACLORURO DE MOLIBDENO"
 - G : Go To [=address] [puntos de ruptura]
	Breakpoint. G=Address produce que se comienze a ejecutar a partir
	de ese address. Luego se da una lista de los offsets en donde poner
	los breakpoints. Pueden ser tantos como se quiera. Ejemplo:
	-g=100 109 205
 - H : Hexadecimal [value1] [value2]
	Aritmetica Hexadecimal. Dados dos valores en Hexa, muestra su suma
	y su resta, tambien en hexa. Ejemplos:
	-h 102 100
	0202 0002
 - I : Input [port]
	Similar a la instruccion assembler IN. El byte entrado es mostrado
	a pantalla. Ejemplos:
	-I 70
	FF
 - L : Load [address] [drive] [first sector] [number]
	Similar a INT 25. Ejemplos:
	-L 200 0 0 1
 - M : Move [range] [address]
	Mueve memoria. Ejemplos:
	-m 100 200 1
 - N : Name [path\name]
	Redefine el nombre del archivo actual, y la lista de argumentos en el
	PSP. Ejemplos:
	-N VIRUS.COM
 - O : Output [port] [byte]
	Similar a la instruccion assembler OUT. Ejemplos:
	-O 70 1
 - P : Proceed [=dirección] [número]
	Proceder a traves del codigo. Si se da 'p=??' se comenzara desde esa
	direccion. 'numero' es el numero de instrucciones a seguir. (si no
	se da, es 1). Notar que con 'P' uno no debuggea INTs o CALLs por
	adentro. (Esa es la diferencia con 'T').
 - Q : Quit
	Sencillamente sale. Todos los cambios hechos en memoria se pierden.
 - R : Register [registro]
	Poniendo 'R' solo muestra el estado actual de los registros, mas la
	orden a la que apunta CS:IP (la proxima orden a ejecutarse). Poniendo
	r[nombre de registro] muestra el valor del registro particular y
	permite que uno cambie este valor.
	No solo se puede entrar AX,BX,CX,DX,SP,BP,SI,DI,DS,ES,CS,SS sino
	ademas IP (RIP), y el registro de las flags (RF)
	Ejemplos:
	-R
	AX=1020 BX=0000 CX=0000 DX=0000 SP=FFEE BP=0000 SI=0000 DI=0000
	DS=31DC ES=31DC SS=31DC CS=31DC IP=0100 NV UP EI PL NZ NA PO NC
	05DE:0100 01060002      ADD [200], AX		   DS:0200=0100
	-RAX
	AX 1020
	:FFFF
	-RIP
	IP 100
	:500
	-RF
	NV UP EI PL NZ NA PO NC - ZR
	-R
	AX=FFFF BX=0000 CX=0000 DX=0000 SP=FFEE BP=0000 SI=0000 DI=0000
	DS=31DC ES=31DC SS=31DC CS=31DC IP=0100 NV UP EI PL ZR NA PO NC
	05DE:0500 B80001        MOV AX, 0100
 - S : Search [start address] [end address] [list .... ]
	Busca entre las dos direcciones la cadena de valores. Debe ser dentro
	del mismo segmento. La cadena puede ser dada en valores Hex o puesta
	directamente. Devuelve las direcciones en que se encontro la cadena
	de bytes. Ejemplos:
	-s ds:100 200 "Ja Je Ji Jo Ju"
	05DE:0190
	-s cs:100 1000 e8 00 00
	05DE:0203
	05DE:0504
 - T : Trace [=address] [value]
	Seguir (paso a paso) la ejecucion del programa. Si se pone T=address,
	el seguimiento comenzara a partir de esa direccion. Si se da un numero
	luego de t, se seguira ese numero de instrucciones. Notar que usando
	't' uno puede debuggear internamente todos los procs (CALLs) y las
	interrupciones.
	-t 2
	(sanata)
	-t=500
	(mas sanata)
 - U : Unassemble [start address] [end address]
	Desensambla a pantalla el codigo en [rango]. El default address en
	que se empieza a desensamblar es CS:IP. Si no se da un address en el
	que parar, DEBUG desensambla de a 20H bytes. El "puntero" se actualiza
	cada vez que se pone este comando, por lo que poniendo dos "u" se
	desensamblan 40H bytes.
	Ejemplo:
	-u 100 110
 - W : Write ds:[address] [drive] [first sector] [number]
	Poniendo 'W' solamente escribe el estado actual de memoria al file
	definido via 'N', usando como size lo contenido en BX.CX. Usando los
	argumentos, es similar a INT 26. Ejemplos:
	-N TEST.COM
	-RCX
	CX 0000
	:100
	-W
	Writing 00100 bytes
	-W 100 0 0 1

Ordenes de EMS:
 - XA : Allocate expanded memory [#pages]
	Reserva memoria expandida. Se debe dar el numero de paginas, y
	devuelve el handler obtenido a pantalla. (Similar a INT 67/AH=43).
	Ejemplo:
	-XA 1
	Handler created = 0001
 - XD : Deallocate Expanded Memory [handler]
	Libera memoria expandida. Se debe dar el handler. (Similar a
	INT 67/AH=45) Ejemplo:
	-XA 1
	Handler created = 0001
	-XD 1
	Handler 0001 deallocated
 - XM : Map Expanded Memory Pages [logical page] [phisical page] [handler]
	Mapear pagina de EMS. (Similar a INT 67/AH=44). Ejemplo:
	-XM 0 0 1
 - XS : Get Expanded Memory State
	Muestra el estado actual de la memoria expandida en pantalla.

	Espero que hayan entendido todo, si no fijense, experimenten un poco. 
El DEBUG puede llegar a ser muy util si se lo sabe usar.
	Por ejemplo: necesitan un .COM para ver si su virus infecta. Van a
molestarse en hacer un .ASM y ensamblarlo? No! Entran al debug, ponen 'a' y
luego "mov ax, 4c00/int 21", luego "rcx/5", y luego 'w'. (Nota: obviamente el
virus no infecta EXE. Sino infectaria el DEBUG. Yo en esos casos copio el
DEBUG.EXE al directorio actual, lo uso y despues lo borro. Uno nunca sabe
adonde puede meterse un bug, y no me cabe terminar con un DEBUG trasheado, o
infectado por mi propio virus :-))
	O sino, estan experimentando con virus de BOOT y quieren ver si
infecto el drive A:. Van a entrar al Disk Editor para esta boludez, y bancarse
que scanee todos los directorios de C:? Jamas! Entrar a DEBUG y hacer un
programa que lea el boot via INT 25? Para que tomarse ese trabajo, si basta
con poner 'L 100 0 0 1'!
	O una tipica: estan haciendo un virus residente, pero el muy marica no 
infecta. Examinan durante sufridas horas el codigo .ASM, pero no encuentran 
nada. Sencillamente no pueden descubrir en que parte de la rutina de la 4B00 
esta el error. Que hacer? Cargar el virus en memoria y debuggear la rutina 
residente del virus con DEBUG! (Esta es una de las cosas que no se puede hacer 
con Turbo Debugger).
	O la ultima: quieren estudiar un virus, pero este utiliza tecnicas
anti-dissasembly. El sourcer (o el que tengan) se queda pagando como un imbecil
cuando trata de desensamblarlo. Que hacer? Desensamblar con DEBUG! Obviamente
no va a quedar con la misma "terminacion" pero eso se puede arreglar con un
poquito de laburo.
	Bueno, basta de ejemplos, ya ven porque DEBUG es un lindo
programita y porque nos sirve a los autores de virus :-). Que lo disfruten!
								    Trurl
```

</div>
