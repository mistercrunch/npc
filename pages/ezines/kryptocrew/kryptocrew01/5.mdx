---
title: "5"
ezine: "kryptocrew"
---

# 5

**Ezine:** kryptocrew

<div className="ascii-content">

```
                                  TCP/IP

                                     ⌐
                       ----------{m|azma}----------


  ------------------------------------------------------------------------




         ----------{Kurze Beschreibung fⁿr den ▄berblick}----------

Dieser Text befasst sich mit dem Thema, wie eine Verbindung zwischen zwei
Rechnern ⁿberhaupt erst entsteht, wie diese funktioniert, und welche
Protokolle und Dienste dazu von N÷ten sind. Erstmal sei gesagt, dass bei
einer Verbindung ⁿber das Internet mit einem Protokollstapel gearbeitet
wird. Der genaue Aufbau und die Unterteilung dieses Stapels in die
verschiedenen Schichten wird weiter unten aufgezeigt. Wird eine Verbindung
aufgebaut, so wird der Stapel Schicht um Schicht erstellt. Kommen die Daten
beim EmpfΣnger an, so werden die Schichten in umgekehrter Richtung wieder
abgebaut, um die entsprechenden Prozesse in Gang zu leiten



             ----------{Aufbau des Protokollstapels}----------

Im folgenden Abschnitt werden jetzt die verschiedenen Schichten(Layers) des
   7-Layer Protokolls, welche heute den ISO/OSI-Standart definiert, etwas
genauer erklΣrt. Die Reihenfolge ist so dargestellt, wie sie beim aussenden
  von Daten aussieht. Beim Zielrechner wird der Stapel von unten nach oben
   gelesen. Ein Layer streift dann nach der Ausfⁿhrung seiner Aufgabe den
  eigenen Header ab, um den Protokollen des nΣchsten Layers die Erledigung
                       seiner Aufgaben zu erm÷glichen


                       Anwendungsschicht: Die Anwendungsschicht
                                          stellt die
                                          Schnittstelle zwischen
                                          den Anwendungen dar,
                                          mit welchen ein
                                          Benutzer Befehle ⁿber
                                          ein Netzwerk sendet
                                          bzw. empfΣngt

                     Darstellungsschicht: In der
                                          Darstellungsschicht
                                          werden je nach System
                                          des anderen Rechners
                                          anwendungsspezifische
                                          Formatierungen
                                          durchgefⁿhrt

                         Sitzungsschicht: Diese Schicht sorgt
                                          dafⁿr, dass
                                          unterbrochene
                                          Verbindungen zwischen
                                          Anwendungen wieder
                                          hergestellt werden und
                                          z.T. auch an genau der
                                          selben Stelle
                                          fortgesetzt werden
                                          k÷nnen, um Datenverlust
                                          zu verhindern

                        Transportschicht: Diese Schicht sorgt fⁿr
                                          die zuverlΣssige
                                          Datenⁿbertragung
                                          zwischen den zwei
                                          Rechnern und dient oft
                                          auch als Schnittstelle
                                          zwischen den
                                          ⁿbergeordneten
                                          Anwedungsschichten und
                                          den untergeordneten
                                          Netzwerkschichten

            Netzwerk-/Verbindungsschicht: In dieser Schicht wird
                                          der optimale Weg
                                          (routing) fⁿr die
                                          ▄bermittlung gesucht.
                                          Das Protokoll kann hier
                                          bereits unabhΣngig von
                                          den ⁿbergeordneten
                                          Schichten gewΣhlt
                                          werden (z.B: IP)

          Verbindungsschicherungsschicht: Diese Schicht hat dafⁿr
                                          zu sorgen, dass keine
                                          Fehlⁿbertragungen
                                          stattfinden und im
                                          Falle einer solchen,
                                          die Daten wieder
                                          hergestellt werden

                  Physikalische Schichte: Diese Schicht ist fⁿr
                                          die Herstellung einer
                                          physikalischen
                                          Verbindung beim
                                          Empfangen bzw.
                                          Aussenden von Daten
                                          verantwortlich


Nachdem wir nun die Aufgaben der einzelnen Schichten kennengelernt haben,
werden wir auf die einzelnen Schichten genauer eingehen, um auch die
verschiedenen Protokolle der jeweiligen Schichten kennen zu lernen. Hier
auf alle Schichten Protokolle wirklich detailiert einzugehen wⁿrde den
Rahmen aber deutlich sprengen. Trotzdem werden die Beschreibungen
ausreichen, um ein recht gutes Wissen ⁿber diesen Protokollstapel zu
erhalten

                ----------{Physikalische Schicht}----------

Diese Bitⁿbertragungsschicht ist fⁿr die Herstellung einer physikalischen
Verbindung zwischen zwei Kommunikationsendpunkten, wie etwa Programmen auf
Rechner A und B verantwortlich. Dazu ben÷tigt sie Kabel, Controller oder
Modulierungsverfahren. Die physikalische Schicht wird in der Regel auch von
der Treibersoftware fⁿr die netzwerkbezogene Hardware reprΣsentiert



                ----------{Datensicherungsschicht}----------

MAC (Media Access Control) ⁿbernimmt in Ethernet wie auch Token Ring die
Zugriffssteuerung fⁿr das jeweils verwendete Medium. Es ist fⁿr die
Adressierung der Netzwerkstationen zustΣndig und ⁿberwacht deren Zustand.
Es gibt daruner drei verschiedene Typen von MAC-Adressen, auf welche wir
aber nicht genauer eingehen werden


LLC (Logical Link Control) ist gegenⁿber MAC unabhΣngig vom jeweiligen
Medium. Es ist also nicht ausschlaggebend, auf welchem Netzwerk es
verwendet wird und bildet einen eigenen Standart. Gerade die Tatsache
dieser FlexibilitΣt macht es fⁿr TCP/IP interessant. Auch von LLC gibt es
gesammthaft drei verschiedene Typen


SNAP (Sub Network Access Protocol) schafft als Erweiterung von LLC die
M÷glichkeit auch Protokolle, welche nicht den ISO-Standarts entsprechen in
Netzwerken zu benutzen. Durch das von LLC verwendete SAP(Service Access
Point) wird die MultiprotokollfΣhigkeit noch stΣrker erweitert

                   ----------{Netzwerkschicht}----------

Hier kommen wir nun also zu einem der Kernpunkte des Themas. Ich werde hier
nur auf IP genauer eingehen und ICMP, ARP sowie RARP nur eher am Rande
beschreiben.


IP (Internet Protocol) bildet zusammen mit dem spΣter erklΣrten TCP das
zentrale Protokollpaar der TCP/IP Architektur. Die Transporteinheit im IP
ist das Datagramm. Sein Aufbau wird in 32 Bit-Bl÷cken dargestellt, wobei
der Header mindestens 20Bytes umfasst. Folgendes wird im Header angegeben:

- "Version": IP-Version (momentan version 4)
- "Packet Length; IHL": Angabe ⁿber die LΣnge des Headers inkl. LΣnge der
(spΣter noch erwΣhnten) "Options"
- "Packet Length; Total Length": GesammtlΣnge des Datagramms, welches
maximal 65535 Bytes gross sein darf
- "Identification": Ein Wert, welcher zur Nummerierung fragmentierter
Datagramme verwendet wird
- "Flags": Hier wird die Fragmentierung an sich gesteuert, falls sie
ⁿberhaupt zum Zuge kommt
- "Fragment Offset": Gibt die Position des fragmentierten Datagramms im
originalen Datagramm an
- "TTL(Time to Live)": Gibt an, nach wieviel Zeit ein Datagramm verfallen
soll (um im Netz kreisenden Datenmⁿll zu verhinden)
- "Protocol": Bestimmt das Protokoll (z.B. UDP) der Transportschicht, an
welches das Datagramm ⁿbergeben wird
- "Header Checksum": Hier werden bei jedem passieren eines Routers die
Werte von TTL, Flags und Flag Offset geΣndert
- "Source IP-Adress": Die Adresse des sendenden Rechners
- "Destination IP-Adress": Die Adresse des Zielrechners
- "Options": Ist nicht unbedingt von N÷ten, kann aber Informationen zu
Raouting, Diagnose und Statistik enthalten


ICMP (Internet Control Message Protocol) ist dafⁿr verantwortlich,
Meldungen (z.B. Fehlermeldungen) zu ⁿbermitteln. Es benutzt zwar IP als
wΣre es selbst ein ⁿbergeordnetes Protokoll, ist jedoch ein fester
Bestandteil vom IP. Hier noch eine kleine Liste der Meldungen, welche von
ICMP gesendet werden:

Fehlermeldungen:

3   Destination unreachable (Zielstation nicht erreichbar)
4   Source quench (Buffer-Ressourcen verbraucht)
5   Redirect (Pfadumleitung)
11 Time exceeded (Timer abgelaufen)
12 Parameter Problem (Parameter Problem)

Informationsmeldungen:

0   Echo reply
8   Echo request
13 Time stamp
14 Time stamp reply
15 Information request
16 Information reply
17 Adress mask request
18 Adress mask reply

IP wird dann entsprechend modifiziert, und an den Rechner zurⁿckgesendet.
Auf die einzelnen Header-Modifikationen einzugehen, wΣre nun etwas
ⁿbertrieben


ARP (Adress Resolutin Protocol)
In einem Netzwerk hat jeder Rechner eine durch die firmware bereits
vordefinierte physikalische Adresse. Fⁿr die Kommunikation mit einem
Partner-Rechner wird jedoch nicht die physikalische, sondern eine logische
Adresse verwendet, welche man beispielsweise im Internet findet. Der
Netzwerktreiber alleine ist nun nicht fΣhig, diesen Rechner ⁿber diese
logische Adresse anzusprechen, da sie in keinster Weise in Verbindung mit
der hardware-Adresse des Controllers steht. Es muss nun also die logische
Adresse in die physikalische Adresse umgesetzt werden. Dazu dient ARP. Es
setzt sich aus einem MAC-Header und dem ARP-Packet zusammen, und enhΣlt die
n÷tigen Daten zu logischer Quell-Protokolladresse, als auch der
physikalischen Adresse


RARP (Reverse Adress Resolution Protocol) funktioniert genau in die
entgegen gesetzte Richtung. Anstatt anhand der logischen Adresse die
physikalische zu ermitteln, sendet hier der Host einen RARP request mit der
physikalischen Adresse aus, worauf dann RARP-Server im Netz ihre eigenen
Referenz-Tabellen durchsehen, und einen RARP request zurⁿcksendet, welcher
die logische Adresse an den anfragenden Host zurⁿcksendet. Diese Methode
wird eigentlich nur von Rechnern verwendet, welche kein Medium besitzen, wo
sie ihre dauerhafte, logische Adresse speichern k÷nnen, und somit immer nur
mit der Kenntnis ihrer physikalischen Adresse ins Netz booten.



                   ----------{Transportschicht}----------

Wir haben bislang wohl am ausfⁿhrlichsten IP besprochen. Wer genau gelesen
hat, dem viel auf, dass es keine Sicherung der Verbindung bei IP gibt. In
diesem Layer kommen wir zu jenen Protokollen, welche zum Teil auch fⁿr die
Sicherung verantwortlich sind. Hier eine kleine Liste, was ein Protokoll
der Transportschicht gewΣhrleisten sollte:

- Erm÷glichung von Datentransfer ⁿber dedizierte Transportverbindungen
- Kontrollierter Auf- und Abbau von Verbindungen
- Verwaltung mehrer zu einem Rechner zur gleichen Zeit (Multiplexing)
- Kontrolle, Fehlererkennung und Flusssteuerung ⁿber die gesammte
Verbindung
- Optimierter Datenfluss (Windowing)
- Priorisierung im Datenfluss

WΣrend das ach so bekannte Protokoll namens TCP all diese Bedingungen
erfⁿllt, treffen eben diese bei dem zweiten, recht markanten Protokoll
namens UDP so gut wie gar nicht zu. Weshalb UDP trotzdem zur
Transportschicht geh÷rt, wird weiter unten erklΣrt

Nun kommen wir aber zu den zwei Protokollen an sich. Als erstes werden wir
TCP ziemlich ausfⁿhrlich beschreiben, danach noch eher kurz gehalten das
UDP, welches auch nicht so viele Optionen enthΣlt


TCP (Transmission Control Protocol) besitzt folgende Hauptmerkmal, welche
es Charakterisieren:

- Datenstrom Transfer
- Virtuelle Full-Duplex Verbindungen
- Datenflusssteuerung
- Fehlererkennungen
- PrioritΣtensteuerung

Eine Anwendung kann TCP zum Aufbau einer Verbindung veranlassen und
ⁿbergibt die Daten. TCP teilt dann die Daten auf bzw. segmentiert sie, und
versieht jedes Segment mit einem eigenen Header. Nun erfolgt die ▄bergabe
an das Internet Protocol. Sobald IP seinen Header nach dem transport durchs
Netz wieder abgestreift hat, werden die Daten wieder an TCP ⁿbergeben,
welches die Packete wieder sauber zusammensetzt und auf Fehler ⁿberprⁿft.
Nun werden die Daten noch der entsprechenden Anwendung zugewiesen, und nach
dem entsprechenden Befehl der Anwendung die Verbindung aufgel÷st.
Wie bereits erwΣhnt, sorgt TCP fⁿr Datensicherheit. Jedes TCP-Segment von
Host A wird von Host B bestΣtigt. Das nachfolgende Packet in einer Reihe
von Packeten wⁿrde also erst dann versendet, wenn das vorangehende
bestΣtigt wurde. Dies schafft zwar die gr÷sst m÷gliche Sicherheit, lΣsst
jedoch die Netz-Performance nahezu v÷llig ausser Acht. Aus diesem Grund hat
man einen Mittelweg gefunden. Anstatt jedes einzelne Packet zu quittieren,
wird immer eine kleine Gruppe von Sendungen quittiert. Dieses Verfahren
trΣgt einen bestimmten Namen und funktioniert folgendermassen:

Sliding Windows bzw. Windowing: Das empfangen einer bestimmten Anzahl an
TCP-Segmenten, ben÷tigt beim EmpfΣnger auch eine entsprechende Anzahl
Buffer. Sobald diese Buffer voll sind, wird ein ACK(acknowlegement)
gesendet. Die Gr÷sse des zur Verfⁿgung stehenden Speichers kann jedoch
nicht beliebig vergr÷ssert werden, da auch nicht beliebig Ressourcen zur
Verfⁿgung stehen. Die Gr÷sse kann jedoch mit jedem gesendeten ACK vom
EmpfΣnger der Daten neu definiert werden. Diese "Window-Size" kann sogar
bis auf den Wert 0 verringert werden, doch wⁿrde dies einen Stop des
Datentransfers bedeuten. Tritt die BestΣtigung fⁿr ein gesendetes Segment
nich innerhalb einer bestimmten Zeit ein, so wird es einfach erneut
ⁿbertragen


UDP (User Datagram Protocol) ist ein ungesichertes Protokoll, welches keine
der oben unter TCP erwΣhnten Eigenschaften besitzt. Es ist ebenso
ungesichert wie die Protokolle der unter der Transportschicht liegenden
Layer. Die Begrⁿndung, wesshalb UDP trotzdem zur Transportschicht geh÷rt,
lautet folgendermassen: IP kann zwar Verbindungen herstellen, jedoch keine
Daten an Anwedungen weitergeben. UDP kann das, genauso wie TCP. Allerdings
erwartet UDP keine BestΣtigung des Empfangs. UDP ist also s.z.s. eine
Anwendungsschnittstelle zu IP. Auch der UDP-Header ist sehr kurz gehalten.
Er enthΣlt Informationen zum Ursprungs-Port, Ziel-Port, LΣnge des
Datagramms und die Checksumme der Daten des UDP-Headers.

Hier eine kleine Tabelle mit Beispielen, welche Dienste mit UDP bzw. TCP
erreichbar sind:











                  ----------{Anwendungsschicht}----------

Die Sitzungs- und Darstellungsschicht lassen wir hier deswegen aus, weil
sie eigentlich nicht definiert werden k÷nnen. Diese Layer stellen Schichten
dar, welche in der Regel einfach Services zur Verfⁿgung stehen, welche in
der ⁿber- bzw- untergeordneten Schicht angesiedelt sind. Bei der
Sitzungsschicht spricht man zum Beispiel von einer TCP-Session
(TCP-Sitzung), welche in ihrer Form weder in Schicht 4 noch in Schicht 5
eingeordnet werden kann. Bei der Darstellungsschicht ist das in etwa das
Selbe. Die grafische OberflΣche von Xwindows stellt hier als
PrΣsentationslevel einen integralen Bestandteil des Darstellungs-Schicht
dar.
Die Anwendungsschicht ist jene Schicht, in welcher der Benutzer seine
Befehle quasi direkt ⁿber eine Anwendung eingeben kann, um eine Verbindung
zu einem Rechner zu ÷ffnen, oder entsprechende Befehle zu geben. Im
umgekehrten Sinne ist also die Anwendungschicht auch jene Schicht, von der
eine Anwendung auf Rechner A auch seine Befehle von Rechner B erhΣlt. In
der Anwedungsschicht gibt es eine ganze Menge Protokolle, und dem sind nach
oben hin auch keine Grenzen gesetzt. Es gibt auch keine klar definierte
"Boarderlinie". Gewisse Anwedungen k÷nnen hier auch auf andere Anwendungen
aufsetzen. Dies ist beispielsweise bei einem SNMP-basierenden Tool von HP
mit dem Namen "Open View" der Fall. Nun aber zur Anwendungsschicht an sich:



TELNET: Anfangs der 80-Jahre, als die Zeit des PCs erst begann, gab es noch
keine echten Netzwerke. Meist standen dort Grossrechner, an die "dumme"
Terminals angehΣngt waren. Ein Terminal konnte dann also ⁿber eine Sammlung
an Kabeln mit dem Grossrechner Daten austauschen, nicht jedoch mit weiteren
Terminals. Um der Anschaffung von unmengen neuer Kabel aus dem Weg zu
gehen, musste eine Software-L÷sung her. So kam es dann zu telnet, welches
dem Benutzer die M÷glichkeit gab, Daten zu editieren etc. als sitze er vor
der Shell des anderen Rechners selbst. Das ╓ffnen einer Verbindung erfolgt
direkt durch den Befehl des Benutzers an die Anwendung. Wir k÷nnten nun
hier noch alle Basisbefehle von telnet auflisten, doch wⁿrde dies wohl
keinen grossen Sinn machen.


FTP (File Transfer Protocol) ist ein Dienst der es erm÷glicht, innerhalb
aller Betriebssysteme Daten zu pebrtragen und sie in den jeweiligen
Dateiformaten abzuspeichern. Bekanntlich benutzen die meisten
Betriebssysteme unterschiedliche Dateiformate. UNIX und UNIX-Klone
verwenden oft NFS (Network File System), O/S2 normalerweise HPFS (High
Performance File System) und DOS ausschliesslich FAT (File Allocation
Table). Die Kommunikation ⁿber FTP basiert wie bei telnet auf dem
Client-Server-Modell, ist jedoch um einiges komplexer. Wir wollen nicht
ganz genau darauf eingehen. Folgende Punkte seien trotzdem erwΣhnt: Die
Kommunikation ist in 5 Phasen eingeteilt:

1. Phase: Verbindungsaufbau
Hier wird vom Client die Anfrage auf Verfⁿgbarkeit des Dienstes an den
Rechner gesendet und von diesem bestΣtigt, User und Passwort verifiziert
und die ▄bertragungsoptionen sowie der bzw. die Dateinamen werden
ⁿbermittelt

2. Phase: Erstellung einer Datenverbindung
Hier werden die Informationen bezⁿglich der Ports ausgetauscht, und der
eigentliche Datentransfer vorbeireitet. Nachdem dies festgelegt ist, kann
der eigentliche Datentransfer beginnen

3. Phase: Datenⁿbertragung
Die Datenⁿbertragung erfolgt nun via FTP in der Form, wie es im
entsprechenden Abschnitt bereits erklΣrt wurde

4. Phase: Einleitung vom ▄bertragungsende
Der Rechner ⁿbermittelt die letzten Daten der gesammten Datei, der Client
bestΣtigt den Empfang dieser Dateien. Nun wird vom Rechner ein Close-Befehl
an den Client gesendet, welcher den Befehl entgegennimmt und akzeptiert.

5. Phase: ▄bertragungsende
Der Server-Datenprozess zeigt seinem Kontrollprozess (Port 21) das Ende der
▄bertragung an und beendet. Der Client-DatenProzess terminiert ebenfalls,
lΣsst den Kontrollprozess jedoch noch aktiv fⁿr weitere Transfers.

Auf die nahezu 60 unter FTP zur Verfⁿgung stehenden Befehle m÷chte ich hier
nicht weiter eingehen, da dies den Rahmen sprengen wⁿrde.


TFTP (Trivial File Transmission Protocol) basiert nicht wie das vorhin
behandelte FTP auf TCP sondern auf UDP. Es Dient zwar auch der ▄bertragung
von Daten, ist jedoch nicht fⁿr den Endverbraucher bestimmt. Im Grunde
genommen gibt es bei diesen Transfers auch keine Passwortabfrage, sondern
h÷chstens die Hinterlegung der Source-IP, damit man ⁿber den m÷glichen
Befehlsumfang zu verfⁿgen. Die wichtigsten sind hierbei connect, mode, get,
put, verbose und quit.

Ich werde nun kurz erklΣren, wie eine Datenⁿbertragung hier ablΣuft, obwohl
die Verbindung ungesichert ist. TFTP basiert ebenfalls auf dem
Client-Server Prinzip. Der Client sendet hierbei einen Request an den
Server, dieser BestΣtigt den Request und beginnt die Datenⁿbertragung.
Jeder Datensatz betrΣgt hierbei 512 Byte und wird vom Server bestΣtigt. Das
Ende der ▄bertragung wird vom Client automatisch dann angenommen, wenn ein
entgegen genommener Satz weniger als 512 Byte lang ist.


BOOTP (Boot Protocol) ist UDP basierend, und wurde eigentlich nur dazu
entwickelt, um Boot-VorgΣnge zu aktivieren. Dies wird nur dort n÷tig, wo
discless-workstations betrieben werden, da diese, wie schonmal erwΣhnt,
ihre logische Adresse nicht speichern k÷nnen. Mit Booten ist hier ⁿbrigens
nicht das eigentliche Booten gemeint, sondern lediglich die ▄bernahme
wichtiger Konfigurationsdaten. Eigentlich brauchen wir darauf auch nicht
genauer einzugehen, da dies heute nicht mehr von grosser Relevanz ist.


SMTP (Simple Mail Transfer Protocol) ist das im Internet wohl am meisten
benutzte Protokoll. Seit frⁿhester Zeit hat sich SMTP bereits auf
UNIX-Systemen etabliert und mitlerweile auch auf normalen PCs seinen platz
gefunden. Hier bedient der Anwender seine Mailsoftware und bereitet eine
Nachricht vor. Schickt er dann seine Nachricht ab, so wird diese solange
zwischengespeichert, bis TCP die gesammte Nachricht ⁿbertragen wurde. Auch
hier stehen dem Client als auch dem Server eine Reihe von Befehlen bzw.
Reaktionen zur Verfⁿgung, welche ich nicht auflisten werde. Stattdessen
werde ich hier einen kleinen Dialog zwischen Server und Client wiedergeben
(wir gehen dabei immer von einer positiven Antwort seitens des Servers
aus):

- Client baut eine Session zum Server auf
- Server bestΣtigt die Verfⁿgbarkeit des Services, oder verweigert, da der
Service nicht verfⁿgbar ist
- Client identifiziert sich
- Server identifiziert sich
- Client ⁿbergibt den eigentlichen Befehl der einen Mail-Versand ankⁿndigt.

- Der Server gibt sein EinverstΣndnis
- Client ⁿbermittelt den EmpfΣnger
- Server antwortet mit: Mailbox erreichbar bzw. Mailbox nicht erreichbar
- Client iniziiert die Datenⁿbertragung
- Server nimmt die Daten auf, und verlangt zur Beendung den Befehl
&lt;crlf>&lt;crlf>
- Client sendet nach Beendung der ▄bermittlung wie vereinbart &lt;crlf>&lt;crlf>
- Client beendet die Verbindung mit dem entsprechenden Befehl
- Server antwortet darauf mit "service closing"

Als in den 80-er Jahren noch andere Mail-Systeme eingefⁿhrt wurden, kam es
zu KompatibilitΣtsproblemen. Die ▄bergΣnge waren nicht einfach so zu
bewΣltigen und so musste man sehr umstΣndliche Konverter einsetzen. Seit
1992 Ist nun hauptsΣchlich MIME (Multipurpose Internet Mail Extensions) im
Einsatz, welches sich nicht mehr nur auf den reinen Textversand beschrΣnkt,
sondern verschiedenste Datentypen wie Grafiken, Audiodaten u.s.w. zu
versenden vermag.


RPC (Remote Procedure Calls) wird verwendet, wenn mehrere Rechner mit
verschieden gestalteten KapazitΣten zur Verfⁿgung stehen und eine Aufgabe
zu erledigen ist, welche sehr grosse Systemressourcen aussch÷pfen. Mit RPC
k÷nnen nun Teilaufgaben spezifisch an die dafⁿr am besten qualifizierten
Rechner zugewiesen werden und die verschiedenen Rechner verschmelzen s.z.s.
zu einem Multi-Computer. Dieses Verfahren findet heutzutage ⁿbrigens je
lΣnger je mehr Anklang bei grossen Unternehmen. Auf die genauere Struktur
wird hier nicht eingegangen.


NIS (Network Information Services) wird zur Verwaltung der Operationen,
Security-Objekte und Zugriffsrechte verwendet. Dieses ursprⁿnglich von SUN
entwickelte System (damals Yellow Pages) erm÷glicht die zentrale
Administration dezentraler UserIDs, GroupIDs und Passw÷rter. Um NIS zu
betreiben sind folgende Komponenten vorrausgesetzt:

NIS-Datenbank: Sie stellt quasi eine ⁿbergrosse /etc/passwd-Datei fⁿr das
Netzwerk dar
NIS-Master-Server: Er verwaltet die NIS-Datenbank fⁿr die entsprechende
DomΣne
NIS-Slave-Server: EnthΣlt Sicherungskopie der Datenbank fⁿr AusfΣlle des
Master-Servers
NIS-DomΣne: Eine Gruppe von auf der NIS-Datenbank abgebildeten Rechnern
NIS-Client: Rechner, welcher Daten vom Server beziehen, jedoch nicht Σndern
kann
  ------------------------------------------------------------------------

Somit hΣtten wΣren dann die wichtigsten Protokolle beschrieben, welche fⁿr
den Verbindungsaufbau n÷tig sind. Natⁿrlich sind es lΣngst nicht alle. Wer
Neuerungen bezⁿglich Protokollen nachschlagen will, kann das ⁿber den FTP
Server 192.112.36.5 (NIC.DDN.MIL) ⁿber den gewohnten anonymous-zugang. Dort
werden immer wieder Berichte zur Festlegung der neuesten Standarts
ver÷ffentlicht.

written by m|azma '99

```

</div>
