---
title: "10"
ezine: "kryptocrew"
---

# 10

**Ezine:** kryptocrew

<div className="ascii-content">

```

 Checksummen

  by SnakeByte [SnakeByte@kryptocrew.de]


Checksummen sind Algorithmen, die gr÷▀ere Datenmengen auf einfache Zahlen abbilden.
Dies kann hilfreich sein um zum Beispiel einen Textbereich eindeutig zu identifizieren.
Checksummen sind normalerweise so gestaltet, das man von der Summe nicht auf den
Datenbereich schlie▀en kann, den die Checksumme abbildet. So kann man dies zum Beispiel
nutzen um Passw÷rter zu kontrollieren. Gespeichert wird in diesem Fall nur die
Checksumme und nach Eingabe eines Passwortes wird die dazugeh÷rige Summe erstellt und
das Ergebnis mit dem gespeicherten verglichen. Sind diese identisch ist das Passwort
richtig.  Auch kann man mit neueren ( CRC32 ) Checksummen einen String so gut
wie 100%ig identifizieren, es ist bisher keine Methode bekannt, wie man einen
Buchstaben eines Strings verΣndern und die Checksumme beibehalten kann. Deshalb schⁿtzen
Checksummen auch vor Manipulation wΣhrend der ▄bertragung. Da es natⁿrlich
fⁿr jede Checksumme mehr als nur einen String geben kann, sollte man die ersten paar
Buchstaben speichern um eine 99,9%ige Wahrscheinlichkeit zu erreichen, wenn man
Checksummen zum erkennen von Viren oder Trojanern einsetzt, wie dies nahezu alle
Antivirenprogramme tun. Eine einfache Art der Checksummenberechnung ist zum Beispiel
das simple aufaddieren aller Zeichen. Diese Methode ist allerdings nicht sehr
zuverlΣssig. Etwas Σhnlich simples ist die Aufaddierung der Zahlen und das anschlie▀ende
Teilen des Ergebnisses durch 100. Der Rest der Division wird nun als Prⁿfsumme verwendet,
was den Vorteil hat, das die Prⁿfsumme nur im Bereich von 0-99 liegt.

Wenn man Prⁿfsummen dafⁿr verwenden will um genau zu sehen, welche Bytes verΣndert
wurden, muss man fⁿr n Bytes genau n-1 Checksummen erstellen ( m÷glichst  kleine, am Besten
4 Bits ). Wenn es egal ist welches Byte genau defekt ist, kann man natⁿrlich auch fⁿr
gr÷▀ere Bereiche diese Checksummen verwenden. Hier ein Beispiel:

A1, A2, A3 und A4 sind die zu ⁿbertragenden Bytes. C1, C2 und C3 unsere Checksummen.

 C1 = A1 + A2 + A3
 C2 = A2 + A3 + A4
 C3 = A3 + A4 + A1

Stimmen nun C1 und C2 aber nicht C3 mit den ermittelten Ergebissen ⁿberein,
wei▀ man, das A2 defekt ist. Sind C1, C2 und C3 falsch, muss der Fehler bei A3 liegen etc.
Dadⁿrch kann man schnell ▄bertragungsfehler erkennen und die entsprechenden Bereiche
neu laden, bzw anfordern. Man kann hierfⁿr auch Checksummen verwenden, die pro Fehler,
den man entdecken m÷chte um ein Vielfaches lΣnger als das Original sind.
Wenn man eine Nachricht von n Bytes verschicken, und m Fehler entdecken will,
so ist m*n die LΣnge der codierten Nachricht. Dies will ich hier nicht im Detail
erklΣren, nur soviel, das man an jeden Block der Nachricht einen Codeblock anhΣngt, der 
fⁿr diesen Teil der Nachricht spezifisch ist. Wer mehr dazu wissen m÷chte, sollte
mal nach dem Stichwort "Reed-Muller Codes suchen".

CRC32 hat sich mitlerweile gut gehalten, deshalb werde ich hier diesen
Algorithmus erlΣutern. HauptsΣchlich basiert CRC32 auf Exclusiven Oder Verknⁿpfungen.
Hierbei wird einfach eine Bitweise Verknⁿpfung erstellt, wenn beide Bits gleich sind kommt
eine 0 raus, wenn beide ungleich sind eine 1.

Zuerst wird das ganze initialisiert, wir erstellen eine Tabelle ( Crc32Table(i) )
mit 256 EintrΣgen, die wir nach folgendem Schema fⁿllen:

  For i = 0 To 255                        'Schleife fⁿr alle EintrΣge
  lCrc32 = i

    For iBits = 0 To 7                    'fⁿr alle 8 Bits
     TempCrc = lCrc32 And &HFFFFFFFE      'logische UND Verknⁿpfung mit -2
     TempCrc = TempCrc \ &H2              'teilen durch 2
     TempCrc = TempCrc And &H7FFFFFFF     'UND Verknⁿpfung mit 2147483647
     
     If (lCrc32 And &H1) <> 0 Then        'fⁿr alle ungeraden Zahlen wird ein
      lCrc32 = TempCrc Xor &HEDB88320     'exclusives ODER mit 3988292384 durchgefⁿhrt
     Else                                 'ansonsten
      lCrc32 = TempCrc                    'ist der Wert ok
     End If
    Next
    
    Crc32Table(i) = lCrc32                'dieser wird nun in unsere Tabelle geschrieben
   Next

Nun k÷nnen wir unsere Checksumme erstellen:

 CRC32 = -1
 lTableValue = 0

 For i = 1 To Len(Unser_String)             'fⁿr jedes Bytes des Strings

  bCharValue = Asc(Mid$(Item, iCounter, 1)) 'ermitteln wir den Hexwert
  
  AccValue = Crc32 And &HFFFFFF00           'wir l÷schen alle Stellen bis auf die letzten
  AccValue = lAccValue \ &H100              'teilen durch 256 und l÷schen
  AccValue = lAccValue And &HFFFFFF         'die ersten beiden Stellen
  
  lIndex = Crc32 And &HFF                   'Die letzten 2 Stellen l÷schen
  lIndex = lIndex Xor bCharValue            'XOR mit dem Buchstaben
  lTableValue = Crc32Table(lIndex)          'mit dem Initialisationswert der Tabelle XOR'en
  
  Crc32 = AccValue Xor lTableValue
 Next

 AddCrc32 = Crc32                           'AddCrc32 ist nun die Checksumme


```

</div>
