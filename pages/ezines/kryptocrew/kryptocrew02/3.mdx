---
title: "3"
ezine: "kryptocrew"
---

# 3

**Ezine:** kryptocrew

<div className="ascii-content">

```

    Kryptografie      Geschrieben von Marc Ruef &lt;marc.ruef@computec.ch> fⁿr
   Version 4.0alpha   http://www.computec.ch/
     (intern) 15.     Alle Rechte vorbehalten - Kopieren erlaubt!
    Dezember 2000     http://www.computec.ch/mruef/texte/kryptografie.html
  ------------------------------------------------------------------------

1.0 Inhaltsverzeichnis

     1.0 Inhaltsverzeichnis

     2.0 Einfⁿhrung

          2.1 Kryptoanalyse

          2.2 OGR - Golomb Ruler

          2.3 Steganografie

     3.0 Wieso soll ich verschlⁿsseln?

     4.0 Symmetrische Kryptoalgorithmen

          4.1 Blowfish

          4.2 CAST-128

          4.3 Clipper

          4.4 DES (Data Encryption Standart)

          4.5 IDEA (International Data Encryption Standart)

          4.6 ROT13 & monoalphabetische Verschlⁿsselungen

          4.7 RC2 (Rivest Cipher 2)

          4.8 RC4 (Rivest Cipher 4)

          4.9 RC5 (Rivest Cipher 5)

          4.10 Safer

          4.11 Triple-DES (3DES)

          4.12 Twofish

     5.0 Assymmetrische Kryptoalgorithmen

          5.1 RSA (Rivest, Shamir, Adleman)

     6.0 Einwegverschlⁿsselungs-Algorithmen

          6.1 DH/DSS

          6.2 MD5 (Message Digest 5)

          6.4 SHA/SHA1 (Secure Hash Algorithm)

2.0 Einfⁿhrung

     Die Kryptologie teilt sich in die beiden TΣtigkeitsfelder
     Kryptografie und Kryptoanalyse auf. Als Kryptografie bezeichnet
     man die Wissenschaft von den Methoden der Ver- und
     Entschlⁿsselung von Daten. Die Kryptoanalyse als Wissenschaft
     versucht bestehende kryptografische Systeme zu brechen.

     In der Verschlⁿsselungstechnik werden grundsΣtzlich drei Arten
     von Daten gekannt: Als Klartext (engl. Plaintext) werden
     unverschlⁿsselte Daten bezeichnet. Im Gegensatz dazu benennt man
     verschlⁿsselte Daten als Schlⁿsseltext (engl. Ciphertext).
     Dazwischen wird natⁿrlich noch ein Schlⁿssel verwendet, welcher
     der eigentliche Verschlⁿsselungsalgorithmus ist.

Verschlⁿsselung : Schlⁿsseltext = Verschlⁿsseln ( Schlⁿssel; Klartext )
Entschlⁿsselung : Klartext = Entschlⁿsseln ( Schlⁿssel; Schlⁿsseltext )
Signieren       : Signatur = Signieren ( Geheimer Schlⁿssel; Text )

     Moderne Kryptoalgorithmen basieren in der Regel auf dem
     Kerckhoff-Prinzip. Das nach Auguste Kerckhoff (1835 - 1903)
     benannte Prinzip besagt, dass die gesamte Sicherheit eines
     Algorithmus nur auf der Geheimhaltung des Schlⁿssels beruhen
     soll, und nicht auf der Geheimhaltung des kryptografischen
     Algorithmus. Der Gegensatz zu Kerckhoff ist das Prinzip der
     Sicherheit durch Verschleiern: Der Angreifer hat bei einem
     verschleierten System keine Ahnung, wie es funktioniert.

     2.1 Kryptoanalyse

          Um den Schlⁿssel eines Kryptoalgorithmus zu brechen,
          gibt es verschiedene Angriffsm÷glichkeiten: Bei der
          "ciphertext only attack" kennt der Angreifer nur den
          Schlⁿsseltext, und versucht daraus den Schlⁿssel oder
          Plaintext zu generieren. Bei der "known plaintext
          attack" kennt der Angreifer mehrere
          Plaintext-Ciphertext-Paare, und versucht danach weitere
          zu generieren. Kann der Angreifer in der "chosen
          plaintext attack" und der "chosen ciphertext attack"
          eigene Klartext- bzw. Schlⁿsseltext-Paare generieren,
          dann ist dies der aussichtsreichste Angriff. Denn dann
          kann durch Probieren der geheime Schlⁿssel gefunden
          werden. Dies nennt man dann eine "brute force attack".

     2.2 OGR

          Im mathematischen Sinn ist ein "Golomb Ruler" eine
          Menge nichtnegativer ganzer Zahlen, wobei alle
          m÷glichen Zahlenpaare eine unterschiedliche Differenz
          haben. Das kann man mit einer Messlatte vergleichen,
          auf der keine zwei Paar Markierungen den gleichen
          Abstand haben. Ein OGR ist dann die kⁿrzeste m÷gli-che
          Messlatte bei gegebener Anzahl Markierungen. Die
          Anwendungen dafⁿr sind zahlreich, z. B. in
          Ra-dioastronomie oder
          R÷ntgenkristallographie.

          Zur Zeit sind die OGR mit bis zu 20 Zahlen bekannt.
          Auch Ruler mit mehr als 20 Zahlen sind bekannt,
          allerdings weis man von diesen nicht, ob sie optimal
          sind. Durch Testen aller m÷glichen Ruler bis zur Gr÷sse
          des besten bekannten Rulers mit 21 Zahlen (und spΣter
          dann auch mehr) kann man entweder einen besseren finden
          oder fⁿr den bekannten beweisen, dass er optimal ist.

     2.3 Steganografie

          Als erstes muss ich sagen, dass Steganografie ein
          Teilgebiet der Verschlⁿsselung darstellt. Steganografie
          ist die Kunst, die Daten einer Kommunikation in anderen
          Daten zu verstecken, so dass es aussieht, als hΣtte nie
          eine Kommunikation stattgefunden. Im Gegensatz dazu
          versuchen kryptografische Methoden nicht, die
          Kommunikation zu verschleidern, sondern deren Inhalt
          fⁿr jeden anderen, als die Ziel-Person, unleserlich zu
          gestalten.

          Die Ursprⁿnge dieser Technik reichen bis in die Antike
          zurⁿck. Im Mittelwalter wurden Bⁿcher und Schriften
          verfasst, in welchen zum Beispiel SΣtze aus privaten
          Dokumenten, wie Briefen, gesammelt wurden. Den
          einzelnen SΣtzen wurden gewisse Bedeutungen zugewiesen,
          wodurch Informationen in Briefen versteckt werden
          konnten. Ein anderes Beispiel ist die Geschichte zur
          Zeit von CΣsar, als eine mit der richtigen Nachricht
          beschriftete Steinplatte mit Wachs ⁿberzogen wurde, um
          eine andere Nachricht darauf vorzutΣuschen. In gewisser
          Weise ist auch das Handeln von David Copperfield der
          Steganografie zuzuschreiben, denn sei-ne Tricks
          versuchen etwas vorzugeben, was nicht wirklich
          elementar ist.

          Im Bereich der Telekommunikation via Internet sind
          MixMaster und Onion Routing Beispiele fⁿr
          Steganographie. Um die Tatsache der Kommunikation zu
          verbergen, wird die Netzlast zwischen Knoten konstant
          gehalten. Im Datenverkehr zwischen den Netzknoten wir
          die Kommunikation zwischen menschlichen Partnern
          verborgen. Wird eine Traffic-Analyse durchgefⁿhrt,
          lΣsst sich nicht feststellen, wer an wen Daten sendet.
          Man erkennt nur, dass Daten von einem Punkt zum anderen
          fliessen.

          MixMaster ist ein Programm, das dieses Prinzip auf den
          Versand von E-Mails ⁿbertrΣgt. Onion Routing ist ein
          Ansatz, Steganografie auf der Ebene des
          Netzwerk-Standarts TCP zu implementieren. Das fⁿr den
          Otto-Normalverbraucher wohl interessanteste Programm
          zur Steganografie ist das Programm "Stegano", welches
          in der gewohnten Umgebung unter Windows 9x Daten in
          anderen Daten verstecken kann.

          Das Problem einer solchen Verschleierung ist, dass das
          Rauschen, mit dem die Information versteckt wird,
          wiederum nicht als Rauschen entdeckt werden darf.
          Gelingt eine Trenning von Rauschen und Informationen,
          ist zumindest die Verschleierung der
          Nachrichtenⁿbermittlung aufgedeckt.

          Heute ist das eigentliche Anwendungsgebiet der
          Steganografie der Copyrightschutz von elektronischen
          Daten, wie zum Beispiel Bildern oder Sound-Dateien. So
          werden zum Beispiel elektronische Wasserzeichen
          (Englisch: watermarks) in ein Bild eingebettet. Das
          Wasserzeichen ist im Bild mit blossem Auge nicht
          sichtbar. Im Streitfall kann der Eigentⁿmer allerdings
          durch ein geeignetes Programm die versteckte
          Information sichtbar
          machen, und dadurch die Standfestigkeit seiner meinung
          festigen. Probleme ergeben sich, falls das Bild
          verΣndert wurde. Es existieren Programme, mit denen ein
          Bild so verΣndert werden kann, dass der Bildinhalt nur
          geringfⁿgig verΣndert wird, und das Wasserzeichen nicht
          mehr nachweisbar ist.

          Im Bereich der Betriebssysteme, die nach dem Orangebook
          (ITSEC) sicherheitszertifiziert wurden, besteht das
          Problem des "Hidden Channel". In entsprechenden
          Betriebssystemen sind alle Objekte (Dateien und
          Prozesse) nicht nur Benutzern und Gruppen zugeordnet,
          sondern auch Sicherheitsstufen. Aufgrund der Vorgaben
          aus dem Orangebook darf ein Objekt mit einer hohen
          Sicherheitsstufe keine Daten an ein Objekt niedriger
          Sicherheitsstufe weitergeben oder zugΣnglich machen.
          Durch die Erzeugung von sogenannten "Hidden Channels"
          kann dies jedoch
          umgangen werden. Ein solcher "Hidden Channel" kann zum
          Beispiel die kⁿnstliche Erh÷hung der Systemlast in
          gewissen ZeitabstΣnden oder Situationen sein. Zwei
          Prozesse, die per Definition nicht miteinander
          kommunizieren dⁿrfen, k÷nnen auf diese Weise trotzdem
          Informationen austauschen.

3.0 Wieso soll ich verschlⁿsseln?

     Wenn man geschΣftliche oder pers÷nliche Informationen lieber in
     einem geschlossenen Umschlag verschicke, weder die Informationen
     per Postkarte an jemanden weiterzuleiten, dann ist die logische
     Schlussfolgerung, dass man sich fⁿr eine Verschlⁿsselung des
     Datenverkehrs im Internet entscheiden sollte.

     Leider gelten unverschlⁿsselte E-Mails als absolut unsicher. Eine
     E-Mail passiert viele verschiedene Rechner/Knotenpunkte auf dem
     Weg durch das Internet, bis es schlussendlich einmal beim
     EmpfΣnger eintrifft. Auf jedem dieser Rechner kann die Nachricht
     im Klartext gelesen werden, was keinen sonderlichen positiven
     Einfluss auf die PrivatsphΣre der beiden kommunizierenden
     Parteien hat. Beide wⁿrden von einem solchen passiven Eingriff
     auch nichts mitbekommen. Sicherheitsexperten und Paranoiker gehen
     davon aus, dass ein Grossteil des Datenverkehrs aufgezeichnet,
     und mittels Schlⁿsselw÷rtern, wie zum Beispiel "Attentat",
     "Anschlag", "Bombe", oder "Mafia" untersucht wird. Besonders die
     amerikanische Regierung, und die NSA (National Security Agency)
     gerieten ins Zwielicht, solche Informationsschnⁿffler und
     -Sammler zu sein.

     Auserdem gestaltet sich der Aufwand, sei es nun pers÷nlicher oder
     finanzieller Natur, mittels des Verschlⁿsselns des Datenverkehrs
     als ausgesprochen gering. Das meist eingesetzte, und von mir
     empfohlene Programm ist PGP (Pretty Good Privacy), und ist als
     Freeware erhΣltlich. Somit sind frei kopierbare Versionen im
     Umlauf, welche als Standart fⁿr den Normalverbraucher, sowie auch
     unter den Experten angesehen wird.

     Solch starke Verschlⁿsselungen, wie sie bei PGP m÷glich sind,
     sind in der Schweiz durchwegs legal, und fallen unter kein
     Waffenexport-Verbot. Da der darin verwendete Algorithmus keine
     sonderlich hohen Hardwareanforderungen hat, ist PGP auf jedem
     gebrΣuchlichen PC einsetzbar.

4.0 Symmetrische Kryptoalgorithmen

     Die symmetrischen Kryptoalgorithmen basieren auf dem Prinzip, die
     Ver- und Entschlⁿsselung mit dem gleichen Schlⁿssel
     durchzufⁿhren.

     4.1 Blowfish

          Der Autor von Blowfish heisst Bruce Schneider, und er
          entwickelte ihn im Jahre 1994. Die BlocklΣnge betrΣgt
          64 Bit, und die SchlⁿssellΣnge kann bis 448 Bit
          ausgeweitet werden.

          Ausgehend von den ersten 8336 Stellen der hexadezimalen
          Darstellung von Pi, wird aus dem Schlⁿssel die
          ben÷tigten Gr÷ssen mt 521 Iterationen des
          Blowfish-Algorithmus erstellt. Damit will man
          eventuellen Hintertⁿren vorbeugen.

     4.2 CAST-128

          Als Autor von CAST-128 gilt C. M. Adams. Die BlocklΣnge
          betrΣgt 64 Bit, und die SchlⁿssellΣnge kann zwischen 40
          und 128 Bit liegen. Der Einsatzort wird nicht nur wegen
          der enormen Geschwindigkeit und dem Entfallen der
          Kosten hauptsΣchlich in PGP 5 gesehen. CAST-128 ist
          weltweit erhΣltlich und einsetzbar; Egal, ob fⁿr den
          privaten oder kommerziellen Gebrauch. Genauere
          Informationen erhΣlt man in RFC2144.

          CAST-128 ist ein Verfahren, welches einen Klartext in
          12 oder 16 DurchgΣngen mittels des Feistel-Verfahrens
          und einer maximalen Blockgr÷sse von 128 Bit
          verschlⁿsselt. Es wird ein Umkehren der wichtigen
          Elemente eingesetzt, was das Verfahren immun gegen
          lineare und differentielle Attacken macht. Es wird eine
          Mixtur aus XOR, Additionen und Subtraktionen (modulo
          2**32) in einem Durchgang eingesetzt, wobei drei
          Variationen der Rundungsfunktion bis zum Endgⁿltigen
          verschlⁿsselten Text zum Zuge kommen. Schlussendlich
          werden 8x32 S-Boxen eingesetzt, wobei die verschiedenen
          Rundungsfunktionen das Minimum von 74 nonlinearen und
          ein Maximum von 2 verschiedenen verteilungs Tabellen
          erreicht wird.

          CAST-128 stellt eine Form der Verschlⁿsselung dar,
          welche "Feister ciphers" genannt wird. Viele
          eingesetzte Operationen sind Σhnlich, wie die des DES
          (Data Encryption Standart). Die komplette
          Verschlⁿsselung geschieht in folgenden vier
          Teilschritten:

          Eingabe           : Klartext k1...k64; Schlⁿssel s = s1...s128.

          Ausgabe           : Verschlⁿsselter Text c1...c64.

          Es werden 16 Subkey-Paare {Kmi, Kri} aus K gebildet. Es
          wird aus k1...k64 L0 und R0 gebildet, also der Klartext
          in zwei 32-Bit-HΣlften gesplittet. L0 = k1...k32 und R0
          = k33...k64. Es werden i1...i16 gebildet, und Li und Ri
          wie folgt ergΣnzt, was dann f ergibt: Li = Ri-1 Ri =
          Li-1 ^ f(Ri-1, Kmi, Kri) c1...c64, also R16 und L16
          werden ausgetauscht, und der verschlⁿsselte Text ist
          gegeben.

          CAST-128 benutzt ein Subkey-Paar pro Prozedur, welche
          als 32-Bit-QuantitΣt Km als "masking Key" und eine
          5-Bit-QuantitΣt Kr als "rotation Key" generiert werden
          mⁿssen.

          Drei verschiedene Rundungs-Funktionen kommen bei
          CAST-128 zum Zuge. Folgend m÷chte ich jene gerne kurz
          beschreiben, wobei D als Daten-Eingabe zur Funktion F
          und Ia und Id die h÷chstwertigen Bytes darstellen. Zu
          beachten ist, dass + und - als Addition und Subtraktion
          modulo 2**32 eingesetzt werden, und ^ als bitweise
          XOR-Funktion genutzt wird. Desweiteren gilt <<< als als
          zurkulierte Leftshift-Operation.

          Type 1:
          I = ((Kmi + D) <<< Kri)
          f = ((S1[Ia] ^ S2[Ib]) - S3[Ic]) + S4[Id]

          Type 2:
          I = ((Kmi ^ D) <<< Kri)
          f = ((S1[Ia] - S2[Ib]) + S3[Ic]) ^ S4[Id]

          Type 3:
          I = ((Kmi - D) <<< Kri)
          f = ((S1[Ia] + S2[Ib]) ^ S3[Ic]) - S4[Id]

          Die Rundungen 1, 4, 7, 10, 13 und 16 benutzen die
          f-Funktion Typus 1.
          Die Rundungen 2, 5, 8, 11 und 14 benutzen die
          f-Funktion Typus 2.
          Die Rundungen 3, 6, 9, 12 und 15 benutzen die
          f-Funktion Typus 3.

          CAST-128 greift auf acht Ersatz-Boxen zurⁿck: Die
          S-Boxen S1, S2, S3 und S4 sind Rundungsfunktionen in
          Form von S-Boxen. S5, S6, S7 und S8 sind planmΣsige
          S-Boxen. Schlussendlich brauchen 8 S-Boxen total 8
          Kbytes Speicher, wobei eigentlich nur 4 Kbytes wΣhren
          des effektiven Umwandlungsvorgangs von Klar- zu
          Schlⁿsseltext, oder Umgekehrt ben÷tigt werden.

          Als 128-Bit-Schlⁿssel nehme ich nun
          x0x1x2x3x4x5x6x7x8x9xAxBxCxDxExF, wobei x0 das
          h÷chstwertige Byte, und xF das niederwertigste Byte
          reprΣsentiert. Z0...zF stellen temporΣre Bytes dar.
          Si[] gilt als S-Box i und ^ represΣntiert eine
          XOR-Addition.

          Die Subkeys werden vom Schlⁿssel
          x0x1x2x3x4x5x6x7x8x9xAxBxCxDxExF gebildet, und
          gestalten sich nun wie folgt:

          z0z1z2z3 = x0x1x2x3 ^ S5[xD] ^ S6[xF] ^ S7[xC] ^ S8[xE]
          ^ S7[x8]
          z4z5z6z7 = x8x9xAxB ^ S5[z0] ^ S6[z2] ^ S7[z1] ^ S8[z3]
          ^ S8[xA]
          z8z9zAzB = xCxDxExF ^ S5[z7] ^ S6[z6] ^ S7[z5] ^ S8[z4]
          ^ S5[x9]
          zCzDzEzF = x4x5x6x7 ^ S5[zA] ^ S6[z9] ^ S7[zB] ^ S8[z8]
          ^ S6[xB]
          K1  = S5[z8] ^ S6[z9] ^ S7[z7] ^ S8[z6] ^ S5[z2]
          K2  = S5[zA] ^ S6[zB] ^ S7[z5] ^ S8[z4] ^ S6[z6]
          K3  = S5[zC] ^ S6[zD] ^ S7[z3] ^ S8[z2] ^ S7[z9]
          K4  = S5[zE] ^ S6[zF] ^ S7[z1] ^ S8[z0] ^ S8[zC]
          x0x1x2x3 = z8z9zAzB ^ S5[z5] ^ S6[z7] ^ S7[z4] ^ S8[z6]
          ^ S7[z0]
          x4x5x6x7 = z0z1z2z3 ^ S5[x0] ^ S6[x2] ^ S7[x1] ^ S8[x3]
          ^ S8[z2]
          x8x9xAxB = z4z5z6z7 ^ S5[x7] ^ S6[x6] ^ S7[x5] ^ S8[x4]
          ^ S5[z1]
          xCxDxExF = zCzDzEzF ^ S5[xA] ^ S6[x9] ^ S7[xB] ^ S8[x8]
          ^ S6[z3]
          K5  = S5[x3] ^ S6[x2] ^ S7[xC] ^ S8[xD] ^ S5[x8]
          K6  = S5[x1] ^ S6[x0] ^ S7[xE] ^ S8[xF] ^ S6[xD]
          K7  = S5[x7] ^ S6[x6] ^ S7[x8] ^ S8[x9] ^ S7[x3]
          K8  = S5[x5] ^ S6[x4] ^ S7[xA] ^ S8[xB] ^ S8[x7]
          z0z1z2z3 = x0x1x2x3 ^ S5[xD] ^ S6[xF] ^ S7[xC] ^ S8[xE]
          ^ S7[x8]
          z4z5z6z7 = x8x9xAxB ^ S5[z0] ^ S6[z2] ^ S7[z1] ^ S8[z3]
          ^ S8[xA]
          z8z9zAzB = xCxDxExF ^ S5[z7] ^ S6[z6] ^ S7[z5] ^ S8[z4]
          ^ S5[x9]
          zCzDzEzF = x4x5x6x7 ^ S5[zA] ^ S6[z9] ^ S7[zB] ^ S8[z8]
          ^ S6[xB]
          K9  = S5[z3] ^ S6[z2] ^ S7[zC] ^ S8[zD] ^ S5[z9]
          K10 = S5[z1] ^ S6[z0] ^ S7[zE] ^ S8[zF] ^ S6[zC]
          K11 = S5[z7] ^ S6[z6] ^ S7[z8] ^ S8[z9] ^ S7[z2]
          K12 = S5[z5] ^ S6[z4] ^ S7[zA] ^ S8[zB] ^ S8[z6]
          x0x1x2x3 = z8z9zAzB ^ S5[z5] ^ S6[z7] ^ S7[z4] ^ S8[z6]
          ^ S7[z0]
          x4x5x6x7 = z0z1z2z3 ^ S5[x0] ^ S6[x2] ^ S7[x1] ^ S8[x3]
          ^ S8[z2]
          x8x9xAxB = z4z5z6z7 ^ S5[x7] ^ S6[x6] ^ S7[x5] ^ S8[x4]
          ^ S5[z1]
          xCxDxExF = zCzDzEzF ^ S5[xA] ^ S6[x9] ^ S7[xB] ^ S8[x8]
          ^ S6[z3]
          K13 = S5[x8] ^ S6[x9] ^ S7[x7] ^ S8[x6] ^ S5[x3]
          K14 = S5[xA] ^ S6[xB] ^ S7[x5] ^ S8[x4] ^ S6[x7]
          K15 = S5[xC] ^ S6[xD] ^ S7[x3] ^ S8[x2] ^ S7[x8]
          K16 = S5[xE] ^ S6[xF] ^ S7[x1] ^ S8[x0] ^ S8[xD]
          z0z1z2z3 = x0x1x2x3 ^ S5[xD] ^ S6[xF] ^ S7[xC] ^ S8[xE]
          ^ S7[x8]
          z4z5z6z7 = x8x9xAxB ^ S5[z0] ^ S6[z2] ^ S7[z1] ^ S8[z3]
          ^ S8[xA]
          z8z9zAzB = xCxDxExF ^ S5[z7] ^ S6[z6] ^ S7[z5] ^ S8[z4]
          ^ S5[x9]
          zCzDzEzF = x4x5x6x7 ^ S5[zA] ^ S6[z9] ^ S7[zB] ^ S8[z8]
          ^ S6[xB]
          K17 = S5[z8] ^ S6[z9] ^ S7[z7] ^ S8[z6] ^ S5[z2]
          K18 = S5[zA] ^ S6[zB] ^ S7[z5] ^ S8[z4] ^ S6[z6]
          K19 = S5[zC] ^ S6[zD] ^ S7[z3] ^ S8[z2] ^ S7[z9]
          K20 = S5[zE] ^ S6[zF] ^ S7[z1] ^ S8[z0] ^ S8[zC]
          x0x1x2x3 = z8z9zAzB ^ S5[z5] ^ S6[z7] ^ S7[z4] ^ S8[z6]
          ^ S7[z0]
          x4x5x6x7 = z0z1z2z3 ^ S5[x0] ^ S6[x2] ^ S7[x1] ^ S8[x3]
          ^ S8[z2]
          x8x9xAxB = z4z5z6z7 ^ S5[x7] ^ S6[x6] ^ S7[x5] ^ S8[x4]
          ^ S5[z1]
          xCxDxExF = zCzDzEzF ^ S5[xA] ^ S6[x9] ^ S7[xB] ^ S8[x8]
          ^ S6[z3]
          K21 = S5[x3] ^ S6[x2] ^ S7[xC] ^ S8[xD] ^ S5[x8]
          K22 = S5[x1] ^ S6[x0] ^ S7[xE] ^ S8[xF] ^ S6[xD]
          K23 = S5[x7] ^ S6[x6] ^ S7[x8] ^ S8[x9] ^ S7[x3]
          K24 = S5[x5] ^ S6[x4] ^ S7[xA] ^ S8[xB] ^ S8[x7]
          z0z1z2z3 = x0x1x2x3 ^ S5[xD] ^ S6[xF] ^ S7[xC] ^ S8[xE]
          ^ S7[x8]
          z4z5z6z7 = x8x9xAxB ^ S5[z0] ^ S6[z2] ^ S7[z1] ^ S8[z3]
          ^ S8[xA]
          z8z9zAzB = xCxDxExF ^ S5[z7] ^ S6[z6] ^ S7[z5] ^ S8[z4]
          ^ S5[x9]
          zCzDzEzF = x4x5x6x7 ^ S5[zA] ^ S6[z9] ^ S7[zB] ^ S8[z8]
          ^ S6[xB]
          K25 = S5[z3] ^ S6[z2] ^ S7[zC] ^ S8[zD] ^ S5[z9]
          K26 = S5[z1] ^ S6[z0] ^ S7[zE] ^ S8[zF] ^ S6[zC]
          K27 = S5[z7] ^ S6[z6] ^ S7[z8] ^ S8[z9] ^ S7[z2]
          K28 = S5[z5] ^ S6[z4] ^ S7[zA] ^ S8[zB] ^ S8[z6]
          x0x1x2x3 = z8z9zAzB ^ S5[z5] ^ S6[z7] ^ S7[z4] ^ S8[z6]
          ^ S7[z0]
          x4x5x6x7 = z0z1z2z3 ^ S5[x0] ^ S6[x2] ^ S7[x1] ^ S8[x3]
          ^ S8[z2]
          x8x9xAxB = z4z5z6z7 ^ S5[x7] ^ S6[x6] ^ S7[x5] ^ S8[x4]
          ^ S5[z1]
          xCxDxExF = zCzDzEzF ^ S5[xA] ^ S6[x9] ^ S7[xB] ^ S8[x8]
          ^ S6[z3]
          K29 = S5[x8] ^ S6[x9] ^ S7[x7] ^ S8[x6] ^ S5[x3]
          K30 = S5[xA] ^ S6[xB] ^ S7[x5] ^ S8[x4] ^ S6[x7]
          K31 = S5[xC] ^ S6[xD] ^ S7[x3] ^ S8[x2] ^ S7[x8]
          K32 = S5[xE] ^ S6[xF] ^ S7[x1] ^ S8[x0] ^ S8[xD]

          Fⁿr das Maskieren und Rotieren der Subkeys gilt
          folgende Regel, wobei Km1...Km16 ein 32-Bit-maskierter
          Subkey, und Kr1...Kr16 den anderen Subkey fⁿr eine
          Sitzung darstellt. Nur die 5 h÷chstwertigen Bits werden
          in einem Durchgang benutzt.

          for (i=1; i<=16; i++)  { Kmi = Ki;  Kri = K16+i; }

          CAST-128 wurde so designt, dass der Schlⁿssel fⁿr eine
          Sitzung zwischen 40 und 128 Bits gewΣhlt werden kann.
          Dabei muss man jedoch bedenken, dass der Schlⁿssel in
          8-Bit-Teile zerlegt werden muss, und somit nur die
          SchlⁿssellΣngen 40, 48, 56, 64, ..., 112, 120 und 128
          Bits m÷glich werden. Fⁿr eine variable Schlⁿsselgr÷sse
          sind folgende offiziellen Spezifikationen in RFC2144
          festgehalten:

          Fⁿr SchlⁿssellΣngen bis zu 80 Bits (also 40, 48, 56,
          64, 72 und 80 Bits) verwendet der Algorithmus die
          Standartbestimmungen, jedoch 12 DurchgΣnge, anstatt 16.
          Fⁿr SchlⁿssellΣngen, die gr÷sser als 80 Bits sind,
          benutzt der Algorithmus alle 16 DurchgΣnge. Fⁿr
          SchlⁿssellΣngen, die kleiner als 128 Bits sind, werden
          die niederwertigsten Positionen mit Nullen aufgefⁿllt.

          Grob kann man nun sagen, dass CAST-128 anstandslos alle
          12 oben genannten SchlⁿssellΣngen akzeptiert, und
          verwerten kann. Zum Einsatz kommen jedoch vorwiegend
          die SchlⁿssellΣngen von 40, 64, 80 und 128 Bits. Bei
          vielen Implementationen ist eine Wahl zwischen diesen
          SchlⁿssellΣngen meist nicht m÷glich.

          Falls nun eine Konfusion auf Basis von CAST-128
          durchgefⁿhrt wird, kann das Verfahren einen anderen
          Namen enthalten. Als Beispiel sei eine Verschlⁿsselung
          mittels CAST-128 mit einem 40 Bit langer Schlⁿssel zu
          nennen, welche dann den Namen CAST5-40 erhΣlt. Wird nun
          ein 128 Bit langer Schlⁿssel eingesetzt, wird das ganze
          als CAST5-128 benannt.

          Die Performance des als sicher geltenden Verfahrens
          kann sich durchaus sehen lassen. Wird ein Text mit
          einem Schlⁿssel von 128 Bit LΣnge ver- oder
          entschlⁿsselt, braucht man auf einem handelsⁿblichen
          Pentium Prozessor, welcher mit 150 MHz getaktet ist,
          nur 3.3 MB/sek.

          Das Dechiffrieren gestaltet sich relativ einfach: Denn
          genau wie Chiffrieren; nur die Reihenfolge der
          Teilschlⁿssel wird umgedreht. Trotzdem gilt dieses
          Verfahren als immun gegen lineare und differentiale
          Kryptoanalyse, da keine schwachen oder semi-schwachen
          Schlⁿssel existieren.

     4.3 Clipper

          Die amerikanische Regierung kⁿndigte auf den Tag genau
          am 16. April 1993 eine neue Initiative der
          Datenverschlⁿsselung an, die jedermann ein grosses
          Masse an Sicherheit garantieren sollte. Die damalige
          Regierung verabschiedete deshalb den EES (Escrowed
          Encryption Standart), der gemeinsam mit dem KES (Key
          Escrow System) dieses Ziel verwirklichen sollte. EES
          sollte das bisherige DES-Verfahren abl÷sen, da das neue
          Verfahren einerseits als sicherer galt, andererseits
          wollte man Verbrechern, die ihre Rechner zu
          kryptografischen Festungen ausgebaut hatten, das
          Handwerk legen.

          Das Wichtigste aber an dieser Initiative war aber ein
          integrierter Hardware-Chip, der sogenannte
          Clipper-Chip, der die eigentlichen
          Sicherheitsmassnahmen darstellen sollte. Die Idee war,
          dass Verschlⁿsselungssystem fⁿr jederman implementiert
          werden konnte, um ein Entschlⁿsseln von Dritten zu
          verhindern. Doch davon ausgenommen sollten autorisierte
          Stellen der Regierung sein. Sie sollte in der Lage
          sein, bei VerbrechensbekΣmpfung verschlⁿsselte
          Nachrichten im Klartext lesen zu k÷nnen, und so
          Verschlⁿsselungen benutzende kriminellen Vereinigungen
          (Terroristen, Mafia,...) das Handwerk zu legen.

          Der Clipper-Chip hat aber nicht nur in Amerika Aufsehen
          erregt, und da zahlreiche Proteste zur Folge waren,
          wurde das Projekt vorerst offiziell wegen Geldmangels
          auf Eis gelegt.

     4.4 DES (Data Encryption Standart)

          1975 wird DES (Data Encryption Standart) von NBS
          (National Buerau of Standarts), welches heute als NIST
          (National Institute of Standards and Technology)
          Erscheinung tritt, der NSA (National Security Agency)
          und IBM (International Business Machines) entwickelt.
          Dieser Algorithmus wurde vom DoD (Department of
          Defense) und der der NSA (National Security Agency)
          1977 zum ÷ffentlichen Verschlⁿsselungsstandart erklΣrt.
          Er wird seitdem in sehr vielen Bereichen eingesetzt,
          darunter auch im Banken- und Finanzwesen. DES (Data
          Encryption Standart) verwendet einen geheimen
          56-Bit-Schlⁿssel, dessen LΣnge nicht variabel ist, und
          basiert auf einer BlocklΣnge von 64 Bit. Nach jeweils 5
          Jahren fand eine Untersuchung statt, der Zahn der Zeit
          nicht zu arg am Algorithmus genagt hat. Er bestand den
          Test in den Jahren 1987 und 1992/93, und wurde erst
          1998 durch den AES (Advanced Encryption Standart)
          abgel÷st.

          Es gibt 4 als unsicher und ungⁿnstig geltende
          Schlⁿssel, welche 0101010101010101, FEFEFEFEFEFEFEFE,
          1F1F1F1F1F1F1F1F und E0E0E0E0E0E0E0E0 lauten. Diese
          k÷nnen zu einer Involution fⁿhren. Es gibt nur 256,
          also 7.2x1016 verschiedene Schlⁿssel. Das gilt im
          Zusammenhang mit heutigen technischen Hilfsmitteln als
          zu klein, und somit unsicher. Ein Ausweg aus dem
          Problem des zu kleinen Schlⁿsselraums bietet die
          mehrfache Chiffrierung mit verschiedenen Schlⁿsseln,
          wenn das Verfahren keine Schlⁿsselgruppe bildet. DES
          (Data Encryption Standart) definiert im Allgemeinen
          keine Gruppe. Die Anzahl der verschiedenen
          Chiffrierungen, die durch mehrfache DES-Anwendung mit
          verschiedenen Schlⁿsseln erreicht werden kann, betrΣgt
          mindestens 102499. Man sollte die tatsΣchlich
          erreichbare KomplexitΣtssteigerung mittels eines
          Meet-in-the-middle-Angriffs nicht ausser Acht lassen.

          DES (Data Encryption Standart) gilt als einer der meist
          durchleuchtesten Standarts fⁿr Verschlⁿsselungen. In
          all den Jahren wurden nie offensichtliche MΣngel
          offengelegt, also kann der Algorithmus selber als sehr
          sicher eingestuft werden. Doch zugleich bleiben gewisse
          Zweifel, ob nicht doch Hintertⁿren fⁿr die NSA
          existieren, da sie ja stark an der Einfⁿhrung des
          Standarts beigewohnt haben. Auch Frontpage von
          Microsoft benutzt DES-Verschlⁿsselungen.

     4.5 IDEA (International Data Encryption Standart)

          Dies ist der im Jahre 1990 an der ETH Zⁿrich von Xuejia
          Lai und James Massey  vorgeschlagene Nachfolger des PES
          (Proposed Encrypton Standart). Der erste Entwurf von
          IDEA (International Data Encryption Standart) wurde
          PEES genannt. Genau wie der DES ist es eine
          64-Bit-Blockchiffrierung, welche aber mit einer auf 128
          Bit vergr÷sserten SchlⁿssellΣnge arbeitet. Durch die
          Reduktion der Iterationen auf die HΣlfte derer des DES
          und dadurch, dass es keine Permtationsoperationen gibt,
          bleibt die Rechenzeit bei gleichzeitiger Steigerung der
          Sicherheit unter der ihres populΣren VorgΣngers.
          Besonders interessant ist, dass keine Bitoperationen
          eingesetzt werden, sondern drei verschiedene
          Operationen auf 16-Bit-Bl÷cken:

             * Bitweise Addition zweier Zahlen ohne ▄bertrag
               (XOR).
             * Addition zweier Zahlen ohne Berⁿcksichtigung
               des ▄bertrags ⁿber 2^16 hinaus.
             * Multiplikation zweier Zahlen und Bildung des
               Restes nach Division durch 2^16+1. Hierbei
               werden 0 und 2^16
             * besonders behandelt: Vor Beginn der
               Multiplikation wird eine 0 durch 2^16
               ersetzt, das Ergebnis 2^16
             * wiederum wird als 0 interpretiert. Daraus
               folgt: 0 x 0 = 1.

          Der 64-Bit-Klartextblock wird in 4 16-Bit-Bl÷cke
          aufgeteilt. 8 (bis auf die Teilschlⁿssel) identische
          Runden und die Abschluss-Transformation fⁿhren zum
          64-Bit-Geheimtextblock. Der 128-Bit Schlⁿssel wird in 8
          16-Bit Teilschlⁿssel aufgeteilt. Dann wird jede dieser
          Ausplittungen um 25 Bitpositionen zyklisch nach links
          verschoben und erneut in 8 16-Bit Teilschlⁿssel
          aufgeteilt. Weitere zyklische Verschiebungen und
          Aufteilungen dieser Art schliessen sich. Insgesamt
          werden 52 Teilschlⁿssel generiert.

          Die eigentliche Verschlⁿsselung lΣuft so ab, dass ein
          Klartextblock von 64 Bit LΣnge in vier Bl÷cke zu je 16
          Bit eingeteilt wird, die anschliessend dem Verfahren in
          Abb. 4 unterworfen werden. Dargestellt ist nur der
          erste Durchlauf, das Verfahren wird achtmal angewendet.

          Dechiffrieren erfolgt mit zu den Teilschlⁿsseln
          inversen Teilschlⁿsseln in (wie gewohnt) umgekehrter
          Reihenfolge. Es gibt eine Klasse von als schwach
          geltende Schlⁿssel. Jene sind aber in der Praxis leicht
          zu vermeiden. Aus diesem Grunde gilt IDEA
          (International Data Encryption Standart) als einer der
          stΣrksten ÷ffentlichen Krypto-Algorithmen.

          IDEA (International Data Encryption Standart)
          unterliegt dem Patentschutz, und geh÷rt somit der Firma
          Ascom Systec. Seine grosse Berⁿhmtheit erlangte IDEA
          (International Data Encryption Standart) dank seines
          Einsatzes bei PGP (Pretty Good Privacy). IDEA gilt
          grundsΣtzlich als besseres Verfahren, weder DES, was
          die differentielle Kryptoanalyse von Biham und Shamir
          bewies.

     4.6 ROT13 - Monoalphabetische Verschlⁿsselung

          Die wohl bekannteste Form einer symmetrischen
          Verschlⁿsselung ist die vom r÷mischen Herrscher Julius
          CΣsar erfundene Monoalphabetische Verschlⁿsselung.
          Dabei werden die Buchstaben im Alphabet vertauscht.
          Dabei kann aus einem "a" ein "f", und aus einem "f" ein
          "l" werden.

          Monoalphabetische Verschlⁿsselungen mit einer
          SchlⁿssellΣnge von 1 Bit werden auch noch in unserer
          Zeit eingesetzt. Vor allem im Internet wird der
          ROT13-Algorithmus oft in Newsgroups verwendet, um
          m÷glicherweise unerwⁿnschte oder anst÷ssige Nachrichten
          zu posten. Dabei wird jeder Buchstabe des Alphabets mit
          einem Buchstaben des um 13 Zeichen verschobenen
          Alphabets ersetzt. Der Buchstabe "A" wird dann durch
          ein "N" ersetzt, "N" wird wiederum durch "A" ersetzt
          und "Z" durch "M". Viele aktuelle Leseprogramme fⁿr
          Newsgroups k÷nnen mit ROT13 verschlⁿsselte Nachrichten
          per Tastendruck chiffrieren bzw. dechiffrieren.

          Hier ist ein Beispiel fⁿr einen mit ROT13
          verschlⁿsselten Text:

                  Klartext                      Mit ROT13
                                                verschlⁿsselt

                  Ich wⁿrde                     Vpu jⁿeqr
                  hier                          uvre
                  gerne                         trear
                  meine                         zrvar
                  anst÷ssige                    nafg÷ffvtr
                  Meinung                       Zrvahat
                  hinschreiben,                 uvafpuervora,
                  m÷chte                        z÷pugr
                  aber aus                      nore nhf
                  H÷flichkeitsgrⁿnden           U÷syvpuxrvgfteⁿaqra
                  ungern                        hatrea
                  jemand                        wrznaq
                  damit                         qnzvg
                  belΣstigen.                   oryΣfgvtra.

          Gerne m÷chte ich das Prinzip dieser
          Verschlⁿsselungstechnik in einem Basic-Quelltext
          wiedergeben, damit damit hervorragend die VorgΣnge, die
          fⁿr das Durchfⁿhren dieser Technik darstellbar ist.
          Folgend der Quelltext eines kleinen Programms, das
          jeden Buchstaben eines Textes beliebiger LΣnge mit
          einem Buchstaben des um 13 Stellen verschobenen
          Alphabets austauscht:

          10 CLS
          20 PRINT "GEBE DEN ZU CODIERENDEN TEXT EIN!"
          25 INPUT K$
          30 FOR I = 1 TO LEN ( K$ )
          40 X$ = MID $ ( N$, I, 1 )
          50 C = ASC ( X$ ) + 13
          60 IF C > 255 THEN C = C - 255
          70 C$ = C$ + CHR$ ( C )
          80 NEXT I
          90 PRINT "DIE CODIERTE NACHRICHT LAUTET:"
          95 PRINT C$

          Natⁿrlich mutet der Quelltext zur Verschlⁿsselung noch
          zur Publikation des Sources zur Entschlⁿsselung an. Bei
          jenem werden die Buchstaben des um 13 Stellen
          verschobenen Alphabetes mit dem original Alphabet
          ausgetauscht:

          10 CLS
          20 PRINT "GEBE DEN ZU ENTSCHL▄SSELNDEN TEXT EIN!"
          25 INPUT V$
          30 FOR I = 1 TO LEN ( V$ )
          40 X$ = MID$ ( V$, I, 1 )
          50 C = ASC ( X$ ) - 13
          60 IF C < 0 THEN C = C + 255
          70 D$ = D$ + CHR$ ( C )
          80 NEXT
          90 PRINT "DIE DECODIERET NACHRICHT LAUTET:"
          95 PRINT D$

          Leider kann sich heuter ein weit weniger vreites
          Spektrum an Personen an der logischen KomplexitΣt von
          Basic erfreuen, und arbeitet mit anderen
          Programmiersprachen. Damit jener nicht zu verachtenden
          Personengruppe keine Mussgunst zugeschrieben wird,
          m÷chte ich noch gerne einen Quelltext fⁿr die
          Handhabung eines Textes durch ein Webinterface eines
          HTML-Dokuments dank Java-Script ver÷ffentlichen. Das
          Script dient gleichermassen zur Ver-, wie auch
          Entschlⁿsselung eines beliebig langen Textes:

          &lt;script LANGUAGE="JavaScript" TYPE="text/javascript">

          <!--

          function rot_13()
          {
                  alert("Diese Funktion erfordert JavaScript
          1.1!")
          }

          // -->

          &lt;/script>
          &lt;script LANGUAGE="JavaScript1.1"
          TYPE="text/javascript">

          <!--

          function rot_13(obj)
          {
                  var keycode     = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                  var text        = new
          String(obj.form.Text.value)
                  var textrot     = new String()

                  for(var i = 0; i < text.length; i++)
                  {
                          var codechar    = text.substring(i, i +
          1)
                          var pos =
          keycode.indexOf(codechar.toUpperCase())

                          if(pos >= 0)
                          {
                                  pos = (pos + keycode.length /
          2) % keycode.length
                                  codechar        = (codechar ==
          codechar.toUpperCase()) ?

          keycode.substring(pos, pos + 1) :

          keycode.substring(pos, pos + 1).toLowerCase()
                          }
                          textrot = textrot + codechar
                  }
                  obj.form.Text.value     = textrot
          }

          // -->

          &lt;/script>

     4.7 RC2 (Rivest Cipher 2)

          Diese Verschlⁿsselungen wurde von Ron Rivest erdacht
          und in die Tat umgesetzt. Daher bedeutet RC auch
          "Rivest Cipher". Sie bieten, im Gegensatz zum DES, die
          M÷glichkeit, eine gr÷ssere und individuellere
          Sicherheit, da die SchlⁿssellΣnge frei definiert werden
          darf. Irrwitzigerweise ben÷tigt es aufgrund des
          Waffenexportverbotes der Vereinigten Staaten, unter
          jenes auch starke Verschlⁿsselungen fallen, eine
          Erlaubis fⁿr dessen Nutzung ausserhalb von Amerika,
          durch die NSA (Natiolan Security Agency).

          Es liegt zwar offiziell eine BeschrΣnkung der
          SchlⁿssellΣnge auf 40 Bit vor (eigentlich 56 Bit fⁿr
          Zweigstellen amerikanischer Firmen), jedoch gibt es die
          M÷glichkeit, eine zusΣtzliche, bis 40 Bit lange
          Zeichenkette zu benutzen, die an den Schlⁿssel
          angehΣngt wird. Falls diese Zeichenkette wirklich nicht
          von Dritten eingesehen werden kann, ist eine
          Entschlⁿsselung praktisch mit den heutigen technischen
          Hilfsmitteln sinnlos. Zudem kann der Algorithmus
          mehrfach auf den zu verschlⁿsselten Text angewandt
          werden, womit die effektive LΣnge des Schlⁿssels
          vergr÷ssert wird. Wegen der amerikanischen
          ExporteinschrΣnken gewinnen diese Verfahren fⁿr
          Entwickler, welche ihre Produkte aus den Staaten
          exportieren wollen, immer mehr an Bedeutung.

     4.8 RC4 (Rivest Cipher 4)

          RC4 wurde von RSA Data Security, Inc. entwickelt, wobei
          das Design des Algorithmus jedoch geheimgehalten wird.
          Vor einiger Zeit jedoch tauchte ein Posting im Usenet
          auf, in welchem ein (wie behauptet wurde) aquivalenter
          Quellecode vorgestellt wurde. Es wird als sehr
          wahrscheinlich angenommen, dass der vorge-stellte
          Algorithmus wirklich aquivalent zu RC4 ist. Der
          Algorithmus ist sehr schnell, seine Sicherheit jedoch
          noch weitgehend unbekannt. RC4 ist im Prinzip ein
          Pseudo-Zufallszahlengenerator, wobei die Zahlen mit den
          zu verschlⁿsselnden Daten durch XOR verknⁿpft werden.
          Aus diesem Grund, sollte nicht zweimal der gleiche
          Schlⁿssel fⁿr die gleichen Daten verwendet werden.

     4.9 RC5 (Rivest Cipher 5)

          RC5 wurde 1995 von Ron Rivest entwickelt, und stellt
          SchlⁿssellΣngen zwischen 40 und 128 Bit zur Aus-wahl.

          Um einen geheimen 64-Bit-Schlⁿssel zu knacken, welcher
          mit RC5 generiert wurde, mⁿssen 2^64 =
          18.446.744.073.709.551.616 verschiedene Schlⁿssel
          ausprobiert werden. Dies ist der 8-fache Aufwand
          gegenⁿber einem 56-Bit-Schlⁿssel. Ein einzelner Pentium
          II 400 MHz wⁿrde ⁿber eine halbe Million Jahre
          ben÷tigen, um alle 2^64 Schlⁿssel auszuprobieren.

     4.10 SAFER

          Safer ist ein Byte-orientierter Block
          Verschlⁿsselungsalgorithmus welcher erstmals auf der
          Crypto'95 von James L. Massey vorgestellt wurde. Es
          gibt Versionen mit 64 Bit und 128 Bit Schlⁿsseln.

     4.11 Triple-DES (Data Encryption Standart)

          Dieses von IBM Mitte der 70er Jahre entwickelte,
          relativ langsame, symmetrische
          Verschlⁿsselungsverfahren ist sehr gut bekannt, und
          wurde bestens auf das m÷gliche Bestehen von
          Schwachstellen untersucht.

          Triple-DES nimmt drei verschiedene Schlⁿssel
          hintereinander, wobei mit dem zweiten entschlⁿsselt
          wird und mit dem ersten und dritten verschlⁿsselt.

     4.12 Twofish

          Der Twofish Algorithmus wurde von dem Counterpane Team
          (Bruce Schneier u.a.) entwickelt und ist ein
          Blockalgorithmus, welcher mit einer Blockgr÷▀e von 128
          Bit arbeitet, und mit einer Schlⁿsselgr÷▀e von bis zu
          256 Bit ⁿber 16 Runden zurecht kommt.

5.0 Assymmetrische Kryptoalgorithmen

     Im Jahr 1976 beschrieben Whitfield Diffie und Martin E. Hellman
     die M÷glichkeit einen Verschlⁿsselungsalgorithmus zu entwickeln,
     der auf zwei unterschiedlichen Schlⁿsseln basiert. Ein Schlⁿssel
     ist dabei ÷ffentlich, der andere geheim. Dabei ist eine mit einem
     ÷ffentlichen Schlⁿssel verschlⁿsselte Nachricht nur wieder mit
     dem dazugeh÷rigen privaten Schlⁿssel dechiffrierbar.

     Das erste ktyptographische Verfahren, welches wirklich eine
     assymmetrische Verschlⁿsselung benutzte, war RSA.

     Die beiden gr÷ssten Nachteile sind die Schwierigkeit des geheimen
     und m÷glichst versteckten Austausches des ÷ffentlichen
     Schlⁿssels, und der Rechenaufwand, der sich negativ auf die
     Geschwindigkeit einer Session auswirkt. Normalerweise werden die
     ÷ffentlichen Schlⁿssel wΣhrend einer Sessioen ausgetauscht, die
     mit einer symmetrischen Verschlⁿsselungstechnik vor Blicken
     unberechtigter Personen geschⁿtzt ist.

     5.1 RSA (Rivest, Shamir, Adleman)

          Dieses Verfahren wurde 1977/78 von Ron Rivest (Siehe
          die RC-Algorithmen!), Adi Shamir und Len Adleman am MIT
          entwickelt, und gilt seitdem als der einzige allgemein
          anerkannte und implementierte Ansatz fⁿr die
          Public-Key-Verschlⁿsselung. RSA wurde patentiert bis
          ins Jahre 2000, jedoch noch  innerhalb der USA. Es ist
          frei erwerbbar. Der Name dieser Methode wurde jeweils
          aus den Anfangsbuchstaben der Nachnamen dessen Erfinder
          erzeugt. RSA verwendet fⁿr die Schlⁿsselerzeugung zwei
          m÷glichst hohe Primzahlen, aus deren Produkt sich ein
          privater und ÷ffentlicher Schlⁿssel ableiten lΣsst.

          RSA gilt als das wohl berⁿhmteste asymmetrische
          Verschlⁿsselungsverfahren. Dessen Name wurde durch die
          Anfangsbuchstaben der drei Entwickler Rivest, Shamir
          und Adleman gebildet. Als RSA 1977 das erste mal der
          ╓ffentlichkeit prΣsentiert wurde, war es das erste
          ÷ffentlich bekannte Verschlⁿsselungsverfahren, welches
          die 1967 von Diffie und Hellman publizierte Idee eines
          ÷ffentlichen Schlⁿssels tatsΣchlich einsetzen konnte.

          RSA basiert auf Rechnungen der ganzen Zahlen modulo ab,
          wobei p und q zwei Primzahlen sein mⁿssen.
          Modulo-Operationen funktieren, indem mit dem Rest einer
          Divisionen gerechnet wird, also mit dem Rest von p und
          q. Wenn nun zum Beispiel pq = 15 ist, dann sind
          folgende Terme korrekt:

          2 + 5 = 7
          2 * 5 = 10
          4 * 5 = 5
          4 * 4 = 1
          1 / 4 = 4

          Von besonderem Interesse sind hier die
          Exponentialfunktionen:

          5 ^ 2 = 10
          4 ^ 7 = 4

          Es ist bis heute kein Verfahren bekannt, diese
          Rechen-Operationen umzukehren. Somit ist also die
          Aufl÷-sung von p ^ 5 = 12 nicht m÷glich mit
          mathematischen M÷glichkeiten zu l÷sen.

          Weiterhin ist p ^ {phi (x)} ~= 1 (mod x) eine sehr
          interessante Beziehung, welche schon Euler bekannt war.
          Das ~=-Zeichen zeigt an, dass die oben erwΣhnte
          Modulo-Operation durchgefⁿhrt wird, und zwar mod x. phi
          (x) ist die Eulersche Phi-Funktion. Fⁿr uns wichtig ist
          jedoch nur, dass fⁿr die Primzahlen p und q phi (pq) =
          (p - 1)(q - 1) gilt:

          a ^ {phi (abq)} ~= 1 (mod ab)
          a ^ {(k * phi (ab))} ~= 1 (mod ab)
          a ^ {(k * phi (ab) + 1)} ~= a (mod ab)

          Wenn wir nun zwei Zahlen d und e einfⁿhren, von denen
          wir verlangen, dass de = k * phi (pq) + 1 gelten soll
          (k sei eine beliebige ganze Zahl, ungleich null), dann
          erhalten wir (ab sofort alle Rechnungen modulo pq):

          a ^ de = a
          a ^ d = b
          b ^ e = a

          Hierbei reicht jedoch die Kenntnis von b und d nicht
          aus, um a zu berechnen. RSA basiert nun darauf, dass
          als ÷ffentlicher Schlⁿssel nun d fungiert, und das
          Produkt pq ver÷ffentlich werden, und die Nachricht a
          damit vershlⁿsselt wird. Die verschlⁿsselte Nachricht b
          kann dann bedenkenlos versendet werden, da sie ohne e
          nicht entschlⁿsselt werden kann.

          Der Verschlⁿsselungsablauf von RSA funktioniert wir
          folgt:

             * Man wΣhlt zwei verschiedene, m÷glichst grosse
               Primzahlen p, q.
             * Dann bildet man ihr Produkt n = p q. Weil p
               und q prim sind, ist PHI(n) = (p-1) (q-1).
             * Es mⁿssen zwei Zahlen e und d gefunden
               werden, fⁿr welche e d == 1 (mod PHI(n))
               gilt. Man wΣhlt zuerst d so, dass d relativ
               prim zu PHI(n) ist. Ideal ist eine Primzahl d
               > max(p,q) und d < PHI(n)-1. Um e zu finden,
               muss man eine L÷sung mit ganzzahligen x und y
               fⁿr die Gleichung x d + y PHI(n) = 1 fin-den.
               Es gilt x d == 1 (mod PHI(n)). Setzt man e =
               x mod PHI(n), dann ist auch e d == 1 (mod
               PHI(n)).
             * e und d sind die Schlⁿssel, n der sogenannte
               Modul. Die Verschlⁿsselungsfunktion ist E(x)
               = xe mod n, die Entschlⁿsselungsfunktion ist
               D(x) = xd mod n. Da bei den Funktionen E(x)
               und D(x) modulo n ge-rechnet wird, muss x < n
               sein. Jede Nachricht X muss so in Bl÷cke x1,
               x2, ... unterteilt werden, dass x1, x2, ... <
               n sind.

          Um das Verfahren m÷glichst sicher zu machen, mⁿssen
          folgende Regeln befolgt werden, damit die
          Faktorisierung von n = p q schwierig genug ist:

             * p q sollen gr÷sser sein als 10100. Es ist
               sinnvoll, eine m÷glichst grosse Zahl d, mit d
               < PHI(n)-1, zu wΣhlen, damit d nicht so
               schnell ermittelt werden kann.
             * p und q sollen in der LΣnge um einige Stellen
               variieren.
             * (p-1) und (q-1) sollen grosse Primfaktoren
               enthalten.
             * Der kleinste gemeinsame Teiler von (p-1) und
               (q-1) sollte m÷glichst klein sein.

          1993 schΣtzte man, dass fⁿr die Zerlegung der
          130-stelligen Zahl
          114'381'625'757'888'867'669'235'779'976'146'612'010'128'296'721'242'362'562'561'842'935'706'935'245'733'897'830'597'123'563'958'705'058'989'075'147'599'290'026'879'543'541
          in ihre zwei Primzahlen Millionen von Jahren
          dahinscheiden mⁿssten. TatsΣchlich gelang es einer
          Gruppe von ⁿber 600 Akademikern und Hacker, die sich
          ⁿber das Internet koordinierten, bereits ein Jahr
          spΣter die Aufl÷sung. Mathematiker neh-men heute an,
          dass bei einer VerlΣngerung des Schlⁿssels auf 250
          Stellen mit einer Zerlegung nicht einmal in einer
          Million Jahren zu rechnen sein k÷nne.

          Die Angriffsm÷glichkeiten auf RSA bestehen nun darin,
          aus a und b e zu berechnen. Dies gilt jedoch mo-mentan
          als unrealistisch zu durchfⁿhrendes Unterfangen.
          Desweiteren kann man aus pq und d versuchen e zu
          berechnen. Dazu muss pq in seine Faktoren zerlegen, was
          ebenfalls nach heutigem technischen Stand nicht in
          annehmbarer Zeit durchfⁿhrbar ist. Einer andere Attacke
          wird die Durchfⁿhrung erm÷glicht, sobald eine
          verschlⁿsselte Nachricht an verschiedene EmpfΣnger
          geschickt wird. Dies wird jedoch nur m÷glich, wenn a an
          mehrere EmpfΣnger verschlⁿsselt wird, wobei dasselbe d
          verwendet wurde. Dazu muss man dann seine
          mathematischen FΣhigkeiten aus dem ─rmel schⁿtteln.
          Dieser Fehler kann im Gebrauch mit PGP (Pretty Good
          Privacy) nicht passieren, da beim Verschlⁿsseln einer
          Nachricht fⁿr viele verschiedene EmpfΣnger der
          IDEA-Schlⁿssel jedesmal mit einer neuen Zufallszahl
          berechnet wird.

          Public-Key-Verschlⁿsselungen stellen trotz Knackbarkeit
          der Schlⁿssel ein relativ hohes Masse an Sicher-heit
          dar, da erstens der ÷ffentliche Schlⁿssel ⁿber
          ungesicherte Datenleitungen weitergegeben werden kann,
          und zweitens bei lΣngeren Verbindungen der
          RSA-Schlⁿssel nach einer vorgegebenen Zeitspanne
          geΣndert werden kann. Ein Entschlⁿsseln einer
          Kommunikation ist somit nach einer gewissen Zeit
          sinnlos.

6.0 Einwegverschlⁿsselungs-Algorithmen

          Einwegverschlⁿsselungen werden fⁿr das Signieren von
          Nachrichten und das Erstellen von codierten
          Passw÷rtern, zum Beispiel auch unter UNIX/Linux,
          genutzt. Dabei wird ein Hash-Wert aus der
          unverschlⁿsselten Eingabe errechnet

          6.1 DH/DSS

               Das Diffie-Hellman-Verfahren wurde vom NIST
               (National Institute of Standarts and
               Technology) zusammen mit der NSA (National
               Security Agency) entwickelt und wurde nocht
               nicht sonderlich gut erforscht. Das Patent
               liegt bei der US-Regierung, die Nutzung des
               Verfahrens ist jedoch kostenlos.

          6.2 MD5 (Message Digest 5)

               MD aus dem Jahre 1991 bedeutet ausgeschrieben
               Message-Digest, und stellt ein Verfahren zur
               Erzeugung von digitalen Unterschriften
               (Hash-Werten) dar. Er gilt als Nachfolger von
               MD2 und MD4, wobei all jene von Ron Rivest
               entwickelt wurden. Er wird in RFC 1321
               definiert.

               Dieser Algorithmus akzeptiert als Eingabe
               eine Botschaft beliebiger LΣnge,und erzeugt
               davon eine Art Fingerabdruck, oder eine
               Botschaftsverarbeitung von 128 Bit LΣnge als
               Ausgabe. Die Chancen, dass aus zwei
               unterschiedlichen Texten ein identischer
               Fingerabdruck generiert werden kann, ist
               beinahe unendlich, aber nicht
               auszuschliessen.

               Den Boer und Bosselaers wurden fⁿndig, was
               Schwachstellen anbelangt. Van Oorschot und
               Wiener liessen dazu genauere AbschΣtzungen
               verlauten.

               Als Zusatz zu MD5 gibt es "Noiz", ein
               Softwarepaket zur Akkumulation zum Erstellen
               von kryptographisch-starken Zufallszahlen.

          6.3 SHA/SHA1 (Secure Hash Algorithm)

               Ein zum Signieren gedachter Secure Hash
               Algorithm, welcher vom NIST und der NSA
               entwickelt wurde. SH1 ist der verbesserte
               Nachfolger vom im Jahre 1994 erschienenen
               SHA. Er ist relativ langsam, gilt jedoch als
               sicherer, als MD5.

  ------------------------------------------------------------------------
Siehe auch Algebra, Algorithmus, Arithmetik, Brute-Force, Kryptoanalyse,
Kryptografie, Kryptologie, Mathematik, PGP, Trigonometrie, Verschlⁿsselung
  ------------------------------------------------------------------------
                               Dieser Text ist unverfΣlscht frei kopierbar!
                                         Marc Ruef &lt;marc.ruef@computec.ch>
                                                    http://www.computec.ch/

```

</div>
