---
title: "P_CIA-01"
ezine: "paranoid"
---

# P_CIA-01

**Ezine:** paranoid

<div className="ascii-content">

```
                                                       Buenos Aires, Argentina
                                                                  Mayo de 1997





                           Conceptos Básicos en Unix
                           ========================= 

                                  por Hackeka
                                  invitado especial: OmYkron

                               members of C.I.A.


                        Donde Encontrarnos:

                              hackeka@hotmail.com
                              OmYkron@gratismail.com (SI! en castellano, Y?!)

                           The X BBS: (54-1) 750-8957


Indice
------

1 Introducción
2 Qué es Unix?
3 Breve historia de Unix
4 Arquitecturas del Kernel
5 Comparacion UNIX - DOS - Win 95 - Win NT
6 FileSystem en Unix
7 Unix Shells
8 Utilidades POSIX
9 Administración de Procesos en Unix
10 Manejo de Memoria en Unix
11 Problemas de Seguridad
12 Comentario Final


 ------------------------------------------------------------------------------


1 Introduccion
------------

En este texto, voy a explicar brevemente los conceptos basicos de Unix, desde
el punto de vista de un programador ex-DOS. Esta dirigido primariamente a
los que recientemente instalaron Linux/Minix/etc. en su PC. Recomiendo leer
los manuales de instalacion/howtos/etc que generalmente vienen incorporados,
ya que no voy a escribir acerca de alguna implementacion en particular, sino
que voy a ponerme un poco mas en un punto de vista teorico/standard. Esto no
significa no-practico, se incluye source (codigo fuente) correspondiente,
que siempre esta en lenguaje C.

El enfoque tambien esta influenciado desde el punto de vista de
seguridad/inseguridad correspondiente.



2 Que es Unix?
------------

Es un sistema operativo multitarea, multithreads, multiusuario. Ademas
generalmente soporta memoria virtual, paging, cache, y seguridad basica. 

Multitarea o multitasking significa que puede llevar a cabo simultaneamente
varios tipos de servicios de I/O, no necesariamente relacionados entre si (por
ejemplo Tty task o Disk task).

Multithreads significa que puede haber mas de un proceso corriendo al mismo
tiempo sobre el mismo codigo. Thread en castellano significa hilo, por el
hilo del proceso...

Multiusuario... go figure...

Memoria virtual es la emulacion de memoria RAM con parte de un disco.

Paging es el sistema de division de memoria en paginas (pages) para asi
tener en la memoria RAM real las partes mas usadas, seleccionandolas
dinamicamente.

Cache es la tecnica de guardar los bloques de disco mas frecuentemente
utilizados en memoria RAM, para una mejor performance y menor desgaste del
disco. En DOS se utiliza generalmente el programa smartdrive, aunque no esta
muy bien diseniado, ya que frecuentemente trae errores de disco.

Unix es el sistema operativo mas usado en los ambientes mainframe,
supercomputing, y toda otra computadora 'grande'. Fue escrito en lenguage C,
y tiene mas de 20 anios. Una de sus cualidades mas importantes es su
portabilidad, ya que la mayor parte de su source esta en C, lo que permite
crear nuevas versiones para distintas plataformas con facilidad. En contraste
con el DOS, que esta escrito en assembly 8086 y que no es facil de portar
(probablemente imposible). Esta orientado muy fuertemente hacia networking,
especialmente de tipo TCP/IP (protocolos de internet).

Hoy en dia existen muchas versiones de Unix, siendo las mas importantes:
SUNOS, Solaris, MACH, HP-UX, SCO, Irix, AIX, BSD, System V, y POSIX.

Todas estan muy ligadas, pero hay ciertas incompatibilidades entre si. Hoy
en dia hay una tendencia general hacia el standard POSIX (incluidos Linux y
Minix).



3 Breve Historia de Unix
----------------------

En los '60s las computadoras costaban mucho dinero, y solo se podia usar
programas secuencialmente, puestos uno atras del otro en una cinta
magnetica. El M.I.T. se junto con AT&T para hacer un sistema que pudiera
correr varios procesos (programas) al mismo tiempo. Asi nacio el MULTICS:
MULT iplexed I nformation and C omputing.

El MULTICS fracaso, pero un investigador del grupo, Ken Thompson, siguio
desde AT&T su investigacion, creando un nuevo sistema operativo. El nombre
nacio de una broma de Brian Kernighan, otro investigador de AT&T, que lo llamo
UNICS (por UNIplexed Information and Computing), y luego por un error
tipografico paso a ser UNIX.

Para buscar una mejor portabilidad, crearon un nuevo lenguaje de alto nivel
que fuera practico y portable. Asi nacio el C, que se convirtio en el
lenguaje dominante desde ese entonces.

Reescribieron el UNIX en C, y dado que AT&T era un monopolio que tenia
permitido realizar negocios en otras areas que no fueran telefonia, se
proveyo el source a las universidades que lo pidieron por poco dinero.

Una de estas universidades fue Berkeley, que junto con el Departamento de
Defensa de USA creo su propia version, Berkeley Software Distribution,
generalmente conocida como BSD. A esta version se le agrego soporte para
networking tipo TCP/IP. Y uno de los adelantos mas importantes fue el
soporte de memotia virtual en 1978. Ademas se le agregaron varias utilidades
como un nuevo shell mas amigable (csh), y el editor de textos vi.

Muchas empresas basaron sus versiones en la de Berkeley, lo que creo una
segunda version de UNIX incompatible con la de AT&T.

La Universidad de Stanford creo SUN Microsystems, que vendio sus versiones
de UNIX, que incluyen Solaris, a principios de los '80s.

En 1983 AT&T lanza System V, que fue un gran impacto entre los que seguian a
la version original, pero que no afecto a las que seguian a Berkeley.
Continuaba la incompatibilidad.

Para lograr unir finalmente System V y BSD, el comite de standards IEEE creo
el proyecto POSIX. La mayoria de los unixes tienden actualmente a este nuevo
standard.

Lamentablemente IBM junto con otras empresas creo un consarcio llamado Open
Software Foundation, que agrego nuevas caracteristicas a su version para
hacerlo incompatible intencionalmente con el de AT&T. Entre ellas esta el
sistema de ventanas X11.

Lo mas comico es que IBM creo por su cuenta otra version, AIX, por supuesto
aun mas incompatible.

Por otro lado, AT&T y SUN crearon variantes con la sguridad en primer plano.
Estas fueron MLS (Multi Level Security) y System V/MLS (tambien VMS). Las
que tienen un nivel de seguridad B1 segun el Departamento de Defensa de USA.

Microsoft comercializa el Xenix, que si bien la parte interna no es unix,
aparenta ser un clon. Por su lado Trusted Information Systems Inc.
desarrollo una version 'segura' del Xenix, que actualmente tiene
clasificacion B2. Hewlett Packard desarrollo el HP-UX, el cual actualmente
llego a grado B1 de seguridad. Silicon Graphics desarrollo el Irix que
tambien actualmente es B1.

En resumen, hay muchas versiones. La mayoria son de kernel tipo monolitico.
Algunas nuevas versiones como el MINIX, buscan volver al microkernel. Otras
versiones nuevas estan orientadas a sistemas distribuidos como el MACH,
y soportan BSD externamente.



4 Arquitecturas del Kernel
------------------------

Existen tres tipos basicos de arquitectura:
      - Monolitica: Es un unico programa sin divisiones donde todas las
                    funciones pueden llamarse entre si sin una estructura o un
                    modulo que las administre y controle.  Esto provoca que
                    cualquiera pueda acceder a la informacion ya que no hay
                    proteccion.
                    Ejemplos: DOS, Linux.

      - De Capas y Niveles: Hagan de cuenta que estos son anillos:
                                      Cada modulo solo se puede comunicar con
        ┌────────────────────────┐    el siguiente o con el anterior.
        │Usr┌────────────────┐   │    Si se modifica un modulo, no se modifican
        │   │1 ┌───────────┐ │   │    los que hay debajo de el, ya que a cada
        │   │  │2┌───────┐ │ │   │    uno se lo puede ver como una caja negra
        │   │  │ │3┌───┐ │ │ │   │    con parametros de entrada y devolucion.
        │   │  │ │ │ n │ │ │ │   │    Establece un cierto tipo de proteccion no
        │   │  │ │3└───┘ │ │ │   │    dando acceso a la informacion a los
        │   │  │2└───────┘ │ │   │    niveles inferiores.
        │   │1 └───────────┘ │   │    Ejemplos: Xinu, OS/2, NT4.
        │Usr└────────────────┘   │
        └────────────────────────┘




      - Microkernel (Cliente - Servidor):
                                         Como su nombre lo indica, se trata que
      ┌───────┐              ┌────────┐  el tamaño del kernel sea lo mas chico
      │Proceso│              │Proceso │  posible.
      │Cliente│              │Servidor│  Cuando un proceso servidor solicita un
      └───────┘   ┌──────┐   └────────┘  proceso determinado al kernel, este se
          |------>│Kernel│-------^       fija quien hizo la solicitud y ejecuta
                  └──────┘               un proceso servidor para atenderlo.
                                         Cuando termina, devuelve un mensaje con
          un resultado al kernel, que procesa el mensaje y le envia la respuesta
          al proceso cliente.
          Las ventajas de esto son varias:
                       - El kernel es modular.
                       - Proteccion (todo se maneja via mensajes al kernel)



5 Comparacion UNIX - DOS - Win 95 - Win NT
----------------------------------------

                     Unix        DOS      Win 95      Win NT
------------------------------------------------------------
Multitarea           SI!         NO        SI          SI
------------------------------------------------------------
Multiusuario         SI!         NO        NO          SI
------------------------------------------------------------
Seguridad            SI!         NO        NO          SI
------------------------------------------------------------
Networking           SI!         NO     (minimo)       SI
------------------------------------------------------------
Paging               SI!         NO     (minimo)       SI
------------------------------------------------------------
Links                SI!         NO        NO          NO
------------------------------------------------------------
Virtual memory       SI!         NO        SI          SI
------------------------------------------------------------
Comunicacion        pipes        --     messages    messages
entre               fifos        --        --          --
procesos           sockets       --        --       sockets
------------------------------------------------------------
Interfaz grafica     SI!         NO        SI          SI
------------------------------------------------------------
Terminal ansi        SI!         SI      emulada     emulada
------------------------------------------------------------
Varios shells        SI!         NO        NO          NO   
------------------------------------------------------------
Plug & Play/Pray     NO          NO        SI (?)      NO
------------------------------------------------------------
Nombre de arch. max. 14/256      8+3      256         256



6 Filesystem en UNIX
------------------

A diferencia del DOS, en unix hay un solo arbol de directorios - no existe el
concepto de "unidad"-, en el que se 'montan' los directorios de las unidades de
disco. El separador del path cambia de '\' a '/'. Por ejemplo el archivo arch1
que se encuentra en el directorio doc, que pertenece a usr, que pertenece al
raiz, se puede referir como /usr/doc/arch1.

Hay ciertos directorios importantes:

        /       .>   RAIZ
        │
        ├─ bin  ->   Binarios (ejecutables) frecuentemente usados
        ├─ dev  ->   Archivos especiales para I/O
        ├─ etc  ->   Administracion del sistema
        ├─ home ->   Archivos personales de usuarios
        ├─ lib  ->   Librerias frecuentemente utilizadas
        ├─ tmp  ->   Archivos temporarios
        ├─ usr  ->   Archivos de usuarios
        └─ var  ->   Archivos de manejo interno del sistema


En UNIX el nombre de un archivo puede tener hasta 14 caracteres, y no es
necesaria la separacion con punto. Ademas es case-sensitive, si tengo un
archivo arch1 no es igual a Arch1 o a aRcH1.

Una de las caracteristicas mas importantes es que se puede hacer links
(conexiones) a cualquier archivo. Esto evita la duplicacion de archivos y
simplifica el uso. Por ejemplo en /home/hackeka tengo un archivo arch1, y
mi amigo omykron quiere usarlo tambien, entonces el en su directorio
/home/omykron puede crear un link a mi archivo:

$ ln /home/hackeka/arch1 /home/omykron/arch1_hackeka

Esto crea un link en /home/omykron llamado 'arch1_hackeka'. Este se puede
usar como culaquier otro archivo, salvo que si se borra no se borra el
archivo original. Pero todos los cambios en el archivo se ven reflejados...

Unix esta orientado al manejo de I/O (input/output) por medio de archivos
especiales ubicados en el directorio /dev. Por ejemplo el primer disco
rigido IDE es /dev/hda, su segunda particion /dev/hda2, la primer particion del
segundo rigido IDE /dev/hdb1, la primer disquetera /dev/fd0, etc.

Otra de las caracteristicas es que los archivos tienen proteccion que la
configura el propietario, para permitir o no la lectura/ejecucion/escritura.
Esto se refleja en 9 bits de permision. 3 para el propietario, 3 para el
grupo propietario, y 3 para el resto de los usuarios. Esto se determina con
la suma binaria de cada terna de bits. Siendo 1 ejecucion, 2 escritura, y 4
lectura...

Por ejemplo, listo los archivos de un directorio:

$ ls -l
 rwxr---wx       1       omykron         cia     5 Aug 12:13 arch1

El bloque de permisos se lee de izquierda a derecha en grupos de tres, a veces
un archivo puede tener una decima letra a la izquierda que indique un tipo
especial de archivo (por ejemplo los links tienen una "l").
El primer grupo (rwx) indica que el dueño del archivo (omykron) puede leer (r),
escribir (w) y ejecutar ese archivo.
El segundo grupo (r--) indica que los usuarios que pertenezcan al mismo grupo
que omykron (cia) van a poder leer el archivo.
El tercer grupo (-wx) dice que TODOS los demas usuarios que no entren a las
otras dos categorias pueden escribir y ejecutar el archivo.

Pero omykron quiere que los que son de su grupo puedan ejecutarlo, y ademas
TODOS los demas usuarios solo puedan ejecutarlo pero NO escribir dentro de el.
Para cambiar los permisos de un archivo se usa el comando "chmod":

$ chmod 751 arch1
$ ls -l
 rwxr-x--x       1       omykron         cia     5 Aug 12:13 arch1

El 751 sale de la suma de los permisos que se quieren otorgar:
        7 = 4 (lectura) + 2 (escritura) + 1 (ejecucion)
        5 = 4 (lectura) + 1 (ejecucion)
        1 = 1 (ejecucion)!

Para cambiar el dueño de un archivo se usa -> chown [usuario] [archivo]
Para cambiar el grupo de un archivo se usa -> chgrp [grupo] [archivo]


Otros 3 bits relativos al uso del archivo son el SUID, el SGID y el sticky
bit. Si un programa tiene SUID (Set User ID), cualquier usuario que ejecute
este programa tendra temporalmente la identidad del propietario del archivo.
Lo mismo con el SGID (Set Group ID) pero con respecto al grupo. El sticky
bit esta para que el programa se 'pegue' al swap (lugar donde se encuentra
la memoria virtual) del disco, permaneciendo alli hasta que lo termine de
usar el proceso correspondiente. No es recomendable usar este servicio ya que
puede saturar la memoria virtual y generar problemas en el sistema
operativo, inclusive una caida de sistema (system crash).

$ ls -l
 rwsr-x--x       1       omykron         cia     5 Aug 12:13 pirulo
 rwxr-S--x       1       omykron         cia     5 Aug 12:13 pepe
 rwxr-x--T       1       omykron         cia     5 Aug 12:13 caca

 pirulo: Tiene SUID activado.
 pepe: Tiene SGID activado.
 caca: Tiene el Sticky Bit activado.


Una de las caracteristicas del filesystem de unix que lo hace uno de los
mejores sistemas multiusuario es que se pueden establecer locks (trabas,
candados) en partes de un archivo, para evitar 'race conditions' (problemas
de procesos utilizando los mismos recursos al mismo tiempo). Si dos procesos
(del mismo usuario o no) utilizan el archivo arch1 al mismo tiempo, el
proceso A podria sobreescribir una parte del archivo que esta leyendo el
proceso B. Si la parte del archivo que A escribe esta relacionada con otra
parte que luego va a escribir, y B lee primero esta otra parte aun no
modificada, B obtendria datos incongruentes (sin sentido).

Para evitar esto, en Unix (POSIX) se crearon los locks. Hay dos tipos de
locks: shared (compartidos), y exclusive (exclusivos):

- Los shared se utilizan para que no se pueda escribir en donde se aplican.
- Los exclusive se utilizan para que no se pueda leer en donde se aplican.
Cualquiera de ellos se puede aplicar a todo un archivo o a una parte, que puede
ser tan pequeña como un byte. En el ejemplo anterior, si el proceso B aplica
un shared lock a las partes criticas del archivo que va a leer, y no hay un
lock exclusivo que abarque esas partes, el proceso A no podria solicitar un
exclusive lock para escribir hasta que B termine de leer. Al liberar B el
shared lock, se le adjudica el exclusive lock a A. Si B intenta nuevamente leer
esa parte, se lo prohibe al no adjudicarsele el shared lock. Esto se refleja en
la siguiente figura:

  B solicita un shared lock desde el byte 3 hasta el 8...
    ___ ___ ___ ___ ___ ___ ___ ___ ___
   | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
   |___|___|_S_|_S_|_S_|_S_|_S_|_S_|___|

  Si A solicita un exclusive lock desde el byte 5 hasta el 9, el sistema
  operativo no se lo adjudica, tiene que esperar.
  Cuando termina de leer, B libera el shared lock...
    ___ ___ ___ ___ ___ ___ ___ ___ ___
   | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
   |___|___|___|___|___|___|___|___|___|

  ... y el sistema le da permiso al proceso A...
    ___ ___ ___ ___ ___ ___ ___ ___ ___
   | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
   |___|___|_X_|_X_|_X_|_X_|_X_|_X_|___|

Los shared locks pueden superponerse entre si, y si un proceso solicita un
exclusive lock sobre una parte de un archivo, tiene que esperar a que todos
los shared locks que hay alli se desactiven.

Esta caracteristica de UNIX es ampliamente utilizada en los programas
administradores de Bases de Datos, en los que se puede establecer locks a un
registro, o a un campo, o a un campo de un registro. Esto depende del
programa...



7 UNIX shells
-----------

El 'shell' es el programa de interfaz entre el usuario y el sistema
operativo, siendo en el DOS el COMMAND.COM. Es el encargado de interpretar
los comandos, proveyendo un prompt.

En unix se usa tradicionalmente el programa sh, que se ubica en el
directorio /bin. Pero tambien estan el csh y el ash.

En unix se puede 'redirigir' el input y el output de un proceso. Normalmente
el input es el teclado y el output el el monitor, pero con el uso de '<' y
de '>' se puede cambiar, por ejemplo, para el programa sort que ordena todo lo
que se le envie por el input y lo imprime en el output:

siendo in y out dos archivos...

$ sort &lt;in       --------> imprime en pantalla el contenido de in ordenado
$ sort &lt;in >out  --------> escribe en out el contenido de in ordenado

Pero esto no es practico para le comunicacion entre procesos, ya que se
necesita un archivo intermedio. Lo que se busca es vincular el out de un
proceso con el in de otro. Esto se llama pipe (canio, tubo), y se implementa
con el simbolo '|'. Por ejemplo:

en vez de
$ sort &lt;in >out1
$ head &lt;out      -------> imprime las 30 primeras lineas de out1 en pantalla
$ rm out1        -------> borra out1

se puede ordenar

$ sort &lt;in | head ------> el output de sort se conecta con el input de head

se pueden hacer varios pipes en linea...

$ sort &lt;in | head | tail -5



8 Utilidades POSIX
----------------

Las siguientes son unas pocas utilitarios basicos de los que es
imprescindible leer su manpage (por ej: $ man cp):

awk, cat, cc/gcc, chmod, cmp, cp, date, diff, echo, find, grep, kill, ln,
ls, make, mkdir, mv, pwd, rm, rmdir, sort, tail, wc.

otros programas utiles: ps, mc, ttysnoop, write, telnet.



9 Administracion de Procesos en Unix
----------------------------------

Como ya vimos unix soporta multiples procesos corriendo simultaneamente, lo
que es muy benefiioso ya que en la mayoria de los programas el procesador
esta esperando a los recursos I/O el 80-90% del tiempo. Estos hoy en dia
soportan DMA, por lo que son muy independientes.


         Procesador      Memory           Device
           (CPU)         Manager         Controller  
             |              |                |
             ----------------------------------------------
                     Bus

Con la Dynamic/direct memory allocation (DMA) el controlador de dispositivo
(controller) devuelve los datos requeridos en la ubicacion de memoria
acordada.

Cada proceso tiene su propio numero PID (process identification) para
referirse a el. Se puede crear procesos hijos (child=ninios) con la funcion
fork() que devuelve el PID del child al padre y 0 al child. Por ejemplo:

     child_pid = fork();

    if (child_pid < 0)               { /* hubo un error */ }
      else if (child_pid > 0)        { codigo del padre }
      else /* (child_pid = 0) !! */  { codigo del hijo};

El child comparte el segmento de codigo con el padre.

Se pueden implementar pipes y fifos con sus respectivas funciones.

Cada usuario tiene su UID o user id, que es un numero de identificacion,
asignado por el administrador del sistema. El UID 0 es del superuser o root,
que puede hacer todo lo que quiera sin ninguna restriccion.

Hay procesos que se inician automaticamente al bootear el sistema, llamados
daemons. Se encargan de servir a otros procesos, o de ejecutar algo
periodicamente.



10 Manejo de Memoria en UNIX
-------------------------

Cada proceso se compone de 3 segmentos. Text, que es donde esta el codigo a
ejecutar, que es de solo-lectura. Data, que contiene las variables y se
divide en dos partes: BSS (no inicializadas) y Data (inicializadas). Y por
ultimo Stack, que es la pila de almacenamiento de variables de ejecucion y
otros valores (contenido de registros, etc.).

Tanto el Stack como el BSS crecen a medida que corre el proceso. El stack
crece desde el tope superior de la memoria virtual hacia abajo. El BSS crece
hacia arriba. No importa cuanto crezcan, nunca se cruzan. El Sistema
Operativo ajusta automaticamente la ubicacion en memoria.

En el Stack se encuentran tambien los argumentos de carga del programa, por
ejemplo si se llamo a '$ grep rojo archivo1', el string 'grep rojo archivo1'
se ubica en el Stack, para que el proceso grep pueda darse cuenta que tiene
que buscar la linea que contiene 'rojo' en el archivo archivo1.

El Text a diferencia del DOS en donde se podia cambiar, con procesos
automodificables, no se puede cambiar. Cuando se genera un child con sus
propios Data y Stack, pero el Text es compartido. En la siguiente figura, 
tenemos un proceso 1 que creo un child (3). Luego de un tiempo de ejecucion
el stack del child puede ser mayor al de parent (padre):


              Memoria            Memoria              Memoria
              Virtual            Fisica               Virtual 
             Proceso 1                               Proceso 3
            __________         __________           __________
     TOPE  |  Stack1  |       |  Stack1  |         |  Stack3  |
           |          |       |          |         |          |
           |----------|       |----------|         |          |
           |          |       |##Vacio###|         |          |
           ~          ~       |----------|         |----------|
           ~          ~       |  Stack3  |         ~          ~
           |          |       |          |         ~          ~
           |          |       |          |         |          |
           |          |       |----------|         |          |
           |          |       |##Vacio###|         |          |
           |          |       |----------|         |          |
           |          |       |   BSS1   |         |          |
           |          |       |..........|         |          |
           |          |       |   Data1  |         |          |
           |          |       |----------|         |----------|
      24 K |----------|       |##Vacio###|         |   BSS2   |
           |   BSS1   |       |----------|         |          |
           |..........|       |   BSS2   |         |..........|
           |   Data1  |       |..........|         |   Data2  |
      12 K |----------|       |   Data2  |         |----------|
           |  Text1   |       |----------|         |  Text2   |
           | (Codigo) |       |##Vacio###|         |          |
       0 K |__________|       |##########|         |__________|
                              |----------|
                              | Text 1-2 |
                              |          |
                              |__________|
                              | Sistema  |
                              |Operativo |
                              |          |
                              |----------|
                              | Vectores |
                              | de ints  |
                              |__________|

...pero el Text es compartido.


La implementacion del paging y la memoria virtual estan fuera del objetivo
de este texto. Si a alguien le interesa, puede pedirlo por mail.



11 Problemas de Seguridad
----------------------

La seguridad en Unix fue agregada posteriormente al disenio original, por lo
que no es todo lo que se desearia. En la escala del Departamento de Defensa
de USA, en la que una calificacion 'A' es muy buena seguridad, 'B' es buena
, 'C' regular, 'D' mala o ninguna seguridad. Dentro de cada letra hay
subdivisiones por numero, siendo por ejemplo B1 menos seguro que B2. Los
sistemas Unix estan en 'C', y solo algunas variantes especiales como el VMS
llegaron a B1. Hasta hoy solo dos sistemas lograron una calificacion A1 (uno
es el Honeywell SCOMP), y la mayoria de los 'A' y 'B3', no estan disponibles
para nadie mas que el Gobierno de USA. Actualmente no hay ningun sistema
operativo comercial con calificacion A.

La mayoria de los problemas de seguridad estan en bugs ('bichos') en el codigo
de programas y del kernel. Estos bugs son los errores que permiten a un
usuario tener mas privilegios.

El 90% de los bugs que se utilizan para penetrar en la seguridad de Unix, son
relativos a programas que utilizan el SUID y el SGID, especialmente el
daemon Sendmail. Estos problemas nacen en que estos servicios (SUID/SGID)
son un arreglo posterior al disenio original de Unix, un parche para
facilitar la tarea de los usuarios. La mayoria de los daemons tienen SUID.
El principal problema son los llamados overflows, en los que se sobreescribe
el stack para forzar la ejecucion de codigo arbitrariamente (casi siempre
/bin/sh), con la ID 'prestada' por el programa original.

El resto son bugs en el kernel ('carozo';es el corazon del sistema operativo),
o protocolos de conexion mal definidos.

Al encontrarse estos problemas de seguridad, a veces suele difundirse un
'exploit' para aprovecharlos. Tambien se los difunde con el objeto de que la
empresa o persona(s) engargada(s) del programa con problemas genere un patch
rapidamente.  Generalmente los exploits son shell scripts (equivalente a los
batch files de DOS, de extension .bat).  Tambien existen organizaciones que se
dedican a buscar nuevos bugs pero que cuando encuentran uno lo que hacen es
notificar al dueño del programa del problema que se encontro para que lo
solucione lo mas pronto posible.  Y a la "comunidad" manda boletines (via
usenet, listas de correo, etc) anunciando el problema descubierto y -cuando es
posible- dan una solucion temporaria para usar mientras aparece el patch
"oficial".

Todos estos problemas llevan a que sea necesario controlar constantemente el
sistema y corregir los bugs a medida que se divulgan.

Una de las nuevas protecciones es utilizar un filesystem encriptado. A mi
parecer no es buena idea ya que los problemas de seguridad pasan por otro
lado...



12 Comentario Final
----------------

A pesar de tener 25 anios, unix se mantiene como uno de los mejores sistemas
operativos (si no el mejor). La idea original de compatibilidad, portabilidad,
y gran poder de manejo, no se perdieron. La nueva tendencia es dividirlo en
capas, dejando un kernel minimo (microkernel); eliminar el super user,
separando sus poderes entre varios neo-superusers.

Ademas en los nuevos sistemas operativos distribuidos, se aprovecha
generalmente la mayoria de las ideas de Unix. Algunos como el MACH proveen
de servicios compatibles con BDS Unix.

Todo esto garantiza que Unix va a seguir por otros varios anios como uno de
los mejores.





```

</div>
