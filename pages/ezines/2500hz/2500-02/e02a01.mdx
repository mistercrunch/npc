---
title: "e02a01"
ezine: "2500hz"
---

# e02a01

**Ezine:** 2500hz

<div className="ascii-content">

```

.--[ @_2500Hz - Underground Scene - ]--------------(http://www.2500hz.org)--.
|                                                                           |
| Titulo : Introduccion al 'mIRC Scripting'                                 |
| Autor  : nEuRoNaL (neuronal@linuxfan.com)                                 |
| Fecha  : 27/03/2000                                                       |
`-----------------------------------------------------(2500hz@mixmail.com)--┤


-#- Indice/Contenidos -#-
-------------------------

 00.    Prologo...
 01.    Introduccion.
 02.    Listado de comandos.
 03.    Las partes programables en el mIRC:
  03.1.  Aliases.(creacion de alias, identificadores, ...)
  03.2.  Popups. (creacion de menus...)
  03.3.  Remotes.
   03.3.1  - Users.
   03.3.2  - Scripts.
   03.3.3  - Variables.
 04.    Estructuras "IF-Else"
 05.    Consejos y recomendaciones.
 06.    Despedida.

-------------------------



-#- 00.  Prologo... -#-
- -- - -- - -- - -- - -

        Este documento pretende ser un peque±o tutorial sobre la programacion
de scripts para el cliente de IRC 'mIRC'. Con esto quiero decir que todo
contenido aqui expuesto es valido en su totalidad para mIRC y, que al ser un
peque±o tutorial, el nivel del documento es, practicamente, basico.

Este documento puede ser distribuido libremente por cualquier tipo de
red/agrupacion, siempre y cuando se respete su entera integridad.

Para cualquier tipo de duda, critica, sugerencia... dirigios a:
neuronal@linuxfan.com y el autor respondera a todos los mails recibidos lo
antes posible.


-#- 01.  Introduccion. -#-
- -- - -- - -- - -- - -- -

        La definicion de que es un script para mIRC podria ser que es el
conjunto de varias rutinas o instrucciones aplicadas al mIRC para poder
ejecutar tareas en el IRC de forma automatica; es decir, que si cada vez que
entramos en un canal queremos decir: "Hola Mundo!" pues la verdad, es un
co±azo teclearlo manualmente, asi que podemos crear una instruccion para que
cada vez que entremos en un canal, el mIRC lance dicho mensaje
automaticamente...
Todas las rutinas que programamos en el mIRC se encuentran en "Las tres
partes programables del mIRC" en los aliases, popups y remotes... estas
partes son simplemente ficheros .ini (pueden tener cualquier extension) los
cuales se cargan en el mIRC.
Todas las instrucciones que programemos se basan en los "comandos base" que
el mIRC puede realizar; es decir, que si queremos decir algo automaticamente
(como el ejemplo anterior...) programamos una instruccion en la que se
encuentra el comando base "/say" (por ejemplo...)
Asi que si quieres dise±ar un Script potente y con multitud de rutinas,
tendras que saber las posibilidades que tiene el mIRC; es decir sus "comandos
base" la lista es bastante amplia, ya que el mIRC es un programa que te da un
ancho campo para que puedas dise±ar verdaderas maravillas. ;)

Bien y para acabar esta introduccion, cabe se±alar un simple detallito;
La gente que programa en C y/o en cualquier otro lenguaje de programacion son
llamados "Programadores" asi como las personas que dise±an y mantienen
Paginas Web son llamamos "WebMasters".
Bien pues nosotr@s, los que programamos Scripts para mIRC, nos hacemos llamar
"Scripters" (Seguramente esta tonteria ya la sabias ;) esto lo digo para que
no "metais la pata" cuando le digais a vuestr@ padre/madre/colega/novi@...
que eres programador de scripts para mIRC (aunque tambien es valido), queda
mas "profesional" y "tecnico" decir que eres Scripter. ;)

Acabada esta peque±a introduccion, damos paso al tutorial...


-#- 02.  Listado de comandos. -#-
- -- - -- - -- - -- - -- - -- - -

        Bien pues en este apartado pongo todos los "comandos base" que el
mIRC incorpora... (Te recuerdo que esta lista es bastante importante, ya que
estos comandos van a ser los que utilices para dise±ar tu propio script desde
cero!)
Tambien quiero que sepais que de memoria no me se todos los comandos, asi que
esta lista a sido sacada de la pagina web del canal #Ayuda_IRC
(http://www.ayuda-irc.net) y ha sido realizada por SomaTic
(sucubus@arrakis.es)
Os recomiendo que os imprimais esta lista, y asi la tendreis presente a todo
momento a la hora de hacer vuestro script...

                ----------------------( CuT HeRe )----------------------

        Esta es una guφa de referencia de la mayorφa de los comandos del mIRC y de su sintaxis tal y como se especifica en la ayuda del programa, versi≤n 5.51. En la sintaxis he utilizado algunos sφmbolos cuyo significado es el siguiente:
Las palabras entre los sφmbolos "<" y ">" representan valores a introducir en el comando, no esas mismas palabras, sino lo que significan.
Todo lo que se encuentra entre los sφmbolos "[" y "]" son valores opcionales.
La barra "\", dentro de la sintaxis del comando, separa valores alternativos es decir, se puede introducir uno u otro pero solo uno cada vez.
Cuando vea especificaciones del tipo: -aqf, por ejemplo, se tratarß de modificadores del comando, es decir, parßmetros que modifican la acci≤n de este. Estos son normalmente una sola letra precedida de un gui≤n. En el ejemplo anterior deberß de poner -a, -q, ≤ -f. Sin embargo, en la mayorφa de los casos es posible especificar mßs de uno cada vez a fin de combinar sus efectos, es este caso no es necesario mßs que un gui≤n, por ejemplo: -af, -fq, -qa,...etc.
Por ·ltimo recuerde que cuando se introduce un comando en la lφnea de escritura del programa es necesario iniciar esta con un sφmbolo especial, con el fin de que sea interpretada como tal comando y no como un mensaje normal al IRC. Este sφmbolo suele ser, en la inmensa mayorφa de los casos, la barra inclinada: "/".
No se preocupe si de momento no entiende algunos comandos, bastantes de ellos realizan acciones avanzadas que ya conocerß con el tiempo y la prßctica, puesto que estßn concebidos para dar su mßxima utilidad dentro de rutinas de script, alias o popups; encontrarß la explicaci≤n al manejo de estos recursos en los capφtulos correspondientes de esta misma web.
Tenga en cuenta que el conocimiento de los comandos es el primer paso para entender el funcionamiento de los scripts y del IRC en general, es muy recomendable que los use habitualmente para irse familiarizando con ellos, aunque su programa de IRC pueda realizar estas mismas funciones de forma automßtica mediante opciones de men·. Muchos comandos no son exclusivos del mIRC, sino que son propios del protocolo IRC general y podrß, por tanto, usarlos sea cual sea su programa cliente.
Para cualquier duda puede dirigirse al canal #ayuda_IRC del IRC Hispano, mi nick es SomaTic. Cualquier aportaci≤n, critica, o consulta serß bien recibida tambiΘn en mi E-mail: sucubus@arrakis.es

/abook [nick]
Esta orden abre la agenda personal de mIRC, donde se pueden guardar los datos de los usuarios que se desee. Si especifica un nick la agenda se abrirß por la referencia a este nick concreto.

/ajinvite [on/off]
Activa o desactiva la opci≤n de entrada automßtica en un canal cuando seamos invitados a este.

/alias [fichero] &lt;nombre del alias> [&lt;comandos>]
A±ade, elimina, o reemplaza un alias en el fichero de alias especificado, o en el primero de los que existan si no se especifica uno. Para mßs informaci≤n sobre los alias lea el capφtulo "Los Alias del mIRC".
Este comando solo permite a±adir alias sencillos, de una sola lφnea. Si ya existe un alias con el nombre indicado lo reemplazarß por el nuevo que escribamos, si no ponemos comandos entenderß que debe de buscar un alias con ese nombre y eliminarlo.

/amsg &lt;mensaje> y /ame &lt;mensaje>
Envφan el mensaje o la acci≤n especificada a todos los canales en los que nos encontramos. Estos comandos no se pueden usar el remotes, como eventos ... etc.

/auser
A±ade un usuario a su lista de usuarios remotos, encontrarß una referencia a este comando y su manejo en el capφtulo  "Usuarios remotos y eventos CTCP".

/away [mensaje de away]
Deja un mensaje explicando que en ese momento no estamos prestando atenci≤n a IRC. Cada vez que un usuario nos envφe un /msg o realice un /whois con nosotros verß automßticamente cualquier mensaje que insertemos. Utilizar /away sin parßmetros elimina el mensaje de AWAY.

/background [-aemsgdluhcfnrtpx] [nombre_ventana] [fichero BMP]
Con este comando es posible especificar una imagen en formato .bmp como fondo para cualquier ventana del mIRC. Es la misma acci≤n que el usuario puede realizar desde la opci≤n BACKGROUND del men· de sistema de cada ventana, es decir, el que aparece haciendo click sobre el icono que se encuentra en el lado izquierdo de la barra de tφtulo de esta (no en la ventana IDE principal del programa).
Ademßs del nombre de la ventana a tratar y del fichero de imagen a emplear se pueden usar los siguientes parßmetros:
        -n = Aplica la imagen en modo normal, es decir, en su tama±o original y ajustada a la izquierda de la ventana.
        -c = Aplica la imagen centrada y en su tama±o original.
        -f = Aplica la imagen ampliandola hasta rellenar por completo la ventana.
        -r = Aplica la imagen centrada en la ventana y adaptandola al tama±o de esta.
        -t = Aplica la imagen en modo mosaico, es decir, rellenando toda la ventana con copias a tama±o original de dicha imagen.
        -p = Aplica la imagen reducida en la esquina superior derecha de la ventana.  
        -a = Aplica el fondo centrado a la ventana que se encuentre activa en ese momento adaptandola al tama±o de esta.
        -m = Aplica el fondo centrado a la ventana IDE principal del mIRC adaptandola al tama±o de esta.
        -s = Aplica el fondo centrado a la ventana de status adaptandola al tama±o de esta.
        -g = Aplica el fondo centrado a la ventana del finger adaptandola al tama±o de esta.
        -d = Aplica el fondo centrado a la ventana de querys adaptandola al tama±o de esta.
        -l = Aplica la imagen en modo mosaico como fondo de la barra superior de botones del mIRC.
        -u = Aplica la imagen como fondo de los botones de la barra superior del mIRC.
        -h = Aplica la imagen en modo mosaico como fondo de la barra de iconos del mIRC.
        -x = Elimina la imagen de fondo.
No es necesario especificar el fichero de imagen cuando se estßn modificando los atributos de visualizaci≤n de alguno ya existente.

/ban [-u&lt;n·mero>] <#canal> &lt;nick\direcci≤n> [&lt;tipo\mßscara>]
Censura en el canal al usuario cuyo nick o direcci≤n se ha especificado. Si el usuario no es operador del canal no podrß hablar en este, si estß fuera o sale del canal no podrß volver a entrar. Cualquier operador del canal podrß realizar esta acci≤n.
Por ejemplo: /ban -u600 #Tortosa PePe 2
La orden anterior banea al usuario PePe en el canal #tortosa durante 10 minutos (600 segundos). La censura se impone a travΘs de su direcci≤n de acuerdo a una mßscara de tipo 2.
El parßmetro -u permite especificar un ban temporal del n·mero de segundos que se introduzca a continuaci≤n. Pasado este tiempo el ban se retira automßticamente. Para retirar manualmente un baneo utilice el comando /mode.
Si hemos especificado un nick el programa ejecuta internamente un /whois para conseguir la direcci≤n del usuario, le aplica la mßscara del tipo indicado y despuΘs realiza (ver comando /mode): /mode #canal +b mßscara
Para una explicaci≤n detallada de las direcciones, las mßscaras y sus tipos, consulte el capφtulo "Las direcciones y las mßscaras en el IRC"
El "tipo" es un n·mero entre 0 y 9 que determina el tipo de mßscara que se aplicarß al baneo. El usuario permanecerß baneado mientras que no se le retire esta condici≤n, o su direcci≤n siga
coincidiendo con el patr≤n que especifica la mßscara. El tipo es opcional (en su defecto se aplicarß la mßscara nick!user_id@direcci≤n). TambiΘn se puede especificar manualmente la mßscara que se desea.
Por ejemplo: /ban #Tortosa *!*@*
Banea a todos los usuarios del IRC del canal #tortosa puesto que se ha introducido una mßscara
genΘrica.
NOTA: Este comando utiliza La Lista Interna de Direcciones conservada por mIRC.

/beep &lt;n·mero> &lt;retraso>
Emite pitidos a travΘs del altavoz interno, un n·mero determinado de veces con un retraso
especificado.

/channel
Hace surgir la ventana central del canal activo. Se trata de una ventana de dialogo donde se pueden manejar c≤modamente los valores del topic, modos del canal, y lista de bans de Θste.

/clear [-sghlc] [ventana]
Borra toda la memoria intermedia de desplazamiento en la ventana; es decir, limpia la ventana actual o la especificada de todos los mensajes impresos.

/clipboard &lt;texto>
Copia en el portapapeles el texto especificado.

/close [-icfgms] [@nombre_ventana] [nick1] ... [nickN]
Cierra todas las ventanas del tipo, nombre, o nick especificados. Si no se especifica nick se cerrarßn todas las ventanas existentes de ese tipo o tipos. Los tipos son: c para chat, f para fserve, g para get, i para "inactive dcc windows", m para query, y s para send. TambiΘn se puede cerrar una ventana personalizada escribiendo su nombre precedido, como es costumbre en estos casos, del sφmbolo "@"
El siguiente ejemplo cierra las ventanas de chat y fserve abiertas con el usuario pepe:      
/close -cf pepe

/closemsg [nick]
Cierra la ventana de query del nick especificado.

/copy -ao &lt;filename> &lt;filename>
Permite dar una orden desde mIRC para copiar un fichero sobre otro fichero o directorio. Especificando el parßmetro -o se sobreescribirßn los ficheros si existen en el destino. Especificando -a se a±adirß el contenido del fichero de origen al de destino.

/creq [+m\-m] [ask\auto\ignore]
Es la lφnea de comandos equivalente a las opciones de configuraci≤n del DCC que se pueden realizar en la ventana DCC\Options\Send (vΘase tambiΘn el comando /sreq).

/ctcpreply &lt;nick> &lt;tipo_de_ctcp> [mensaje]
Especifica una respuesta para los requerimientos CTCP del tipo expresado.
Por ejemplo: /ctcpreply pepe HELP Llama a los bomberos ;-D.
Encontrarß una explicaci≤n mas detallada a este comando y su uso en el capφtulo "Usuarios remotos y eventos CTCP".

/dcc send &lt;nick> [fichero1, fichero2,...]
Inicia un envφo de ficheros hacia otro usuario. Se pueden especificar uno o mßs ficheros. Si no
ponemos ninguno se abrirß una ventana de dißlogo desde donde podremos navegar por nuestro disco
para seleccionarlos.

/disconnect
Fuerza una desconexi≤n inmediata. Este es diferente al comando /quit, el cual envφa un mensaje de despedida al servidor y espera a que Θste nos desconecte.

/dns &lt;nick\direcci≤n>
Se utiliza para resolver direcciones. Si especificamos un nick nos informarß de su IP; si ponemos una IP intentarß encontrar su resoluci≤n inversa. Para ser mßs precisos: si mIRC ve un "." en el nombre que hemos especificado, asume que es una direcci≤n e intentarß resolverla, de lo contrario asumirß que es un nick y realizarß un /whois para averiguar su direcci≤n y posteriormente resolverla. Si le damos una direcci≤n IP, buscarß el nombre del residente.
Es posible indicar mßs de un nick y/o direcci≤n.

/dqwindow [on\off\show\hide\min]
Permite activar (on), desactivar (off), visualizar (show), ocultar (hide), o minimizar (min) una ventana destinada a recoger todos los querys recibidos. Usar esta ventana para todos los querys, en lugar de una para cada uno de ellos, implica que al responderlos deberemos de preceder cada mensaje de una indicaci≤n de a quien va dirigido, es decir, el comando /msg nick. Si usted observa que todos los querys le salen en la misma ventana y quiere cambiarlo para que exista una para cada uno de ellos, teclee: dqwindow off

/echo [color] [-e] [-s\-a\#canal\nick] &lt;texto>
Imprime el texto especificado en la ventana, utilizando el color indicado (del 0 al 15). S≤lo es impreso y visualizado por nosotros. Puede especificarse como destino de la impresi≤n la ventana de status (-e), la ventana activa (-a), un canal determinado, o una ventana de privado con un nick concreto. El modificador -e a±ade una marca de separaci≤n una lφnea por encima y por debajo del mensaje.

/editbox [-s\-a\ventana] &lt;texto>
Inserta el mensaje indicado en la lφnea de escritura (caja de edici≤n) de una determinada ventana, en la de status (-s), o en la activa (-a).

/exit
Obliga a mIRC a desconectar y salir.

/finger &lt;nick/direcci≤n>
Realiza un "finger" en un usuario. Si indicamos una direcci≤n Θsta es se±alada inmediatamente y si especificamos un apodo se busca la direcci≤n del usuario utilizando un /whois y posteriormente es se±alada.

/filter [-sgdfwxnpr] [n-n2] &lt;origen> &lt;salida> &lt;cadena>
Este comando lee lφneas de texto desde una ventana o fichero indicado como origen buscando la
cadena de texto especificada. Copia completas las lφneas que encuentre conteniendo la cadena en otra ventana o fichero indicado como salida donde pueden ser consultadas.
Debemos de indicar en el comando si el origen y la salida son ficheros ambos (-ff), ventanas ambos (-ww), un fichero y una ventana (-fw) o una ventana y un fichero (wf)
Por ejemplo:    /filter -ff in.txt out.txt *mirc*
                /filter -wf #ayuda_irc out.txt *help*
Veamos la utilidad del resto de los parßmetros que podemos emplear:
        El parßmetro -x harß lo contrario a lo explicado antes, es decir, copiarß las lφneas que no contienen la cadena.
        El parßmetro -n icluirß un n·mero de lφnea delante de cada una de las que se copien.
        El parßmetro -s harß que se use la ventana de status como origen.
        El parßmetro -g harß que se use la ventana de finger como origen.
        El parßmetro -d harß que se use la ventana dedicada de msg's como origen.
        El parßmetro -p permitirß que se emplee una ventana personalizada como salida.
        El parßmetro -r permite especificar un rango de lφneas del origen a analizar.

/flash [-w\-b] &lt;texto>
Este comando es muy ·til para insertarlo en una rutina de script, a fin de que nos avise de cuando se produce un determinado suceso si estamos en otra aplicaci≤n y tenemos en mIRC minimizado.
Bßsicamente produce un aviso intermitente en el icono o bot≤n del mIRC en la barra de tareas del Windows. El aviso continua hasta que pulsamos el icono y restauramos el mIRC.
Se puede especificar un texto que aparecerß una vez por segundo en el icono del mIRC TambiΘn
podemos poner un "beep" que sonarß con la misma frecuencia mediante el modificador -b, o bien otro sonido Midi o Wav si asφ lo indicamos en el dißlogo "Event Beeps" de File/Options y usamos el modificador -w.
Puede ver un ejemplo inmediato escribiendo el comando: //.timer263 1 10 flash -b Esto es prueba
El timer nos darß tiempo a minimizar mIRC para ver los efectos del comando (he elegido el n·mero 263 al azar). Pasados 10 segundos el bot≤n del mIRC comenzarß a mostrar intermitentemente la frase: "Esto es una prueba" y a emitir "beeps" de aviso; continuarß asφ hasta que pulse el icono y restaure en pantalla el programa.

/font [[-a\-s\-b] [ventana] &lt;tama±o de fuente> &lt;nombre de fuente>]
Si indicamos el comando /font sin mßs parßmetros activarß la aparici≤n del dißlogo de fuentes en la ventana en la que estamos. Podemos tambiΘn determinar directamente una configuraci≤n de fuentes para la ventana activa (-a), la de status (-s). u otra que indiquemos, dando un tama±o y nombre de fuente. El modificador -b fuerza la aparici≤n en negrita de la fuente.

/fserve
Envφa una sesi≤n del servidor de ficheros para otro usuario utilizando un DCC Chat con con este. El usuario estarß limitado a acceder s≤lo a los ficheros y directorios que indicamos en el comando. La sintaxis completa es:
/fserve &lt;nick> &lt;maxgets> &lt;directorio_inicio> &lt;Fichero_de_texto_de_bienvenida>
Los maxgets son el mßximo n·mero de DCC gets simultßneos que el usuario puede tener durante una
sesi≤n del servidor de ficheros. El fichero de bienvenida es un texto que leerß el usuario cuando se conecta al servidor de ficheros.
Por ejemplo: /fserve pepe 5 c:\users c:\instruciones.txt
Esta lφnea iniciarß una sesi≤n del servidor con el usuario pepe, accediendo Θste al directorio c:\users, y enviarß a pepe el texto del fichero instrucciones.txt. El usuario s≤lo puede tener 5 gets simultßneos, es decir, s≤lo puede recibir 5 ficheros simultßneamente. En cada directorio o subdirectorio podemos colocar un fichero dirinfo.srv, que describe ese directorio. Cada vez que un usuario realice un CD para cambiar de directorio, mIRC buscarß este fichero, y si lo encuentra, el texto que hay en su interior serß presentado al usuario.
Los comandos principales que estßn a disposici≤n del usuario, una vez conectado, son: cd (cambio de directorio), dir (listar directorio), ls (listar directorio en modo multicolumna), get &lt;fichero> (recibir fichero vφa DCC), read &lt;fichero de texto> (leer el fichero). Todos los comandos disponibles han sido enormemente limitados con la esperanza de que puedan evitar una violaci≤n de seguridad.
Si un usuario se ha retrasado demasiado, el servidor cerrarß automßticamente la conexi≤n. Podemos instalar el tiempo de retraso en el dißlogo de Opciones DCC.

/goto &lt;etiqueta>
Se usa en definiciones de scripts para producir un salto incondicional a un punto diferente del script. Ver el capφtulo "La estructura condicional IF-ELSE"

/help
Nos muestra la secci≤n de Comandos bßsicos de IRC en el fichero help de mIRC. TambiΘn podemos
ejecutar un /help palabra_clave , y si esta palabra coincide con un t≤pico de ayuda podremos acceder a Θl.

/ial [on\off]
Este comando activa o desactiva la Lista Interna de Direcciones del mIRC que es necesaria en algunos comandos e identificadores. Esta lista guarda los datos de los usuarios del IRC que vamos encontrando en nuestra sesi≤n, los que estßn el los mismos canales que nosotros... etc. Su capacidad es limitada, por tanto los mßs antiguos se irßn eliminando a medida que se cargan otros nuevos.

/identd [on/off] [User_id]
Activa o desactiva la opci≤n Ident Server del Setup. Puede especificarse el USER ID deseado.

/ignore [-rpcntki] [-u&lt;segundos>] &lt;nick/direcci≤n> [tipo]
Nos permite ignorar los mensajes procedentes de un nick especificado. Si no especificamos un tipo, s≤lo serß ignorado el apodo del usuario, pero si lo hacemos, la direcci≤n serß buscada mediante un /whois y se aplicarß la mßscara correspondiente a ese tipo; todos los mensajes procedentes de esta direcci≤n serßn ignorados.
El modificador -r retira un ignore
Por ejemplo: /ignore -r PePe
Se puede especificar un ignore con una duraci≤n limitada en segundos: /ignore -u300 PePe
Asφ mismo se puede ignorar solo determinados envφos de un usuario, no todos ellos, mediante el
modificador adecuado: privados (-p), mensajes al canal (-c), notices (-n), ctcp's (-t), c≤digos de control (-k), e invites (-i). Puede indicar uno solo de ellos o varios simultßneos.
Por ejemplo: /ignore -pntik PePe
Este ejemplo pone un ignore al usuario PePe en todos sus envφos menos los que hace al canal.

/Invite &lt;nick> <#canal>
Invita a otro usuario al canal.

/join [-inx] [<#canal>]
Nos introduce en el canal especificado. Con el modificador -i entraremos en el ·ltimo canal al que nos hayan invitado. los modificadores -n y -x permiten minimizar o maximizar la ventana del canal tras nuestra entrada.

/kick <#canal> &lt;nick>
Expulsa a este usuario de un canal especificado (solo para OP).

/linesep [-s\ventana]
Inserta una lφnea de separaci≤n en la ventana especificada. (-s es para la ventana de status).

/links
Presenta la lista de servidores de IRC enlazados en la red en que nos encontramos.

/list [&lt;cadena> [-min&lt;n·mero>] [-max&lt;n·mero>]]
Nos presenta la lista de canales del IRC. Si especificamos una cadena de caracteres sacarß solo
aquellos canales que contengan esa cadena en su nombre. TambiΘn se puede indicar que presente
solo aquellos que tengan un n·mero mßximo y/o mφnimo de usuarios en su interior     
Ejemplos:
        /list
        /list -min 5 -max 20
        /list #ayuda

/load <-a\-ps\-pc\-pq\-pn\-pm\-ru\-rs\-rv> &lt;fichero>
Este comando permite cargar en el ßrea de memoria RAM correspondiente al mIRC los ficheros de
alias, popups, y remotes que le indicamos. Solo podemos cargar uno cada vez.
Es la lφnea de comandos equivalente a la opci≤n Load de los dißlogos de alias (-a), popups (-p) y remotes (fichero de usuarios: -ru, fichero de script: -rs, y fichero de variables: -rv).
        /load -a &lt;fichero>
        Carga un fichero de alias

        /load -ps &lt;fichero>
        Carga un fichero de popups para el status

        /load -pc &lt;fichero>
        Carga un fichero de popups para el canal

        /load -pq &lt;fichero>
        Carga un fichero de popups para los query y chat

        /load -pn &lt;fichero>
        Carga un fichero de popups para la lista de nicks

        /load -pm &lt;fichero>
        Carga un fichero de popups para la barra de men·s

        /load -rs &lt;fichero>
        Carga un fichero de script

        /load -ru &lt;fichero>
        Carga un fichero de usuarios

        /load -rv &lt;fichero>
        Carga un fichero de variables

Los ficheros serßn de texto. Pueden tener cualquier extensi≤n aunque el formato mßs recomendable es el .INI. La capacidad de cada fichero es limitada, pero se pueden tener cargados tantos como se desee o permita la capacidad de nuestra RAM.

/loadbuf [&lt;lφneas>] &lt;ventana> &lt;fichero>
Permite imprimir en la ventana indicada el n·mero de lφneas que deseemos, contando desde la ·ltima, procedentes de un fichero de texto.
Por ejemplo: /loadbuf 10 #ayuda_irc mirc.ini
Esta orden imprimirß en la ventana del canal #ayuda_irc (siempre que estemos en Θl) las 10 ·ltimas lφneas del fichero mirc.ini. Estas lφneas solo las veremos nosotros, no son enviadas al servidor.
TambiΘn se puede especificar un rango de lφneas, las comprendidas entre dos n·meros:    
/loadbuf 10-20 #ayuda_irc mirc.ini
O incluso desde una lφnea hasta el final del fichero:    
/loadbuf 30- #ayuda_irc mirc.ini

/log &lt;on\off> [&lt;ventana>]
Nos permite conectar o desconectar la grabaci≤n "log" en una ventana, o de la ventana actual si no se especifica una.

/mkdir &lt;nombre de directorio>
Permite crear un directorio con el nombre que deseemos.

/me &lt;mensaje>
Envφa una acci≤n a la ventana activa, es decir un mensaje precedido de nuestro nick. Este comando no se puede usar en los remotes (eventos ... etc).

/mode [<#canal/nick>] [[+/-] modo [parßmetros]]
Este es un comando que nos da gran control sobre los usuarios y el canal. Para cambiar los modos del canal se requiere el status de operador. La utilizaci≤n del signo + o - equivale a la aplicaci≤n o retirada de los efectos del modo que se pone a continuaci≤n.

Modos para el canal:
        b &lt;nick>: Banea a un usuario, equivale al comando /ban. La censura se extiende tanto al nick como al resto de la direcci≤n del usuario.
Por ejemplo: /mode #bolsa +b PePe
        i: Hace el canal s≤lo para invitados.
        L&lt;n·mero>: El canal es limitado a un n·mero mßximo de usuarios.
        m: El canal es moderado (s≤lo los operadores o los usuarios con voz pueden hablar).
        n: Mensajes externos al canal no estßn permitidos.
        o &lt;nick>: Convierte al nick en operador de canal
        p: Hace el canal es privado, es similar al modo s.
        s: El canal es secreto. No aparecerß en la lista de canales ni en el whois de los usuarios que
estßn dentro.
        t El topic es limitado, s≤lo los operadores pueden cambiarlo.
        k &lt;clave>: Instala una clave secreta para acceder al canal (/join <#canal> &lt;clave>).
        v: Proporciona voz a un usuario en un canal moderado.

Modos del usuario (cualquier usuario puede cambiar sus modos)
        i: Nos hace invisibles ante un usuario que no conozca las letras exactas de nuestro apodo, o no
estΘ en el mismo canal que nosotros.
        s: Recibe las noticias del servidor.
        w: recibiremos los Wall-op.
        d: Es un modo "ausente". no veremos los mensajes que se envien al canal, solo las acciones que se producen en este.

/msg &lt;nick> &lt;mensaje>
Envφa un mensaje privado (query) a este usuario.

/nick &lt;nick1> [&lt;nick2>]
Cambia nuestro nick por otro que deseemos. Opcionalmente podemos indicar un segundo nick por si el primero ya estß en uso.

/notify [-r] &lt;nick> [&lt;comentario>]
A±ade un nick a la lista de notificaci≤n que nos avisarß cada vez que este entre o salga del IRC.
Opcionalmente se puede a±adir un comentario que tambiΘn serß visualizado.
Por ejemplo: /notify Adrian íCuidado que este nukea!
Podemos eliminar un nick de la lista insertando el modificador -r. /notify -r Marisa
Podemos ver la lista de notify con los usuarios actualmente conectados mediante el modificador -s: /notify -s
O bien ocultarla con el modificador -h. /omsg [<#canal>] &lt;mensaje>
Solo para operadores. Envφa un mensaje privado a todos los operadores del canal actual o el
especificado.

/onotice [<#canal>] &lt;mensaje>
Envφa mediante notice el mensaje especificado a todos los operadores de un canal. Es necesario ser un operador para usar este comando. Si no se especifica el canal, entonces se utilizarß el canal activo.

/part <#canal>
Produce nuestra salida del canal.

/partall
Produce nuestra salida de todos los canales en los que nos encontramos.

/perform [on\off]
Equivale a activar o desactivar la casilla "On connect, Perform these commands" del dialogo
File/Options/Perform. En esta ventana podemos indicar una serie de comandos que queremos que se
ejecuten siempre al inicio de las sesiones.

/play [-scp] [q&lt;n·mero>] [m&lt;nick\#canal>] [r] [L&lt;n·mero>] [t&lt;n·mero>] [&lt;ventana>] &lt;fichero> [&lt;retardo>]
Nos permite enviar textos procedentes de un fichero a un usuario o a un canal. El retardo se valora en milisegundos; si un usuario envφa los ficheros a un servidor con demasiada rapidez, probablemente serß desconectado por flood. El retardo por defecto es 1000. Las lφneas vacφas que se encuentren en un texto serßn consideradas como un retardo.
/play -c \text\mypoem.txt 1500
El modificador -c obliga a mIRC a interpretar las lφneas como comandos en lugar de un simple texto, por tanto los ejecutarß.
El modificador -s permite imprimir en la pantalla de status sin necesidad de estar conectados al server.
El comando /play forma una cola con las ordenes de impresi≤n cuando hay otras en curso. Esto se
debe a que si el comando intentara enviar todas las peticiones al mismo tiempo, el usuario podrφa ser desconectado del servidor por flood.
El modificador -p indica que Θsta petici≤n es prioritaria y por tanto deberφa ser colocada a la cabeza de la cola para su envφo inmediato. La impresi≤n en activo serß detenida y reanudada posteriormente una vez que la de prioridad haya finalizado.
El modificador -q&lt;n·mero> especifica el n·mero mßximo de demandas que pueden estar en la cola.
Si su longitud es mayor o igual que el n·mero especificado, la demanda de envφo serß ignorada. /play -q5 c:\text\info.txt 1000
El modificador -m&lt;nick\#canal> limita el n·mero de peticiones que pueden ser insertadas en la cola por un usuario o canal especφficos (·til para comandos remotos). Si Θstos se exceden o ya tienen el n·mero acordado de peticiones, entonces la demanda de envφo ser  ignorada.
/play -ml info.txt 1000
Esta lφnea limita a cada usuario a un mßximo de una petici≤n de una vez e ignora las demßs.
NOTA: Los conectores -q y -m s≤lo se aplican a un /play iniciado a travΘs de una definici≤n remota, que no es especificada por usted. Para combinar los conectores anteriores, harφamos:
/play -cpq5ml info.txt 1000
El conector -r escoge aleatoriamente una lφnea individual de un fichero para enviarla.
/play -r action.txt 1500
El conector -L&lt;n·mero> envφa el n·mero de lφneas especificado.
/play -L125 witty.txt 1500
Tanto para -r como para -L la primera lφnea del fichero debe ser un solo n·mero que especifique la cantidad de lφneas que hay en su interior
El modificador -t obliga a mIRC a buscar en el fichero el t≤pico especificado y a enviar todas las lφneas bajo ese t≤pico.
Por ejemplo: /play - thelp1 c:\help.txt
En el fichero help.txt tendrφamos:
        [help1]
        lφnea1
        lφnea2
        lφnea3
        [help2]....
El mIRC enviarß  todo aquello que se encuentre despuΘs de [help1] y se detendrß cuando llegue al siguiente t≤pico o al final del fichero.

/pop &lt;retardo> [<#canal>] &lt;nick>
Ejecuta un Op retrasado en un nick. El prop≤sito de este comando es el de evitar que la ventana del canal estΘ atestada de cambios de modo Op en los casos en que varios usuarios tengan al mismo nick en su secci≤n auto-op. MIRC se detendrß en los segundos de retraso antes de ejecutar Op. Antes de ejecutar Op verificarß si el usuario ya ha sido opeado. Si no especificamos el canal se considerarß el canal activo.

/query &lt;nick> &lt;mensaje>
Abre una ventana de query a este usuario para enviarle un mensaje privado.

/quit [&lt;mensaje>]
Cierra la conexi≤n con el servidor de IRC. Permite opcionalmente enviar un mensaje de despedida a todos los canales en los que los encontramos. Por Ejemplo: /quit Hasta luego amigos!!

/raw [-q] &lt;comando>
Envφa los comandos que hemos insertado directamente al servidor. Es imprescindible conocer el
formato correcto raw del comando que estamos enviando. Es ·til para mandar comandos que mIRC
a·n no ha ejecutado. El conector -q realiza este trabajo sin imprimir lo que estß enviando. Ojo, los comando raw no son necesariamente los mismos que los de un cliente de IRC, se trata de comando del servidor.
/raw PRIVMSG nick :Hellooo there!

/remini &lt;fichero.ini> &lt;secci≤n> [palabra]
Este comando borrarß una secci≤n especificada de un fichero .INI (una secci≤n es un bloque de lφneas encabezado por un tφtulo entre corchetes). Opcionalmente podemos poner una palabra, en este caso solo se borrarßn todas las ocurrencias de esa palabra.
PRECAUCI╙N: no use este comando para modificar ficheros .INI que se encuentren en uso.

/remove &lt;fichero>
Se borrarß el fichero especificado.

/rename &lt;fichero> &lt;nuevo_fichero>
Permite renombrar un fichero. TambiΘn es ·til para mover los ficheros de un directorio a otro aplicando la sintaxis: /rename &lt;origen> &lt;destino>

/resetidle
Pone a cero el identificador $idle.

/rmdir &lt;directorio>
Permite borrar un directorio. Este directorio debe de estar vacφo.

/run [-n] &lt;fichero o programa> [parßmetros]
Nos permite ejecutar un programa, bien especificandolo directamente o bien indicando un fichero de trabajo de ese programa. TambiΘn es posible introducir parßmetros que ese programa acepte por lφnea de comandos.
Por ejemplo: /run c:\comms\ftp\ftp.exe sunsite.unc.edu
Este ejecuta el programa ftp.exe con los parßmetros sunsite.unc.edu

/savebuf [-s\-f] [-a] [n] [&lt;ventana>] &lt;fichero>
Salva en un fichero las n ·ltimas lφneas de una ventana especificada, o bien el rango de lφneas que se marque.
Por ejemplo: /savebuf 20 #ayuda_irc copias.sav
/savebuf 10-15 status copias.sav
El modificador -s permite salvar el buffer de la ventana de status, y -a salvarß la ventana actual.
Si el fichero de destino ya tiene alg·n contenido, y no queremos que se sobreesciba sino que las lφneas salvadas se a±adan al final de este, podemos utilizar el modificador -a.

/save &lt;parßmetros> &lt;fichero>
Es la lφnea de comandos equivalente al bot≤n SAVE TO en los dißlogos de alias, popups y remotos, y es utilizado para salvar la secci≤n especificada. Los parßmetros y su uso son los mismos que en el comando /load, consultelo mßs arriba. Por ejemplo, si deseßramos salvar los alias en un fichero, harφamos: /save -a aliases.ini
NOTA: S≤lo podemos referirnos a una secci≤n de una vez, de forma que no podemos ejecutar:
/save -uce some.ini.

/say &lt;mensaje>
Nos permite definir un alias que se escribe directamente en un canal como si estuviΘramos diciendo algo. Asφ que, /say Hello there serφa lo mismo que teclear "Hello there" en el canal actual. Es ·til en el caso de un alias cuando queremos hacerle la misma pregunta (o enviar la misma informaci≤n) una y otra vez:

/info /say "Visita la pßgina: http://www.arrakis.es/~sucubus"
Cada vez que tecleemos el alias /info, la frase especificada se mostrarß en el canal o ventana actual. Ver la secci≤n "Los alias del mIRC"
NOTA: No se puede utilizar este comando en la secci≤n remota, en su lugar use:
/msg <#canal> &lt;mensaje>

/server &lt;servidor\n·mero> [puerto] [palabra clave]
Nos conecta a un servidor.
/server fuego.irc-hispano.org
Si tecleamos /server sin parßmetros, mIRC conectarß al ·ltimo servidor que utilizamos. TambiΘn
podemos indicar tan solo un n·mero para conectarnos al que tenga este n·mero de orden dentro de la lista de servidores del Setup. Si usamos el comando mientras estemos conectados seremos
desconectados al recibir el mensaje de abandono y seguidamente seremos conectados al servidor
especificado.

/showmirc -nrstx
Manipula la ventana principal del mIRC. -n = minimiza, -r = restaura, -s = activa, -t = iconiza, -x = maximiza.

/set <%variable> &lt;valor>
Se usa en definiciones de scripts para crear y asignar valores a variables. Las variables deber de ir precedidas por el signo %. Este valor se puede eliminar con el comando /unset {variable}. Ver la secci≤n "Variables del mIRC".

/sline [-a\r] <#canal> &lt;n·mero|nick>
Permite seleccionar o deseleccionar un elemento de la lista de nicks de un canal. El parßmetro -a permite seleccionar un nick sin deseleccionar otros que ya lo estuvieran antes. El parßmetro -r permite deseleccionar un nick.

/sound [nick/canal] &lt;fichero de sonido> &lt;mensaje>
Envφa una demanda de sonido a otro usuario. VΘase el dißlogo de Opciones de Sonido para mayor
informaci≤n. Tiene un ameno artφculo sobre este tema en esta misma Web en: "El sonido en el mIRC".

/speak &lt;texto>
Envφa el texto especificado a "Mon≤loge" o a "Text Assist", programas que digitalizan sonido a partir de cualquier texto escrito que se les envφa.

/splay &lt;fichero de sonido\stop>
Ejecuta un fichero de sonido para escucharlo solo nosotros. la orden /splay stop detiene un sonido en curso.

/sreq [+m\-m] [ask/auto/ignore]
Es la lφnea de comandos que equivale a la configuraci≤n de los botones de la radio para solicitar un DCC Send y que se encuentra en el dißlogo de opciones DCC (vΘase /creq arriba).

/timer&lt;N║/nombre> [-om] [tiempo] &lt;repeticiones> &lt;intervalo> &lt;comandos>
Nos permite ejecutar comandos con un retardo de tiempo determinado, y que estos se repitan un
n·mero concreto de veces, o indefinidamente hasta que detenemos el timer (poniendo las repeticiones a 0). El formato es: Por ejemplo: /timer1 0 20 /say estß AWAY!
Timer1 imprimirß el mensaje en el canal actual, cada 20 segundos, hasta que detengamos el
temporizador.
/timer9 14:30 1 1 /quit Adi≤s, hora de salir
Timer9 esperarß a las 14:30 y cerrarß la secci≤n con el server enviando el mensaje indicado.   
Con el modificador -m se puede especificar el tiempo del intervalo en milisegundos. Para ejecutar un timer es necesario estar conectado al server, salvo que usemos el modificador -o.
Para ver la lista de los temporizadores activos, teclee /timers. Para desactivarlos todos, teclee: /timers off, para desactivar uno determinado serφa: /timer&lt;N/nombre> off. TambiΘn es posible desactivar un rango de timers simultßneamente, por ejemplo, la siguiente orden desactiva todos los timer entre el 30 y el 39: /timer3? off
Si estamos activando un nuevo temporizador, no necesitamos especificar el n·mero del mismo,
simplemente hacemos lo siguiente: /timer 10 20 &lt;comando>
Y mIRC a±adirß  a este comando el primer temporizador libre que encuentre.
NOTA: Evidentemente es posible utilizar timers en rutinas de script aplicando identificadores. El inconveniente es que el timer no eval·a el contenido de estos tras la primera ejecuci≤n.
Por ejemplo: //time.reloj 0 600 echo -a La hora actual es: $time
Este timer nos darφa la hora cada 10 minutos, pero siempre presentarφa la misma porque $time solo es evaluado una vez, la soluci≤n es aplicar la variante: $!time. El sφmbolo "!" fuerza que el identificador sea evaluado a cada acci≤n del timer.

/timestamp [-s\-a\-e] [on\off] [&lt;ventana>]
Activa o desactiva la impresi≤n de la hora delante de los mensajes que se reciben. La orden
/timestamp sin mßs parßmetros nos indica su estado actual: on o off.
el modificador -s activa el comando solo para la ventana de status, -a lo hace para la ventana activa, -s lo aplicarß a todas las ventanas.

/titlebar [@ventana_personalizada] &lt;texto>
Presenta el texto especificado en la barra de tφtulo del mIRC o en una ventana personalizada que indiquemos.

/topic <#canal> &lt;mensaje>
Cambia el t≤pico o mensaje explicativo del canal que todos los usuarios verßn junto al nombre al hacer un /list, y en la barra de tφtulo de la ventana del canal.

/unload <-a\-rs> &lt;fichero>
Descarga ficheros de alias y de script. Ver comando /load para mßs detalles.

/url [-d] [on\off\hide]
presenta la ventana de listas de URL. Si especificamos el parßmetro -d , todas las opciones marcadas con "?" serßn eliminadas antes de que aparezca la ventana. TambiΘn podemos usar on\off para activar o desactivar la recepci≤n de URL y hide para ocultar la ventana si Θsta ya ha aparecido.

/uwho &lt;nick>
Presenta la ventana de un usuario, en la que se muestra informaci≤n sobre Θl. Se trata de la misma informaci≤n que obtendrφamos si ejecutßramos un /whois nick.

/whois &lt;nick>
Muestra informaci≤n sobre alguien.

/winhelp &lt;fichero> [palabra]
Abre el fichero .hlp especificado. Si indicamos una palabra clave lo harß por la referencia a esa palabra.

/write [-cid -s&lt;texto> -L&lt;n·mero>] &lt;fichero> [texto]
Nos permite escribir lφneas a±adidas a un fichero. El modificador -c borra el fichero completamente antes de escribir en Θl; es decir, nos permite hacer borr≤n y cuenta nueva.
/write -c c:\info.txt Prueba
Este fichero serß borrado y solo contendrß la cadena "prueba".    
        El modificador -L&lt;n·mero> especifica el n·mero de lφneas en la que se va a escribir el texto. si no lo insertamos, la lφnea serß a±adida al final del fichero: /write -L5 c:\info.txt Prueba
Esta lφnea sobreescribirß la lφnea 5 en el fichero "info.txt".
        El modificador -i indica que el texto deberφa ser insertado en la lφnea especificada en lugar de sobreescribirla. Si no indicamos ning·n texto, una lφnea en blanco serß insertada, y si no especificamos el n·mero de lφnea, una en blanco serß a±adida al final del fichero.
/write -iL5 c:\info.txt
Una lφnea en blanco serß insertada en la lφnea 5 del fichero "info.txt".
        El modificador -d elimina una lφnea del fichero. si no especificamos el n·mero de la lφnea, la ·ltima del fichero serß eliminada.
        El modificador -s&lt;texto> escanearß el fichero buscando una lφnea que comience por el texto indicado y operarß con ella.

/writeini &lt;fichero ini> &lt;secci≤n> [item] [valor]
Permite escribir y modificar valores en un fichero de texto de tipo .ini.
Por ejemplo, podemos conseguir modificar una secci≤n llamada [DDE] de un fichero: config.ini para que tenga la siguiente forma:
        [DDE]   
        ServerStatus=on   
        ServiceName=mirc
Las ordenes correspondientes serφan:
        /writeini config.ini DDE ServerStatus on
        /writeini config.ini DDE ServiceName mirc

                ----------------------( eNd Of CuT )----------------------


-#- 03.  Las partes programables en el mIRC: -#-
- -- - -- - -- - -- - -- - -- - -- - -- - -- - -

        Bueno, y eso de las partes programables que es┐?... Pues simplemente
es el lugar en donde se escribe el codigo del script.
Estas partes (como ya sabreis) son tres: Aliases, Popups y Remotes; se
encuentran en el mIRC en la opcion Tools -->   Aliases
                                               Popups
                                               Remotes
O simplemente apretando Alt+A --> Aliases.
                        Alt+P --> Popups.
                        Alt+R --> Remotes.

Estas partes se encuentran o las podemos crear en archivos ini (te recuerdo
que puede ser cualquir extension...) que pueden estar en el mismo directorio
del mIRC32.exe o que pueden estar en un directorio especifico para este tipo
de archivos. (Por ejemplo el directorio /Sistema/)

A continuacion aprenderemos a programar el script en cada una de estas tres
partes...


-#- 03.1.  Aliases. -#-
- -- - -- - -- - -- - -

        En la parte de los aliases que es lo que pondremos? Pues las alias :P
Se accede a los aliases pinchando en "Tools" y luego en "Aliases" o
simplemente aprieta "Alt+A"
Las alias las podemos interpretar como comandos hechos por nosotros mismos.
(Recuerda que hay otro tipo de comandos que son los llamados por nosotros los
"comandos base" es decir, los comandos de mIRC)
Para que podais entender esta "tonteria" os pongo un simple ejemplo:

        /Hola /echo -s Hola que tal estas hoy ┐?

Bien pues en este facil ejemplo podemos ver el alias creado por nosotros
"/Hola" y este alias ejecuta el comando base: "/echo" ; Ahora cada vez que
escribas "/hola" automaticamente se visualizara en la ventana del status la
frase: "Hola que tal estas hoy ┐?"
como puedes ver los comandos "alias" son rutinas que creamos para automatizar
cualquier proceso que no queramos escribir una y otra vez.
Tienes que tener presente un peque±o detalle que puedes ver en el ejemplo
anterior; los comandos alias van precedidos del signo "/" (aunque este signo
puede no ponerse) luego el nombre del comando alias y seguidamente un
"espacio" (Esto es importante, ya que si no lo pones de este modo, el comando
creado puede resultar que no funcione...)

Los comandos alias que creemos pueden invocar a otro comando alias, es decir,
que se puede hacer una serie de comandos para que al final de todos esos
comandos ejecuten un comando final:
por ejemplo:

        /hola /decir
        /decir /echo -s Hola que tal estas hoy ┐?

En este ejemplo se ve claro como al ejecutar el comando "/hola" este llama al
comando "/decir" el cual ejecuta el comando final que queriamos.
Si por otro lado queremos crear un comando alias en el que se ejecuten
diversos comandos, tendremos que especificar nuestro comando alias con las
llaves "{" "}" (estas llaves sirven para encerrar todos los comandos que
querramos ejecutar en un mismo comando alias)
Por ejemplo:

        /multiple {     
          /nick nEuRoNaL
          /join #Scripters
          /part #Scripters
        } 

Bueno este ejemplo es como los anteriores... como ves la sintaxis de los
alias son bastante sencillas...
En este ejemplo se ve que con el comando que escribimos nosotros "/multiple",
automaticamete el mIRC nos cambiara el nick a nEuRoNaL, entrara en el canal
#Scripters y seguidamente saldra del canal #Scripters...
Como ves este simple comando nos puede ahorrar tiempo... Y esto es uno de los
principales factores a la hora de realizar un script, el de ahorrar tiempo y
automatizar nuestras acciones en nuestras sesiones de IRC. ;)
Tambien puedes crear el comando "/multiple" en una misma linea, mediante el
signo | entre cada comando.
Por ejemplo:

        /multiple /nick nEuRoNaL | /join #Scripters | /part #Scripters

Jeje, como ves hemos hecho lo mismo, pero ahora estan todos los comandos en
una sola y unica linea. ;)

Los aliases tambien nos permiten crear alias utilizando las teclas de funcion
(como las F1, F2, etc..). Esto es algo bastante util, ya que si durante tus
sesiones de IRC, estas continuamente tecleando o realizando alguna accion, la
puedes automatizar para que al apretar F1, o F2, o F3, o... se ejecute
automaticamente.
Por ejemplo; Nosotros siempre estamos haciendo los siguientes smelys: <[:) y
};-D. Bien pues esto nos puede resultar algo co±azo teclearlos siempre que
queramos ponerlos, asi que podemos hacer lo siguiente:

        F1 /say <[:)
        F2 /say };-D

Con estas dos peque±as rutinas nos ahorraremos el teclear esos smelys, con
solo apretar la tecla "F1" el script devolvera al canal/query el smely "<[:)"
y lo mismo que al apretar la tecla "F2" devolvera el smely "};-D"
Tambien podemos crear alias para que cuando apretemos las teclas "Sift+F?" el
script ejecute alguna rutina automaticamente... Por ejemplo:

        /sF1 /quit $?="Mensaje de Salida"

Con esta rutina, al apretar "Sift+F1" el script invocara una ventana de
dialogo en donde te preguntara que mensaje quieres que salga en tu quit...

Bueno y si nos ponemos pesaos con este tema, pasa exactamente lo mismo con la
tecla "Ctrl+F?"
Ejemplo:

        /cF1 /join #$?="A que canal quieres ir┐?" 

Bien pues este ejemplo, es como los anteriores, pero ahora has de apretar las
teclas "Ctrl+F1" y en este caso el script te preguntara en una ventana de
dialogo que a que canal quieres entrar...

(Bueno, yo estos ejemplos os los explico, pero creo que son sumamente simples
y que cualquiera ya debe entenderlos e interpretarlos... ;o)

Tambien podemos crear comandos alias en donde podemos NO especificar, por
ejemplo, un canal al que quieres entrar; esto es posible mediante los llamados "Identificadores" Para que veais esto un poco mas claro pongamos un ejemplo...
(joer, que seria de este tutorial sin los ejemplos? xD ;)

        /j /join $1
                 ^^ -> representa al canal que quieras tu ("#canal")

Bien, pues en este ejemplo, como ya sabreis, el comando alias (es decir, el
que creamos nosotros) es el "/j" y el comando base (es decir, uno de los
comandos basicos del mIRC) el /join...
Con esto entramos en un canal el cual no lo especificamos en el alias... es
decir, que para poder usar ese alias tendriamos que
teclear --> /j "#canal" --> aqui escribes tu el canal al que quieras entrar
mediante el comando "/j"
Como ves, los Identificadores ($1, $2, $3, $...) son lo que le da
"flexibilidad" y manejabilidad a la hora de programar un script!

Tambien podemos hacer que el mIRC nos pregunte mediante una ventana de
dißlogo lo que queramos; esto se hace mediante la sintaxis "$?" (en ejemplos
anteriores ya la hemos usado)... Por ejemplo:

        /j /join $?="A que canal quieres ir┐?"

Aqui se ve que al teclear "/j" el mIRC sabe que debe entrar en un canal
(/join) pero al no especificar que canal y estar el "$?" aparecera una
ventana de dialogo en donde te preguntara: A que canal quieres ir┐?
con esto se puede preguntar lo que quieras...
Como nuevo nick: /n /nick $?="Tu nuevo nick es┐?";
O lo que tu quieras...

El sector de los identificadores es muy amplio, asi que os pongo una lista
copiada de la web de #Ayuda-IRC (http://www.ayuda-irc.net)... (Aqui pasa como
con la parte de comandos base del mIRC, es una lista la cual no me se de
memoria, y en donde se recogen la mayoria de Identificadores...)

                ----------------------( CuT HeRe )------------------------

        A continuaci≤n se relaciona una lista con la mayorφa de los
identificadores que se encuentran disponibles en la versi≤n 5.31 de mIRC. Es
tambiΘn necesario se±alar que existe otra serie de identificadores asociados
con los eventos de mIRC de forma exclusiva, es decir, solo se pueden usar
dentro de estos y solo en algunos de ellos, puesto que son especφficos para
los mismos; los podrß descubrir dentro de los ejemplos que se presentan del
el capitulo correspondiente a los eventos del mIRC.


                        IDENTIFICADORES DE TIEMPO Y FECHA
Se trata de una colecci≤n de funciones que devuelven valores relativos a la duraci≤n y tratamiento de intervalos de tiempo, asφ como al uso del importantφsimo comando /timer.

$ctime
Devuelve el n·mero total de segundos transcurridos desde las 0 horas de 1 de enero de 1970. Este valor es ·til puesto que normalmente los servers, que suelen trabajar bajo sistemas UNIX, nos informarßn de  los datos referidos a un momento determinado (conexi≤n de un usuario ... etc), en este mismo formato, y podemos calcular los tiempos transcurridos entre dos sucesos, o uno y el momento actual, haciendo una simple resta y, luego transformandolo a formato semanas/dφas/horas/minutos/segundos mediante el identificador $duration.

$asctime(n║)
Si el n·mero es 0 devuelve el dato: "Thu Jan 01 01:00:00 1970", si introducimos otro n·mero este se entenderß como segundos, y transformarß al formato fecha/hora el instante que resulta de sumar esos segundos al momento: "Thu Jan 01 01:00:00 1970".
Por ejemplo, si el server nos informa de que una Gline fue establecida en 8736924372, podemos ver, en formato mßs comprensible, la hora y la fecha que eso supone con la orden:
//echo -a $asctime(8736924372)

$date
Devuelve la fecha actual en formato: dφa/mes/a±o. Como ejemplo introduzca la siguiente orden:
//echo -a $date
Obtendrß una respuesta como: 19/05/98

$adate
Es igual a $date, pero devuelve al fecha en formato americano, es decir: mes/dφa/a±o

$day
Devuelve el nombre del dφa actual de la semana, en inglΘs claro ;)

$duration(n║)
Devuelve el n·mero especificado de segundos transformado al formato: semanas/dφas/horas/minutos/segundos.
Por ejemplo: //echo -s $duration($ctime)
Esta orden devolverß el tiempo transcurrido desde las 0 horas de 1 de enero de 1970 hasta el momento presente, en formato semanas/dφas/horas/minutos/segundos.

$fulldate
Devuelve la fecha en formato largo, por ejemplo: Tue May 19 13:17:08 1998

$idle
Devuelve nuestro actual tiempo idle, es decir, el tiempo transcurrido desde que enviamos el ·ltimo mensaje a IRC.

$ltimer
Devuelve el n·mero del ·ltimo timer activado con el comando /timer

$online
Devuelve el n·mero de segundos transcurridos desde que se puso a cero el reloj contador del mIRC, es decir, los segundos transcurridos desde que nos conectamos en la sesi≤n actual, o desde una fecha determinada, dependiendo como tengamos configurado el dialogo TIMER (men· TOOLS).

$ticks
Devuelve el n·mero de ticks desde que se inici≤ el sistema operativo. Esta es una unidad de medida propia del reloj interno de nuestro ordenador.

$time
Devuelve la hora actual en formato horas/minutos/segundos.

$timer(0)
Devuelve el n·mero de timers activos en el momento actual (ver comando TIMER).

$timer(n║)[.propiedad]
Devuelve todas las propiedades de timer cuyo n·mero se especifica: n·mero de repeticiones, retardo y tipo... etc. Las propiedades que podemos usar son: com, time, reps, delay, type.
Por ejemplo: $timer(n║).com
Devuelve el comando o comandos asociados al timer especificado.

$timer(n║).type
Devuelve el tipo de status del timer especificado: online/offline.

$timestamp
Devuelve la hora actual en formato: [xx:xx]. Por ejemplo: [13:34]


                        IDENTIFICADORES DE N┌MEROS Y TEXTOS
Son funciones para el tratamiento aritmΘtico de n·meros y el manejo de cadenas de caracteres.

$abs(n║)
Devuelve el valor absoluto de un n·mero, es decir, ese mismo n·mero pero sin signo.

$asc(caracter)
Devuelve el n·mero ASCII asociado al carßcter que le introduzcamos.

$calc(operaciones)
Devuelve el resultado de las operaciones especificadas. Es ·til para realizar operaciones m·ltiples de una forma sencilla.
Por ejemplo: $calc(3.14159 * (2 ^ %x % 3) - ($ticks / (10000 + 1)))
El sφmbolo "^" representa la potencia, el asterisco el producto, y "%" la divisi≤n. Evidentemente "+" y "-" son la suma y la resta. No confundir el operador de la divisi≤n con el sφmbolo "%" que precede a las variables (las cuales tambiΘn se pueden incluir en la expresi≤n), en el caso de estas el sφmbolo precede inmediatamente al nombre de la variable, mientras que si se trata del operador de divisi≤n tendrß siempre espacios en blanco a ambos lados

$chr(n║)
Devuelve el carßcter ASCII correspondiente al n·mero especificado.
Por ejemplo: $chr(65)
Devolverß el carßcter A. Como se puede apreciar es la operaci≤n inversa a la que realiza el identificador $asc.

$cos(N), $acos(N)
Devuelven el coseno y arcocoseno de un n·mero.

$tan(N), $atan(N)
Devuelven la tangente y arcotangente de un n·mero.

$count(cadena_1,cadena_2)
Devuelve el n·mero de veces que cadena_2 se encuentra repetida dentro de cadena_1.
Por ejemplo: $count (jajajajaja, ja) Devolverß: 5

$int(n║)
Devuelve la parte entera de un n·mero, sin redondear.
Por ejemplo: $int(3,94159) Devolverß: 3

$left(cadena,N)
Devuelve los N primeros caracteres de una cadena.
Por ejemplo: $left(goodbye,4) Devolverß: good

$right(cadena,N)
Devuelve los N ·ltimos caracteres de una cadena.
Por ejemplo: $right(othello,5) Devolverß: hello

$len(cadena)
Devuelve el n·mero de caracteres de una cadena, incluidos los espacios en blanco que contenga.

$lower(texto)
Retorna todos los caracteres de una cadena convertidos a min·sculas.
Por ejemplo: $lower(HOLA) Devolverß: "hola"

$mid(cadena,posici≤n,n·mero)
Devuelve el n·mero especificado de caracteres de una cadena desde una posici≤n dada.
Por ejemplo: $mid(othello,3,4) Retornarß: "hell"

$pos(cadena,sub_cadena,n·mero)
Devuelve la posici≤n en que una sub_cadena comienza dentro de una cadena. El n·mero sirve para especificar la subcadena cuando esta se repite en la cadena principal.
Por ejemplo: $pos(hello,el,1)
Devolverß: 2, puesto que la cadena "el" comienza en el segundo carßcter de la cadena "hello"

$pos(hello,la)
Devolverß: $null (valor nulo), puesto que la subcadena no se encuentra dentro de la cadena principal.
Si el n·mero especificado es 0 el identificador devolverß el n·mero de veces que la subcadena se repite, igual que el identificador $count.
Nota: personalmente he detectado fallos en este identificador en algunos combinaciones, por lo tanto ·sese con reservas y para casos contrastados.

$rand(valor1,valor2)
Devuelve un n·mero o letra aleatorio comprendido en el rango [valor1-valor2] .
Por ejemplo: $rand(1,4)
Devolverß cualquier n·mero entre 1 y 4, ambos inclusive.

$remove(cadena,sub_cadena)
Devuelve la primera cadena, de la que habrß suprimido la primera ocurrencia expresada en sub_cadena.
Por ejemplo: $remove(abcdefg,cd)
Devolverß: "abefg"

$replace(texto,cadena,reemplazo)
Busca una cadena dentro de un texto, y la reemplaza por otra especificada.
Por ejemplo: $replace(1234567,34,abc) Devolverß: "12abc567"

$round(n·mero,N)
Devuelve un n·mero especificado, con solo los N primeros decimales.
Por ejemplo: $round(3.14159,2) Devolverß: 3.14

$strip(texto)
Devuelve un texto del que eliminarß los posibles c≤digos de colores, negrita y subrayado.

$str(texto,N)
Devuelve un texto dado repetido N veces.
$str(ho,3) Devolverß: "hohoho"

$upper(texto)
Devuelve un texto dado con todas las letras pasada a may·sculas


                        IDENTIFICADORES DE FICHEROS Y DIRECTORIOS
Estas funciones permiten manipular y sacar informaci≤n de nuestra estructura de ficheros y directorios en disco desde la sesi≤n de mIRC, asφ como analizar aquellos que estßn relacionados con el propio programa mIRC.

$alias(n)
Devuelve el nombre de n-Θsimo fichero de alias cargado en ese momento. Si se especifica un 0 devolverß el n·mero de ficheros de alias que se encuentran cargados.
Es posible tambiΘn especificar un nombre de fichero en lugar del n·mero, la utilidad de esto es que el identificador devolverß $null si ese nombre de fichero no corresponde a ninguno de los ficheros de alias cargados en ese momento, e puede aprovechar en expresiones del tipo IF-ELSE (ver capφtulo acerca de la estrutura IF-ELSE).
Ejemplos:
        $alias(0) Devuelve el n·mero de ficheros de alias cargados en ese momento.
        $alias(2) Devuelve el nombre del segundo fichero de alias cargado en ese momento.
        $alias(aliases.ini) Devuelve $null si el fichero de alias especificado no estß cargado.

$dir, $sdir, $file y $hfile
Presentan un cuadro de dialogo desde el que permiten seleccionar un fichero o directorio para ser utilizado dentro de la especificaci≤n de un alias, popup, o rutina de script. $dir presenta un dialogo desde donde se puede acceder a toda la estructura de ficheros y directorios del disco permitiendo seleccionar un fichero, mientras que $file presenta solo los ficheros contenidos dentro de un determinado directorio. En ambos casos se puede especificar mediante el comodφn "*" quΘ tipos de ficheros se desea que aparezcan seg·n su extensi≤n. $hfile es igual a $file con la ·nica diferencia de que presenta los ficheros horizontalmente. $dir permite seleccionar un directorio, es ·til para casos en que no se desea que se especifique un fichero, sino tan solo un directorio.
El formato es: $dir[="Texto"] &lt;path>
$file[="Texto"] &lt;path>
$hfile[="texto"] &lt;path>
$sdir[="Texto"] &lt;path>
Por ejemplo, podemos definir una opci≤n de popups que reproduzca los ficheros de tipo midi que hay dentro de un directorio llamado "midis", del que podremos seleccionar el que deseemos:
M·sica midi: splay $file="Selecciona la m·sica" c:\midis\*.mid
Es ·til poner un sφmbolo $ adicional (dos en total) delante del identidicador, de este modo, si no se selecciona ning·n fichero o directorio el comando no se ejecutarß, de lo contrario darφa un mensaje de error de parßmetro no especificado.
Nota: no usar estos especificadores para seleccionar un fichero a enviar por DCC, puesto que este comando lleva ya incorporado su propio dialogo de selecci≤n.

$exists(fichero)
Devuelve $true si el fichero existe, y $false si no es asφ. Es ·til en instrucciones del tipo IF-ELSE.
$exists(c:\mirc\mirc.exe) Devolverß $true o $false.

$findfile(directorio, tipo_de_fichero, n·mero)
Busca en el directorio especificado (y en todos sus subdirectorios), a todos los ficheros de un determinado tipo, y presenta el path y el nombre del que tiene el n·mero de orden indicado. Si el n·mero es 0 presentarß toda la lista de ficheros encontrados de ese tipo.
Por ejemplo:    $findfile(c:\mirc,*.exe,1) Devolverß: c:\mirc\mirc.exe
                $findfile(c:\, auto*.*,1) Devolverß: c:\autoexec.bat

$getdir
Devuelve el directorio que tengamos especificado en el dißlogo DCC options, como destino por defecto para las recepciones DCC.

$getdir(tipo_fichero)    
Devuelve el directorio que tengamos especificado en el dißlogo DCC options, como destino para las recepciones DCC de ficheros del tipo especificado.
Por ejemplo: $getdir(*.txt)

$lines(fichero)
Devuelve el n·mero de lφneas que tiene un fichero de texto.
$lines(c:\irc\kicks.txt) Devolverß el n·mero de filas del fichero: c:\irc\kicks.txt

$lof(fichero)
Devuelve el tama±o en bytes de un fichero especificado.

$logdir
Devuelve el directorio especificado en la secci≤n Loggin del dißlogo File/options, es decir, el direcctorio en los que se guardarßn las copias (logs).

$mididir
Devuelve el directorio especificado para los ficheros Midi en la secci≤n Sound Requests del dißlogo File/options, es decir, aquel en el que mIRC buscarß un fichero de extensi≤n MID ante un requerimiento CTCP MIDI.

$nofile(fichero)
Devuelve el path o ruta de un fichero especificado.
Por ejemplo: $nofile(c:\mirc\mirc32.exe) Devolverß: c:\mirc\

$nopath(ruta y fichero)
Devuelve el nombre del fichero especificado, sin incluir el path.
Por ejemplo: $nopath(c:\mirc\mirc.exe) Devolverß mirc.exe

$mircdir
Devuelve el path donde se encuentra actualmente el programa mIRC.

$mircini
Devuelve el nombre del fichero .ini principal del directorio donde se encuentra el mIRC. Este es normalmente: mirc.ini.

$read
Lee una lφnea aleatoria de un fichero de texto, y la inserta dentro del alias en que se estΘ utilizando, interpretando esta lφnea como un comando de mIRC.
Su formato es: $read [-nL&lt;n·mero>] [-s&lt;texto>] &lt;fichero>
        El parßmetro "-L&lt;n·mero>" permite especificar un n·mero concreto de lφnea del fichero.
        El parßmetro "-n" permite interpretar literalmente la lφnea, no como un comando.
        El parßmetro "-s&lt;texto>" devuelve la primera lφnea que comience por el texto especificado.
Ejemplos:
/say $read c:\funny.txt Imprimirß en pantalla una lφnea aleatoria del fichero c:\funny.txt.    
/say $read -l24 c:\funny.txt Imprimirß la lφnea 24 del fichero
/pateo /kick # $1 $read kicks.txt
Harß un kick del nick especificado dando como raz≤n una lφnea elegida al azar del fichero "kicks.txt"
/say $read -smirc info.txt Busca una lφnea dentro del fichero "info.txt" que comience por "mirc", e imprime en pantalla el resto de la lφnea.
NOTA: si la primera lφnea del fichero es un n·mero el programa entenderß que representa el n·mero total de lφneas del fichero; esto acelerarß considerablemente la ejecuci≤n de $read. En caso de que especifiquemos el 0 como n·mero de lφnea, y la primera de ellas sea un n·mero, el identificador devolverß dicho n·mero.

$readini
Lee informaci≤n de un fichero .ini e inserta la fila correspondiente dentro del alias para su interpretaci≤n como un comando.
El formato es: $readini <-n>&lt;fichero> &lt;secci≤n> &lt;item>
Por ejemplo: /echo $readini mirc.ini mIRC nick
Presentarß nuestro nick actual tomßndolo del fichero mirc.ini
El parßmetro "-n" permite interpretar literalmente la lφnea, no como un comando.

$script(N/fichero)
Devuelve el nombre del n-Θsimo fichero de script cargado. Si se especifica un nombre de fichero de script en lugar de un n·mero, devolverß este mismo nombre, o $null si dicho fichero no se encuentra cargado.
Ejemplos:
        $script(0) Devuelve el n·mero de ficheros de script cargados.
        $script(2) Devuelve el nombre del segundo fichero de script.
        $script(moo.txt) Devuelve $null si el fichero no estß cargado, o moo.txt si lo estß.

$wavedir
Devuelve el directorio especificado para los ficheros WAV en la secci≤n Sound Requests del dißlogo File/options.

                        IDENTIFICADORES DE NICKS Y DIRECCIONES
Algunas de las funciones mßs interesantes del mIRC se encuentran aquφ. Una colecci≤n de identificadores ·tiles para el manejo y automatizaci≤n de labores relaccionadas con los nicks y su direcci≤n de conexi≤n al IRC e Internet.

$address(nick,tipo)
Busca en la lista interna de direcciones la direcci≤n asociada al nick especificado. Los tipos son los que se describen en el identificador $mask.
Por ejemplo: $address(nick,1)
Devuelve el formato: nick!User_ID@dominio.host
Si la lista interna no contiene el nick especificado, o se encuentra desactivada, se devolverß $null.

$comchan(nick,n║)
Devuelve los canales en que nos encontramos nosotros junto al nick especificado.
Por ejemplo:
        $comchan(nick,0) Devuelve todos los canales en que estamos nosotros y ese nick.
        $comchan(nick,1) Devuelve el primer canal en que nos encontramos junto a ese nick

$ial(mßscara,n║)[.propiedad]
Devuelve direcciones de la lista interna de direcciones.
Propiedades: nick, user, host, addr.
Ejemplos:
        $ial(*!*@*.demon.co.uk,0) Devuelve todas las direcciones que concuerdan con la mßscara especificada.
        $ial(*!*@*.demon.co.uk,3) Devuelve la tercera direcci≤n de la lista que concuerda con la mßscara especificada.
        $ial(*!*@*.com,0).nick Devuelve el nick que concuerda con la mßscara.
        $ial(*!*@*.com,4).user Devuelve el User_ID que concuerda con la mßscara.
Para escanear todas las direcciones de la lista interna se puede usar: $ial(*,0).

$ialchan(mßscara,#canal,n║)
Igual al anterior pero solo referido a la lista de ocupantes de un canal especificado.

$level(address)
Busca dentro de nuestra lista de acceso remoto el usuario con la direcci≤n especificada y devuelve su nivel de acceso.

$link(N)[.propiedad]
Devuelve el n-Θsimo server de las lista de servers enlazados en la actual red de IRC.
Propiedades: addr, ip, level, info.
Ejemplos:
        $link(0) Devuelve el n·mero de servers enlazados
        $link(1) Devuelve el primer server de la lista de links

$longip(address)
Convierte ina direcci≤n IP en su formato en entero largo, y viceversa.

$maddress(mßscara)
Busca el la lista interna de usuarios y devuelve la direcci≤n del primer usuario que corresponde con la mßscara especificada.

$mask(direcci≤n,tipo)
Devuelve la mßscara correspondiente al tipo especificado, para una direcci≤n dada.
Por ejemplo: $mask(nick!khaled@mardam.demon.co.uk,1) Devolverß: *!*khaled@mardam.demon.co.uk
$mask(nick!khaled@mardam.demon.co.uk,2) Devolverß: *!*@mardam.demon.co.uk
Los tipos de mßscara aplicables son los siguientes:
        0: *!User ID@host.dominio
        1: *!* User ID@host.dominio
        2: *!*@host.dominio
        3: *!* User ID@*.dominio
        4: *!*@*.dominio
        5: nick! User ID@host.dominio
        6: nick!* User ID@host.dominio
        7: nick!*@host.dominio
        8: nick!* User ID@*.dominio
        9: nick!*@*.dominio
La utilidad de este identificador es su uso en otros identificadores y comandos.

$me
Devuelve nuestro actual nick.

$nick(#canal,N)
Devuelve el n-Θsimo nick de la lista de nicks del canal especificado. Si ponemos 0 devolverß en n·mero de ocupantes del canal.

$nopnick(#canal,N)
Devuelve el enΘsimo nick de la lista de nicks que no tiene estatus de operador del canal especificado. Si ponemos 0 devolverß en n·mero de no operadores del canal

$notify(N)[.propidad]
Igual a los anteriores pero referido a los nicks de nuestra lista de notificaciones. Ademßs tiene las propiedades: note, sound, y whois.

$vnick(#canal,N)
Igual a los anteriores pero referido a los nicks que tengan voz dentro del canal especificado

$nvnick(#canal,N)
Igual a los anteriores pero referido a los nicks que no tengan voz dentro del canal especificado    

$opnick(#canal,N)
Igual los anteriores, pero referido solo a los nicks que tengan estatus de operadores del canal

$snicks
Devuelve en una lφnea, separados por comas, todos los nicks que tengamos seleccionados de la lista de nicks del canal.


                                                IDENTIFICADORES TOKEN
He mantenido el nombre de TOKEN para clasificar a este tipo de identificadores, tal como lo hace la ayuda de mIRC, porque es como se las alude normalmente en este "mundillo" y se trata de un grupo de funciones con una finalidad muy especφfica: el tratamiento de cadenas de caracteres, considerßndolas como una serie de elementos individuales separados todos ellos entrΘ sφ por un carßcter concreto.
Pensemos por ejemplo en una frase cualquiera; estarß formada por una serie de palabras que se pueden identificar individualmente, aunque no entendamos su significado, porque tienen siempre un caracter ASCII concreto que las separa: el espacio en blanco. Otro ejemplo es la ruta de acceso completa de un fichero en nuestro disco duro, un caso: c:\musica\midis\pelφculas\terminator.mid
Esta lφnea no es mßs que una cadena de caracteres que agrupa una serie de elementos individuales, identificables por el separador que hay entre ellos: la barra invertida: "\". Los identificadores TOKEN nos permitirßn tomar cadenas de este tipo y manejar sus elementos, a±adiendo, eliminando, sustituyendo... etc los que nosotros queramos, con solo especificar en la
funci≤n correspondiente cual es el separador com·n que hay entre ellos (este separador hay que identificarlo siempre mediante su correspondiente c≤digo ASCII; por ejemplo, el c≤digo del espacio en blanco es el 32 y el del punto el 46).
La gran utilidad de los identificadores TOKEN es que nos permiten hacer una buena emulaci≤n de lo que en programaci≤n se conoce como "tratamiento de arrays", es decir, manejar comodamente variables cuyo contenido es a su vez un conjunto de variables, todas ellas del mismo tipo, agrupadas para facilitar su manejo, e identificables individualmente por un φndice.
Veamos los que estßn disponibles:

$addtok(cadena,elemento,separador)
A±ade un nuevo elemento al final de la serie. Por ejemplo, hemos creado una variable conteniendo una serie de mombres: set %amigos Juan Antonio Pedro Luis
Desde este momento es indistinto usar la variable %amigos en el identificador o especificar la cadena completa: Juan Antonio Pedro Luis. Para el identificador no es mßs que una serie de elementos separados por un espacio en blanco.
Podemos usarlo para a±adir un nuevo elemento a la variable, separado de los demßs por un espacio en blanco, haciendo: $addtok(%amigos,Manuel,32)
Ahora la variable contendrß: Juan Antonio Pedro Luis Manuel. Podremos verlo facilmente con una orden que nos lo imprima en la ventana de estatus: //echo -s %amigos

$instok(cadena,elemento,posici≤n,separador)
Es similar al anterior, permite a±adir un elemento a la cadena, pero insertßndolo en la posici≤n que deseemos en lugar de al final de esta. Si especificamos una posoci≤n superior a la ·ltima lo a±adirß al final de la serie. Por ejemplo: $instok(1 2 3 4 5,R,3,32)
Este ejemplo devolverß: 1 2 R 3 4 5

$puttok(cadena,elemento,posici≤n,separador)
Sustituye el elemento que se encuentra en una determinada posici≤n por el que nosotros le especificamos.

$deltok(cadena,posici≤n,separador)
Devolverß la cadena, de la que habrß eliminado el elemento que se encuentra en una determinada posici≤n.

$gettok(cadena,posici≤n,separador)
Nos devuelve el elemento de la cadena que se encuentra en una determinada posici≤n. Si la posici≤n es superior a la ·ltima nos devolverß $null.
Por ejemplo: $gettok(Juan Antonio Pedro Luis,2,32) Esta funci≤n nos devolverß: "Antonio".
Si en lugar de posici≤n ponemos el valor 0 nos devolverß el n·mero de elementos de la cadena.
TambiΘn podemos indicar un rango de posiciones, es decir, pedir todos los elementos entre dos posiciones dadas, o una posici≤n y el final:
$gettok(a.b.c.d.e,2-,46) Devolverß desde la 2¬ hasta el final: b.c.d.e
$gettok(a.b.c.d.e,2-4,46) Devolverß los elementod desde el 2║ al 4║: b.c.d

$findtok(cadena,elemento,n·mero,separador)
Nos devolverß la posici≤n el la que se encuentra el elemento especificado dentro de la cadena. Si el elemento no se encuentra devolverß $null.
El n·mero sirve para se±alarle a la funci≤n, en caso de que encuentre mas de un elemento igual al se±alado, a cual de ellos nos referimos.
Por ejemplo: $findtok(A B C C D C,c,3,32)
Este ejemplo devolverß: 6, es decir, la posici≤n del tercer caracter "c" dentro de la cadena.

$remtok(cadena,elemento,n·mero,separador)
Buscarß dentro de la cadena un elemento igual al indicado, si hay varios elejirß el que hace el n·mero de orden que indicamos, y nos devolverß la misma cadena despuΘs de haber eliminado este elemento.
$reptok(cadena,elemento,nuevo_elemento,n·mero,separador)
Buscarß dentro de la cadena un elemento igual al indicado, si hay varios elejirß el que hace el n·mero de orden que indicamos, sustituirß este elemento por uno nuevo especificado, y nos devolverß la cadena resultante.


                                        IDENTIFICADORES DE VENTANAS
Funciones que nos informan acerca de distintos aspectos referios a las distintas ventanas abiertas en la sesi≤n de mIRC; ya sean de canal, chat privado, servidor de ficheros, etc.

$active
Devuelve el nombre de la ventana activa.

$appactive
Devuelve $true si mIRC es la aplicaci≤n activa en ese momento, y $false si no lo es.

$chan(N\#canal)[.propiedad]
Devuelve informaci≤n sobre los canales en que nos encontramos.
Propiedades: topic, mode, key, limit.
Si se especifica un numero en vez de un canal, devuelve el nombre de ese canal.
        $chan(0) Devuelve el n·mero de canales en que nos encontramos.
        $chan(2) Devuelve el nombre del segundo canal en que nos encontramos.
        $chan(2).key Devuelve la clave del segundo canal en que nos encontramos.
TambiΘn podemos especificar un nombre de canal, pero solo devuelve informaci≤n sobre este si nos encontramos dentro de Θl.
$chan(#mIRC).mode Devuelve los modos del canal #mirc.

$chat(N/nick)[.propiedad]
Devuelve informaci≤n sobre las ventanas de DCC chat abiertas. Propiedades: ip, status.
Por ejemplo: $chat(2).ip Devuelve la IP del segundo DCC chat activo.

$fserv(N/nick)
Devuelve informaci≤n sobre las ventanas abiertas del servidor de ficheros.
Propiedades: ip, status, cd (directorio abierto)

$get(N/nick)[.propiedades]
Devuelve informaci≤n sobre los DCC get en curso (recepci≤n de ficheros).
Propiedades: ip, status, file, size, rcvd, cps, pc.
Ejemplos:
        $get(0) Devuelve el n·mero de dcc gets en curso.
        $get(2) Devuelve el nick que envφa el segundo DCC get activo
        $get(2).rcvd Devuelve el n·mero de bytes recibidos hasta el momento en el segundo dcc get.
        $get(2).cps Devuelve el n·mero de caracteres por segundo que se estßn recibiendo en la segunda transmisi≤n de ficheros
        $get(3).pc Devuelve el porcentaje transmitido en la tercera recepci≤n en curso.

$query(N/nick)[.address]
Devuelve el nick o la direcci≤n del enΘsimo query abierto.
Propiedad: address
Ejemplos:
        $query(0) Devuelve el n·mero de querys abiertos.
        $query(2) Devuelve el nick del segundo query.
        $query(1).address Devuelve la direcci≤n del primer query.

$send(N/nick)[.propiedad]
Devuelve informaci≤n sobre los envφos de ficheros en curso (DCC sends).
Propiedades: ip, status, file, size, sent, cps, pc.
Ejemplos:
        $send(0) Devuelve el n·mero de ficheros que se estßn enviando.
        $send(2) Devuelve el nick de destino del segundo envφo.
        $send(1).sent Devuelve el n·mero de bytes enviados en el primer DCC en curso.
        $send(3).pc Devuelve el porcentaje transferido en el tercer envφo en curso.
        $send(3).status Devuelve el estado (activo, inactivo, o en espera) del tercer sed en curso.


                                        IDENTIFICADORES DIVERSOS
Aquφ cabrφan todos los identificadores no detallados anteriormente, que son muchos; pero, como ya he comentado, gran cantidad de ellos estß vinculados necesariamente a ciertos eventos y no son aplicables siempre, por lo que en generßl dos dejarΘmos para el capφtulo de Eventos. Aquφ incluirΘ una miscelßnea de mßs dificil clasificaci≤n de acuerdo a la clasificaci≤n que hace el mIRC en sus ficheros de ayuda (como vengo haciendo en el resto de este documento), y algunos
mßs que vayan surgiendo y encuentre inetesante a±adir.

$away
Devuelve el valor $true (verdadero) o $false (falso) Si estamos en estado de away o no.

$bits
Devuelve 16 o 32, seg·n tengamos la versi≤n de 16 o 32 bits del mIRC.

$cb
Devuelve los primeros 256 caracteres contenidos en el portapapeles.

$cr
Devuelve el carßcter de retorno de carro. Es equivalente a poner: $chr(13)

$ddename
Devuelve el nombre actualmente especicado para el servidor DDE

$editbox(window)
Devuelve el texto contenido en la caja de edici≤n (lφmea de escritura) de una determinada ventana.

$email
Devuelve la direcci≤n de mail especificada en la correspondiente casilla del dialogo File/Setup.     

$host
Devuelve el nombre del actual Local host.

$ignore(N)[.type]
Devuelve la direcci≤n del enΘsimo elemento de la lista de ignores.
        $ignore(0) Devuelve el n·mero de elementos incluidos en la lista de ignores.
        $ignore(1) Devuelve la direcci≤n del primer elemento de la lista de ignores.
        $ignore(2).type Devuelve el flag del segundo elemento de la lista de ignores, es decir, el tipo de ignore impuesto: a los querys, a los DCC...etc.

$inmidi e $inwave
Devuelve $true si se estß reproduciendo un fichero midi o wave respectivamente, de lo contrario devuelve $false.

$ip
Devuelve nuestra direcci≤n IP.

$lf
Devuelve el carßcter de salto de lφnea. Equivale a: $chr(10).

$port
Devuelve el n·mero del puerto del server en el que estamos conectados.

$server
Devuelve el nombre del server al que estamos conectados, o $null si estamos desconectados.
$server(N)
Devuelve la direcci≤n del enΘsimo server de la lista de servers de File/Setup/IRC Server.
Propiedades: desc (descripci≤n), port (puerto), group (grupo).
        $server(0) Devuelve el n·mero de servers de la lista.
        $server(2) Devuelve la direcci≤n del segundo server.
        $server(2).desc Devuelve la descripci≤n del segundo server.
        $server(3).port Devuelve el puerto de conexi≤n especificado para el tercer server.

$url
Devuelve la direcci≤n URL de la pßgina actualmente cargada en el navegador.
Ejemplo: /say Estoy viendo la pßgina: $url ... os la recomiendo!

$usermode
Devuelve nuestros actuales modos de usuario.

$version
Devuelve la versi≤n del mIRC en uso.

$+
Este identificador insertado en una lφnea de instrucci≤n eliminarß el espacio el espacio en blanco que se encuentra a su derecha, y el que se encuentra a su izquierda (ver la secci≤n a Alias del mIRC).

$&lt;n·mero>-
Se puede usar $1 $2 ... $N para referirse a los parßmetros o palabras individuales de una lφnea de comando. Ademßs es posible especificar $n║- para referirse al parßmetro o palabra de la posici≤n especificada, y todos los que le siguen, y $n║_1-n_2║ para referirse a todas la palabras comprendidas entre dos posiciones especificadas (ver la secci≤n de Alias del mIRC).

$address
Devuelve la direcci≤n de un usuario asociado a un evento, en la forma: User_ID@host.dominio.

$fulladdress
Devuelve la direcci≤n de un usuario asociado a un evento, en la forma: nick!User_ID@host.dominio.

$group(N/#nombre)[.status]
Devuelve el nombre o estatus de un grupo de un script.
        $group(0) Devuelve el n·mero de grupos del script.
        $group(1) Devuelve el nombre del primer grupo del script.
        $group(1).status Devuelve el estatus del primer grupo: on o off.
        $group(#name) Devuelve el estatus del grupo #name

$nick
Devuelve el nick de un usuario asociado a un evento.

$ulevel
Devuelve el nivel de acceso remoto de un usuario asociado a un evento.

                ----------------------( eNd Of CuT )----------------------

Como podras observar, hay muchisimos tipos de identificadores; tambien puedes
crear los tuyos propios... Simplemente creas uno con el nombre que quieras
(por ejemplo "&DecirHola") en ese identificador especificas el alias, el cual
es el que lleva la accion... Ejemplo:

        $DecirHola /hola
        /hola /say $me os envia un gran saludo!

El identificador "$DecirHola" invoca al comando alias "/hola" el cual es el
que envia el mensaje "$me(tu nick) os envia un gran saludo!"

Bueno, y que mas nos falta por saber sobre el aliases... que sepas que en el
aliases encontraras estructuras como las llamadas variables (se representan
por %?); las estructuras "IF-Else" (son estructuras que muestran una
condicion...) y muchas otras cosas que ya aprenderemos durante la marcha...
Aun nos falta saber las posibilidades que tienen las dos partes programables
restantes; los popups y los remotes.

En este tipo de programacion tienes que ver la relacion que hay entre
aliases, popups y remotes... (Seguramente, aun no veras dicha relacion, ya
que solo hemos dado la parte de los aliases); todas las alias se complementan
o con los popups o con los remotes y estos a su vez se relacionan entre
ellos; con lo que todas las partes estan ligadas unas con otras: Esto es
digamos el "secreto" de la programacion de Scripts para mIRC.

Resumiendo todo este tema de los aliases cabe tener muy claro que:

        _  Todo script es formado mediante los "comandos base" de mIRC.
           (/nick, /join, /kick,  etc...)
        _  Todos los comandos alias que creemos son unicamente comandos que
           invocan a los comandos base.
           (Ej: /n.join /nick nEuRoNaL | /join #Scripters | /part #Scripters
        _  Lo principal en las alias son los identificadores; (es lo que "da
           flexibilidad" a la hora de crear scripts). Son como otro tipo de
           comandos que muchas veces se entrelazan con comandos alias.
           (ejemplo: /j /join $?="A que canal quieres ir┐?" | $me os Saluda!)
        _  Tambien es importante en los aliases el uso de variables,
           estructuras "IF Else", etc... (Lo daremos mas adelante...)


-#- 03.2 Popups. -#-
- -- - -- - -- -- --

        Los popups son los menus que encontramos en el mIRC.
Se accede al popups pinchando en "Tools" y luego en "Popups" o simplemente
aprieta "Alt+P"
Estos menus pueden ser modificados creando nuestro propios menus para nuestro
script.
Para comprender bien el tema de los popups hace falta haber leido previamente
el tema de los aliases, y comprender su uso, ya que los popups son
practicamente un tipo de aliases aunque orientado a los menus mIRC. (con esto
quiero decir, que los popups son simplemente "ordenes" que, generalmente,
llaman a algun comando alias...)

Los menus de mIRC son los siguientes:

        _  Status: Este menu es el referente a la ventana "Status" del mIRC;
           se accede a el pulsando con el boton derecho del raton sobre la
           ventana "Status"
        _  Channel: Este menu es el referente al menu de las ventanas de los
           canales; se accede a el pulsando con el boton derecho del raton
           sobre la ventana de cualquier #canal.
        _  Query/Chat Este menu es el referente al menu de las ventanas
           "Query" y "DCC Chat"; se accede a el pulsando con el boton derecho
           del raton sobre la ventana de cualquier Query o DCC Chat.
        _  Nickname List: Este menu es el referente al menu de los nicks de
           un canal; se accede a el pulsando con el boton derecho sobre el
           nick que quieras que se abra el menu de Opciones "Nickname List"
        _  Menubar: Este menu es el referente al menu de la barra de tareas
           de mIRC (En el mIRC, el menu se expone como "Commands"; se accede
           a el pulsando con el boton izquierdo sobre la palabra "Commands"
           de la barra de tareas del mIRC...)

Para poder programar y modificar cada uno de los menus del mIRC, pincharemos
en "Tools" luego en "Popups" (como hemos dicho anteriormente...) y en la
ventana que aparece pulsamos sobre la opcion "View"; nos apareceran todos los
menus posibles que se pueden programar. (Status, Channel, Query/Chat,
Nickname List, Menubar)

Para comprender mejor los popups expondremos un ejemplo... A contnuacion
pondremos el menu popups del Status del mIRC (Modificado algo por mi...)

        Agradezco la ayuda a:/agradecimientos
        -
        Opciones del canal
        .Entrar en
        ..#mIRC:/join #mirc
        ..#irchelp:/join #irchelp
        ..Entrar en?:/join #$$?="Donde quieres entrar┐?"
        .-
        .Quien hay en┐?
        ..#mIRC:/names #mirc
        ..#irchelp: /names #irchelp
        ..Quien hay en?:/names #$$?="Sacar nick del canal...┐?"
        Opciones varias
        .Listar canales:/list
        .-
        .Cambiar tu nick:/nick $$?="Nuevo nick que quieres┐?"
        .Away
        ..Encender:/away $$?="Motivo porque estas away┐?"
        ..Apagar:/away
        .-
        .Whois ?:/whois $$?="Nick ┐?"
        .Query:/query $$?="Nick ┐?"
        -
        Desconectar del IRC:/quit Leaving!

Jeje, este es el Menu Status del mIRC (Aunque bastante cambiado ;)
Lo primero que has de entender es la estructura de los menus. Como ves, cada
linea del menu tiene en primer lugar un nombre (Por ejemplo -> "Opciones del
canal") Estos nombres son los que apareceran cuando pulses con el boton
derecho de tu raton sobre la ventana Status y se despliegue el menu.
El menu, a su vez puede tener otros menus (SubMenus) estos "SubMenus" se
describen mediante el punto "." que llevan delante algunos nombres...
(Por ejemplo -> .Quien hay en┐?
                ..#mIRC:/names #mirc)
Y estos submenus pueden tener otros menus y estos otros mas y asi
sucesivamente; un punto "." significa un SubMenu, dos puntos ".." significa
un Sub-SubMenu, tres puntos "..." significa un Sub-Sub-Sunmenu, y asi
sucesivamente... (Este rollo de los menus lo puedes comparar con el rollo de
los directorios de un Disco Duro; Un ejemplo de esto puede ser lo siguiente:
en el directorio "C:\Juegos" puede haber un subdirectorio llamado por ejemplo
"Quake2" y en este puede haver uno llamado "baseq2" y en este otro llamado
"players" y esto sucesivamente...)

En cada linea del menu (como hemos dicho anteriormente) esta compuesta por un
nombre; y seguidamente le acompa±a el signo ":" despues de los dos puntos ":"
sigue la accion que finalmente se ejecutara (Esta accion normalmente es un
comando aliases; aunque tambien puede invocar a una opcion del remote; o
puede que la accion sea un comando base...) para entender esta tonteria
pongamos ejemplos ;)

Ejemplo 1:      Desconectar del IRC:/quit Leaving! --> (En esta opcion del
                menu, la accion que se ejecutara sera la de un "comando base"
                el comando /quit)

Ejemplo 2:      Agradezco la ayuda a:/agradecimientos --> (En esta opcion del
                menu la accion que se ejecutara sera la de un "comando alias"
                el comando alias "/agradecimientos")

        (No pongo ningun ejemplo de alguna opcion de menu que ejecute algun
comando de los remotes para que no veias como son y os podais liar; tened
paciencia, que si estais entendiendo hasta ahora todo o casi todo lo expuesto
hasta ahora, dentro de poco estareis distribuyendo en las mejores Webs
vuestro propio Script! ;)

Bueno pues otra peque±a cosa que cabe decir es el detalle de que en algunas
opciones del menu (como por ejemplo la de -> "Opciones del canal") no le
sigue ningun ":" ni ninguna accion a ejecutar, esto es debido a que al pasar
el raton por esa opcion se abrira un SubMenu, con esto quiero decir que las
opciones de menu que no tengan delante del nombre ninguna accion, es debido a
que en la siguiente linea le precede uno o mas SebMenus... Ejemplo:

        Opciones del canal
        .Entrar en
        ..#mIRC:/join #mIRC

Como vereis en el ejemplo, la opcion "Opciones del canal" no le precede
ninguna accion ni ":" pero si seguis viendo y pasais a la siguiente linea,
vereis que lleva un punto "." quiere decir que es un SubMenu; en este ejemplo
este SubMenu tampoco lleva precedido ninguna opcion ni ":" ello quiere decir
que la siguiente linea es otro SubMenu, es dezir, un "Sub-Submenu"
especificado con los dos puntos ".." de delante de la linea. En este ejemplo,
al final de el Sub-SubMenu, aparece la accion "entrar en el canal #mIRC"

Tambien cabe resaltar la raya esa "-" esta raya lo unico que representa es
una linea entre menu y menu... Ejemplo:

        Agradezco la ayuda a:/agradecimientos
        -
        Opciones del canal

Esta "-" marca una separacion entre cada menu. Como imaginareis tambien
ponemos separar mediante estas rayas los submenus... Ejemplo:

        .Listar canales:/list
        .-
        .Cambiar tu nick:/nick $$?="Nuevo nick que quieres┐?"

Aqui se ve claramente como el "SubMenu" Listar canales queda separado del
otro "SubMenu" Cambiar tu nick ...

Bueno pues ya estan explicados los popups, no es nada mas... como vereis, la
relacion que decia que existe entre los aliases y los popups se cumple, ya
que los menus popups pueden invocar a comandos aliases o a los remotes, con
lo que todas las partes programables del mIRC se relacionan entre si mimsas;
eso es "el secreto" del Scripting. (vuelvo a repetir x)


-#- 03.3 Remotes. -#-
- -- - -- - -- - -- -

        Personalmente creo que esta parte es la mas significativa e
importante de mIRC, ya que en ella podremos crear multitud de rutinas (como
por ejemplo crear listas de usuarios, ctcp┤s, File Server...) con las que
podremos, verdaderamente, estar al tanto de todo lo que sucede alrededor de
nuestras sesiones de IRC.

Incluso podremos realizar menus popups y comandos aliases en los mismos
remotes (esto es muy util y utilizado por numerosos scripters para realizar
los llamados ADDon┤s, ficheros, normalmente con extension .mrc, "de a±adido"
que se cargan en el programa mIRC para que, de este modo, queden "instaladas"
nuevas funciones y/o menus en el mIRC.)
Se accede a los remotes pinchando en "Tools" y luego en "Remote" o
simplemente aprieta "Alt+R"

Los remotes se dividen en tres partes fundamentales:
    - Users.
    - Scripts.
    - Variables.


-#- 03.3.1 Users. -#-
- -- - -- - -- - -- -

        Se accede pinchando en "Tools" y luego en "Remote" (si lo prefieres,
aprieta "Alt+R") y luego pulsando sobre la solapa "Users".
En esta parte es donde asignaremos diferentes niveles de acceso para los
usuarios creando una lista de usuarios. De esta forma, podremos determinar
nuestra lista de amigos, enemigos...
Estos "niveles de acceso" que determinaremos son libres, es decir que
podremos asignar los numeros que queramos para cada tipo de nivel (Que sepas
que mIRC pone niveles a todos los usuarios como "normales", es decir sin
privilegios ni denegaciones (logico no?) y el numero que utiliza mIRC por
defecto es 1, aunque este numero puede variar segun lo que indique en la
opcion Tools/Remote/Options/Default User Level)

Una vez tengamos asignados numeros a nuestros deseados niveles para nuestra
lista de usuarios, deberemos utilizar los diferentes niveles para crear los
llamados eventos (estos son todos los sucesos que se van produciendo a lo
largo de una sesi≤n de chat: join┤s, part┤s, quit┤s, kick┤s...). La creacion
de estos eventos se explicara mas adelante...
La sintaxis es la siguiente:

        &lt;nivel>:&lt;nick>!&lt;user>@&lt;host>/&lt;ip>

Para facilitar la comprension de este tipo de estructura, pongamos un par de
ejemplos:

                50:nEuRoNaL!2500hz@195.53.66.56

En este ejemplo vemos que el nivel de usuario es '50' y que SOLO tendra acceso
a dicho nivel AQUEL usuario que tenga por nick 'nEuRoNaL', que su User ID sea
'2500hz' y que el host que tenga sea '195.53.66.56' (En este caso, si alguna
de estas tres cosas no coinciden, el usuario en cuestion no tendra acceso al
nivel 50)

                100:*!blackcode@*

Este caso ya es algo mas "flexible" ya que para que el usuario tenga acceso
al nivel '100', puede tener el nick que quiera (* significa que es valido
cualquiera...), el User ID debe ser 'blackcode' y su host/ip puede ser cualquiera...

Tambien es importante destacar que aquel usuario que tenga acceso a un nivel
determinado (100, por ejemplo.), tiene acceso tambien a cualquier nivel
inferior a ese (99, 98, 97, 96...); por ejemplo; en los ejemplos anteriores, el
usuario *!blackcode@* al tener acceso al nivel 100, tambien lo tiene sobre el
nivel 50.
Si quisieramos que el usuario *!blackcode@* unicamente tuviera acceso al
nivel '100' podriamos conseguirlo a±adiendo un '=' delante de la sintaxis del
usuario.
Quedaria de la siguiente forma:

        =100:*!blackcode@*

Como vereis, el "=" delante del nivel '100' determina que la persona
*!blackcode@* unicamente podra tener acceso a los eventos del nivel
determinado...

Bien, una vez conocida y comprendida la estructuracion y sintaxis de los
niveles de usuario, vamos a ver como podria ser una posible lista de usuarios
con el fin de que os hagais una peque±a idea:

        ;Ejemplo de una lista de usuarios.
        ;---------------------------------
        ;Usuarios con:
        ;------------: nivel 500 - Yo
        ;------------: nivel 400 - Bots
        ;------------: nivel 300 - Auto Op
        ;------------: nivel 100 - Auto Voz
        ;------------: nivel 10  - Auto Kick
        500:*!*2500hz@195.53.66.56
        400:CHaN!-@-
        400:NiCK!-@-
        400:MeMo!-@-
        400:oPeR!-@-
        400:SHaDoW!^@^
        300:*!*blackcode@212.79.130.*
        100:*!*E-N-G@213.4.74.*
        10:*!*mig@63.67.171.*

Bien, pues con esta reducida lista de usuarios se ve claramente su
funcionamiento.
Para una mejor lectura he comentado mediante ";" la diferente numeracion que
ha sido asignada a cada nivel de usuario.


-#- 03.3.2 Scripts. -#-
- -- - -- - -- - -- - -

        Se accede pinchando en "Tools" y luego en "Remote" (si lo prefieres,
aprieta "Alt+R").
Es la seccion "mas importante" de los remotes puesto que es donde se
colocaran todos aquellos eventos que, unicamente, podran ser activos por
aquellos usuarios que tengan el nivel de acceso requerido. Este nivel de
acceso se especifica, como ya hemos visto, en la parte de Users.

Para esquematizar y ordenar de la mejor forma posible estos eventos, decimos
que estos se dividen en tres tipos fundamentalmente:
    - Events
    - CTCP
    - RAW (Numeros RAW)


        -#- Events -#-

        Bien pues, como dije anteriormente, los events (eventos) son todos
aquellos sucesos que se van produciendo a lo largo de nuestras sesiones de
IRC...
Antes de describir la mayoria de los eventos en esta seccion, vamos a poner
un ejemplo de uno para comentar su estructuracion:

Imaginaos que queremos que cuando algun usuario entre a algun canal en donde
estemos nosotros, nuestro script nos avise mediante un sonido e imprima en
pantalla un mensaje:
Bien pues para eso pondremos:

        ON ^1:JOIN:#: {
          /splay $mircdirsonidos/join.wav
          echo # - (J)oin - $nick ha entrado en # | halt
        }

Bien pues aqui vemos que cuando algun usuario con nivel 1, es decir cualquier
usuario (recuerda que mIRC por defecto asignaba el numero 1 al nivel
"normal": usuario cualquiera.) entra en el canal "#" (canal donde estemos)
mIRC ejecutara un sonido llamado "join.wav" el cual se encuentra en la
carpeta "sonidos".
A parte de ejecutar dicho sonido, imprimira en nuestra pantalla un mensaje
diciendo: "- (J)oin - $nick ha entrado en #" (donde $nick es el usuario que
ha entrado en # , es decir, en el canal.)

Como veis, consta de una estructuracion muy simple y bastante legible...

Bien ahora imaginaos que queremos dar OP automaticamente a aquellos usuarios
que tengamos en nuestra lista de usuarios con nivel de usuario: "Auto Op" (en
el ejemplo anterior de la lista de usuarios asignamos a dicho nivel el numero
300)
En este caso pondriamos:

        ON @300:JOIN:#: {
          mode $chan +o $nick 
        }

En este caso el nivel de usuario ha cambiado, ahora es 300 (Auto Op) con lo
que nuestro mIRC solo realizara la siguiente accion a aquellos usuarios que
tengan dicho nivel; la siguiente accion es dar op (mode $chan +o $nick) en
ese canal a dicho usuario "privilegiado".

Una vez explicado la estructuracion y sintaxis de cualquier evento, os
adjunto algunos de los eventos con los que se pueden componer los remotes.
(esta lista a sido sacada de la pagina web del canal #Ayuda_IRC
(http://www.ayuda-irc.net) y ha sido realizada por SomaTic
(sucubus@arrakis.es))


                ----------------------( CuT HeRe )----------------------

#- Evento ON TEXT
Este evento se produce al recibirse un mensaje especificado, bien en un privado, o bien en un canal en el que nos encontramos.

Formato: on &lt;level>:TEXT:&lt;texto>:<*><?><#[,#]>:&lt;comandos>   
Ejemplo: on 1:TEXT:*ayuda*:*:/msg $nick ┐Cual es el problema?

El texto del mensaje que deseamos que produzca el evento se puede especificar de varias maneras:   
        *  El evento se producirß ante cualquier texto.
        &  El evento se producirß ante cualquier palabra.
        Texto  El evento se produce anta una palabra concreta y no otra.
        Texto*  Se produce ante una cadena de caracteres que comience por el texto especificado.
        *Texto  Se produce ante una cadena de caracteres que finalice por el texto especificado.
        *Texto*  El evento se produce si el texto contiene la cadena especificada, sea cual sea su                 posici≤n.
Se puede especificar el lugar donde se controlarß el evento de la siguiente forma:
        ?  Controlara la producci≤n del evento dentro de un query o de un DCC chat
        #  Controlara la producci≤n del evento dentro de un canal cualquiera en el que nos
           encontremos
        #canal_1,#canal_2,...  Controlarß la producci≤n del evento dentro de un canal
                                     especificado.
        *  Controla el evento en un privado o canal indistintamente.

Ejemplos:

        on 1:TEXT:Hola*:#:/msg $chan íBienvenido al canal $chan $nick $+ !

Esta instrucci≤n detectarß cuando alguien diga la palabra "Hola" en cualquier canal que nos encontremos, y automßticamente le darß la bienvenida al canal en cuesti≤n. El identificador $+ elimina los espacios en blanco que tiene a ambos lados, de ese modo podemos hacer que el nick de la persona que ha dicho "hola" aparezca en nuestra respuesta seguido del sφmbolo "!", si escribimos directamente este sφmbolo a continuaci≤n de $nick este no serß reconocido como un identificador del nick del usuario, sino que aparecerß literalmente como estß en la orden.   
           
TambiΘn es posible emplear variables para dar mßs flexibilidad al formato del evento, por ejemplo:   
           
        on 1:TEXT:%text:%canal:/msg $nick T· has escrito %text en el canal: %channel
           
Este ejemplo trabajarß con los valores previamente guardados en las variables %text, y %canal.   
           
Nota: Este evento se producirß solo ante textos de otros usuarios, los de usted no desencadenarßn el evento.

      
#- Eventos ON ACTION  y ON NOTICE
Tienen el mismo formato que on TEXT, y se producen a partir de una acci≤n o de una noticia respectivamente. Recordemos que una noticia se produce cuando alguien nos envφa un mensaje con el comando /notice, y una acci≤n cuando alguien efect·a una acci≤n de control dentro del canal; por ejemplo:   
           
        on 1:ACTION:*set mode*:#:/msg $chan íYa estamos jugando con los modos!
           
Esta orden detectarß cualquier acci≤n que contenga la cadena "Set mode", y emitirß un mensaje al canal en que se produce.   
           
        on 1:NOTICE:*:?:/msg $nick Estoy ocupado, espera un momento!
           
Esta orden detecta cualquier /notice recibido estando en un privado, y responde con otro /notice al autor.   


#- Eventos ON BAN y ON UNBAN
Estos eventos se producirßn cuando un usuario sea baneado o desbaneado en el canal.   

Formato: on &lt;level>:BAN:<#[,#]>:&lt;comandos>   
Ejemplos:
        on 1:BAN:#:/msg $nick Has sido baneado de: $chan
        on 9:BAN:#:/mode $chan -o $nick | /mode $chan -b $banmask

El segundo ejemplo es una acci≤n m·ltiple que quita el estatus de operador al usuario que puso el ban, y elimina este cuando el usuario baneado tiene nivel 9 o superior en la lista de usuarios de nuestro programa (la funci≤n $banmask devuelve la mßscara de baneo que fue empleada, y se usa, en este caso, para eliminar dicho baneo).


#- on 1:UNBAN:#:/msg $bnick Has sido desbaneado por $nick
Observe en este ejemplo el uso de la funci≤n $bnick. Esta devuelve el nick del usuario baneado o desbaneado, pero solo en caso de que dicho nick este incluido dentro de la mßscara del baneo. En caso contrario $bnick = $null (nulo).   

Es posible tener en cuenta en la sintaxis de la instrucci≤n los niveles del baneador y del baneado. A este fin se puede preceder el n·mero de l nivel de los signos: <,>,<=,=>,<>, ≤ =. Por ejemplo:   

        on >=2:BAN:#:/msg $chan $nick baneado $banmask (legal)
           
En esta situaci≤n, si el nivel del baneador es mayor o igual que el del usuario baneado, se comunica queeste es un ban legal (como se podrφa comunicar cualquier otra cosa)   
           
Recuerde, esta sintaxis compara los niveles de baneado y baneador, nunca que este tenga o no nivel superior o igual a 2.   
           
Nota: Estos eventos solo operan cuando el server de IRC proporciona los nicks de baneador y baneado, y no su cuando da sus direcciones.   
           
Observe el siguiente ejemplo:   

        on 1:BAN:#: {   
          if ( $banmask iswm $address( $me ,0)) || ( $me isin $banmask ) { echo -s $nick te ha
          baneado con esta mßscara: $banmask }
          if ( $me isop $chan ) { mode $chan -ob+b $nick $banmask $address($nick,2) }
        }

Esta rutina se inicia cada vez que se produce una acci≤n de baneo en un canal en que nos encontramos. En primer lugar comprueba que la mßscara del ban coincide con la nuestra o bien tiene incluido nuestro nick, en tal caso emite un mensaje a la ventana de estatus especificando la persona que lo ha realizado y la mßscara con la que se ha hecho el ban, a continuaci≤n comprueba si somos operadores del canal, y en tal caso retira el estatus de operador a quien nos ha baneado, y le banea a su vez.


#- Eventos ON CHAT y ON SERV
Los eventos on CHAT y on SERV se producen cada vez que es enviado un mensaje la una ventana de DCC chat, o a un Fserve respectivamente. Es similar al evento on TEXT, el cual no funciona en un chat ni en un servidor de ficheros.

Formato: on &lt;level>:&lt;CHAT/SERV>:&lt;texto>:&lt;comandos>
Ejemplo: on 1:CHAT:*ayuda*:/msg $nick Cual es el problema?

La especificaci≤n del texto que producirß el evento se hace de la misma forma que en ON TEXT.


#- Eventos ON CHATOPEN y ON CHATCLOSE
Estos eventos se producen al abrirse o cerrarse (respectivamente), una sesi≤n de DCC chat.   

Formato: on &lt;level>:CHATOPEN:&lt;comandos>
Ejemplo: on 1:CHATOPEN:/msg =$nick Bienvenido!
Ejemplos:

        on 1:CHATOPEN:/msg =$nick Hola, estoy contigo en un momento.
           
Esta instrucci≤n envφa una frase al DCC chat cuando este se abre por primera vez. El uso del signo "igual" delante de $nick es necesario para que el mensaje se dirija a la misma ventana del DCC chat, y no a una ventana privada aparte.

        on 1:CHATCLOSE:/notice $nick fin de la discusi≤n!

Esto se produce al cerrar la ventana del DCC chat.


#- Eventos ON SERVOPEN y ON SERVCLOSE
Estos eventos se producen al abrirse o cerrarse (respectivamente), una sesi≤n del FSERVE .

Formato: on &lt;level>:CHATOPEN:&lt;comandos>
Ejemplo: on 1:CHATOPEN:/msg =$nick Bienvenido!


#- Eventos ON CONNECT y ON DISCONNECT
El evento on CONNECT se produce cuando mIRC conecta al server de IRC, despuΘs de visualizar el MOTD (mensaje del dφa del servidor).

Formato: on &lt;level>:CONNECT:&lt;comandos>
Ejemplo: on 1:CONNECT:/join #ayuda_irc

on DISCONNECT es otro evento con el mismo formato, que se produce al desconectarse del server.

Ejemplo:   
        on 1:CONNECT:/echo Conectado a $server a las $time Tu nick es: $nick


#- Evento ON CTCPREPLY
Se produce cuando otro usuario responde a una pregunta CTCP por parte de usted.

Formato: on &lt;level>:CTCPREPLY:&lt;texto>:&lt;comandos>
Ejemplo: on 1:CTCPREPLY:VERSION*:/echo $nick estß usando IRC cliente: $1-

Ver evento on TEXT para los formatos de texto aceptados.
Ejemplo:

        on 1:CTCPREPLY:PING*:/echo -s $nick ha respondido al ping!


#- Eventos ON OP y ON DEOP
Se producen cuando un usuario del canal es opeado o deopeado.

Formato: on &lt;level>:OP:<#[,#]>:&lt;comandos>
Ejemplo: on 1:OP:#ayuda_irc:/msg $nick No abuses del estatus!

El evento on SERVEROP es exactamente igual, y se produce cuando un usuario es opeado por el server.
           
Ejemplos:

        on 9:OP:#:/mode $chan -o $opnick | /msg $nick no opees a esa persona!

En este ejemplo el evento se produce cuando es opeado un usuario de nivel de acceso 9 en nuestra secci≤n de remotes. $opnick devuelve el nick de la persona opeada o deopeada, y $nick el de la que lo ope≤ o deope≤.

        on 1:DEOP:#ayuda_irc:/mode $chan +o $opnick

Con esta orden devolvemos el op a cualquier persona que sea deopeada en el canal #ayuda_irc.
          
Es posible tener en cuenta en la sintaxis de la instrucci≤n los niveles del opeador y del opeado. A
 este fin se puede preceder el n·mero de nivel de los signos: <,>,<=,=>,<>, ≤ =. Por ejemplo:

        on >=2:OP:#mIRC:/msg $chan $nick opeado (legal)

En esta situaci≤n, si el nivel del opeador es mayor o igual que el del usuario opeado, se comunica que este es un op legal (como se podrφa comunicar cualquier otra cosa)
Recuerde, esta sintaxis compara los niveles de opeado y opeador, nunca que este tenga o no nivel superior o igual a 2.

Nota: Estos eventos solo operan cuando el server de IRC proporciona los nicks de opeador y opeado, y no su cuando da sus direcciones.


#- Eventos ON VOICE y ON DEVOICE
Se produce cuando un usuario recibe o es privado de voz en un canal moderado en que nos encontramos.

Formato: on &lt;level>:VOICE:<#[,#]>:&lt;comandos>
Ejemplo: on 1:VOICE:#:/msg $vnick ya tienes voz en: $chan

Ejemplos:

        on 9:VOICE:#:/mode $chan -v $vnick | /msg $nick No des voz o ese tφo!

Esta orden se ejecuta cuando el que recibe voz tiene nivel 9 o superior.

        on 1:DEVOICE:#mIRC:/mode $chan +v $vnick

Devuelve la voz al que se le quite en el canal.
Son aplicables tambiΘn los prefijos de comparaci≤n de niveles descritos en on BAN y on OP.


#- Evento ON DNS
Se produce cuando hacemos un requerimiento DNS (comando /dns).

Formato: on &lt;level>:DNS:&lt;commandos>
Ejemplo: on 1:DNS:/notice $me resuelto: $raddress

Ejemplo:

        on 1:DNS:/echo $nick ip address: $iaddress named address: $naddress resolved address: $raddress


#- Evento ON ERROR
Se produce cuando el server envφa un mensaje de error, por ejemplo, en una desconexi≤n.

Formato: on &lt;level>:ERROR:&lt;texto>:&lt;commandos>
Ejemplo: on 1:ERROR:*server full*:/echo Has salido del server!

Ver el evento on TEXT para el formato del texto.

Ejemplos:

        on 1:ERROR:*banned*:/echo Has sido baneado de este server!


#- ON FILESEND y ON FILERCVD.
   ON SENDFAIL y ON GETFAIL
Se producen al completarse un dcc send o un dcc get (envio o recepci≤n de ficheros reapectivamente).

Formato: on &lt;level>:FILESENT:&lt;filename[,filename]>:&lt;comandos>
Ejemplo: on 1:FILESENT:*.txt:/msg $nick ahφ te mando: $filename !!

Los eventos on SENDFAIL y on GETFAIL se producen cuando un dcc send o un dcc get son fallidos.

Ejemplos:

        on 1:FILESENT:*.txt,*.ini:/echo Enviado $filename a $nick $address

Se produce cuando enviamos un fichero .TXT o INI. $filename devuelve el nombre del fichero enviado.

        on 1:FILERCVD:*.txt,*.ini:/echo Recibido $filename de $nick | /run notepad.exe $filename

Esta orden avisa cuando hemos recibido ficheros .TXT e .INI, y abre el bloc de notas para ver su contenido.

        on 1:SENDFAIL:*.txt:/echo Ha fallado el envφo de $filename a $nick!!


#- Evento ON INPUT
Se produce cuando introducimos texto en una caja de texto y pulsamos INTRO.

Formato: on &lt;level>:INPUT:&lt;commandos>
Ejemplo: on 1:INPUT:/echo Texto introducido: $1-

La funci≤n $1- devuelve en este caso toda la cadena de texto introducida.


#- Evento ON INVITE
Se produce cuando un usuario nos invita a un canal.

Formato: on &lt;level>:INVITE:<#[,#]>:&lt;comandos>
Ejemplo: on 1:INVITE:#mIRC:/join $chan


#- Eventos ON JOIN y ON PART
Se producen al entrar o salir un usuario de un canal en que nos encontramos

Formato: on &lt;level>:JOIN:<#[,#]>:&lt;comandos>
Ejemplo: on 1:JOIN:#:/msg $nick Hola!


#- Evento ON KICK
Se produce cuando un usuario es expulsado de un canal en el que nos encontramos.

Formato: on &lt;level>:KICK:<#[,#]>:&lt;comandos>
Ejemplo: on 5:KICK:#:/invite $knick $chan | /msg $nick Hey, $knick ese es mi amigo!

Es aplicable tambiΘn aquφ la regla de comparaci≤n de niveles de los nicks descrita el los eventos on BAN y on OP.


#- Eventos ON LOAD y ON START
Estos eventos se producen cuando un fichero de script es cargado o descargado.

Formato: on &lt;level>:LOAD:&lt;commandos>
Ejemplo: on 1:LOAD:/echo mIRC Script cargado!


#- Eventos ON MIDIEND y ON WAVEEND
Se produce cuando el mIRC termina la reproducci≤n de un fichero MIDI o WAV

Formato: on &lt;level>:MIDIEND:&lt;commandos>
Ejemplo: on 1:MIDIEND:/splay jazzy.mid

Este evento no tiene funciones asociadas. No se producirß si la reproducci≤n se detiene a causa de una interrupci≤n, solo lo hace cuando la reproducci≤n es completada.


#- Evento ON MODE
Se produce cuando un usuario cambia los modos del canal (pero no los de usuario).

Formato: on &lt;level>:MODE:<#[,#]>:&lt;comandos>
Ejemplo: on 1:MODE:#ayuda_IRC:/notice $me $nick Cambia modos de $chan a: $1-


#- On SERVERMODE es otro evento que se produce cuando los modos son cambiados por el servidor.

Ejemplo:
        on @1:MODE:#:/notice $me $nick changed $chan mode to $1-

Esta instrucci≤n se produce cuando alguien cambia los modos del canal teniendo nosotros tambiΘn el estatus de operador.


#- Evento ON NICK
Se produce cuando un usuario cambia de nick dentro del canal.

Formato: on &lt;level>:NICK:&lt;commandos>
Ejemplo: on 1:NICK:/msg $nick Hi $newnick!

$nick devuelve el nick antiguo; $newnick el nuevo.


#- Evento ON NOSOUND
Este evento se produce cuando alguien activa un sonido en el canal y el mIRC no encuentra el fichero midi o wav en nuestros directorios de sonidos, los especificados en el dialogo FILE/OPTONS/SOUNDS.

Formato: on &lt;level>:NOSOUND:&lt;comandos>
Ejemplo: on 1:NOSOUND:/notice $nick No tengo el fichero $filename


#- Eventos ON NOTIFY y UNOTIFY
Se producen al entrar o salir del IRC un usuario que se encuentra en nuestra lista de notificaciones.

Formato: on &lt;level>:NOTIFY:&lt;commandos>
Ejemplos:

        on 1:NOTIFY:/msg $nick Hola nick, ya te veo venir!!! :)
        on 1:NOTIFY:/notice $me $nick se va del IRC *sniff* :-(


#- Eventos ON QUERYOPEN y ON QUERYCLOSE
Se producen respectivamente al abrirse una ventana de query.

Formato: on &lt;level>:QUERYOPEN:&lt;comandos>
Ejemplo:

        on 1:QUERYOPEN:/echo -s Abierto query con: $nick $address | / msg $nick Hola $nick


#- Evento ON QUIT
Se produce cuando un usuario que estß en nuestro canal sale del IRC.

Formato: on &lt;level>:QUIT:&lt;commandos>
Ejemplos:

        on 1:QUIT:/notice $me $nick sale del IRC con el mensaje: $1- on 1:QUIT:/msg $chan Bye-Bye to $nick *sniff*


#- Evento ON SNOTICE
Se produce cuando recibimos una noticia del server.

Formato: on &lt;level>:SNOTICE:&lt;texto>:&lt;commandos>
Ejemplo: on 1:SNOTICE:*client connecting*:/halt

Para una explicaci≤n del formato del texto, ver el evento on TEXT.

Ejemplo:

        on 1:SNOTICE:*split*:/splay hack.wav

Activa un fichero de sonido en caso de una noticia del server anunciando un split.


#- Evento ON TOPIC
Se produce cuando alg·n usuario cambia el t≤pico del canal.

Formato: on &lt;level>:TOPIC:<#[,#]>:&lt;comandos>
Ejemplo: on 1:TOPIC:#mIRC:/msg $chan Hmm, que t≤pico mas cutre!!!: $1-

La funci≤n $1- devuelve el texto completo del nuevo t≤pico.


#- Evento ON USERMODE
Se produce cuando cambiamos nuestros modos de usuario.

Formato: on &lt;level>:USERMODE:&lt;commandos>
Ejemplo: on 1:USERMODE:/echo nuevos modos: $1-


#- Evento ON WALLOPS
Se produce cuando recibimos un wallops message.

Formato: on &lt;level>:WALLOPS:&lt;texto>:&lt;commandos>
Ejemplo: on 1:WALLOPS:*aviso*:/echo $nick mensaje de aviso a las: $time

Ver el evento on TEXT para una explicaci≤n de los posibles formatos del texto.


#- Eventos ON TOPIC
Se produce cuando alg·n usuario cambia el t≤pico del canal.

Formato: on &lt;level>:TOPIC:<#[,#]>:&lt;comandos>
Ejemplo: on 1:TOPIC:#mIRC:/msg $chan Hmm, que t≤pico mas cutre!!!: $1-

La funci≤n $1- devuelve el texto del nuevo t≤pico. 


                ----------------------( CuT HeRe )----------------------


        -#- CTCP -#-

        CTCP - Client To Client Protocol - podriamos decir que los CTCPs son
otro tipo distinto de eventos "especializados" en la comunicacion entre los
distintos usuarios conectados a un servidor de IRC.
Normalmente, usaremos los CTCP┤s para hacer que el usuario haga/responda de
forma automatica alguna accion cuando reciba la informacion necesaria que
nosotros le hallamos enviado por CTCP.
Visto de esta forma parece algo dificil de entender; pongamos un ejemplo para
aclararlo:

Imaginaos que nosotros queremos saber cuanto LAG tiene el usuario de nick
'Pepe'. Para saber dicha "informacion" deberemos de enviarle un ctcp del tipo
'PING' y, de esta forma, el usuario 'Pepe' nos respondera con un 'Ping Reply'
donde obtendremos el tiempo de lag de dicho usuario.

La sintaxis del CTCP es de la forma: /ctcp &lt;nick> &lt;accion/mensaje>
Ejemplo: /ctcp Pepe ping

Tambien saber que podremos enviarle algun CTCP y no recibir respuesta
alguna... esto es que el script que utilice el usuario al que le hagamos el
CTCP que sea no tiene asignado un CTCP Reply (CTCP de respuesta) para ese
CTCP en concreto; por ejemplo:

        Nosotros enviamos un CTCP Ping al usuario Pepe:
                /ctcp Pepe ping
        Y su mIRC/Script nos respondera automaticamente un mensaje (CTCP
        Reply) con la informacion referida al CTCP Ping:
                [Pepe PING reply]: 2secs

En este caso SI que recibiremos respuesta por parte del usuario; pero si
realizamos algun CTCP que el usuario al que se lo hallamos hecho no tenga un
Reply para dicho CTCP, el usuario no nos respondera automaticamente.
Por ejemplo:

        Nosotros enviamos un CTCP hola al usuario Pepe:
                /ctcp Pepe hola
        Como el mIRC/Script de dicho usuario no tiene informacion asignada a
        dicho CTCP, no realizara ninguna accion ni mensaje...

Bien, con esto podriamos decir que mIRC en si trae por defecto asignados un
par de CTCP Replys para un par de CTCP┤s. Estos son los siguientes:
- CTCP Ping - (Mensaje Reply: [Pepe PING reply]: 2secs)
- CTCP Finger - (Mensaje Reply: [Pepe FINGER reply]: &lt;Mensaje> Idle 2799
                seconds)
- CTCP Version - (Mensaje Reply: [Pepe VERSION reply]: mIRC32 v5.7
                 K.Mardam-Bey)
- CTCP Time - (Mensaje Reply: [Pepe TIME reply]: Fri Feb 25 18:03:28 2000)

Si lo preferimos, tambien podemos modificar el tipo de "Mensaje Reply" para
que nos quede un poco mas vistoso.
Por ejemplo; el Mensaje Reply por defecto del CTCP Ping es:

        [Pepe PING reply]: 2secs

Bien, pues en vez de eso, podemos hacer que nos responda con otro tipo de
mensaje. Para ello, creamos un evento del tipo 'CTCPREPLY'.
Su sintaxis es la siguiente:

        on 1:CTCPREPLY:&lt;ctcp>:{ comandos }

En &lt;ctcp> pondremos el CTCP que queramos responder con nuestro Reply
personalizado... (Ping, version, Time...);
Ejemplo:

        on 1:CTCPREPLY:*PING*:{
          %lag = $ctime - $2  
          echo $nick tiene un LAG de: %lag Segundo(s)
          halt
        }

Aqui teneis un simple ejemplo de un PING Reply personalizado por nosotros.
%lag es una variable (las cuales las explicaremos mas adelante...) que, en
este caso, "recoge" la cantidad de lag que tiene el usuario a quien le
hayamos hecho un "/ctcp &lt;usuario> ping"; la respuesta que recibiremos sera un
mensaje impreso en nuestro status diciendo lo siguiente:

        Pepe tiene un LAG de: 1 Segundo(s)

Donde 'Pepe' es $nick (es a quien le hemos hecho el CTCP Ping) y '1' son los
segundos que ha "registrado/recogido" la variable %lag sobre el usuario
'Pepe'

Una vez ya introducidos un poco en la sintaxis de los CTCP, aprenderemos a
realizar nuestros propios CTCP Replys para cualquier CTCP que queramos crear
para nuestro script.
Para empezar, veremos como son este tipo de eventos; su sintaxis es de la forma:

        ctcp &lt;nivel>:&lt;ctcp>:<#,?,*>:{ comandos }

Asi es la estructura general de cualquier CTCP Event; donde &lt;nivel> es el
nivel de usuario que queramos que vaya dirijido el CTCP; &lt;ctcp> es el CTCP
que queramos especificar para luego devolver el Reply; '#' se utiliza si nos
referimos a algun canal, '?' si es para un query, '*' si queremos que sea
para cualquier cosa...
Para verlo de una forma mas sencilla la estructuracion del CTCP Event,
pongamos un simple ejemplo:

        ctcp 1:*hola*:*:{
          /msg $nick Hola $nick - ┐Que tal? ;)
        }

Con este simple evento conseguiras que cuando alguien te envie un "/ctcp
&lt;tu_nick> hola"; tu, automaticamente, le respondas al CTCP mediante el Reply
indicado; es decir, que le haras un /msg (mensaje/privado) a $nick (quien te
haya hecho el CTCP) diciendole: "Hola $nick - ┐Que tal? ;)"

Tambien podreis crear vuestros propios Reply┤s a aquellos CTCP┤s que mIRC
responde por defecto (es decir, los que ya comentamos anteriormente: ping,
version, finger, time).
Esto puede ser de utilidad si, por ejemplo, no quereis que nadie sepa vuestro
LAG cuando alguien os haga un "/ctcp &lt;tu_nick> ping" o, si por otro lado,
quereis poner un 'Version reply' para vuestro script. (en vez del reply por
defecto de mIRC...)
Vamos un par de ejemplos:

        ctcp 1:PING:*:{
          /msg $nick Acceso denegado. Informacion no disponible...
          halt
        }

Este ejemplo es para el caso de que no quereis que nadie sepa vuestro LAG.
Cuando alguien os haga un "/ctcp &lt;tu_nick> ping" vosotros le respondereis con
un mensaje diciendo "Acceso denegado. Informacion no disponible..." y luego
acabara la respuesta gracias al comando que hemos puesto "halt". (Como
vereis, gracias a 'halt' conseguimos no revelar nuestro LAG...)

        ctcp 1:VERSION:*:{
          .notice $nick Estoy usando '@_2500Hz mIRC-Script' v1.0 -
        }


        -#- RAW -#-

        Los numeros (tambien llamados codigos) RAW son quienes identifican
las diferentes respuestas que nos dara un servidor cuando estamos conectados
a el y le enviamos algun comando del mIRC (como por ejemplo /whois, /away,
/lusers...)
Pongamos el clasico ejemplo con el comando /whois "nick" ... Imaginaos que le
hacemos un /whois al nick 'nEuRoNaL' y no hay ningun usuario con ese nick; la
respuesta que recibiremos por parte del servidor sera:

        -
        nEuRoNaL No such nick/channel
        nEuRoNaL End of /WHOIS list
        -

Pues bien cada mensaje equivale a un numero RAW diferente... en este caso el
mensaje de 'nEuRoNaL No such nick/channel' equivale al numero RAW 401 y el
mensaje de 'nEuRoNaL End of /WHOIS list' equivale al numero RAW 318

Esto es basicamente los numeros RAW... y fundamentalmente se utilizan para
traducir los diferentes mensajes que responde el servidor al castellano,
tambien se le pueden poner colorines, negrita... todo lo que querais pudiendo
hacer un script con un buen dise±o en todos sus aspectos x)

Bueno... sigamos con el ejemplo anterior; imaginaos que queremos traducir y
cambiar ese mensaje... para ello nos vamos a la parte de los remotes
(aconsejo crear un nuevo fichero con el nonmbre de raw.ini donde metais todos
los numeros RAW que querais para vuestro script, para que asi tengais mejor
organizado el codigo de vuestro script...) y escribimos lo siguiente:

        raw 401:*:echo -a - | echo -a <☻♥4 $parm2 ☻♥1> no esta conectado al IRC... | halt
        raw 318:*:echo -a Final del Quien es: <☻♥4 $parm2 ☻♥1> | echo -a - | halt

Como veis en las lineas anteriores... la sintaxis de los numeros RAW es:

        raw "numero":*:"comando" (el '*' equivale a un texto, lo normal es poner *, cualquiera)

Un detalle que cabe resaltar es como terminaos de definir el numero RAW: con
la orden 'halt' esto lo ponemos para que, despues de que imprima el mensaje
que le hayamos dicho, de por acabada la accion.

Poniendo las lineas anteriores en nuestros remotes obtendremos la siguiente
respuesta:

        -
        < nEuRoNaL > no esta conectado al IRC...
        Final del Quien es: < nEuRoNaL >
        -

Como vereis el mensaje ha cambiado, he incluso sale en color rojo y en
negrita el nick.

No hay que saber mucho mas de los numeros RAW, simplemente saber que todos
los mensajes equivalen cada uno a un numero RAW; como imaginareis la lista
puede ser inmensa con lo que si estas interesado en conocer todos los
numeros RAW te recomiendo que descargues de internet el  rfc 1459 : "Internet
Relay Chat Protocol". Este documento fue escrito en 1993 y aunque sea antiguo
nos sigue siendo muy util.
Lo podras encontrar en: http://members.es.tripod.de/anthrax/rfc1459.zip

Para finalizar con este tema os pondre una peque±a lista de los numeros RAW
mas comunes y utilizados; pero antes sigamos viendo un par de ejemplos mas:

Sigamos con el ejemplo de /whois "nick" esta vez veremos la respuesta que nos
da el servidor cuando dicho "nick" si esta conectado al servidor:

        nEuRonaL is 2500hz@195.53.66.56 * @_2500Hz - Underground Scene -
        nEuRonaL on @#@_2500Hz @#BLaCkCoDe #cyber_punk
        nEuRonaL using bigbang.irc-hispano.org Servidor irc de kaos-online
        End of /WHOIS list.

En el whois nos encontramos con cuatro lienas que equivalen a los numeros
RAW: 311 (RPL_WHOISUSER), 319 (RPL_WHOISCHANNELS), 312 (RPL_WHOISSERVER) y
318 (RPL_ENDOFWHOIS) respectivamente.

Bien pues una vez conocidos los numeros RAW para cada uno de los mensajes
podemos comenzar a personalizar la respuesta:

        raw 311:*:echo -a Quien es <☻♥4 $parm2 ☻♥1> | echo -a . | echo -a Nombre: <☻♥4 $parm6* ☻♥1> | echo -a Direccion: <☻♥4 $parm3 $+ @ $+ $parm4 ☻♥1> | halt
        raw 319:*:echo -a Canal(es) <☻♥4 $parm3* ☻♥1> | halt
        raw 312:*:echo -a Servidor <☻♥4 $parm3 - $parm4* ☻♥1> | halt
        raw 318:*:echo -a Final del Quien es: <☻♥4 $parm2 ☻♥1> | echo -a - | halt

Con esto nuestro script nos mostrara la siguiente respuesta:

        Quien es < nEuRonaL >
        .
        Nombre: < @_2500Hz - Underground Scene - >
        Direccion: < blackcode@195.53.66.56 >
        Canal(es) < @#@_2500Hz @#BLaCkCoDe #cyber_punk >
        Servidor < bigbang.irc-hispano.org - Servidor irc de kaos-online >
        Final del Quien es: < nEuRonaL >

Si quereis ampliar la informacion del whois, por ejemplo si el usuario al que
le haces whois esta away, tambien puedes personalizar el mensaje a±adiendo un
RAW mas a tu whois personalizado:

        raw 311:*:echo -a Quien es <☻♥4 $parm2 ☻♥1> | echo -a . | echo -a Nombre: <☻♥4 $parm6* ☻♥1> | echo -a Direccion: <☻♥4 $parm3 $+ @ $+ $parm4 ☻♥1> | halt
        raw 319:*:echo -a Canal(es) <☻♥4 $parm3* ☻♥1> | halt
        raw 312:*:echo -a Servidor <☻♥4 $parm3 - $parm4* ☻♥1> | halt
-->     raw 301:*:echo -a Esta Away, Razon:á<☻♥4 $parm3* ☻♥1> | halt
        raw 318:*:echo -a Final del Quien es: <☻♥4 $parm2 ☻♥1> | echo -a - | halt

Como veis, tenemos el whois del ejemplo anterior mas el numero RAW 301
(RPL_AWAY) que equivale al mensaje de Away; el mensaje que nos dara el script
si al usuario al que le haremos un whois esta away sera el siguiente:

        Quien es < nEuRonaL >
        .
        Nombre: < @_2500Hz - Underground Scene - >
        Direccion: < blackcode@195.53.66.56 >
        Canal(es) < @#@_2500Hz @#BLaCkCoDe #cyber_punk >
        Servidor < bigbang.irc-hispano.org - Servidor irc de kaos-online >
-->     Esta Away, Razon:á< Estoy trabajando... >
        Final del Quien es: < nEuRonaL >

Como ultimo ejemplo veamos el comando /away; el mensaje que recibiremos a
ponernos away sera:

        You have been marked as being away

Para poder personalizar este mensaje tendremos que conocer con que numero RAW
se identifica; ese el el 306 (RPL_NOWAWAY) con que no nos queda mas que hacer
el mensaje:

        raw 306:*: { echo -a Ahora estas <☻♥4 Away ☻♥1> | halt }

Con esto conseguiremos cambiar el mensaje a:

        Ahora estas < Away >

Cuando volvemos a ejecutar el comando /away para quitarnos del estado de away
nos aparece por defecto el mensaje:

        You are no longer marked as being away

Este mensaje equivale al numero RAW 305 (RPL_UNAWAY) y para personalizarlo ya
sabeis que hacer no? ;):

        raw 305:* { echo -a Estado de  Away <☻♥4 Finalizado ☻♥1> | halt  }

Con esto conseguimos cambiar el mensaje a:

        Estado de Away < Finalizado >

Bueno y podriamos estar asi un laaaargo tiempo... como veis, el unico secreto
de los numeros RAW es saber que numeracion corresponde con cada mensaje.

A continuacion os remito una lista de algunos de los numeros RAW mas comunes
y utilizados; esta peque±a lista la he sacado del documento sobre numeros RAW
escrito por HOWE para #Scripting (http://www.lanzadera.com/canalscripting):

BIENVENIDA SERVIDOR
001     Respuesta Bienvenida Servidor - "Wellcome to..."
002     Respuesta Bienvenida Host - "Tu host es..."
003     Respuesta Bienvenida Fecha - "this server was created..."
004     Respuesta Bienvenida


AWAY
301     Respuesta Away - "Nick esta away - &lt;motivo>"
305     Respuesta Away - "Dejas de estar Away"
306     Respuesta Away - "A partir de ahora estas Away"


WHOIS
311     Respuesta User
        $parm2 ---> nick
        $parm3 ---> user ident
        $parm4 ---> host
        $parm6 ---> Nombre "Real" (1¬ palabra)
        $parm7 ---> Nombre "Real" (2¬ palabra)
        etc...

312     Respuesta Servidor
        $parm3 ---> Su servidor IRC

313   Respuesta IRCop
        $parms por defecto: "&lt;nick> :is an IRC operator"

317   Respuesta idle
        $parm3 Tiempo de idle
        $parm4 Tiempo de Conexion al server

401     Respuesta Whois - "NO SUCK NICK..."
        Indica ke el nick no se encuentra

318     Fin del Whois û END OF WHOIS

319   Canales en los ke esta el individuo
        $parm3 ---> primer canal
        $parm4 ---> segundo canal
        etc... (usa $parm3* para englobarlos todos)


WHOWAS
314     Respuesta Whowas
        $parm2 ---> Nick
        $parm3 ---> User Ident
        $parm4 ---> Host
        $parm6* --> Nombre "Real"

369     Respuesta Fin del Whowas


WHO
352     Respuesta del who
        $parm3 ---> User Ident
        $parm4 ---> Host
        $parm6 ---> Nick

315     Fin del Who


TOPIC
331     El canal .. no tiene ningun topic
        $parm2 ---> Canal

332   El topic del canal .. es ..
        $parm2 ---> Canal
        $parm3* --> Topic

333     Kien y cuando se puso el topic
        $parm3 ---> Kien lo puso
        $parm4 ---> Cuando lo puso


OTROS
351     Version del servidor
        $parm4
        $parm2

421     El comando no existe
        $parm2 ---> comando erroneo ejecutado

481     No eres IRCop

482     No eres OP

474     No puedes pasar al canal porke estas baneado
        $parm2 ---> canal donde te pusieron el ban

Por ultimo te recomiendo que para tener mas informacion sobre los numeros RAW
descarges el siguiente fichero:

	http://www.ayuda-irc.net/downloads/rawhelp.zip

Este archivo zip contiene dos archivos:
* numeric.hlp: Se trata del "Jeepster's numeric reference"; es una completa
referencia de los numeros RAW. Incluye una completa lista en formato .help
para Windows y alguna informacion mas de interes. (Esta en ingles.)
* rawtool.ini: No es mas que un fichero de script realizado por SomaTic, con
la idea de que cada vez que se introduzca un comando dirigido al server,
informase de cual es el numero raw de cada una de las lineas que recibia, el
nombre de esta (solo a titulo informativo), y el mensaje estandar que la
acompa±aba.


-#- 03.3.3 Variables. -#-
-- - -- - -- - -- - -- --

        Se accede pinchando en "Tools" y luego en "Remote" (si lo prefieres,
aprieta "Alt+R") y luego pulsando sobre la solapa "Variables".
Las variables no son mas que una forma de almacenamiento de valores (datos)
temporal; podriamos decir que una variable es un area de almacenamiento en
donde podemos almacenar un valor cualquiera para que, posteriormente, podamos
utilizar dicha variable en alguna o varias rutinas, de este modo, no sera
necesario alterar la/as rutina/as cada vez que queramos modificar el valor
que queremos utilizar, sino que unicamente tendremos que asignarle el nuevo
valor deseado a dicha variable.
Las variables se representan con el signo '%' precedido de un nombre
cualquiera (p.ejemplo: %pepito)

Para comprender mejor que es y para que se usan las variables, pongamos un
peque±o ejemplo:
Imaginaos que creamos una variable llamada '%dat.name' y le asignamos el
valor 'Carlos' (es decir que quedaria de esta forma: %dat.name Carlos)
Entonces nos vamos a las Aliases (recordad: Alt+A) y creamos la siguiente
rutina:

        /nombre /echo -s Hola! mi nombre es %dat.name ┐Que tal?

Con esto conseguimos que cuando nosotros ejecutemos el alias: /nombre el mIRC
imprima en el Status el mensaje de: Hola! mi nombre es Carlos ┐Que tal? (Como
veis, mIRC a interpretado la variable %dat.name por su valor asignado
'Carlos')
Si quisieramos que dijera Pepe en vez de Carlos, no tendriamos mas que
modificar el valor de la variable %dat.name asignandole el nuevo valor
deseado Pepe

Bien, pues una vez explicado el sencillo manejo de las variables en mIRC,
vamos a explicar como controlarlas mediante sus sencillas ordenes:

        * set: Su sintaxis es: /set <%variable> [valor]
Con esta orden podremos crear/establecer variables con sus correspondientes
valores deseados. Ejemplo:

        /datos {
          set %dat.name Carlos
          set %dat.age 19
          set %dat.pais Espa±a
          echo Hola, me llamo %dat.name tengo %dat.age a±os y soy de %dat.pais
        }

Teniendo esta rutina en el aliases, lo que hacemos es que al ejecutar el
alias /datos, mIRC establezca automaticamente en la parte de variables las
variables %dat.name, %dat.age, %dat.pais con sus correspondientes datos e
imprima en pantalla el mensaje: Hola, me llamo Carlos tengo 19 a±os y soy de
Espa±a

        * unset: Su sintaxis es /unset <%variable>
Con esta orden borraremos la variable que especifiquemos de la lista de
variables. Ejemplo:

        /datos {
          set %dat.name Carlos
          set %dat.age 19
          set %dat.pais Espa±a
          echo Hola, me llamo %dat.name tengo %dat.age a±os y soy de %dat.pais
          unset %dat.name
          unset %dat.age
          unset %dat.pais
        }

Con esta rutina conseguimos la misma accion del ejemplo anterior pero esta
vez, al final de la rutina especificamos que mIRC borre las variables
%dat.name, %dat.age, %dat.pais.

Si por otra parte no quieres escribir tanto codigo y deseas borrar todas
aquellas variables que empiecen de la misma manera (como en los anteriores
ejemplos: %DAT.name, %DAT.age, %DAT.pais...) puedes hacerlo borrandolas todas
de un golpe. Esto lo conseguimos con el comodin '*'
Ejemplo:

        /datos {
          set %dat.name Carlos
          set %dat.age 19
          set %dat.pais Espa±a
          echo Hola, me llamo %dat.name tengo %dat.age a±os y soy de %dat.pais
          unset %dat.*
        }

        * unsetall: Esta orden no tiene sintaxis alguna.
Con esta orden borraremos todas las variables que tengamos establecidas en la
parte de vaiables de mIRC.
Ejemplo:

        /variables.NO {
          unsetall
          echo -s Lista de variables vacia.
        }

        * inc: Su sintaxis es /inc <%variable> [valor]
Con esta orden incrementaremos (aumentaremos) el valor de la variable que
hayamos especificado.
Ejemplo:

        /up {
          set %num 10
          set %num2 20
          inc %num %num2
          echo -a El numero resultante es: %num
        }

En este ejemplo establecemos las variables %num y %num2 con valores 10 y 20
luego, con la orden inc, a±adimos el valor de la variable %num2 al valor de
la variable %num y finalmente mIRC imprimira en la ventana activa el mensaje:
El numero resultante es: 30 (donde 30 es el resultado de a±adir el valor 20
de %num2 al valor 10 de %num --> 10+20=30)

        * dec: Su sintaxis es /dec <%variable> [valor]
Con esta orden decrementaremos (disminuiremos) el valor de la variable que
hayamos especificado. Ejemplo:

        /down {
          set %num 10
          set %num2 20
          dec %num %num2
          echo -a El numero resultante es: %num
        }

Este ejemplo es identico al anterior, solo que en vez de a±adir el valor 20
de la variable %num2 al valor 10 de la variable %num, se la resta quedando el
valor -10 (10-20=-10) finalizando con el mensaje: El numero resultante es:
-10


-#- 04.  Estructuras "IF-Else" -#-
- -- - -- - -- - -- - -- - -- - --

        He decidido explicar este tipo de estructura apartandola fuera de las
secciones aliases, popups, remotes; ya que se puede poner en cualquier
parte...
Las estrcuturas IF-Else son aquellas que plantean una o varias condicion/nes;
es decir, que unicamente se ejecutara uno o varios comandos si se cumple o no
la condicion fijada...

Su sintaxis entera es de la forma:

        if (v1 operador v2) {comandos}
        elseif (v1 operador v2) {comandos}
        else {comandos}


La orden IF hace que 'v1' se compare con 'v2' mediante algun operador (ya los
daremos mas adelante) y, a raiz de esta comparacion, ejecutara los comandos
que se le indiquen o, por el contrario interpretara la orden else efectuando
los comandos que se le indiquen... Ejemplo:

        /sonido.start {
          if (%Sonidos == On) { .splay inicio.wav }
          else { halt }
        }

Con este ejemplo queda bastante claro para que sirven estas utiles
estructuras...
En este ejemplo al ejecutar /sonido.start el script interpreta la condicion
de que Si la variable '%Sonidos' tiene asignado el valor 'On', que ejecute el
sonido 'inicio.wav'; pero por el contrario, si el valor asignado a la
variable '%Sonidos' es otro distinto de 'On', que ejecute el comando halt...

Los operadores que podremos utilizar para realizar comparaciones son:
==              : Igual que
===             : No igual que (caso-seensible)
!=              : No igual que
<               : Menor que
>               : Mayor que
>=              : Mayor o igual que
<=              : Menor o igual que
//              : Es un multiplo de
\\              : No es multiplo de
&               : Es una comparacion

isin            : Cadena v1 esta en la cadena v2
isincs          : Cadena v1 esta en la cadena v2 (caso sensible)
iswm            : Comodin de la cadena v1 contiene la cadena v2
isnum           : v1 es numero en el rango de v2 en la forma n1-n2
                  (v2 opcional)
isletter        : Letra v1 es una letra en la lista de letras de v2
                  (v2 opcional)

ison            : Nick v1 esta en canal v2
isop            : Nick v1 es un op en canal v2
isvo            : Nick v1 tiene voz en canal v2
ishelp          : Nick v1 es un helper en canal v2

isreg           : Nick v1 es un nick normal en canal v2
ischan          : Si v1 es un canal en que estas.

isauto          : Si v1 es usuario en tu lista auto-op del canal v2
                  (v2 optional)
isignore        : Si v1 esta en la lista ignore con el parametro v2
                  (v2 opcional)
isprotect       : Si v1 es usuario en tu lista protect para el canal v2
                  (v2 opcional)
isnotify        : Si v1 es usuario en tu lista notify.

Estos son todos los operadores... si queremos negar algun operador deberemos
anteponer al operador que queramos negar el simbolo ! . Ejemplo:

        /sonido.start {
          if (%Sonidos !== On) { .splay inicio.wav }
        }

Este ejemplo es igual que el anterior pero totalmente diferente, ya que esta
vez se ejecutara el sonido inicio.wav si la variable '%Sonidos' NO tiene
asignado el valor 'On'

Tambien puedes combinar varias comparaciones en una misma condicion utilizando
los operadores:

&&              : AND (En castellano Y)
||              : OR (En castellano O)

Ejemplos:

        /sonido.start {
          if (%Sonidos !== On) && (%inicio == On) { .splay inicio.wav }
        }

Como vereis en este sencillo ejemplo... unicamente se ejecutara el sonido
'inicio.wav' si se cumple que la variable '%Sonidos' tenga asignado el valor
'On' Y que la variable %inicio tenga asignado el valor 'On'. (EXIGE que se
cumplan las dos condiciones!)

        /sonido.start {
          if (%Sonidos == On) || (%inicio == On) { .splay inicio.wav }
        }

Este otro ejemplo es tambien muy simple y claro... Interpreta que si la
variable '%Sonidos' tiene asignado el valor 'On' O si la variable '%inicio'
tiene asignado el valor 'On' que ejecute el sonido 'inicio.wav' (Este no
exige que se cumplan las dos condiciones, sino que da la opcion de que se
cumpla la una o la otra...)

Para acabar con la explicacion de estrcturas IF-Else vamos a explicar la
orden 'goto' el cual es un recurso muy util y utilizado...
Su sintaxis es: goto "etiqueta"

Por si no lo sabeis 'goto' en castellano significa 'ir a' con lo que podemos
decir que esta orden se utiliza dentro de una orden IF cuando queremos "dar
un salto" de forma automatica a otra instruccion de la orden IF... este salto
es la llamada 'etiqueta' la cual se identifica con el simbolo : delante.
Ejemplo:

        /sonido.start {
          if (%Sonidos !== On) goto restaurar
          :restaurar
          set %Sonidos On
          if (%Sonidos == On) { .splay inicio.wav }
        }


-#- 05.  Consejos y recomendaciones. -#-
- -- - -- - -- - -- - -- - -- - -- -

        En esta parte del documento vamos a comentar algun que otro consejillo
para que tengais en cuenta a la hora de hacer y distribuir vustros scripts...

-#- Primer Consejo: Estructuracion de archivos y directorios del script:
        Os aconsejo que cuando os pongais a dise±ar un script, antes de
poneros a escribir codigo, os penseis una estructura de los archivos y
directorios del script...

Para vuestros archivos de aliases, popups y remotes podeis crear diversos
archivos y directorios para dividirlos...
        Por ejemplo, podeis crear un directorio llamado 'Sistema' y en el
creais tres directorios mas llamados 'Alias', 'Popups', 'Remotes' para que en
cada directorio metais los correspondientes archivos de alias, popups y
remotes...
Tambien estaria bien tener divididos en diferentes archivos los remotes,
teniendo los eventos en un archivo llamado events.ini; los ctcp┤s en un
archivo llamado ctcp.ini; los numeros RAW en un archivo llamado raw.ini; etc.

Para las utilidades externas del script (como nukes, scanners... es decir
programas independientes) podeis crear otro directorio llamado 'utils'
Para los archivos que te envien por DCC otro directorio llamdado 'Incoming'
Para los logs un directorio llamdado 'Logs'
etc... asi con toda la estructura del script...

De esta forma tendras muy bien organizado cualquier archivo del script y
quedara mucho mas presentable...

-#- Segundo Consejo: Testeando nuestro script sin conectar a inernet:
        Ya que, por el momento, no todos los usuarios de internet podemos
disponer de una tarifa plana que nos sea asequible y rentable (Ejem, EJEM!
tome nota de esto Sr.Villalonga :P), tenemos que buscar diferentes
alternativas para poder probar aquellas rutinas que hayamos hecho a nuestro
script y que requieran estar conectado a un servidor de IRC...
Una posible y muy buena solucion es montar tu propio servidor de IRC para
que, de este modo, puedas conectarte de forma local a dicho server IRC...

Existen multiples servidores de IRC para cualquier plataforma... yo te
aconsejo dos de ellos:
        - WircSrv: Este es el que mas me gusta... ya que es muy sencillo de
          utilizar; practicamente solo tendras que instalarlo en el sistema y
          ejecutarlo. En principio no requiere ninguna configuracion por tu
          parte, ya que el mismo programa trae configurado el localhost por
          defecto (127.0.0.1) y el puerto 6667... Con lo que unicamente
          deberas ejecutar WircSrv y luego conectar al servidor 127.0.0.1 por
          el puerto 6667

          Puedes bajarlo de: http://www.wircsrv.com/

        - Conference Room: Este otro programa tambien esta muy bien... aunque
          probablemente, si tienes montada una red local (LAN) puedas tener
          algun que otro problema a la hora de hacer funcionar el servidor
          (Yo tuve que configurarle un par de cosillas para que fuera
          correctamente en mi red local...)

          Puedes bajarlo de: http://www.webmaster.com/products/conferenceroom/

Existen otros muchos servidores pero estos dos son los que recomiendo para
utilizarlos en plataformas Windows...
Realmente os podreis montar un excelente y seguro servidor de IRC para
vuestros experimentos y, si quereis llegar aun mas lejos con el tema del
servidor IRC, podreis llegar a montar de forma muy simple y sencilla
servicios de IRC fuera y dentro de vuestras redes locales x)

-#- Tercer Consejo: Publicando nuestros scripts:
        A la hora de hacer publicos nuestros scripts es muy importante que
todo este listo y a punto... A continuacion os propongo un par de consejos a
la hora de depurar, empaquetar, distribuir nuestro script:

        * Una vez tengas acabado tu script, deberas de "depurarlo" es decir,
tendras que revisar todo el codigo para poder eliminar aquellas lineas que
guarden informacion sensible sobre ti, como puedan ser passwords, datos
personales...
Tambien habras de revisar los archivos del script para asi eliminar los logs,
archivos inutiles, los archivos que hayan en el directorio 'Incoming', los
archivos generados por el script como son url.ini... etc...

Ten especial cuidado y consideracion sobre las variables que, normalmente,
guardan passwords y datos que no deseas que se sepan...

        * Una vez hayas "depurado" minuciosamente tu script, deberas de
empaquetarlo en un unico archivo comprimido y deberas de hacer que ocupe lo
menos posible para que, de este modo, los usuarios que decidan descargar tu
script tarden lo menos posible...
Para el tema del espacio... te recomiendo que utilices pocos (solo los
necesarios) archivos de sonido (*.wav, *.mid...), imagenes (*.bmp), archivos
ejecutables, como nukes, scanners, flooders, mail bombers.... (es decir...
los *.exe)
Si cargas mucho el script con este tipo de ficheros... al final el tama±o de
tu script sera muy elevado, te aconsejo que no superes las 5 megas de script.

Una vez hayas cuidado el tama±o del script y hayas reducido un poco su tama±o
(si acaso era necesario) deberas de escanearlo de virus para asegurar que el
script que distribuyes esta libre de cualquier virus.. Esto es muy importante
ya que a nadie le agrada descargar de la red un script y al ejecutarlo
infectarse con algun virus... (Tambien te aconsejo que cuando bajes algo de
internet le pases un antivirus actuializado... y si alguien que no conoces te
envia algun archivo ejecutable no te fies y, por si las moscas, no lo
ejecutes... 'mas vale prevenir que curar' x)

Para la compresion del script aconsejo que utiliceis Winzip para crear un
fichero zip y, posteriormente, utilicies el WinZip Self Extractor para crear
un archivo ejecuitable.
De este modo lograreis empaquetar el script con la mejor calidad y, ya que el
archivo es un ejecutable, los usuarios no tendran porque tener algun
descompresor para archivos zip... x)

        * Finalmente tendras que poner el script al alcance de todo el mundo.
Para ello recomiendo crear una pagina web atractiva y que vaya acorde con el
dise±o del script...
No digo que hagais una web con miles de imagenes y muy pesada... sino que
hagais una pagina que tenga un par de imagenes y una buena estructura con un
par de secciones; asi como seccion de descarga del script, seccion de
caracteristicas del script, seccion de FAQ del script, una buena
presentacion...

Una vez tengais hecha una pagina web donde albergar vuestro script, debereis
de hacer una buena "Campa±a de Publicidad".
Para hacer publicidad del script os aconsejo lo siguiente:
        * Tener un par de amigos que vayan difundiendo el script... y que
          vayan atrayendo a posibles usuarios...
        * Incluir tu script en todas aquellas webs donde se puedan descargar
          scripts (es decir, webs como 100Scripts, Ayuda-Irc, Xcalibre...)
          para ello envia mails a los correspondientes webmasters
          comunicandoles el nombre y version de vuestro script, version del
          mirc, autor, web del script... y por su puesto de una forma educada
          (Nada de exigire a nadie nada x)
        * Utilizar las redes de IRC para profanar el script... Para ello
          utiliza los topics, mensajes globales, mensajes de bienvenida, de
          despedida; haz propaganda del script en canales con un elevado
          numero de usuarios (#sexo, #amor, #mas-de*, ...), entra en diversas
          redes y haz propaganda en todas ellas... (Cuidado... una cosa es
          hacer propaganda del script y otra muy distinta es acosar a los
          usuarios! Te aconsejo que seas un poco pesado, pero no te repitas
          mucho o, de lo contrario, seras expulsado del canal donde te hayas
          excedido...)


-#- 06.  Despedida. -#-
- -- - -- - -- - -- - -

        Y aqui concluyo este peque±o, aunque intenso, tutorial sobre
scripting... Ya sabeis que si teneis alguna duda me la podeis hacer saber
comunicandomela via mail, o, si lo preferis, via IRC (suelo estar en el IRC
Hispano con mi nick nEuRoNaL en canales como #@_2500Hz, #blackcode,
#cyber_punk, #hacker_novatos, #mundomovil.... por supuesto un saludo a todos
ellos! x)

Os aconsejo que si quereis aprender mas y mejor este tipo de "programacion",
os bajeis mas documentos y referencias sobre el tema...
Aqui os pongo varias direcciones de algunas webs que tienen relacion con el
tema:
    - http://www.ayuda-irc.net
    - http://100scripts.islaweb.com/
    - http://www.mirces.com
    - http://fly.to/ayuda_scripting

Espero que os haya gustado esta introduccion al maravilloso mundo del mIRC
Scripting y que, por lo menos, sepais entender la basica estructuracion y
sencilla manipulacion de uno de los clientes de IRC, para plataformas
Windows, mas populares y usados en todo el planeta!
(- Lastima que no existan versiones de mIRC para Linux :( (Todavia... ;) -)

Por ultimo agradecer a gente como SomaTic, al equipo de #Ayuda-IRC, a los
chicos de #100scripts, ... por realizar tan excelente trabajo con el cual me
he basado y me ha servido de referencia para realizar de forma completa este
tutorial...

                                              Un saludo y hasta la proxima :)

--  nEuRoNaL  -- - -- - -- - -- - -- - -- - -- @_2500Hz - Underground Scene -
- -- - -- - -- - -- - -- - -- - -- - -- - -- - -- - -- - -- - -- - -- - -- --
```

</div>
